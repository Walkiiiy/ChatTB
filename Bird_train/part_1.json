{
    "2480": {
        "db_id": "shooting",
        "question": "How many instances were found in June 2015?",
        "ground_truth": "SELECT COUNT(case_number) FROM incidents WHERE date BETWEEN '2015-06-01' AND '2015-06-30'",
        "amends": [
            "Do reference the `incidents` table instead of `instances` and use `COUNT(case_number)` instead of `COUNT(*)` to count specific case numbers rather than all rows. Do filter by a date range using `BETWEEN '2015-06-01' AND '2015-06-30'` instead of separate month and year conditions, which ensures accurate date filtering for June 2015. The amended query now correctly counts case numbers from the incidents table within the specified date range, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM instances WHERE month = 'June' AND year = 2015;",
            "SELECT COUNT(case_number) FROM incidents WHERE date BETWEEN '2015-06-01' AND '2015-06-30'"
        ],
        "rule_sql": []
    },
    "6722": {
        "db_id": "retails",
        "question": "What is the average price before discount of the top 10 orders with the highest total price?",
        "ground_truth": "SELECT SUM(T2.l_extendedprice) / 10 FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY T1.o_totalprice DESC LIMIT 10",
        "amends": [
            "Do use `SUM(T2.l_extendedprice) / 10` instead of `AVG(price)` for the aggregate calculation. Do add `INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey` instead of omitting the join to the lineitem table. Do reference `T1.o_totalprice` instead of `total_price` in the ORDER BY clause. Do include table aliases `T1` and `T2` instead of omitting them. The amended query now correctly calculates the average extended price from joined tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM orders ORDER BY total_price DESC LIMIT 10;",
            "SELECT SUM(T2.l_extendedprice) / 10 \nFROM orders AS T1\nINNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey\nORDER BY T1.o_totalprice DESC\nLIMIT 10"
        ],
        "rule_sql": []
    },
    "7587": {
        "db_id": "image_and_language",
        "question": "List all the ID of the images that have an attribute class of \"horse\".",
        "ground_truth": "SELECT T2.IMG_ID FROM ATT_CLASSES AS T1 INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T1.ATT_CLASS = 'horse'",
        "amends": [
            "Do join `ATT_CLASSES AS T1` and `IMG_OBJ_ATT AS T2` with `INNER JOIN` on `T1.ATT_CLASS_ID = T2.ATT_CLASS_ID` instead of querying only the `images` table. Do select `T2.IMG_ID` instead of `image_id` from the wrong table. Do filter on `T1.ATT_CLASS = 'horse'` instead of `attribute_class = 'horse'` using the correct table reference. The amended query now correctly joins the attribute classes with image-object-attribute mappings to find images associated with the 'horse' class, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id FROM images WHERE attribute_class = 'horse';",
            "SELECT DISTINCT T2.IMG_ID\nFROM ATT_CLASSES AS T1\nINNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID\nWHERE T1.ATT_CLASS = 'horse'"
        ],
        "rule_sql": []
    },
    "8203": {
        "db_id": "sales_in_weather",
        "question": "What is the lowest minimum temperature recorded in store 16 on January 2012?",
        "ground_truth": "SELECT MIN(tmin) FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T2.store_nbr = 16 AND T1.`date` LIKE '%2012-01%'",
        "amends": [
            "Do select `MIN(tmin)` instead of `MAX(min_temperature)` to find the minimum temperature rather than the maximum. Do use `weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr` instead of querying only `weather_data` to properly join weather and store relation tables. Do filter with `T2.store_nbr = 16` instead of `store_id = 16` to reference the correct column name from the joined table. Do use `T1.date LIKE '%2012-01%'` instead of separate `year = 2012 AND month = 1` conditions to filter for January 2012 dates using pattern matching. The amended query now correctly retrieves the minimum temperature for store 16 in January 2012 by properly joining the relevant tables and using appropriate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(min_temperature) FROM weather_data WHERE store_id = 16 AND year = 2012 AND month = 1",
            "SELECT MIN(T1.tmin) \nFROM weather AS T1 \nINNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr \nWHERE T2.store_nbr = 16 \nAND T1.date LIKE '%2012-01%'"
        ],
        "rule_sql": []
    },
    "2516": {
        "db_id": "app_store",
        "question": "What is the average sentiment polarity score of the Cooking Fever app? Indicate the age group that the app is targeted at.",
        "ground_truth": "SELECT AVG(T2.Sentiment_Polarity), T1.\"Content Rating\" FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = 'Cooking Fever'",
        "amends": [
            "Do select `AVG(T2.Sentiment_Polarity)` and `T1.\"Content Rating\"` instead of `AVG(sentiment_polarity)` as `average_sentiment` and `age_group`. Do join from `playstore AS T1 INNER JOIN user_reviews AS T2` instead of from just `apps`. Do use join condition `ON T1.App = T2.App` instead of no join condition. Do filter with `WHERE T1.App = 'Cooking Fever'` instead of `WHERE app_name = 'Cooking Fever'`. Do remove `GROUP BY age_group` instead of keeping it. The amended query now correctly joins the playstore and user_reviews tables to calculate average sentiment for the specified app."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(sentiment_polarity) as average_sentiment, age_group \nFROM apps \nWHERE app_name = 'Cooking Fever' \nGROUP BY age_group",
            "SELECT AVG(T2.Sentiment_Polarity) AS average_sentiment, T1.\"Content Rating\" AS age_group\nFROM playstore AS T1 \nINNER JOIN user_reviews AS T2 ON T1.App = T2.App\nWHERE T1.App = 'Cooking Fever'"
        ],
        "rule_sql": []
    },
    "2654": {
        "db_id": "regional_sales",
        "question": "List the order for all in-store sales along with the products sold.",
        "ground_truth": "SELECT DISTINCT T1.OrderNumber, T2.`Product Name` FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T1.`Sales Channel` = 'In-Store'",
        "amends": [
            "Do select specific columns `T1.OrderNumber` and `T2.Product Name` instead of using `*` to select all columns. Do add table aliases `T1` and `T2` instead of omitting them. Do change the source table from `orders` to `Sales Orders AS T1` instead of the original table name. Do add an `INNER JOIN` with `Products AS T2` on `T2.ProductID = T1._ProductID` instead of having no join. Do change the filter condition to `T1.Sales Channel = 'In-Store'` instead of `sale_type = 'online'`. Do add `DISTINCT` to eliminate duplicate rows instead of returning all matching rows. The amended query now correctly filters for in-store sales with proper table joins and specific column selection."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM orders WHERE sale_type = 'online';",
            "SELECT DISTINCT T1.OrderNumber, T2.\"Product Name\"\nFROM \"Sales Orders\" AS T1\nINNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE T1.\"Sales Channel\" = 'In-Store'"
        ],
        "rule_sql": []
    },
    "6144": {
        "db_id": "food_inspection_2",
        "question": "How many employees are under Gregory Cardenas?",
        "ground_truth": "SELECT COUNT(T1.employee_id) FROM employee AS T1 WHERE T1.supervisor = ( SELECT employee_id FROM employee WHERE first_name = 'Gregory' AND last_name = 'Cardenas' )",
        "amends": [
            "Do reference the table as `employee` with alias `T1` instead of `employees` without an alias. Do select `COUNT(T1.employee_id)` instead of `COUNT(*)` to count specific employee records. Do use the column `T1.supervisor` instead of `manager_id` for the filter condition. The amended query now correctly counts employees supervised by Gregory Cardenas using the proper table name, column references, and specific count aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE manager_id = (SELECT employee_id FROM employees WHERE first_name = 'Gregory' AND last_name = 'Cardenas');",
            "SELECT COUNT(T1.employee_id) \nFROM employee T1 \nINNER JOIN employee T2 ON T1.supervisor = T2.employee_id \nWHERE T2.first_name = 'Gregory' AND T2.last_name = 'Cardenas'"
        ],
        "rule_sql": []
    },
    "3021": {
        "db_id": "shakespeare",
        "question": "How many chapters include the character name \"First Witch\"?",
        "ground_truth": "SELECT COUNT(T2.chapter_id) FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T1.CharName = 'First Witch'",
        "amends": [
            "Do `SELECT COUNT(T2.chapter_id)` instead of `SELECT COUNT(*)` to count specific chapter occurrences rather than all rows. Do add `FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id` instead of just `FROM characters` to join with the paragraphs table and establish the character-paragraph relationship. Do use `WHERE T1.CharName = 'First Witch'` instead of `WHERE name = 'First Witch'` to reference the correct column name for character names. The amended query now correctly counts chapter appearances for the specified character by joining related tables and using proper column references, matching the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the query should count all chapter_id occurrences rather than distinct values for the specified character. The amended query now matches RIGHT_SQL's behavior by returning the total count of chapter_id values associated with 'First Witch' rather than counting distinct chapter_ids."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM characters WHERE name = 'First Witch';",
            "SELECT COUNT(DISTINCT T2.chapter_id) FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T1.CharName = 'First Witch'",
            "SELECT COUNT(T2.chapter_id) FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T1.CharName = 'First Witch'"
        ],
        "rule_sql": []
    },
    "2316": {
        "db_id": "movielens",
        "question": "What is the disparate number of the comedy films that got the 1 rating?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.movieid) FROM movies2directors AS T1 INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid WHERE T2.rating = 1 AND T1.genre = 'comedy'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.movieid)` instead of `COUNT(*)` to count unique movies. Do join `movies2directors AS T1` and `u2base AS T2` with `INNER JOIN` on `T1.movieid = T2.movieid` instead of querying a single `films` table. Do filter on `T2.rating = 1` and `T1.genre = 'comedy'` instead of `genre = 'comedy' AND rating = 1` from a single table. Do add table aliases `T1` and `T2` instead of omitting them. The amended query now correctly counts distinct comedy movies with rating 1 by joining the appropriate tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE genre = 'comedy' AND rating = 1;",
            "SELECT COUNT(DISTINCT T1.movieid) \nFROM movies2directors AS T1 \nINNER JOIN u2base AS T2 ON T1.movieid = T2.movieid \nWHERE T1.genre = 'comedy' AND T2.rating = '1'"
        ],
        "rule_sql": []
    },
    "4583": {
        "db_id": "mental_health_survey",
        "question": "What is the oldest age of the users in 2014's survey?",
        "ground_truth": "SELECT T2.AnswerText FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T1.questiontext = 'What is your age?' AND T2.SurveyID = 2014 ORDER BY T2.AnswerText DESC LIMIT 1",
        "amends": [
            "Do select `T2.AnswerText` instead of `MAX(age)` and do add `FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID` instead of `FROM users` with proper join conditions. Do change the WHERE clause to `T1.questiontext = 'What is your age?' AND T2.SurveyID = 2014` instead of `survey_year = 2014` to filter by question text and survey ID. Do add `ORDER BY T2.AnswerText DESC LIMIT 1` instead of omitting ordering and limiting, and do remove the aggregate function MAX() since the limit approach achieves the same maximum value retrieval. The amended query now correctly retrieves the maximum age answer from the appropriate survey by joining the Question and Answer tables with proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(age) FROM users WHERE survey_year = 2014;",
            "SELECT T2.AnswerText \nFROM Question AS T1 \nINNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID \nWHERE T1.questiontext = 'What is your age?' AND T2.SurveyID = 2014 \nORDER BY T2.AnswerText DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1374": {
        "db_id": "synthea",
        "question": "How many care plans has Mrs. Norman Berge taken?",
        "ground_truth": "SELECT COUNT(T2.PATIENT) FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mrs.' AND T1.first = 'Norman' AND T1.last = 'Berge'",
        "amends": [
            "Do join `patients AS T1` with `careplans AS T2` on `T1.patient = T2.PATIENT` instead of querying only `care_plans` without any join. Do filter on `T1.prefix = 'Mrs.' AND T1.first = 'Norman' AND T1.last = 'Berge'` instead of filtering directly on `patient_name = 'Mrs. Norman Berge'` in the care_plans table. Do count `T2.PATIENT` instead of counting all rows with `COUNT(*)`. The amended query now correctly joins patient information with care plans and matches the intended behavior by properly filtering on normalized patient name components rather than a concatenated string."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM care_plans WHERE patient_name = 'Mrs. Norman Berge';",
            "SELECT COUNT(T2.PATIENT) \nFROM patients AS T1 \nJOIN careplans AS T2 ON T1.patient = T2.PATIENT \nWHERE T1.prefix = 'Mrs.' AND T1.first = 'Norman' AND T1.last = 'Berge'"
        ],
        "rule_sql": []
    },
    "6983": {
        "db_id": "ice_hockey_draft",
        "question": "Calculate the average weight in pounds of all players drafted by Arizona Coyotes.",
        "ground_truth": "SELECT CAST(SUM(T1.weight_in_lbs) AS REAL) / COUNT(T2.ELITEID) FROM weight_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE T2.overallby = 'Arizona Coyotes'",
        "amends": [
            "Do use `CAST(SUM(T1.weight_in_lbs) AS REAL) / COUNT(T2.ELITEID)` instead of `AVG(weight)` to calculate the weighted average with proper casting. Do join `weight_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight` instead of querying a single `players` table. Do filter on `T2.overallby = 'Arizona Coyotes'` instead of `team = 'Arizona Coyotes'` to use the correct column name from the joined table. The amended query now correctly calculates the average weight by joining the necessary tables and using the proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weight) FROM players WHERE team = 'Arizona Coyotes';",
            "SELECT CAST(SUM(T1.weight_in_lbs) AS REAL) / COUNT(T2.ELITEID) AS average_weight_lbs\nFROM weight_info AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight\nWHERE T2.overallby = 'Arizona Coyotes'"
        ],
        "rule_sql": []
    },
    "2037": {
        "db_id": "soccer_2016",
        "question": "What is the total number of players born between 1970 to 1975?",
        "ground_truth": "SELECT COUNT(Player_Id) FROM Player WHERE strftime('%Y', DOB) BETWEEN '1970' AND '1975'",
        "amends": [
            "Do use `COUNT(Player_Id)` instead of `COUNT(*)` to count specific non-null values. Do reference table `Player` instead of `players` to use the correct table name. Do use column `DOB` with `strftime('%Y', DOB)` instead of `birth_year` to properly extract the year from a date field. Do filter with years `'1970'` and `'1975'` instead of `1975` and `1980` to capture the correct birth year range. The amended query now correctly counts players born between 1970 and 1975 using proper date handling and table/column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE birth_year BETWEEN 1975 AND 1980;",
            "SELECT COUNT(Player_Id) FROM Player WHERE strftime('%Y', DOB) BETWEEN '1970' AND '1975'"
        ],
        "rule_sql": []
    },
    "5715": {
        "db_id": "language_corpus",
        "question": "State one biword pair with occurence of 4.",
        "ground_truth": "SELECT T1.word, T3.word FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd WHERE T2.occurrences = 4 LIMIT 1",
        "amends": [
            "Do select `T1.word` and `T3.word` instead of `biword` and `COUNT(*) as occurrence`. Do use `FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd` instead of `FROM biword_table`. Do filter with `T2.occurrences = 4` instead of `occurrence = 4`. Do remove the aggregate `COUNT(*)` instead of keeping it. The amended query now correctly retrieves word pairs from the normalized schema instead of counting occurrences from a denormalized table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT biword, COUNT(*) as occurrence FROM biword_table WHERE occurrence = 4 LIMIT 1;",
            "SELECT T1.word, T3.word\nFROM words AS T1 \nINNER JOIN biwords AS T2 ON T1.wid = T2.w1st \nINNER JOIN words AS T3 ON T3.wid = T2.w2nd\nWHERE T2.occurrences = 4\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3258": {
        "db_id": "donor",
        "question": "What are the coordinates of the school where project 'Look, Look, We Need a Nook!' Was donated to and what resource type is it?",
        "ground_truth": "SELECT T2.school_latitude, T2.school_longitude, T2.resource_type FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.title LIKE 'Look, Look, We Need a Nook!'",
        "amends": [
            "Do select `T2.school_latitude` and `T2.school_longitude` instead of `school.latitude` and `school.longitude`. Do use `essays AS T1` and `projects AS T2` as FROM sources instead of `school`, `project`, and `resource` tables. Do perform `INNER JOIN` between `T1` and `T2` on `T1.projectid = T2.projectid` instead of joining `school` to `project` and then to `resource`. Do filter with `T1.title LIKE 'Look, Look, We Need a Nook!'` instead of `project.project_name = 'Look, Look, We Need a Nook!'`. Do remove the unnecessary `resource.resource_type` column reference and instead select `T2.resource_type` directly from the projects table. The amended query now correctly retrieves school coordinates and resource type by joining essays to projects using the appropriate relationship and filtering on essay title rather than project name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school.latitude, school.longitude, resource.resource_type \nFROM school \nJOIN project ON school.school_id = project.school_id \nJOIN resource ON project.resource_id = resource.resource_id \nWHERE project.project_name = 'Look, Look, We Need a Nook!'",
            "SELECT T2.school_latitude, T2.school_longitude, T2.resource_type\nFROM essays AS T1\nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid\nWHERE T1.title = 'Look, Look, We Need a Nook!'"
        ],
        "rule_sql": []
    },
    "8536": {
        "db_id": "software_company",
        "question": "Give the level of education and occupation of customers ages from 20 to 35 with an income K of 2000 and below.",
        "ground_truth": "SELECT T1.EDUCATIONNUM, T1.OCCUPATION FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T2.INCOME_K < 2000 AND T1.age >= 20 AND T1.age <= 35",
        "amends": [
            "Do select `EDUCATIONNUM` and `OCCUPATION` instead of `education` and `occupation`. Do use `Customers AS T1` joined with `Demog AS T2` on `T1.GEOID = T2.GEOID` instead of querying only the `customers` table. Do filter on `T2.INCOME_K < 2000` instead of `income <= 2000`. Do filter on `T1.age >= 20 AND T1.age <= 35` instead of `age BETWEEN 20 AND 35`. The amended query now correctly joins demographic data and filters based on the appropriate income field from the joined table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT education, occupation FROM customers WHERE age BETWEEN 20 AND 35 AND income <= 2000;",
            "SELECT T1.EDUCATIONNUM, T1.OCCUPATION\nFROM Customers AS T1\nJOIN Demog AS T2 ON T1.GEOID = T2.GEOID\nWHERE T1.age >= 20 AND T1.age <= 35\nAND T2.INCOME_K <= 2000"
        ],
        "rule_sql": []
    },
    "9314": {
        "db_id": "movie_3",
        "question": "Who is the customer with the largest payment for rental films?",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T1.first_name, T1.last_name, SUM(T2.amount) AS num FROM customer AS T1 INNER JOIN payment AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.first_name, T1.last_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T2.amount)` instead of `MAX(p.amount)` for calculating the total payment amount. Do group by `T1.first_name, T1.last_name` instead of `c.customer_id` to ensure proper aggregation by customer name. Do wrap the aggregated query in a subquery `T` instead of querying directly, allowing cleaner ordering. Do order by the alias `T.num` instead of repeating the aggregate function `MAX(p.amount)`. The amended query now correctly calculates total payment amounts per customer and matches RIGHT_SQL's behavior.",
            "Do remove `T.total_amount` from the SELECT list instead of including it, as the outer query only needs the customer names. Do use `T1` and `T2` as table aliases in the subquery instead of `c` and `p` for consistency. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. Do rename the aggregate column alias to `num` instead of `total_amount` in the subquery. Do reference `T.num` in the ORDER BY clause instead of `T.total_amount` to match the new alias. The amended query now correctly returns only the customer names while maintaining the same ranking logic based on payment totals."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name, MAX(p.amount) \nFROM customer c \nJOIN payment p ON c.customer_id = p.customer_id \nGROUP BY c.customer_id \nORDER BY MAX(p.amount) DESC \nLIMIT 1;",
            "SELECT T.first_name, T.last_name, T.total_amount\nFROM (\n    SELECT c.first_name, c.last_name, SUM(p.amount) AS total_amount\n    FROM customer c\n    JOIN payment p ON c.customer_id = p.customer_id\n    GROUP BY c.first_name, c.last_name\n) T\nORDER BY T.total_amount DESC\nLIMIT 1;",
            "SELECT T.first_name, T.last_name\nFROM (\n    SELECT T1.first_name, T1.last_name, SUM(T2.amount) AS num\n    FROM customer T1\n    INNER JOIN payment T2 ON T1.customer_id = T2.customer_id\n    GROUP BY T1.first_name, T1.last_name\n) T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1175": {
        "db_id": "talkingdata",
        "question": "How many OPPO users participated in events which were held around 12 AM on 1st May,2016?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' AND STRFTIME('%Y-%m-%d', T1.`timestamp`) = '2016-05-01'",
        "amends": [
            "Do count `T1.device_id` instead of `*` and use `events` as `T1` instead of `users` as the primary table. Do join `phone_brand_device_model2` as `T2` instead of `users` and use `INNER JOIN` on `T1.device_id = T2.device_id` instead of joining `events` to `users` on `user_id`. Do filter on `T2.phone_brand = 'OPPO'` instead of `u.brand = 'OPPO'` and use `STRFTIME('%Y-%m-%d', T1.timestamp) = '2016-05-01'` for date comparison instead of exact `event_time` timestamp matching. The amended query now correctly counts OPPO devices from events on the specified date.",
            "Do remove the time filter `STRFTIME('%H:%M', T1.timestamp) LIKE '00:%'` instead of keeping it, as the right query only filters by date without restricting to midnight hours. Do use backticks for the timestamp column `T1.timestamp` instead of unquoted timestamp to handle potential reserved keyword conflicts. The amended query now correctly counts OPPO device events from May 1, 2016 without the unnecessary time restriction, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users u JOIN events e ON u.user_id = e.user_id WHERE u.brand = 'OPPO' AND e.event_time = '2016-05-01 12:00:00';",
            "SELECT COUNT(T1.device_id) \nFROM events T1\nINNER JOIN phone_brand_device_model2 T2 ON T1.device_id = T2.device_id\nWHERE T2.phone_brand = 'OPPO'\nAND STRFTIME('%Y-%m-%d', T1.timestamp) = '2016-05-01'\nAND STRFTIME('%H:%M', T1.timestamp) LIKE '00:%'",
            "SELECT COUNT(T1.device_id) \nFROM events T1\nINNER JOIN phone_brand_device_model2 T2 ON T1.device_id = T2.device_id\nWHERE T2.phone_brand = 'OPPO'\nAND STRFTIME('%Y-%m-%d', T1.timestamp) = '2016-05-01'"
        ],
        "rule_sql": []
    },
    "1907": {
        "db_id": "soccer_2016",
        "question": "List the name and country of the players who got more than average catches in ascending order of the number of catches.",
        "ground_truth": "SELECT T1.Player_Name, T4.Country_Name FROM Player AS T1 INNER JOIN Wicket_Taken AS T2 ON T1.Player_Id = T2.Fielders INNER JOIN Out_Type AS T3 ON T2.Kind_Out = T3.Out_Id INNER JOIN Country AS T4 ON T1.Country_Name = T4.Country_Id GROUP BY T1.Player_Name ORDER BY COUNT(T3.Out_Name) ASC",
        "amends": [
            "Do use explicit table aliases `T1.Player_Name` and `T4.Country_Name` instead of generic column names `name` and `country`. Do join multiple tables including `Player AS T1`, `Wicket_Taken AS T2`, `Out_Type AS T3`, and `Country AS T4` instead of querying only the `players` table. Do specify `INNER JOIN` conditions with proper foreign key relationships like `T1.Player_Id = T2.Fielders` and `T1.Country_Name = T4.Country_Id` instead of no joins. Do add a `GROUP BY T1.Player_Name` clause instead of omitting grouping. Do aggregate with `COUNT(T3.Out_Name)` instead of filtering on `catches > AVG(catches)`. Do order by the aggregate count in `ASC` order instead of ordering by `catches DESC`. Do remove the subquery and WHERE filter entirely instead of keeping them. The amended query now correctly calculates wicket counts by player with proper table relationships instead of using a simple average filter on catches.",
            "Do remove the `WHERE T3.Out_Name = 'caught'` filter instead of keeping it, as the filtering is handled through the join conditions. Do change the `GROUP BY` clause to include only `T1.Player_Name` instead of both `T1.Player_Name` and `T4.Country_Name`, since `T4.Country_Name` is functionally dependent on the player. Do remove the entire `HAVING` clause with its subquery instead of keeping the complex average comparison, as the requirement changed to simply ordering by catch count. Do change the `ORDER BY` clause to use `COUNT(T3.Out_Name)` instead of `COUNT(*)` for more explicit counting of caught wickets. The amended query now correctly focuses on counting caught wickets per player and ordering by that count without unnecessary filtering and grouping complexity.",
            "Do remove `T4.Country_Name` from the GROUP BY clause instead of including it, as the aggregation is performed by player only. Do keep the same SELECT list, FROM sources with INNER JOINs on `T1.Player_Id = T2.Fielders`, `T2.Kind_Out = T3.Out_Id`, and `T1.Country_Name = T4.Country_Id`, and ORDER BY `COUNT(T3.Out_Name)` ASC as originally specified. Do remove the WHERE filter `T3.Out_Name = 'caught'` instead of keeping it, allowing all out types to be counted rather than filtering for only caught dismissals. The amended query now correctly counts all types of dismissals by fielders rather than restricting to caught dismissals only, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, country, catches FROM players WHERE catches > (SELECT AVG(catches) FROM players) ORDER BY catches DESC;",
            "SELECT T1.Player_Name, T4.Country_Name\nFROM Player AS T1\nINNER JOIN Wicket_Taken AS T2 ON T1.Player_Id = T2.Fielders\nINNER JOIN Out_Type AS T3 ON T2.Kind_Out = T3.Out_Id\nINNER JOIN Country AS T4 ON T1.Country_Name = T4.Country_Id\nWHERE T3.Out_Name = 'caught'\nGROUP BY T1.Player_Name, T4.Country_Name\nHAVING COUNT(*) > (\n    SELECT AVG(catch_count)\n    FROM (\n        SELECT COUNT(*) AS catch_count\n        FROM Wicket_Taken AS wt\n        INNER JOIN Out_Type AS ot ON wt.Kind_Out = ot.Out_Id\n        WHERE ot.Out_Name = 'caught'\n        GROUP BY wt.Fielders\n    )\n)\nORDER BY COUNT(*) ASC;",
            "SELECT T1.Player_Name, T4.Country_Name\nFROM Player AS T1\nINNER JOIN Wicket_Taken AS T2 ON T1.Player_Id = T2.Fielders\nINNER JOIN Out_Type AS T3 ON T2.Kind_Out = T3.Out_Id\nINNER JOIN Country AS T4 ON T1.Country_Name = T4.Country_Id\nWHERE T3.Out_Name = 'caught'\nGROUP BY T1.Player_Name, T4.Country_Name\nORDER BY COUNT(T3.Out_Name) ASC;",
            "SELECT T1.Player_Name, T4.Country_Name\nFROM Player AS T1\nINNER JOIN Wicket_Taken AS T2 ON T1.Player_Id = T2.Fielders\nINNER JOIN Out_Type AS T3 ON T2.Kind_Out = T3.Out_Id\nINNER JOIN Country AS T4 ON T1.Country_Name = T4.Country_Id\nGROUP BY T1.Player_Name\nORDER BY COUNT(T3.Out_Name) ASC;"
        ],
        "rule_sql": []
    },
    "2832": {
        "db_id": "professional_basketball",
        "question": "What is the average weight of the players who have won the award of Rookie of the year?",
        "ground_truth": "SELECT AVG(T1.weight) FROM players AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE T2.award = 'Rookie of the Year'",
        "amends": [
            "Do add `INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID` instead of querying only the `players` table. Do reference `T1.weight` instead of just `weight` for explicit table qualification. Do move the filter condition to `T2.award = 'Rookie of the Year'` instead of `players.award` since the award information correctly resides in the joined awards_players table. Do use proper case sensitivity with 'Rookie of the Year' instead of 'Rookie of the year'. The amended query now correctly calculates average weight only for players who have received the specific award by joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weight) FROM players WHERE award = 'Rookie of the year';",
            "SELECT AVG(T1.weight) AS average_weight\nFROM players AS T1\nINNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID\nWHERE T2.award = 'Rookie of the Year';"
        ],
        "rule_sql": []
    },
    "4969": {
        "db_id": "olympics",
        "question": "Calculate the percentage of women who have participated in Equestrianism Mixed Three-Day Event, Individual.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.gender = 'F' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN event AS T4 ON T3.event_id = T4.id WHERE T4.event_name = 'Equestrianism Mixed Three-Day Event, Individual'",
        "amends": [
            "Do use `CAST` to convert the count to `REAL` instead of implicit conversion. Do reference `gender` from the person table instead of `Gender` from an undefined table. Do use `ELSE NULL` in the `CASE` expression instead of omitting the `ELSE` clause. Do count `id` from the person table instead of using `COUNT(*)`. Do join `person` as `T1` instead of `Athletes a`. Do join `games_competitor` as `T2` on `T1.id = T2.person_id` instead of an undefined join. Do join `competitor_event` as `T3` on `T2.id = T3.competitor_id` instead of joining `Results` on `AthleteID`. Do join `event` as `T4` on `T3.event_id = T4.id` instead of joining `Events` on `EventID`. Do filter on `event_name` from the event table instead of `EventName` from an undefined table. The amended query now correctly calculates the percentage of women participants for the specified event using the proper schema relationships.",
            "Do use `CASE WHEN T1.gender = 'F' THEN 1 ELSE NULL END` instead of `CASE WHEN T1.gender = 'F' THEN T1.id ELSE NULL END` for the count condition. Do place the multiplication by 100 before division instead of after it in the percentage calculation. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for all table joins. Do remove the column alias `percentage_women` instead of keeping it. Do remove the unnecessary parentheses around the entire percentage calculation instead of including them. The amended query now correctly calculates the percentage of women participants by using a simpler case expression and proper mathematical order of operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN g.Gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM \n    Athletes a\nJOIN \n    Results r ON a.AthleteID = r.AthleteID\nJOIN \n    Events e ON r.EventID = e.EventID\nWHERE \n    e.EventName = 'Equestrianism Mixed Three-Day Event, Individual';",
            "SELECT \n    (CAST(COUNT(CASE WHEN T1.gender = 'F' THEN T1.id ELSE NULL END) AS REAL) / COUNT(T1.id)) * 100.0 AS percentage_women\nFROM \n    person T1\nJOIN \n    games_competitor T2 ON T1.id = T2.person_id\nJOIN \n    competitor_event T3 ON T2.id = T3.competitor_id\nJOIN \n    event T4 ON T3.event_id = T4.id\nWHERE \n    T4.event_name = 'Equestrianism Mixed Three-Day Event, Individual';",
            "SELECT \n    (COUNT(CASE WHEN T1.gender = 'F' THEN 1 ELSE NULL END) * 100.0 / COUNT(T1.id)) \nFROM \n    person T1\n    INNER JOIN games_competitor T2 ON T1.id = T2.person_id\n    INNER JOIN competitor_event T3 ON T2.id = T3.competitor_id\n    INNER JOIN event T4 ON T3.event_id = T4.id\nWHERE \n    T4.event_name = 'Equestrianism Mixed Three-Day Event, Individual';"
        ],
        "rule_sql": []
    },
    "7694": {
        "db_id": "hockey",
        "question": "For the goalie who had the most shutouts in 2010, what's his catching hand?",
        "ground_truth": "SELECT T1.shootCatch FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 2010 GROUP BY T2.playerID ORDER BY SUM(T2.SHO) DESC LIMIT 1",
        "amends": [
            "Do select `shootCatch` from the `Master` table instead of `catching_hand` from `goalies`. Do join `Master` and `Goalies` tables with `INNER JOIN` on `playerID` instead of querying only the `goalies` table. Do filter on `year = 2010` from the `Goalies` table instead of directly from the original table. Do add `GROUP BY playerID` to aggregate by individual players instead of no grouping. Do order by `SUM(SHO)` descending instead of `shutouts` descending to properly aggregate shutout totals per player. The amended query now correctly retrieves the shooting/catch hand from the master player table while properly aggregating shutout statistics by player for the specified year, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT catching_hand \nFROM goalies \nWHERE year = 2010 \nORDER BY shutouts DESC \nLIMIT 1;",
            "SELECT m.shootCatch\nFROM Master m\nINNER JOIN Goalies g ON m.playerID = g.playerID\nWHERE g.year = 2010\nGROUP BY m.playerID\nORDER BY SUM(CAST(g.SHO AS INTEGER)) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6829": {
        "db_id": "retails",
        "question": "What is the account balance of the supplier with the most parts?",
        "ground_truth": "SELECT T.s_acctbal FROM ( SELECT T1.s_acctbal, COUNT(T2.ps_suppkey) AS num FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey GROUP BY T1.s_suppkey ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do add a subquery with `T1.s_acctbal` and `COUNT(T2.ps_suppkey) AS num` instead of directly selecting `s_acctbal` without aggregation context. Do join `supplier AS T1` with `partsupp AS T2` using `INNER JOIN` on `T1.s_suppkey = T2.ps_suppkey` instead of querying `supplier` alone without any join. Do add `GROUP BY T1.s_suppkey` to aggregate by supplier key instead of missing proper grouping. Do order by the computed count alias `T.num` instead of directly ordering by `COUNT(p_partkey)` which references an incorrect column. Do reference the subquery result `T.s_acctbal` instead of the base table column directly. The amended query now correctly calculates each supplier's part count and returns the account balance of the supplier with the highest count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s_acctbal FROM supplier ORDER BY COUNT(p_partkey) DESC LIMIT 1;",
            "SELECT T.s_acctbal\nFROM (\n    SELECT T1.s_acctbal, COUNT(T2.ps_suppkey) AS num\n    FROM supplier AS T1\n    INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey\n    GROUP BY T1.s_suppkey\n) AS T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4756": {
        "db_id": "legislator",
        "question": "How many males were members of the current legislators?",
        "ground_truth": "SELECT COUNT(*) FROM current WHERE gender_bio = 'M'",
        "amends": [
            "Do reference table `current` instead of `legislators` and use column `gender_bio` with value 'M' instead of `gender` with value 'male`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE gender = 'male';",
            "SELECT COUNT(*) FROM current WHERE gender_bio = 'M'"
        ],
        "rule_sql": []
    },
    "1736": {
        "db_id": "restaurant",
        "question": "How many streets with restaurants are there in the Northern California region?",
        "ground_truth": "SELECT COUNT(T1.city) FROM geographic AS T1 INNER JOIN location AS T2 ON T1.city = T2.city WHERE T1.region = 'northern california'",
        "amends": [
            "Do select `COUNT(T1.city)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do use tables `geographic AS T1` and `location AS T2` with an `INNER JOIN` on `T1.city = T2.city` instead of querying only the `streets` table. Do filter on `T1.region = 'northern california'` with lowercase spelling instead of `region = 'Northern California'` with title case. Do remove the `has_restaurant = 'yes'` filter instead of keeping it, as the correct logic focuses solely on the region condition. The amended query now correctly counts cities in the northern california region from joined geographic and location data, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM streets WHERE region = 'Northern California' AND has_restaurant = 'yes';",
            "SELECT COUNT(T2.city) \nFROM geographic AS T1 \nINNER JOIN location AS T2 ON T1.city = T2.city \nWHERE T1.region = 'northern california'"
        ],
        "rule_sql": []
    },
    "3289": {
        "db_id": "donor",
        "question": "How many total items were requested for the Onslow Co School District urban metro school projects?",
        "ground_truth": "SELECT SUM(T1.item_quantity) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_metro = 'urban' AND T2.school_district = 'Onslow Co School District'",
        "amends": [
            "Do select `SUM(T1.item_quantity)` instead of `COUNT(*)` to sum quantities rather than count rows. Do change the FROM source to `resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid` instead of just `requests` to join two tables on the project ID relationship. Do move the district filter to `T2.school_district = 'Onslow Co School District'` instead of `district = 'Onslow Co School District'` to reference the correct table column. Do change the metro filter to `T2.school_metro = 'urban'` instead of `school_type = 'urban metro'` to use the proper column name and value format. The amended query now correctly aggregates resource quantities for projects in the specified district and metro type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM requests WHERE district = 'Onslow Co School District' AND school_type = 'urban metro'",
            "SELECT SUM(T1.item_quantity) \nFROM resources AS T1 \nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid \nWHERE T2.school_district = 'Onslow Co School District' \nAND T2.school_metro = 'urban'"
        ],
        "rule_sql": []
    },
    "2322": {
        "db_id": "movielens",
        "question": "Please give the ids of the oldest films that got the most ratings.",
        "ground_truth": "SELECT DISTINCT T1.movieid FROM u2base AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T1.rating = 5 AND T2.year = 1",
        "amends": [
            "Do select `DISTINCT T1.movieid` instead of `film_id` without distinct. Do use `FROM u2base AS T1 INNER JOIN movies AS T2` instead of `FROM ratings` alone. Do add join condition `ON T1.movieid = T2.movieid` instead of omitting it. Do add WHERE filters `T1.rating = 5 AND T2.year = 1` instead of having no filters. Do remove `ORDER BY rating DESC, release_year ASC LIMIT 1` instead of keeping ordering and limiting. The amended query now correctly finds distinct movie IDs with rating 5 from year 1 instead of just the highest rated film."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT film_id FROM ratings ORDER BY rating DESC, release_year ASC LIMIT 1;",
            "SELECT DISTINCT T1.movieid\nFROM u2base AS T1\nINNER JOIN movies AS T2 ON T1.movieid = T2.movieid\nWHERE T1.rating = '5' AND T2.year = 1"
        ],
        "rule_sql": []
    },
    "5387": {
        "db_id": "sales",
        "question": "Calculate the total price of products purchased by Adam.",
        "ground_truth": "SELECT SUM(T3.Price * T2.quantity) FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T1.FirstName = 'Adam'",
        "amends": [
            "Do join `Customers AS T1` and `Sales AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying only the products table. Do join `Products AS T3` on `T2.ProductID = T3.ProductID` instead of missing the sales relationship. Do calculate `SUM(T3.Price * T2.quantity)` instead of `SUM(price)` to account for quantity sold. Do filter on `T1.FirstName = 'Adam'` instead of `customer_name = 'Adam'` to use the correct customer identifier. The amended query now correctly calculates total sales value for customer Adam by joining the necessary tables and accounting for purchase quantities."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM products WHERE customer_name = 'Adam';",
            "SELECT SUM(T3.Price * T2.Quantity) AS TotalPrice\nFROM Customers AS T1\nJOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nJOIN Products AS T3 ON T2.ProductID = T3.ProductID\nWHERE T1.FirstName = 'Adam'"
        ],
        "rule_sql": []
    },
    "2628": {
        "db_id": "regional_sales",
        "question": "Which product has the highest net profit in 2019?",
        "ground_truth": "SELECT T2.`Product Name` FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T1.OrderDate LIKE '%/%/19' ORDER BY REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '') DESC LIMIT 1",
        "amends": [
            "Do reference `T2.Product Name` instead of `product_name` and calculate profit as `REPLACE(Unit Price, ',', '') - REPLACE(Unit Cost, ',', '')` instead of `SUM(revenue - cost)`. Do join `Sales Orders` AS T1 with `Products` AS T2 on `T2.ProductID = T1._ProductID` instead of querying a single table. Do filter with `OrderDate LIKE '%/%/19'` instead of `year = 2019`. Do remove `GROUP BY` and aggregation instead of keeping them. Do order by the calculated profit expression directly instead of using an alias. Do maintain `LIMIT 1` and `DESC` ordering. The amended query now correctly joins tables, handles formatted numeric values, filters by date pattern, and calculates individual order profits to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, SUM(revenue - cost) as net_profit FROM sales WHERE year = 2019 GROUP BY product_name ORDER BY net_profit DESC LIMIT 1;",
            "SELECT T2.\"Product Name\"\nFROM \"Sales Orders\" AS T1\nJOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE T1.OrderDate LIKE '%/%/19'\nORDER BY (REPLACE(T1.\"Unit Price\", ',', '') - REPLACE(T1.\"Unit Cost\", ',', '')) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3665": {
        "db_id": "authors",
        "question": "Indicate the year and a full name of the journal in which the publication named 'Area Effects in Cepaea' was published.",
        "ground_truth": "SELECT T1.Year, T2.FullName FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE T1.Title = 'Area Effects in Cepaea'",
        "amends": [
            "Do select `T1.Year` and `T2.FullName` instead of `year` and `journal_name`. Do join `Paper AS T1` with `Journal AS T2` using `INNER JOIN` on `T1.JournalId = T2.Id` instead of querying only the `publications` table. Do filter on `T1.Title = 'Area Effects in Cepaea'` instead of filtering on `title` from a single table. The amended query now correctly joins the Paper and Journal tables to retrieve the year and full journal name for the specified paper title, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, journal_name FROM publications WHERE title = 'Area Effects in Cepaea';",
            "SELECT T1.Year, T2.FullName \nFROM Paper AS T1 \nINNER JOIN Journal AS T2 ON T1.JournalId = T2.Id \nWHERE T1.Title = 'Area Effects in Cepaea'"
        ],
        "rule_sql": []
    },
    "2624": {
        "db_id": "regional_sales",
        "question": "Please list the id and detailed position of all stores in Birmingham city.",
        "ground_truth": "SELECT StoreID, Latitude, Longitude FROM `Store Locations` WHERE `City Name` = 'Birmingham'",
        "amends": [
            "Do select `StoreID`, `Latitude`, and `Longitude` instead of `id` and `position`. Do use table `Store Locations` instead of `stores`. Do filter on column `City Name` instead of `city`. The amended query now correctly retrieves store location coordinates from the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, position FROM stores WHERE city = 'Birmingham';",
            "SELECT StoreID, Latitude, Longitude FROM \"Store Locations\" WHERE \"City Name\" = 'Birmingham';"
        ],
        "rule_sql": []
    },
    "6963": {
        "db_id": "ice_hockey_draft",
        "question": "Mention the type of game that Matthias Trattnig played.",
        "ground_truth": "SELECT DISTINCT T1.GAMETYPE FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Matthias Trattnig'",
        "amends": [
            "Do select `DISTINCT T1.GAMETYPE` instead of `game_type` without distinct. Do use `SeasonStatus AS T1` and `PlayerInfo AS T2` as source tables instead of only `players`. Do add `INNER JOIN` on `T1.ELITEID = T2.ELITEID` instead of no join condition. Do filter on `T2.PlayerName = 'Matthias Trattnig'` instead of `name = 'Matthias Trattnig'`. The amended query now correctly joins related tables and returns distinct game types matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_type FROM players WHERE name = 'Matthias Trattnig';",
            "SELECT DISTINCT T1.GAMETYPE FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Matthias Trattnig'"
        ],
        "rule_sql": []
    },
    "1595": {
        "db_id": "car_retails",
        "question": "What is the total actual profit gained from orders made by American customers from 2003-01-06 to 2005-05-09?",
        "ground_truth": "SELECT SUM(T2.priceEach - T1.buyPrice) FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber INNER JOIN customers AS T4 ON T3.customerNumber = T4.customerNumber WHERE T3.orderDate > '2003-01-05' AND T3.orderDate < '2005-05-10'",
        "amends": [
            "Do calculate profit as `SUM(T2.priceEach - T1.buyPrice)` instead of simply `SUM(profit)` to properly compute the difference between selling price and cost. Do join multiple tables including `products AS T1`, `orderdetails AS T2`, `orders AS T3`, and `customers AS T4` instead of querying only the `orders` table to access all necessary data relationships. Do use `INNER JOIN` with proper join conditions `T1.productCode = T2.productCode`, `T2.orderNumber = T3.orderNumber`, and `T3.customerNumber = T4.customerNumber` instead of missing these table connections entirely. Do filter on `T3.orderDate > '2003-01-05' AND T3.orderDate < '2005-05-10'` using exclusive bounds instead of `BETWEEN` with inclusive bounds to match the original date range semantics. Do remove the explicit `customer_country = 'USA'` filter instead of including it, as the corrected query logic no longer requires this specific country restriction. The amended query now properly calculates profit from the price difference while maintaining the intended date filtering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(profit) FROM orders WHERE customer_country = 'USA' AND order_date BETWEEN '2003-01-06' AND '2005-05-09';",
            "SELECT SUM(T2.priceEach - T1.buyPrice) AS total_profit\nFROM products AS T1\nINNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode\nINNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber\nINNER JOIN customers AS T4 ON T3.customerNumber = T4.customerNumber\nWHERE T3.orderDate > '2003-01-05' AND T3.orderDate < '2005-05-10'"
        ],
        "rule_sql": []
    },
    "3566": {
        "db_id": "authors",
        "question": "What are the conference name and journal name of paper written by Shueh-Lin Yau? List down the name of co-authors and provide the title of that paper.",
        "ground_truth": "SELECT T1.ConferenceId, T1.JournalId, T2.Name, T1.Title FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id INNER JOIN Journal AS T4 ON T1.JournalId = T4.Id WHERE T2.Name = 'Shueh-Lin Yau'",
        "amends": [
            "Do select `T1.ConferenceId`, `T1.JournalId`, `T2.Name`, and `T1.Title` instead of `conference_name`, `journal_name`, `co_authors`, and `title`. Do join `Paper AS T1` with `PaperAuthor AS T2` on `T1.Id = T2.PaperId` instead of querying a single `papers` table. Do add `INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id` and `INNER JOIN Journal AS T4 ON T1.JournalId = T4.Id` instead of omitting these table joins. Do filter on `T2.Name = 'Shueh-Lin Yau'` instead of `author = 'Shueh-Lin Yau'` to correctly reference the joined author table. The amended query now properly joins across multiple normalized tables to retrieve conference and journal information while filtering by author name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT conference_name, journal_name, co_authors, title FROM papers WHERE author = 'Shueh-Lin Yau';",
            "SELECT T3.FullName AS conference_name, T4.FullName AS journal_name, T2.Name AS co_authors, T1.Title\nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nINNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id\nINNER JOIN Journal AS T4 ON T1.JournalId = T4.Id\nWHERE T2.Name = 'Shueh-Lin Yau'"
        ],
        "rule_sql": []
    },
    "5840": {
        "db_id": "airline",
        "question": "Provide the number of airplanes that landed on Oakland Airport on 2018/8/7.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.Description LIKE '%Oakland%' THEN 1 ELSE 0 END) AS count FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE T2.FL_DATE = '2018/8/7'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.Description LIKE '%Oakland%' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count specific pattern matches. Do join `Airports AS T1` and `Airlines AS T2` with `INNER JOIN` on `T1.Code = T2.DEST` instead of querying a single `flights` table. Do filter on `T2.FL_DATE = '2018/8/7'` instead of `date = '2018/8/7'` to use the correct date column. Do search for `'%Oakland%'` in `T1.Description` instead of exact match on `destination = 'Oakland'` to capture Oakland-related airports. The amended query now correctly counts flights to Oakland airports on the specified date by properly joining airport and airline data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'Oakland' AND date = '2018/8/7';",
            "SELECT SUM(CASE WHEN T1.Description LIKE '%Oakland%' THEN 1 ELSE 0 END) \nFROM Airports AS T1\nINNER JOIN Airlines AS T2 ON T1.Code = T2.DEST\nWHERE T2.FL_DATE = '2018/8/7'"
        ],
        "rule_sql": []
    },
    "5352": {
        "db_id": "beer_factory",
        "question": "How many transactions were made at Sac State Union?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM `transaction` AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.LocationName = 'Sac State Union'",
        "amends": [
            "Do reference the `transaction` table with alias `T1` instead of using a non-existent `transactions` table. Do join with the `location` table as `T2` on `T1.LocationID = T2.LocationID` instead of directly filtering on a non-existent `location` column. Do count `T1.TransactionID` instead of using `COUNT(*)` to ensure accurate counting of specific transactions. Do filter on `T2.LocationName = 'Sac State Union'` instead of attempting to filter on a non-existent `location` column in the transactions table. The amended query now correctly joins the transaction and location tables to count transactions associated with the specified location name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE location = 'Sac State Union';",
            "SELECT COUNT(T1.TransactionID) \nFROM \"transaction\" T1\nJOIN location T2 ON T1.LocationID = T2.LocationID\nWHERE T2.LocationName = 'Sac State Union'"
        ],
        "rule_sql": []
    },
    "1130": {
        "db_id": "talkingdata",
        "question": "How many male users of the \"Galaxy S5\" device model?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T1.device_model = 'Galaxy S5' AND T2.gender = 'M'",
        "amends": [
            "Do join `phone_brand_device_model2` as `T1` with `gender_age` as `T2` on `T1.device_id = T2.device_id` instead of querying only the `users` table. Do filter on `T2.gender = 'M'` instead of `gender = 'male'` and maintain `T1.device_model = 'Galaxy S5'` instead of `device_model = 'Galaxy S5'`. Do count `T1.device_id` instead of `COUNT(*)` to ensure accurate device counting. The amended query now correctly joins the required tables and uses proper gender coding while maintaining the Galaxy S5 device filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE gender = 'male' AND device_model = 'Galaxy S5';",
            "SELECT COUNT(T1.device_id) \nFROM phone_brand_device_model2 AS T1 \nJOIN gender_age AS T2 ON T1.device_id = T2.device_id \nWHERE T2.gender = 'M' AND T1.device_model = 'Galaxy S5'"
        ],
        "rule_sql": []
    },
    "180": {
        "db_id": "book_publishing_company",
        "question": "State the publisher name for publisher ID 877? Calculate its average year to date sales.",
        "ground_truth": "SELECT T2.pub_name, AVG(T1.ytd_sales) FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE T1.pub_id = '0877' GROUP BY T2.pub_name",
        "amends": [
            "Do join `titles AS T1` with `publishers AS T2` on `T1.pub_id = T2.pub_id` instead of querying only the `publishers` table. Do use `AVG(T1.ytd_sales)` instead of `AVG(year_to_date_sales)` and `T2.pub_name` instead of `publisher_name`. Do add `GROUP BY T2.pub_name` instead of omitting it. Do filter on `T1.pub_id = '0877'` with string comparison instead of `publisher_id = 877` with numeric comparison. The amended query now correctly calculates average sales by joining the titles table and grouping by publisher name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name, AVG(year_to_date_sales) FROM publishers WHERE publisher_id = 877;",
            "SELECT T2.pub_name, AVG(T1.ytd_sales) AS average_ytd_sales\nFROM titles AS T1\nJOIN publishers AS T2 ON T1.pub_id = T2.pub_id\nWHERE T1.pub_id = '0877'\nGROUP BY T2.pub_name;"
        ],
        "rule_sql": []
    },
    "7284": {
        "db_id": "works_cycles",
        "question": "What is the biggest amount of reviews a salable product gets?",
        "ground_truth": "SELECT T1.Comments FROM ProductReview AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.FinishedGoodsFlag = 1 GROUP BY T1.Comments ORDER BY COUNT(T1.ProductReviewID) DESC LIMIT 1",
        "amends": [
            "Do use `SELECT T1.Comments` with a specific column instead of `SELECT MAX(review_count)` with an aggregate function. Do add `FROM ProductReview AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID` with a table join instead of `FROM products` with a single table. Do change the filter to `WHERE T2.FinishedGoodsFlag = 1` instead of `WHERE salable = 0`. Do add `GROUP BY T1.Comments` for grouping instead of omitting it. Do add `ORDER BY COUNT(T1.ProductReviewID) DESC` for ordering instead of omitting it. Do add `LIMIT 1` for result limiting instead of omitting it. The amended query now correctly joins product review data with product information, filters for finished goods, groups by comments, and returns the most frequently occurring comment."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(review_count) FROM products WHERE salable = 0;",
            "SELECT T1.Comments\nFROM ProductReview AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID\nWHERE T2.FinishedGoodsFlag = 1\nGROUP BY T1.Comments\nORDER BY COUNT(T1.ProductReviewID) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4217": {
        "db_id": "simpson_episodes",
        "question": "Provide the episode number, title and rating of which were aired in October, 2008.",
        "ground_truth": "SELECT episode, title, rating FROM Episode WHERE SUBSTR(air_date, 1, 7) LIKE '2008-10%';",
        "amends": [
            "Do reference table `Episode` instead of `episodes` and column `episode` instead of `episode_number` in the SELECT list. Do use `SUBSTR(air_date, 1, 7)` to extract the year-month portion instead of the basic `LIKE` pattern matching on the full date string, ensuring proper date filtering for October 2008 episodes regardless of day values. The amended query now correctly matches the RIGHT_SQL's behavior by using the appropriate table name, column reference, and date handling function."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_number, title, rating FROM episodes WHERE air_date LIKE '2008-10%';",
            "SELECT episode, title, rating FROM Episode WHERE SUBSTR(air_date, 1, 7) = '2008-10'"
        ],
        "rule_sql": []
    },
    "5279": {
        "db_id": "beer_factory",
        "question": "Among the root beer brands that do not advertise on Facebook and Twitter, which brand has the highest number of purchases?",
        "ground_truth": "SELECT T2.BreweryName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T2.FacebookPage IS NULL AND T2.Twitter IS NULL GROUP BY T2.BrandID ORDER BY COUNT(T1.BrandID) DESC LIMIT 1",
        "amends": [
            "Do select `BreweryName` instead of `brand_name` and `SUM(purchases)`. Do use `FROM rootbeer` and `INNER JOIN rootbeerbrand` instead of `FROM root_beer_brands` alone. Do join on `T1.BrandID = T2.BrandID` instead of no join condition. Do filter with `T2.FacebookPage IS NULL AND T2.Twitter IS NULL` instead of `facebook_ads = 0 AND twitter_ads = 0`. Do add `GROUP BY T2.BrandID` instead of omitting grouping. Do order by `COUNT(T1.BrandID)` instead of `total_purchases`. The amended query now correctly identifies breweries with null social media presence and counts their brand occurrences.",
            "Do select only `T2.BreweryName` instead of including both `T2.BreweryName` and `COUNT(T1.BrandID) AS total_purchases` in the SELECT list. Do remove the alias `AS total_purchases` instead of keeping it. Do maintain the same FROM clause with `rootbeer T1` and `rootbeerbrand T2` joined via `INNER JOIN` on `T1.BrandID = T2.BrandID`. Do keep the WHERE filters `T2.FacebookPage IS NULL` and `T2.Twitter IS NULL` unchanged. Do preserve the GROUP BY on `T2.BrandID` and ORDER BY on `COUNT(T1.BrandID) DESC` with LIMIT 1. The amended query now correctly returns only the brewery name with the highest purchase count for brands lacking social media presence, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand_name, SUM(purchases) as total_purchases\nFROM root_beer_brands\nWHERE facebook_ads = 0 AND twitter_ads = 0\nORDER BY total_purchases DESC\nLIMIT 1;",
            "SELECT \n    T2.BreweryName,\n    COUNT(T1.BrandID) AS total_purchases\nFROM \n    rootbeer T1\nINNER JOIN \n    rootbeerbrand T2 ON T1.BrandID = T2.BrandID\nWHERE \n    T2.FacebookPage IS NULL \n    AND T2.Twitter IS NULL\nGROUP BY \n    T2.BrandID\nORDER BY \n    COUNT(T1.BrandID) DESC\nLIMIT 1;",
            "SELECT T2.BreweryName\nFROM rootbeer T1\nINNER JOIN rootbeerbrand T2 ON T1.BrandID = T2.BrandID\nWHERE T2.FacebookPage IS NULL AND T2.Twitter IS NULL\nGROUP BY T2.BrandID\nORDER BY COUNT(T1.BrandID) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2295": {
        "db_id": "movielens",
        "question": "How many drama movie with the rating of 3?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.movieid) FROM u2base AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T2.genre = 'drama' AND T1.rating = 3",
        "amends": [
            "Do select `COUNT(DISTINCT T2.movieid)` instead of `COUNT(*)` to count unique movies rather than all rows. Do add `FROM u2base AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid` instead of just `FROM movies` to join the user ratings and movie-director tables. Do change the filter to `T2.genre = 'drama'` instead of `genre = 'drama'` to reference the correct table's genre column. Do change the rating filter to `T1.rating = 3` instead of `rating = 3` to reference the user ratings table instead of the movies table. The amended query now correctly counts distinct movies from the joined tables with proper table references and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE genre = 'drama' AND rating = 3;",
            "SELECT COUNT(DISTINCT T2.movieid) \nFROM u2base AS T1 \nINNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid \nWHERE T2.genre = 'drama' AND T1.rating = '3'"
        ],
        "rule_sql": []
    },
    "2016": {
        "db_id": "soccer_2016",
        "question": "What are the names of players in team 1?",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Team AS T3 ON T2.Team_Id = T3.Team_Id WHERE T3.Team_Id = 1 GROUP BY T1.Player_Name",
        "amends": [
            "Do select `T1.Player_Name` instead of `name` and add explicit table aliases. Do add `INNER JOIN Player_Match AS T2` and `INNER JOIN Team AS T3` instead of querying only the `players` table. Do use join conditions `T1.Player_Id = T2.Player_Id` and `T2.Team_Id = T3.Team_Id` instead of a simple `WHERE team_id = 2` filter. Do filter on `T3.Team_Id = 1` instead of `team_id = 2` to reference the joined Team table. Do add `GROUP BY T1.Player_Name` instead of omitting aggregation grouping. The amended query now correctly joins multiple tables to find player names associated with a specific team through match relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE team_id = 2;",
            "SELECT T1.Player_Name\nFROM Player AS T1\nINNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id\nINNER JOIN Team AS T3 ON T2.Team_Id = T3.Team_Id\nWHERE T3.Team_Id = 1\nGROUP BY T1.Player_Name"
        ],
        "rule_sql": []
    },
    "5468": {
        "db_id": "sales",
        "question": "Name the product that sold the most quantity.",
        "ground_truth": "SELECT T2.Name FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Quantity DESC LIMIT 1",
        "amends": [
            "Do select `T2.Name` from the `Products` table instead of `product_name` from `products`. Do join `Sales AS T1` with `Products AS T2` using `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying only the `products` table without any joins. Do order by `T1.Quantity DESC` instead of `product_id DESC` to sort by sales quantity rather than product identifier. The amended query now correctly retrieves the product name with the highest sales quantity by joining sales and product tables and ordering by quantity, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY product_id DESC LIMIT 1;",
            "SELECT T2.Name \nFROM Sales AS T1 \nINNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID \nORDER BY T1.Quantity DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4115": {
        "db_id": "public_review_platform",
        "question": "In how many businesses with the ambience_trendy attribute?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name = 'ambience_trendy' AND T2.attribute_value IN ('none', 'no', 'false')",
        "amends": [
            "Do select `COUNT(T2.business_id)` from the joined table instead of `COUNT(*)` from a single table. Do use `Attributes AS T1 INNER JOIN Business_Attributes AS T2` with join condition `T1.attribute_id = T2.attribute_id` instead of querying only the `businesses` table. Do add filter `T1.attribute_name = 'ambience_trendy'` to specify the attribute type instead of assuming a direct column. Do change the value filter to `T2.attribute_value IN ('none', 'no', 'false')` to capture negative values instead of checking only for `'true'`. The amended query now correctly counts businesses based on attribute-value pairs in the normalized schema rather than relying on denormalized columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE ambience_trendy = 'true';",
            "SELECT COUNT(T2.business_id) \nFROM Attributes AS T1 \nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id \nWHERE T1.attribute_name = 'ambience_trendy' \nAND T2.attribute_value IN ('none', 'no', 'false')"
        ],
        "rule_sql": []
    },
    "811": {
        "db_id": "social_media",
        "question": "Which state was the tweet `tw-685681052912873473` from? Give the state code.",
        "ground_truth": "SELECT T2.StateCode FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T1.TweetID = 'tw-685681052912873473'",
        "amends": [
            "Do select `T2.StateCode` instead of `user.state` to reference the correct column from the location table. Do use `twitter AS T1` and `location AS T2` as table sources instead of `tweets` and `users` to reference the correct table names. Do perform an `INNER JOIN` on `T2.LocationID = T1.LocationID` instead of joining on `tweets.user_id = users.user_id` to establish the proper relationship between the twitter and location tables. Do filter on `T1.TweetID` instead of `tweets.tweet_id` to use the correct column name for the tweet identifier. The amended query now correctly retrieves state information by joining the appropriate tables through their location relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user.state FROM tweets JOIN users ON tweets.user_id = users.user_id WHERE tweets.tweet_id = 'tw-685681052912873473';",
            "SELECT T2.StateCode \nFROM twitter AS T1 \nINNER JOIN location AS T2 ON T2.LocationID = T1.LocationID \nWHERE T1.TweetID = 'tw-685681052912873473'"
        ],
        "rule_sql": []
    },
    "5462": {
        "db_id": "sales",
        "question": "Among the employee names, what is the most common middle initial?",
        "ground_truth": "SELECT MiddleInitial FROM Employees GROUP BY MiddleInitial ORDER BY COUNT(MiddleInitial) DESC LIMIT 1",
        "amends": [
            "Do select `MiddleInitial` instead of `first_name` and do count `MiddleInitial` specifically instead of using `COUNT(*)`. Do group by `MiddleInitial` instead of `first_name` and do order by `COUNT(MiddleInitial)` instead of the alias `count`. The amended query now correctly analyzes middle initial frequency distribution instead of first name counts.",
            "Do remove the `WHERE MiddleInitial IS NOT NULL` filter instead of keeping it, as the GROUP BY already handles NULL values appropriately. Do simplify the SELECT list to only include `MiddleInitial` instead of also including `COUNT(MiddleInitial) AS count`, since the ORDER BY clause already uses the count for sorting and only the MiddleInitial value is needed in the final result. Do maintain the `GROUP BY MiddleInitial`, `ORDER BY COUNT(MiddleInitial) DESC`, and `LIMIT 1` clauses as they correctly identify the most frequent non-NULL MiddleInitial value. The amended query now matches RIGHT_SQL's behavior by returning the most common MiddleInitial without unnecessary filtering and column selection."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, COUNT(*) as count FROM employees GROUP BY first_name ORDER BY count DESC LIMIT 1;",
            "SELECT MiddleInitial, COUNT(MiddleInitial) AS count \nFROM Employees \nWHERE MiddleInitial IS NOT NULL \nGROUP BY MiddleInitial \nORDER BY COUNT(MiddleInitial) DESC \nLIMIT 1;",
            "SELECT MiddleInitial FROM Employees GROUP BY MiddleInitial ORDER BY COUNT(MiddleInitial) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "7815": {
        "db_id": "hockey",
        "question": "What are the total weights of players for team 'ANA' as per year 1997?",
        "ground_truth": "SELECT SUM(T1.weight) FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 1997 AND T2.tmID = 'ANA'",
        "amends": [
            "Do select `SUM(T1.weight)` from the `Master` table instead of `SUM(weight)` from a single table. Do add `INNER JOIN Scoring AS T2` with join condition `ON T1.playerID = T2.playerID` instead of querying only the `players` table. Do move the year filter to `T2.year = 1997` on the joined Scoring table instead of filtering on the base table. Do change the team filter to `T2.tmID = 'ANA'` on the Scoring table instead of `team = 'ANA'` on the base table. The amended query now correctly aggregates player weights by joining the Master and Scoring tables and filtering on the appropriate columns from each table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(weight) FROM players WHERE team = 'ANA' AND year = 1997",
            "SELECT SUM(T1.weight) \nFROM Master AS T1\nINNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID\nWHERE T2.year = 1997 AND T2.tmID = 'ANA'"
        ],
        "rule_sql": []
    },
    "1520": {
        "db_id": "synthea",
        "question": "Provide the full names of patients who have been taking Penicillin V Potassium 250 MG since 1948.",
        "ground_truth": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Penicillin V Potassium 250 MG' AND strftime('%Y', T2.START) >= '1948'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `T1.first` and `T1.last` instead of `first_name` and `last_name`. Do add `INNER JOIN medications AS T2` instead of querying only the patients table, and join on `T1.patient = T2.PATIENT` instead of filtering directly. Do filter on `T2.DESCRIPTION` instead of `medication`, and use `strftime('%Y', T2.START) >= '1948'` instead of `start_year = 1948` to capture dates from 1948 onward rather than only the exact year 1948. The amended query now correctly joins the medications table to find patients with the specified medication and properly handles date filtering by year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM patients WHERE medication = 'Penicillin V Potassium 250 MG' AND start_year = 1948;",
            "SELECT DISTINCT T1.first, T1.last\nFROM patients AS T1\nINNER JOIN medications AS T2 ON T1.patient = T2.PATIENT\nWHERE T2.DESCRIPTION = 'Penicillin V Potassium 250 MG'\nAND strftime('%Y', T2.START) >= '1948';"
        ],
        "rule_sql": []
    },
    "7135": {
        "db_id": "works_cycles",
        "question": "What is the location of business number 1?",
        "ground_truth": "SELECT T1.AddressLine1 FROM Address AS T1 INNER JOIN BusinessEntityAddress AS T2 USING (AddressID) WHERE T2.BusinessEntityID = 1",
        "amends": [
            "Do select `T1.AddressLine1` instead of `name` from the SELECT list. Do add `Address AS T1` and `BusinessEntityAddress AS T2` tables with an `INNER JOIN` using `AddressID` instead of querying only the `businesses` table. Do change the WHERE filter to `T2.BusinessEntityID = 1` instead of `id = 1` to properly reference the joined table's column. The amended query now correctly retrieves address information through proper table relationships instead of directly querying a single table with incorrect column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE id = 1;",
            "SELECT T1.AddressLine1 \nFROM Address AS T1 \nINNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID \nWHERE T2.BusinessEntityID = 1"
        ],
        "rule_sql": []
    },
    "7053": {
        "db_id": "works_cycles",
        "question": "What is the pay frequency of the oldest employee?",
        "ground_truth": "SELECT T1.PayFrequency FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY T2.BirthDate ASC LIMIT 1",
        "amends": [
            "Do select `T1.PayFrequency` from the `EmployeePayHistory` table instead of `pay_frequency` from the `employees` table. Do join `Employee` as `T2` with an `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table without any joins. Do order by `T2.BirthDate` in ascending order instead of `age` in descending order. The amended query now correctly retrieves pay frequency data from the appropriate joined tables using the proper business entity relationship and sorts by birth date to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pay_frequency FROM employees ORDER BY age DESC LIMIT 1;",
            "SELECT T1.PayFrequency \nFROM EmployeePayHistory T1\nINNER JOIN Employee T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nORDER BY T2.BirthDate ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4893": {
        "db_id": "legislator",
        "question": "What was current legislator Sherrod Brown's Washington, D.C. office phone number during his term starting on 2013/1/3?",
        "ground_truth": "SELECT T1.phone FROM `current-terms` AS T1 INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE T2.official_full_name = 'Sherrod Brown' AND T1.start = '2013-01-03'",
        "amends": [
            "Do select `phone` from `current-terms` instead of `phone_number` from `legislators`. Do join `current-terms` as `T1` with `current` as `T2` on `T2.bioguide_id = T1.bioguide` instead of querying a single `legislators` table. Do filter on `T2.official_full_name = 'Sherrod Brown'` instead of `name = 'Sherrod Brown'` and `city = 'Washington, D.C.'`. Do use `T1.start = '2013-01-03'` with ISO date format instead of `start_date = '2013/1/3'` with non-standard format. The amended query now correctly retrieves phone information through proper table relationships and date handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM legislators WHERE name = 'Sherrod Brown' AND city = 'Washington, D.C.' AND start_date = '2013/1/3';",
            "SELECT T1.phone FROM \"current-terms\" AS T1 JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE T2.official_full_name = 'Sherrod Brown' AND T1.start = '2013-01-03'"
        ],
        "rule_sql": []
    },
    "2515": {
        "db_id": "app_store",
        "question": "What is the name and category of the app with the highest amount of -1 sentiment polarity score?",
        "ground_truth": "SELECT DISTINCT T1.App, T1.Category FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T2.Sentiment_Polarity = '-1.0'",
        "amends": [
            "Do reference `T1.App` and `T1.Category` instead of `name` and `category`. Do use `DISTINCT` instead of omitting it. Do join `playstore AS T1` with `user_reviews AS T2` on `T1.App = T2.App` instead of querying only the `apps` table. Do filter on `T2.Sentiment_Polarity = '-1.0'` instead of `sentiment_polarity = -1`. Do remove `ORDER BY` and `LIMIT` instead of keeping them. The amended query now correctly identifies apps with sentiment polarity of -1.0 by joining the appropriate tables and using string comparison instead of numeric comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, category FROM apps WHERE sentiment_polarity = -1 ORDER BY sentiment_polarity DESC LIMIT 1;",
            "SELECT DISTINCT T1.App, T1.Category FROM playstore AS T1 JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T2.Sentiment_Polarity = '-1.0'"
        ],
        "rule_sql": []
    },
    "5164": {
        "db_id": "address",
        "question": "Among the postal points in Texas, provide the zip codes and cities of postal points which have total beneficiaries of above 10000.",
        "ground_truth": "SELECT T2.zip_code, T2.city FROM state AS T1 INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE T1.name = 'Texas' AND T2.total_beneficiaries > 10000",
        "amends": [
            "Do join `state AS T1` and `zip_data AS T2` with `INNER JOIN` on `T1.abbreviation = T2.state` instead of querying only `postal_points`. Do reference columns as `T2.zip_code` and `T2.city` instead of directly from the original table. Do filter on `T1.name = 'Texas'` instead of `state = 'Texas'` to use the state name from the joined table. Do keep the filter `T2.total_beneficiaries > 10000` but apply it to the joined table instead. The amended query now correctly joins state information with zip code data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, city FROM postal_points WHERE state = 'Texas' AND total_beneficiaries > 10000;",
            "SELECT T2.zip_code, T2.city\nFROM state AS T1\nINNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state\nWHERE T1.name = 'Texas' AND T2.total_beneficiaries > 10000"
        ],
        "rule_sql": []
    },
    "2078": {
        "db_id": "music_tracker",
        "question": "Among id from 10 to 50. Which artist tagged as \"new.york\" has the most downloads?",
        "ground_truth": "SELECT T1.artist FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.id BETWEEN 10 AND 50 AND T2.tag LIKE 'new.york' ORDER BY T1.totalSnatched DESC LIMIT 1",
        "amends": [
            "Do select `T1.artist` instead of `artist` and remove `COUNT(*) as download_count` instead of including it. Do use `FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id` instead of `FROM downloads` with no join. Do change the filter to `T2.tag LIKE 'new.york'` instead of `tags = 'new.york'` while keeping `T1.id BETWEEN 10 AND 50`. Do remove `GROUP BY artist` instead of keeping it. Do change ordering to `ORDER BY T1.totalSnatched DESC` instead of `ORDER BY download_count DESC` while keeping `LIMIT 1`. The amended query now correctly joins torrents with tags and uses the appropriate column for ordering based on total snatched count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist, COUNT(*) as download_count \nFROM downloads \nWHERE id BETWEEN 10 AND 50 \nAND tags = 'new.york' \nGROUP BY artist \nORDER BY download_count DESC \nLIMIT 1;",
            "SELECT T1.artist FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.id BETWEEN 10 AND 50 AND T2.tag LIKE 'new.york' ORDER BY T1.totalSnatched DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "7428": {
        "db_id": "works_cycles",
        "question": "Has the product Chainring Bolts been on any of the sales?",
        "ground_truth": "SELECT CASE WHEN COUNT(T1.Description) >= 1 THEN 'Yes' ELSE 'No' END FROM SpecialOffer AS T1 INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID INNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID WHERE T3.Name = 'Chainring Bolts'",
        "amends": [
            "Do use a `CASE` expression with `COUNT(T1.Description)` to return 'Yes' or 'No' instead of selecting all columns with `SELECT *`. Do join three tables - `SpecialOffer AS T1`, `SpecialOfferProduct AS T2`, and `Product AS T3` - instead of querying only the `products` table. Do use `INNER JOIN` on `T1.SpecialOfferID = T2.SpecialOfferID` and `T2.ProductID = T3.ProductID` instead of no joins. Do filter on `T3.Name = 'Chainring Bolts'` instead of `product_name = 'Chainring Bolts'`. The amended query now correctly checks for the existence of special offers for the specified product and returns the appropriate indicator, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products WHERE product_name = 'Chainring Bolts';",
            "SELECT CASE WHEN COUNT(T1.Description) > 0 THEN 'Yes' ELSE 'No' END AS HasBeenOnSale\nFROM SpecialOffer AS T1\nINNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID\nINNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID\nWHERE T3.Name = 'Chainring Bolts';"
        ],
        "rule_sql": []
    },
    "4727": {
        "db_id": "disney",
        "question": "Find out what proportion of total revenue Walt Disney Parks and Resorts received in 2010.",
        "ground_truth": "SELECT SUM(`Walt Disney Parks and Resorts`) / SUM(Total) * 100 FROM revenue WHERE year = 2010",
        "amends": [
            "Do use `SUM(Walt Disney Parks and Resorts)` and `SUM(Total)` in the SELECT expression instead of calculating a proportion with a subquery. Do reference the `revenue` table instead of `financial_data`. Do include `* 100` to convert to percentage instead of leaving as a decimal proportion. Do remove the WHERE filter for company name and year since the aggregation handles this logic instead of filtering individual rows. Do use proper column names from the revenue table structure instead of generic revenue calculations. The amended query now correctly calculates the percentage contribution using proper table structure and aggregation.",
            "Do use standard division operator `/` instead of parentheses around the entire expression. Do remove the explicit decimal cast `100.0` and use integer `100` instead. Do use backticks instead of double quotes for column names. Do use lowercase `year` in the WHERE clause instead of uppercase `Year`. Do remove the alias `proportion` instead of keeping it. The amended query now correctly calculates the percentage proportion without unnecessary parentheses and with proper column referencing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (revenue / (SELECT SUM(revenue) FROM financial_data WHERE year = 2010)) AS proportion\nFROM financial_data \nWHERE company = 'Walt Disney Parks and Resorts' AND year = 2010;",
            "SELECT (SUM(\"Walt Disney Parks and Resorts\") * 100.0 / SUM(Total)) AS proportion FROM revenue WHERE Year = 2010;",
            "SELECT (SUM(`Walt Disney Parks and Resorts`) / SUM(Total)) * 100 FROM revenue WHERE year = 2010;"
        ],
        "rule_sql": []
    },
    "9264": {
        "db_id": "movie_3",
        "question": "To which country does the address '1386 Nakhon Sawan Boulevard' belong?",
        "ground_truth": "SELECT T1.country FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id INNER JOIN address AS T3 ON T2.city_id = T3.city_id WHERE T3.address = '1386 Nakhon Sawan Boulevard'",
        "amends": [
            "Do add table joins with `country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id INNER JOIN address AS T3 ON T2.city_id = T3.city_id` instead of querying `addresses` directly. Do reference the country column as `T1.country` instead of just `country`. Do filter on `T3.address = '1386 Nakhon Sawan Boulevard'` instead of `street = '1386 Nakhon Sawan Boulevard'` to use the correct column name from the joined address table. The amended query now correctly joins through the city and country relationships to find the country associated with the specific address, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM addresses WHERE street = '1386 Nakhon Sawan Boulevard';",
            "SELECT T1.country \nFROM country AS T1 \nINNER JOIN city AS T2 ON T1.country_id = T2.country_id \nINNER JOIN address AS T3 ON T2.city_id = T3.city_id \nWHERE T3.address = '1386 Nakhon Sawan Boulevard'"
        ],
        "rule_sql": []
    },
    "4801": {
        "db_id": "legislator",
        "question": "Among the legislators who started a term on 2nd December 1793, how many of them were males?",
        "ground_truth": "SELECT COUNT(T1.bioguide_id) FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND T2.start = '1793-12-02'",
        "amends": [
            "Do use `COUNT(T1.bioguide_id)` instead of `COUNT(*)` to count specific identifiers rather than all rows. Do query from `historical AS T1` instead of `legislators` as the correct source table. Do add `INNER JOIN historical-terms AS T2 ON T1.bioguide_id = T2.bioguide` instead of omitting the join to connect biographical and term data. Do filter with `T1.gender_bio = 'M'` instead of `gender = 'male'` using the correct column name and value format. Do filter with `T2.start = '1793-12-02'` instead of `start_date = '1793-12-02'` using the joined table's date column. The amended query now correctly counts male legislators with terms starting on the specified date by properly joining the biographical and term tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE start_date = '1793-12-02' AND gender = 'male';",
            "SELECT COUNT(T1.bioguide_id) \nFROM historical AS T1 \nINNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide \nWHERE T2.start = '1793-12-02' \nAND T1.gender_bio = 'M'"
        ],
        "rule_sql": []
    },
    "4996": {
        "db_id": "olympics",
        "question": "Among the Olympic games held in Los Angeles, what is the name of the Olympic game that has the most number of competitors?",
        "ground_truth": "SELECT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN games_city AS T3 ON T2.games_id = T3.games_id INNER JOIN city AS T4 ON T3.city_id = T4.id WHERE T4.city_name = 'Los Angeles' GROUP BY T1.id ORDER BY COUNT(T2.person_id) DESC LIMIT 1",
        "amends": [
            "Do reference `games_name` from the `games` table instead of `Games` from an unspecified source. Do join `games` with `games_competitor` on `games.id = games_competitor.games_id` instead of omitting these necessary table relationships. Do join `games_city` on `games_competitor.games_id = games_city.games_id` instead of missing this connection to cities. Do join `city` on `games_city.city_id = city.id` instead of directly filtering on `City` without proper table linkage. Do filter on `city.city_name = 'Los Angeles'` instead of `City = 'Los Angeles'` without table qualification. Do group by `games.id` instead of omitting grouping for the aggregate count. Do count `games_competitor.person_id` instead of `Competitors` which lacks proper table reference. The amended query now correctly retrieves games from Los Angeles by establishing proper table relationships through multiple joins and appropriate grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Games FROM olympics WHERE City = 'Los Angeles' ORDER BY COUNT(Competitors) DESC LIMIT 1;",
            "SELECT g.games_name\nFROM games g\nJOIN games_competitor gc ON g.id = gc.games_id\nJOIN games_city gct ON g.id = gct.games_id\nJOIN city c ON gct.city_id = c.id\nWHERE c.city_name = 'Los Angeles'\nGROUP BY g.id, g.games_name\nORDER BY COUNT(gc.person_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "987": {
        "db_id": "computer_student",
        "question": "Please list the IDs of the teachers who have advised more than 4 others to teach.",
        "ground_truth": "SELECT p_id_dummy FROM advisedBy GROUP BY p_id_dummy HAVING COUNT(p_id_dummy) > 4",
        "amends": [
            "Do select `p_id_dummy` instead of `teacher_id` from the `advisedBy` table instead of the `advisors` table. Do count `p_id_dummy` specifically instead of using `COUNT(*)` to count all rows. The amended query now correctly identifies advisors with more than 4 advisees by using the proper table and column names while maintaining the same logical behavior of counting group members.",
            "Do select `p_id_dummy` instead of `p_id` in the SELECT list. Do group by `p_id_dummy` instead of `p_id` in the GROUP BY clause, while keeping the same HAVING condition `COUNT(p_id_dummy) > 4` unchanged. The amended query now correctly aggregates and returns the same column used for counting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT teacher_id FROM advisors GROUP BY teacher_id HAVING COUNT(*) > 4",
            "SELECT p_id FROM advisedBy GROUP BY p_id HAVING COUNT(p_id_dummy) > 4",
            "SELECT p_id_dummy FROM advisedBy GROUP BY p_id_dummy HAVING COUNT(p_id_dummy) > 4"
        ],
        "rule_sql": []
    },
    "3473": {
        "db_id": "video_games",
        "question": "What are the game IDs of the games published by Bethesda Softworks?",
        "ground_truth": "SELECT T1.game_id FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Bethesda Softworks'",
        "amends": [
            "Do select `T1.game_id` from the `game_publisher` table instead of selecting `game_id` directly from a non-existent `games` table. Do join `publisher AS T2` using `INNER JOIN` with the predicate `T1.publisher_id = T2.id` instead of querying a single table. Do filter on `T2.publisher_name = 'Bethesda Softworks'` instead of filtering on a non-existent `publisher` column, which correctly references the publisher name from the joined publisher table rather than attempting to use publisher as a column. The amended query now properly joins the necessary tables and matches the RIGHT_SQL's behavior by correctly relating game publishers through their IDs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_id FROM games WHERE publisher = 'Bethesda Softworks';",
            "SELECT T1.game_id FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Bethesda Softworks'"
        ],
        "rule_sql": []
    },
    "8609": {
        "db_id": "chicago_crime",
        "question": "Give the name of the person who was responsible for case No.JB524952.",
        "ground_truth": "SELECT T1.commander FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T2.case_number = 'JB524952'",
        "amends": [
            "Do select `T1.commander` instead of `person_name` from a different table. Do use `FROM District AS T1 INNER JOIN Crime AS T2` instead of `FROM cases` alone, adding two tables with an explicit join. Do specify the join condition `ON T1.district_no = T2.district_no` instead of having no join predicate. Do keep the filter `WHERE T2.case_number = 'JB524952'` but apply it to the joined Crime table instead of the original cases table. The amended query now correctly retrieves the commander from the District table by joining with Crime table using district numbers and filtering on the specific case number, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT person_name FROM cases WHERE case_number = 'JB524952';",
            "SELECT T1.commander FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T2.case_number = 'JB524952'"
        ],
        "rule_sql": []
    },
    "7511": {
        "db_id": "image_and_language",
        "question": "What are the corresponding classes for the \"very large bike\" attribute?",
        "ground_truth": "SELECT ATT_CLASS_ID FROM ATT_CLASSES WHERE ATT_CLASS = 'very large'",
        "amends": [
            "Do select only `ATT_CLASS_ID` instead of all columns with `*`. Do reference table `ATT_CLASSES` instead of `classes`. Do filter on column `ATT_CLASS` with value `'very large'` instead of filtering on `attribute` with value `'very large bike'`. The amended query now correctly retrieves the specific class ID from the appropriate table using the correct filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM classes WHERE attribute = 'very large bike';",
            "SELECT ATT_CLASS_ID FROM ATT_CLASSES WHERE ATT_CLASS = 'very large'"
        ],
        "rule_sql": []
    },
    "546": {
        "db_id": "movies_4",
        "question": "List the job titles of Sally Menke in the crew.",
        "ground_truth": "SELECT DISTINCT T2.job FROM person AS T1 INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Sally Menke'",
        "amends": [
            "Do select `DISTINCT T2.job` instead of `job_title` from a single table. Do join `person AS T1` and `movie_crew AS T2` with `INNER JOIN` on `T1.person_id = T2.person_id` instead of querying only the `crew` table. Do filter on `T1.person_name = 'Sally Menke'` instead of `name = 'Sally Menke'` to use the correct column name from the joined table structure. The amended query now correctly retrieves distinct job titles from the proper relational structure instead of relying on a potentially incorrect single-table approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title FROM crew WHERE name = 'Sally Menke';",
            "SELECT DISTINCT T2.job FROM person AS T1 INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Sally Menke'"
        ],
        "rule_sql": []
    },
    "890": {
        "db_id": "cs_semester",
        "question": "Among the most important courses, what is the name of the most difficult course?",
        "ground_truth": "SELECT name FROM course WHERE credit = ( SELECT MAX(credit) FROM course ) AND diff = ( SELECT MAX(diff) FROM course )",
        "amends": [
            "Do select `name` from the `course` table instead of `course_name` from `courses`. Do filter with `credit = (SELECT MAX(credit) FROM course)` and `diff = (SELECT MAX(diff) FROM course)` instead of `importance = 'high'`. Do remove `ORDER BY difficulty DESC LIMIT 1` and instead use subqueries to find maximum values for both credit and difficulty. Do change the table reference from `courses` to `course` and use the correct column names `name`, `credit`, and `diff` instead of `course_name`, `importance`, and `difficulty`. The amended query now correctly finds courses with both maximum credit and maximum difficulty values instead of just the single most difficult high-importance course."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE importance = 'high' ORDER BY difficulty DESC LIMIT 1;",
            "SELECT name FROM course WHERE credit = (SELECT MAX(credit) FROM course) AND diff = (SELECT MAX(diff) FROM course);"
        ],
        "rule_sql": []
    },
    "910": {
        "db_id": "cs_semester",
        "question": "What is the male and female ratio among the professors?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN gender = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN gender = 'Female' THEN 1 ELSE 0 END) FROM prof",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN gender = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN gender = 'Female' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to calculate the ratio of male to female professors. Do filter with specific gender conditions `gender = 'Male'` and `gender = 'Female'` instead of `gender = 'male' OR gender = 'female'` to ensure proper case sensitivity and ratio calculation. Do remove the `WHERE` clause entirely instead of filtering by gender, as the CASE expressions handle the gender-specific counting within the aggregates. The amended query now correctly calculates the male-to-female ratio rather than simply counting all professors, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE gender = 'male' OR gender = 'female';",
            "SELECT CAST(SUM(CASE WHEN gender = 'Male' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN gender = 'Female' THEN 1 ELSE 0 END) AS male_female_ratio FROM prof;"
        ],
        "rule_sql": []
    },
    "282": {
        "db_id": "retail_complains",
        "question": "Among the clients born between 1980 and 2000, list the name of male clients who complained through referral.",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.year BETWEEN 1980 AND 2000 AND T1.sex = 'Male' AND T2.`Submitted via` = 'Referral'",
        "amends": [
            "Do select `T1.first`, `T1.middle`, `T1.last` instead of just `name`. Do use table alias `T1` for `client` instead of `clients`. Do add `INNER JOIN events AS T2` instead of omitting it. Do use join condition `T1.client_id = T2.Client_ID` instead of no join. Do use filter `T1.year BETWEEN 1980 AND 2000` instead of `year_of_birth`. Do use `T1.sex = 'Male'` instead of `gender = 'male'`. Do use `T2.Submitted via = 'Referral'` instead of `complaint_method = 'referral'`. The amended query now correctly joins the client and events tables to filter based on event submission method while selecting the proper name components."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM clients WHERE gender = 'male' AND year_of_birth BETWEEN 1980 AND 2000 AND complaint_method = 'referral';",
            "SELECT T1.first, T1.middle, T1.last\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.year BETWEEN 1980 AND 2000\nAND T1.sex = 'Male'\nAND T2.\"Submitted via\" = 'Referral'"
        ],
        "rule_sql": []
    },
    "4976": {
        "db_id": "olympics",
        "question": "How many gold medals were given to the winners in the Ice Hockey Men's Ice Hockey event?",
        "ground_truth": "SELECT COUNT(T2.competitor_id) FROM event AS T1 INNER JOIN competitor_event AS T2 ON T1.id = T2.event_id WHERE T1.event_name LIKE 'Ice Hockey Men%s Ice Hockey' AND T2.medal_id = 1",
        "amends": [
            "Do select `COUNT(T2.competitor_id)` instead of `COUNT(*)` to count specific competitor entries rather than all rows. Do use `event AS T1 INNER JOIN competitor_event AS T2` instead of querying only the `medals` table to properly join event and competitor data. Do join on `T1.id = T2.event_id` instead of missing the join condition entirely. Do filter with `T1.event_name LIKE 'Ice Hockey Men%s Ice Hockey'` instead of `event = 'Ice Hockey Men\\'s Ice Hockey'` to handle the apostrophe correctly and match the event name pattern. Do filter with `T2.medal_id = 1` instead of `medal_type = 'Gold'` to use the correct ID reference for gold medals. The amended query now correctly counts gold medal winners for the specified ice hockey event by properly joining the relevant tables and using appropriate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM medals WHERE event = 'Ice Hockey Men\\'s Ice Hockey' AND medal_type = 'Gold';",
            "SELECT COUNT(T2.competitor_id) \nFROM event AS T1 \nINNER JOIN competitor_event AS T2 ON T1.id = T2.event_id \nWHERE T1.event_name LIKE 'Ice Hockey Men%s Ice Hockey' \nAND T2.medal_id = 1"
        ],
        "rule_sql": []
    },
    "684": {
        "db_id": "codebase_comments",
        "question": "List all the tokenized name of the solution path \"jurney_P4Backup\\P4Backup\\P4Backup.sln\n\".",
        "ground_truth": "SELECT DISTINCT T2.NameTokenized FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'jurney_P4BackupP4BackupP4Backup.sln'",
        "amends": [
            "Do select `T2.NameTokenized` instead of `name` from a different table. Do use `DISTINCT` instead of omitting it to remove duplicates. Do join `Solution AS T1` and `Method AS T2` with `INNER JOIN` on `T1.Id = T2.SolutionId` instead of querying only the `tokens` table. Do filter on `T1.Path` instead of `solution_path` with the corrected path value `'jurney_P4BackupP4BackupP4Backup.sln'` instead of the original path format. The amended query now correctly retrieves distinct tokenized method names from the appropriate tables with proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM tokens WHERE solution_path = 'jurney_P4Backup\\P4Backup\\P4Backup.sln';",
            "SELECT DISTINCT T2.NameTokenized FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'jurney_P4BackupP4BackupP4Backup.sln'"
        ],
        "rule_sql": []
    },
    "91": {
        "db_id": "movie_platform",
        "question": "Please provide the ID of the user with the most followers on the list.",
        "ground_truth": "SELECT user_id FROM lists ORDER BY list_followers DESC LIMIT 1",
        "amends": [
            "Do select `user_id` from the `lists` table instead of from the `followers` table. Do order by `list_followers` instead of ordering by `COUNT(follower_id)`. Do remove the `GROUP BY user_id` clause instead of keeping it. The amended query now correctly retrieves the user with the most followers from the lists table rather than attempting to count followers from a followers table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM followers GROUP BY user_id ORDER BY COUNT(follower_id) DESC LIMIT 1;",
            "SELECT user_id FROM lists ORDER BY list_followers DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2510": {
        "db_id": "genes",
        "question": "Of the genes whose phenotype and motif are nucleic acid metabolism defects, PS00107, what percentage perform positive interaction with another gene?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Expression_Corr > 0, 1, 0)) AS REAL) * 100 / COUNT(T2.GeneID1) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Phenotype = 'Nucleic acid metabolism defects' AND T1.Motif = 'PS00107'",
        "amends": [
            "Do use `SUM(IIF(T2.Expression_Corr > 0, 1, 0))` instead of `COUNT(CASE WHEN interaction_type = 'positive' THEN 1 END)` for counting positive interactions. Do join `Genes AS T1` with `Interactions AS T2` using `INNER JOIN` on `T1.GeneID = T2.GeneID1` instead of using a subquery with `gene_id IN`. Do reference `T2.Expression_Corr > 0` instead of `interaction_type = 'positive'` for the positive interaction condition. Do use `T1.Phenotype` and `T1.Motif` in the WHERE clause instead of the original table's columns. Do add explicit `CAST` to `REAL` for the percentage calculation instead of implicit conversion. Do remove the subquery entirely and instead perform the join directly between the tables. The amended query now correctly calculates the percentage of positive expression correlations by joining the tables directly and using the appropriate correlation threshold.",
            "Do use `COUNT(T2.GeneID1)` instead of `COUNT(*)` to count only non-null interaction records. Do change the case sensitivity in the WHERE clause to `'Nucleic acid metabolism defects'` instead of `'nucleic acid metabolism defects'` to match the exact string value. Do remove the alias `percentage_positive_interaction` instead of keeping it since the RIGHT_SQL doesn't include column naming. Do simplify the percentage calculation by moving the multiplication factor directly instead of using division followed by multiplication. The amended query now correctly calculates the percentage of positive interactions while ensuring proper case matching and accurate counting of relevant records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN interaction_type = 'positive' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_positive_interaction\nFROM genes\nWHERE phenotype = 'nucleic acid metabolism defects' \nAND motif = 'PS00107'\nAND gene_id IN (\n    SELECT gene_id \n    FROM interactions \n    WHERE interaction_type = 'positive'\n)",
            "SELECT \n    (CAST(SUM(IIF(T2.Expression_Corr > 0, 1, 0)) AS REAL) / COUNT(*)) * 100.0 AS percentage_positive_interaction\nFROM \n    Genes AS T1\nINNER JOIN \n    Interactions AS T2 ON T1.GeneID = T2.GeneID1\nWHERE \n    T1.Phenotype = 'nucleic acid metabolism defects' \n    AND T1.Motif = 'PS00107';",
            "SELECT CAST(SUM(IIF(T2.Expression_Corr > 0, 1, 0)) * 100.0 / COUNT(T2.GeneID1) AS REAL) \nFROM Genes AS T1\nINNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1\nWHERE T1.Phenotype = 'Nucleic acid metabolism defects' AND T1.Motif = 'PS00107';"
        ],
        "rule_sql": []
    },
    "5275": {
        "db_id": "beer_factory",
        "question": "What are the full names of the customer who gave River City a 5-star?",
        "ground_truth": "SELECT T1.First, T1.Last FROM customers AS T1 INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID WHERE T3.BrandName = 'River City' AND T2.StarRating = 5",
        "amends": [
            "Do add `T1.First` and `T1.Last` instead of `first_name` and `last_name` in the SELECT list. Do add `INNER JOIN rootbeerreview AS T2` on `T1.CustomerID = T2.CustomerID` instead of omitting this table and join. Do add `INNER JOIN rootbeerbrand AS T3` on `T2.BrandID = T3.BrandID` instead of omitting this table and join. Do change the WHERE filter to `T3.BrandName = 'River City'` instead of `company = 'River City'`. Do change the rating filter to `T2.StarRating = 5` instead of `rating = 5`. The amended query now correctly joins through the review and brand tables to filter by brand name and star rating instead of incorrectly filtering on non-existent columns in the customers table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE rating = 5 AND company = 'River City';",
            "SELECT T1.First, T1.Last\nFROM customers AS T1\nINNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID\nWHERE T3.BrandName = 'River City' AND T2.StarRating = 5"
        ],
        "rule_sql": []
    },
    "2494": {
        "db_id": "genes",
        "question": "What are the functions of the pair of genes that have the lowest expression correlation score?a",
        "ground_truth": "SELECT T1.Function FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 ORDER BY T2.Expression_Corr ASC LIMIT 1",
        "amends": [
            "Do select `T1.Function` instead of `gene1, gene2, function`. Do use `FROM Genes AS T1 INNER JOIN Interactions AS T2` instead of `FROM gene_pairs`. Do specify join condition `ON T1.GeneID = T2.GeneID1` instead of omitting explicit joins. Do order by `T2.Expression_Corr ASC` instead of `correlation_score DESC`. The amended query now correctly retrieves function data through proper table joins and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gene1, gene2, function FROM gene_pairs ORDER BY correlation_score DESC LIMIT 1;",
            "SELECT T1.Function FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 ORDER BY T2.Expression_Corr ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7044": {
        "db_id": "works_cycles",
        "question": "Among the companies to which Adventure Works Cycles purchases parts or other goods, what is the profit on net obtained from the vendor who has an above average credit rating? Kindly indicate each names of the vendor and the corresponding net profits.",
        "ground_truth": "SELECT T2.Name, T1.LastReceiptCost - T1.StandardPrice FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.CreditRating = 3",
        "amends": [
            "Do select `T2.Name` and `T1.LastReceiptCost - T1.StandardPrice` instead of `v.Name` and `SUM(soh.SubTotal - soh.TotalDue) AS NetProfit`. Do use `FROM ProductVendor AS T1 INNER JOIN Vendor AS T2` instead of `FROM Purchasing.Vendor v JOIN Purchasing.PurchaseOrderHeader poh JOIN Sales.SalesOrderHeader soh`. Do join on `T1.BusinessEntityID = T2.BusinessEntityID` instead of `v.VendorID = poh.VendorID` and `poh.PurchaseOrderID = soh.PurchaseOrderID`. Do filter with `WHERE T2.CreditRating = 3` instead of `WHERE v.CreditRating > (SELECT AVG(CreditRating) FROM Purchasing.Vendor)`. Do remove `GROUP BY v.Name` instead of keeping it. The amended query now correctly calculates vendor profit using the appropriate tables and fixed credit rating filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT v.Name, SUM(soh.SubTotal - soh.TotalDue) AS NetProfit\nFROM Purchasing.Vendor v\nJOIN Purchasing.PurchaseOrderHeader poh ON v.VendorID = poh.VendorID\nJOIN Sales.SalesOrderHeader soh ON poh.PurchaseOrderID = soh.PurchaseOrderID\nWHERE v.CreditRating > (SELECT AVG(CreditRating) FROM Purchasing.Vendor)\nGROUP BY v.Name;",
            "SELECT \n    T2.Name AS VendorName,\n    (T1.LastReceiptCost - T1.StandardPrice) AS NetProfit\nFROM \n    ProductVendor AS T1 \nINNER JOIN \n    Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE \n    T2.CreditRating = 3"
        ],
        "rule_sql": []
    },
    "5753": {
        "db_id": "language_corpus",
        "question": "What percentage of Catalan-language Wikipedia pages have more than 10,000 words?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.words > 10000 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.page) FROM langs AS T1 INNER JOIN pages AS T2 ON T1.lid = T2.lid WHERE T1.lang = 'ca'",
        "amends": [
            "Do use `COUNT(CASE WHEN T2.words > 10000 THEN 1 ELSE NULL END)` instead of `COUNT(*)` to count only specific rows. Do join `langs AS T1 INNER JOIN pages AS T2 ON T1.lid = T2.lid` instead of querying only the `pages` table. Do filter with `WHERE T1.lang = 'ca'` instead of `WHERE language = 'Catalan'` to use the language code. Do reference `T2.words` instead of `word_count` for the column name. Do use `COUNT(T2.page)` as the denominator instead of a subquery. Do cast the result as `REAL` instead of using `100.0` for proper numeric handling. The amended query now correctly calculates the percentage of Catalan pages with more than 10000 words using proper table joins and counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM pages WHERE language = 'Catalan')) AS percentage\nFROM pages \nWHERE language = 'Catalan' AND word_count > 10000;",
            "SELECT \n    (COUNT(CASE WHEN T2.words > 10000 THEN 1 ELSE NULL END) * 100.0 / COUNT(T2.page)) AS percentage\nFROM \n    langs AS T1 \nINNER JOIN \n    pages AS T2 ON T1.lid = T2.lid\nWHERE \n    T1.lang = 'ca';"
        ],
        "rule_sql": []
    },
    "8248": {
        "db_id": "mondial_geo",
        "question": "Which country has the lowest inflation rate?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE T2.Inflation IS NOT NULL ORDER BY T2.Inflation ASC LIMIT 1",
        "amends": [
            "Do select `T1.Name` from the `country` table instead of `country` from the `inflation_data` table. Do join with `economy` table using `INNER JOIN` on `T1.Code = T2.Country` instead of querying a single table. Do add filter `T2.Inflation IS NOT NULL` instead of omitting null handling. Do order by `T2.Inflation ASC` instead of `inflation_rate DESC` to find the lowest inflation instead of highest. The amended query now correctly identifies the country with the lowest inflation rate by properly joining country and economy tables with appropriate filtering and sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM inflation_data ORDER BY inflation_rate DESC LIMIT 1;",
            "SELECT T1.Name \nFROM country T1 \nINNER JOIN economy T2 ON T1.Code = T2.Country \nWHERE T2.Inflation IS NOT NULL \nORDER BY T2.Inflation ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2020": {
        "db_id": "soccer_2016",
        "question": "Where did SB Joshi come from?",
        "ground_truth": "SELECT T2.Country_Name FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE T1.Player_Name = 'SB Joshi'",
        "amends": [
            "Do select `T2.Country_Name` instead of `name`. Do use `INNER JOIN` between `Player AS T1` and `Country AS T2` on `T1.Country_Name = T2.Country_ID` instead of querying only the `people` table. Do filter on `T1.Player_Name = 'SB Joshi'` instead of `hometown = 'SB Joshi'`. The amended query now correctly joins the Player and Country tables to retrieve the country name for the specified player, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE hometown = 'SB Joshi';",
            "SELECT T2.Country_Name \nFROM Player AS T1 \nINNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id \nWHERE T1.Player_Name = 'SB Joshi'"
        ],
        "rule_sql": []
    },
    "1795": {
        "db_id": "soccer_2016",
        "question": "Please list the names of the players who use the right hand as their batting hand and are from Australia.",
        "ground_truth": "SELECT T2.Player_Name FROM Country AS T1 INNER JOIN Player AS T2 ON T2.Country_Name = T1.Country_id INNER JOIN Batting_Style AS T3 ON T2.Batting_hand = T3.Batting_Id WHERE T1.Country_Name = 'Australia' AND T3.Batting_Hand = 'Right-hand bat'",
        "amends": [
            "Do use `T2.Player_Name` instead of `name` for the SELECT column. Do join `Country AS T1` and `Player AS T2` with `T2.Country_Name = T1.Country_id` instead of directly filtering on `country`. Do add a join to `Batting_Style AS T3` with `T2.Batting_hand = T3.Batting_Id` instead of directly filtering on `batting_hand`. Do filter on `T1.Country_Name = 'Australia'` instead of `country = 'Australia'`. Do filter on `T3.Batting_Hand = 'Right-hand bat'` instead of `batting_hand = 'left'`. The amended query now correctly joins normalized tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE batting_hand = 'left' AND country = 'Australia';",
            "SELECT T2.Player_Name\nFROM Player AS T2\nJOIN Country AS T1 ON T2.Country_Name = T1.Country_Id\nJOIN Batting_Style AS T3 ON T2.Batting_hand = T3.Batting_Id\nWHERE T1.Country_Name = 'Australia'\nAND T3.Batting_hand = 'Right-hand bat'"
        ],
        "rule_sql": []
    },
    "5943": {
        "db_id": "books",
        "question": "What is the cost of the slowest and least expensive shipping method?",
        "ground_truth": "SELECT method_name FROM shipping_method ORDER BY cost ASC LIMIT 1",
        "amends": [
            "Do select `method_name` instead of `MAX(cost)` for the output column. Do query from `shipping_method` instead of `shipping_methods` as the table source. Do remove the WHERE clause with the subquery for `speed = (SELECT MIN(speed) FROM shipping_methods)` instead of keeping that complex filter. Do add `ORDER BY cost ASC` instead of omitting any ordering. Do add `LIMIT 1` instead of using MAX aggregation to find the single cheapest method. The amended query now correctly identifies the shipping method with the lowest cost by ordering and limiting rather than using maximum cost with a subquery filter on minimum speed."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(cost) FROM shipping_methods WHERE speed = (SELECT MIN(speed) FROM shipping_methods);",
            "SELECT method_name FROM shipping_method ORDER BY cost ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5657": {
        "db_id": "shipping",
        "question": "Which headquarter's truck has the highest shipments in year 2016?",
        "ground_truth": "SELECT CASE WHEN T2.make = 'Peterbilt' THEN 'Texas (TX)' WHEN T2.make = 'Mack' THEN 'North Carolina (NC)' WHEN T2.make = 'Kenworth' THEN 'Washington (WA)' END AS \"result\" FROM shipment AS T1 INNER JOIN truck AS T2 ON T1.truck_id = T2.truck_id WHERE CAST(T1.ship_date AS DATE) = 2016 GROUP BY T2.make ORDER BY COUNT(T1.ship_id) DESC LIMIT 1",
        "amends": [
            "Do use `CASE` expression with `T2.make` conditions to derive headquarters names instead of directly selecting `hq_name`. Do join `shipment AS T1` with `truck AS T2` using `INNER JOIN` on `T1.truck_id = T2.truck_id` instead of joining through a headquarters table. Do filter with `CAST(T1.ship_date AS DATE) = 2016` for exact date comparison instead of `YEAR(s.shipment_date) = 2016`. Do group by `T2.make` instead of `hq_name` to aggregate by truck manufacturer. Do order by `COUNT(T1.ship_id)` descending instead of the alias `shipment_count`. Do return the CASE result as \"result\" instead of multiple columns. The amended query now correctly maps truck manufacturers to headquarters locations and counts shipments by make for 2016 date matches.",
            "Do change the CASE statement to handle `'Peterbilt'` mapping to `'Texas (TX)'`, `'Mack'` mapping to `'North Carolina (NC)'`, and `'Kenworth'` mapping to `'Washington (WA)'` instead of the previous mappings for Ford, Chevrolet, Toyota, Honda, Volkswagen, BMW, and Mercedes-Benz. Do remove the ELSE `'Unknown'` clause instead of keeping it. The FROM clause with `INNER JOIN` on `T1.truck_id = T2.truck_id` remains unchanged, as does the WHERE filter on `CAST(T1.ship_date AS DATE) = 2016`, GROUP BY `T2.make`, and ORDER BY `COUNT(T1.ship_id) DESC` with LIMIT 1. The amended query now correctly maps specific truck makes to their corresponding locations as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hq_name, COUNT(*) as shipment_count\nFROM shipments s\nJOIN trucks t ON s.truck_id = t.truck_id\nJOIN headquarters h ON t.hq_id = h.hq_id\nWHERE YEAR(s.shipment_date) = 2016\nGROUP BY hq_name\nORDER BY shipment_count DESC\nLIMIT 1;",
            "SELECT \n    CASE \n        WHEN T2.make = 'Ford' THEN 'Detroit'\n        WHEN T2.make = 'Chevrolet' THEN 'Detroit'\n        WHEN T2.make = 'Toyota' THEN 'Tokyo'\n        WHEN T2.make = 'Honda' THEN 'Tokyo'\n        WHEN T2.make = 'Volkswagen' THEN 'Wolfsburg'\n        WHEN T2.make = 'BMW' THEN 'Munich'\n        WHEN T2.make = 'Mercedes-Benz' THEN 'Stuttgart'\n        ELSE 'Unknown'\n    END AS result\nFROM shipment AS T1\nINNER JOIN truck AS T2 ON T1.truck_id = T2.truck_id\nWHERE CAST(T1.ship_date AS DATE) = 2016\nGROUP BY T2.make\nORDER BY COUNT(T1.ship_id) DESC\nLIMIT 1;",
            "SELECT \n    CASE \n        WHEN T2.make = 'Peterbilt' THEN 'Texas (TX)'\n        WHEN T2.make = 'Mack' THEN 'North Carolina (NC)'\n        WHEN T2.make = 'Kenworth' THEN 'Washington (WA)'\n    END AS result\nFROM shipment AS T1\nINNER JOIN truck AS T2 ON T1.truck_id = T2.truck_id\nWHERE CAST(T1.ship_date AS DATE) = 2016\nGROUP BY T2.make\nORDER BY COUNT(T1.ship_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5185": {
        "db_id": "address",
        "question": "List all the cities with micro CBSA.",
        "ground_truth": "SELECT T2.city FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_type = 'Micro'",
        "amends": [
            "Do select only `city` from `zip_data` instead of selecting all columns with `*` from `cities`. Do join `CBSA` table with `zip_data` using `INNER JOIN` on `CBSA = CBSA` instead of querying a single `cities` table. Do filter on `CBSA_type = 'Micro'` from the `CBSA` table instead of filtering `cbsa_type = 'micro'` from a non-existent table. The amended query now correctly joins the required tables and filters based on the proper CBSA type classification, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cities WHERE cbsa_type = 'micro'",
            "SELECT DISTINCT zd.city \nFROM zip_data zd\nINNER JOIN CBSA c ON zd.CBSA = c.CBSA\nWHERE c.CBSA_type = 'Micro'\nORDER BY zd.city;"
        ],
        "rule_sql": []
    },
    "995": {
        "db_id": "computer_student",
        "question": "For the professor who advised student no.6, please list the IDs of the courses he or she teaches.",
        "ground_truth": "SELECT T2.course_id FROM taughtBy AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id INNER JOIN advisedBy AS T3 ON T3.p_id = T1.p_id WHERE T1.p_id = 9",
        "amends": [
            "Do use explicit table aliases `T2.course_id` instead of just `course_id` in the SELECT list. Do join multiple tables `taughtBy AS T1`, `course AS T2`, and `advisedBy AS T3` instead of querying only the `courses` table. Do use `INNER JOIN` with proper join conditions `T1.course_id = T2.course_id` and `T3.p_id = T1.p_id` instead of a subquery with `professor_id = (SELECT advisor_id FROM students WHERE student_id = 6)`. Do filter on `T1.p_id = 9` instead of using a subquery to match professor IDs. Do remove the subquery correlation entirely instead of maintaining nested query logic. The amended query now correctly joins the taughtBy, course, and advisedBy tables to find courses taught by a specific professor with ID 9, matching the RIGHT_SQL's behavior.",
            "Do filter on `T1.p_id = 9` instead of `T3.p_id_dummy = 6` in the WHERE clause, correcting the table reference and column name to properly filter based on the professor ID from the taughtBy table rather than using a non-existent column from advisedBy. The amended query now matches RIGHT_SQL's behavior by fixing the predicate to use the correct table and column for the intended filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id FROM courses WHERE professor_id = (SELECT advisor_id FROM students WHERE student_id = 6);",
            "SELECT T2.course_id\nFROM taughtBy AS T1\nINNER JOIN course AS T2 ON T1.course_id = T2.course_id\nINNER JOIN advisedBy AS T3 ON T3.p_id = T1.p_id\nWHERE T3.p_id_dummy = 6",
            "SELECT T2.course_id\nFROM taughtBy AS T1\nINNER JOIN course AS T2 ON T1.course_id = T2.course_id\nINNER JOIN advisedBy AS T3 ON T3.p_id = T1.p_id\nWHERE T1.p_id = 9"
        ],
        "rule_sql": []
    },
    "8514": {
        "db_id": "software_company",
        "question": "Among the customers over 30, how many of them are Machine-op-inspcts?",
        "ground_truth": "SELECT COUNT(ID) FROM Customers WHERE OCCUPATION = 'Machine-op-inspct' AND age > 30",
        "amends": [
            "Do count `ID` instead of `*` to count specific non-null values rather than all rows. Do reference table `Customers` instead of `customers` to match the correct case sensitivity. Do place the `OCCUPATION` filter before the `age` filter instead of after it, though this is a cosmetic ordering change that doesn't affect results. Do use the exact occupation value `'Machine-op-inspct'` instead of `'Machine-op-inspcts'` to match the correct spelling in the database. The amended query now correctly counts customers with the specific occupation spelling and age criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE age > 30 AND occupation = 'Machine-op-inspcts';",
            "SELECT COUNT(ID) FROM Customers WHERE OCCUPATION = 'Machine-op-inspct' AND age > 30;"
        ],
        "rule_sql": []
    },
    "5982": {
        "db_id": "books",
        "question": "How many books were published in Japanese?",
        "ground_truth": "SELECT COUNT(T2.book_id) FROM book_language AS T1 INNER JOIN book AS T2 ON T1.language_id = T2.language_id WHERE T1.language_name = 'Japanese'",
        "amends": [
            "Do join `book_language AS T1` with `book AS T2` on `T1.language_id = T2.language_id` instead of querying only the `books` table. Do filter on `T1.language_name = 'Japanese'` instead of `language = 'Japanese'`. Do count `T2.book_id` instead of `COUNT(*)` to accurately count books in the specified language. The amended query now correctly joins the language and book tables to count books by language name rather than assuming a language column exists in the books table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE language = 'Japanese';",
            "SELECT COUNT(T2.book_id) \nFROM book_language AS T1 \nJOIN book AS T2 ON T1.language_id = T2.language_id \nWHERE T1.language_name = 'Japanese'"
        ],
        "rule_sql": []
    },
    "2767": {
        "db_id": "european_football_1",
        "question": "Who is the winner of the game happened on 2009/10/10, between \"East Fife\" and \"Dumbarton\"?",
        "ground_truth": "SELECT CASE WHEN FTR = 'H' THEN 'East Fife' ELSE 'Dumbarton' END WINNER FROM matchs WHERE Date = '2009-10-10' AND HomeTeam = 'East Fife' AND AwayTeam = 'Dumbarton'",
        "amends": [
            "Do use `CASE WHEN FTR = 'H' THEN 'East Fife' ELSE 'Dumbarton' END` as the winner calculation instead of directly selecting `winner`. Do reference table `matchs` instead of `games`. Do filter with `Date = '2009-10-10'` using hyphen date format instead of `date = '2009/10/10'` with slash format. Do use `HomeTeam = 'East Fife'` and `AwayTeam = 'Dumbarton'` with AND conjunction instead of `(home_team = 'East Fife' OR away_team = 'Dumbarton')` with OR logic. The amended query now correctly identifies the winner based on match result rather than assuming team presence determines victory."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner FROM games WHERE date = '2009/10/10' AND (home_team = 'East Fife' OR away_team = 'Dumbarton')",
            "SELECT \n    CASE \n        WHEN FTR = 'H' THEN 'East Fife' \n        WHEN FTR = 'A' THEN 'Dumbarton' \n        ELSE 'Draw' \n    END AS winner\nFROM matchs \nWHERE Date = '2009-10-10' \n    AND HomeTeam = 'East Fife' \n    AND AwayTeam = 'Dumbarton'"
        ],
        "rule_sql": []
    },
    "6129": {
        "db_id": "food_inspection_2",
        "question": "How many \"food maintenance\" related violations did inspection no.1454071 have?",
        "ground_truth": "SELECT COUNT(T2.point_id) FROM inspection_point AS T1 INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE T2.inspection_id = '1454071' AND T1.category = 'Food Maintenance'",
        "amends": [
            "Do select `COUNT(T2.point_id)` from specific table columns instead of `COUNT(*)` from all rows. Do use `INNER JOIN` between `inspection_point AS T1` and `violation AS T2` on `T1.point_id = T2.point_id` instead of querying only the `violations` table. Do add table alias `T2` for the `violation` table instead of using the base table name. Do filter with `T2.inspection_id = '1454071'` as a string instead of numeric comparison. Do add the condition `T1.category = 'Food Maintenance'` instead of using `LIKE '%food%' OR violation_description LIKE '%maintenance%'` pattern matching. The amended query now correctly joins related tables and uses precise category filtering instead of unreliable text pattern matching, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM violations WHERE inspection_id = 1454071 AND violation_description LIKE '%food%' OR violation_description LIKE '%maintenance%';",
            "SELECT COUNT(T2.point_id) \nFROM inspection_point AS T1 \nINNER JOIN violation AS T2 ON T1.point_id = T2.point_id \nWHERE T2.inspection_id = '1454071' \nAND T1.category = 'Food Maintenance'"
        ],
        "rule_sql": []
    },
    "5067": {
        "db_id": "olympics",
        "question": "In which city was the game held where the oldest competitor participated?",
        "ground_truth": "SELECT T4.city_name FROM games_competitor AS T1 INNER JOIN games AS T2 ON T1.games_id = T2.id INNER JOIN games_city AS T3 ON T1.games_id = T3.games_id INNER JOIN city AS T4 ON T3.city_id = T4.id ORDER BY T1.age DESC LIMIT 1",
        "amends": [
            "Do select `T4.city_name` instead of `city`. Do use `games_competitor AS T1` instead of `competitors`. Do change join from `JOIN competitors ON games.game_id = competitors.game_id` to `INNER JOIN games AS T2 ON T1.games_id = T2.id` with proper table aliases. Do add two additional joins: `INNER JOIN games_city AS T3 ON T1.games_id = T3.games_id` and `INNER JOIN city AS T4 ON T3.city_id = T4.id` instead of omitting them. Do change sort order to `ORDER BY T1.age DESC` instead of `ORDER BY competitors.age ASC`. The amended query now correctly joins through the proper relationship tables to access city data and uses the appropriate sort direction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM games JOIN competitors ON games.game_id = competitors.game_id ORDER BY competitors.age ASC LIMIT 1;",
            "SELECT T4.city_name\nFROM games_competitor AS T1\nINNER JOIN games AS T2 ON T1.games_id = T2.id\nINNER JOIN games_city AS T3 ON T1.games_id = T3.games_id\nINNER JOIN city AS T4 ON T3.city_id = T4.id\nORDER BY T1.age DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3371": {
        "db_id": "video_games",
        "question": "Give the name of the publisher of the game ID 75.",
        "ground_truth": "SELECT T2.publisher_name FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.game_id = 75",
        "amends": [
            "Do select `T2.publisher_name` instead of `game_name` from a different table. Do join `game_publisher AS T1` and `publisher AS T2` with an `INNER JOIN` on `T1.publisher_id = T2.id` instead of querying only the `games` table. Do filter on `T1.game_id = 75` instead of `game_id = 75` to reference the correct table in the join. The amended query now correctly retrieves publisher information through proper table relationships instead of attempting to get it directly from the games table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE game_id = 75;",
            "SELECT T2.publisher_name \nFROM game_publisher AS T1 \nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id \nWHERE T1.game_id = 75"
        ],
        "rule_sql": []
    },
    "4334": {
        "db_id": "simpson_episodes",
        "question": "How many awards classified as \"Primetime Emmy\" category?",
        "ground_truth": "SELECT COUNT(award_id) FROM Award WHERE award_category = 'Primetime Emmy';",
        "amends": [
            "Do reference the `award_id` column instead of `COUNT(*)` for counting specific non-null values. Do use the correct table name `Award` instead of `awards` to match the schema. Do filter on `award_category = 'Primetime Emmy'` instead of `category = 'Emmy Award'` to use the proper column name and exact category value. The amended query now correctly counts non-null award IDs from the Award table for Primetime Emmy awards, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE category = 'Emmy Award'",
            "SELECT COUNT(award_id) FROM Award WHERE award_category = 'Primetime Emmy';"
        ],
        "rule_sql": []
    },
    "2206": {
        "db_id": "world_development_indicators",
        "question": "What proportion of Sub-Saharan Africa's countries have lower middle incomes?",
        "ground_truth": "SELECT SUM(CASE WHEN IncomeGroup = 'Lower middle income' THEN 1 ELSE 0 END) * 100.0 / COUNT(CountryCode) persentage FROM Country WHERE Region = 'Sub-Saharan Africa'",
        "amends": [
            "Do use `SUM(CASE WHEN IncomeGroup = 'Lower middle income' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to correctly calculate the proportion of specific income groups. Do reference `IncomeGroup` instead of `income_group` and `Region` instead of `region` to match the correct column names. Do use `COUNT(CountryCode)` instead of a subquery `(SELECT COUNT(*) FROM countries WHERE region = 'Sub-Saharan Africa')` for the denominator calculation. Do reference table `Country` instead of `countries` and use column `CountryCode` instead of generic count for more precise counting. Do rename the result column to `persentage` instead of `proportion` as specified. The amended query now correctly calculates the percentage of Lower middle income countries within the Sub-Saharan Africa region using proper conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM countries WHERE region = 'Sub-Saharan Africa') AS proportion\nFROM countries \nWHERE region = 'Sub-Saharan Africa' AND income_group = 'Lower middle income';",
            "SELECT \n    (SUM(CASE WHEN IncomeGroup = 'Lower middle income' THEN 1 ELSE 0 END) * 100.0 / COUNT(CountryCode)) AS persentage\nFROM \n    Country\nWHERE \n    Region = 'Sub-Saharan Africa';"
        ],
        "rule_sql": []
    },
    "6041": {
        "db_id": "books",
        "question": "How many books under 300 pages has HarperCollins Publishers published?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'HarperCollins Publishers' AND T1.num_pages < 300",
        "amends": [
            "Do join `book AS T1` with `publisher AS T2` on `T1.publisher_id = T2.publisher_id` instead of querying the `books` table directly without proper table relationships. Do filter on `T2.publisher_name = 'HarperCollins Publishers'` instead of using `publisher` column directly from the books table. Do use `T1.num_pages < 300` instead of `pages > 300` to correctly filter for books with fewer than 300 pages rather than more than 300 pages. The amended query now properly joins the normalized tables and applies the correct page count filter to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher = 'HarperCollins Publishers' AND pages > 300;",
            "SELECT COUNT(*) \nFROM book AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id\nWHERE T2.publisher_name = 'HarperCollins Publishers' \nAND T1.num_pages < 300"
        ],
        "rule_sql": []
    },
    "3247": {
        "db_id": "donor",
        "question": "Write down the need statement of Family History Project.",
        "ground_truth": "SELECT need_statement FROM essays WHERE title = 'Family History Project'",
        "amends": [
            "Do select only `need_statement` instead of all columns with `*`. Do query from `essays` table instead of `family_history` table. Do filter on `title = 'Family History Project'` instead of `project = 'Family History Project'` and remove the `need_statement IS NULL` condition. The amended query now correctly retrieves the need_statement from the essays table where the title matches the specified project name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM family_history WHERE project = 'Family History Project' AND need_statement IS NULL;",
            "SELECT need_statement FROM essays WHERE title = 'Family History Project'"
        ],
        "rule_sql": []
    },
    "6135": {
        "db_id": "food_inspection_2",
        "question": "Show the phone number of the sanitarian who was responsible for inspection no.634597.",
        "ground_truth": "SELECT T2.phone FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE T1.inspection_id = 634597 AND T2.title = 'Sanitarian'",
        "amends": [
            "Do select `phone` from the `employee` table instead of `phone_number` from the `sanitarian` table. Do join `inspection` with `employee` using `employee_id` instead of querying a single table. Do add filter `title = 'Sanitarian'` to ensure only sanitarian employees are selected instead of omitting this qualification. The amended query now correctly retrieves phone numbers from the employee table with proper join conditions and role filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM sanitarian WHERE inspection_id = 634597",
            "SELECT e.phone \nFROM employee e\nJOIN inspection i ON e.employee_id = i.employee_id\nWHERE i.inspection_id = 634597\nAND e.title = 'Sanitarian';"
        ],
        "rule_sql": []
    },
    "5834": {
        "db_id": "airline",
        "question": "Among the flights operated by American Airlines Inc. on 2018/8/1, how many of them were cancelled?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.CANCELLED = 1 THEN 1 ELSE 0 END) AS count FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN `Air Carriers` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE T2.FL_DATE = '2018/8/1' AND T3.Description = 'American Airlines Inc.: AA'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.CANCELLED = 1 THEN 1 ELSE 0 END) AS count` instead of `COUNT(*)` to count only cancelled flights. Do join `Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN` instead of querying a single `flights` table. Do add `INNER JOIN \\`Air Carriers\\` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code` to connect to carrier information. Do filter with `T3.Description = 'American Airlines Inc.: AA'` instead of `airline = 'American Airlines Inc.'` to use the proper carrier identifier. Do use `T2.FL_DATE = '2018/8/1'` instead of `date = '2018/8/1'` with the correct date column name. Do remove the explicit `status = 'cancelled'` filter instead of keeping it, as cancellation status is now handled through the `CANCELLED` flag in the conditional sum. The amended query now correctly counts cancelled American Airlines flights from August 1, 2018 by properly joining the necessary tables and using the appropriate cancellation indicator."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE airline = 'American Airlines Inc.' AND date = '2018/8/1' AND status = 'cancelled';",
            "SELECT SUM(CASE WHEN T2.CANCELLED = 1 THEN 1 ELSE 0 END) AS count\nFROM Airlines AS T2\nINNER JOIN \"Air Carriers\" AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code\nWHERE T3.Description = 'American Airlines Inc.: AA'\nAND T2.FL_DATE = '2018/8/1'"
        ],
        "rule_sql": []
    },
    "6803": {
        "db_id": "retails",
        "question": "What is the total price and the order priority of order number 33?",
        "ground_truth": "SELECT o_totalprice, o_orderpriority FROM orders WHERE o_orderkey = 33",
        "amends": [
            "Do use column `o_totalprice` instead of `total_price` in the SELECT list. Do use column `o_orderpriority` instead of `order_priority` in the SELECT list. Do use filter condition `o_orderkey = 33` instead of `order_number = 33` in the WHERE clause. The amended query now correctly references the actual column names in the schema and matches the intended behavior of filtering by order key rather than order number."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT total_price, order_priority FROM orders WHERE order_number = 33;",
            "SELECT o_totalprice, o_orderpriority FROM orders WHERE o_orderkey = 33;"
        ],
        "rule_sql": []
    },
    "8390": {
        "db_id": "mondial_geo",
        "question": "What is the total number of cities that Japan have?",
        "ground_truth": "SELECT COUNT(T3.Name) FROM country AS T1 INNER JOIN province AS T2 ON T1.Code = T2.Country INNER JOIN city AS T3 ON T3.Province = T2.Name WHERE T1.Name = 'Japan'",
        "amends": [
            "Do add joins to `country`, `province`, and `city` tables instead of querying only `countries`. Do use `INNER JOIN` on `T1.Code = T2.Country` and `T3.Province = T2.Name` instead of no joins. Do change the filter to `T1.Name = 'Japan'` instead of `country_name = 'Japan'`. Do count `T3.Name` instead of `COUNT(*)` to count cities in Japan. Do remove the single table query structure instead of keeping it. The amended query now correctly counts cities in Japan by joining through the country-province-city hierarchy."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE country_name = 'Japan';",
            "SELECT COUNT(T3.Name) \nFROM country T1\nINNER JOIN province T2 ON T1.Code = T2.Country\nINNER JOIN city T3 ON T2.Name = T3.Province AND T2.Country = T3.Country\nWHERE T1.Name = 'Japan'"
        ],
        "rule_sql": []
    },
    "1507": {
        "db_id": "synthea",
        "question": "Mention the description of the care plan of American patients.",
        "ground_truth": "SELECT DISTINCT T1.DESCRIPTION FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.ethnicity = 'american'",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it. Do change the source table from `care_plans` to `careplans AS T1` instead of using the original table name. Do add `INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient` instead of querying a single table. Do change the filter condition to `T2.ethnicity = 'american'` instead of `nationality = 'American'`. Do reference the description column as `T1.DESCRIPTION` instead of just `description`. The amended query now correctly joins patient data and filters by ethnicity rather than nationality, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM care_plans WHERE nationality = 'American';",
            "SELECT DISTINCT T1.DESCRIPTION FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.ethnicity = 'american'"
        ],
        "rule_sql": []
    },
    "9177": {
        "db_id": "movie_3",
        "question": "How much is the total rental payment for the first 10 rentals?",
        "ground_truth": "SELECT SUM(amount) FROM payment WHERE rental_id BETWEEN 1 AND 10",
        "amends": [
            "Do query the `payment` table instead of the `rental` table. Do add a `WHERE` filter on `rental_id BETWEEN 1 AND 10` instead of omitting any filtering condition. Do remove the `LIMIT 10` clause instead of keeping it, as the aggregation should be calculated over the filtered payment records rather than limiting the result set after aggregation. The amended query now correctly calculates the sum of payment amounts for rentals 1 through 10 instead of attempting to sum amounts from the rental table directly with an incorrect limit clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM rental LIMIT 10;",
            "SELECT SUM(amount) AS total_payment FROM payment WHERE rental_id BETWEEN 1 AND 10;"
        ],
        "rule_sql": []
    },
    "1713": {
        "db_id": "restaurant",
        "question": "What is the name of the Chinese restaurant that can be found at 104 San Tomas Aquino Road, Campbell?",
        "ground_truth": "SELECT T1.label FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_num = 104 AND T1.city = 'campbell' AND T2.street_name = 'san tomas aquino road'",
        "amends": [
            "Do select `T1.label` from the `generalinfo` table instead of `name` from the `restaurants` table. Do use an `INNER JOIN` with the `location` table on `T1.id_restaurant = T2.id_restaurant` instead of querying a single table. Do filter on `T2.street_num = 104` and `T2.street_name = 'san tomas aquino road'` instead of a combined `address` field. Do add `T1.city = 'campbell'` instead of omitting city filtering. Do remove the `cuisine = 'Italian'` condition instead of keeping it. The amended query now correctly joins normalized tables and uses proper address component filtering instead of a combined address string."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE address = '104 San Tomas Aquino Road, Campbell' AND cuisine = 'Italian';",
            "SELECT T1.label \nFROM generalinfo T1\nINNER JOIN location T2 ON T1.id_restaurant = T2.id_restaurant\nWHERE T1.food_type = 'Chinese'\nAND T2.street_num = 104\nAND T2.street_name = 'San Tomas Aquino Road'\nAND T1.city = 'Campbell';"
        ],
        "rule_sql": []
    },
    "1019": {
        "db_id": "computer_student",
        "question": "Among the students being advised by Advisor 5, how many students are in the 5th year?",
        "ground_truth": "SELECT COUNT(*) FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T1.p_id_dummy = 5 AND T2.student = 1 AND T2.yearsInProgram = 'Year_5'",
        "amends": [
            "Do join `advisedBy AS T1` and `person AS T2` with `INNER JOIN` on `T1.p_id = T2.p_id` instead of querying only the `students` table. Do filter on `T1.p_id_dummy = 5` instead of `advisor_id = 5` and use `T2.yearsInProgram = 'Year_5'` instead of `year = 5`. Do add the condition `T2.student = 1` instead of omitting it to ensure only student records are counted. The amended query now correctly matches the intended behavior by properly joining the advisor-student relationship tables and filtering for specific student attributes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE advisor_id = 5 AND year = 5;",
            "SELECT COUNT(*) \nFROM advisedBy AS T1 \nINNER JOIN person AS T2 ON T1.p_id = T2.p_id \nWHERE T1.p_id_dummy = 5 \nAND T2.student = 1 \nAND T2.yearsInProgram = 'Year_5'"
        ],
        "rule_sql": []
    },
    "8721": {
        "db_id": "chicago_crime",
        "question": "In the least populated community, what is the most common location of all the reported crime incidents?",
        "ground_truth": "SELECT T2.location_description FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.population = ( SELECT MIN(population) FROM Community_Area ) AND T2.location_description IS NOT NULL GROUP BY T2.location_description",
        "amends": [
            "Do use `T2.location_description` in the SELECT list instead of `location` and remove the `COUNT(*) as crime_count` aggregation. Do change the FROM source to `Community_Area AS T1 INNER JOIN Crime AS T2` instead of just `crime_incidents` and add the join condition `ON T1.community_area_no = T2.community_area_no`. Do add a WHERE clause with `T1.population = (SELECT MIN(population) FROM Community_Area)` and `T2.location_description IS NOT NULL` instead of no filters. Do remove the ORDER BY and LIMIT clauses instead of keeping them. Do add GROUP BY `T2.location_description` instead of grouping by just `location`. The amended query now correctly finds location descriptions in the community area with minimum population rather than simply counting crimes by location."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) as crime_count \nFROM crime_incidents \nGROUP BY location \nORDER BY crime_count DESC \nLIMIT 1;",
            "SELECT T2.location_description\nFROM Community_Area AS T1\nINNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no\nWHERE T1.population = (SELECT MIN(population) FROM Community_Area)\nAND T2.location_description IS NOT NULL\nGROUP BY T2.location_description"
        ],
        "rule_sql": []
    },
    "1184": {
        "db_id": "talkingdata",
        "question": "How many devices belong to model \"A51\"?",
        "ground_truth": "SELECT COUNT(device_id) FROM phone_brand_device_model2 WHERE device_model = 'A51'",
        "amends": [
            "Do select `COUNT(device_id)` instead of `COUNT(*)` to count specific non-null values. Do reference table `phone_brand_device_model2` instead of `devices` as the correct data source. Do filter on column `device_model` instead of `model` to use the proper column name for device model filtering. The amended query now correctly counts devices with model 'A51' from the appropriate table using the correct column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM devices WHERE model = 'A51';",
            "SELECT COUNT(device_id) FROM phone_brand_device_model2 WHERE device_model = 'A51'"
        ],
        "rule_sql": []
    },
    "2403": {
        "db_id": "superstore",
        "question": "How many orders in the south superstore with the fastest delivery are items of furniture?",
        "ground_truth": "SELECT COUNT(T1.`Order ID`) FROM south_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.`Ship Mode` = 'First Class' AND T2.Category = 'Furniture'",
        "amends": [
            "Do `COUNT(T1.Order ID)` instead of `COUNT(*)` to count specific non-null order identifiers rather than all rows. Do use table aliases `south_superstore AS T1` and `product AS T2` instead of `orders o` and `products p` with corrected table names. Do join on `T1.Product ID = T2.Product ID` instead of `o.product_id = p.product_id` with proper column naming. Do filter with `T1.Ship Mode = 'First Class'` instead of `o.region = 'South' AND o.store = 'Superstore'` to use the correct shipping mode condition. Do remove `ORDER BY o.delivery_time ASC LIMIT 1` instead of keeping the ordering and limiting since the count aggregation should return a single row without sorting. The amended query now correctly counts furniture orders shipped via first class from the south superstore.",
            "Do use backticks for column names like `Order ID` and `Ship Mode` instead of double quotes to ensure proper identifier quoting. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly counts orders with First Class shipping for Furniture products through proper table joining and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM orders o\nJOIN products p ON o.product_id = p.product_id\nWHERE o.region = 'South' \nAND o.store = 'Superstore'\nAND p.category = 'Furniture'\nORDER BY o.delivery_time ASC\nLIMIT 1;",
            "SELECT COUNT(T1.\"Order ID\") \nFROM south_superstore AS T1\nJOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\"\nWHERE T1.Ship Mode = 'First Class'\nAND T2.Category = 'Furniture'",
            "SELECT COUNT(T1.`Order ID`)\nFROM south_superstore AS T1\nINNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID`\nWHERE T1.`Ship Mode` = 'First Class'\nAND T2.Category = 'Furniture'"
        ],
        "rule_sql": []
    },
    "2180": {
        "db_id": "world_development_indicators",
        "question": "Name the country with fastest growth in adjusted net national income in 1980 and state the currency used by this country.",
        "ground_truth": "SELECT T2.countryname, T1.CurrencyUnit FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.IndicatorName = 'Adjusted net national income (annual % growth)' AND T2.Year = 1980 AND T1.CurrencyUnit != '' ORDER BY T2.Value DESC LIMIT 1",
        "amends": [
            "Do select `T2.countryname` and `T1.CurrencyUnit` instead of `country` and `currency`. Do join `Country AS T1` with `Indicators AS T2` using `INNER JOIN` on `T1.CountryCode = T2.CountryCode` instead of querying only `national_income`. Do add filter `T2.IndicatorName = 'Adjusted net national income (annual % growth)'` instead of omitting it. Do keep `T2.Year = 1980` filter but add `T1.CurrencyUnit != ''` condition instead of having no currency filter. Do order by `T2.Value DESC` instead of `growth_rate DESC`. The amended query now correctly joins country and indicator data, filters for the specific income growth metric, excludes empty currency values, and sorts by the actual value column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, currency FROM national_income WHERE year = 1980 ORDER BY growth_rate DESC LIMIT 1;",
            "SELECT T2.CountryName, T1.CurrencyUnit\nFROM Country AS T1\nINNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.IndicatorName = 'Adjusted net national income (annual % growth)'\nAND T2.Year = 1980\nAND T1.CurrencyUnit != ''\nORDER BY T2.Value DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2970": {
        "db_id": "shakespeare",
        "question": "Give the abbreviation name for the character \"Earl of Westmoreland\".",
        "ground_truth": "SELECT DISTINCT Abbrev FROM characters WHERE CharName = 'Earl of Westmoreland'",
        "amends": [
            "Do select `Abbrev` instead of `name` and add `DISTINCT` instead of omitting it. Do filter on `CharName` instead of `abbreviation` while keeping the same literal value 'Earl of Westmoreland'. The amended query now correctly retrieves distinct abbreviations from the characters table based on character name matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM characters WHERE abbreviation = 'Earl of Westmoreland';",
            "SELECT DISTINCT Abbrev FROM characters WHERE CharName = 'Earl of Westmoreland';"
        ],
        "rule_sql": []
    },
    "1107": {
        "db_id": "talkingdata",
        "question": "List at least 10 device models that male users over the age of 39 usually use.",
        "ground_truth": "SELECT T1.device_model FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T2.`group` = 'M39+' AND T2.gender = 'M' LIMIT 10",
        "amends": [
            "Do select `T1.device_model` from the `phone_brand_device_model2` table instead of `device_model` from the `users` table. Do join with `gender_age AS T2` using `T1.device_id = T2.device_id` instead of querying a single table. Do filter on `T2.group = 'M39+'` and `T2.gender = 'M'` instead of `gender = 'male' AND age > 39`. The amended query now correctly joins the device and demographic tables using proper foreign key relationships and uses the standardized group classification 'M39+' instead of raw age filtering, matching the intended behavior.",
            "Do use backticks around the reserved keyword `group` in the WHERE clause instead of using it unquoted. Do maintain the same JOIN type with `INNER JOIN` instead of the implicit JOIN. Do keep the same SELECT list with `device_model`, FROM sources with `phone_brand_device_model2` and `gender_age`, join condition with `T1.device_id = T2.device_id`, WHERE filters with `gender = 'M'` and `group = 'M39+'`, and LIMIT clause with `10`. Do remove the unnecessary `GROUP BY T1.device_model` clause instead of keeping it since there are no aggregate functions in the SELECT list. The amended query now matches RIGHT_SQL's behavior by properly quoting the reserved word and eliminating the redundant grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_model FROM users WHERE gender = 'male' AND age > 39 LIMIT 10;",
            "SELECT T1.device_model\nFROM phone_brand_device_model2 AS T1\nJOIN gender_age AS T2 ON T1.device_id = T2.device_id\nWHERE T2.gender = 'M' AND T2.group = 'M39+'\nGROUP BY T1.device_model\nLIMIT 10;",
            "SELECT T1.device_model\nFROM phone_brand_device_model2 AS T1\nINNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id\nWHERE T2.gender = 'M' AND T2.`group` = 'M39+'\nLIMIT 10"
        ],
        "rule_sql": []
    },
    "1375": {
        "db_id": "synthea",
        "question": "Why did Mrs. Annabelle Pouros take leucovorin 100 mg injection on 1970/12/19? State the reason.",
        "ground_truth": "SELECT T2.reasondescription FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mrs.' AND T1.first = 'Annabelle' AND T1.last = 'Pouros' AND T2.start = '1970-12-19' AND T2.description = 'Leucovorin 100 MG Injection'",
        "amends": [
            "Do select `reasondescription` from the `medications` table instead of `reason` from a single table. Do join `patients` as `T1` with `medications` as `T2` on `T1.patient = T2.PATIENT` instead of querying only the `medications` table. Do filter by `T1.prefix = 'Mrs.'` and `T1.first = 'Annabelle'` and `T1.last = 'Pouros'` instead of `patient_name = 'Mrs. Annabelle Pouros'`. Do filter by `T2.start = '1970-12-19'` with hyphen date format instead of `date = '1970/12/19'` with slash format. Do filter by `T2.description = 'Leucovorin 100 MG Injection'` with proper medication description format instead of separate `medication = 'leucovorin'` and `dosage = '100 mg injection'` filters. The amended query now correctly joins patient and medication data with proper field matching and standardized formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reason FROM medications WHERE patient_name = 'Mrs. Annabelle Pouros' AND medication = 'leucovorin' AND dosage = '100 mg injection' AND date = '1970/12/19';",
            "SELECT T2.REASONDESCRIPTION \nFROM patients T1\nJOIN medications T2 ON T1.patient = T2.PATIENT\nWHERE T1.prefix = 'Mrs.' \nAND T1.first = 'Annabelle' \nAND T1.last = 'Pouros'\nAND T2.START = '1970-12-19'\nAND T2.DESCRIPTION = 'Leucovorin 100 MG Injection'"
        ],
        "rule_sql": []
    },
    "9340": {
        "db_id": "movie_3",
        "question": "List down all of the film IDs with highest rental duration.",
        "ground_truth": "SELECT film_id FROM film WHERE rental_duration = ( SELECT MAX(rental_duration) FROM film )",
        "amends": [
            "Do use a subquery to find the maximum rental_duration value instead of ordering and limiting. Do filter with WHERE rental_duration = (subquery) instead of using ORDER BY rental_duration ASC LIMIT 1. Do remove the ORDER BY and LIMIT clauses instead of keeping them, as the subquery approach correctly identifies films with the maximum rental duration rather than just the single minimum duration film. The amended query now matches RIGHT_SQL's behavior by returning all films with the maximum rental duration value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT film_id FROM film ORDER BY rental_duration ASC LIMIT 1;",
            "SELECT film_id FROM film WHERE rental_duration = (SELECT MAX(rental_duration) FROM film)"
        ],
        "rule_sql": []
    },
    "2127": {
        "db_id": "world_development_indicators",
        "question": "How many low income countries are there in South Asia?",
        "ground_truth": "SELECT COUNT(CountryCode) FROM Country WHERE Region = 'South Asia' AND IncomeGroup = 'Low income'",
        "amends": [
            "Do reference the correct table name `Country` instead of `countries`. Do use the correct column name `CountryCode` in the COUNT function instead of `*`. Do use the correct column name `Region` instead of `region`. Do use the correct column name `IncomeGroup` instead of `income_level`. The amended query now correctly counts countries in the South Asia region with low income level using the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE region = 'South Asia' AND income_level = 'Low income';",
            "SELECT COUNT(CountryCode) FROM Country WHERE Region = 'South Asia' AND IncomeGroup = 'Low income';"
        ],
        "rule_sql": []
    },
    "6029": {
        "db_id": "books",
        "question": "How many books were ordered in the last month of the year 2020?",
        "ground_truth": "SELECT COUNT(*) FROM cust_order WHERE order_date LIKE '2020-12%'",
        "amends": [
            "Do reference table `cust_order` instead of `orders` in the FROM clause, as the correct table name is cust_order rather than orders. The amended query now correctly counts records from the cust_order table for December 2020 orders, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE order_date LIKE '2020-12%';",
            "SELECT COUNT(*) AS book_count\nFROM cust_order co\nJOIN order_line ol ON co.order_id = ol.order_id\nWHERE strftime('%Y-%m', co.order_date) = '2020-12'"
        ],
        "rule_sql": []
    },
    "3636": {
        "db_id": "authors",
        "question": "What is the percentage of preprints of John Van Reenen's papers?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.ConferenceId = 0 AND T1.JournalId = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T2.Name = 'John Van Reenen'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN T1.ConferenceId = 0 AND T1.JournalId = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id)` instead of `(COUNT(CASE WHEN p.preprint = 1 THEN 1 END) * 100.0 / COUNT(*))` for the percentage calculation. Do join `PaperAuthor AS T2` instead of `authors a` and use `INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` instead of `JOIN authors a ON p.author_id = a.author_id`. Do filter on `T2.Name = 'John Van Reenen'` instead of `a.name = 'John Van Reenen'` and use the correct table alias. Do reference `T1.Id` in the count instead of `*` for precise counting. The amended query now correctly identifies preprints by checking both ConferenceId and JournalId being zero instead of relying on a preprint flag, and properly joins through the PaperAuthor table to filter by author name.",
            "Do remove the multiplication by `100.0` and the alias `PercentagePreprints` instead of including them, as the right query calculates a ratio rather than a percentage. Do maintain the same `SELECT` expression with `CAST`, `SUM` of the conditional case, and division by `COUNT(T1.Id)` instead of altering the core calculation logic. Do preserve the `FROM` clause with `Paper AS T1` and the `INNER JOIN` on `PaperAuthor AS T2` with the same join condition `T1.Id = T2.PaperId`. Do keep the `WHERE` filter on `T2.Name = 'John Van Reenen'` unchanged. The amended query now correctly computes the proportion of preprints without converting to percentage, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.preprint = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_preprints\nFROM papers p\nJOIN authors a ON p.author_id = a.author_id\nWHERE a.name = 'John Van Reenen';",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.ConferenceId = 0 AND T1.JournalId = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id)) * 100.0 AS PercentagePreprints\nFROM \n    Paper AS T1\nINNER JOIN \n    PaperAuthor AS T2 ON T1.Id = T2.PaperId\nWHERE \n    T2.Name = 'John Van Reenen';",
            "SELECT CAST(SUM(CASE WHEN T1.ConferenceId = 0 AND T1.JournalId = 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id)\nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nWHERE T2.Name = 'John Van Reenen';"
        ],
        "rule_sql": []
    },
    "1157": {
        "db_id": "talkingdata",
        "question": "Which category has more app users, Securities or Finance?",
        "ground_truth": "SELECT IIF(SUM(IIF(T2.category = 'Securities', 1, 0)) - SUM(IIF(T2.category = 'Finance', 1, 0)) > 0, 'Securities', 'Finance') AS diff FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id",
        "amends": [
            "Do use `IIF` conditional expressions to compare category counts instead of a simple `COUNT(*)` aggregation. Do join `app_labels` and `label_categories` tables on `label_id` instead of querying a single `apps` table. Do calculate the difference between 'Securities' and 'Finance' counts using `SUM(IIF(...))` expressions instead of grouping by category. Do return a single row with the dominant category name instead of limiting grouped results. Do remove the `GROUP BY`, `ORDER BY`, and `LIMIT` clauses since the logic now uses conditional aggregation. The amended query now correctly identifies which category has more occurrences by comparing their counts directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(*) as user_count FROM apps WHERE category IN ('Securities', 'Finance') GROUP BY category ORDER BY user_count DESC LIMIT 1;",
            "SELECT \n    IIF(\n        SUM(IIF(lc.category = 'Securities', 1, 0)) > SUM(IIF(lc.category = 'Finance', 1, 0)),\n        'Securities',\n        'Finance'\n    ) AS dominant_category\nFROM \n    app_labels al\nJOIN \n    label_categories lc ON al.label_id = lc.label_id\nWHERE \n    lc.category IN ('Securities', 'Finance')"
        ],
        "rule_sql": []
    },
    "7465": {
        "db_id": "works_cycles",
        "question": "What is the profit for the product \"792\"?",
        "ground_truth": "SELECT T1.ListPrice - T2.StandardCost FROM ProductListPriceHistory AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductID = 792",
        "amends": [
            "Do select the expression `T1.ListPrice - T2.StandardCost` instead of `SUM(price * quantity)` and remove the alias `profit` instead of keeping it. Do use tables `ProductListPriceHistory AS T1` and `ProductCostHistory AS T2` with an `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of a single table `sales`. Do keep the filter `WHERE T1.ProductID = 792` but apply it to the joined tables instead of the original single table. The amended query now correctly calculates profit by subtracting standard cost from list price for the specific product across related history tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price * quantity) AS profit FROM sales WHERE product_id = 792",
            "SELECT T1.ListPrice - T2.StandardCost FROM ProductListPriceHistory AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductID = 792"
        ],
        "rule_sql": []
    },
    "4088": {
        "db_id": "public_review_platform",
        "question": "How many likes did short comment left by users who joined in 2010 get?",
        "ground_truth": "SELECT SUM(T2.likes) FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2010",
        "amends": [
            "Do use `SUM(T2.likes)` instead of `COUNT(*)` to sum individual like counts rather than counting rows. Do join `Users AS T1` and `Tips AS T2` instead of joining `likes`, `comments`, and `users` with different table relationships. Do use `INNER JOIN` on `T1.user_id = T2.user_id` instead of chained joins on `likes.comment_id = comments.id` and `comments.user_id = users.id`. Do filter on `T1.user_yelping_since_year = 2010` instead of `users.join_year = 2010 AND comments.type = 'short'` to target users who joined in 2010 without comment type restrictions. The amended query now correctly calculates total likes from tips by users who joined in 2010, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM likes \nJOIN comments ON likes.comment_id = comments.id \nJOIN users ON comments.user_id = users.id \nWHERE users.join_year = 2010 AND comments.type = 'short';",
            "SELECT SUM(T2.likes) \nFROM Users AS T1\nINNER JOIN Tips AS T2 ON T1.user_id = T2.user_id\nWHERE T1.user_yelping_since_year = 2010"
        ],
        "rule_sql": []
    },
    "5528": {
        "db_id": "menu",
        "question": "How many dishes appear in the right upper corner of the menu page?",
        "ground_truth": "SELECT COUNT(*) FROM MenuItem AS T1 INNER JOIN Dish AS T2 ON T1.dish_id = T2.id WHERE T1.xpos > 0.75 AND T1.ypos < 0.25",
        "amends": [
            "Do join `MenuItem AS T1` and `Dish AS T2` on `T1.dish_id = T2.id` instead of querying only the `dishes` table. Do filter on `T1.xpos > 0.75` and `T1.ypos < 0.25` instead of `position_x > 50` and `position_y < 50` to use proper coordinate thresholds. The amended query now correctly joins the menu item and dish tables with appropriate position filters, matching the intended behavior.",
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT T2.id)` to count all matching rows rather than distinct dish IDs. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity, though this is functionally equivalent. Do remove the unnecessary `DISTINCT` modifier and column reference in the count instead of keeping them, as we want the total count of menu items meeting the positional criteria rather than distinct dish counts. The join condition `ON T1.dish_id = T2.id` and WHERE filters `T1.xpos > 0.75 AND T1.ypos < 0.25` remain unchanged as they correctly identify the relevant menu items in the specified quadrant. The amended query now matches RIGHT_SQL's behavior by counting all menu items in the top-right quadrant rather than distinct dishes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dishes WHERE position_x > 50 AND position_y < 50;",
            "SELECT COUNT(DISTINCT T2.id) \nFROM MenuItem AS T1 \nJOIN Dish AS T2 ON T1.dish_id = T2.id \nWHERE T1.xpos > 0.75 AND T1.ypos < 0.25",
            "SELECT COUNT(*) \nFROM MenuItem AS T1\nINNER JOIN Dish AS T2 ON T1.dish_id = T2.id\nWHERE T1.xpos > 0.75 AND T1.ypos < 0.25"
        ],
        "rule_sql": []
    },
    "2416": {
        "db_id": "superstore",
        "question": "What is the ratio between customers who live in Texas and customers who live in Indiana?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN State = 'Texas' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE  WHEN State = 'Indiana' THEN 1 ELSE 0 END) FROM people",
        "amends": [
            "Do use `SUM(CASE WHEN State = 'Texas' THEN 1 ELSE 0 END)` and `SUM(CASE WHEN State = 'Indiana' THEN 1 ELSE 0 END)` instead of separate subqueries with `COUNT(*)`. Do cast the Texas sum to `REAL` instead of performing integer division. Do multiply by `100` to calculate percentage instead of raw ratio. Do query from `people` table instead of `customers` table. Do use column name `State` instead of `state`. The amended query now correctly calculates the percentage of Texas residents relative to Indiana residents using proper type casting and avoids division by zero issues.",
            "Do place the multiplication by 100 before the division instead of after it to correctly calculate the percentage ratio. Do maintain the same `SUM(CASE)` expressions for counting Texas and Indiana records instead of changing them. Do keep the `CAST` to `REAL` for proper division instead of removing it. Do preserve the same `FROM people` table source instead of altering it. The amended query now correctly computes the percentage by multiplying before dividing to avoid integer division issues and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM customers WHERE state = 'Texas') / \n    (SELECT COUNT(*) FROM customers WHERE state = 'Indiana') AS ratio",
            "SELECT \n    (CAST(SUM(CASE WHEN State = 'Texas' THEN 1 ELSE 0 END) AS REAL) / \n     SUM(CASE WHEN State = 'Indiana' THEN 1 ELSE 0 END)) * 100 AS ratio_percentage\nFROM people;",
            "SELECT \n    (CAST(SUM(CASE WHEN State = 'Texas' THEN 1 ELSE 0 END) AS REAL) * 100) / \n    SUM(CASE WHEN State = 'Indiana' THEN 1 ELSE 0 END) AS percentage_ratio\nFROM people\nWHERE State IN ('Texas', 'Indiana');"
        ],
        "rule_sql": []
    },
    "8353": {
        "db_id": "mondial_geo",
        "question": "How many Jewish residents are there in Moldova?",
        "ground_truth": "SELECT T2.Percentage * T1.Population FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Moldova' AND T2.Name = 'Jewish'",
        "amends": [
            "Do select `T2.Percentage * T1.Population` as a calculated expression instead of `COUNT(*)`. Do use `FROM country AS T1 INNER JOIN ethnicGroup AS T2` with a join condition `ON T1.Code = T2.Country` instead of querying only the `residents` table. Do filter with `T1.Name = 'Moldova'` and `T2.Name = 'Jewish'` instead of `country = 'Moldova'` and `religion = 'Jewish'`. The amended query now correctly calculates the Jewish population percentage multiplied by the total population instead of counting residents, using the proper table relationships and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM residents WHERE country = 'Moldova' AND religion = 'Jewish';",
            "SELECT T2.Percentage * T1.Population \nFROM country AS T1 \nINNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country \nWHERE T1.Name = 'Moldova' AND T2.Name = 'Jewish'"
        ],
        "rule_sql": []
    },
    "6904": {
        "db_id": "retails",
        "question": "How many customers in the building segments have orders with a total price of no less than 50,000?",
        "ground_truth": "SELECT COUNT(T2.c_name) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_mktsegment = 'BUILDING' AND T1.o_totalprice > 50000",
        "amends": [
            "Do use `T2.c_name` in the COUNT instead of `DISTINCT c.customer_id`. Do join `orders AS T1` with `customer AS T2` instead of `customers c` with `orders o`. Do use `T1.o_custkey = T2.c_custkey` as the join condition instead of `c.customer_id = o.customer_id`. Do filter on `T2.c_mktsegment = 'BUILDING'` instead of `c.segment = 'BUILDING'`. Do use `T1.o_totalprice > 50000` instead of `o.total_price >= 50000`. The amended query now correctly counts customer names for building segment customers with orders exceeding 50000 total price.",
            "Do use `COUNT(T2.c_name)` instead of `COUNT(DISTINCT T2.c_name)` to count all matching rows rather than distinct values. Do use `>` comparison instead of `>=` for `T1.o_totalprice > 50000` to exclude orders exactly equal to 50000. The amended query now correctly counts all customer names from the BUILDING market segment with orders over 50000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.customer_id) \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE c.segment = 'BUILDING' \nAND o.total_price >= 50000;",
            "SELECT COUNT(DISTINCT T2.c_name) \nFROM orders AS T1 \nJOIN customer AS T2 ON T1.o_custkey = T2.c_custkey \nWHERE T2.c_mktsegment = 'BUILDING' \nAND T1.o_totalprice >= 50000",
            "SELECT COUNT(T2.c_name) \nFROM orders AS T1 \nJOIN customer AS T2 ON T1.o_custkey = T2.c_custkey \nWHERE T2.c_mktsegment = 'BUILDING' \nAND T1.o_totalprice > 50000"
        ],
        "rule_sql": []
    },
    "6758": {
        "db_id": "retails",
        "question": "Among all the customers in Brazil, how many of them have an account balance of less than 1000?",
        "ground_truth": "SELECT COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'BRAZIL' AND T1.c_acctbal < 1000",
        "amends": [
            "Do use `COUNT(T1.c_custkey)` instead of `COUNT(*)` to count specific customer keys rather than all rows. Do join `customer AS T1` with `nation AS T2` on `T1.c_nationkey = T2.n_nationkey` instead of querying only the customers table. Do filter on `T2.n_name = 'BRAZIL'` instead of `country = 'Brazil'` to use the standardized nation name from the joined table. Do use `c_acctbal < 1000` instead of `balance > 1000` to find customers with account balances below the threshold rather than above it. The amended query now correctly joins customer and nation tables to filter by standardized country names and identifies customers with low account balances as specified."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE country = 'Brazil' AND balance > 1000;",
            "SELECT COUNT(T1.c_custkey) \nFROM customer AS T1\nJOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey\nWHERE T2.n_name = 'BRAZIL' AND T1.c_acctbal < 1000"
        ],
        "rule_sql": []
    },
    "5323": {
        "db_id": "beer_factory",
        "question": "How many female mailing list subscribers from Sacramento gave a 4-star rating between 1/3/2016 and 10/26/2016?",
        "ground_truth": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.StarRating = 4 AND T1.City = 'Sacramento' AND T1.Gender = 'F' AND T1.SubscribedToEmailList = 'TRUE' AND T2.ReviewDate BETWEEN '2013-01-03' AND '2013-10-26'",
        "amends": [
            "Do use `COUNT(T1.CustomerID)` instead of `COUNT(*)` to count specific customer IDs rather than all rows. Do join `customers AS T1` and `rootbeerreview AS T2` instead of `mailing_list_subscribers` and `ratings` with different table names and structure. Do use `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of joining on `subscriber_id` columns. Do filter on `T2.StarRating = 4` instead of `r.rating = 4` with a different column name. Do filter on `T1.City = 'Sacramento'` and `T1.Gender = 'F'` instead of `mls.city` and `mls.gender = 'female'` with different gender representation. Do add `T1.SubscribedToEmailList = 'TRUE'` instead of omitting this subscription status filter. Do use date range `'2013-01-03' AND '2013-10-26'` on `T2.ReviewDate` instead of `'2016-01-03' AND '2016-10-26'` on `r.rating_date` with different years and column name. The amended query now correctly counts subscribed customers with specific beer reviews in Sacramento during 2013."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM mailing_list_subscribers mls\nJOIN ratings r ON mls.subscriber_id = r.subscriber_id\nWHERE mls.gender = 'female' \nAND mls.city = 'Sacramento'\nAND r.rating = 4\nAND r.rating_date BETWEEN '2016-01-03' AND '2016-10-26';",
            "SELECT COUNT(T1.CustomerID) \nFROM customers AS T1\nINNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.City = 'Sacramento' \nAND T1.Gender = 'F' \nAND T1.SubscribedToEmailList = 'TRUE'\nAND T2.StarRating = 4\nAND T2.ReviewDate BETWEEN '2013-01-03' AND '2013-10-26'"
        ],
        "rule_sql": []
    },
    "8475": {
        "db_id": "mondial_geo",
        "question": "Name the organizations with the most members.",
        "ground_truth": "SELECT T1.Name FROM organization AS T1 INNER JOIN isMember AS T2 ON T2.Country = T1.Country INNER JOIN country AS T3 ON T2.Country = T3.Code GROUP BY T1.Name ORDER BY COUNT(T3.Name) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `organization_name` and `COUNT(*) as member_count`. Do use `FROM organization AS T1` instead of `FROM members`. Do add `INNER JOIN isMember AS T2 ON T2.Country = T1.Country` and `INNER JOIN country AS T3 ON T2.Country = T3.Code` instead of a single table. Do change `GROUP BY T1.Name` instead of `GROUP BY organization_name`. Do order by `COUNT(T3.Name) DESC` instead of `member_count ASC`. Do set `LIMIT 1` instead of `LIMIT 5`. The amended query now correctly joins multiple tables to count country members per organization and returns the organization with the highest count.",
            "Do join `isMember` on `T2.Country = T1.Country` instead of `T2.Organization = T1.Abbreviation` to correctly relate members to organizations. Do remove `COUNT(*) as member_count` from the SELECT list instead of including it since only organization names are needed. Do keep the same `GROUP BY T1.Name`, `ORDER BY COUNT(T3.Name) DESC`, and `LIMIT 1` structure as the logic for ordering and limiting remains correct. The amended query now matches the right SQL's behavior by properly joining organizations to their member countries rather than using organization abbreviations.",
            "Do `INNER JOIN` on `T2.Country = T1.Country` instead of `T2.Organization = T1.Abbreviation` for the isMember join condition. The amended query now correctly matches the RIGHT_SQL's behavior by fixing the join predicate between organization and isMember tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_name, COUNT(*) as member_count FROM members GROUP BY organization_name ORDER BY member_count ASC LIMIT 5;",
            "SELECT T1.Name, COUNT(*) as member_count\nFROM organization AS T1\nINNER JOIN isMember AS T2 ON T2.Organization = T1.Abbreviation\nINNER JOIN country AS T3 ON T2.Country = T3.Code\nGROUP BY T1.Name\nORDER BY COUNT(T3.Name) DESC\nLIMIT 1;",
            "SELECT T1.Name\nFROM organization AS T1\nINNER JOIN isMember AS T2 ON T2.Organization = T1.Abbreviation\nINNER JOIN country AS T3 ON T2.Country = T3.Code\nGROUP BY T1.Name\nORDER BY COUNT(T3.Name) DESC\nLIMIT 1",
            "SELECT T1.Name\nFROM organization AS T1\nINNER JOIN isMember AS T2 ON T2.Country = T1.Country\nINNER JOIN country AS T3 ON T2.Country = T3.Code\nGROUP BY T1.Name\nORDER BY COUNT(T3.Name) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5880": {
        "db_id": "airline",
        "question": "What is the actual departure time of JetBlue Airways with the plane's tail number N903JB to Fort Lauderdale-Hollywood International Airport on the 20th of August 2018?",
        "ground_truth": "SELECT T1.DEP_TIME FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code INNER JOIN Airports AS T3 ON T1.DEST = T3.Code WHERE T1.FL_DATE = '2018/8/20' AND T1.TAIL_NUM = 'N903JB' AND T2.Description LIKE '%JetBlue Airways%' AND T3.Description LIKE '%Fort Lauderdale-Hollywood%'",
        "amends": [
            "Do join `Airlines` as `T1` instead of querying `flights` directly. Do join `Air Carriers` as `T2` on `T1.OP_CARRIER_AIRLINE_ID = T2.Code` instead of filtering `airline` directly. Do join `Airports` as `T3` on `T1.DEST = T3.Code` instead of filtering `destination` directly. Do select `T1.DEP_TIME` instead of `actual_departure_time`. Do use `T1.FL_DATE = '2018/8/20'` instead of `date = '2018-08-20'`. Do filter with `T2.Description LIKE '%JetBlue Airways%'` instead of exact match on airline name. Do filter with `T3.Description LIKE '%Fort Lauderdale-Hollywood%'` instead of exact match on airport name. The amended query now correctly joins related tables and uses pattern matching for flexible text comparisons, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actual_departure_time \nFROM flights \nWHERE airline = 'JetBlue Airways' \nAND tail_number = 'N903JB' \nAND destination = 'Fort Lauderdale-Hollywood International Airport' \nAND date = '2018-08-20';",
            "SELECT T1.DEP_TIME\nFROM Airlines AS T1\nJOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code\nJOIN Airports AS T3 ON T1.DEST = T3.Code\nWHERE T1.FL_DATE = '2018/8/20'\nAND T2.Description LIKE '%JetBlue Airways%'\nAND T3.Description LIKE '%Fort Lauderdale-Hollywood%'\nAND T1.TAIL_NUM = 'N903JB'"
        ],
        "rule_sql": []
    },
    "7659": {
        "db_id": "hockey",
        "question": "Among the coaches whose team has over 30 wins in a year, how many of them are born in the USA?",
        "ground_truth": "SELECT COUNT(T2.coachID) FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE T2.W > 30 AND T1.birthCountry = 'USA'",
        "amends": [
            "Do use `COUNT(T2.coachID)` instead of `COUNT(*)` to count specific coach records. Do reference `Master AS T1` instead of omitting this table entirely. Do use `INNER JOIN Coaches AS T2` instead of `JOIN coaches c` with proper table aliasing. Do join on `T1.coachID = T2.coachID` instead of `c.team_id = t.team_id` to correctly link coaches to their master records. Do filter on `T2.W > 30` instead of `t.wins > 30` to use the correct wins column from the coaches table. Do filter on `T1.birthCountry = 'USA'` instead of `c.birth_country = 'USA'` to use the birth country from the master table. The amended query now correctly counts coaches with over 30 wins who were born in the USA by properly joining coach records with their master data and using the appropriate columns from each table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM coaches c\nJOIN teams t ON c.team_id = t.team_id\nWHERE t.wins > 30 AND c.birth_country = 'USA';",
            "SELECT COUNT(T2.coachID) \nFROM Master AS T1\nINNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID\nWHERE T2.W > 30 AND T1.birthCountry = 'USA'"
        ],
        "rule_sql": []
    },
    "8627": {
        "db_id": "chicago_crime",
        "question": "Who is the commanding officer in the district with the highest number of disorderly conduct?",
        "ground_truth": "SELECT T1.commander FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no WHERE T3.title = 'Disorderly Conduct' AND T2.fbi_code_no = 24 GROUP BY T2.fbi_code_no ORDER BY COUNT(T1.district_no) DESC LIMIT 1",
        "amends": [
            "Do add `T1.commander` instead of `commanding_officer` in the SELECT list. Do add `INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no` and `INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no` instead of omitting these table joins. Do add `WHERE T3.title = 'Disorderly Conduct' AND T2.fbi_code_no = 24` instead of having no filter conditions. Do add `GROUP BY T2.fbi_code_no` instead of omitting grouping. Do change `ORDER BY COUNT(T1.district_no) DESC` instead of `ORDER BY disorderly_conduct DESC` to count crimes per district. The amended query now correctly joins multiple tables, filters for specific crime types, groups by FBI code, and orders by crime count instead of a direct column reference, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT commanding_officer FROM districts ORDER BY disorderly_conduct DESC LIMIT 1;",
            "SELECT T1.commander\nFROM District AS T1\nINNER JOIN Crime AS T2 ON T1.district_no = T2.district_no\nINNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no\nWHERE T3.title = 'Disorderly Conduct' AND T2.fbi_code_no = '24'\nGROUP BY T2.fbi_code_no\nORDER BY COUNT(T1.district_no) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5386": {
        "db_id": "sales",
        "question": "Has Alex purchased product with id 498?",
        "ground_truth": "SELECT IIF(T1.ProductID = 498, 'YES', 'NO') FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.FirstName = 'Alex'",
        "amends": [
            "Do use `IIF(T1.ProductID = 498, 'YES', 'NO')` as the SELECT expression instead of selecting all columns with `*`. Do join `Sales AS T1` with `Customers AS T2` using `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `purchases` table. Do filter on `T2.FirstName = 'Alex'` instead of `customer_name = 'Alex' AND product_id = 498`. The amended query now correctly joins customer and sales data to determine product ownership status, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM purchases WHERE customer_name = 'Alex' AND product_id = 498;",
            "SELECT IIF(T1.ProductID = 498, 'YES', 'NO') \nFROM Sales AS T1 \nINNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T2.FirstName = 'Alex'"
        ],
        "rule_sql": []
    },
    "3356": {
        "db_id": "video_games",
        "question": "List down the game ID of games with genre ID 2.",
        "ground_truth": "SELECT T.id FROM game AS T WHERE T.genre_id = 2",
        "amends": [
            "Do select `T.id` with table alias instead of `game_id` without alias. Do reference table as `game AS T` instead of `games`. Do use equality filter `T.genre_id = 2` instead of inequality `genre_id != 2`. The amended query now correctly selects games belonging to genre 2 rather than excluding them."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_id FROM games WHERE genre_id != 2;",
            "SELECT T.id FROM game AS T WHERE T.genre_id = 2"
        ],
        "rule_sql": []
    },
    "9399": {
        "db_id": "movie_3",
        "question": "Which category is the film \"Beach Heartbreakers\" falls into?",
        "ground_truth": "SELECT T3.name FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T1.title = 'BEACH HEARTBREAKERS'",
        "amends": [
            "Do select `T3.name` from the category table instead of `category` from the films table. Do join `film` as `T1` with `film_category` as `T2` on `T1.film_id = T2.film_id` instead of querying a single table. Do add a second join to `category` as `T3` on `T2.category_id = T3.category_id` instead of omitting the category relationship. Do use uppercase `'BEACH HEARTBREAKERS'` for the title filter instead of mixed case `'Beach Heartbreakers'`. The amended query now correctly retrieves the category name through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM films WHERE title = 'Beach Heartbreakers';",
            "SELECT T3.name \nFROM film AS T1\nJOIN film_category AS T2 ON T1.film_id = T2.film_id\nJOIN category AS T3 ON T2.category_id = T3.category_id\nWHERE T1.title = 'BEACH HEARTBREAKERS'"
        ],
        "rule_sql": []
    },
    "755": {
        "db_id": "movie",
        "question": "Who played the No.2 character in the credit list of the movie \"American Hustle\"?",
        "ground_truth": "SELECT T3.Name FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T1.Title = 'American Hustle' AND T2.creditOrder = '2'",
        "amends": [
            "Do use proper table joins with `INNER JOIN` on `T1.MovieID = T2.MovieID` and `T3.ActorID = T2.ActorID` instead of querying a single table. Do reference columns from the correct tables with `T3.Name` instead of just `name`. Do use the correct column names `T1.Title` and `T2.creditOrder` instead of `movie_title` and `credit_position`. Do add the required table aliases `T1`, `T2`, and `T3` instead of omitting them. The amended query now correctly joins the movie, characters, and actor tables to retrieve the actor name for the specified credit position in the given movie."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM actors WHERE movie_title = 'American Hustle' AND credit_position = 2;",
            "SELECT T3.Name\nFROM movie T1\nINNER JOIN characters T2 ON T1.MovieID = T2.MovieID\nINNER JOIN actor T3 ON T3.ActorID = T2.ActorID\nWHERE T1.Title = 'American Hustle' AND T2.creditOrder = 2"
        ],
        "rule_sql": []
    },
    "7675": {
        "db_id": "hockey",
        "question": "In which month was the player who has won the most awards born?",
        "ground_truth": "SELECT T1.birthMon FROM Master AS T1 INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID GROUP BY T2.playerID ORDER BY COUNT(T2.award) DESC LIMIT 1",
        "amends": [
            "Do select `T1.birthMon` instead of `MONTH(birth_date)` and add proper table aliases. Do join `Master AS T1` with `AwardsPlayers AS T2` using `INNER JOIN` on `T1.playerID = T2.playerID` instead of querying a single table without joins. Do add `GROUP BY T2.playerID` to aggregate awards per player instead of missing grouping. Do order by `COUNT(T2.award)` instead of `COUNT(awards)` with proper table qualification. Do maintain `DESC` ordering and `LIMIT 1` as in the original query. The amended query now correctly identifies the birth month of the player with the most awards by properly joining the player master data with awards data and grouping at the player level."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MONTH(birth_date) FROM players ORDER BY COUNT(awards) DESC LIMIT 1;",
            "SELECT T1.birthMon\nFROM Master AS T1\nINNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID\nGROUP BY T2.playerID\nORDER BY COUNT(T2.award) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1905": {
        "db_id": "soccer_2016",
        "question": "Which city hosted the least number of no-result matches?",
        "ground_truth": "SELECT T4.City_Name FROM `Match` AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id INNER JOIN Venue AS T3 ON T1.Venue_Id = T3.Venue_Id INNER JOIN City AS T4 ON T3.City_Id = T4.City_Id WHERE T2.Win_Type = 'NO Result' GROUP BY T4.City_Id ORDER BY COUNT(T2.Win_Type) ASC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T4.City_Name` instead of `city` and join through proper relationships via `INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id`, `INNER JOIN Venue AS T3 ON T1.Venue_Id = T3.Venue_Id`, and `INNER JOIN City AS T4 ON T3.City_Id = T4.City_Id` instead of querying a single table. Do filter on `T2.Win_Type = 'NO Result'` instead of `result = 'no-result'` to use the correct lookup table. Do group by `T4.City_Id` instead of `city` to use the primary key. Do order by `COUNT(T2.Win_Type) ASC` instead of `match_count DESC` to get the minimum count in ascending order. The amended query now correctly joins through the proper table relationships and returns the city with the fewest 'NO Result' matches."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as match_count \nFROM matches \nWHERE result = 'no-result' \nGROUP BY city \nORDER BY match_count DESC \nLIMIT 1;",
            "SELECT T4.City_Name\nFROM Match AS T1\nINNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id\nINNER JOIN Venue AS T3 ON T1.Venue_Id = T3.Venue_Id\nINNER JOIN City AS T4 ON T3.City_Id = T4.City_Id\nWHERE T2.Win_Type = 'NO Result'\nGROUP BY T4.City_Id\nORDER BY COUNT(T2.Win_Type) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "909": {
        "db_id": "cs_semester",
        "question": "List the courses' IDs and students' IDs who failed to pass the course.",
        "ground_truth": "SELECT course_id, student_id FROM registration WHERE grade IS NULL OR grade = ''",
        "amends": [
            "Do query from `registration` table instead of `enrollments` table. Do filter for `grade IS NULL OR grade = ''` instead of `grade >= 60`. Do remove the numeric grade comparison and instead check for missing or empty grade values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id, student_id FROM enrollments WHERE grade >= 60;",
            "SELECT course_id, student_id FROM registration WHERE grade IS NULL OR grade = '';"
        ],
        "rule_sql": []
    },
    "3840": {
        "db_id": "public_review_platform",
        "question": "Among the Yelp_Businesses in Arizona, how many of them are still running?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE state LIKE 'AZ' AND active LIKE 'True'",
        "amends": [
            "Do count `business_id` instead of `*` to avoid counting null values. Do use table alias `Business` instead of `Yelp_Businesses` for the correct table reference. Do filter with `state LIKE 'AZ'` instead of `state = 'Arizona'` to match the abbreviated state code format. Do filter with `active LIKE 'True'` instead of `is_open = 0` to use the correct column name and boolean representation. The amended query now correctly counts active businesses in Arizona using the proper table structure and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Yelp_Businesses WHERE state = 'Arizona' AND is_open = 0;",
            "SELECT COUNT(business_id) FROM Business WHERE state LIKE 'AZ' AND active LIKE 'True';"
        ],
        "rule_sql": []
    },
    "7564": {
        "db_id": "image_and_language",
        "question": "Which object has the highest attribute classes?",
        "ground_truth": "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ_ATT GROUP BY OBJ_SAMPLE_ID ORDER BY COUNT(OBJ_SAMPLE_ID) DESC LIMIT 1",
        "amends": [
            "Do select `OBJ_SAMPLE_ID` instead of `object` and `MAX(attribute_classes)`. Do use `FROM IMG_OBJ_ATT` instead of `FROM objects`. Do add `GROUP BY OBJ_SAMPLE_ID` instead of omitting it. Do add `ORDER BY COUNT(OBJ_SAMPLE_ID) DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limitation. The amended query now correctly identifies the most frequent object sample ID by counting occurrences rather than attempting to find maximum attribute classes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object, MAX(attribute_classes) FROM objects;",
            "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ_ATT GROUP BY OBJ_SAMPLE_ID ORDER BY COUNT(OBJ_SAMPLE_ID) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "6280": {
        "db_id": "coinmarketcap",
        "question": "List the names and symbols of the coins that were added on June 14, 2013.",
        "ground_truth": "SELECT name, symbol FROM coins WHERE date_added LIKE '2013-06-14%'",
        "amends": [
            "Do use `LIKE '2013-06-14%'` for partial date matching instead of exact equality `= '2013-06-14'` to accommodate timestamp values that may include time components while still filtering for the specific date. The amended query now correctly matches all records from June 14, 2013, regardless of time values, ensuring it returns the same results as the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, symbol FROM coins WHERE added_date = '2013-06-14';",
            "SELECT name, symbol FROM coins WHERE date_added LIKE '2013-06-14%'"
        ],
        "rule_sql": []
    },
    "6936": {
        "db_id": "ice_hockey_draft",
        "question": "What are the names of the players who played for Acadie-Bathurst Titan during the regular season in 1998-1999?",
        "ground_truth": "SELECT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '1998-1999' AND T1.GAMETYPE = 'Regular Season' AND T1.TEAM = 'Acadie-Bathurst Titan'",
        "amends": [
            "Do select `T2.PlayerName` from `PlayerInfo` instead of `name` from `players`. Do join `SeasonStatus AS T1` with `PlayerInfo AS T2` on `T1.ELITEID = T2.ELITEID` instead of querying a single table. Do filter on `T1.SEASON = '1998-1999'` and `T1.GAMETYPE = 'Regular Season'` and `T1.TEAM = 'Acadie-Bathurst Titan'` instead of filtering directly on the player table with `game_type = 'regular'`. The amended query now correctly joins the necessary tables and uses the proper column references and filter values to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE team = 'Acadie-Bathurst Titan' AND season = '1998-1999' AND game_type = 'regular';",
            "SELECT T2.PlayerName \nFROM SeasonStatus AS T1 \nJOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID \nWHERE T1.SEASON = '1998-1999' \nAND T1.GAMETYPE = 'Regular Season' \nAND T1.TEAM = 'Acadie-Bathurst Titan'"
        ],
        "rule_sql": []
    },
    "9400": {
        "db_id": "movie_3",
        "question": "List at least 10 films that falls into the Horror category.",
        "ground_truth": "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Horror'",
        "amends": [
            "Do specify `T1.title` in the SELECT list instead of using `*` to select all columns. Do add joins to `film_category AS T2` and `category AS T3` instead of querying only the `films` table. Do use `INNER JOIN` with `T1.film_id = T2.film_id` and `T2.category_id = T3.category_id` instead of no joins. Do filter on `T3.name = 'Horror'` instead of `category = 'Horror'` to properly reference the category table. Do remove the `LIMIT 5` clause instead of keeping it since the query logic now correctly filters by category. The amended query now correctly joins related tables and filters by category name to return horror film titles.",
            "Do remove the `LIMIT 10` clause instead of keeping it, as the requirement is to return all horror films rather than just the first 10 results. The amended query now matches RIGHT_SQL's behavior by returning all horror film titles without any row limitation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM films WHERE category = 'Horror' LIMIT 5;",
            "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Horror' LIMIT 10",
            "SELECT T1.title \nFROM film AS T1\nINNER JOIN film_category AS T2 ON T1.film_id = T2.film_id\nINNER JOIN category AS T3 ON T2.category_id = T3.category_id\nWHERE T3.name = 'Horror'"
        ],
        "rule_sql": []
    },
    "1978": {
        "db_id": "soccer_2016",
        "question": "List the IDs and names of the umpires from New Zealand.",
        "ground_truth": "SELECT T1.Umpire_Id, T1.Umpire_Name FROM Umpire AS T1 INNER JOIN Country AS T2 ON T1.Umpire_Country = T2.Country_Id WHERE T2.Country_Name = 'New Zealand'",
        "amends": [
            "Do select `T1.Umpire_Id` and `T1.Umpire_Name` instead of `id` and `name`. Do join `Umpire AS T1` with `Country AS T2` using `INNER JOIN` on `T1.Umpire_Country = T2.Country_Id` instead of querying only the `umpires` table. Do filter on `T2.Country_Name = 'New Zealand'` instead of `country = 'Australia'`. Do use proper table aliases and qualified column names throughout instead of unqualified references. The amended query now correctly joins the Umpire and Country tables to filter by country name rather than relying on a direct country field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, name FROM umpires WHERE country = 'Australia';",
            "SELECT T1.Umpire_Id, T1.Umpire_Name\nFROM Umpire AS T1\nINNER JOIN Country AS T2 ON T1.Umpire_Country = T2.Country_Id\nWHERE T2.Country_Name = 'New Zealand'"
        ],
        "rule_sql": []
    },
    "6069": {
        "db_id": "books",
        "question": "What is the shipping method ordered by Nicolette Sadler at 6/29/2020 7:40:07 PM?",
        "ground_truth": "SELECT T3.method_name FROM cust_order AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T1.shipping_method_id WHERE T2.first_name = 'Nicolette' AND T2.last_name = 'Sadler' AND T1.order_date = '2020-06-29 19:40:07'",
        "amends": [
            "Do select `T3.method_name` from the `shipping_method` table instead of `shipping_method` from the `orders` table. Do join `cust_order AS T1` instead of querying `orders` directly. Do add `INNER JOIN customer AS T2` on `T1.customer_id = T2.customer_id` instead of filtering by customer name directly. Do add `INNER JOIN shipping_method AS T3` on `T3.method_id = T1.shipping_method_id` instead of selecting from a single table. Do filter by `T2.first_name = 'Nicolette'` and `T2.last_name = 'Sadler'` instead of `customer_name = 'Nicolette Sadler'`. Do use standardized date format `2020-06-29 19:40:07` instead of `6/29/2020 7:40:07 PM`. The amended query now correctly joins related tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shipping_method FROM orders WHERE customer_name = 'Nicolette Sadler' AND order_date = '6/29/2020 7:40:07 PM';",
            "SELECT T3.method_name \nFROM cust_order AS T1\nINNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN shipping_method AS T3 ON T3.method_id = T1.shipping_method_id\nWHERE T2.first_name = 'Nicolette' \nAND T2.last_name = 'Sadler' \nAND T1.order_date = '2020-06-29 19:40:07'"
        ],
        "rule_sql": []
    },
    "2570": {
        "db_id": "app_store",
        "question": "What is the rating of Dragon Ball Legends and how many users dislike this App?",
        "ground_truth": "SELECT T1.Rating, COUNT(T2.Sentiment_Polarity) FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = 'Dragon Ball Legends' AND CAST(Sentiment_Polarity AS INTEGER) < -0.5",
        "amends": [
            "Do select `T1.Rating` and `COUNT(T2.Sentiment_Polarity)` instead of `rating` and `dislike_count`. Do use `FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App` instead of `FROM apps` alone. Do add filter `T1.App = 'Dragon Ball Legends'` instead of `name = 'Dragon Ball Legends'`. Do add additional filter `CAST(Sentiment_Polarity AS INTEGER) < -0.5` instead of omitting it. The amended query now correctly joins tables and counts negative sentiment polarity values for the specified app."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating, dislike_count FROM apps WHERE name = 'Dragon Ball Legends';",
            "SELECT T1.Rating, COUNT(T2.Sentiment_Polarity) \nFROM playstore AS T1 \nINNER JOIN user_reviews AS T2 ON T1.App = T2.App \nWHERE T1.App = 'Dragon Ball Legends' \nAND CAST(T2.Sentiment_Polarity AS REAL) < -0.5"
        ],
        "rule_sql": []
    },
    "936": {
        "db_id": "cs_semester",
        "question": "List the course's name where students acquired a grade of D.",
        "ground_truth": "SELECT T1.name FROM course AS T1 INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE T2.grade = 'D'",
        "amends": [
            "Do select `T1.name` from the `course` table instead of `course_name` from `courses`. Do join `registration AS T2` with `INNER JOIN` on `T1.course_id = T2.course_id` instead of querying a single table. Do filter on `T2.grade = 'D'` in the WHERE clause instead of filtering on a `grade` column from the courses table. The amended query now correctly retrieves course names by joining with the registration table to access grade information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE grade = 'D';",
            "SELECT T1.name FROM course AS T1 INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE T2.grade = 'D'"
        ],
        "rule_sql": []
    },
    "4754": {
        "db_id": "legislator",
        "question": "What is the average number of terms for a current female legislator?",
        "ground_truth": "SELECT CAST(COUNT(T2.bioguide) AS REAL) / COUNT(DISTINCT T1.bioguide_id) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F'",
        "amends": [
            "Do use `CAST(COUNT(T2.bioguide) AS REAL) / COUNT(DISTINCT T1.bioguide_id)` instead of `AVG(term_count)` for calculating the average terms per legislator. Do join `current AS T1` with `current-terms AS T2` on `T1.bioguide_id = T2.bioguide` instead of querying a single `legislators` table. Do filter on `T1.gender_bio = 'F'` instead of `gender = 'male'` to target female legislators. Do remove the `current = 1` filter instead of keeping it since the join with the `current` table inherently handles current legislators. The amended query now correctly calculates average terms per female legislator by counting terms and distinct legislators separately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(term_count) FROM legislators WHERE gender = 'male' AND current = 1;",
            "SELECT CAST(COUNT(T2.bioguide) AS REAL) / COUNT(DISTINCT T1.bioguide_id) AS avg_terms\nFROM current AS T1\nJOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nWHERE T1.gender_bio = 'F'"
        ],
        "rule_sql": []
    },
    "1936": {
        "db_id": "soccer_2016",
        "question": "Where was the ID 336005 match held? Please give me the venue and the city.",
        "ground_truth": "SELECT T2.Venue_Name, T3.City_Name FROM `Match` AS T1 INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id INNER JOIN City AS T3 ON T2.City_Id = T3.City_Id WHERE T1.Match_Id = '336005'",
        "amends": [
            "Do use explicit table aliases `T2.Venue_Name` and `T3.City_Name` instead of ambiguous column names `venue` and `city`. Do add `INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id` and `INNER JOIN City AS T3 ON T2.City_Id = T3.City_Id` instead of querying a single table. Do reference the correct table `Match` instead of `matches`. Do use proper join conditions with foreign key relationships `T1.Venue_Id = T2.Venue_Id` and `T2.City_Id = T3.City_Id` instead of no joins. Do filter on `T1.Match_Id = '336005'` with string comparison instead of numeric comparison. The amended query now correctly joins through the venue and city relationships to retrieve the proper venue name and city name for the specified match."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue, city FROM matches WHERE match_id = 336005",
            "SELECT T2.Venue_Name, T3.City_Name \nFROM Match AS T1\nINNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id\nINNER JOIN City AS T3 ON T2.City_Id = T3.City_Id\nWHERE T1.Match_Id = '336005'"
        ],
        "rule_sql": []
    },
    "8771": {
        "db_id": "chicago_crime",
        "question": "What is the average number of incidents per month in 2018 in the ward with the most population?",
        "ground_truth": "SELECT COUNT(T1.ward_no) / 12 AS average FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.date LIKE '%2018%' AND T1.Population = ( SELECT MAX(T1.Population) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.date LIKE '%2018%' )",
        "amends": [
            "Do use `COUNT(T1.ward_no) / 12` as the average calculation instead of `AVG(incidents)` to count incidents per ward divided by months. Do join `Ward AS T1` with `Crime AS T2` on `T1.ward_no = T2.ward_no` instead of querying a single table without joins. Do filter with `T2.date LIKE '%2018%'` instead of `year = 2018` to handle date string matching. Do use a subquery with `MAX(T1.Population)` to find the most populous ward instead of `ORDER BY population DESC LIMIT 1`. Do include the same date filter `T2.date LIKE '%2018%'` in the subquery instead of omitting temporal constraints. Do reference the correct table aliases `T1` and `T2` consistently instead of inconsistent table references. The amended query now correctly calculates average monthly incidents for the most populous ward in 2018.",
            "Do use `COUNT(T1.ward_no)` instead of `COUNT(T2.ward_no)` to count from the correct table. Do remove the decimal `.0` from the division denominator and use `12` instead of `12.0`. Do change the alias to `average` instead of `average_incidents_per_month`. Do move the population filter from a subquery in the WHERE clause to a direct equality condition `T1.Population = (subquery)` instead of using `T1.ward_no = (subquery)`. Do add the missing `INNER` keyword to explicitly specify `INNER JOIN` instead of just `JOIN`. Do reorder the WHERE clause conditions to place `T2.date LIKE '%2018%'` first instead of second. Do modify the subquery to include the same join condition `INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no` and date filter `WHERE T2.date LIKE '%2018%'` instead of using a simple population lookup without joins. The amended query now correctly calculates the average monthly incidents for the ward with maximum population among those with 2018 crime data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(incidents) as avg_incidents_per_month\nFROM incidents_table\nWHERE year = 2018\nAND ward_id = (SELECT ward_id FROM population_table ORDER BY population DESC LIMIT 1);",
            "SELECT COUNT(T2.ward_no) / 12.0 AS average_incidents_per_month\nFROM Ward AS T1\nJOIN Crime AS T2 ON T1.ward_no = T2.ward_no\nWHERE T1.ward_no = (\n    SELECT ward_no\n    FROM Ward\n    WHERE Population = (SELECT MAX(Population) FROM Ward)\n)\nAND T2.date LIKE '%2018%';",
            "SELECT COUNT(T1.ward_no) / 12 AS average\nFROM Ward AS T1\nINNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no\nWHERE T2.date LIKE '%2018%'\nAND T1.Population = (\n    SELECT MAX(T1.Population)\n    FROM Ward AS T1\n    INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no\n    WHERE T2.date LIKE '%2018%'\n)"
        ],
        "rule_sql": []
    },
    "8758": {
        "db_id": "chicago_crime",
        "question": "How many incidents are considered \"severe\" in the IUCR classification?",
        "ground_truth": "SELECT COUNT(*) FROM IUCR WHERE index_code = 'I'",
        "amends": [
            "Do reference the `IUCR` table instead of the `incidents` table. Do filter on `index_code = 'I'` instead of `severity = 'severe'`. The amended query now correctly counts records from the IUCR table where the index code equals 'I', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM incidents WHERE severity = 'severe';",
            "SELECT COUNT(*) FROM IUCR WHERE index_code = 'I';"
        ],
        "rule_sql": []
    },
    "528": {
        "db_id": "movies_4",
        "question": "What is the original language of the movie with the tagline \"An offer you can't refuse.\"?",
        "ground_truth": "SELECT T3.language_name FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id INNER JOIN language_role AS T4 ON T2.language_role_id = T4.role_id WHERE T4.language_role = 'Original' AND T1.tagline LIKE 'An offer you can%t refuse.'",
        "amends": [
            "Do join `movie`, `movie_languages`, `language`, and `language_role` tables instead of querying only `movies`. Do select `T3.language_name` instead of `original_language`. Do use `INNER JOIN` with `T1.movie_id = T2.movie_id` and `T2.language_id = T3.language_id` instead of no joins. Do add join condition `T2.language_role_id = T4.role_id` instead of omitting it. Do filter with `T4.language_role = 'Original'` instead of no role filter. Do use `LIKE 'An offer you can%t refuse.'` pattern matching instead of exact string match. The amended query now correctly retrieves original language names through proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT original_language FROM movies WHERE tagline = \"An offer you can't refuse.\";",
            "SELECT T3.language_name \nFROM movie T1\nINNER JOIN movie_languages T2 ON T1.movie_id = T2.movie_id\nINNER JOIN language T3 ON T2.language_id = T3.language_id\nINNER JOIN language_role T4 ON T2.language_role_id = T4.role_id\nWHERE T1.tagline LIKE 'An offer you can%t refuse.'\nAND T4.language_role = 'Original'"
        ],
        "rule_sql": []
    },
    "7825": {
        "db_id": "world",
        "question": "How many cities are there in the country with the largest surface area?",
        "ground_truth": "SELECT T2.ID FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T1.SurfaceArea = ( SELECT MAX(SurfaceArea) FROM Country )",
        "amends": [
            "Do select `T2.ID` instead of `COUNT(*)` to return individual city IDs rather than a count. Do use `INNER JOIN` between `Country` and `City` tables on `T1.Code = T2.CountryCode` instead of a subquery in the WHERE clause. Do filter with `T1.SurfaceArea = (SELECT MAX(SurfaceArea) FROM Country)` instead of `country_id = (SELECT id FROM countries ORDER BY surface_area DESC LIMIT 1)` to correctly identify the country with maximum surface area using an aggregate function rather than ordering and limiting. Do reference tables as `Country AS T1` and `City AS T2` with explicit aliases instead of simple table names. The amended query now correctly returns cities from the country with the largest surface area rather than counting them."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country_id = (SELECT id FROM countries ORDER BY surface_area DESC LIMIT 1);",
            "SELECT T2.ID FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T1.SurfaceArea = (SELECT MAX(SurfaceArea) FROM Country)"
        ],
        "rule_sql": []
    },
    "4092": {
        "db_id": "public_review_platform",
        "question": "How much time do businesses in El Mirage City, AZ State operate in average daily?",
        "ground_truth": "SELECT SUM(T2.closing_time - T2.opening_time) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'El Mirage' AND T1.state = 'AZ'",
        "amends": [
            "Do join `Business` and `Business_Hours` tables on `business_id` instead of querying only `businesses` table. Do calculate `SUM` of `closing_time - opening_time` instead of taking `AVG` of `operating_hours`. Do reference columns with table aliases `T1` and `T2` instead of using unqualified column names. Do use explicit `INNER JOIN` syntax instead of implicit single table query. The amended query now correctly calculates total operating hours by summing the difference between opening and closing times from the joined tables instead of averaging a single column, matching the intended behavior.",
            "Do use `SUM` for the aggregate function instead of `AVG` to calculate total operating hours rather than average hours. Do remove the alias `AS average_daily_operating_hours` instead of keeping it since the right query returns an unaliased result. The `FROM` clause with `INNER JOIN` on `T1.business_id = T2.business_id` remains correct, as do the `WHERE` filters for `T1.city = 'El Mirage'` and `T1.state = 'AZ'`. The amended query now correctly sums the total operating hours for businesses in El Mirage, AZ instead of averaging them."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(operating_hours) FROM businesses WHERE city = 'El Mirage' AND state = 'AZ';",
            "SELECT AVG(T2.closing_time - T2.opening_time) AS average_daily_operating_hours\nFROM Business T1\nINNER JOIN Business_Hours T2 ON T1.business_id = T2.business_id\nWHERE T1.city = 'El Mirage' AND T1.state = 'AZ'",
            "SELECT SUM(CAST(T2.closing_time AS REAL) - CAST(T2.opening_time AS REAL)) \nFROM Business T1 \nINNER JOIN Business_Hours T2 ON T1.business_id = T2.business_id \nWHERE T1.city = 'El Mirage' AND T1.state = 'AZ'"
        ],
        "rule_sql": []
    },
    "2263": {
        "db_id": "movielens",
        "question": "Please list down the ID of actors and directors in action movies.",
        "ground_truth": "SELECT T2.actorid, T1.directorid FROM movies2directors AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE T1.genre = 'Action'",
        "amends": [
            "Do select `T2.actorid` and `T1.directorid` instead of `actor_id` and `director_id`. Do use `movies2directors AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid` instead of the single table `movies`. Do filter on `T1.genre = 'Action'` instead of `genre = 'action'` with proper case sensitivity. The amended query now correctly joins related tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id, director_id FROM movies WHERE genre = 'action';",
            "SELECT T2.actorid, T1.directorid \nFROM movies2directors AS T1 \nINNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid \nWHERE T1.genre = 'Action'"
        ],
        "rule_sql": []
    },
    "7858": {
        "db_id": "world",
        "question": "How many countries have Socialistic Republic form of government?",
        "ground_truth": "SELECT COUNT(Code) FROM Country WHERE GovernmentForm = 'Socialistic Republic'",
        "amends": [
            "Do reference the table as `Country` instead of `countries` and use the column `Code` instead of `*` in the COUNT function instead of counting all rows. Do use the correct column name `GovernmentForm` instead of `government_form` for the filter condition instead of the incorrect lowercase version. The amended query now correctly counts distinct country codes with the specified government form rather than counting all rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE government_form = 'Socialistic Republic';",
            "SELECT COUNT(Code) FROM Country WHERE GovernmentForm = 'Socialistic Republic';"
        ],
        "rule_sql": []
    },
    "6213": {
        "db_id": "food_inspection_2",
        "question": "What is the risk level of the establishment that Bob Benson inspected?",
        "ground_truth": "SELECT DISTINCT T3.risk_level FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE T1.first_name = 'Bob' AND T1.last_name = 'Benson'",
        "amends": [
            "Do use `DISTINCT T3.risk_level` instead of `risk_level` without distinct. Do change the FROM clause to use `employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no` instead of querying `inspections` directly. Do replace the WHERE filter with `T1.first_name = 'Bob' AND T1.last_name = 'Benson'` instead of `inspector_name = 'Bob Benson'` to properly match the employee by first and last name. The amended query now correctly joins through the employee and inspection tables to establish the proper relationship between the inspector and risk levels, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT risk_level FROM inspections WHERE inspector_name = 'Bob Benson';",
            "SELECT DISTINCT T3.risk_level\nFROM employee AS T1\nINNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nINNER JOIN establishment AS T3 ON T2.license_no = T3.license_no\nWHERE T1.first_name = 'Bob' AND T1.last_name = 'Benson'"
        ],
        "rule_sql": []
    },
    "6495": {
        "db_id": "retail_world",
        "question": "How many customers are there in Berlin, Germany?",
        "ground_truth": "SELECT COUNT(City) FROM Customers WHERE Country = 'Germany' AND City = 'Berlin'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'Berlin';"
        ],
        "rule_sql": []
    },
    "2005": {
        "db_id": "soccer_2016",
        "question": "How many victory matches were there in 2008?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM Match WHERE Match_Date LIKE '2008%' AND Match_Winner IS NOT NULL",
        "amends": [
            "Do count `Match_Id` instead of `*` to avoid counting NULL values. Do reference table `Match` instead of `matches` with proper schema naming. Do filter on `Match_Date LIKE '2008%'` instead of `year = 2008` to capture all matches from 2008 regardless of date format. Do filter on `Match_Winner IS NOT NULL` instead of `result = 'victory'` to properly identify completed matches with a winner rather than relying on a specific victory string. The amended query now correctly counts completed matches from 2008 by using proper NULL handling and date filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2008 AND result = 'victory';",
            "SELECT COUNT(Match_Id) FROM Match WHERE Match_Date LIKE '2008%' AND Match_Winner IS NOT NULL"
        ],
        "rule_sql": []
    },
    "4685": {
        "db_id": "disney",
        "question": "List the movie titles and character names by Bill Thompson.",
        "ground_truth": "SELECT movie, character FROM `voice-actors` WHERE 'voice-actor' = 'Bill Thompson'",
        "amends": [
            "Do reference table `voice-actors` instead of `movies` in the FROM clause. Do select columns `movie` and `character` instead of `movie_title` and `character_name` in the SELECT list. Do use filter condition `'voice-actor' = 'Bill Thompson'` instead of `actor_name = 'Bill Thompson'` in the WHERE clause. The amended query now correctly retrieves data from the appropriate table structure with the proper column names and filter condition.",
            "Do use backticks `voice-actors` instead of double quotes \"voice-actors\" for the table identifier, and do use single quotes 'voice-actor' instead of double quotes \"voice-actor\" for the column identifier in the WHERE clause instead of using double quotes for both. The amended query now correctly uses backticks for table names and single quotes for string literals and column references, matching the right SQL's behavior.",
            "Do use backtick-quoted identifier `voice-actor` in the WHERE clause instead of incorrectly using a string literal 'voice-actor', which would compare the literal string 'voice-actor' to 'Bill Thompson' instead of filtering by the column value. The amended query now correctly references the column name with backticks to filter rows where the voice-actor column equals 'Bill Thompson', matching the intended behavior of the right SQL.",
            "Do use backtick-quoted identifier `voice-actor` in the WHERE clause instead of incorrectly using a string literal 'voice-actor' which would always evaluate to true when compared to 'Bill Thompson'. The amended query now correctly filters for rows where the voice-actor column equals 'Bill Thompson', matching the intended behavior.",
            "Do use backtick-quoted identifier `voice-actor` in the WHERE clause instead of incorrectly using it as a string literal 'voice-actor', which would cause the condition to always evaluate to false since a string literal cannot equal another string literal. This change ensures proper column reference instead of a constant comparison that would filter out all rows. The amended query now correctly filters for rows where the voice-actor column equals 'Bill Thompson', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_title, character_name FROM movies WHERE actor_name = 'Bill Thompson'",
            "SELECT movie, character FROM \"voice-actors\" WHERE \"voice-actor\" = 'Bill Thompson'",
            "SELECT movie, character FROM `voice-actors` WHERE `voice-actor` = 'Bill Thompson'",
            "SELECT movie, character FROM `voice-actors` WHERE `voice-actor` = 'Bill Thompson'",
            "SELECT movie, character FROM `voice-actors` WHERE `voice-actor` = 'Bill Thompson'",
            "SELECT movie, character FROM `voice-actors` WHERE `voice-actor` = 'Bill Thompson'"
        ],
        "rule_sql": []
    },
    "2455": {
        "db_id": "superstore",
        "question": "Who ordered the order ID CA-2011-118976 from the East region?",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Order ID` = 'CA-2011-118976' AND T2.Region = 'East'",
        "amends": [
            "Do use `DISTINCT T2.`Customer Name`` instead of `customer_name` to select from the people table with distinct values. Do join `east_superstore AS T1 INNER JOIN people AS T2` instead of querying only the orders table, adding the required join condition `ON T1.`Customer ID` = T2.`Customer ID``. Do filter on `T1.`Order ID` = 'CA-2011-118976'` instead of `order_id = 'CA-2011-118976'` to reference the correct table. Do change the region filter to `T2.Region = 'East'` instead of `region = 'West'` to both reference the correct table and use the proper region value. The amended query now correctly retrieves distinct customer names from the joined tables with accurate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM orders WHERE order_id = 'CA-2011-118976' AND region = 'West';",
            "SELECT DISTINCT T2.\"Customer Name\"\nFROM east_superstore AS T1\nINNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nWHERE T1.\"Order ID\" = 'CA-2011-118976'\nAND T2.Region = 'East'"
        ],
        "rule_sql": []
    },
    "6178": {
        "db_id": "food_inspection_2",
        "question": "How many inspections were done under the personnel category?",
        "ground_truth": "SELECT COUNT(T1.inspection_id) FROM violation AS T1 INNER JOIN inspection_point AS T2 ON T1.point_id = T2.point_id WHERE T2.category = 'Personnel'",
        "amends": [
            "Do select `COUNT(T1.inspection_id)` from specific column instead of `COUNT(*)` from all rows. Do use `violation AS T1` and `inspection_point AS T2` as source tables instead of only `inspections`. Do add `INNER JOIN` on `T1.point_id = T2.point_id` instead of having no join condition. Do filter on `T2.category = 'Personnel'` with proper table reference and capitalization instead of `category = 'personnel'` from a single table. The amended query now correctly counts inspection violations specifically in the Personnel category by properly joining the violation and inspection_point tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE category = 'personnel';",
            "SELECT COUNT(T1.inspection_id) \nFROM violation AS T1\nINNER JOIN inspection_point AS T2 ON T1.point_id = T2.point_id\nWHERE T2.category = 'Personnel'"
        ],
        "rule_sql": []
    },
    "7120": {
        "db_id": "works_cycles",
        "question": "What is the forename and birthdate of person number 18?",
        "ground_truth": "SELECT T1.FirstName, T2.BirthDate FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.BusinessEntityID = 18",
        "amends": [
            "Do use `T1.FirstName` and `T2.BirthDate` instead of `forename` and `birthdate`. Do add `INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` instead of querying only the `persons` table. Do use `T1.BusinessEntityID = 18` instead of `person_id = 18` as the filter condition. The amended query now correctly joins the Person and Employee tables to retrieve the employee's first name and birth date using the proper BusinessEntityID relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT forename, birthdate FROM persons WHERE person_id = 18;",
            "SELECT T1.FirstName, T2.BirthDate FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.BusinessEntityID = 18"
        ],
        "rule_sql": []
    },
    "5248": {
        "db_id": "beer_factory",
        "question": "Among all the root beers purchased by Frank-Paul Santangelo, how many of them were non-sweetened?",
        "ground_truth": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE T1.First = 'Frank-Paul' AND T1.Last = 'Santangelo' AND T4.ArtificialSweetener = 'FALSE' AND T4.Honey = 'FALSE'",
        "amends": [
            "Do use `COUNT(T1.CustomerID)` instead of `COUNT(*)` to count specific customer records. Do join `transaction` table as `T2` instead of `purchases` table, connecting via `T1.CustomerID = T2.CustomerID` instead of `p.customer_id = c.customer_id`. Do join `rootbeer` table as `T3` instead of `products` table, connecting via `T2.RootBeerID = T3.RootBeerID` instead of `p.product_id = pr.product_id`. Do add an additional join to `rootbeerbrand` table as `T4` via `T3.BrandID = T4.BrandID` instead of omitting it. Do filter on `T4.ArtificialSweetener = 'FALSE'` and `T4.Honey = 'FALSE'` instead of `pr.sweetened = 'yes'` to properly identify unsweetened root beer products. Do use column names `T1.First` and `T1.Last` instead of `c.first_name` and `c.last_name` for customer name matching. The amended query now correctly counts transactions for Frank-Paul Santangelo involving root beer products without artificial sweeteners or honey, matching the intended behavior.",
            "Do count `T1.CustomerID` instead of `T2.CustomerID` to ensure the count reflects unique customers rather than potentially duplicated transaction records. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity, though this is functionally equivalent. The amended query now correctly counts unique customers matching the specified criteria while maintaining the same join logic and filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM purchases p\nJOIN customers c ON p.customer_id = c.customer_id\nJOIN products pr ON p.product_id = pr.product_id\nWHERE c.first_name = 'Frank-Paul' AND c.last_name = 'Santangelo'\nAND pr.category = 'root beer'\nAND pr.sweetened = 'yes';",
            "SELECT COUNT(T2.CustomerID) \nFROM customers T1\nJOIN transaction T2 ON T1.CustomerID = T2.CustomerID\nJOIN rootbeer T3 ON T2.RootBeerID = T3.RootBeerID\nJOIN rootbeerbrand T4 ON T3.BrandID = T4.BrandID\nWHERE T1.First = 'Frank-Paul' AND T1.Last = 'Santangelo'\nAND T4.ArtificialSweetener = 'FALSE' AND T4.Honey = 'FALSE'",
            "SELECT COUNT(T1.CustomerID)\nFROM customers T1\nINNER JOIN \"transaction\" T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN rootbeer T3 ON T2.RootBeerID = T3.RootBeerID\nINNER JOIN rootbeerbrand T4 ON T3.BrandID = T4.BrandID\nWHERE T1.First = 'Frank-Paul' AND T1.Last = 'Santangelo'\nAND T4.ArtificialSweetener = 'FALSE' AND T4.Honey = 'FALSE'"
        ],
        "rule_sql": []
    },
    "1384": {
        "db_id": "synthea",
        "question": "When did Mrs. Ira Deckow have the standard pregnancy test?",
        "ground_truth": "SELECT T2.date FROM patients AS T1 INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mrs.' AND T1.first = 'Ira' AND T1.last = 'Deckow' AND T2.description = 'Standard pregnancy test'",
        "amends": [
            "Do select `T2.date` from the `procedures` table instead of `test_date` from `pregnancy_tests`. Do join `patients AS T1` with `procedures AS T2` on `T1.patient = T2.PATIENT` instead of querying a single table. Do filter on `T1.prefix = 'Mrs.' AND T1.first = 'Ira' AND T1.last = 'Deckow'` instead of `patient_name = 'Mrs. Ira Deckow'`. Do filter on `T2.description = 'Standard pregnancy test'` instead of `test_type = 'standard'`. The amended query now correctly joins patient and procedure data using proper relational identifiers and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT test_date FROM pregnancy_tests WHERE patient_name = 'Mrs. Ira Deckow' AND test_type = 'standard'",
            "SELECT T2.DATE\nFROM patients AS T1\nJOIN procedures AS T2 ON T1.patient = T2.PATIENT\nWHERE T1.prefix = 'Mrs.' AND T1.first = 'Ira' AND T1.last = 'Deckow'\nAND T2.DESCRIPTION = 'Standard pregnancy test'"
        ],
        "rule_sql": []
    },
    "3986": {
        "db_id": "public_review_platform",
        "question": "List all the businesses that closed at 8PM.",
        "ground_truth": "SELECT DISTINCT business_id FROM Business_Hours WHERE closing_time = '8PM'",
        "amends": [
            "Do select `DISTINCT business_id` instead of `*` to return only unique business identifiers rather than all columns. Do query from `Business_Hours` table instead of `businesses` to access the correct data source containing closing time information. Do keep the filter `closing_time = '8PM'` unchanged as it correctly identifies the target closing time. The amended query now correctly returns distinct business IDs from the Business_Hours table that close at 8PM, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM businesses WHERE closing_time = '8PM';",
            "SELECT DISTINCT business_id FROM Business_Hours WHERE closing_time = '8PM'"
        ],
        "rule_sql": []
    },
    "6037": {
        "db_id": "books",
        "question": "What is the status of the orders placed on 04/10/2022?",
        "ground_truth": "SELECT DISTINCT T1.status_value FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id WHERE T3.order_date LIKE '2022-04-10%'",
        "amends": [
            "Do select `DISTINCT T1.status_value` instead of `status` from a single table. Do add joins to `order_status AS T1`, `order_history AS T2`, and `cust_order AS T3` instead of querying only `orders`. Do use `INNER JOIN` on `T1.status_id = T2.status_id` and `T3.order_id = T2.order_id` instead of no joins. Do change the WHERE filter to `T3.order_date LIKE '2022-04-10%'` instead of `order_date = '2022-04-10'` to capture partial date matches. The amended query now correctly retrieves distinct status values through proper table relationships and date filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status FROM orders WHERE order_date = '2022-04-10';",
            "SELECT DISTINCT T1.status_value\nFROM order_status AS T1\nINNER JOIN order_history AS T2 ON T1.status_id = T2.status_id\nINNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id\nWHERE T3.order_date LIKE '2022-04-10%'"
        ],
        "rule_sql": []
    },
    "7850": {
        "db_id": "world",
        "question": "Who is the head of the country where Santa Catarina district belongs?",
        "ground_truth": "SELECT T1.HeadOfState FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T2.District = 'Santa Catarina'",
        "amends": [
            "Do reference `HeadOfState` instead of `head_of_state` in the SELECT list. Do join `Country` table instead of `countries` and use `City` table instead of `districts` as the source. Do use `T1.Code = T2.CountryCode` as the join condition instead of `c.country_id = d.country_id`. Do filter on `T2.District = 'Santa Catarina'` instead of `d.name = 'Santa Catarina'` in the WHERE clause. The amended query now correctly retrieves head of state information by joining Country with City tables using the proper relationship and filtering on the district column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.head_of_state FROM countries c JOIN districts d ON c.country_id = d.country_id WHERE d.name = 'Santa Catarina';",
            "SELECT c.HeadOfState \nFROM Country c\nJOIN City ct ON c.Code = ct.CountryCode\nWHERE ct.District = 'Santa Catarina'"
        ],
        "rule_sql": []
    },
    "1259": {
        "db_id": "law_episode",
        "question": "Which episode got the most 1 star votes? Give its title.",
        "ground_truth": "SELECT T2.title FROM Vote AS T1 INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE T1.stars = 1 ORDER BY T1.votes DESC LIMIT 1",
        "amends": [
            "Do select `T2.title` from the `Episode` table instead of just `title` from `episodes`. Do add an `INNER JOIN` between `Vote` as `T1` and `Episode` as `T2` on `T2.episode_id = T1.episode_id` instead of querying a single table. Do add a `WHERE` filter for `T1.stars = 1` instead of omitting any star condition. Do order by `T1.votes DESC` instead of `votes_1_star DESC`. The amended query now correctly joins the Vote and Episode tables to find the episode with the most 1-star votes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY votes_1_star DESC LIMIT 1;",
            "SELECT T2.title\nFROM Vote AS T1\nINNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.stars = 1\nORDER BY T1.votes DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5586": {
        "db_id": "shipping",
        "question": "Among the shipments in 2017, how many of them have the destination in New Jersey?",
        "ground_truth": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE STRFTIME('%Y', T1.ship_date) = '2017' AND T2.state = 'New Jersey'",
        "amends": [
            "Do join `shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id` instead of querying only the `shipments` table. Do filter by `STRFTIME('%Y', T1.ship_date) = '2017'` to extract the year from the date column instead of using a simple `year = 2017` condition. Do filter by `T2.state = 'New Jersey'` on the joined city table instead of using `destination = 'New Jersey'` directly. The amended query now correctly joins the necessary tables and uses proper date extraction and state filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE year = 2017 AND destination = 'New Jersey';",
            "SELECT COUNT(*) \nFROM shipment AS T1 \nINNER JOIN city AS T2 ON T1.city_id = T2.city_id \nWHERE STRFTIME('%Y', T1.ship_date) = '2017' \nAND T2.state = 'New Jersey'"
        ],
        "rule_sql": []
    },
    "1576": {
        "db_id": "car_retails",
        "question": "How many employees who are living in Australia and have the credit limit under 200000? State their email address and countries where they are working.",
        "ground_truth": "SELECT T2.email, T3.country FROM customers AS T1 INNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber INNER JOIN offices AS T3 ON T2.officeCode = T3.officeCode WHERE T3.country = 'Australia' AND T1.creditLimit < 200000 AND T2.jobTitle = 'Sales Rep'",
        "amends": [
            "Do use `T2.email` and `T3.country` in the SELECT list instead of `email`, `country`, and `COUNT(*) as employee_count`. Do join `customers AS T1`, `employees AS T2`, and `offices AS T3` instead of querying only the `employees` table. Do use `INNER JOIN` on `T1.salesRepEmployeeNumber = T2.employeeNumber` and `T2.officeCode = T3.officeCode` instead of no joins. Do add filters for `T3.country = 'Australia'`, `T1.creditLimit < 200000`, and `T2.jobTitle = 'Sales Rep'` instead of `country = 'Australia'` and `credit_limit < 200000`. Do remove the `GROUP BY email, country` clause instead of keeping it. The amended query now correctly joins related tables and applies appropriate filters to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email, country, COUNT(*) as employee_count \nFROM employees \nWHERE country = 'Australia' AND credit_limit < 200000 \nGROUP BY email, country;",
            "SELECT T2.email, T3.country\nFROM customers AS T1\nINNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber\nINNER JOIN offices AS T3 ON T2.officeCode = T3.officeCode\nWHERE T3.country = 'Australia' \nAND T1.creditLimit < 200000 \nAND T2.jobTitle = 'Sales Rep'"
        ],
        "rule_sql": []
    },
    "8729": {
        "db_id": "chicago_crime",
        "question": "What is the difference between the number of communities that are located on the north and south sides with a population of more than 30,000?",
        "ground_truth": "SELECT SUM(CASE WHEN side = 'South ' THEN 1 ELSE 0 END) - SUM(CASE WHEN side = 'North' THEN 1 ELSE 0 END) AS DIFF FROM Community_Area WHERE population > 300000",
        "amends": [
            "Do use a single query with conditional aggregation using `SUM(CASE WHEN side = 'South ' THEN 1 ELSE 0 END)` instead of separate subqueries with `COUNT(*)`. Do reference the correct table name `Community_Area` instead of `communities`. Do use the correct population threshold `300000` instead of `30000`. Do handle the case sensitivity and spacing in side values with `'South '` (with trailing space) and `'North'` instead of `'south'` and `'north'`. Do calculate the difference as South minus North instead of North minus South. The amended query now correctly computes the population difference between southern and northern communities above the 300,000 threshold."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM communities WHERE side = 'north' AND population > 30000) - \n    (SELECT COUNT(*) FROM communities WHERE side = 'south' AND population > 30000) AS difference;",
            "SELECT \n    SUM(CASE WHEN side = 'South ' THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN side = 'North' THEN 1 ELSE 0 END) AS difference\nFROM Community_Area\nWHERE population > 300000;"
        ],
        "rule_sql": []
    },
    "5009": {
        "db_id": "olympics",
        "question": "How many 20 years old athletes were there in the 1984 Summer Olympic Games?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name = '1984 Summer' AND T2.age = 20",
        "amends": [
            "Do select `COUNT(T2.person_id)` instead of `COUNT(*)` to count distinct competitors. Do join `games AS T1` and `games_competitor AS T2` with `INNER JOIN` on `T1.id = T2.games_id` instead of querying a single `athletes` table. Do filter on `T1.games_name = '1984 Summer'` instead of separate `year = 1984 AND season = 'Summer'` conditions. Do filter on `T2.age = 20` instead of `age = 20` to reference the correct table. The amended query now correctly counts 20-year-old competitors from the 1984 Summer games by properly joining the games and competitor tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE age = 20 AND year = 1984 AND season = 'Summer';",
            "SELECT COUNT(T2.person_id) \nFROM games AS T1\nINNER JOIN games_competitor AS T2 ON T1.id = T2.games_id\nWHERE T1.games_name = '1984 Summer'\nAND T2.age = 20"
        ],
        "rule_sql": []
    },
    "2904": {
        "db_id": "professional_basketball",
        "question": "Percentage of games lost out of total games played by the Houston Mavericks",
        "ground_truth": "SELECT CAST(SUM(lost) AS REAL) * 100 / SUM(games) FROM teams WHERE name = 'Houston Mavericks'",
        "amends": [
            "Do use `CAST(SUM(lost) AS REAL) * 100 / SUM(games)` instead of `(losses / (wins + losses)) * 100` for the calculation expression. Do reference `SUM(lost)` and `SUM(games)` instead of individual `losses` and `wins` columns. Do use `name` instead of `team_name` for the filter column. Do remove the `AS loss_percentage` alias instead of keeping it. The amended query now correctly calculates the loss percentage using aggregate functions and proper casting to handle division."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (losses / (wins + losses)) * 100 AS loss_percentage FROM teams WHERE team_name = 'Houston Mavericks';",
            "SELECT CAST(SUM(lost) AS REAL) * 100 / SUM(games) FROM teams WHERE name = 'Houston Mavericks';"
        ],
        "rule_sql": []
    },
    "7667": {
        "db_id": "hockey",
        "question": "Among the players who became coaches, how many of them have gotten in the Hall of Fame?",
        "ground_truth": "SELECT COUNT(T1.playerID) FROM Master AS T1 INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE T1.playerID IS NOT NULL AND T1.coachID IS NOT NULL",
        "amends": [
            "Do select `COUNT(T1.playerID)` instead of `COUNT(*)` to count specific non-null player IDs. Do use `Master AS T1` and `HOF AS T2` as table sources instead of `players p` and `coaches c`. Do perform an `INNER JOIN` on `T1.hofID = T2.hofID` instead of joining on `p.player_id = c.player_id`. Do add filters for `T1.playerID IS NOT NULL` and `T1.coachID IS NOT NULL` instead of only checking `p.hall_of_fame = 'Yes'`. The amended query now correctly counts players with Hall of Fame entries while ensuring both player and coach IDs are present, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players p JOIN coaches c ON p.player_id = c.player_id WHERE p.hall_of_fame = 'Yes';",
            "SELECT COUNT(T1.playerID) \nFROM Master AS T1\nINNER JOIN HOF AS T2 ON T1.hofID = T2.hofID\nWHERE T1.playerID IS NOT NULL AND T1.coachID IS NOT NULL"
        ],
        "rule_sql": []
    },
    "3464": {
        "db_id": "video_games",
        "question": "Calculate the difference between sales of games from region ID 2 and region ID 3.",
        "ground_truth": "SELECT SUM(CASE WHEN T.region_id = 2 THEN T.num_sales ELSE 0 END) - SUM(CASE WHEN T.region_id = 3 THEN T.num_sales ELSE 0 END) FROM region_sales t",
        "amends": [
            "Do reference the table with alias `T` instead of using unqualified column names. Do use column `num_sales` instead of `sales` in the CASE expressions. Do specify the correct table name `region_sales` with alias `T` instead of `games` in the FROM clause. The amended query now correctly calculates the sales difference between regions 2 and 3 using the proper table structure and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(CASE WHEN region_id = 2 THEN sales ELSE 0 END) - SUM(CASE WHEN region_id = 3 THEN sales ELSE 0 END) AS sales_difference FROM games;",
            "SELECT \n    SUM(CASE WHEN T.region_id = 2 THEN T.num_sales ELSE 0 END) - \n    SUM(CASE WHEN T.region_id = 3 THEN T.num_sales ELSE 0 END) AS sales_difference\nFROM region_sales T"
        ],
        "rule_sql": []
    },
    "8455": {
        "db_id": "mondial_geo",
        "question": "Which constitutional monarchy nations saw the greatest growth in the number of organizations after 1907?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE STRFTIME('%Y', T2.Established) > '1907' AND T3.Government = 'constitutional monarchy' GROUP BY T1.Name ORDER BY COUNT(DISTINCT T2.Name) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country, COUNT(*) as growth`. Do use `INNER JOIN organization AS T2 ON T1.Code = T2.Country` and `INNER JOIN politics AS T3 ON T3.Country = T2.Country` instead of querying only the `organizations` table. Do filter with `STRFTIME('%Y', T2.Established) > '1907'` instead of `year > 1907` and `T3.Government = 'constitutional monarchy'` instead of `government_type = 'constitutional monarchy'`. Do group by `T1.Name` instead of `country`. Do order by `COUNT(DISTINCT T2.Name) DESC` instead of `growth DESC`. Do limit to `1` instead of `5`. The amended query now correctly joins multiple tables, uses proper date extraction, counts distinct organization names, and returns the single top country matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as growth FROM organizations WHERE year > 1907 AND government_type = 'constitutional monarchy' GROUP BY country ORDER BY growth DESC LIMIT 5;",
            "SELECT T1.Name\nFROM country AS T1\nINNER JOIN organization AS T2 ON T1.Code = T2.Country\nINNER JOIN politics AS T3 ON T3.Country = T2.Country\nWHERE STRFTIME('%Y', T2.Established) > '1907'\nAND T3.Government = 'constitutional monarchy'\nGROUP BY T1.Name\nORDER BY COUNT(DISTINCT T2.Name) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6703": {
        "db_id": "retails",
        "question": "Give the percentage of Japanese suppliers whose account is in debt.",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.n_name = 'JAPAN', 1, 0)) AS REAL) * 100 / COUNT(T1.s_name) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0",
        "amends": [
            "Do use `SUM(IIF(T2.n_name = 'JAPAN', 1, 0))` instead of `COUNT(*)` to count only Japanese suppliers. Do join `supplier AS T1` with `nation AS T2` on `T1.s_nationkey = T2.n_nationkey` instead of filtering by `country = 'Japan'` directly. Do move the country filter condition into the `IIF` function instead of using a `WHERE` clause. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T1.s_name)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) ...)`. Do remove the redundant subquery and instead perform the calculation in a single query with proper joins. Do filter by `T1.s_acctbal < 0` instead of `account_balance < 0` using the correct column name. The amended query now correctly calculates the percentage of Japanese suppliers with negative account balances relative to all suppliers.",
            "Do remove the `T2.n_name = 'JAPAN'` condition from the `IIF` function's logical test instead of including it there, and do move the `T1.s_acctbal < 0` filter to the `WHERE` clause instead of keeping it within the `IIF` function. Do maintain the same `INNER JOIN` between `supplier` and `nation` on `s_nationkey = n_nationkey` instead of changing the join logic. The amended query now correctly calculates the percentage of Japanese suppliers with negative account balances by first filtering for negative balances in the WHERE clause and then counting only Japanese suppliers in the numerator, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM suppliers WHERE country = 'Japan')) AS percentage\nFROM suppliers \nWHERE country = 'Japan' AND account_balance < 0;",
            "SELECT CAST(SUM(IIF(T2.n_name = 'JAPAN' AND T1.s_acctbal < 0, 1, 0)) AS REAL) * 100 / COUNT(T1.s_name) AS percentage\nFROM supplier AS T1\nJOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey;",
            "SELECT \n    CAST(SUM(IIF(T2.n_name = 'JAPAN', 1, 0)) AS REAL) * 100 / COUNT(T1.s_name) AS percentage\nFROM \n    supplier AS T1\nINNER JOIN \n    nation AS T2 ON T1.s_nationkey = T2.n_nationkey\nWHERE \n    T1.s_acctbal < 0"
        ],
        "rule_sql": []
    },
    "8779": {
        "db_id": "food_inspection",
        "question": "How many low risk violations were found in the inspection on 2014/1/14 for Tiramisu Kitchen?",
        "ground_truth": "SELECT COUNT(T1.business_id) FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.`date` = '2014-01-14' AND T2.name = 'Tiramisu Kitchen' AND T1.risk_category = 'Low Risk'",
        "amends": [
            "Do select `COUNT(T1.business_id)` from the `violations` table instead of `COUNT(*)` from the `inspections` table. Do join `businesses AS T2` with `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying a single table. Do filter on `T1.date = '2014-01-14'` with proper date format instead of `inspection_date = '2014/1/14'`. Do filter on `T2.name = 'Tiramisu Kitchen'` instead of `restaurant_name = 'Tiramisu Kitchen'`. Do keep the `risk_category = 'Low Risk'` filter but apply it to the `violations` table instead of the `inspections` table. The amended query now correctly counts violations for the specified business on the given date with the proper risk category, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE restaurant_name = 'Tiramisu Kitchen' AND inspection_date = '2014/1/14' AND risk_category = 'Low Risk'",
            "SELECT COUNT(T1.business_id) \nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T1.date = '2014-01-14' \nAND T2.name = 'Tiramisu Kitchen' \nAND T1.risk_category = 'Low Risk'"
        ],
        "rule_sql": []
    },
    "7177": {
        "db_id": "works_cycles",
        "question": "How much is HL Grip Tape's profit ratio?",
        "ground_truth": "SELECT (T1.LastReceiptCost - T1.StandardPrice) / T1.StandardPrice FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'HL Grip Tape'",
        "amends": [
            "Do reference columns `T1.LastReceiptCost` and `T1.StandardPrice` instead of `price` and `cost`. Do join tables `ProductVendor AS T1` and `Product AS T2` with `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying a single table. Do filter on `T2.Name = 'HL Grip Tape'` instead of `product_name = 'HL Grip Tape'`. Do omit the `profit_ratio` alias instead of including it. The amended query now correctly calculates the profit ratio using the appropriate table structure and column references.",
            "Do calculate `(T1.LastReceiptCost - T1.StandardPrice) / T1.StandardPrice` instead of `((T1.StandardPrice - T1.LastReceiptCost) / T1.StandardPrice) * 100` to compute the correct percentage difference formula. The amended query now matches RIGHT_SQL's behavior by properly calculating the cost variance percentage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (price - cost) / price * 100 AS profit_ratio FROM products WHERE product_name = 'HL Grip Tape';",
            "SELECT ((T1.StandardPrice - T1.LastReceiptCost) / T1.StandardPrice) * 100 FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'HL Grip Tape'",
            "SELECT (T1.LastReceiptCost - T1.StandardPrice) / T1.StandardPrice \nFROM ProductVendor AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID \nWHERE T2.Name = 'HL Grip Tape'"
        ],
        "rule_sql": []
    },
    "8680": {
        "db_id": "chicago_crime",
        "question": "What kind of location in Austin reported the most number of crimes?",
        "ground_truth": "SELECT T2.location_description FROM District AS T1 INNER JOIN Crime AS T2 ON T2.district_no = T1.district_no WHERE T1.district_name = 'Austin' GROUP BY T2.location_description ORDER BY COUNT(T2.case_number) DESC LIMIT 1",
        "amends": [
            "Do select `T2.location_description` instead of `location_type` and `crime_count`. Do use `FROM District AS T1 INNER JOIN Crime AS T2` instead of `FROM crimes`. Do change the join condition to `ON T2.district_no = T1.district_no` instead of no join. Do change the WHERE filter to `T1.district_name = 'Austin'` instead of `city = 'Austin'`. Do group by `T2.location_description` instead of `location_type`. Do order by `COUNT(T2.case_number) DESC` instead of `crime_count DESC`. The amended query now correctly joins District and Crime tables to find the most common crime location description in Austin district rather than counting crimes by location type in Austin city.",
            "Do remove `COUNT(T2.case_number) AS crime_count` from the SELECT list instead of including it, as the RIGHT_SQL only requires the location_description column. Do maintain the same `INNER JOIN` on `T2.district_no = T1.district_no` with the unchanged `WHERE T1.district_name = 'Austin'` filter, and preserve the identical `GROUP BY T2.location_description` with the same `ORDER BY COUNT(T2.case_number) DESC` and `LIMIT 1` structure. The amended query now correctly returns only the single most frequent crime location description for the Austin district without the unnecessary crime count column, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_type, COUNT(*) as crime_count FROM crimes WHERE city = 'Austin' GROUP BY location_type ORDER BY crime_count DESC LIMIT 1;",
            "SELECT T2.location_description, COUNT(T2.case_number) AS crime_count\nFROM District AS T1\nINNER JOIN Crime AS T2 ON T2.district_no = T1.district_no\nWHERE T1.district_name = 'Austin'\nGROUP BY T2.location_description\nORDER BY COUNT(T2.case_number) DESC\nLIMIT 1;",
            "SELECT T2.location_description\nFROM District AS T1\nINNER JOIN Crime AS T2 ON T2.district_no = T1.district_no\nWHERE T1.district_name = 'Austin'\nGROUP BY T2.location_description\nORDER BY COUNT(T2.case_number) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "525": {
        "db_id": "movies_4",
        "question": "What is the most common keyword among all the movies released in 2006?",
        "ground_truth": "SELECT T3.keyword_name FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE T1.release_date LIKE '2006%' GROUP BY T3.keyword_name ORDER BY COUNT(T3.keyword_name) DESC LIMIT 1",
        "amends": [
            "Do join `movie` table as `T1` and `movie_keywords` as `T2` on `T1.movie_id = T2.movie_id` instead of querying only `movies` table. Do join `keyword` table as `T3` on `T2.keyword_id = T3.keyword_id` instead of missing the keyword relationship. Do filter on `T1.release_date LIKE '2006%'` instead of `release_year = 2006` to handle date-based filtering. Do select `T3.keyword_name` instead of just `keyword` to properly reference the joined table. Do group by `T3.keyword_name` instead of `keyword` to match the selected column. Do order by `COUNT(T3.keyword_name)` instead of `count` to explicitly reference the aggregate function. The amended query now correctly joins the necessary tables to find the most frequent keyword for 2006 movies and matches the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T3.keyword_name) as keyword_count` from the SELECT list instead of including it, and do change the ORDER BY clause to use `COUNT(T3.keyword_name) DESC` instead of referencing the removed alias `keyword_count`. The amended query now correctly returns only the keyword name while maintaining the same ranking logic based on count frequency."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword, COUNT(*) as count FROM movies WHERE release_year = 2006 GROUP BY keyword ORDER BY count DESC LIMIT 1;",
            "SELECT T3.keyword_name, COUNT(T3.keyword_name) as keyword_count\nFROM movie T1\nJOIN movie_keywords T2 ON T1.movie_id = T2.movie_id\nJOIN keyword T3 ON T2.keyword_id = T3.keyword_id\nWHERE T1.release_date LIKE '2006%'\nGROUP BY T3.keyword_name\nORDER BY keyword_count DESC\nLIMIT 1;",
            "SELECT T3.keyword_name\nFROM movie AS T1\nJOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id\nJOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id\nWHERE T1.release_date LIKE '2006%'\nGROUP BY T3.keyword_name\nORDER BY COUNT(T3.keyword_name) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7331": {
        "db_id": "works_cycles",
        "question": "List all product only MOQ of 1,000 and with standard cost more than 17.",
        "ground_truth": "SELECT T2.Name FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T1.MaxOrderQty = 1000 AND T2.StandardCost > 17",
        "amends": [
            "Do specify exact columns `T2.Name` instead of selecting all columns with `*`. Do join tables `ProductVendor AS T1`, `Product AS T2`, and `Vendor AS T3` instead of querying only the `products` table. Do use `INNER JOIN` on `T1.ProductID = T2.ProductID` and `T1.BusinessEntityID = T3.BusinessEntityID` instead of no joins. Do filter on `T1.MaxOrderQty = 1000` instead of `MOQ = 1000` and `T2.StandardCost > 17` instead of `standard_cost > 17`. The amended query now correctly joins related tables and filters on the appropriate columns to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products WHERE MOQ = 1000 AND standard_cost > 17;",
            "SELECT T2.Name \nFROM ProductVendor AS T1\nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID\nINNER JOIN Vendor AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID\nWHERE T1.MaxOrderQty = 1000 AND T2.StandardCost > 17;"
        ],
        "rule_sql": []
    },
    "8790": {
        "db_id": "food_inspection",
        "question": "Tell the Id number of the business with the most number of violations.",
        "ground_truth": "SELECT business_id FROM violations GROUP BY business_id ORDER BY COUNT(business_id) DESC LIMIT 1",
        "amends": [
            "Do select `business_id` instead of `Id` from the businesses table. Do add `GROUP BY business_id` to aggregate violations by business instead of ordering by the raw violations column. Do order by `COUNT(business_id)` DESC instead of `violations` DESC to sort by the number of violations per business rather than the violations column value itself. Do use the violations table instead of the businesses table as the data source to properly count violations. The amended query now correctly identifies the business with the most violations by counting and grouping violation records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Id FROM businesses ORDER BY violations DESC LIMIT 1;",
            "SELECT business_id FROM violations GROUP BY business_id ORDER BY COUNT(business_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2409": {
        "db_id": "superstore",
        "question": "What is the total quantity that Cindy Stewart order \"Lexmark X 9575 Professional All-in-One Color Printer\" in the south superstore?",
        "ground_truth": "SELECT SUM(T1.Quantity) FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Cindy Stewart' AND T3.`Product Name` = 'Lexmark X 9575 Professional All-in-One Color Printer'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `o`, `c`, and `p`. Do reference `T1.Quantity` instead of `quantity`. Do use `south_superstore` as the main table instead of `orders`. Do join with `people` on `T1.Customer ID = T2.Customer ID` instead of `customers` on `o.customer_id = c.customer_id`. Do join with `product` on `T3.Product ID = T1.Product ID` instead of `products` on `o.product_id = p.product_id`. Do remove the join with `stores` and the `s.region = 'South'` filter instead of keeping them. Do filter on `T2.Customer Name = 'Cindy Stewart'` instead of separate `first_name` and `last_name` conditions. Do keep the `T3.Product Name` filter unchanged. The amended query now correctly aggregates sales for the specified customer and product without the unnecessary region constraint.",
            "Do remove the redundant `Region` join condition from both joins instead of including it, specifically removing `T1.Region = T2.Region` from the people join and `T1.Region = T3.Region` from the product join. Do use standard `INNER JOIN` syntax instead of just `JOIN` for clarity. Do remove the alias `AS total_quantity` from the SUM aggregation instead of keeping it. Do use backticks instead of double quotes for column identifiers like `Customer ID` and `Product Name` instead of double quotes. Do fix the join direction in the product table join to `T3.Product ID = T1.Product ID` instead of `T1.Product ID = T3.Product ID` to maintain consistent table reference order. The amended query now correctly matches the RIGHT_SQL's behavior by eliminating unnecessary join conditions and standardizing syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) \nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nJOIN products p ON o.product_id = p.product_id\nJOIN stores s ON o.store_id = s.store_id\nWHERE c.first_name = 'Cindy' \nAND c.last_name = 'Stewart'\nAND p.product_name = 'Lexmark X 9575 Professional All-in-One Color Printer'\nAND s.region = 'South'",
            "SELECT SUM(T1.Quantity) AS total_quantity\nFROM south_superstore T1\nJOIN people T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" AND T1.Region = T2.Region\nJOIN product T3 ON T1.\"Product ID\" = T3.\"Product ID\" AND T1.Region = T3.Region\nWHERE T2.\"Customer Name\" = 'Cindy Stewart'\nAND T3.\"Product Name\" = 'Lexmark X 9575 Professional All-in-One Color Printer'",
            "SELECT SUM(T1.Quantity)\nFROM south_superstore T1\nINNER JOIN people T2 ON T1.`Customer ID` = T2.`Customer ID`\nINNER JOIN product T3 ON T3.`Product ID` = T1.`Product ID`\nWHERE T2.`Customer Name` = 'Cindy Stewart'\nAND T3.`Product Name` = 'Lexmark X 9575 Professional All-in-One Color Printer'"
        ],
        "rule_sql": []
    },
    "2566": {
        "db_id": "app_store",
        "question": "List the top 5 lowest rated puzzle games and count the number of negative sentiments the games received.",
        "ground_truth": "SELECT T1.App, COUNT(T1.App) COUNTNUMBER FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T2.Sentiment = 'Negative' GROUP BY T1.App ORDER BY T1.Rating LIMIT 5",
        "amends": [
            "Do use `T1.App` and `COUNT(T1.App) COUNTNUMBER` in the SELECT list instead of `game_name` and `COUNT(*) as negative_count`. Do join `playstore AS T1` with `user_reviews AS T2` using `INNER JOIN` on `T1.App = T2.App` instead of querying only the `games` table. Do filter with `T2.Sentiment = 'Negative'` instead of `genre = 'puzzle'`. Do add `GROUP BY T1.App` instead of omitting grouping. Do order by `T1.Rating` instead of `rating ASC`. The amended query now correctly counts negative reviews per app from the joined tables instead of counting puzzle games by rating.",
            "Do remove the `T1.Category = 'Puzzle'` filter from the WHERE clause instead of keeping it, as the right query focuses only on negative sentiment reviews across all categories. Do keep the `ORDER BY T1.Rating` without the ASC keyword instead of specifying ASC explicitly, since ASC is the default sort order. The amended query now correctly counts negative sentiment reviews for all apps without restricting to the Puzzle category, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name, COUNT(*) as negative_count \nFROM games \nWHERE genre = 'puzzle' \nORDER BY rating ASC \nLIMIT 5;",
            "SELECT T1.App, COUNT(T1.App) COUNTNUMBER\nFROM playstore AS T1\nINNER JOIN user_reviews AS T2 ON T1.App = T2.App\nWHERE T1.Category = 'Puzzle' AND T2.Sentiment = 'Negative'\nGROUP BY T1.App\nORDER BY T1.Rating ASC\nLIMIT 5",
            "SELECT T1.App, COUNT(T1.App) COUNTNUMBER\nFROM playstore AS T1\nINNER JOIN user_reviews AS T2 ON T1.App = T2.App\nWHERE T2.Sentiment = 'Negative'\nGROUP BY T1.App\nORDER BY T1.Rating\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "7917": {
        "db_id": "world",
        "question": "Among the countries that use Italian as their language, what is the percentage of republic countries?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.GovernmentForm = 'Republic' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM CountryLanguage AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.Language = 'Italian'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.GovernmentForm = 'Republic' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN governmentform = 'Republic' THEN 1 END)` for proper conditional counting. Do add `INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code` instead of querying a single table, properly relating language data to country information. Do reference `T2.GovernmentForm` instead of `governmentform` to specify the joined table. Do use `CountryLanguage AS T1` as the main table instead of `country` to access language-specific data. Do filter on `T1.Language = 'Italian'` instead of `language = 'Italian'` with proper table qualification. Do add explicit `CAST(... AS REAL)` instead of implicit decimal handling for precise percentage calculation. Do remove the alias `percentage_republic` instead of keeping it since the right query omits it. The amended query now correctly joins language and country tables to calculate the percentage of Italian-speaking countries that are republics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN governmentform = 'Republic' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_republic\nFROM country\nWHERE language = 'Italian';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.GovernmentForm = 'Republic' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100\nFROM \n    CountryLanguage AS T1\nINNER JOIN \n    Country AS T2 ON T1.CountryCode = T2.Code\nWHERE \n    T1.Language = 'Italian'"
        ],
        "rule_sql": []
    },
    "7223": {
        "db_id": "works_cycles",
        "question": "What is the shipping address for the sales order \"43873\"?",
        "ground_truth": "SELECT T1.ShipToAddressID FROM SalesOrderHeader AS T1 INNER JOIN Address AS T2 ON T1.BillToAddressID = T2.AddressID WHERE T1.SalesOrderID = 43873 GROUP BY T1.ShipToAddressID",
        "amends": [
            "Do select `T1.ShipToAddressID` instead of `billing_address`. Do join `SalesOrderHeader AS T1` with `Address AS T2` using `INNER JOIN` on `T1.BillToAddressID = T2.AddressID` instead of querying only `sales_orders`. Do filter on `T1.SalesOrderID = 43873` instead of `order_number = '43873'`. Do add `GROUP BY T1.ShipToAddressID` instead of omitting aggregation. The amended query now correctly retrieves the shipping address ID by joining order header with address tables and filtering by numeric SalesOrderID instead of string order number."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT billing_address FROM sales_orders WHERE order_number = '43873';",
            "SELECT T1.ShipToAddressID \nFROM SalesOrderHeader AS T1 \nINNER JOIN Address AS T2 ON T1.BillToAddressID = T2.AddressID \nWHERE T1.SalesOrderID = 43873 \nGROUP BY T1.ShipToAddressID"
        ],
        "rule_sql": []
    },
    "493": {
        "db_id": "movies_4",
        "question": "What is the genre of the movie title with the lowest revenue generated?",
        "ground_truth": "SELECT T3.genre_name FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id ORDER BY T1.revenue LIMIT 1",
        "amends": [
            "Do join `movie_genres` and `genre` tables instead of querying only the `movies` table. Do select `T3.genre_name` instead of `genre` from a single table. Do use `INNER JOIN` on `T1.movie_id = T2.movie_id` and `T2.genre_id = T3.genre_id` instead of no joins. Do order by `T1.revenue` instead of `revenue` from an unspecified table. The amended query now correctly retrieves the genre name with the lowest revenue by properly joining the necessary tables to resolve genre information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM movies ORDER BY revenue ASC LIMIT 1;",
            "SELECT T3.genre_name \nFROM movie T1\nINNER JOIN movie_genres T2 ON T1.movie_id = T2.movie_id\nINNER JOIN genre T3 ON T2.genre_id = T3.genre_id\nORDER BY T1.revenue ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "216": {
        "db_id": "book_publishing_company",
        "question": "Which job level is O'Rourke at?",
        "ground_truth": "SELECT job_lvl FROM employee WHERE lname = 'O''Rourke'",
        "amends": [
            "Do reference column `job_lvl` instead of `job_level` in the SELECT list. Do reference table `employee` instead of `employees` in the FROM clause. Do reference column `lname` instead of `last_name` in the WHERE filter. The amended query now correctly matches the target schema and returns the intended results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_level FROM employees WHERE last_name = 'O''Rourke';",
            "SELECT job_lvl FROM employee WHERE lname = 'O''Rourke'"
        ],
        "rule_sql": []
    },
    "1770": {
        "db_id": "restaurant",
        "question": "What is the name of the most popular restaurant serving Asian foods in San Francisco?",
        "ground_truth": "SELECT label FROM generalinfo WHERE food_type = 'asian' AND city = 'san francisco' AND review = ( SELECT MAX(review) FROM generalinfo WHERE food_type = 'asian' AND city = 'san francisco' )",
        "amends": [
            "Do select `label` from `generalinfo` instead of `name` from `restaurants`. Do use `food_type = 'asian'` instead of `cuisine = 'Asian'` and `city = 'san francisco'` instead of `city = 'San Francisco'`. Do add a subquery with `MAX(review)` to find the highest review instead of using `ORDER BY rating DESC LIMIT 1`. Do remove the explicit `ORDER BY` and `LIMIT` clauses in favor of the subquery approach. Do change the table reference from `restaurants` to `generalinfo` and the column references from `name` and `rating` to `label` and `review` respectively. The amended query now correctly identifies the record with the maximum review value using a correlated subquery instead of relying on sorting and limiting, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE cuisine = 'Asian' AND city = 'San Francisco' ORDER BY rating DESC LIMIT 1;",
            "SELECT label FROM generalinfo WHERE food_type = 'asian' AND city = 'san francisco' AND review = (SELECT MAX(review) FROM generalinfo WHERE food_type = 'asian' AND city = 'san francisco')"
        ],
        "rule_sql": []
    },
    "6087": {
        "db_id": "books",
        "question": "What is the title of the first book that was written by A.J. Ayer?",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'A.J. Ayer' ORDER BY T1.publication_date ASC LIMIT 1",
        "amends": [
            "Do add joins to `book_author` and `author` tables instead of querying only the `books` table. Do use `INNER JOIN` on `T1.book_id = T2.book_id` and `INNER JOIN` on `T3.author_id = T2.author_id` instead of missing these relationships entirely. Do filter on `T3.author_name = 'A.J. Ayer'` instead of filtering directly on `author` in the books table. Do qualify columns with table aliases like `T1.title` and `T1.publication_date` instead of using unqualified column names. The amended query now correctly joins through the relationship tables to find books by author name instead of assuming author information is stored directly in the books table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE author = 'A.J. Ayer' ORDER BY publication_date ASC LIMIT 1;",
            "SELECT b.title\nFROM book b\nINNER JOIN book_author ba ON b.book_id = ba.book_id\nINNER JOIN author a ON ba.author_id = a.author_id\nWHERE a.author_name = 'A.J. Ayer'\nORDER BY b.publication_date ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7915": {
        "db_id": "world",
        "question": "In countries with constitutional monarchy, what is the percentage of cities located in the district of England?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.District = 'England' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.GovernmentForm = 'Constitutional Monarchy'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.District = 'England' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    City c\nJOIN \n    Country co ON c.CountryCode = co.Code\nWHERE \n    co.GovernmentForm = 'Constitutional Monarchy';"
        ],
        "rule_sql": []
    },
    "334": {
        "db_id": "retail_complains",
        "question": "Among the female clients, how many of them have a complaint with a priority of 1?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.sex = 'Female' AND T2.priority = 1",
        "amends": [
            "Do select `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific client records. Do use `client AS T1` and `callcenterlogs AS T2` as table sources instead of just `clients`. Do add `INNER JOIN` on `T1.client_id = T2.rand client` instead of querying a single table. Do filter on `T1.sex = 'Female'` instead of `gender = 'female'` for proper column reference and case sensitivity. Do filter on `T2.priority = 1` instead of `priority = 1` to reference the correct table's priority column. The amended query now correctly joins client and callcenterlogs tables to count female clients with priority 1 calls, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE gender = 'female' AND priority = 1;",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\"\nWHERE T1.sex = 'Female' AND T2.priority = 1"
        ],
        "rule_sql": []
    },
    "316": {
        "db_id": "retail_complains",
        "question": "How many clients who live in Kansas City provided a 1-star review?",
        "ground_truth": "SELECT COUNT(T1.Stars) FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.city = 'Kansas City' AND T1.Stars = 1",
        "amends": [
            "Do select `COUNT(T1.Stars)` from the `reviews` table instead of `COUNT(*)` from the `clients` table. Do join `district AS T2` using `INNER JOIN` with predicate `T1.district_id = T2.district_id` instead of querying a single table. Do filter on `T2.city = 'Kansas City'` instead of a non-existent city column in clients, and maintain the `T1.Stars = 1` condition instead of a non-existent review_rating column. The amended query now correctly counts reviews with one star from Kansas City districts instead of attempting to count from an incorrect table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE city = 'Kansas City' AND review_rating = 1;",
            "SELECT COUNT(T1.Stars) \nFROM reviews AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.city = 'Kansas City' AND T1.Stars = 1;"
        ],
        "rule_sql": []
    },
    "5561": {
        "db_id": "menu",
        "question": "What is the ID of the menu with the most number of dishes?",
        "ground_truth": "SELECT id FROM Menu ORDER BY dish_count DESC LIMIT 1",
        "amends": [
            "Do select `id` from the `Menu` table instead of `menu_id` from the `dishes` table. Do use a direct column reference `dish_count` for ordering instead of calculating `COUNT(*)` from a grouped aggregation. Do remove the `GROUP BY` clause and aggregation entirely instead of grouping by `menu_id`. Do query the `Menu` table directly instead of joining or aggregating from the `dishes` table. The amended query now correctly retrieves the menu ID with the highest dish count directly from the Menu table's pre-calculated dish_count column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT menu_id FROM dishes GROUP BY menu_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT id FROM Menu ORDER BY dish_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7647": {
        "db_id": "hockey",
        "question": "Among the players who won an award in the year 1983, how many of them play the position of goalie?",
        "ground_truth": "SELECT COUNT(playerID) FROM AwardsPlayers WHERE pos = 'G' AND year = 1983",
        "amends": [
            "Do select `COUNT(playerID)` instead of `COUNT(*)` to count specific non-null values. Do use table `AwardsPlayers` instead of joining `players` and `awards` tables since all needed data exists in one table. Do filter on `pos = 'G'` instead of `p.position = 'goalie'` to use the correct column name and value format. Do keep the `year = 1983` filter but apply it directly to the AwardsPlayers table instead of through a join. Do remove the unnecessary table join entirely instead of maintaining the join structure. The amended query now correctly counts goalies who received awards in 1983 using the appropriate table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players p\nJOIN awards a ON p.player_id = a.player_id\nWHERE a.year = 1983 AND p.position = 'goalie';",
            "SELECT COUNT(playerID) FROM AwardsPlayers WHERE year = 1983 AND pos = 'G'"
        ],
        "rule_sql": []
    },
    "9100": {
        "db_id": "bike_share_1",
        "question": "How many subscribers have ended their trip at MLK Library and how many docks does that station have?",
        "ground_truth": "SELECT COUNT(T1.id), T2.dock_count FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.end_station_name = 'MLK Library' AND T1.subscription_type = 'Subscriber' AND T2.dock_count = 19",
        "amends": [
            "Do count `T1.id` instead of `COUNT(*)` and select `T2.dock_count` instead of `docks`. Do join `trip AS T1` with `station AS T2` instead of `trips t` with `stations s` and use `INNER JOIN` on `T2.name = T1.start_station_name` instead of `JOIN` on `t.end_station_id = s.station_id`. Do filter with `T1.end_station_name = 'MLK Library'` instead of `s.name = 'MLK Library'` and use `T1.subscription_type = 'Subscriber'` instead of `t.subscriber_type = 'Subscriber'`. Do add `T2.dock_count = 19` instead of omitting this filter. The amended query now correctly counts trips ending at MLK Library for subscribers at stations with exactly 19 docks."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS subscriber_count, docks FROM trips t JOIN stations s ON t.end_station_id = s.station_id WHERE s.name = 'MLK Library' AND t.subscriber_type = 'Subscriber';",
            "SELECT COUNT(T1.id) AS subscriber_count, T2.dock_count\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.end_station_name = 'MLK Library'\nAND T1.subscription_type = 'Subscriber'\nAND T2.dock_count = 19"
        ],
        "rule_sql": []
    },
    "2760": {
        "db_id": "european_football_1",
        "question": "Which away team in the division of Bundesliga has the highest final time goals?",
        "ground_truth": "SELECT T1.AwayTeam FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div=T2.division WHERE T2.name = 'Bundesliga' ORDER BY T1.FTAG DESC LIMIT 1",
        "amends": [
            "Do reference `T1.AwayTeam` instead of `away_team` and remove the aggregate function instead of using `MAX(final_time_goals)`. Do join `matchs AS T1` with `divisions AS T2` on `T1.Div=T2.division` instead of querying only the `matches` table. Do filter with `T2.name = 'Bundesliga'` instead of `division = 'Bundesliga'`. Do order by `T1.FTAG DESC` instead of `MAX(final_time_goals) DESC` and remove the `GROUP BY away_team` clause instead of keeping it. The amended query now correctly joins tables to filter by division name and retrieves the away team with the highest full-time away goals for the Bundesliga division."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT away_team, MAX(final_time_goals) \nFROM matches \nWHERE division = 'Bundesliga' \nGROUP BY away_team \nORDER BY MAX(final_time_goals) DESC \nLIMIT 1;",
            "SELECT T1.AwayTeam\nFROM matchs AS T1\nJOIN divisions AS T2 ON T1.Div = T2.division\nWHERE T2.name = 'Bundesliga'\nORDER BY T1.FTAG DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7925": {
        "db_id": "music_platform_2",
        "question": "List the authors who created review for podcast titled 'Pop Rocket' in 2016 with rating less than 5.",
        "ground_truth": "SELECT T2.author_id FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'Pop Rocket' AND T2.created_at LIKE '2016-%' AND T2.rating < 5",
        "amends": [
            "Do select `T2.author_id` instead of `author_name` and change the source tables to use `podcasts AS T1` and `reviews AS T2` instead of just `authors`. Do use `INNER JOIN` on `T2.podcast_id = T1.podcast_id` instead of querying a single table. Do change the filter to `T1.title = 'Pop Rocket'` instead of `podcast_title = 'Pop Rocket'` and use `T2.created_at LIKE '2016-%'` for year filtering instead of `year = 2016`. Do change the rating condition to `T2.rating < 5` instead of `rating >= 5`. The amended query now correctly joins the podcasts and reviews tables to find authors with low ratings for the specified podcast in 2016, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM authors WHERE podcast_title = 'Pop Rocket' AND year = 2016 AND rating >= 5;",
            "SELECT T2.author_id\nFROM podcasts AS T1\nINNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id\nWHERE T1.title = 'Pop Rocket'\nAND T2.created_at LIKE '2016-%'\nAND T2.rating < 5"
        ],
        "rule_sql": []
    },
    "3014": {
        "db_id": "shakespeare",
        "question": "List down any 5 titles in the history genre.",
        "ground_truth": "SELECT Title FROM works WHERE GenreType = 'History' LIMIT 5",
        "amends": [
            "Do reference `Title` instead of `title` and use table `works` instead of `books`. Do filter on `GenreType = 'History'` instead of `genre = 'history'` to match the correct column name and case sensitivity. The amended query now correctly retrieves historical works from the appropriate table with proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE genre = 'history' LIMIT 5;",
            "SELECT Title FROM works WHERE GenreType = 'History' LIMIT 5;"
        ],
        "rule_sql": []
    },
    "4763": {
        "db_id": "legislator",
        "question": "What is the current official Youtube username of Chris Van Hollen?",
        "ground_truth": "SELECT T2.youtube FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id WHERE T1.official_full_name = 'Chris Van Hollen'",
        "amends": [
            "Do select `T2.youtube` instead of `username` and change the data source to use `current AS T1 INNER JOIN social-media AS T2` instead of `youtube_users`. Do add the join condition `ON T2.bioguide = T1.bioguide_id` instead of no join. Do filter on `T1.official_full_name = 'Chris Van Hollen'` instead of `full_name = 'Chris Van Hollen'`. Do remove `ORDER BY created_at DESC LIMIT 1` instead of keeping it. The amended query now correctly retrieves the YouTube handle from the joined social media table using the bioguide identifier instead of searching a standalone users table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT username FROM youtube_users WHERE full_name = 'Chris Van Hollen' ORDER BY created_at DESC LIMIT 1;",
            "SELECT T2.youtube FROM current AS T1 INNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id WHERE T1.official_full_name = 'Chris Van Hollen'"
        ],
        "rule_sql": []
    },
    "862": {
        "db_id": "cs_semester",
        "question": "Please list the full names of all the students who took the course Machine Learning Theory.",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Machine Learning Theory'",
        "amends": [
            "Do use table aliases `T1.f_name` and `T1.l_name` instead of direct column references `first_name` and `last_name`. Do add `INNER JOIN registration AS T2` and `INNER JOIN course AS T3` instead of querying only the `students` table. Do use join conditions `ON T1.student_id = T2.student_id` and `ON T2.course_id = T3.course_id` instead of no joins. Do filter on `T3.name = 'Machine Learning Theory'` instead of `course = 'Machine Learning Theory'` to properly reference the course table. The amended query now correctly joins through the registration table to find students enrolled in the specific course, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE course = 'Machine Learning Theory';",
            "SELECT T1.f_name, T1.l_name\nFROM student AS T1\nINNER JOIN registration AS T2 ON T1.student_id = T2.student_id\nINNER JOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T3.name = 'Machine Learning Theory'"
        ],
        "rule_sql": []
    },
    "5836": {
        "db_id": "airline",
        "question": "What is the average departure delay time of flights operated by American Airlines Inc.?",
        "ground_truth": "SELECT AVG(T1.DEP_DELAY) FROM Airlines AS T1 INNER JOIN Airports AS T2 ON T2.Code = T1.ORIGIN INNER JOIN `Air Carriers` AS T3 ON T1.OP_CARRIER_AIRLINE_ID = T3.Code WHERE T3.Description = 'American Airlines Inc.: AA'",
        "amends": [
            "Do add joins to `Airlines AS T1`, `Airports AS T2`, and `Air Carriers AS T3` instead of querying only the `flights` table. Do use `AVG(T1.DEP_DELAY)` instead of `AVG(departure_delay)` for the aggregate calculation. Do join `T2.Code = T1.ORIGIN` and `T1.OP_CARRIER_AIRLINE_ID = T3.Code` instead of having no join conditions. Do filter on `T3.Description = 'American Airlines Inc.: AA'` instead of `carrier = 'American Airlines Inc.'` to properly identify the carrier. The amended query now correctly joins multiple tables to calculate average departure delay for the specific airline carrier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(departure_delay) FROM flights WHERE carrier = 'American Airlines Inc.'",
            "SELECT AVG(T1.DEP_DELAY) \nFROM Airlines AS T1\nJOIN \"Air Carriers\" AS T3 ON T1.OP_CARRIER_AIRLINE_ID = T3.Code\nWHERE T3.Description = 'American Airlines Inc.: AA'"
        ],
        "rule_sql": []
    },
    "4216": {
        "db_id": "simpson_episodes",
        "question": "Among the casts who were born in Los Angeles, describe the name and birth date of who have 1.8 m and above in height.",
        "ground_truth": "SELECT name, birthdate FROM Person WHERE birth_place = 'Los Angeles' AND height_meters >= 1.8;",
        "amends": [
            "Do reference table `Person` instead of `casts` and select column `birthdate` instead of `birth_date`. Do filter on column `height_meters` instead of `height` while maintaining the same conditions for `birth_place = 'Los Angeles'` and `height_meters >= 1.8`. The amended query now correctly references the appropriate table schema and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, birth_date FROM casts WHERE birth_place = 'Los Angeles' AND height >= 1.8;",
            "SELECT name, birthdate FROM Person WHERE birth_place = 'Los Angeles' AND height_meters >= 1.8;"
        ],
        "rule_sql": []
    },
    "2559": {
        "db_id": "app_store",
        "question": "What is the percentage for free application with a rating 4.5 and above have not been updated since 2018?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN SUBSTR('Last Updated', -4) > '2018' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(App) PER FROM playstore WHERE Type = 'Free' AND Rating >= 4.5",
        "amends": [
            "Do use `CAST` and `SUM` with conditional logic instead of `COUNT` with `CASE` for percentage calculation. Do reference columns `App` and `Type` instead of omitting them. Do filter with `WHERE Type = 'Free'` instead of `price = 0`. Do use `SUBSTR('Last Updated', -4) > '2018'` for date comparison instead of `last_updated < '2018-01-01'`. Do calculate percentage as `SUM(CASE...) * 100 / COUNT(App)` instead of `COUNT(CASE...) * 100.0 / COUNT(CASE...)`. Do use table `playstore` instead of `applications`. The amended query now correctly filters free apps, uses proper date extraction, and calculates the percentage of apps updated after 2018 among highly-rated free apps."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN price = 0 AND rating >= 4.5 AND last_updated < '2018-01-01' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN price = 0 AND rating >= 4.5 THEN 1 END)) AS percentage\nFROM applications;",
            "SELECT \n    (SUM(CASE WHEN SUBSTR('Last Updated', -4) > '2018' THEN 1 ELSE 0 END) * 100.0 / COUNT(App)) AS percentage\nFROM playstore\nWHERE Type = 'Free' AND Rating >= 4.5"
        ],
        "rule_sql": []
    },
    "4396": {
        "db_id": "student_loan",
        "question": "Which students that filed for bankruptcy are also in the foreign legion?",
        "ground_truth": "SELECT T2.name FROM enlist AS T1 INNER JOIN filed_for_bankrupcy AS T2 ON T1.`name` = T2.`name` WHERE T1.organ = 'foreign_legion'",
        "amends": [
            "Do select only `T2.name` instead of all columns with `*`. Do use `enlist` as T1 and `filed_for_bankrupcy` as T2 instead of `students`. Do perform an `INNER JOIN` on `T1.name=T2.name` instead of querying a single table. Do filter on `T1.organ='foreign_legion'` instead of separate `bankruptcy='filed'` and `foreign_legion='yes'` conditions. The amended query now correctly joins the enlist and bankruptcy tables to find foreign legion members who filed for bankruptcy, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE bankruptcy = 'filed' AND foreign_legion = 'yes';",
            "SELECT T2.name \nFROM enlist AS T1 \nINNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name \nWHERE T1.organ = 'foreign_legion'"
        ],
        "rule_sql": []
    },
    "3808": {
        "db_id": "public_review_platform",
        "question": "Provide the businesses name in Tempe city whose opening hours are earlier than 8AM.",
        "ground_truth": "SELECT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Business_Hours AS T4 ON T3.business_id = T4.business_id WHERE T3.city LIKE 'Tempe' AND T4.opening_time < '8AM'",
        "amends": [
            "Do use `T1.category_name` in the SELECT list instead of `name`. Do add three INNER JOINs instead of querying a single table: join `Categories AS T1` to `Business_Categories AS T2` on `T1.category_id = T2.category_id`, then join to `Business AS T3` on `T2.business_id = T3.business_id`, and finally join to `Business_Hours AS T4` on `T3.business_id = T4.business_id`. Do change the WHERE filter to use `T3.city LIKE 'Tempe'` instead of `city = 'Tempe'` and `T4.opening_time < '8AM'` instead of `opening_hours < '08:00:00'`. The amended query now correctly joins multiple tables to retrieve category names for businesses in Tempe with specific opening hours, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE city = 'Tempe' AND opening_hours < '08:00:00';",
            "SELECT T1.category_name\nFROM Categories AS T1\nINNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id\nINNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nINNER JOIN Business_Hours AS T4 ON T3.business_id = T4.business_id\nWHERE T3.city LIKE 'Tempe' AND T4.opening_time < '8AM'"
        ],
        "rule_sql": []
    },
    "7532": {
        "db_id": "image_and_language",
        "question": "How many images contain 'bridge' as an object element?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.IMG_ID) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'bridge'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.IMG_ID)` instead of `COUNT(*)` to count unique images rather than all rows. Do join `IMG_OBJ AS T1` with `OBJ_CLASSES AS T2` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single `images` table. Do filter on `T2.OBJ_CLASS = 'bridge'` instead of `object = 'bridge'` to properly reference the joined table structure. Do remove the direct table reference and simple condition in favor of the correct join relationship and classification system. The amended query now correctly counts distinct images associated with the 'bridge' object class through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE object = 'bridge';",
            "SELECT COUNT(DISTINCT T1.IMG_ID) \nFROM IMG_OBJ AS T1 \nJOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID \nWHERE T2.OBJ_CLASS = 'bridge'"
        ],
        "rule_sql": []
    },
    "4746": {
        "db_id": "legislator",
        "question": "What is the username of the current official Facebook presence of the oldest current legislator?",
        "ground_truth": "SELECT T2.facebook FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id ORDER BY T1.birthday_bio LIMIT 1",
        "amends": [
            "Do select `T2.facebook` instead of `username`. Do use `current AS T1` and `social-media AS T2` as source tables instead of `legislators` and `social_media`. Do perform an `INNER JOIN` on `T2.bioguide = T1.bioguide_id` instead of `JOIN` on `legislators.id = social_media.legislator_id`. Do remove the `WHERE` clause with `platform = 'Facebook'` and subquery for minimum birth date instead of keeping it. Do add `ORDER BY T1.birthday_bio` instead of omitting ordering. Do keep `LIMIT 1` as in the original. The amended query now correctly retrieves the Facebook handle from the joined tables ordered by birthday instead of using complex filtering with subqueries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT username FROM legislators JOIN social_media ON legislators.id = social_media.legislator_id WHERE platform = 'Facebook' AND birth_date = (SELECT MIN(birth_date) FROM legislators) LIMIT 1;",
            "SELECT T2.facebook\nFROM current AS T1\nINNER JOIN \"social-media\" AS T2 ON T2.bioguide = T1.bioguide_id\nORDER BY T1.birthday_bio\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4695": {
        "db_id": "disney",
        "question": "Who is the voice actor of the hero in Lion King?",
        "ground_truth": "SELECT T1.`voice-actor` FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T1.movie = T2.movie_title WHERE T2.movie_title = 'Lion King' AND T1.character = 'Lion King'",
        "amends": [
            "Do use `INNER JOIN` with `characters AS T2` on `T1.movie = T2.movie_title` instead of querying only the `voice_actors` table. Do reference `T1.character` instead of `character` and filter it to `'Lion King'` instead of `'hero'`. Do select `T1.voice-actor` with proper quoting instead of `actor_name`. Do add a condition `T2.movie_title = 'Lion King'` in the WHERE clause instead of filtering only on `movie = 'Lion King'`. The amended query now correctly joins tables and filters for the Lion King movie character instead of a generic hero, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM voice_actors WHERE movie = 'Lion King' AND character = 'hero';",
            "SELECT T1.\"voice-actor\" \nFROM \"voice-actors\" AS T1\nINNER JOIN characters AS T2 ON T1.movie = T2.movie_title\nWHERE T2.movie_title = 'Lion King' AND T1.character = T2.hero"
        ],
        "rule_sql": []
    },
    "6824": {
        "db_id": "retails",
        "question": "List all the nations in Europe.",
        "ground_truth": "SELECT T2.n_name FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey WHERE T1.r_name = 'EUROPE'",
        "amends": [
            "Do select `T2.n_name` instead of `*` to return only the nation names instead of all columns. Do use `region AS T1 INNER JOIN nation AS T2` instead of `FROM countries` to join the region and nation tables instead of querying a single countries table. Do specify the join condition `T1.r_regionkey = T2.n_regionkey` instead of omitting any join logic. Do filter on `T1.r_name = 'EUROPE'` instead of `continent = 'Asia'` to select European nations instead of Asian countries. The amended query now correctly joins region and nation tables to return nation names from Europe, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM countries WHERE continent = 'Asia';",
            "SELECT T2.n_name FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey WHERE T1.r_name = 'EUROPE'"
        ],
        "rule_sql": []
    },
    "1571": {
        "db_id": "car_retails",
        "question": "List out full name of employees who are working in Tokyo?",
        "ground_truth": "SELECT T1.firstName, T1.lastName FROM employees AS T1 INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE T2.city = 'Tokyo'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of bare table names. Do add `INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode` instead of querying only the employees table. Do reference `T2.city` in the WHERE clause instead of `city` to filter by office location rather than employee address. Do qualify column names as `T1.firstName` and `T1.lastName` instead of unqualified `first_name` and `last_name`. The amended query now correctly joins the employees and offices tables to filter employees based on their office location in Tokyo rather than assuming employees have a city attribute."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE city = 'Tokyo';",
            "SELECT T1.firstName, T1.lastName FROM employees AS T1 INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE T2.city = 'Tokyo'"
        ],
        "rule_sql": []
    },
    "2772": {
        "db_id": "european_football_1",
        "question": "How many draw games happened on 2018/8/7 for National League?",
        "ground_truth": "SELECT COUNT(T1.FTR) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'National League' AND T1.Date = '2018-08-07' AND T1.FTR = 'D'",
        "amends": [
            "Do select `COUNT(T1.FTR)` instead of `COUNT(*)` to count specific draw outcomes. Do use tables `matchs AS T1` and `divisions AS T2` with an `INNER JOIN` on `T1.Div = T2.division` instead of querying only the `games` table. Do filter by `T2.name = 'National League'` instead of `league = 'National League'` to reference the division name correctly. Do use date format `'2018-08-07'` instead of `'2018/8/7'` for proper date comparison. Do filter by `T1.FTR = 'D'` instead of `home_score = away_score` to identify draws using the dedicated result column. The amended query now correctly counts drawn matches in the National League on the specified date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE date = '2018/8/7' AND league = 'National League' AND home_score = away_score;",
            "SELECT COUNT(T1.FTR) \nFROM matchs AS T1 \nINNER JOIN divisions AS T2 ON T1.Div = T2.division \nWHERE T2.name = 'National League' \nAND T1.Date = '2018-08-07' \nAND T1.FTR = 'D'"
        ],
        "rule_sql": []
    },
    "584": {
        "db_id": "codebase_comments",
        "question": "How much is the processed time of the method whose tokenized name is \"about box1 dispose\"? Indicate the language of the method.",
        "ground_truth": "SELECT DISTINCT T1.ProcessedTime, T2.Lang FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.NameTokenized = 'about box1 dispose'",
        "amends": [
            "Do select `T1.ProcessedTime` and `T2.Lang` instead of `processed_time` and `language`. Do use `DISTINCT` instead of omitting it. Do join `Solution AS T1` and `Method AS T2` with `INNER JOIN` on `T1.Id = T2.SolutionId` instead of querying only the `methods` table. Do filter on `T2.NameTokenized = 'about box1 dispose'` instead of `tokenized_name = 'about box1 dispose'`. The amended query now correctly joins the Solution and Method tables to retrieve the processed time and language for methods with the specified tokenized name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT processed_time, language FROM methods WHERE tokenized_name = 'about box1 dispose';",
            "SELECT DISTINCT T1.ProcessedTime, T2.Lang FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.NameTokenized = 'about box1 dispose'"
        ],
        "rule_sql": []
    },
    "3652": {
        "db_id": "authors",
        "question": "List all of the conferences where a paper was published in 2008.",
        "ground_truth": "SELECT DISTINCT T2.FullName FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T1.Year = 2008",
        "amends": [
            "Do select `T2.FullName` instead of `conference` to retrieve the conference name from the joined table. Do join `Conference AS T2` with `Paper AS T1` using `INNER JOIN` on `T1.ConferenceId = T2.Id` instead of querying only the papers table. Do filter on `T1.Year = 2008` instead of `year = 2007` to target the correct year. The amended query now correctly joins conference data and filters for the specified year, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT conference FROM papers WHERE year = 2007;",
            "SELECT DISTINCT T2.FullName \nFROM Paper AS T1 \nINNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id \nWHERE T1.Year = 2008"
        ],
        "rule_sql": []
    },
    "8138": {
        "db_id": "sales_in_weather",
        "question": "How many units of item no.9 were sold in store no.1 in total in January, 2012?",
        "ground_truth": "SELECT SUM(units) FROM sales_in_weather WHERE SUBSTR(`date`, 6, 2) = '01' AND SUBSTR(`date`, 1, 4) = '2012' AND item_nbr = 9 AND store_nbr = 1",
        "amends": [
            "Do reference table `sales_in_weather` instead of `sales`. Do use column `units` instead of `quantity` for aggregation. Do filter by `item_nbr = 9` instead of `item_id = 9`. Do filter by `store_nbr = 1` instead of `store_id = 1`. Do extract month using `SUBSTR(date, 6, 2) = '01'` instead of `month = 1`. Do extract year using `SUBSTR(date, 1, 4) = '2012'` instead of `year = 2012`. The amended query now correctly references the target table structure and properly extracts date components from the date string format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM sales WHERE item_id = 9 AND store_id = 1 AND year = 2012 AND month = 1;",
            "SELECT SUM(units) AS total_units\nFROM sales_in_weather\nWHERE item_nbr = 9\nAND store_nbr = 1\nAND SUBSTR(date, 1, 4) = '2012'\nAND SUBSTR(date, 6, 2) = '01';"
        ],
        "rule_sql": []
    },
    "2719": {
        "db_id": "regional_sales",
        "question": "How much is the discount applied to the order with the highest unit price?",
        "ground_truth": "SELECT `Discount Applied` FROM `Sales Orders` WHERE REPLACE(`Unit Price`, ',', '') = ( SELECT REPLACE(`Unit Price`, ',', '') FROM `Sales Orders` ORDER BY REPLACE(`Unit Price`, ',', '') DESC LIMIT 1 ) ORDER BY REPLACE(`Unit Price`, ',', '') DESC LIMIT 1",
        "amends": [
            "Do use a subquery to find the maximum `Unit Price` instead of calculating `MAX(UnitPrice) * 0.1`. Do reference the `Sales Orders` table instead of `OrderDetails`. Do apply `REPLACE` function to handle comma-formatted prices instead of assuming numeric values. Do filter with `WHERE` comparing the current row's price to the maximum price instead of using an aggregate function. Do select the actual `Discount Applied` column instead of calculating a derived discount. Do add `ORDER BY` and `LIMIT 1` to ensure only the highest-priced row is returned instead of a single aggregate value. The amended query now correctly retrieves the discount value from the row with the highest unit price while properly handling formatted numeric values.",
            "Do use backticks instead of double quotes for column and table names like `Discount Applied` and `Sales Orders` instead of \"Discount Applied\" and \"Sales Orders\". Do use a subquery that directly returns the cleaned string value with `REPLACE(Unit Price, ',', '')` instead of using `MAX(CAST(REPLACE(Unit Price, ',', '') AS REAL))` to find the maximum value. Do maintain the same `ORDER BY REPLACE(Unit Price, ',', '') DESC` clause instead of `CAST(REPLACE(Unit Price, ',', '') AS REAL) DESC` since the comparison is now between string values rather than numeric values. The amended query now correctly identifies the record with the highest unit price by comparing string values directly and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(UnitPrice) * 0.1 AS Discount FROM OrderDetails;",
            "SELECT \"Discount Applied\" \nFROM \"Sales Orders\" \nWHERE REPLACE(\"Unit Price\", ',', '') = (\n    SELECT MAX(CAST(REPLACE(\"Unit Price\", ',', '') AS REAL)) \n    FROM \"Sales Orders\"\n)\nORDER BY CAST(REPLACE(\"Unit Price\", ',', '') AS REAL) DESC\nLIMIT 1;",
            "SELECT `Discount Applied` \nFROM `Sales Orders` \nWHERE REPLACE(`Unit Price`, ',', '') = (\n    SELECT MAX(REPLACE(`Unit Price`, ',', '')) \n    FROM `Sales Orders`\n)\nORDER BY REPLACE(`Unit Price`, ',', '') DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1956": {
        "db_id": "soccer_2016",
        "question": "List the names of all the umpires from England.",
        "ground_truth": "SELECT T1.Umpire_Name FROM Umpire AS T1 INNER JOIN country AS T2 ON T2.Country_Id = T1.Umpire_Country WHERE T2.Country_Name = 'England'",
        "amends": [
            "Do select `T1.Umpire_Name` instead of `name` and use table aliases. Do join `Umpire AS T1` with `country AS T2` on `T2.Country_Id = T1.Umpire_Country` instead of querying a single table. Do filter on `T2.Country_Name = 'England'` instead of `country = 'England'` to properly reference the joined country table. The amended query now correctly joins tables to filter umpires by country name rather than relying on a direct country field in the umpires table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM umpires WHERE country = 'England';",
            "SELECT T1.Umpire_Name \nFROM Umpire AS T1 \nJOIN Country AS T2 ON T2.Country_Id = T1.Umpire_Country \nWHERE T2.Country_Name = 'England'"
        ],
        "rule_sql": []
    },
    "8049": {
        "db_id": "university",
        "question": "Provide the ranking system ID of the Center for World University Rankings.",
        "ground_truth": "SELECT id FROM ranking_system WHERE system_name = 'Center for World University Rankings'",
        "amends": [
            "Do select `id` instead of `ranking_system_id` from the table. Do use table name `ranking_system` instead of `ranking_systems`. Do filter on `system_name` instead of `name` for the condition. The amended query now correctly retrieves the identifier from the appropriate table using the correct column name for filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_system_id FROM ranking_systems WHERE name = 'Center for World University Rankings';",
            "SELECT id FROM ranking_system WHERE system_name = 'Center for World University Rankings';"
        ],
        "rule_sql": []
    },
    "7563": {
        "db_id": "image_and_language",
        "question": "Find the object in image 5 where the object with the coordinate of (634, 468).",
        "ground_truth": "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ WHERE IMG_ID = 5 AND X = 634 AND Y = 468",
        "amends": [
            "Do select `OBJ_SAMPLE_ID` instead of `*` for all columns. Do use table `IMG_OBJ` instead of `objects` as the source. Do reference column `IMG_ID` instead of `image_id` in the filter condition. The amended query now correctly retrieves only the OBJ_SAMPLE_ID from the IMG_OBJ table with the specified image and coordinate filters, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM objects WHERE image_id = 5 AND x = 634 AND y = 468;",
            "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ WHERE IMG_ID = 5 AND X = 634 AND Y = 468"
        ],
        "rule_sql": []
    },
    "8853": {
        "db_id": "food_inspection",
        "question": "Among the violations in 2016, how many of them have unscheduled inspections?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T2.type = 'Routine - Unscheduled'",
        "amends": [
            "Do add `INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id` instead of querying only the `violations` table. Do change the count to `COUNT(T2.business_id)` instead of `COUNT(*)` to count distinct business IDs from the joined inspections table. Do use `STRFTIME('%Y', T1.date) = '2016'` instead of `year = 2016` to extract the year from the date field. Do change the filter to `T2.type = 'Routine - Unscheduled'` instead of `inspection_type = 'unscheduled'` to reference the correct table and column with the proper value format. The amended query now correctly joins violations with inspections and counts business IDs with routine unscheduled inspections in 2016, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM violations WHERE year = 2016 AND inspection_type = 'unscheduled';",
            "SELECT COUNT(T2.business_id) \nFROM violations AS T1\nINNER JOIN inspections AS T2 ON T1.business_id = T2.business_id\nWHERE STRFTIME('%Y', T1.date) = '2016'\nAND T2.type = 'Routine - Unscheduled'"
        ],
        "rule_sql": []
    },
    "4214": {
        "db_id": "simpson_episodes",
        "question": "In \"Sex, Pies and Idiot Scrapes\", how many percentage of votes did the 9 star score has?",
        "ground_truth": "SELECT T2.percent FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.title = 'Sex, Pies and Idiot Scrapes' AND T2.stars = 9;",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references without aliases. Do reference `T2.percent` instead of calculating `COUNT(*) * 100 / (SELECT COUNT(*) FROM votes WHERE episode_title = 'Sex, Pies and Idiot Scrapes')` as a percentage. Do join `Episode AS T1` and `Vote AS T2` on `T2.episode_id = T1.episode_id` instead of querying a single table with a correlated subquery. Do filter on `T1.title = 'Sex, Pies and Idiot Scrapes'` instead of `episode_title = 'Sex, Pies and Idiot Scrapes'`. Do filter on `T2.stars = 9` instead of `score = 9`. Do remove the subquery calculation and instead directly select the pre-calculated `percent` column from the Vote table. The amended query now correctly retrieves the percentage of 9-star votes for the specified episode by leveraging proper table relationships and existing calculated data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM votes WHERE episode_title = 'Sex, Pies and Idiot Scrapes')) AS percentage FROM votes WHERE episode_title = 'Sex, Pies and Idiot Scrapes' AND score = 9",
            "SELECT T2.percent\nFROM Episode AS T1\nJOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.title = 'Sex, Pies and Idiot Scrapes'\nAND T2.stars = 9"
        ],
        "rule_sql": []
    },
    "6826": {
        "db_id": "retails",
        "question": "List all the customers' phone numbers from Ethiopia.",
        "ground_truth": "SELECT T1.c_phone FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'Ethiopia'",
        "amends": [
            "Do join `customer AS T1` with `nation AS T2` on `T1.c_nationkey = T2.n_nationkey` instead of querying only the `customers` table. Do filter on `T2.n_name = 'Ethiopia'` instead of `country = 'Ethiopia'` to use the proper nation name reference. Do select `T1.c_phone` with table alias qualification instead of just `phone` for clarity. The amended query now correctly joins customer and nation tables to filter by country name through the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers WHERE country = 'Ethiopia';",
            "SELECT T1.c_phone FROM customer AS T1 JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'Ethiopia'"
        ],
        "rule_sql": []
    },
    "6269": {
        "db_id": "coinmarketcap",
        "question": "What was the number of Bitcoins verifiably burned until 2013/4/28?",
        "ground_truth": "SELECT T2.max_supply - T2.total_supply FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T2.date = '2013-04-28' AND T1.name = 'Bitcoin'",
        "amends": [
            "Do select `T2.max_supply - T2.total_supply` instead of `COUNT(*)`. Do use `FROM coins AS T1 INNER JOIN historical AS T2` instead of `FROM bitcoin_burns`. Do add join condition `ON T1.id = T2.coin_id` instead of omitting it. Do add filter `WHERE T2.date = '2013-04-28'` instead of `burn_date <= '2013-04-28'`. Do add additional filter `AND T1.name = 'Bitcoin'` instead of omitting it. The amended query now correctly calculates Bitcoin's remaining supply rather than counting burns, using proper table relationships and date equality instead of inequality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM bitcoin_burns WHERE burn_date <= '2013-04-28';",
            "SELECT T2.max_supply - T2.total_supply\nFROM coins AS T1\nINNER JOIN historical AS T2 ON T1.id = T2.coin_id\nWHERE T2.date = '2013-04-28'\nAND T1.name = 'Bitcoin'"
        ],
        "rule_sql": []
    },
    "8308": {
        "db_id": "mondial_geo",
        "question": "Among the countries whose government type is republic, how many of them shares a border that's longer than 200?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN borders AS T3 ON T3.Country1 = T2.Country WHERE T2.Government = 'republic' AND T3.Length > 200",
        "amends": [
            "Do `COUNT(DISTINCT T1.Name)` instead of `COUNT(*)` to count distinct country names rather than all border records. Do join `politics AS T2` instead of omitting it, connecting via `T1.Code = T2.Country` to access government information. Do filter on `T2.Government = 'republic'` instead of `c1.government = 'Republic'` to use the correct table and case-sensitive value. Do join `borders AS T3` on `T3.Country1 = T2.Country` instead of `c1.code = b.country1` to properly link politics data to border information. Do maintain the `T3.Length > 200` filter but reference the correct table alias. The amended query now correctly counts distinct republic countries with borders longer than 200 units by properly joining through the politics table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM country c1\nJOIN borders b ON c1.code = b.country1\nJOIN country c2 ON b.country2 = c2.code\nWHERE c1.government = 'Republic' \nAND b.length > 200;",
            "SELECT COUNT(DISTINCT T1.Name) \nFROM country AS T1\nJOIN politics AS T2 ON T1.Code = T2.Country\nJOIN borders AS T3 ON T3.Country1 = T2.Country\nWHERE T2.Government = 'republic' AND T3.Length > 200"
        ],
        "rule_sql": []
    },
    "994": {
        "db_id": "computer_student",
        "question": "Among the courses that are basic or medium undergraduate courses, how many of them are taught by a faculty member?",
        "ground_truth": "SELECT COUNT(*) FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id INNER JOIN person AS T3 ON T2.p_id = T3.p_id WHERE T3.professor = 1 AND T1.courseLevel = 'Level_300'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `c` and `f`. Do join `course AS T1` with `taughtBy AS T2` on `T1.course_id = T2.course_id` instead of joining `courses` with `faculty` on `faculty_id`. Do add a second join to `person AS T3` on `T2.p_id = T3.p_id` instead of omitting it. Do filter on `T3.professor = 1` instead of `f.role = 'faculty'`. Do filter on `T1.courseLevel = 'Level_300'` instead of `c.level IN ('basic', 'medium')` and `c.type = 'undergraduate'`. The amended query now correctly counts courses taught by professors at the 300 level.",
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT T1.course_id)` to count all matching rows rather than distinct course IDs. Do remove the explicit `DISTINCT` modifier instead of keeping it since the count should include all professor-course associations. Do maintain the same `INNER JOIN` structure on `T1.course_id = T2.course_id` and `T2.p_id = T3.p_id` with identical table aliases. Do preserve the `WHERE` filter conditions `T3.professor = 1` and `T1.courseLevel = 'Level_300'` in the same logical conjunction. The amended query now correctly counts all course instances taught by professors at the 300 level rather than counting distinct courses, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM courses c\nJOIN faculty f ON c.faculty_id = f.id\nWHERE c.level IN ('basic', 'medium') \nAND c.type = 'undergraduate'\nAND f.role = 'faculty';",
            "SELECT COUNT(DISTINCT T1.course_id) \nFROM course AS T1 \nJOIN taughtBy AS T2 ON T1.course_id = T2.course_id \nJOIN person AS T3 ON T2.p_id = T3.p_id \nWHERE T1.courseLevel = 'Level_300' AND T3.professor = 1",
            "SELECT COUNT(*)\nFROM course AS T1\nINNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id\nINNER JOIN person AS T3 ON T2.p_id = T3.p_id\nWHERE T3.professor = 1 AND T1.courseLevel = 'Level_300'"
        ],
        "rule_sql": []
    },
    "9263": {
        "db_id": "movie_3",
        "question": "How many payments were made throughout the month of August 2005?",
        "ground_truth": "SELECT SUM(amount) FROM payment WHERE payment_date LIKE '2005-08%'",
        "amends": [
            "Do use `SUM(amount)` in the SELECT list instead of `COUNT(*)` to calculate the total payment amount rather than counting rows. Do reference the `payment` table instead of `payments` to use the correct table name. The amended query now correctly sums payment amounts for August 2005 instead of counting rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM payments WHERE payment_date LIKE '2005-08%';",
            "SELECT SUM(amount) FROM payment WHERE strftime('%Y-%m', payment_date) = '2005-08';"
        ],
        "rule_sql": []
    },
    "4755": {
        "db_id": "legislator",
        "question": "Among all the current legislators whose religion is Roman Catholic, what is the percentage of the ones without an instagram account?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.instagram IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM `social-media` AS T1 INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE T2.religion_bio = 'Roman Catholic'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.instagram IS NULL THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN instagram IS NULL THEN 1 END)` to properly count NULL values. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion. Do change the data source to `social-media AS T1` instead of `legislators` and add `INNER JOIN current AS T2` instead of querying a single table. Do use join condition `ON T1.bioguide = T2.bioguide_id` instead of no join. Do move the religion filter to `WHERE T2.religion_bio = 'Roman Catholic'` instead of `WHERE religion = 'Roman Catholic'` and remove the `current = 1` filter since the join handles current status. Do remove the alias `percentage_without_instagram` instead of keeping it. The amended query now correctly joins the social media and current legislator data to calculate the percentage of Roman Catholic current legislators without Instagram accounts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN instagram IS NULL THEN 1 END) * 100.0 / COUNT(*)) AS percentage_without_instagram\nFROM legislators\nWHERE religion = 'Roman Catholic'\nAND current = 1;",
            "SELECT \n    CAST(SUM(CASE WHEN T1.instagram IS NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100\nFROM \n    \"social-media\" AS T1\nINNER JOIN \n    current AS T2 ON T1.bioguide = T2.bioguide_id\nWHERE \n    T2.religion_bio = 'Roman Catholic';"
        ],
        "rule_sql": []
    },
    "3008": {
        "db_id": "shakespeare",
        "question": "In \"A Lover's Complaint\", what is the description of Act 1, Scene 1?",
        "ground_truth": "SELECT T2.Description FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Act = 1 AND T2.Scene = 1 AND T1.Title = 'A Lover''s Complaint'",
        "amends": [
            "Do select `T2.Description` from the `chapters` table instead of `description` from the `scenes` table. Do join `works AS T1` with `chapters AS T2` using `INNER JOIN` on `T1.id = T2.work_id` instead of querying only the `scenes` table. Do filter by `T1.Title = 'A Lover''s Complaint'` instead of `play_title = 'A Lover''s Complaint'`. Do use `T2.Act = 1` and `T2.Scene = 1` instead of `act_number = 1` and `scene_number = 1`. The amended query now correctly retrieves chapter descriptions by joining works and chapters tables with proper relationship constraints."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM scenes WHERE play_title = 'A Lover''s Complaint' AND act_number = 1 AND scene_number = 1;",
            "SELECT T2.Description \nFROM works AS T1 \nINNER JOIN chapters AS T2 ON T1.id = T2.work_id \nWHERE T1.Title = 'A Lover''s Complaint' \nAND T2.Act = 1 \nAND T2.Scene = 1"
        ],
        "rule_sql": []
    },
    "2171": {
        "db_id": "world_development_indicators",
        "question": "What are the years when countries have indicator name of \"Air transport, passengers carried\"? List the table name of these countries.",
        "ground_truth": "SELECT DISTINCT T2.Year, T1.TableName FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.IndicatorName = 'Air transport, passengers carried'",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicates instead of omitting it. Do select `T2.Year` and `T1.TableName` with proper table aliases instead of `year` and `table_name` without qualification. Do join `Country AS T1` with `Indicators AS T2` using `INNER JOIN` on `T1.CountryCode = T2.CountryCode` instead of querying only the `countries` table. Do filter on `T2.IndicatorName` instead of `indicator_name` to reference the correct table. The amended query now correctly joins the necessary tables and returns distinct results matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, table_name FROM countries WHERE indicator_name = 'Air transport, passengers carried'",
            "SELECT DISTINCT T2.Year, T1.TableName\nFROM Country AS T1\nINNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.IndicatorName = 'Air transport, passengers carried'"
        ],
        "rule_sql": []
    },
    "2983": {
        "db_id": "shakespeare",
        "question": "What percentage of all scenes are tragic scenes in Shakespeare's work in 1594?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.GenreType = 'Tragedy', 1, 0)) AS REAL) * 100 / COUNT(T1.Scene) FROM chapters AS T1 INNER JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.Date = '1594'",
        "amends": [
            "Do use `SUM(IIF(T2.GenreType = 'Tragedy', 1, 0))` instead of `COUNT(*)` to count only tragedy scenes. Do join `chapters AS T1` and `works AS T2` with `INNER JOIN` on `T1.work_id = T2.id` instead of querying only `scenes` table. Do filter on `T2.Date = '1594'` instead of `year = 1594` to use the correct date column from works table. Do cast the sum to `REAL` and calculate percentage with proper division instead of using a subquery for total count. Do reference `T1.Scene` in `COUNT` instead of counting all rows. The amended query now correctly calculates the percentage of tragedy scenes from 1594 works by properly joining the chapters and works tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM scenes)) AS percentage\nFROM scenes \nWHERE genre = 'tragedy' \nAND year = 1594;",
            "SELECT \n    (SUM(IIF(T2.GenreType = 'Tragedy', 1, 0)) * 100.0 / COUNT(T1.Scene)) AS percentage\nFROM \n    chapters AS T1\nINNER JOIN \n    works AS T2 ON T1.work_id = T2.id\nWHERE \n    T2.Date = '1594';"
        ],
        "rule_sql": []
    },
    "6257": {
        "db_id": "coinmarketcap",
        "question": "What was the price of 1 Bitcoin in 2016?",
        "ground_truth": "SELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bitcoin' AND STRFTIME('%Y', T2.date) = '2016'",
        "amends": [
            "Do select `AVG(T2.price)` instead of `price` to calculate the average instead of retrieving a single value. Do use `FROM coins AS T1 INNER JOIN historical AS T2` instead of `FROM bitcoin_prices` to join two tables instead of querying a single table. Do add join condition `ON T1.id = T2.coin_id` instead of omitting it to properly relate the tables. Do add filter `T1.name = 'Bitcoin'` instead of omitting it to specifically target Bitcoin records. Do use `STRFTIME('%Y', T2.date) = '2016'` instead of `year = 2016` to extract year from date column instead of using a non-existent year column. Do remove `LIMIT 1` instead of keeping it to return the average of all matching records rather than a single row. The amended query now correctly calculates the average Bitcoin price for 2016 by properly joining and filtering the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM bitcoin_prices WHERE year = 2016 LIMIT 1;",
            "SELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bitcoin' AND STRFTIME('%Y', T2.date) = '2016'"
        ],
        "rule_sql": []
    },
    "4048": {
        "db_id": "public_review_platform",
        "question": "What is the average year for a user to be upgraded to elite user?",
        "ground_truth": "SELECT CAST(SUM(T2.year_id - T1.user_yelping_since_year) AS REAL) / COUNT(T1.user_id) FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id",
        "amends": [
            "Do use `CAST(SUM(T2.year_id - T1.user_yelping_since_year) AS REAL) / COUNT(T1.user_id)` instead of `AVG(upgrade_year)` to calculate the average difference between elite year and user registration year. Do add `INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id` instead of omitting the join to properly relate elite years to users. Do reference `T1.user_yelping_since_year` and `T2.year_id` instead of the non-existent `upgrade_year` column. Do include the `Users AS T1` table instead of only querying from `elite_users`. The amended query now correctly calculates the average time between user registration and elite status acquisition by joining the necessary tables and performing the appropriate mathematical operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(upgrade_year) FROM elite_users;",
            "SELECT CAST(SUM(T2.year_id - T1.user_yelping_since_year) AS REAL) / COUNT(T1.user_id) AS average_upgrade_year\nFROM Users AS T1\nINNER JOIN Elite AS T2 ON T1.user_id = T2.user_id;"
        ],
        "rule_sql": []
    },
    "203": {
        "db_id": "book_publishing_company",
        "question": "What is the price of the book that sells the best?",
        "ground_truth": "SELECT T2.price FROM sales AS T1 INNER JOIN titles AS T2 ON T1.title_id = T2.title_id ORDER BY T1.qty DESC LIMIT 1",
        "amends": [
            "Do select `T2.price` from the `sales` table instead of selecting `price` from the `books` table. Do join `titles AS T2` with `sales AS T1` using an `INNER JOIN` on `T1.title_id = T2.title_id` instead of querying a single table. Do order by `T1.qty DESC` instead of ordering by `sales DESC`. The amended query now correctly retrieves the price from the joined titles table based on sales quantity rather than attempting to access price directly from a non-existent sales column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM books ORDER BY sales DESC LIMIT 1;",
            "SELECT T2.price \nFROM sales AS T1 \nINNER JOIN titles AS T2 ON T1.title_id = T2.title_id \nORDER BY T1.qty DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1514": {
        "db_id": "synthea",
        "question": "What is the percentage of female patients who started the care plan in 2010?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) AS percentage FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.START) = '2010'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END)` with explicit ELSE 0 instead of `COUNT(CASE WHEN gender = 'F' THEN 1 END)` for accurate female patient counting. Do join `careplans AS T1` with `patients AS T2` on `T1.PATIENT = T2.patient` instead of querying only the patients table to access start date information. Do filter with `WHERE strftime('%Y', T1.START) = '2010'` on the careplans table instead of using `YEAR(start_date)` on the patients table. Do cast the sum to `REAL` before division instead of using decimal literal `100.0` to ensure floating-point arithmetic. Do calculate percentage as `SUM(...) * 100 / COUNT(T1.PATIENT)` instead of the nested CASE expression structure. The amended query now correctly calculates the percentage of female patients in careplans starting in 2010 by properly joining the relevant tables and using accurate counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'F' AND YEAR(start_date) = 2010 THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN YEAR(start_date) = 2010 THEN 1 END)) AS percentage_female_patients_2010\nFROM patients;",
            "SELECT \n    (SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.PATIENT)) AS percentage\nFROM \n    careplans AS T1\nJOIN \n    patients AS T2 ON T1.PATIENT = T2.patient\nWHERE \n    strftime('%Y', T1.START) = '2010'"
        ],
        "rule_sql": []
    },
    "7864": {
        "db_id": "world",
        "question": "Who is the head of state of the country where the city of Pyongyang is under?",
        "ground_truth": "SELECT T1.HeadOfState FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Pyongyang'",
        "amends": [
            "Do join `Country AS T1` with `City AS T2` on `T1.Code = T2.CountryCode` instead of querying `countries` table alone. Do filter on `T2.Name = 'Pyongyang'` instead of `capital = 'Pyongyang'`. Do select `T1.HeadOfState` instead of `head_of_state` to reference the correct column from the joined table. The amended query now correctly retrieves the head of state by joining country and city tables and filtering on the city name rather than assuming the capital column exists in the countries table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT head_of_state FROM countries WHERE capital = 'Pyongyang';",
            "SELECT T1.HeadOfState FROM Country AS T1 JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Pyongyang'"
        ],
        "rule_sql": []
    },
    "4037": {
        "db_id": "public_review_platform",
        "question": "How many users have uber review votes for funny from the fans?",
        "ground_truth": "SELECT COUNT(DISTINCT user_id) FROM Reviews WHERE review_votes_funny = 'Uber'",
        "amends": [
            "Do select `COUNT(DISTINCT user_id)` instead of `COUNT(*)` to count distinct users rather than all rows. Do query from `Reviews` table instead of `users` table to access the correct data source. Do use filter `review_votes_funny = 'Uber'` instead of `uber_review_votes = 'funny' AND fans = 1` to properly identify Uber-related funny votes without the unnecessary fans condition. The amended query now correctly counts distinct users who gave funny votes on Uber reviews, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE uber_review_votes = 'funny' AND fans = 1;",
            "SELECT COUNT(DISTINCT user_id) FROM Reviews WHERE review_votes_funny = 'Uber'"
        ],
        "rule_sql": []
    },
    "9044": {
        "db_id": "bike_share_1",
        "question": "How many trips which subscription types were Subscriber and ended in San Jose city?",
        "ground_truth": "SELECT COUNT(T1.subscription_type) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.end_station_name WHERE T1.subscription_type = 'Subscriber' AND T2.city = 'San Jose'",
        "amends": [
            "Do add `INNER JOIN station AS T2 ON T2.name = T1.end_station_name` instead of querying only the `trips` table. Do reference `T2.city = 'San Jose'` instead of `end_city = 'San Jose'` to properly filter by station city. Do change the table alias from `trips` to `trip AS T1` for consistency with the join. Do specify `COUNT(T1.subscription_type)` instead of `COUNT(*)` to count only subscriber records. The amended query now correctly joins station data to filter by city instead of relying on a non-existent end_city column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trips WHERE subscription_type = 'Subscriber' AND end_city = 'San Jose';",
            "SELECT COUNT(T1.subscription_type) \nFROM trip AS T1 \nINNER JOIN station AS T2 ON T2.name = T1.end_station_name \nWHERE T1.subscription_type = 'Subscriber' AND T2.city = 'San Jose'"
        ],
        "rule_sql": []
    },
    "4453": {
        "db_id": "student_loan",
        "question": "List all the organisations of students who filed for bankcrupcy.",
        "ground_truth": "SELECT T2.organ FROM filed_for_bankrupcy AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name",
        "amends": [
            "Do select `T2.organ` instead of `*` from all columns. Do use `filed_for_bankrupcy AS T1` instead of `students` as the source table. Do add `INNER JOIN enlist AS T2` instead of having only one table. Do join on `T1.name = T2.name` instead of filtering with `bankruptcy = 'filed'`. Do remove the `WHERE` clause filter entirely instead of keeping it, as the join condition now handles the logic. The amended query now correctly retrieves organ information from the enlist table for individuals who have filed for bankruptcy, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE bankruptcy = 'filed';",
            "SELECT T2.organ FROM filed_for_bankrupcy AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name"
        ],
        "rule_sql": []
    },
    "5920": {
        "db_id": "books",
        "question": "How many books are in English?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE T2.language_name = 'English'",
        "amends": [
            "Do join `book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id` instead of querying only the `books` table. Do filter on `T2.language_name = 'English'` instead of directly filtering on `language = 'English'` since the language name is stored in a separate lookup table. The amended query now correctly joins to the language reference table to filter by language name instead of assuming the language field contains the name directly, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE language = 'English';",
            "SELECT COUNT(*) \nFROM book AS T1 \nINNER JOIN book_language AS T2 ON T1.language_id = T2.language_id \nWHERE T2.language_name = 'English'"
        ],
        "rule_sql": []
    },
    "7046": {
        "db_id": "works_cycles",
        "question": "What is the postal code of the street address of the account that is latest updated?",
        "ground_truth": "SELECT PostalCode FROM Address ORDER BY ModifiedDate DESC LIMIT 1",
        "amends": [
            "Do reference `PostalCode` from the `Address` table instead of `postal_code` from `accounts`. Do use `ModifiedDate` for ordering instead of `updated_at`. Do query from the `Address` table instead of the `accounts` table. The amended query now correctly retrieves postal code data from the address table ordered by modification date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT postal_code FROM accounts ORDER BY updated_at DESC LIMIT 1;",
            "SELECT PostalCode FROM Address ORDER BY ModifiedDate DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2065": {
        "db_id": "music_tracker",
        "question": "How many albums and Single-Tables were released by the artist named '50 cent' between 2010 and 2015?",
        "ground_truth": "SELECT COUNT(id), ( SELECT COUNT(id) FROM torrents WHERE groupYear BETWEEN 2010 AND 2015 AND artist LIKE '50 cent' AND releaseType LIKE 'album' ) FROM torrents WHERE groupYear BETWEEN 2010 AND 2015 AND artist LIKE '50 cent' AND releaseType LIKE 'Single'",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` and add a correlated subquery that counts `torrents` with `groupYear BETWEEN 2010 AND 2015` and `artist LIKE '50 cent'` and `releaseType LIKE 'album'` instead of omitting it. Do change the FROM source to `torrents` instead of `albums` and modify the WHERE filter to use `groupYear BETWEEN 2010 AND 2015` instead of `release_year BETWEEN 2010 AND 2015`, `artist LIKE '50 cent'` instead of `artist = '50 cent'`, and add `releaseType LIKE 'Single'` instead of omitting it. The amended query now correctly counts both singles and albums from the torrents table with proper pattern matching and year filtering.",
            "Do use a scalar subquery to count `album` releases instead of conditional aggregation with `CASE`. Do remove the `OR` condition from the main query's `WHERE` clause and instead filter only for `Single` releases in the outer query. Do add a separate subquery that filters specifically for `album` releases with identical `WHERE` conditions instead of handling both release types in a single query with conditional logic. Do maintain the same `groupYear` and `artist` filters in both the main query and subquery instead of applying them only once. Do count all `id` values directly in both queries instead of using conditional `CASE` expressions. The amended query now correctly produces separate counts for Singles and albums while maintaining consistent filtering logic across both counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums WHERE artist = '50 cent' AND release_year BETWEEN 2010 AND 2015;",
            "SELECT \n    COUNT(CASE WHEN releaseType LIKE 'album' THEN id END) AS album_count,\n    COUNT(CASE WHEN releaseType LIKE 'Single' THEN id END) AS single_count\nFROM torrents \nWHERE artist LIKE '50 cent' \nAND groupYear BETWEEN 2010 AND 2015\nAND (releaseType LIKE 'album' OR releaseType LIKE 'Single')",
            "SELECT \n    (SELECT COUNT(id) FROM torrents WHERE groupYear BETWEEN 2010 AND 2015 AND artist LIKE '50 cent' AND releaseType LIKE 'Single') AS single_count,\n    (SELECT COUNT(id) FROM torrents WHERE groupYear BETWEEN 2010 AND 2015 AND artist LIKE '50 cent' AND releaseType LIKE 'album') AS album_count"
        ],
        "rule_sql": []
    },
    "4795": {
        "db_id": "legislator",
        "question": "How old was Jr. F. James Sensenbrenner when he first started as a legislator?",
        "ground_truth": "SELECT CAST(MIN(T2.start) - T1.birthday_bio AS DATE) AS AGE FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'F. James Sensenbrenner, Jr.'",
        "amends": [
            "Do use `CAST(MIN(T2.start) - T1.birthday_bio AS DATE)` for age calculation instead of `birth_year - start_year` to properly handle date arithmetic. Do join `current AS T1` with `current-terms AS T2` on `T1.bioguide_id = T2.bioguide` instead of querying a single `legislators` table. Do filter by `T1.official_full_name = 'F. James Sensenbrenner, Jr.'` instead of `name = 'Jr. F. James Sensenbrenner'` to match the correct name format. Do add `MIN()` aggregation on `T2.start` instead of using a raw column value to handle multiple terms. The amended query now correctly calculates age using proper date operations and joins between the current legislators and their terms tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_year - start_year AS age FROM legislators WHERE name = 'Jr. F. James Sensenbrenner';",
            "SELECT CAST((MIN(T2.start) - T1.birthday_bio) AS DATE) AS age_at_start\nFROM current AS T1\nJOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nWHERE T1.official_full_name = 'F. James Sensenbrenner, Jr.'"
        ],
        "rule_sql": []
    },
    "5053": {
        "db_id": "olympics",
        "question": "How many different football events are there?",
        "ground_truth": "SELECT COUNT(T2.event_name) FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Football'",
        "amends": [
            "Do add tables `sport AS T1` and `event AS T2` with an `INNER JOIN` on `T1.id = T2.sport_id` instead of querying only the `events` table. Do change the count expression to `COUNT(T2.event_name)` instead of `COUNT(*)`. Do change the filter condition to `T1.sport_name = 'Football'` instead of `sport = 'basketball'` to properly reference the sport name from the joined table and use the correct sport value. The amended query now correctly counts events for football by joining the sport and event tables through their relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE sport = 'basketball';",
            "SELECT COUNT(T2.event_name) \nFROM sport AS T1 \nINNER JOIN event AS T2 ON T1.id = T2.sport_id \nWHERE T1.sport_name = 'Football'"
        ],
        "rule_sql": []
    },
    "5286": {
        "db_id": "beer_factory",
        "question": "List the full name and phone number of male customers from Fair Oaks who are subscribed to the email list.",
        "ground_truth": "SELECT First, Last, PhoneNumber FROM customers WHERE Gender = 'M' AND City = 'Fair Oaks' AND SubscribedToEmailList = 'TRUE'",
        "amends": [
            "Do select `First`, `Last`, and `PhoneNumber` instead of `first_name`, `last_name`, and `phone_number`. Do filter on `Gender = 'M'` instead of `gender = 'Female'`. Do filter on `SubscribedToEmailList = 'TRUE'` instead of `email_subscribed = 1`. The amended query now correctly selects the specified columns with proper gender filtering and boolean handling for email subscription status."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, phone_number FROM customers WHERE gender = 'Female' AND city = 'Fair Oaks' AND email_subscribed = 1",
            "SELECT First, Last, PhoneNumber FROM customers WHERE Gender = 'M' AND City = 'Fair Oaks' AND SubscribedToEmailList = 'TRUE';"
        ],
        "rule_sql": []
    },
    "7228": {
        "db_id": "works_cycles",
        "question": "What is the business ID of the person who has made the most sales total year to date?",
        "ground_truth": "SELECT BusinessEntityID FROM SalesPerson ORDER BY SalesYTD DESC LIMIT 1",
        "amends": [
            "Do select `BusinessEntityID` instead of `business_id` and order by `SalesYTD` instead of `total_sales`. Do query from `SalesPerson` table instead of `sales` table. The amended query now correctly retrieves the top-performing salesperson based on year-to-date sales performance."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM sales ORDER BY total_sales DESC LIMIT 1;",
            "SELECT BusinessEntityID FROM SalesPerson ORDER BY SalesYTD DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1882": {
        "db_id": "soccer_2016",
        "question": "What are the match IDs that were played at Brabourne Stadium?",
        "ground_truth": "SELECT T1.Match_Id FROM Match AS T1 INNER JOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id WHERE T2.Venue_Name = 'Brabourne Stadium'",
        "amends": [
            "Do use `T1.Match_Id` with table alias instead of `match_id` without qualification. Do join `Venue AS T2` on `T2.Venue_Id = T1.Venue_Id` instead of querying `matches` table directly without joins. Do filter on `T2.Venue_Name = 'Brabourne Stadium'` instead of `stadium = 'Brabourne Stadium'` to properly reference the venue name from the joined table. The amended query now correctly joins the Match and Venue tables to filter by venue name instead of relying on a potentially incorrect or non-existent stadium column in the matches table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT match_id FROM matches WHERE stadium = 'Brabourne Stadium';",
            "SELECT T1.Match_Id\nFROM Match AS T1\nJOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id\nWHERE T2.Venue_Name = 'Brabourne Stadium'"
        ],
        "rule_sql": []
    },
    "5019": {
        "db_id": "olympics",
        "question": "Where was the 1920 Summer held?",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T3.games_name = '1920 Summer'",
        "amends": [
            "Do select `T2.city_name` from the `city` table instead of `city` directly from `olympics`. Do join `games_city AS T1` and `city AS T2` on `T1.city_id = T2.id` instead of querying a single table. Do add an additional join to `games AS T3` on `T1.games_id = T3.id` instead of omitting this relationship. Do filter on `T3.games_name = '1920 Summer'` instead of `year = 1920 AND season = 'Winter'` to correctly identify the specific games. The amended query now properly navigates the relational schema to retrieve the correct city name for the 1920 Summer Olympics instead of incorrectly assuming a denormalized structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM olympics WHERE year = 1920 AND season = 'Winter';",
            "SELECT T2.city_name \nFROM games_city AS T1\nJOIN city AS T2 ON T1.city_id = T2.id\nJOIN games AS T3 ON T1.games_id = T3.id\nWHERE T3.games_name = '1920 Summer'"
        ],
        "rule_sql": []
    },
    "2956": {
        "db_id": "shakespeare",
        "question": "How many more scenes are there in Act 1 than in Act 5 in Twelfth Night?",
        "ground_truth": "SELECT SUM(IIF(T2.Act = 1, 1, 0)) - SUM(IIF(T2.Act = 5, 1, 0)) AS more FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Twelfth Night'",
        "amends": [
            "Do use `SUM(IIF(T2.Act = 1, 1, 0)) - SUM(IIF(T2.Act = 5, 1, 0)) AS more` instead of `COUNT(*)` to calculate the difference between acts 1 and 5. Do join `works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id` instead of querying only `scenes` table. Do filter with `T1.Title = 'Twelfth Night'` instead of `play = 'Twelfth Night' AND act = 1`. Do remove the `WHERE act = 1` condition entirely instead of keeping it, as the logic is now handled through conditional aggregation. The amended query now correctly calculates the difference between act 1 and act 5 counts for 'Twelfth Night' by joining the works and chapters tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM scenes WHERE act = 1 AND play = 'Twelfth Night'",
            "SELECT SUM(IIF(T2.Act = 1, 1, 0)) - SUM(IIF(T2.Act = 5, 1, 0)) AS more\nFROM works AS T1\nINNER JOIN chapters AS T2 ON T1.id = T2.work_id\nWHERE T1.Title = 'Twelfth Night'"
        ],
        "rule_sql": []
    },
    "191": {
        "db_id": "book_publishing_company",
        "question": "Among all employees, who have job level greater than 200. State the employee name and job description.",
        "ground_truth": "SELECT T1.fname, T1.lname, T2.job_desc FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE T1.job_lvl > 200",
        "amends": [
            "Do select `T1.fname` and `T1.lname` instead of `employee_name`, and `T2.job_desc` instead of `job_description`. Do add `INNER JOIN jobs AS T2` on `T1.job_id = T2.job_id` instead of querying only the employees table. Do use `T1.job_lvl > 200` instead of `job_level > 200` and reference the joined table alias. The amended query now correctly joins employee and jobs tables to retrieve the appropriate names and job descriptions based on job level criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_name, job_description FROM employees WHERE job_level > 200",
            "SELECT T1.fname, T1.lname, T2.job_desc FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE T1.job_lvl > 200"
        ],
        "rule_sql": []
    },
    "1373": {
        "db_id": "synthea",
        "question": "Give the body height status of Mr. Vincent Wyman on 2010/8/2.",
        "ground_truth": "SELECT T2.description, T2.VALUE, T2.units FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mr.' AND T1.first = 'Vincent' AND T1.last = 'Wyman' AND T2.date = '2010-08-02' AND T2.description = 'Body Height'",
        "amends": [
            "Do select `T2.description`, `T2.VALUE`, and `T2.units` instead of `height_status`. Do join `observations AS T2` with `patients AS T1` using `INNER JOIN` on `T1.patient = T2.PATIENT` instead of querying only the `patients` table. Do add filter conditions for `T1.prefix = 'Mr.'` and `T2.description = 'Body Height'` instead of omitting them. Do use date format `'2010-08-02'` instead of `'2010/8/2'` and apply it to `T2.date` instead of the base table date. Do reference columns as `T1.first` and `T1.last` instead of `first_name` and `last_name`. The amended query now correctly retrieves observation details from the joined tables with proper filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT height_status FROM patients WHERE first_name = 'Vincent' AND last_name = 'Wyman' AND date = '2010/8/2';",
            "SELECT T2.description, T2.VALUE, T2.units\nFROM patients AS T1\nINNER JOIN observations AS T2 ON T1.patient = T2.PATIENT\nWHERE T1.prefix = 'Mr.'\nAND T1.first = 'Vincent'\nAND T1.last = 'Wyman'\nAND T2.description = 'Body Height'\nAND T2.DATE = '2010-08-02';"
        ],
        "rule_sql": []
    },
    "371": {
        "db_id": "retail_complains",
        "question": "What is the longest server time when the call is about the issue of arbitration?",
        "ground_truth": "SELECT MAX(T1.ser_time) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.issue = 'Arbitration'",
        "amends": [
            "Do select `MAX(T1.ser_time)` from the `callcenterlogs` table instead of `MAX(duration)` from the `calls` table. Do add `INNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\"` instead of querying only a single table. Do filter on `T2.issue = 'Arbitration'` instead of `issue = 'arbitration'` to use the correct table reference and case-sensitive value. The amended query now correctly joins the necessary tables and uses the appropriate column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(duration) FROM calls WHERE issue = 'arbitration';",
            "SELECT MAX(T1.ser_time) \nFROM callcenterlogs AS T1\nINNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\"\nWHERE T2.Issue = 'Arbitration'"
        ],
        "rule_sql": []
    },
    "770": {
        "db_id": "movie",
        "question": "List the runtime of movies starred by an African-American actor born on December 28, 1954.",
        "ground_truth": "SELECT T1.Runtime FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T3.Ethnicity = 'African American' AND T3.`Date of Birth` = '1954-12-28'",
        "amends": [
            "Do select `Runtime` from `movie` instead of `runtime` from `movies`. Do join `characters` on `MovieID` instead of `stars` on `movie_id`. Do join `actor` on `ActorID` instead of `people` on `person_id`. Do filter on `Ethnicity` = 'African American' instead of `race` = 'African-American'. Do filter on `Date of Birth` instead of `birth_date`. The amended query now correctly retrieves runtime information for movies featuring African American actors born on December 28, 1954."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.runtime \nFROM movies m \nJOIN stars s ON m.id = s.movie_id \nJOIN people p ON s.person_id = p.id \nWHERE p.race = 'African-American' \nAND p.birth_date = '1954-12-28';",
            "SELECT m.Runtime \nFROM movie m\nJOIN characters c ON m.MovieID = c.MovieID\nJOIN actor a ON c.ActorID = a.ActorID\nWHERE a.Ethnicity = 'African American' \nAND a.\"Date of Birth\" = '1954-12-28'"
        ],
        "rule_sql": []
    },
    "3377": {
        "db_id": "video_games",
        "question": "Sum the total game sales in every region for platform ID 9658.",
        "ground_truth": "SELECT SUM(T.num_sales) * 100000 FROM region_sales AS T WHERE T.game_platform_id = 9658",
        "amends": [
            "Do select `SUM(T.num_sales) * 100000` instead of `SUM(sales)` and remove the `region` column instead of including it. Do use `FROM region_sales AS T` instead of `FROM game_sales` and change the table source. Do use `WHERE T.game_platform_id = 9658` instead of `WHERE platform_id = 9658` to fix the column reference and table alias. Do remove `GROUP BY region` instead of keeping it since aggregation is now handled differently. The amended query now correctly calculates total sales in hundreds of thousands for the specified game platform."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, SUM(sales) FROM game_sales WHERE platform_id = 9658 GROUP BY region;",
            "SELECT SUM(T.num_sales) * 100000 FROM region_sales AS T WHERE T.game_platform_id = 9658"
        ],
        "rule_sql": []
    },
    "7984": {
        "db_id": "music_platform_2",
        "question": "Please list the titles of the podcasts for which the author whose ID is F7E5A318989779D has written a review.",
        "ground_truth": "SELECT T2.title FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.author_id = 'F7E5A318989779D'",
        "amends": [
            "Do join `reviews AS T2` instead of querying only the `podcasts` table. Do reference `T2.title` instead of `title` from the podcasts table. Do add an `INNER JOIN` condition `ON T2.podcast_id = T1.podcast_id` instead of missing the join relationship. Do move the author filter to `T2.author_id` instead of applying it to `podcasts.author_id`. Do add table alias `T1` for podcasts instead of using the table name directly. The amended query now correctly retrieves review titles from the reviews table for the specified author instead of podcast titles, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM podcasts WHERE author_id = 'F7E5A318989779D';",
            "SELECT T2.title FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.author_id = 'F7E5A318989779D'"
        ],
        "rule_sql": []
    },
    "460": {
        "db_id": "movies_4",
        "question": "Tally the movie ID and character name in the movie starring Jim Carrey.",
        "ground_truth": "SELECT T2.movie_id, T2.character_name FROM person AS T1 INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Jim Carrey'",
        "amends": [
            "Do use `T2.movie_id` and `T2.character_name` instead of `movie_id` and `character_name` without table aliases. Do add `person AS T1` and `movie_cast AS T2` tables instead of only `movies` table. Do use `INNER JOIN` with `T1.person_id = T2.person_id` instead of querying a single table. Do filter on `T1.person_name = 'Jim Carrey'` instead of `actor_name = 'Jim Carrey'`. The amended query now correctly joins person and movie_cast tables to find Jim Carrey's movie roles, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_id, character_name FROM movies WHERE actor_name = 'Jim Carrey';",
            "SELECT T2.movie_id, T2.character_name FROM person AS T1 INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Jim Carrey'"
        ],
        "rule_sql": []
    },
    "6948": {
        "db_id": "ice_hockey_draft",
        "question": "Name the player who has the most NHL points in draft year.",
        "ground_truth": "SELECT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.P = ( SELECT MAX(P) FROM SeasonStatus )",
        "amends": [
            "Do select `T2.PlayerName` from `PlayerInfo` instead of `player_name` from `players`. Do use `SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2` instead of a single `players` table. Do join on `T1.ELITEID = T2.ELITEID` instead of no join condition. Do filter with `T1.P = (SELECT MAX(P) FROM SeasonStatus)` instead of `draft_year = (SELECT MAX(draft_year) FROM players)`. Do remove `ORDER BY points DESC LIMIT 1` instead of keeping it. The amended query now correctly retrieves the player with maximum P value from SeasonStatus joined with PlayerInfo, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE draft_year = (SELECT MAX(draft_year) FROM players) ORDER BY points DESC LIMIT 1;",
            "SELECT T2.PlayerName\nFROM SeasonStatus AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE T1.P = (SELECT MAX(P) FROM SeasonStatus)"
        ],
        "rule_sql": []
    },
    "748": {
        "db_id": "movie",
        "question": "How many movies has the highest networth actor acted in?",
        "ground_truth": "SELECT COUNT(*) FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE CAST(REPLACE(REPLACE(T2.NetWorth, ',', ''), '$', '') AS REAL) = ( SELECT MAX(CAST(REPLACE(REPLACE(NetWorth, ',', ''), '$', '') AS REAL)) FROM actor)",
        "amends": [
            "Do query the `characters` table instead of `movies`, and join with `actor` table instead of referencing `actors`. Do use `INNER JOIN` on `T1.ActorID = T2.ActorID` instead of filtering by `actor_id` subquery. Do add proper NetWorth value parsing with `CAST(REPLACE(REPLACE(T2.NetWorth, ',', ''), '$', '') AS REAL)` instead of directly using `networth`. Do change the subquery to find the maximum parsed NetWorth value instead of ordering by networth with LIMIT 1. Do remove the incorrect subquery correlation and instead use an uncorrelated subquery to find the global maximum NetWorth. The amended query now correctly counts characters for actors with the highest net worth by properly handling currency formatting and using accurate table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE actor_id = (SELECT id FROM actors ORDER BY networth DESC LIMIT 1);",
            "SELECT COUNT(*) AS movie_count\nFROM characters c\nINNER JOIN actor a ON c.ActorID = a.ActorID\nWHERE CAST(REPLACE(REPLACE(a.NetWorth, ',', ''), '$', '') AS REAL) = (\n    SELECT MAX(CAST(REPLACE(REPLACE(NetWorth, ',', ''), '$', '') AS REAL))\n    FROM actor\n)"
        ],
        "rule_sql": []
    },
    "5045": {
        "db_id": "olympics",
        "question": "List out the id of event that achieve the gold medal.",
        "ground_truth": "SELECT T2.event_id FROM medal AS T1 INNER JOIN competitor_event AS T2 ON T1.id = T2.medal_id WHERE T1.medal_name = 'Gold'",
        "amends": [
            "Do select `T2.event_id` instead of `id`. Do join `medal AS T1` and `competitor_event AS T2` instead of querying only `events`. Do use `INNER JOIN` on `T1.id = T2.medal_id` instead of no join condition. Do filter on `T1.medal_name = 'Gold'` instead of `medal = 'gold'`. The amended query now correctly retrieves event IDs for gold medals by properly joining the medal and competitor_event tables with appropriate join conditions and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM events WHERE medal = 'gold';",
            "SELECT T2.event_id\nFROM medal AS T1\nINNER JOIN competitor_event AS T2 ON T1.id = T2.medal_id\nWHERE T1.medal_name = 'Gold'"
        ],
        "rule_sql": []
    },
    "1421": {
        "db_id": "synthea",
        "question": "Provide the patients' full names who received the extraction of wisdom tooth.",
        "ground_truth": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Extraction of wisdom tooth'",
        "amends": [
            "Do select `T1.first` and `T1.last` with table aliases instead of `first_name` and `last_name` without aliases. Do add `INNER JOIN procedures AS T2` instead of querying only the `patients` table. Do use join condition `ON T1.patient = T2.PATIENT` instead of having no join. Do filter on `T2.DESCRIPTION = 'Extraction of wisdom tooth'` instead of filtering directly on a `procedure` column in the patients table. The amended query now correctly joins the patients and procedures tables to find patients who have undergone wisdom tooth extraction procedures."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM patients WHERE procedure = 'wisdom tooth extraction';",
            "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Extraction of wisdom tooth'"
        ],
        "rule_sql": []
    },
    "2278": {
        "db_id": "movielens",
        "question": "For the male users no older than 18, how many times have they given the highest rating?",
        "ground_truth": "SELECT COUNT(T1.movieid) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 5 AND T2.age < 18 AND T2.u_gender = 'M'",
        "amends": [
            "Do use `COUNT(T1.movieid)` instead of `COUNT(*)` to count specific non-null values. Do reference tables as `u2base AS T1` and `users AS T2` instead of `users u` and `ratings r` with different aliases. Do use `INNER JOIN` with `T1.userid = T2.userid` instead of `JOIN` with `u.user_id = r.user_id` and different column names. Do filter with `T1.rating = 5` instead of `r.rating = (SELECT MAX(rating) FROM ratings)` to use a fixed rating value rather than a subquery. Do filter with `T2.age < 18` instead of `u.age <= 18` to use strict inequality. Do filter with `T2.u_gender = 'M'` instead of `u.gender = 'male'` to use different gender representation. The amended query now correctly counts movies rated 5 by users under 18 with male gender, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM users u\nJOIN ratings r ON u.user_id = r.user_id\nWHERE u.gender = 'male' \nAND u.age <= 18\nAND r.rating = (SELECT MAX(rating) FROM ratings);",
            "SELECT COUNT(T1.movieid) \nFROM u2base AS T1 \nINNER JOIN users AS T2 ON T1.userid = T2.userid \nWHERE T1.rating = '5' \nAND T2.age < '18' \nAND T2.u_gender = 'M'"
        ],
        "rule_sql": []
    },
    "2309": {
        "db_id": "movielens",
        "question": "How many actors have acted in both US or UK films?",
        "ground_truth": "SELECT COUNT(T1.actorid) FROM movies2actors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.country = 'USA' OR T2.country = 'UK'",
        "amends": [
            "Do select `COUNT(T1.actorid)` instead of `COUNT(DISTINCT actor_id)` and change the source to `movies2actors AS T1` instead of `actors`. Do add `INNER JOIN movies AS T2 ON T1.movieid = T2.movieid` instead of omitting the join. Do change the filter to `T2.country = 'USA' OR T2.country = 'UK'` instead of `country IN ('US', 'UK')` and move it from the actors table to the movies table. Do remove the `DISTINCT` modifier instead of keeping it since the join structure ensures unique actor counts. The amended query now correctly counts actors from movies produced in the specified countries rather than actors based on their personal nationality, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT actor_id) \nFROM actors \nWHERE country IN ('US', 'UK');",
            "SELECT COUNT(T1.actorid) \nFROM movies2actors AS T1\nINNER JOIN movies AS T2 ON T1.movieid = T2.movieid\nWHERE T2.country = 'USA' OR T2.country = 'UK'"
        ],
        "rule_sql": []
    },
    "1334": {
        "db_id": "law_episode",
        "question": "List out all award titles nominated for episode 20.",
        "ground_truth": "SELECT T2.award FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T1.episode = 20 AND T2.result IN ('Winner', 'Nominee')",
        "amends": [
            "Do select `T2.award` instead of `award_title` and add the `T2.result` filter instead of omitting it. Do use `INNER JOIN` between `Episode AS T1` and `Award AS T2` on `T1.episode_id = T2.episode_id` instead of querying only the `awards` table. Do add the condition `T1.episode = 20` instead of `episode_number = 20` and include `T2.result IN ('Winner', 'Nominee')` instead of having no result filtering. The amended query now correctly joins the Episode and Award tables with proper filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT award_title FROM awards WHERE episode_number = 20",
            "SELECT T2.award\nFROM Episode AS T1\nINNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id\nWHERE T1.episode = 20\nAND T2.result IN ('Winner', 'Nominee')"
        ],
        "rule_sql": []
    },
    "7601": {
        "db_id": "image_and_language",
        "question": "Write 10 coordinates with the object class \"pizza.\"",
        "ground_truth": "SELECT T1.IMG_ID, T1.X, T1.Y FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'pizza' LIMIT 10",
        "amends": [
            "Do select specific columns `T1.IMG_ID`, `T1.X`, `T1.Y` instead of using `*` to select all columns. Do join tables `IMG_OBJ AS T1` and `OBJ_CLASSES AS T2` with an `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single table `coordinates`. Do filter on `T2.OBJ_CLASS = 'pizza'` instead of filtering on `object_class = 'pizza'` since the class name is stored in the joined table. The amended query now correctly retrieves image coordinates for pizza objects by properly joining the object classes table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM coordinates WHERE object_class = 'pizza' LIMIT 10;",
            "SELECT T1.IMG_ID, T1.X, T1.Y FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'pizza' LIMIT 10"
        ],
        "rule_sql": []
    },
    "7517": {
        "db_id": "image_and_language",
        "question": "Which image has the highest number of \"white\" class attributes?",
        "ground_truth": "SELECT T1.IMG_ID AS IMGID FROM IMG_OBJ_att AS T1 INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T2.ATT_CLASS = 'white' GROUP BY T1.IMG_ID ORDER BY COUNT(T1.ATT_CLASS_ID) DESC LIMIT 1",
        "amends": [
            "Do select `IMG_ID` as `IMGID` instead of `image_id` and `white_count`. Do use `INNER JOIN` on `ATT_CLASSES` with predicate `T1.ATT_CLASS_ID = T2.ATT_CLASS_ID` instead of querying a single table. Do filter on `T2.ATT_CLASS = 'white'` instead of `class = 'white'`. Do add `GROUP BY T1.IMG_ID` instead of omitting it. Do order by `COUNT(T1.ATT_CLASS_ID)` descending instead of ordering by the alias `white_count`. The amended query now correctly joins the necessary tables, groups by image ID, and counts attributes per image to match the intended behavior.",
            "Do remove `COUNT(T1.ATT_CLASS_ID) AS white_count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T1.IMG_ID AS IMGID`. Do keep the same `INNER JOIN` on `T1.ATT_CLASS_ID = T2.ATT_CLASS_ID` and maintain the `WHERE T2.ATT_CLASS = 'white'` filter. Do preserve the `GROUP BY T1.IMG_ID` and `ORDER BY COUNT(T1.ATT_CLASS_ID) DESC` with `LIMIT 1`, as these remain unchanged. The amended query now matches RIGHT_SQL's behavior by selecting only the image ID while maintaining the same grouping, ordering, and limiting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id, COUNT(*) as white_count \nFROM image_attributes \nWHERE class = 'white' \nORDER BY white_count DESC \nLIMIT 1;",
            "SELECT T1.IMG_ID AS IMGID, COUNT(T1.ATT_CLASS_ID) AS white_count\nFROM IMG_OBJ_ATT T1\nINNER JOIN ATT_CLASSES T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID\nWHERE T2.ATT_CLASS = 'white'\nGROUP BY T1.IMG_ID\nORDER BY COUNT(T1.ATT_CLASS_ID) DESC\nLIMIT 1",
            "SELECT T1.IMG_ID AS IMGID\nFROM IMG_OBJ_ATT T1\nINNER JOIN ATT_CLASSES T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID\nWHERE T2.ATT_CLASS = 'white'\nGROUP BY T1.IMG_ID\nORDER BY COUNT(T1.ATT_CLASS_ID) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3308": {
        "db_id": "video_games",
        "question": "Please list all the games that have the same game genre as 3D Lemmings.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 WHERE T1.genre_id = ( SELECT T.genre_id FROM game AS T WHERE T.game_name = '3D Lemmings' )",
        "amends": [
            "Do reference `T1.game_name` in the SELECT list instead of `*` to return only specific columns. Do use table alias `T1` for the main table instead of no alias. Do reference `T1.genre_id` in the WHERE condition instead of `genre` to use the correct column name. Do use `game` as the table name instead of `games` to match the correct schema. Do reference `T.genre_id` in the subquery SELECT instead of `genre` to use the proper column name. Do use table alias `T` for the subquery table instead of no alias. Do reference `T.game_name` in the subquery WHERE condition instead of `title` to use the correct column name. The amended query now correctly finds games with the same genre_id as '3D Lemmings' using proper column references and aliases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM games WHERE genre = (SELECT genre FROM games WHERE title = '3D Lemmings');",
            "SELECT T1.game_name\nFROM game T1\nWHERE T1.genre_id = (\n    SELECT T.genre_id\n    FROM game T\n    WHERE T.game_name = '3D Lemmings'\n)"
        ],
        "rule_sql": []
    },
    "7279": {
        "db_id": "works_cycles",
        "question": "How many products are out of stock?",
        "ground_truth": "SELECT COUNT(ProductID) FROM ProductVendor WHERE OnOrderQty = 0",
        "amends": [
            "Do reference the `ProductVendor` table instead of the `products` table. Do count `ProductID` instead of using `COUNT(*)`. Do filter on `OnOrderQty = 0` instead of `stock_quantity > 0`. The amended query now correctly counts products with zero on-order quantity from the ProductVendor table instead of counting products with positive stock quantity from a different table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE stock_quantity > 0;",
            "SELECT COUNT(ProductID) FROM ProductVendor WHERE OnOrderQty = 0;"
        ],
        "rule_sql": []
    },
    "1790": {
        "db_id": "soccer_2016",
        "question": "Please list the IDs of all the matches in the year 2008.",
        "ground_truth": "SELECT Match_Id FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2008'",
        "amends": [
            "Do reference the table as `Match` instead of `matches` and use column `Match_Id` instead of `match_id`. Do use `SUBSTR(Match_Date, 1, 4) = '2008'` to extract the year from a date string instead of relying on a direct `year = 2008` comparison. The amended query now correctly handles date extraction and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT match_id FROM matches WHERE year = 2008;",
            "SELECT Match_Id FROM Match WHERE SUBSTR(Match_Date, 1, 4) = '2008'"
        ],
        "rule_sql": []
    },
    "6248": {
        "db_id": "food_inspection_2",
        "question": "Among the establishments that paid a 500 fine, what is the percentage of restaurants?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.facility_type = 'Restaurant' THEN T1.license_no END) AS REAL) * 100 / COUNT(T1.facility_type) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE T3.fine = 500",
        "amends": [
            "Do use `T1.facility_type` instead of `establishment_type` and `T1.license_no` instead of `1` in the CASE expression. Do add `INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no` and `INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id` instead of querying only the establishments table. Do use `T3.fine = 500` instead of `fine_amount = 500` in the WHERE clause. Do cast the count to `REAL` instead of using `100.0` for proper division. Do reference `T1.facility_type` in the denominator count instead of `*` to ensure consistent counting logic. The amended query now correctly joins related tables and uses the appropriate column names to calculate the percentage of restaurants with $500 fines."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN establishment_type = 'Restaurant' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_restaurants\nFROM establishments\nWHERE fine_amount = 500;",
            "SELECT \n    (COUNT(CASE WHEN T1.facility_type = 'Restaurant' THEN T1.license_no END) * 100.0 / COUNT(T1.facility_type)) AS percentage\nFROM \n    establishment AS T1\nINNER JOIN \n    inspection AS T2 ON T1.license_no = T2.license_no\nINNER JOIN \n    violation AS T3 ON T2.inspection_id = T3.inspection_id\nWHERE \n    T3.fine = 500;"
        ],
        "rule_sql": []
    },
    "1941": {
        "db_id": "soccer_2016",
        "question": "Tally the match IDs in which V Kohli is the \"Man of the Match\".",
        "ground_truth": "SELECT T1.Match_Id FROM `Match` AS T1 INNER JOIN Player AS T2 ON T1.Man_of_the_Match = T2.Player_Id WHERE T2.Player_Name = 'V Kohli'",
        "amends": [
            "Do select `T1.Match_Id` instead of `COUNT(*)` to return individual match IDs rather than a count. Do use `FROM Match AS T1` instead of `FROM matches` with proper table aliasing. Do add `INNER JOIN Player AS T2` instead of omitting the Player table join. Do use join condition `ON T1.Man_of_the_Match = T2.Player_Id` instead of directly filtering on player name. Do filter with `WHERE T2.Player_Name = 'V Kohli'` instead of `WHERE player_of_match = 'V Kohli'` to properly reference the normalized player name field. The amended query now correctly joins the Match and Player tables to find matches where V Kohli was man of the match, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE player_of_match = 'V Kohli'",
            "SELECT T1.Match_Id\nFROM Match AS T1\nINNER JOIN Player AS T2 ON T1.Man_of_the_Match = T2.Player_Id\nWHERE T2.Player_Name = 'V Kohli'"
        ],
        "rule_sql": []
    },
    "8485": {
        "db_id": "mondial_geo",
        "question": "Find the government type for the country with the highest percentage GDP in Agriculture.",
        "ground_truth": "SELECT T3.Government FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country ORDER BY T2.Agriculture DESC LIMIT 1",
        "amends": [
            "Do select `T3.Government` instead of `government_type` and add proper table aliases. Do join `country AS T1` instead of querying `countries` alone, then add `INNER JOIN economy AS T2 ON T1.Code = T2.Country` instead of missing this table relationship, and add `INNER JOIN politics AS T3 ON T3.Country = T2.Country` instead of omitting the politics table entirely. Do order by `T2.Agriculture DESC` instead of `gdp_agriculture_percentage DESC` to use the correct column from the joined economy table. The amended query now correctly joins the necessary tables to retrieve government type from the politics table while ordering by agriculture percentage from the economy table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT government_type FROM countries ORDER BY gdp_agriculture_percentage DESC LIMIT 1;",
            "SELECT T3.Government\nFROM country AS T1\nINNER JOIN economy AS T2 ON T1.Code = T2.Country\nINNER JOIN politics AS T3 ON T3.Country = T2.Country\nORDER BY T2.Agriculture DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1633": {
        "db_id": "car_retails",
        "question": "What is the total price of the order made by Cruz & Sons Co. on 2003/3/3?",
        "ground_truth": "SELECT SUM(t1.priceEach * t1.quantityOrdered) FROM orderdetails AS t1 INNER JOIN orders AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN customers AS t3 ON t2.customerNumber = t3.customerNumber WHERE t3.customerName = 'Cruz & Sons Co.' AND t2.orderDate = '2003-03-03'",
        "amends": [
            "Do calculate `SUM(t1.priceEach * t1.quantityOrdered)` instead of `SUM(price)` to properly account for both unit price and quantity. Do join `orderdetails AS t1` instead of omitting it, as the price data resides in the orderdetails table. Do join `orders AS t2` with `t1.orderNumber = t2.orderNumber` instead of querying orders directly, to establish the proper relationship between order details and orders. Do join `customers AS t3` with `t2.customerNumber = t3.customerNumber` instead of filtering by customer_name directly on orders, to correctly link customers to their orders. Do filter by `t3.customerName` instead of `customer_name` to use the proper column name from the customers table. Do use date format `'2003-03-03'` instead of `'2003/3/3'` for consistent date handling. The amended query now correctly calculates the total order value by joining the necessary tables and using the proper aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE customer_name = 'Cruz & Sons Co.' AND order_date = '2003/3/3';",
            "SELECT SUM(t1.priceEach * t1.quantityOrdered) AS total_price\nFROM orderdetails AS t1\nJOIN orders AS t2 ON t1.orderNumber = t2.orderNumber\nJOIN customers AS t3 ON t2.customerNumber = t3.customerNumber\nWHERE t3.customerName = 'Cruz & Sons Co.'\nAND t2.orderDate = '2003-03-03';"
        ],
        "rule_sql": []
    },
    "9069": {
        "db_id": "bike_share_1",
        "question": "What is the longest duration for a bike trip starting on a day with a fog in 2013?",
        "ground_truth": "SELECT MAX(T1.duration) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.date LIKE '%2013%' AND T2.events = 'Fog' AND T2.zip_code = 94107",
        "amends": [
            "Do reference `T1.duration` with table alias instead of `duration` without qualification. Do join `trip AS T1` with `weather AS T2` on `T2.zip_code = T1.zip_code` instead of querying only `bike_trips`. Do filter on `T2.date LIKE '%2013%'` instead of `start_time LIKE '2013%'` to match weather dates. Do filter on `T2.events = 'Fog'` instead of `weather = 'fog'` using the correct column name and case. Do add `T2.zip_code = 94107` condition instead of omitting the zip code filter. The amended query now correctly joins trip and weather data with proper date matching and event filtering for the specified location."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(duration) FROM bike_trips WHERE start_time LIKE '2013%' AND weather = 'fog';",
            "SELECT MAX(T1.duration) AS longest_duration\nFROM trip AS T1\nJOIN weather AS T2 ON T2.zip_code = T1.zip_code\nWHERE T2.date LIKE '%2013%'\nAND T2.events = 'Fog'\nAND T2.zip_code = '94107';"
        ],
        "rule_sql": []
    },
    "3309": {
        "db_id": "video_games",
        "question": "How many action games are there in total?",
        "ground_truth": "SELECT COUNT(T1.id) FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T2.genre_name = 'Action'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific records. Do join `game AS T1` with `genre AS T2` on `T1.genre_id = T2.id` instead of querying a single table. Do filter on `T2.genre_name = 'Action'` instead of `genre = 'Action'` to properly reference the normalized genre table. The amended query now correctly counts games by joining with the genre table and filtering on the genre name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE genre = 'Action';",
            "SELECT COUNT(T1.id) \nFROM game AS T1 \nJOIN genre AS T2 ON T1.genre_id = T2.id \nWHERE T2.genre_name = 'Action'"
        ],
        "rule_sql": []
    },
    "6879": {
        "db_id": "retails",
        "question": "The part \"hot spring dodger dim light\" is ordered in how many orders?",
        "ground_truth": "SELECT COUNT(T1.p_partkey) FROM part AS T1 INNER JOIN lineitem AS T2 ON T1.p_partkey = T2.l_partkey WHERE T1.p_name = 'hot spring dodger dim light'",
        "amends": [
            "Do add `part AS T1 INNER JOIN lineitem AS T2 ON T1.p_partkey = T2.l_partkey` instead of querying only the `orders` table. Do change the count expression to `COUNT(T1.p_partkey)` instead of `COUNT(*)` to count specific part keys. Do change the filter to `T1.p_name = 'hot spring dodger dim light'` instead of `part_name = 'hot spring dodger dim light'` to use the correct column name from the joined table. The amended query now correctly joins the part and lineitem tables to count parts with the specified name that have associated line items, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE part_name = 'hot spring dodger dim light';",
            "SELECT COUNT(DISTINCT T2.l_orderkey) \nFROM part AS T1 \nINNER JOIN lineitem AS T2 ON T1.p_partkey = T2.l_partkey \nWHERE T1.p_name = 'hot spring dodger dim light'"
        ],
        "rule_sql": []
    },
    "8835": {
        "db_id": "food_inspection",
        "question": "Who were the owners of eateries which had highest health hazard by improper cooking time or temperatures?",
        "ground_truth": "SELECT T2.owner_name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.risk_category = 'High Risk' AND T1.description = 'Improper cooking time or temperatures'",
        "amends": [
            "Do select `T2.owner_name` from the `businesses` table instead of `owner_name` from the `eateries` table. Do join `violations AS T1` with `businesses AS T2` using `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying only the `eateries` table. Do filter with `T1.risk_category = 'High Risk'` and `T1.description = 'Improper cooking time or temperatures'` instead of `health_hazard = 'improper cooking time' OR health_hazard = 'improper temperatures'`. Do remove the `ORDER BY health_hazard_score ASC LIMIT 1` clause instead of keeping it, as the correct query returns all matching records rather than just one. The amended query now correctly joins violation data with business information and uses proper risk category and description filtering instead of incorrect health hazard fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_name FROM eateries WHERE health_hazard = 'improper cooking time' OR health_hazard = 'improper temperatures' ORDER BY health_hazard_score ASC LIMIT 1;",
            "SELECT T2.owner_name\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T1.risk_category = 'High Risk'\nAND T1.description = 'Improper cooking time or temperatures'"
        ],
        "rule_sql": []
    },
    "2625": {
        "db_id": "regional_sales",
        "question": "Which city has the largest population?",
        "ground_truth": "SELECT `City Name` FROM `Store Locations` ORDER BY Population DESC LIMIT 1",
        "amends": [
            "Do select `City Name` instead of `city` to match the correct column name. Do reference table `Store Locations` instead of `cities` to use the proper table source. Do order by `Population DESC` instead of `population ASC` to sort by descending population rather than ascending. Do maintain `LIMIT 1` to return only the top result. The amended query now correctly retrieves the city with the highest population from the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities ORDER BY population ASC LIMIT 1;",
            "SELECT \"City Name\" FROM \"Store Locations\" ORDER BY Population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5930": {
        "db_id": "books",
        "question": "List the title of the earliest published Japanese book.",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE T2.language_name = 'Japanese' ORDER BY T1.publication_date ASC LIMIT 1",
        "amends": [
            "Do join `book AS T1` with `book_language AS T2` on `T1.language_id = T2.language_id` instead of querying `books` table directly. Do filter on `T2.language_name = 'Japanese'` instead of `language = 'Japanese'`. Do order by `T1.publication_date ASC` instead of `publication_date DESC`. Do select `T1.title` with table alias instead of just `title`. The amended query now correctly joins through the language reference table and sorts in ascending order to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE language = 'Japanese' ORDER BY publication_date DESC LIMIT 1;",
            "SELECT T1.title \nFROM book AS T1 \nJOIN book_language AS T2 ON T1.language_id = T2.language_id \nWHERE T2.language_name = 'Japanese' \nORDER BY T1.publication_date ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2948": {
        "db_id": "professional_basketball",
        "question": "For the player in 2011 who started every game he played, which team had the player who had the most steals?",
        "ground_truth": "SELECT T1.tmID FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = 2011 AND T2.GP = T2.GS GROUP BY T1.tmID, T2.steals ORDER BY T2.steals DESC LIMIT 1",
        "amends": [
            "Do select `T1.tmID` instead of `t.name, p.player_name, SUM(s.steals) as total_steals`. Do use `teams AS T1` instead of `teams t` and `players_teams AS T2` instead of `players p` and `player_stats s`. Do perform `INNER JOIN` on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of separate joins on `p.player_id = s.player_id` and `p.team_id = t.team_id`. Do add filter `T1.year = 2011` instead of `s.year = 2011` and keep `T2.GP = T2.GS` instead of `s.games_started = s.games_played`. Do group by `T1.tmID, T2.steals` instead of `p.player_id`. Do order by `T2.steals DESC` instead of `total_steals DESC`. The amended query now correctly retrieves team IDs with the highest steals from players who played all games in 2011."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.name, p.player_name, SUM(s.steals) as total_steals\nFROM players p\nJOIN player_stats s ON p.player_id = s.player_id\nJOIN teams t ON p.team_id = t.team_id\nWHERE s.year = 2011\nAND s.games_started = s.games_played\nGROUP BY p.player_id\nORDER BY total_steals DESC\nLIMIT 1;",
            "SELECT T1.tmID\nFROM teams AS T1\nINNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.year = 2011 AND T2.GP = T2.GS\nGROUP BY T1.tmID, T2.steals\nORDER BY T2.steals DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4944": {
        "db_id": "olympics",
        "question": "How many gold medals does Henk Jan Zwolle have?",
        "ground_truth": "SELECT COUNT(T1.id) FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE T1.full_name = 'Henk Jan Zwolle' AND T4.medal_name = 'Gold'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references. Do join multiple tables with `INNER JOIN` on `T1.id=T2.person_id`, `T2.id=T3.competitor_id`, and `T3.medal_id=T4.id` instead of querying a single `medals` table. Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific records. Do filter on `T1.full_name='Henk Jan Zwolle'` instead of `athlete_name='Henk Jan Zwolle'` to use the correct column name. Do filter on `T4.medal_name='Gold'` instead of `medal_type='Gold'` to reference the proper medal attribute. The amended query now correctly joins the person, games_competitor, competitor_event, and medal tables to count gold medals for the specified athlete, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM medals WHERE athlete_name = 'Henk Jan Zwolle' AND medal_type = 'Gold';",
            "SELECT COUNT(T1.id) \nFROM person T1\nINNER JOIN games_competitor T2 ON T1.id = T2.person_id\nINNER JOIN competitor_event T3 ON T2.id = T3.competitor_id\nINNER JOIN medal T4 ON T3.medal_id = T4.id\nWHERE T1.full_name = 'Henk Jan Zwolle' AND T4.medal_name = 'Gold'"
        ],
        "rule_sql": []
    },
    "212": {
        "db_id": "book_publishing_company",
        "question": "What is the average level employees working as Managing Editor are at? How many levels are there between the average level and the highest level?",
        "ground_truth": "SELECT AVG(T2.job_lvl), T1.max_lvl - AVG(T2.job_lvl) FROM jobs AS T1 INNER JOIN employee AS T2 ON T1.job_id = T2.job_id WHERE T1.job_desc = 'Managing Editor' GROUP BY T2.job_id, T1.max_lvl",
        "amends": [
            "Do join `jobs AS T1` and `employee AS T2` with `INNER JOIN` on `T1.job_id = T2.job_id` instead of querying only `employees` table. Do filter on `T1.job_desc = 'Managing Editor'` instead of `job_title = 'Managing Editor'`. Do add `GROUP BY T2.job_id, T1.max_lvl` instead of omitting grouping. Do reference `T2.job_lvl` and `T1.max_lvl` instead of `level` column. Do remove column aliases `average_level` and `levels_difference` instead of keeping them. The amended query now correctly calculates statistics by joining job descriptions with employee levels and grouping to avoid aggregation errors."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(level) AS average_level, MAX(level) - AVG(level) AS levels_difference \nFROM employees \nWHERE job_title = 'Managing Editor';",
            "SELECT AVG(T2.job_lvl) AS average_level, (T1.max_lvl - AVG(T2.job_lvl)) AS levels_difference FROM jobs AS T1 INNER JOIN employee AS T2 ON T1.job_id = T2.job_id WHERE T1.job_desc = 'Managing Editor' GROUP BY T2.job_id, T1.max_lvl"
        ],
        "rule_sql": []
    },
    "8066": {
        "db_id": "university",
        "question": "Name the university and country which had the highest number of international students in 2015.",
        "ground_truth": "SELECT T1.university_name, T3.country_name FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.year = 2015 ORDER BY T2.num_students DESC LIMIT 1",
        "amends": [
            "Do select `university_name` and `country_name` instead of `university` and `country`. Do join `university` as `T1` with `university_year` as `T2` on `T1.id = T2.university_id` instead of querying a single table. Do add join to `country` as `T3` on `T3.id = T1.country_id` instead of omitting it. Do filter on `T2.year = 2015` instead of `year = 2015`. Do order by `T2.num_students DESC` instead of `student_count ASC`. The amended query now correctly retrieves the university with the highest student count in 2015 by properly joining the necessary tables and ordering in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university, country FROM international_students WHERE year = 2015 ORDER BY student_count ASC LIMIT 1;",
            "SELECT T1.university_name, T3.country_name\nFROM university T1\nJOIN university_year T2 ON T1.id = T2.university_id\nJOIN country T3 ON T3.id = T1.country_id\nWHERE T2.year = 2015\nORDER BY T2.num_students DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8397": {
        "db_id": "mondial_geo",
        "question": "Give the full names of the countries that are located in more than one continent.",
        "ground_truth": "SELECT T3.Name FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country GROUP BY T3.Name HAVING COUNT(T3.Name) > 1",
        "amends": [
            "Do use `T3.Name` from the `country` table instead of `country_name` from a non-existent `countries` table. Do add `INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent` and `INNER JOIN country AS T3 ON T3.Code = T2.Country` instead of querying a single table. Do use `GROUP BY T3.Name` and `HAVING COUNT(T3.Name) > 1` instead of `WHERE continent_count > 1` to filter aggregated results rather than individual rows. Do reference the correct schema with proper table aliases and join conditions instead of using incorrect table names and column references. The amended query now correctly identifies countries that belong to more than one continent through proper joins and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE continent_count > 1;",
            "SELECT T3.Name \nFROM continent AS T1\nINNER JOIN encompasses AS T2 ON T1.Name = T2.Continent\nINNER JOIN country AS T3 ON T3.Code = T2.Country\nGROUP BY T3.Name\nHAVING COUNT(T3.Name) > 1"
        ],
        "rule_sql": []
    },
    "9426": {
        "db_id": "movie_3",
        "question": "Among the payments made by Mary Smith, how many of them are over 4.99?",
        "ground_truth": "SELECT COUNT(T1.amount) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'MARY' AND T2.last_name = 'SMITH' AND T1.amount > 4.99",
        "amends": [
            "Do use `COUNT(T1.amount)` instead of `COUNT(*)` to count only non-null payment amounts. Do use table aliases `T1` and `T2` instead of `p` and `c` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use uppercase string comparisons `'MARY'` and `'SMITH'` instead of mixed case `'Mary'` and `'Smith'` to match case-insensitive database behavior. The amended query now correctly counts payments over $4.99 for customer MARY SMITH while maintaining the same logical behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM payment p JOIN customer c ON p.customer_id = c.customer_id WHERE c.first_name = 'Mary' AND c.last_name = 'Smith' AND p.amount > 4.99",
            "SELECT COUNT(T1.amount) \nFROM payment T1\nINNER JOIN customer T2 ON T1.customer_id = T2.customer_id\nWHERE T2.first_name = 'MARY' \nAND T2.last_name = 'SMITH' \nAND T1.amount > 4.99"
        ],
        "rule_sql": []
    },
    "2931": {
        "db_id": "professional_basketball",
        "question": "How many percent of points were scored by NBA players who belonged to 'LAL' team and had performed steals movement.",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.steals IS NOT NULL AND T1.tmID = 'LAL', 1, 0)) AS REAL) * 100 / COUNT(T1.tmID) FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year",
        "amends": [
            "Do use `CAST(SUM(IIF(...)) AS REAL)` for precise percentage calculation instead of `COUNT(*) * 100.0` which counts all rows. Do reference `T2.steals IS NOT NULL` instead of `p.movement = 'steals'` to properly check for steal events. Do join `teams AS T1` and `players_teams AS T2` with `T1.tmID = T2.tmID AND T1.year = T2.year` instead of joining `points` and `players` on `player_id` alone. Do filter for `T1.tmID = 'LAL'` instead of `pl.team = 'LAL'` to correctly identify the team. Do calculate percentage as `SUM(IIF(condition, 1, 0)) * 100 / COUNT(T1.tmID)` instead of dividing by total points count, which better represents the team-specific percentage. The amended query now correctly calculates the percentage of players with steals for the LAL team across the proper team-player relationship with year alignment.",
            "Do move the `T1.tmID = 'LAL'` filter from the WHERE clause to inside the IIF condition instead of applying it globally. Do change `COUNT(*)` to `COUNT(T1.tmID)` instead of counting all rows. Do remove the alias `percentage` instead of keeping it. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do remove the multiplication by `100.0` and division formatting instead of keeping the explicit decimal notation. The amended query now correctly calculates the percentage only for the specified team while maintaining proper join semantics and aggregation behavior.",
            "Do remove the `WHERE T1.tmID = 'LAL'` filter instead of keeping it, as the conditional logic within the `IIF` function already handles the team-specific calculation while preserving the full dataset needed for the denominator's `COUNT` operation. This ensures the percentage calculation correctly represents the proportion of players with steals data for the LAL team relative to all players across all teams in the joined dataset."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM points)) AS percentage\nFROM points p\nJOIN players pl ON p.player_id = pl.player_id\nWHERE pl.team = 'LAL' AND p.movement = 'steals';",
            "SELECT \n    CAST(SUM(IIF(T2.steals IS NOT NULL, 1, 0)) AS REAL) * 100.0 / COUNT(*) AS percentage\nFROM \n    teams AS T1\nJOIN \n    players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE \n    T1.tmID = 'LAL';",
            "SELECT CAST(SUM(IIF(T2.steals IS NOT NULL AND T1.tmID = 'LAL', 1, 0)) AS REAL) * 100 / COUNT(T1.tmID) \nFROM teams AS T1 \nINNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year \nWHERE T1.tmID = 'LAL';",
            "SELECT CAST(SUM(IIF(T1.tmID = 'LAL' AND T2.steals IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.tmID) \nFROM teams AS T1 \nINNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year;"
        ],
        "rule_sql": []
    },
    "5068": {
        "db_id": "olympics",
        "question": "What is the name of the youngest competitor?",
        "ground_truth": "SELECT T1.full_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id ORDER BY T2.age LIMIT 1",
        "amends": [
            "Do select `T1.full_name` instead of `name` to reference the correct column from the joined table. Do add `FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id` instead of the single table `competitors` to properly join the person and competitor data through the relationship. Do order by `T2.age` instead of `age` to reference the age column from the correct table source. The amended query now correctly retrieves the youngest competitor's full name by joining the person and games_competitor tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM competitors ORDER BY age ASC LIMIT 1;",
            "SELECT T1.full_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id ORDER BY T2.age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8965": {
        "db_id": "human_resources",
        "question": "How much is the salary of the first ever employee that was hired?",
        "ground_truth": "SELECT salary FROM employee ORDER BY hiredate ASC LIMIT 1",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do order by `hiredate` with `ASC` direction instead of `hire_date` with `DESC` direction. The amended query now correctly retrieves the salary from the employee table ordered by hiredate in ascending order with a limit of 1, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT salary FROM employees ORDER BY hire_date DESC LIMIT 1;",
            "SELECT salary FROM employee ORDER BY hiredate ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "8438": {
        "db_id": "mondial_geo",
        "question": "Which nation has the lowest proportion of people who speak an African language? Please state the nation's full name.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'African' ORDER BY T2.Percentage ASC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country.name`. Do join `ethnicGroup AS T2` instead of `language` table. Do use `INNER JOIN` with `T1.Code = T2.Country` instead of joining on `country.code = language.country_code`. Do filter with `T2.Name = 'African'` instead of `language.name LIKE '%African%'`. Do remove `GROUP BY country.name` instead of keeping it. Do order by `T2.Percentage ASC` instead of `COUNT(language.name) / country.population ASC`. The amended query now correctly finds countries with African ethnic groups ordered by percentage rather than attempting to calculate language ratios."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.name \nFROM country \nJOIN language ON country.code = language.country_code \nWHERE language.name LIKE '%African%' \nGROUP BY country.name \nORDER BY COUNT(language.name) / country.population ASC \nLIMIT 1;",
            "SELECT T1.Name \nFROM country AS T1\nINNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country\nWHERE T2.Name = 'African'\nORDER BY T2.Percentage ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7648": {
        "db_id": "hockey",
        "question": "How many coaches worked a temporary term in the year 2007?",
        "ground_truth": "SELECT COUNT(coachID) FROM Coaches WHERE year = 2007 AND notes = 'interim'",
        "amends": [
            "Do count `coachID` instead of `*` to exclude null values. Do reference table `Coaches` instead of `coaches` with proper case sensitivity. Do filter on column `notes` with value 'interim' instead of column `temporary` with value 'yes' to correctly identify interim coaches. The amended query now matches the intended behavior of counting interim coaches from the Coaches table for the year 2007."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM coaches WHERE year = 2007 AND temporary = 'yes';",
            "SELECT COUNT(coachID) FROM Coaches WHERE year = 2007 AND notes = 'interim'"
        ],
        "rule_sql": []
    },
    "2289": {
        "db_id": "movielens",
        "question": "Among the films directed by directors who direct the best, how many of them have an average rating of over 3.5?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT DISTINCT T2.movieid FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid INNER JOIN u2base AS T3 ON T2.movieid = T3.movieid WHERE T1.d_quality = 5 GROUP BY T2.movieid HAVING AVG(T3.rating) > 3.5 ) AS T1",
        "amends": [
            "Do use `SELECT DISTINCT T2.movieid` in a subquery instead of `SELECT COUNT(*)` directly from the main query. Do join `movies2directors AS T2` on `T1.directorid = T2.directorid` instead of joining `directors d` on `f.director_id = d.director_id`. Do add `u2base AS T3` joined on `T2.movieid = T3.movieid` instead of omitting this table. Do filter with `T1.d_quality = 5` instead of `d.director_rating = 'best'`. Do use `GROUP BY T2.movieid` and move the rating filter to `HAVING AVG(T3.rating) > 3.5` instead of using `WHERE f.rating > 3.5` directly. Do count the distinct movie IDs from the subquery instead of counting all film records. The amended query now correctly counts movies by high-quality directors with average user ratings above 3.5, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM films f\nJOIN directors d ON f.director_id = d.director_id\nWHERE d.director_rating = 'best' \nAND f.rating > 3.5;",
            "SELECT COUNT(*) FROM (\n    SELECT DISTINCT T2.movieid\n    FROM directors AS T1\n    JOIN movies2directors AS T2 ON T1.directorid = T2.directorid\n    JOIN u2base AS T3 ON T2.movieid = T3.movieid\n    WHERE T1.d_quality = 5\n    GROUP BY T2.movieid\n    HAVING AVG(CAST(T3.rating AS REAL)) > 3.5\n)"
        ],
        "rule_sql": []
    },
    "2137": {
        "db_id": "world_development_indicators",
        "question": "From 1960 to 1965, which country had the highest Death rate, crude (per 1,000 people)?",
        "ground_truth": "SELECT CountryName FROM Indicators WHERE Year BETWEEN 1960 AND 1965 AND IndicatorName = 'Death rate, crude (per 1,000 people)' ORDER BY Value DESC LIMIT 1",
        "amends": [
            "Do select `CountryName` instead of `Country` and do not use an aggregate function or alias. Do query from `Indicators` instead of `health_data` and add a filter for `IndicatorName = 'Death rate, crude (per 1,000 people)'` instead of omitting it. Do remove the `GROUP BY Country` clause instead of keeping it. Do order by `Value DESC` instead of `Highest_Death_Rate DESC` while maintaining the same `LIMIT 1`. The amended query now correctly filters for the specific death rate indicator and orders by the actual value column rather than using an unnecessary aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country, MAX(Death_rate) as Highest_Death_Rate \nFROM health_data \nWHERE Year BETWEEN 1960 AND 1965 \nGROUP BY Country \nORDER BY Highest_Death_Rate DESC \nLIMIT 1;",
            "SELECT CountryName FROM Indicators WHERE IndicatorName = 'Death rate, crude (per 1,000 people)' AND Year BETWEEN 1960 AND 1965 ORDER BY Value DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "1697": {
        "db_id": "restaurant",
        "question": "Calculate the average rating of reviews for restaurants in Santa Cruz County.",
        "ground_truth": "SELECT AVG(T2.review) FROM geographic AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.county = 'santa cruz county'",
        "amends": [
            "Do select `AVG(T2.review)` from the `generalinfo` table instead of `AVG(rating)` from a non-existent `reviews` table. Do join `geographic AS T1` with `generalinfo AS T2` using `INNER JOIN` on `T1.city = T2.city` instead of querying a single table. Do filter on `T1.county = 'santa cruz county'` instead of `county = 'Santa Cruz'` to match the correct county name format and source table. The amended query now correctly calculates average reviews from the appropriate joined tables with proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM reviews WHERE county = 'Santa Cruz';",
            "SELECT AVG(T2.review) \nFROM geographic AS T1 \nINNER JOIN generalinfo AS T2 ON T1.city = T2.city \nWHERE T1.county = 'santa cruz county'"
        ],
        "rule_sql": []
    },
    "5022": {
        "db_id": "olympics",
        "question": "Please list all game names that were held in Los Angeles.",
        "ground_truth": "SELECT T3.games_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T2.city_name = 'Los Angeles'",
        "amends": [
            "Do use a multi-table join structure with `games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id` instead of querying only the `games` table. Do reference the column as `T3.games_name` instead of `game_name` to specify the table alias. Do filter on `T2.city_name = 'Los Angeles'` instead of `city = 'Los Angeles'` to use the proper city name column from the city table. Do remove the direct city filter on the games table instead of assuming it contains city information. The amended query now correctly joins through the association table to find games associated with Los Angeles, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE city = 'Los Angeles';",
            "SELECT T3.games_name\nFROM games_city AS T1\nINNER JOIN city AS T2 ON T1.city_id = T2.id\nINNER JOIN games AS T3 ON T1.games_id = T3.id\nWHERE T2.city_name = 'Los Angeles'"
        ],
        "rule_sql": []
    },
    "5805": {
        "db_id": "language_corpus",
        "question": "Which word that has 274499 repetitions in the Catalan language?",
        "ground_truth": "SELECT T1.word FROM words AS T1 INNER JOIN langs_words AS T2 ON T1.wid = T2.wid WHERE T2.occurrences = 274499 AND T2.lid = 1",
        "amends": [
            "Do select `T1.word` with table alias instead of just `word` without qualification. Do join `words AS T1` and `langs_words AS T2` with an `INNER JOIN` on `T1.wid = T2.wid` instead of querying only `catalan_words` without any joins. Do add filter conditions `T2.occurrences = 274499` and `T2.lid = 1` instead of filtering only on `repetitions = 274499` without language specification. The amended query now correctly retrieves words with specific occurrence counts for a particular language by joining the appropriate tables and filtering on the language ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word FROM catalan_words WHERE repetitions = 274499;",
            "SELECT T1.word FROM words AS T1 INNER JOIN langs_words AS T2 ON T1.wid = T2.wid WHERE T2.occurrences = 274499 AND T2.lid = 1"
        ],
        "rule_sql": []
    },
    "1593": {
        "db_id": "car_retails",
        "question": "Who is the sales agent of the customer who has made the highest payment? Include the full names of employee and his/her supervisor.",
        "ground_truth": "SELECT T1.firstName, T1.lastName, T1.reportsTo FROM employees AS T1 INNER JOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber INNER JOIN payments AS T3 ON T2.customerNumber = T3.customerNumber ORDER BY T3.amount DESC LIMIT 1",
        "amends": [
            "Do select `firstName`, `lastName`, and `reportsTo` instead of `FirstName`, `LastName`, `SupervisorFirstName`, and `SupervisorLastName`. Do join `employees AS T1` with `customers AS T2` on `T1.employeeNumber = T2.salesRepEmployeeNumber` instead of joining `employees e` with `customers c` on `e.EmployeeId = c.SupportRepId`. Do join `customers AS T2` with `payments AS T3` on `T2.customerNumber = T3.customerNumber` instead of joining `customers c` with `payments p` on `c.CustomerId = p.CustomerId`. Do remove the supervisor join on `e.ReportsTo = s.EmployeeId` instead of keeping it. Do remove the WHERE clause with subquery for `MAX(Amount)` instead of filtering by maximum payment amount. Do add `ORDER BY T3.amount DESC` instead of omitting ordering. Do keep `LIMIT 1` but change its position to after ordering instead of before. The amended query now correctly finds the employee with the highest payment amount by sorting payments in descending order and taking the top result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.FirstName, e.LastName, s.FirstName AS SupervisorFirstName, s.LastName AS SupervisorLastName\nFROM employees e\nJOIN customers c ON e.EmployeeId = c.SupportRepId\nJOIN payments p ON c.CustomerId = p.CustomerId\nJOIN employees s ON e.ReportsTo = s.EmployeeId\nWHERE p.Amount = (SELECT MAX(Amount) FROM payments)\nLIMIT 1;",
            "SELECT T1.firstName, T1.lastName, T1.reportsTo\nFROM employees AS T1\nJOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber\nJOIN payments AS T3 ON T2.customerNumber = T3.customerNumber\nORDER BY T3.amount DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "540": {
        "db_id": "movies_4",
        "question": "List the movies in the Somali language.",
        "ground_truth": "SELECT T1.title FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id WHERE T3.language_name = 'Somali'",
        "amends": [
            "Do select only `T1.title` instead of all columns with `*`. Do join `movie AS T1` with `movie_languages AS T2` on `T1.movie_id = T2.movie_id` instead of querying a single table. Do add a second join to `language AS T3` on `T2.language_id = T3.language_id` instead of omitting this relationship. Do filter on `T3.language_name = 'Somali'` instead of `language = 'English'` to correctly identify Somali language films through the normalized language table structure. The amended query now properly joins through the language relationship tables to accurately filter movies by language name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM movies WHERE language = 'English';",
            "SELECT T1.title\nFROM movie AS T1\nJOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id\nJOIN language AS T3 ON T2.language_id = T3.language_id\nWHERE T3.language_name = 'Somali'"
        ],
        "rule_sql": []
    },
    "8416": {
        "db_id": "mondial_geo",
        "question": "Which river with its mouth in the Donau River and a length greater than 500 km is located in Slovenia?",
        "ground_truth": "SELECT T2.River FROM country AS T1 INNER JOIN geo_river AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Slovenia' AND T2.River IN ( SELECT NAME FROM river WHERE Length > 500 AND River = 'Donau' )",
        "amends": [
            "Do select `T2.River` from the `geo_river` table instead of `name` from the `rivers` table. Do join `country` as `T1` with `geo_river` as `T2` on `T1.Code = T2.Country` instead of querying a single `rivers` table. Do filter on `T1.Name = 'Slovenia'` instead of `country = 'Slovenia'`. Do use a subquery to filter rivers with `Length > 500` and `River = 'Donau'` instead of direct filters `mouth = 'Donau River'` and `length > 500`. Do reference the river as `'Donau'` instead of `'Donau River'` in the condition. The amended query now correctly joins country and river geography data and uses proper subquery filtering to match the intended logic.",
            "Do use `NAME` in the subquery SELECT list instead of `River` to properly reference the river table's column. Do change the subquery WHERE clause order to `Length > 500 AND River = 'Donau'` instead of `River = 'Donau' AND Length > 500'` for equivalent but potentially more efficient filtering. The amended query now correctly filters for rivers named 'Donau' with length greater than 500 while maintaining the same join logic and country filter for Slovenia."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM rivers WHERE mouth = 'Donau River' AND length > 500 AND country = 'Slovenia';",
            "SELECT T2.River\nFROM country T1\nJOIN geo_river T2 ON T1.Code = T2.Country\nWHERE T1.Name = 'Slovenia'\nAND T2.River IN (\n    SELECT River\n    FROM river\n    WHERE River = 'Donau'\n    AND Length > 500\n)",
            "SELECT T2.River\nFROM country T1\nJOIN geo_river T2 ON T1.Code = T2.Country\nWHERE T1.Name = 'Slovenia'\nAND T2.River IN (\n    SELECT NAME\n    FROM river\n    WHERE Length > 500\n    AND River = 'Donau'\n)"
        ],
        "rule_sql": []
    },
    "9169": {
        "db_id": "movie_3",
        "question": "What is the percentage more for the rental payment for store No.2 than store No.1?",
        "ground_truth": "SELECT CAST((SUM(IIF(T2.store_id = 2, T1.amount, 0)) - SUM(IIF(T2.store_id = 1, T1.amount, 0))) AS REAL) * 100 / SUM(IIF(T2.store_id = 1, T1.amount, 0)) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN store AS T3 ON T2.store_id = T3.store_id",
        "amends": [
            "Do add explicit `CAST` to `REAL` for the numerator instead of implicit integer division. Do reference `T1.amount` through table aliases instead of direct column references. Do add `FROM` clause with `INNER JOIN` between `payment AS T1` and `customer AS T2` on `T1.customer_id = T2.customer_id` instead of a single table. Do add second `INNER JOIN` to `store AS T3` on `T2.store_id = T3.store_id` instead of omitting store validation. Do move the multiplication by 100 to after the division instead of before it. Do remove the alias `percentage_more` instead of keeping it. The amended query now correctly calculates the percentage difference between store amounts with proper joins and real number arithmetic.",
            "Do use `IIF` instead of `CASE WHEN` for conditional expressions. Do calculate the difference between store sums directly as `SUM(IIF(T2.store_id = 2, T1.amount, 0)) - SUM(IIF(T2.store_id = 1, T1.amount, 0))` instead of using a ratio minus one. Do reference `T2.store_id` directly instead of joining to the store table and using `T3.store_id`. Do remove the unnecessary join to the `store` table since the store_id is already available in the customer table. Do restructure the mathematical operation to subtract sums before division instead of calculating a ratio minus one. Do place the multiplication by 100 after the division instead of before it in the calculation. The amended query now correctly calculates the percentage difference between store payments without redundant joins and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SUM(CASE WHEN store_id = 2 THEN amount ELSE 0 END) - SUM(CASE WHEN store_id = 1 THEN amount ELSE 0 END)) / SUM(CASE WHEN store_id = 1 THEN amount ELSE 0 END) * 100 AS percentage_more FROM payments;",
            "SELECT \n    (CAST(SUM(CASE WHEN T3.store_id = 2 THEN T1.amount ELSE 0 END) AS REAL) / \n     CAST(SUM(CASE WHEN T3.store_id = 1 THEN T1.amount ELSE 0 END) AS REAL) - 1) * 100\nFROM payment AS T1\nINNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN store AS T3 ON T2.store_id = T3.store_id;",
            "SELECT CAST(100.0 * (SUM(IIF(customer.store_id = 2, payment.amount, 0)) - SUM(IIF(customer.store_id = 1, payment.amount, 0))) / SUM(IIF(customer.store_id = 1, payment.amount, 0)) AS REAL) FROM payment INNER JOIN customer ON payment.customer_id = customer.customer_id;"
        ],
        "rule_sql": []
    },
    "3831": {
        "db_id": "public_review_platform",
        "question": "What are the opening hours of business number 53 on Friday?",
        "ground_truth": "SELECT T1.closing_time - T1.opening_time AS \"opening hours\" FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T2.day_of_week LIKE 'Friday' AND T1.business_id = 53",
        "amends": [
            "Do select `T1.closing_time - T1.opening_time AS \"opening hours\"` instead of just `opening_hours`. Do join `Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id` instead of querying only `business_hours`. Do filter with `T2.day_of_week LIKE 'Friday'` instead of `day = 'Friday'` while keeping `T1.business_id = 53`. The amended query now correctly calculates opening hours by joining to the Days table and using proper column references.",
            "Do remove `T1.opening_time` and `T1.closing_time` from the SELECT list instead of including them, keeping only the calculated `opening hours` expression. Do maintain the `INNER JOIN` on `T1.day_id = T2.day_id` without change. Do reorder the WHERE clause predicates to place `T2.day_of_week LIKE 'Friday'` before `T1.business_id = 53` instead of the original order, though this is functionally equivalent. The amended query now correctly returns only the calculated opening hours duration without the individual time columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT opening_hours FROM business_hours WHERE business_id = 53 AND day = 'Friday';",
            "SELECT T1.opening_time, T1.closing_time, (T1.closing_time - T1.opening_time) AS \"opening hours\" FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T1.business_id = 53 AND T2.day_of_week LIKE 'Friday'",
            "SELECT T1.closing_time - T1.opening_time AS \"opening hours\"\nFROM Business_Hours AS T1\nINNER JOIN Days AS T2 ON T1.day_id = T2.day_id\nWHERE T2.day_of_week LIKE 'Friday' AND T1.business_id = 53"
        ],
        "rule_sql": []
    },
    "8271": {
        "db_id": "mondial_geo",
        "question": "Which country is 41% Christian? Give the full name of the country.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Christian' AND T2.Percentage = 41",
        "amends": [
            "Do select `T1.Name` from the `country` table instead of `country` from the `countries` table. Do add an `INNER JOIN` with the `religion` table on `T1.Code = T2.Country` instead of querying a single table. Do filter on `T2.Name = 'Christian'` and `T2.Percentage = 41` instead of filtering directly on `christian_percentage = 41`. The amended query now correctly joins relational data and matches the RIGHT_SQL's behavior by properly linking country codes with religious affiliation data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM countries WHERE christian_percentage = 41;",
            "SELECT T1.Name \nFROM country T1\nINNER JOIN religion T2 ON T1.Code = T2.Country\nWHERE T2.Name = 'Christian' AND T2.Percentage = 41"
        ],
        "rule_sql": []
    },
    "2777": {
        "db_id": "european_football_1",
        "question": "How many Scottish League One games took place on the day that \"Pro Vercelli\" and \"Pescara\"had a 5-2 game?",
        "ground_truth": "SELECT COUNT(T1.Date) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'Scottish League One' AND T1.Date = ( SELECT Date FROM matchs WHERE FTHG = 5 AND FTAG = 2 AND HomeTeam = 'Pro Vercelli' AND AwayTeam = 'Pescara' )",
        "amends": [
            "Do use `COUNT(T1.Date)` instead of `COUNT(*)` to count specific column values. Do join `matchs AS T1` with `divisions AS T2` on `T1.Div = T2.division` instead of querying a single table. Do filter with `T2.name = 'Scottish League One'` instead of directly referencing a league-specific table. Do reference `FTHG = 5` and `FTAG = 2` instead of `home_score = 5` and `away_score = 2` for score columns. Do use `HomeTeam = 'Pro Vercelli'` and `AwayTeam = 'Pescara'` instead of `home_team` and `away_team` for team column names. The amended query now correctly joins division information and uses proper column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM Scottish_League_One_Games \nWHERE date = (SELECT date FROM Games WHERE home_team = 'Pro Vercelli' AND away_team = 'Pescara' AND home_score = 5 AND away_score = 2)\nAND home_team = 'Pro Vercelli' AND away_team = 'Pescara';",
            "SELECT COUNT(T1.Date) \nFROM matchs AS T1\nJOIN divisions AS T2 ON T1.Div = T2.division\nWHERE T2.name = 'Scottish League One'\nAND T1.Date = (\n    SELECT Date \n    FROM matchs \n    WHERE HomeTeam = 'Pro Vercelli' \n    AND AwayTeam = 'Pescara' \n    AND FTHG = 5 \n    AND FTAG = 2\n)"
        ],
        "rule_sql": []
    },
    "4519": {
        "db_id": "student_loan",
        "question": "State the number of male students who do not have payment due.",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN male AS T2 ON T2.name = T1.name WHERE T1.bool = 'pos'",
        "amends": [
            "Do select `COUNT(T1.name)` instead of `COUNT(*)`. Do use `FROM no_payment_due AS T1 INNER JOIN male AS T2` instead of `FROM students`. Do apply join condition `ON T2.name = T1.name` instead of filtering with `WHERE gender = 'male' AND payment_due = 0`. Do add `WHERE T1.bool = 'pos'` instead of omitting this filter. The amended query now correctly joins specialized tables and applies the proper boolean filter to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND payment_due = 0",
            "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN male AS T2 ON T2.name = T1.name WHERE T1.bool = 'pos'"
        ],
        "rule_sql": []
    },
    "7591": {
        "db_id": "image_and_language",
        "question": "How many images have \"picture\" as their attribute class?",
        "ground_truth": "SELECT COUNT(T2.IMG_ID) FROM ATT_CLASSES AS T1 INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T1.ATT_CLASS = 'picture'",
        "amends": [
            "Do select `COUNT(T2.IMG_ID)` instead of `COUNT(*)` to count distinct image IDs rather than all rows. Do join `ATT_CLASSES AS T1` and `IMG_OBJ_ATT AS T2` with an `INNER JOIN` on `T1.ATT_CLASS_ID = T2.ATT_CLASS_ID` instead of querying only the `images` table. Do filter on `T1.ATT_CLASS = 'picture'` instead of `attribute = 'picture'` to use the correct attribute class name from the joined table. The amended query now correctly counts images associated with the 'picture' attribute class by joining the appropriate tables and using the proper relationship between attribute classes and image attributes.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the right query counts all matching IMG_ID values rather than only distinct ones. The amended query now matches RIGHT_SQL's behavior by returning the total count of all image IDs associated with the 'picture' attribute class rather than counting only unique image IDs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE attribute = 'picture';",
            "SELECT COUNT(DISTINCT T2.IMG_ID) \nFROM ATT_CLASSES AS T1 \nINNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID \nWHERE T1.ATT_CLASS = 'picture'",
            "SELECT COUNT(T2.IMG_ID) \nFROM ATT_CLASSES AS T1 \nINNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID \nWHERE T1.ATT_CLASS = 'picture'"
        ],
        "rule_sql": []
    },
    "2808": {
        "db_id": "professional_basketball",
        "question": "What division did the team coached by the winner of the 1977 NBA Coach of the Year award play in in 1976?",
        "ground_truth": "SELECT DISTINCT T3.divID FROM awards_coaches AS T1 INNER JOIN coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN teams AS T3 ON T2.tmID = T3.tmID WHERE T1.year = 1977 AND T1.award = 'NBA Coach of the Year' AND T3.year = 1976",
        "amends": [
            "Do use `DISTINCT T3.divID` instead of `division` to select the division ID with uniqueness. Do join `awards_coaches AS T1` instead of querying `awards` table directly. Do use `INNER JOIN coaches AS T2 ON T1.coachID = T2.coachID` instead of assuming coach names match directly. Do add `INNER JOIN teams AS T3 ON T2.tmID = T3.tmID` instead of querying teams separately. Do filter with `T1.year = 1977` instead of using a subquery for the award year. Do use `T1.award = 'NBA Coach of the Year'` instead of `award_name`. Do keep `T3.year = 1976` filter but reference it through the joined table instead of standalone. The amended query now correctly handles the relational structure between awards, coaches, and teams to return the proper division ID for the 1976 season."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT division FROM teams WHERE coach = (SELECT winner FROM awards WHERE award_name = 'NBA Coach of the Year' AND year = 1977) AND year = 1976;",
            "SELECT DISTINCT T3.divID\nFROM awards_coaches AS T1\nINNER JOIN coaches AS T2 ON T1.coachID = T2.coachID\nINNER JOIN teams AS T3 ON T2.tmID = T3.tmID\nWHERE T1.year = 1977\nAND T1.award = 'NBA Coach of the Year'\nAND T3.year = 1976"
        ],
        "rule_sql": []
    },
    "2742": {
        "db_id": "european_football_1",
        "question": "Of all the teams that played as a team away against Caen in the 2010 season, which one has the highest winning percentage?",
        "ground_truth": "SELECT AwayTeam FROM matchs WHERE HomeTeam = 'Caen' AND season = 2010 AND FTR = 'A' GROUP BY AwayTeam ORDER BY COUNT(AwayTeam) DESC LIMIT 1",
        "amends": [
            "Do select only `AwayTeam` instead of multiple columns including `away_team`, `total_games`, `wins`, and `winning_percentage`. Do use table `matchs` instead of `matches`. Do add filter `FTR = 'A'` instead of calculating wins through conditional logic comparing `away_score > home_score`. Do remove the aggregate calculations and percentage computation instead of including them. Do change the GROUP BY to simply `AwayTeam` instead of grouping by `away_team` with multiple aggregates. Do order by `COUNT(AwayTeam) DESC` instead of ordering by `winning_percentage DESC`. The amended query now correctly identifies away teams that won against Caen in 2010 by using the pre-computed FTR (Full Time Result) field instead of manually calculating win conditions, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    away_team,\n    COUNT(*) as total_games,\n    SUM(CASE WHEN away_score > home_score THEN 1 ELSE 0 END) as wins,\n    (SUM(CASE WHEN away_score > home_score THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) as winning_percentage\nFROM matches\nWHERE home_team = 'Caen' \nAND season = 2010\nGROUP BY away_team\nORDER BY winning_percentage DESC\nLIMIT 1;",
            "SELECT AwayTeam FROM matchs WHERE HomeTeam = 'Caen' AND season = 2010 AND FTR = 'A' GROUP BY AwayTeam ORDER BY COUNT(AwayTeam) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3961": {
        "db_id": "public_review_platform",
        "question": "For the Yelp businesses which received a \"5\" star review with \"uber\" number of votes for funny, which one is located in \"Phoenix\"? Give the business ID.",
        "ground_truth": "SELECT T1.business_id FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'Phoenix' AND T2.review_stars = 5 AND T2.review_votes_funny = 'Uber'",
        "amends": [
            "Do join `Business AS T1` with `Reviews AS T2` on `T1.business_id = T2.business_id` instead of querying only the `businesses` table. Do reference `T1.city` instead of just `city` for the Phoenix filter. Do use `T2.review_stars = 5` instead of `stars = 5` to access the review rating from the correct table. Do use `T2.review_votes_funny = 'Uber'` instead of `funny = 'uber'` with proper case sensitivity and the correct column name from the Reviews table. The amended query now correctly joins business and review data to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE city = 'Phoenix' AND stars = 5 AND funny = 'uber';",
            "SELECT T1.business_id\nFROM Business AS T1\nJOIN Reviews AS T2 ON T1.business_id = T2.business_id\nWHERE T1.city = 'Phoenix'\nAND T2.review_stars = 5\nAND T2.review_votes_funny = 'Uber';"
        ],
        "rule_sql": []
    },
    "2008": {
        "db_id": "soccer_2016",
        "question": "List the names of players who play by the left hand.",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id WHERE T2.Batting_hand = 'Left-hand bat'",
        "amends": [
            "Do select `T1.Player_Name` instead of `name` and do use a proper join structure instead of a single table query. Do add `INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id` instead of querying only the players table. Do filter on `T2.Batting_hand = 'Left-hand bat'` instead of `hand = 'right'` to correctly identify left-handed batters through the joined batting style table. The amended query now properly joins the necessary tables and filters for the correct batting hand specification, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE hand = 'right';",
            "SELECT T1.Player_Name \nFROM Player AS T1 \nINNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id \nWHERE T2.Batting_hand = 'Left-hand bat'"
        ],
        "rule_sql": []
    },
    "446": {
        "db_id": "movies_4",
        "question": "How many movies did Universal Studios release?",
        "ground_truth": "SELECT COUNT(T2.movie_id) FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id WHERE T1.company_name = 'Universal Studios'",
        "amends": [
            "Do reference the `production_company` table as `T1` and `movie_company` table as `T2` instead of querying only the `movies` table. Do use `INNER JOIN` between `T1` and `T2` on `T1.company_id = T2.company_id` instead of no join condition. Do filter on `T1.company_name = 'Universal Studios'` instead of `studio = 'Universal'`. Do count `T2.movie_id` instead of using `COUNT(*)`. The amended query now correctly counts movies by joining through the proper company relationship tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE studio = 'Universal'",
            "SELECT COUNT(T2.movie_id) \nFROM production_company T1 \nINNER JOIN movie_company T2 ON T1.company_id = T2.company_id \nWHERE T1.company_name = 'Universal Studios'"
        ],
        "rule_sql": []
    },
    "2560": {
        "db_id": "app_store",
        "question": "What genre does Honkai Impact 3rd belong to?",
        "ground_truth": "SELECT DISTINCT Genres FROM playstore WHERE App = 'Honkai Impact 3rd'",
        "amends": [
            "Do select `DISTINCT Genres` from the `playstore` table instead of `genre` from the `games` table. Do filter on `App = 'Honkai Impact 3rd'` instead of `title = 'Honkai Impact 3rd'`. The amended query now correctly retrieves distinct genre information from the appropriate table with the proper column names and filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE title = 'Honkai Impact 3rd';",
            "SELECT DISTINCT Genres FROM playstore WHERE App = 'Honkai Impact 3rd';"
        ],
        "rule_sql": []
    },
    "6797": {
        "db_id": "retails",
        "question": "Calculate the average profit of prom brushed steel products.",
        "ground_truth": "SELECT SUM(T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity) / COUNT(T1.ps_partkey) FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T3.p_type = 'PROMO BRUSHED STEEL'",
        "amends": [
            "Do use `SUM(T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity) / COUNT(T1.ps_partkey)` instead of `AVG(price)` for calculating the average net profit per part. Do join `partsupp AS T1`, `lineitem AS T2`, and `part AS T3` with `INNER JOIN` conditions `T1.ps_suppkey = T2.l_suppkey` and `T1.ps_partkey = T3.p_partkey` instead of querying only the `products` table. Do filter on `T3.p_type = 'PROMO BRUSHED STEEL'` instead of `product_name LIKE '%prom brushed steel%'` for exact type matching. The amended query now correctly calculates the average profit margin for promotional brushed steel parts by joining the necessary tables and using the proper financial calculation.",
            "Do remove the `AND T1.ps_partkey = T2.l_partkey` condition from the `INNER JOIN` between `partsupp` and `lineitem` instead of including it, as the join should only be on the supplier key. Do keep the same `SELECT` list calculation and aliases, maintain the same `FROM` sources and join types, preserve the identical `WHERE` filter on `p_type`, and retain the same aggregate functions without changes to `GROUP BY` or `HAVING` clauses. The amended query now correctly calculates average profit by joining only on supplier keys rather than both supplier and part keys, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE product_name LIKE '%prom brushed steel%';",
            "SELECT SUM(T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity) / COUNT(T1.ps_partkey) AS avg_profit\nFROM partsupp AS T1\nINNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey AND T1.ps_partkey = T2.l_partkey\nINNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey\nWHERE T3.p_type = 'PROMO BRUSHED STEEL';",
            "SELECT SUM(T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity) / COUNT(T1.ps_partkey) AS avg_profit\nFROM partsupp AS T1\nINNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey\nINNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey\nWHERE T3.p_type = 'PROMO BRUSHED STEEL'"
        ],
        "rule_sql": []
    },
    "7814": {
        "db_id": "hockey",
        "question": "In 2010, how many loses made by team 'BOS' and how many assists were made by the players?",
        "ground_truth": "SELECT SUM(T1.L), SUM(T2.A) FROM Teams AS T1 INNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.tmID = 'BOS' AND T1.year = 2010",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do join `Teams` and `Scoring` tables with `INNER JOIN` on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of querying only the `games` table. Do select `SUM(T1.L)` and `SUM(T2.A)` instead of `COUNT(*) AS loses` and `SUM(assists) AS total_assists`. Do filter on `T1.tmID = 'BOS' AND T1.year = 2010` instead of `year = 2010 AND team = 'BOS'`. The amended query now correctly aggregates loss and assist statistics from the joined Teams and Scoring tables for the specified team and year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS loses, SUM(assists) AS total_assists \nFROM games \nWHERE year = 2010 AND team = 'BOS'",
            "SELECT SUM(T1.L) AS total_losses, SUM(T2.A) AS total_assists\nFROM Teams AS T1\nINNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.tmID = 'BOS' AND T1.year = 2010"
        ],
        "rule_sql": []
    },
    "4091": {
        "db_id": "public_review_platform",
        "question": "For businesses with long length reviews, which state are they located?",
        "ground_truth": "SELECT DISTINCT T1.state FROM Business AS T1 INNER JOIN Tips AS T2 ON T1.business_id = T2.business_id WHERE T2.tip_length = 'Long'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the source table to `Business AS T1` instead of `businesses`. Do add `INNER JOIN Tips AS T2` instead of querying a single table. Do change the join condition to `ON T1.business_id = T2.business_id` instead of no join. Do change the filter to `WHERE T2.tip_length = 'Long'` instead of `WHERE review_length > 1000`. Do remove `ORDER BY review_length DESC` instead of keeping it. Do remove `LIMIT 10` instead of keeping it. The amended query now correctly retrieves distinct states from businesses with long tips instead of states from businesses with long reviews."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM businesses WHERE review_length > 1000 ORDER BY review_length DESC LIMIT 10;",
            "SELECT DISTINCT T1.state FROM Business AS T1 INNER JOIN Tips AS T2 ON T1.business_id = T2.business_id WHERE T2.tip_length = 'Long'"
        ],
        "rule_sql": []
    },
    "406": {
        "db_id": "retail_complains",
        "question": "List the product and its issues of the complains of clients with age greater than the 60% of average age of all clients.",
        "ground_truth": "SELECT DISTINCT T2.Product, T2.Issue FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.age * 100 > ( SELECT AVG(age) * 60 FROM client )",
        "amends": [
            "Do use `DISTINCT` instead of `GROUP BY` for deduplication. Do select `T2.Product` and `T2.Issue` instead of `p.product_name` and `i.issue_description`. Do use `client AS T1` instead of `clients cl` as the main table. Do use `INNER JOIN events AS T2` instead of multiple joins through `products`, `issues`, and `complaints`. Do join on `T1.client_id = T2.Client_ID` instead of the chain `p.product_id = i.product_id`, `i.issue_id = c.issue_id`, and `c.client_id = cl.client_id`. Do move the filter to `WHERE T1.age * 100 >` instead of `WHERE cl.age >` with a different multiplier. Do use `(SELECT AVG(age) * 60 FROM client)` instead of `(SELECT AVG(age) * 0.6 FROM clients)` with a different table reference and multiplier. Do remove the `GROUP BY` clause instead of keeping it. The amended query now correctly filters clients based on age threshold and joins directly to events instead of through multiple intermediate tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name, i.issue_description \nFROM products p\nJOIN issues i ON p.product_id = i.product_id\nJOIN complaints c ON i.issue_id = c.issue_id\nJOIN clients cl ON c.client_id = cl.client_id\nWHERE cl.age > (SELECT AVG(age) * 0.6 FROM clients)\nGROUP BY p.product_name, i.issue_description;",
            "SELECT DISTINCT T2.Product, T2.Issue\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.age * 100 > (SELECT AVG(age) * 60 FROM client)"
        ],
        "rule_sql": []
    },
    "6943": {
        "db_id": "ice_hockey_draft",
        "question": "Name the player who scored the most goals in a single game in the 2007-2008 season of WHL?",
        "ground_truth": "SELECT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '2007-2008' AND T1.LEAGUE = 'WHL' ORDER BY T1.G DESC LIMIT 1",
        "amends": [
            "Do select `T2.PlayerName` instead of `player_name` and `MAX(goals)`. Do use `FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID` instead of `FROM game_stats` with a simple table reference. Do apply filters `T1.SEASON = '2007-2008' AND T1.LEAGUE = 'WHL'` to the joined table instead of the original table. Do remove `GROUP BY player_name` and aggregate function since the maximum goal value is now directly accessed from `T1.G`. Do order by `T1.G DESC` instead of the alias `most_goals DESC`. The amended query now correctly retrieves the player with the highest goals by joining season statistics with player information and ordering by the goal column directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, MAX(goals) as most_goals \nFROM game_stats \nWHERE season = '2007-2008' AND league = 'WHL' \nGROUP BY player_name \nORDER BY most_goals DESC \nLIMIT 1;",
            "SELECT T2.PlayerName\nFROM SeasonStatus AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE T1.SEASON = '2007-2008' AND T1.LEAGUE = 'WHL'\nORDER BY T1.G DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4981": {
        "db_id": "olympics",
        "question": "What is the ratio male to female athletes in the 2012 Summer Olympic?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'M' THEN 1 ELSE NULL END) AS REAL) / COUNT(CASE WHEN T3.gender = 'F' THEN 1 ELSE NULL END) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '2012 Summer'",
        "amends": [
            "Do use `CAST(... AS REAL)` for division instead of integer division. Do reference `T3.gender` with table aliases instead of bare column names. Do use gender values `'M'` and `'F'` instead of `'Male'` and `'Female'`. Do add `ELSE NULL` in CASE expressions instead of omitting explicit ELSE clauses. Do join tables `games`, `games_competitor`, and `person` instead of querying a single table. Do use `INNER JOIN` on `T1.id = T2.games_id` and `T2.person_id = T3.id` instead of no joins. Do filter on `T1.games_name = '2012 Summer'` instead of separate `year = 2012 AND season = 'Summer'` conditions. Do remove the alias `male_to_female_ratio` instead of keeping it. The amended query now correctly calculates the ratio using proper table relationships and gender encoding."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(CASE WHEN gender = 'Male' THEN 1 END) / COUNT(CASE WHEN gender = 'Female' THEN 1 END) AS male_to_female_ratio\nFROM athletes\nWHERE year = 2012 AND season = 'Summer';",
            "SELECT \n    CAST(SUM(CASE WHEN T3.gender = 'M' THEN 1 ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN T3.gender = 'F' THEN 1 ELSE 0 END) AS REAL) \nFROM \n    games T1\nINNER JOIN \n    games_competitor T2 ON T1.id = T2.games_id\nINNER JOIN \n    person T3 ON T2.person_id = T3.id\nWHERE \n    T1.games_name = '2012 Summer'"
        ],
        "rule_sql": []
    },
    "1543": {
        "db_id": "synthea",
        "question": "What is the difference between the number of married patients and the number of single patients with diabetes?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.marital = 'M' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.marital = 'S' THEN 1 ELSE 0 END) FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Diabetes'",
        "amends": [
            "Do use `SUM(CASE)` conditional aggregation instead of separate subqueries. Do join `conditions AS T1` and `patients AS T2` with `INNER JOIN` on `T1.PATIENT = T2.patient` instead of querying only the patients table. Do filter with `WHERE T1.DESCRIPTION = 'Diabetes'` instead of filtering on `diabetes = 1`. Do reference marital status codes `'M'` and `'S'` instead of full values `'Married'` and `'Single'`. Do calculate the difference directly in the main query instead of using subtraction between subquery results. The amended query now correctly filters for diabetes conditions and calculates the marital status difference in a single efficient operation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM patients WHERE marital_status = 'Married' AND diabetes = 1) - \n    (SELECT COUNT(*) FROM patients WHERE marital_status = 'Single' AND diabetes = 1) AS difference;",
            "SELECT \n    SUM(CASE WHEN T2.marital = 'M' THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN T2.marital = 'S' THEN 1 ELSE 0 END) AS marital_difference\nFROM conditions AS T1\nINNER JOIN patients AS T2 ON T1.PATIENT = T2.patient\nWHERE T1.DESCRIPTION = 'Diabetes'"
        ],
        "rule_sql": []
    },
    "5041": {
        "db_id": "olympics",
        "question": "What is the average age of the people who participated in the winter season?",
        "ground_truth": "SELECT AVG(T2.age) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Winter'",
        "amends": [
            "Do add `games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id` as the FROM source instead of querying only `participants`. Do reference `T2.age` in the AVG function instead of just `age`. Do filter on `T1.season = 'Winter'` with proper table qualification instead of `season = 'winter'`. Do use proper case `'Winter'` instead of lowercase `'winter'` for the season filter. The amended query now correctly joins the games and games_competitor tables to calculate average age for winter season participants."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM participants WHERE season = 'winter';",
            "SELECT AVG(T2.age) AS average_age FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Winter'"
        ],
        "rule_sql": []
    },
    "4546": {
        "db_id": "student_loan",
        "question": "What is the school and gender of student34?",
        "ground_truth": "SELECT T1.school , IIF(T3.name IS NULL, 'female', 'male') AS gender FROM enrolled AS T1 INNER JOIN person AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE T2.name = 'student34'",
        "amends": [
            "Do select `T1.school` and a conditional expression `IIF(T3.name IS NULL, 'female', 'male') AS gender` instead of directly selecting `school` and `gender` columns. Do use `FROM enrolled AS T1` with `INNER JOIN person AS T2 ON T1.name = T2.name` and `LEFT JOIN male AS T3 ON T2.name = T3.name` instead of querying only the `students` table. Do filter on `T2.name = 'student34'` instead of filtering on `student_id = 'student34'`. The amended query now correctly joins multiple tables to determine gender through conditional logic based on the presence in the male table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school, gender FROM students WHERE student_id = 'student34';",
            "SELECT T1.school, IIF(T3.name IS NULL, 'female', 'male') AS gender\nFROM enrolled AS T1\nINNER JOIN person AS T2 ON T1.name = T2.name\nLEFT JOIN male AS T3 ON T2.name = T3.name\nWHERE T2.name = 'student34'"
        ],
        "rule_sql": []
    },
    "5219": {
        "db_id": "address",
        "question": "Provide the zip codes and coordinates of the postal points under Allentown-Bethlehem-Easton, PA-NJ.",
        "ground_truth": "SELECT T2.zip_code, T2.latitude, T2.longitude FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'Allentown-Bethlehem-Easton, PA-NJ'",
        "amends": [
            "Do select `T2.zip_code`, `T2.latitude`, and `T2.longitude` instead of `zip_code` and `coordinates`. Do use `FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA` instead of `FROM postal_points`. Do filter on `T1.CBSA_name = 'Allentown-Bethlehem-Easton, PA-NJ'` instead of `city = 'Allentown-Bethlehem-Easton' AND state = 'PA-NJ'`. The amended query now correctly joins the CBSA and zip_data tables to retrieve accurate geographic coordinates for the specified metropolitan area."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, coordinates FROM postal_points WHERE city = 'Allentown-Bethlehem-Easton' AND state = 'PA-NJ';",
            "SELECT T2.zip_code, T2.latitude, T2.longitude\nFROM CBSA AS T1\nINNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA\nWHERE T1.CBSA_name = 'Allentown-Bethlehem-Easton, PA-NJ'"
        ],
        "rule_sql": []
    },
    "4980": {
        "db_id": "olympics",
        "question": "What is the percentage of female athletes below 20s who participated in the 2002 Winter Olympic?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'F' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.person_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '2002 Winter' AND T2.age < 20",
        "amends": [
            "Do use explicit table aliases `T3.gender` and `T2.person_id` instead of unqualified column references. Do add proper table joins with `INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id` and `INNER JOIN person AS T3 ON T2.person_id = T3.id` instead of querying a single table. Do change the filter condition to `T1.games_name = '2002 Winter'` instead of separate `olympic_year` and `olympic_season` columns. Do move the age filter `T2.age < 20` to the WHERE clause instead of including it in the CASE condition. Do simplify the CASE expression to `CASE WHEN T3.gender = 'F' THEN 1 ELSE NULL END` instead of combining gender and age conditions. Do add explicit `CAST` to `REAL` instead of using decimal notation. Do count `T2.person_id` instead of `COUNT(*)` to avoid counting NULL values. The amended query now correctly calculates the percentage of female competitors under age 20 in the 2002 Winter Olympics using proper table relationships.",
            "Do place the multiplication by 100 after the division instead of before it, changing `COUNT(...) / COUNT(...) * 100` to `COUNT(...) * 100 / COUNT(...)` to correctly calculate the percentage by first multiplying the numerator count before dividing by the denominator count, which ensures proper percentage computation where the female count is scaled before division rather than the division result being scaled. The amended query now matches RIGHT_SQL's behavior with the corrected mathematical operation order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'F' AND age < 20 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM athletes\nWHERE olympic_year = 2002 AND olympic_season = 'Winter';",
            "SELECT \n    CAST(COUNT(CASE WHEN T3.gender = 'F' THEN 1 ELSE NULL END) AS REAL) / COUNT(T2.person_id) * 100 AS percentage\nFROM \n    games AS T1\n    INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id\n    INNER JOIN person AS T3 ON T2.person_id = T3.id\nWHERE \n    T1.games_name = '2002 Winter'\n    AND T2.age < 20",
            "SELECT \n    COUNT(CASE WHEN T3.gender = 'F' THEN 1 ELSE NULL END) * 100.0 / COUNT(T2.person_id) AS percentage\nFROM \n    games AS T1\nINNER JOIN \n    games_competitor AS T2 ON T1.id = T2.games_id\nINNER JOIN \n    person AS T3 ON T2.person_id = T3.id\nWHERE \n    T1.games_name = '2002 Winter'\n    AND T2.age < 20"
        ],
        "rule_sql": []
    },
    "1331": {
        "db_id": "law_episode",
        "question": "How many people from Canada are nominated for an award?",
        "ground_truth": "SELECT COUNT(T1.person_id) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T1.birth_country = 'Canada'",
        "amends": [
            "Do select `COUNT(T1.person_id)` instead of `COUNT(*)` to count specific person IDs rather than all rows. Do use `Person AS T1` and `Award AS T2` tables instead of a single `people` table, adding an `INNER JOIN` on `T1.person_id = T2.person_id` instead of filtering by `award_nominated = 1`. Do filter by `T1.birth_country = 'Canada'` instead of `country = 'Canada'` to use the correct column name. Do remove the direct boolean filter `award_nominated = 1` and instead join with the Award table to properly identify nominated individuals through table relationships. The amended query now correctly counts Canadian-born people who have award nominations by leveraging proper table joins instead of relying on a potentially incorrect boolean flag column.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the join condition already ensures unique person_id values from the Person table when counting awards. The amended query now matches RIGHT_SQL's behavior by counting all award instances for Canadian-born persons rather than distinct persons with awards."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE country = 'Canada' AND award_nominated = 1;",
            "SELECT COUNT(DISTINCT T1.person_id) \nFROM Person AS T1 \nINNER JOIN Award AS T2 ON T1.person_id = T2.person_id \nWHERE T1.birth_country = 'Canada'",
            "SELECT COUNT(T1.person_id) \nFROM Person AS T1 \nINNER JOIN Award AS T2 ON T1.person_id = T2.person_id \nWHERE T1.birth_country = 'Canada'"
        ],
        "rule_sql": []
    },
    "7249": {
        "db_id": "works_cycles",
        "question": "When did the company hired its first Accountant?",
        "ground_truth": "SELECT MIN(HireDate) FROM Employee WHERE JobTitle = 'Accountant'",
        "amends": [
            "Do reference `HireDate` instead of `hire_date` in the SELECT clause. Do reference `Employee` instead of `employees` in the FROM clause. Do reference `JobTitle` instead of `job_title` in the WHERE filter. The amended query now correctly matches the RIGHT_SQL's behavior with proper column and table names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(hire_date) FROM employees WHERE job_title = 'Accountant';",
            "SELECT HireDate FROM Employee WHERE JobTitle = 'Accountant' ORDER BY HireDate ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5519": {
        "db_id": "menu",
        "question": "List down name of dishes from menu with menu page ID 1389.",
        "ground_truth": "SELECT T2.name FROM MenuItem AS T1 INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE T1.menu_page_id = 1389",
        "amends": [
            "Do select `T2.name` from the `Dish` table instead of `name` from the `menu` table. Do join `MenuItem AS T1` with `Dish AS T2` using `INNER JOIN` on `T2.id = T1.dish_id` instead of querying only the `menu` table. Do filter on `T1.menu_page_id = 1389` instead of `menu_page_id = 1389` to reference the correct table. The amended query now correctly retrieves dish names by joining through the MenuItem relationship rather than directly from a non-existent menu table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM menu WHERE menu_page_id = 1389;",
            "SELECT T2.name \nFROM MenuItem AS T1\nINNER JOIN Dish AS T2 ON T2.id = T1.dish_id\nWHERE T1.menu_page_id = 1389"
        ],
        "rule_sql": []
    },
    "28": {
        "db_id": "movie_platform",
        "question": "How many movies were added to the list with the most number of movies? Indicate whether the user was a paying subscriber or not when he created the list.",
        "ground_truth": "SELECT T1.list_movie_number, T2.user_has_payment_method FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id ORDER BY T1.list_movie_number DESC LIMIT 1",
        "amends": [
            "Do select `list_movie_number` and `user_has_payment_method` instead of `COUNT(*) AS movie_count` and a CASE expression for subscription status. Do join `lists` with `lists_users` on `list_id` instead of joining `movies` with `users` on `user_id`. Do remove the GROUP BY clause instead of grouping by `user_id`. Do order by `list_movie_number DESC` instead of ordering by the aggregated `movie_count DESC`. Do maintain the `LIMIT 1` clause to return only the top result. The amended query now correctly retrieves the list with the highest movie count along with its associated user payment status, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS movie_count, \n       CASE WHEN u.subscription_status = 'paid' THEN 'paying subscriber' ELSE 'non-paying subscriber' END AS subscriber_status\nFROM movies m\nJOIN users u ON m.user_id = u.user_id\nGROUP BY u.user_id\nORDER BY movie_count DESC\nLIMIT 1;",
            "SELECT l.list_movie_number, lu.user_has_payment_method\nFROM lists l\nJOIN lists_users lu ON l.list_id = lu.list_id\nORDER BY l.list_movie_number DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8546": {
        "db_id": "software_company",
        "question": "Among the customers with a marital status of married-civ-spouse, list the number of inhabitants and age of those who are machine-op-inspct.",
        "ground_truth": "SELECT T2.INHABITANTS_K FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T1.OCCUPATION = 'Farming-fishing' AND T1.SEX = 'Male' AND T1.age >= 20 AND T1.age <= 30",
        "amends": [
            "Do select `T2.INHABITANTS_K` instead of `COUNT(*) as number_of_inhabitants, age`. Do use `INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID` instead of no join. Do change the table alias to `T1` instead of no alias. Do add filters `T1.OCCUPATION = 'Farming-fishing'`, `T1.SEX = 'Male'`, and `T1.age >= 20 AND T1.age <= 30` instead of `marital_status = 'married-civ-spouse' AND occupation = 'machine-op-inspct'`. Do remove the `age` column from the SELECT list instead of including it. The amended query now correctly joins demographic data and filters for specific occupation, gender, and age range instead of counting married machine operators."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as number_of_inhabitants, age FROM customers WHERE marital_status = 'married-civ-spouse' AND occupation = 'machine-op-inspct'",
            "SELECT T2.INHABITANTS_K\nFROM Customers AS T1\nINNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID\nWHERE T1.OCCUPATION = 'Farming-fishing'\nAND T1.SEX = 'Male'\nAND T1.age >= 20 AND T1.age <= 30"
        ],
        "rule_sql": []
    },
    "5457": {
        "db_id": "sales",
        "question": "How many chainring bolts were sold under sales ID 551971?",
        "ground_truth": "SELECT T1.Quantity FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'Chainring Bolts' AND T1.SalesID = 551971",
        "amends": [
            "Do join `Sales` with `Products` on `T1.ProductID = T2.ProductID` instead of querying only the `sales` table. Do filter on `T2.Name = 'Chainring Bolts'` instead of `product_name = 'chainring bolts'` to use the correct table and column name. Do select `T1.Quantity` instead of `COUNT(*)` to return the actual quantity value rather than a count. Do use proper table aliases `T1` and `T2` instead of no aliases. Do maintain the filter `T1.SalesID = 551971` instead of `sales_id = 551971` with the correct column reference. The amended query now correctly joins the tables and returns the specific quantity value for the matching sales record."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE sales_id = 551971 AND product_name = 'chainring bolts';",
            "SELECT T1.Quantity \nFROM Sales T1\nJOIN Products T2 ON T1.ProductID = T2.ProductID\nWHERE T1.SalesID = 551971 \nAND T2.Name = 'Chainring Bolts'"
        ],
        "rule_sql": []
    },
    "8932": {
        "db_id": "human_resources",
        "question": "How many emplyees have a good job performance?",
        "ground_truth": "SELECT COUNT(*) FROM employee WHERE performance = 'Good'",
        "amends": [
            "Do reference table `employee` instead of `employees` in the FROM clause. Do filter on column `performance` with value `'Good'` instead of `job_performance` with value `'good'` in the WHERE clause. The amended query now correctly counts records from the employee table where performance equals 'Good', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_performance = 'good';",
            "SELECT COUNT(*) FROM employee WHERE performance = 'Good';"
        ],
        "rule_sql": []
    },
    "4864": {
        "db_id": "legislator",
        "question": "Based on the number of current legislators, calculate the percentage of legislators that served in 21st-Century.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN strftime('%Y', T2.start) BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bioguide_id) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN strftime('%Y', T2.start) BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bioguide_id)` instead of `COUNT(*) * 100 / (SELECT COUNT(*) FROM legislators)` for the percentage calculation. Do join `current AS T1 INNER JOIN current-terms AS T2 ON T1.bioguide_id = T2.bioguide_id` instead of querying only the `legislators` table. Do filter with `strftime('%Y', T2.start) BETWEEN '2000' AND '2017'` in the CASE expression instead of `WHERE end_year >= 2000`. Do count `T1.bioguide_id` instead of using a subquery for total count. The amended query now correctly calculates the percentage of legislators with terms starting between 2000 and 2017 relative to all current legislators.",
            "Do use backticks for the table name `current-terms` instead of double quotes. Do ensure the join condition `T1.bioguide_id = T2.bioguide_id` is complete instead of truncating it to `T1.bioguide_id = T2.bioguide`. Do remove the alias `percentage` from the SELECT expression instead of keeping it. The amended query now correctly calculates the percentage of terms starting between 2000 and 2017 relative to all current members.",
            "Do use `T2.bioguide` instead of `T2.bioguide_id` in the `INNER JOIN` ON predicate to ensure proper table joining. The amended query now correctly matches the RIGHT_SQL's behavior with the appropriate join condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM legislators) AS percentage FROM legislators WHERE end_year >= 2000;",
            "SELECT \n    CAST(SUM(CASE WHEN strftime('%Y', T2.start) BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bioguide_id) AS percentage\nFROM \n    current AS T1 \nINNER JOIN \n    \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide_id",
            "SELECT CAST(SUM(CASE WHEN strftime('%Y', T2.start) BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bioguide_id) \nFROM current AS T1 \nINNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide_id",
            "SELECT CAST(SUM(CASE WHEN strftime('%Y', T2.start) BETWEEN '2000' AND '2017' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bioguide_id) \nFROM current AS T1 \nINNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide"
        ],
        "rule_sql": []
    },
    "4716": {
        "db_id": "disney",
        "question": "The main character Elsa is voiced by which actor and who is the director of the movie?",
        "ground_truth": "SELECT T1.`voice-actor`, T3.director FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T1.movie = T2.movie_title INNER JOIN director AS T3 ON T2.movie_title = T3.name WHERE T2.hero = 'Elsa'",
        "amends": [
            "Do select `voice-actor` and `director` instead of `actor.name` and `director.name`. Do use `voice-actors` AS T1, `characters` AS T2, and `director` AS T3 instead of `movies`, `actors`, and `directors`. Do perform `INNER JOIN` between `voice-actors` and `characters` on `movie = movie_title` instead of joining `movies` with `actors` on `movies.id = actors.movie_id`. Do perform another `INNER JOIN` between `characters` and `director` on `movie_title = name` instead of joining `movies` with `directors` on `movies.id = directors.movie_id`. Do filter on `hero = 'Elsa'` instead of `movies.title = 'Frozen' AND characters.name = 'Elsa'`. The amended query now correctly retrieves voice actors and directors for the character Elsa using the proper table relationships and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor.name, director.name \nFROM movies \nJOIN actors ON movies.id = actors.movie_id \nJOIN directors ON movies.id = directors.movie_id \nWHERE movies.title = 'Frozen' AND characters.name = 'Elsa'",
            "SELECT T1.\"voice-actor\", T3.director\nFROM \"voice-actors\" AS T1\nINNER JOIN characters AS T2 ON T1.movie = T2.movie_title\nINNER JOIN director AS T3 ON T2.movie_title = T3.name\nWHERE T2.hero = 'Elsa'"
        ],
        "rule_sql": []
    },
    "226": {
        "db_id": "book_publishing_company",
        "question": "Which city did Victoria P Ashworth work in?",
        "ground_truth": "SELECT T2.city FROM employee AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE T1.fname = 'Victoria' AND T1.minit = 'P' AND T1.lname = 'Ashworth'",
        "amends": [
            "Do select `T2.city` from the `publishers` table instead of `city` from the `employees` table. Do join `employee AS T1` with `publishers AS T2` using `T1.pub_id = T2.pub_id` instead of querying only the `employees` table. Do filter on `T1.fname = 'Victoria'` and `T1.lname = 'Ashworth'` instead of `first_name` and `last_name`, and do add the additional filter `T1.minit = 'P'` instead of omitting it. The amended query now correctly retrieves the city from the publishers table by joining with employee data using the publication ID relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM employees WHERE first_name = 'Victoria' AND last_name = 'Ashworth';",
            "SELECT T2.city FROM employee AS T1 JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE T1.fname = 'Victoria' AND T1.lname = 'Ashworth' AND T1.minit = 'P'"
        ],
        "rule_sql": []
    },
    "3710": {
        "db_id": "college_completion",
        "question": "What's the average number of graduates for Central Alabama Community College in the 3 consecutive years from 2011 to 2013?",
        "ground_truth": "SELECT AVG(T2.grad_cohort) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.chronname = 'Central Alabama Community College' AND T2.year IN (2011, 2012, 2013) AND T2.gender = 'B' AND T2.race = 'X'",
        "amends": [
            "Do select `AVG(T2.grad_cohort)` from the `institution_grads` table instead of `AVG(graduates)` from a single table. Do join `institution_details AS T1` and `institution_grads AS T2` with an `INNER JOIN` on `T2.unitid = T1.unitid` instead of querying a single `college_data` table. Do filter by `T1.chronname = 'Central Alabama Community College'` instead of `college_name`. Do use `T2.year IN (2011, 2012, 2013)` for specific year values instead of `year BETWEEN 2011 AND 2013`. Do add filters for `T2.gender = 'B'` and `T2.race = 'X'` instead of omitting these demographic criteria. The amended query now correctly joins institutional data with graduation metrics and applies the necessary demographic filters to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(graduates) FROM college_data WHERE college_name = 'Central Alabama Community College' AND year BETWEEN 2011 AND 2013;",
            "SELECT AVG(T2.grad_cohort) \nFROM institution_details AS T1\nINNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid\nWHERE T1.chronname = 'Central Alabama Community College'\nAND T2.year IN (2011, 2012, 2013)\nAND T2.gender = 'B'\nAND T2.race = 'X'"
        ],
        "rule_sql": []
    },
    "5098": {
        "db_id": "address",
        "question": "How many counties are there in Alabama?",
        "ground_truth": "SELECT COUNT(T2.county) FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE T1.name = 'Alabama'",
        "amends": [
            "Do select `COUNT(T2.county)` instead of `COUNT(*)` to count specific county records rather than all rows. Do use `state AS T1 INNER JOIN country AS T2` instead of querying only the `states` table to properly join the state and country tables. Do specify the join condition `ON T1.abbreviation = T2.state` instead of no join condition to correctly relate states to their counties. Do filter on `T1.name = 'Alabama'` instead of `state_name = 'Alabama'` to use the correct column name from the joined table structure. The amended query now correctly counts counties in Alabama by joining state and country tables with proper relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM states WHERE state_name = 'Alabama';",
            "SELECT COUNT(T2.county) FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE T1.name = 'Alabama'"
        ],
        "rule_sql": []
    },
    "2264": {
        "db_id": "movielens",
        "question": "How many female actors acted in the movies of year 4?",
        "ground_truth": "SELECT COUNT(T2.actorid) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T3.a_gender = 'F' AND T1.year = 4",
        "amends": [
            "Do join `movies AS T1` and `movies2actors AS T2` on `T1.movieid = T2.movieid` instead of querying only the `actors` table. Do join `actors AS T3` on `T2.actorid = T3.actorid` instead of missing the necessary table relationships. Do filter on `T3.a_gender = 'F'` instead of `gender = 'female'` to use the correct column name and value format. Do filter on `T1.year = 4` instead of `year = 4` to reference the correct table's year column. Do count `T2.actorid` instead of `COUNT(*)` to count specific actor IDs from the join result. The amended query now correctly counts female actors from movies released in year 4 by properly joining the three required tables with accurate column references.",
            "Do remove `DISTINCT` from `COUNT` instead of keeping it, as the count should include all matching rows rather than unique values. Do maintain the same `INNER JOIN` structure on `T1.movieid = T2.movieid` and `T2.actorid = T3.actorid` without changing join conditions. Do keep the `WHERE` filters `T3.a_gender = 'F'` and `T1.year = 4` in the same logical conjunction. The amended query now correctly counts all female actors from movies released in year 4, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors WHERE gender = 'female' AND year = 4;",
            "SELECT COUNT(DISTINCT T2.actorid) \nFROM movies AS T1 \nJOIN movies2actors AS T2 ON T1.movieid = T2.movieid \nJOIN actors AS T3 ON T2.actorid = T3.actorid \nWHERE T1.year = 4 AND T3.a_gender = 'F'",
            "SELECT COUNT(T2.actorid) \nFROM movies AS T1 \nINNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid \nINNER JOIN actors AS T3 ON T2.actorid = T3.actorid \nWHERE T3.a_gender = 'F' AND T1.year = 4"
        ],
        "rule_sql": []
    },
    "2971": {
        "db_id": "shakespeare",
        "question": "Which chapter has the most paragraphs? Give the description of the chapter.",
        "ground_truth": "SELECT T1.Description FROM chapters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.chapter_id ORDER BY T2.ParagraphNum DESC LIMIT 1",
        "amends": [
            "Do select `T1.Description` instead of `chapter_id, description, COUNT(*) as paragraph_count`. Do use `FROM chapters AS T1 INNER JOIN paragraphs AS T2` instead of `FROM chapters` alone. Do add join condition `ON T1.id = T2.chapter_id` instead of omitting the join entirely. Do remove `GROUP BY chapter_id` and the aggregate function instead of keeping them. Do change ordering to `ORDER BY T2.ParagraphNum DESC` instead of `ORDER BY paragraph_count DESC`. The amended query now correctly joins chapters with paragraphs and orders by paragraph number instead of counting paragraphs, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT chapter_id, description, COUNT(*) as paragraph_count \nFROM chapters \nGROUP BY chapter_id \nORDER BY paragraph_count DESC \nLIMIT 1;",
            "SELECT T1.Description FROM chapters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.chapter_id ORDER BY T2.ParagraphNum DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3099": {
        "db_id": "cars",
        "question": "Among the cars with an engine displacement of no less than 400 cubic millimeter, how many cars cost at least 30,000?",
        "ground_truth": "SELECT COUNT(*) FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE T1.displacement > 400 AND T2.price > 30000",
        "amends": [
            "Do join `data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID` instead of querying only `cars` table. Do filter on `T1.displacement > 400` instead of `engine_displacement >= 400` to use greater than rather than greater than or equal. Do filter on `T2.price > 30000` instead of `price < 30000` to find prices above rather than below the threshold. The amended query now correctly joins the data and price tables and applies the proper filtering conditions to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE engine_displacement >= 400 AND price < 30000;",
            "SELECT COUNT(*) \nFROM data AS T1 \nINNER JOIN price AS T2 ON T1.ID = T2.ID \nWHERE T1.displacement > 400 \nAND T2.price > 30000"
        ],
        "rule_sql": []
    },
    "8176": {
        "db_id": "sales_in_weather",
        "question": "For the weather station has store no.9, what was the increased percentage of the average temperature from 2012/2/2 to 2012/2/3?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T1.`date` = '2012-02-03' THEN T1.tavg * 1 ELSE 0 END) - SUM(CASE WHEN T1.`date` = '2012-02-02' THEN T1.tavg * 1 ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN T1.`date` = '2012-02-02' THEN T1.tavg * 1 ELSE 0 END) FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T2.store_nbr = 9",
        "amends": [
            "Do use `SUM` with explicit `ELSE 0` instead of `AVG` with implicit NULL handling in the percentage calculation. Do reference `tavg` column instead of `temperature` for the temperature values. Do format dates as `'2012-02-02'` and `'2012-02-03'` with hyphens instead of `'2012/2/2'` and `'2012/2/3'` with slashes and missing leading zeros. Do add an `INNER JOIN` with `relation AS T2` on `T1.station_nbr = T2.station_nbr` instead of directly filtering by `store_no`. Do filter by `T2.store_nbr = 9` in the WHERE clause instead of `store_no = 9`. Do remove the `GROUP BY store_no` clause since the join and filter already ensure single-store results. Do use explicit `CAST` to `REAL` for the difference calculation instead of implicit casting. Do structure the percentage formula with multiplication before division instead of using parentheses around the entire expression. The amended query now correctly calculates temperature percentage increase by joining through station-store relations rather than assuming direct store filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    ((AVG(CASE WHEN date = '2012/2/3' THEN temperature END) - AVG(CASE WHEN date = '2012/2/2' THEN temperature END)) / AVG(CASE WHEN date = '2012/2/2' THEN temperature END)) * 100 AS increased_percentage\nFROM weather\nWHERE store_no = 9\nAND date IN ('2012/2/2', '2012/2/3')\nGROUP BY store_no",
            "SELECT \n    (CAST(SUM(CASE WHEN w.date = '2012-02-03' THEN w.tavg ELSE 0 END) - SUM(CASE WHEN w.date = '2012-02-02' THEN w.tavg ELSE 0 END) AS REAL) / \n     CAST(SUM(CASE WHEN w.date = '2012-02-02' THEN w.tavg ELSE 0 END) AS REAL)) * 100 AS percentage_increase\nFROM weather w\nINNER JOIN relation r ON w.station_nbr = r.station_nbr\nWHERE r.store_nbr = 9\nAND w.date IN ('2012-02-02', '2012-02-03')"
        ],
        "rule_sql": []
    },
    "6059": {
        "db_id": "books",
        "question": "Among all addresses provided by customers, identify the percentage that are not in use anymore.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.address_status = 'Inactive' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM customer_address AS T1 INNER JOIN address_status AS T2 ON T2.status_id = T1.status_id",
        "amends": [
            "Do use `SUM(CASE WHEN T2.address_status = 'Inactive' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN is_active = 0 THEN 1 END)` for counting inactive records. Do add `INNER JOIN address_status AS T2 ON T2.status_id = T1.status_id` instead of querying only the addresses table. Do change the table reference from `addresses` to `customer_address AS T1` instead of using the wrong table name. Do use `CAST(... AS REAL)` for floating-point division instead of implicit casting with `100.0`. Do reference `T2.address_status = 'Inactive'` instead of `is_active = 0` for status checking. The amended query now correctly joins the customer address table with address status and properly calculates the percentage of inactive addresses.",
            "Do place the multiplication by 100 before the division instead of after it, changing the calculation order to `* 100 / COUNT(*)` instead of `/ COUNT(*) * 100.0`. Do remove the alias `inactive_percentage` instead of keeping it. The amended query now correctly calculates the percentage by multiplying before dividing to maintain precision and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN is_active = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_inactive\nFROM addresses;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.address_status = 'Inactive' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100.0 AS inactive_percentage\nFROM \n    customer_address AS T1\nINNER JOIN \n    address_status AS T2 ON T2.status_id = T1.status_id",
            "SELECT CAST(SUM(CASE WHEN T2.address_status = 'Inactive' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(*) \nFROM customer_address AS T1 \nINNER JOIN address_status AS T2 ON T2.status_id = T1.status_id"
        ],
        "rule_sql": []
    },
    "551": {
        "db_id": "movies_4",
        "question": "Provide the production companies of the movie that has over 35% average running time per movie in 2016.",
        "ground_truth": "SELECT T.company_name FROM ( SELECT DISTINCT T3.company_name, T1.runtime FROM movie AS T1 INNER JOIN movie_company AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_company AS T3 ON T3.company_id = T2.company_id WHERE T1.release_date LIKE '2016%' ) T WHERE T.runtime * 100 > (0.35 * ( SELECT AVG(T1.runtime) FROM movie AS T1 INNER JOIN movie_company AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_company AS T3 ON T3.company_id = T2.company_id WHERE T1.release_date LIKE '2016%' ) + ( SELECT AVG(T1.runtime) FROM movie AS T1 INNER JOIN movie_company AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_company AS T3 ON T3.company_id = T2.company_id WHERE T1.release_date LIKE '2016%' )) * 100",
        "amends": [
            "Do select `T.company_name` from a derived table instead of directly selecting `production_company`. Do join `movie`, `movie_company`, and `production_company` tables with proper foreign key relationships instead of querying a single table. Do filter by `release_date LIKE '2016%'` instead of `year = 2016` to handle date formats. Do calculate runtime comparison using a complex subquery with `AVG` aggregates instead of a window function `COUNT(*) OVER ()`. Do use multiplication by 100 for percentage comparison instead of direct decimal comparison. Do remove the window function entirely and replace it with proper aggregate subqueries. The amended query now correctly identifies production companies where individual movie runtimes exceed a threshold based on average runtime statistics for 2016 releases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT production_company FROM movies WHERE year = 2016 AND (runtime / COUNT(*) OVER ()) > 0.35;",
            "SELECT DISTINCT pc.company_name\nFROM movie m\nJOIN movie_company mc ON m.movie_id = mc.movie_id\nJOIN production_company pc ON mc.company_id = pc.company_id\nWHERE m.release_date LIKE '2016%'\nAND m.runtime > (\n    SELECT AVG(runtime) * 1.35\n    FROM movie\n    WHERE release_date LIKE '2016%'\n    AND runtime IS NOT NULL\n)"
        ],
        "rule_sql": []
    },
    "699": {
        "db_id": "trains",
        "question": "Among the trains that run in the east direction, how many of them have more than 2 long cars?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.longCarsNum > 2 THEN 1 ELSE 0 END)as count FROM trains AS T1 INNER JOIN ( SELECT train_id, COUNT(id) AS longCarsNum FROM cars WHERE len = 'long' GROUP BY train_id ) AS T2 ON T1.id = T2.train_id WHERE T1.direction = 'west'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.longCarsNum > 2 THEN 1 ELSE 0 END) AS count` instead of `COUNT(*)` for conditional counting. Do add an `INNER JOIN` with a subquery `(SELECT train_id, COUNT(id) AS longCarsNum FROM cars WHERE len = 'long' GROUP BY train_id) AS T2` instead of omitting the join entirely. Do use `ON T1.id = T2.train_id` instead of no join condition. Do change the filter to `T1.direction = 'west'` instead of `direction = 'east'`. Do remove the filter `long_cars <= 2` instead of keeping it, as the condition is now handled in the CASE expression. The amended query now correctly counts trains going west that have more than 2 long cars by joining with car data and using conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trains WHERE direction = 'east' AND long_cars <= 2;",
            "SELECT SUM(CASE WHEN T2.longCarsNum > 2 THEN 1 ELSE 0 END) AS count\nFROM trains T1\nINNER JOIN (SELECT train_id, COUNT(id) AS longCarsNum FROM cars WHERE len = 'long' GROUP BY train_id) AS T2\nON T1.id = T2.train_id\nWHERE T1.direction = 'west'"
        ],
        "rule_sql": []
    },
    "2817": {
        "db_id": "professional_basketball",
        "question": "How many total minutes has the Brooklyn-born player, known by the name of Superman, played during all of his NBA All-Star seasons?",
        "ground_truth": "SELECT SUM(T2.minutes) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCity = 'Brooklyn' AND T1.nameNick LIKE '%Superman%'",
        "amends": [
            "Do reference table `player_allstar` as `T2` instead of `all_star_appearances` as `a`. Do use column `playerID` instead of `player_id` for both join conditions. Do reference `T2.minutes` in the aggregate instead of just `minutes`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do filter with `T1.nameNick LIKE '%Superman%'` instead of exact match `p.nickname = 'Superman'`. Do use column `birthCity` instead of `birth_city`. The amended query now correctly joins the proper tables with the correct column names and implements fuzzy matching for the nickname filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(minutes) AS total_minutes\nFROM players p\nJOIN all_star_appearances a ON p.player_id = a.player_id\nWHERE p.birth_city = 'Brooklyn' AND p.nickname = 'Superman';",
            "SELECT SUM(T2.minutes) AS total_minutes\nFROM players T1\nINNER JOIN player_allstar T2 ON T1.playerID = T2.playerID\nWHERE T1.birthCity = 'Brooklyn' AND T1.nameNick LIKE '%Superman%';"
        ],
        "rule_sql": []
    },
    "7524": {
        "db_id": "image_and_language",
        "question": "What is the object class of the image with a bounding box of 0, 0, 135, 212?",
        "ground_truth": "SELECT T1.OBJ_CLASS FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.X = 0 AND T2.Y = 0 AND T2.W = 135 AND T2.H = 212",
        "amends": [
            "Do select `T1.OBJ_CLASS` from `OBJ_CLASSES AS T1` instead of `object_class` from `images`. Do add `INNER JOIN IMG_OBJ AS T2` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single table. Do change the WHERE clause to filter on individual coordinate columns `T2.X = 0`, `T2.Y = 0`, `T2.W = 135`, and `T2.H = 212` instead of using a single string comparison `bounding_box = '0, 0, 135, 212'`. The amended query now properly joins the object classes table with the image objects table and correctly filters on the individual bounding box coordinates rather than relying on a string representation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class FROM images WHERE bounding_box = '0, 0, 135, 212';",
            "SELECT T1.OBJ_CLASS FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.X = 0 AND T2.Y = 0 AND T2.W = 135 AND T2.H = 212;"
        ],
        "rule_sql": []
    },
    "8004": {
        "db_id": "university",
        "question": "Between 2011 to 2016, in which countries can you find the universities where at least 50% of its students are international students?",
        "ground_truth": "SELECT DISTINCT T3.country_name FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.pct_international_students > 50 AND T2.year BETWEEN 2011 AND 2016",
        "amends": [
            "Do select `DISTINCT T3.country_name` instead of `country` to return unique country names. Do use `university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id` instead of a single table to properly join university and year data. Do add `INNER JOIN country AS T3 ON T3.id = T1.country_id` to link to the country table instead of assuming country data exists in the universities table. Do filter on `T2.pct_international_students > 50` instead of `international_students >= 50` to use the correct percentage column and comparison operator. Do apply the year filter `T2.year BETWEEN 2011 AND 2016` on the joined university_year table instead of the base universities table. The amended query now correctly retrieves distinct country names where universities had international student percentages exceeding 50% between 2011-2016, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM universities WHERE year BETWEEN 2011 AND 2016 AND international_students >= 50;",
            "SELECT DISTINCT T3.country_name\nFROM university AS T1\nINNER JOIN university_year AS T2 ON T1.id = T2.university_id\nINNER JOIN country AS T3 ON T3.id = T1.country_id\nWHERE T2.year BETWEEN 2011 AND 2016\nAND T2.pct_international_students > 50"
        ],
        "rule_sql": []
    },
    "3725": {
        "db_id": "college_completion",
        "question": "Give the cohort name for the school with biggest cohort size.",
        "ground_truth": "SELECT DISTINCT T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.cohort_size = ( SELECT MAX(T1.cohort_size) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid )",
        "amends": [
            "Do select `DISTINCT T1.chronname` instead of `cohort_name` and change the source from `schools` to `institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid` instead of a single table. Do add a `WHERE` filter with `T1.cohort_size = (subquery)` instead of no filter, and replace `ORDER BY cohort_size ASC LIMIT 1` with a subquery that finds `MAX(T1.cohort_size)` instead of the minimum value. The amended query now correctly identifies institutions with the maximum cohort size rather than the minimum, using proper table joins and distinct selection to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cohort_name FROM schools ORDER BY cohort_size ASC LIMIT 1;",
            "SELECT DISTINCT T1.chronname\nFROM institution_details AS T1\nINNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid\nWHERE T1.cohort_size = (SELECT MAX(cohort_size) FROM institution_details)"
        ],
        "rule_sql": []
    },
    "835": {
        "db_id": "social_media",
        "question": "Please list the texts of all the tweets that are not in English.",
        "ground_truth": "SELECT text FROM twitter WHERE Lang != 'en'",
        "amends": [
            "Do reference table `twitter` instead of `tweets` and use column `Lang` instead of `language`. Do filter for `Lang != 'en'` instead of `language != 'English'` to use the correct language code format. The amended query now correctly selects text from the twitter table filtering for non-English content using the proper column names and language code values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE language != 'English';",
            "SELECT text FROM twitter WHERE Lang != 'en';"
        ],
        "rule_sql": []
    },
    "1896": {
        "db_id": "soccer_2016",
        "question": "From which country does the most umpires are from? How many of them are from the mentioned country?\n",
        "ground_truth": "SELECT T2.Country_Id, COUNT(T1.Umpire_Id) FROM Umpire AS T1 INNER JOIN Country AS T2 ON T2.Country_Id = T1.Umpire_Country GROUP BY T2.Country_Id ORDER BY COUNT(T1.Umpire_Id) DESC LIMIT 1",
        "amends": [
            "Do join `Country` as `T2` instead of querying only the `umpires` table. Do use `INNER JOIN` on `T2.Country_Id = T1.Umpire_Country` instead of missing the join condition. Do select `T2.Country_Id` instead of `country`. Do count `T1.Umpire_Id` instead of using `COUNT(*)`. Do group by `T2.Country_Id` instead of `country`. Do order by `COUNT(T1.Umpire_Id)` instead of `count`. The amended query now correctly joins the Country table to count umpires per country and matches the RIGHT_SQL's behavior.",
            "Do select `T2.Country_Id` instead of `T2.Country_Name` in the SELECT list to match the GROUP BY clause. Do remove the alias `AS Umpire_Count` instead of keeping it since the RIGHT_SQL doesn't include column aliases. The amended query now correctly returns the country ID with the highest umpire count instead of the country name, ensuring the GROUP BY and SELECT clauses are properly aligned."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as count FROM umpires GROUP BY country ORDER BY count DESC LIMIT 1;",
            "SELECT T2.Country_Name, COUNT(T1.Umpire_Id) AS Umpire_Count\nFROM Umpire T1\nINNER JOIN Country T2 ON T2.Country_Id = T1.Umpire_Country\nGROUP BY T2.Country_Id\nORDER BY COUNT(T1.Umpire_Id) DESC\nLIMIT 1;",
            "SELECT T2.Country_Id, COUNT(T1.Umpire_Id)\nFROM Umpire T1\nINNER JOIN Country T2 ON T2.Country_Id = T1.Umpire_Country\nGROUP BY T2.Country_Id\nORDER BY COUNT(T1.Umpire_Id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6838": {
        "db_id": "retails",
        "question": "Please indicate the total price of order key 32.",
        "ground_truth": "SELECT o_totalprice FROM orders WHERE o_orderkey = 32",
        "amends": [
            "Do select the specific column `o_totalprice` instead of aggregating with `SUM(price)` which incorrectly sums all prices. Do filter on the correct primary key column `o_orderkey` instead of using `order_id` which may not exist or be the appropriate identifier. Do remove the aggregation function entirely instead of applying it to what should be a single row lookup, as the query intends to retrieve the total price for a specific order rather than summing across multiple records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE order_id = 32;",
            "SELECT o_totalprice FROM orders WHERE o_orderkey = 32;"
        ],
        "rule_sql": []
    },
    "2113": {
        "db_id": "world_development_indicators",
        "question": "What is the series note description of the series \"SP.DYN.TO65.MA.ZS\" which covers the topic \"Health: Mortality\" in 1967?",
        "ground_truth": "SELECT T2.Description FROM Series AS T1 INNER JOIN SeriesNotes AS T2 ON T1.SeriesCode = T2.Seriescode WHERE T1.SeriesCode = 'SP.DYN.TO65.MA.ZS' AND T1.Topic = 'Health: Mortality' AND T2.Year = 'YR1967'",
        "amends": [
            "Do join `SeriesNotes` as `T2` on `T1.SeriesCode = T2.Seriescode` instead of querying only the `series` table. Do select `T2.Description` instead of `note_description`. Do filter with `T2.Year = 'YR1967'` instead of `year = 1967` to use the correct string format and reference the joined table. Do add table aliases `T1` and `T2` instead of omitting them for clarity. The amended query now correctly retrieves the description from the SeriesNotes table using proper join conditions and year formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT note_description FROM series WHERE series_code = 'SP.DYN.TO65.MA.ZS' AND topic = 'Health: Mortality' AND year = 1967;",
            "SELECT T2.Description \nFROM Series T1\nJOIN SeriesNotes T2 ON T1.SeriesCode = T2.Seriescode\nWHERE T1.SeriesCode = 'SP.DYN.TO65.MA.ZS' \nAND T1.Topic = 'Health: Mortality' \nAND T2.Year = 'YR1967'"
        ],
        "rule_sql": []
    },
    "1051": {
        "db_id": "talkingdata",
        "question": "What is the most common device model among female users between the ages 27 to 28?",
        "ground_truth": "SELECT T2.device_model FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.`group` = 'F27-28' AND T1.gender = 'F' ORDER BY T2.device_id DESC LIMIT 1",
        "amends": [
            "Do select `T2.device_model` instead of `device_model` and `COUNT(*) as count`. Do use `FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2` instead of `FROM users`. Do join on `T1.device_id = T2.device_id` instead of no join condition. Do filter with `T1.group = 'F27-28' AND T1.gender = 'F'` instead of `gender = 'female' AND age BETWEEN 27 AND 28`. Do remove `GROUP BY device_model` instead of keeping it. Do order by `T2.device_id DESC` instead of `count DESC`. The amended query now correctly retrieves the device model from the joined tables using proper filtering criteria and ordering.",
            "Do remove `COUNT(*) as count` from the SELECT list instead of including it. Do add `LIMIT 1` at the end instead of omitting it. Do escape the reserved keyword `group` as `group` in the WHERE clause instead of using it unescaped. The amended query now correctly returns a single device model with proper keyword handling and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_model, COUNT(*) as count\nFROM users\nWHERE gender = 'female' AND age BETWEEN 27 AND 28\nGROUP BY device_model\nORDER BY count DESC\nLIMIT 1;",
            "SELECT T2.device_model, COUNT(*) as count \nFROM gender_age AS T1 \nINNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id \nWHERE T1.group = 'F27-28' AND T1.gender = 'F' \nORDER BY T2.device_id DESC",
            "SELECT T2.device_model \nFROM gender_age AS T1 \nINNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id \nWHERE T1.\"group\" = 'F27-28' AND T1.gender = 'F' \nORDER BY T2.device_id DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6673": {
        "db_id": "retails",
        "question": "What is the comment of the order with the highest total price?",
        "ground_truth": "SELECT o_comment FROM orders WHERE o_totalprice = ( SELECT MAX(o_totalprice) FROM orders )",
        "amends": [
            "Do select `o_comment` instead of `comment` to use the correct column name. Do add a `WHERE` filter comparing `o_totalprice` to the maximum value from a subquery instead of omitting filtering entirely. Do use a subquery with `MAX(o_totalprice)` instead of simple `ORDER BY total_price DESC LIMIT 1` to properly find the record with the highest price. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them since the maximum value is now determined through aggregation. The amended query now correctly identifies the comment associated with the order having the maximum total price, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT comment FROM orders ORDER BY total_price DESC LIMIT 1;",
            "SELECT o_comment FROM orders WHERE o_totalprice = (SELECT MAX(o_totalprice) FROM orders);"
        ],
        "rule_sql": []
    },
    "5006": {
        "db_id": "olympics",
        "question": "How many kinds of events belong to the sport of cycling?",
        "ground_truth": "SELECT COUNT(T2.event_name) FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Cycling'",
        "amends": [
            "Do use explicit table joins with `sport AS T1 INNER JOIN event AS T2` instead of querying a single table. Do reference the correct column `T2.event_name` in the count instead of counting all rows with `COUNT(*)`. Do join on the proper foreign key relationship `T1.id = T2.sport_id` instead of filtering directly on a non-existent column. Do filter on the standardized sport name `T1.sport_name = 'Cycling'` instead of using the incorrect column `sport = 'cycling'` with wrong case sensitivity. The amended query now correctly counts cycling events by properly joining the sport and event tables through their established relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE sport = 'cycling';",
            "SELECT COUNT(DISTINCT T2.event_name) \nFROM sport AS T1 \nINNER JOIN event AS T2 ON T1.id = T2.sport_id \nWHERE T1.sport_name = 'Cycling'"
        ],
        "rule_sql": []
    },
    "7319": {
        "db_id": "works_cycles",
        "question": "List all product name from Australia Bike Retailer order by product ID.",
        "ground_truth": "SELECT T3.Name FROM Vendor AS T1 INNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID WHERE T1.Name = 'Australia Bike Retailer'",
        "amends": [
            "Do use `T3.Name` instead of `product_name` in the SELECT list. Do join `Vendor AS T1` and `ProductVendor AS T2` with `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do add another `INNER JOIN` to `Product AS T3` on `T2.ProductID = T3.ProductID` instead of omitting these table relationships. Do use `T1.Name = 'Australia Bike Retailer'` as the WHERE filter instead of separate `country = 'Australia'` and `retailer = 'Bike Retailer'` conditions. Do remove the `ORDER BY product_id` clause instead of keeping it. The amended query now correctly joins multiple tables to retrieve product names from the specific vendor and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE country = 'Australia' AND retailer = 'Bike Retailer' ORDER BY product_id;",
            "SELECT T3.Name\nFROM Vendor AS T1\nINNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN Product AS T3 ON T2.ProductID = T3.ProductID\nWHERE T1.Name = 'Australia Bike Retailer'"
        ],
        "rule_sql": []
    },
    "8043": {
        "db_id": "university",
        "question": "How many criteria are associated with ranking system Center for World University Rankings?",
        "ground_truth": "SELECT COUNT(T2.criteria_name) FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T1.system_name = 'Center for World University Rankings'",
        "amends": [
            "Do select `COUNT(T2.criteria_name)` instead of `COUNT(*)` to count specific criteria rather than all rows. Do use `ranking_system AS T1` and `ranking_criteria AS T2` as FROM sources instead of just `ranking_systems` to join related tables. Do add `INNER JOIN` on `T1.id = T2.ranking_system_id` instead of no join condition to properly relate the tables. Do filter on `T1.system_name = 'Center for World University Rankings'` instead of `name = 'Center for World University Rankings'` to use the correct column name from the proper table. The amended query now correctly counts ranking criteria for the specified system rather than just checking system existence."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ranking_systems WHERE name = 'Center for World University Rankings';",
            "SELECT COUNT(T2.criteria_name) \nFROM ranking_system AS T1 \nINNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id \nWHERE T1.system_name = 'Center for World University Rankings'"
        ],
        "rule_sql": []
    },
    "9080": {
        "db_id": "bike_share_1",
        "question": "Are all stations with zip code 94107 located in San Francisco city?",
        "ground_truth": "SELECT DISTINCT T2.city FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.zip_code = 94107",
        "amends": [
            "Do select `DISTINCT T2.city` instead of `COUNT(*)` to return unique city names rather than a count. Do use `FROM trip AS T1 INNER JOIN station AS T2` instead of `FROM stations` to join trip and station tables. Do apply the join condition `ON T2.name = T1.start_station_name` instead of no join condition. Do filter with `WHERE T1.zip_code = 94107` instead of `WHERE zip_code = '94107' AND city != 'San Francisco'`, removing the numeric quote wrapping and city filter. Do remove the `COUNT(*)` aggregation and city inequality filter entirely instead of keeping them. The amended query now correctly retrieves distinct cities from stations associated with trips originating from zip code 94107, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stations WHERE zip_code = '94107' AND city != 'San Francisco';",
            "SELECT DISTINCT T2.city\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.zip_code = 94107"
        ],
        "rule_sql": []
    },
    "898": {
        "db_id": "cs_semester",
        "question": "How many students does Ogdon Zywicki advise?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.first_name = 'Ogdon' AND T2.last_name = 'Zywicki'",
        "amends": [
            "Do select `COUNT(T1.student_id)` from a specific column instead of `COUNT(*)` from all rows. Do use `FROM RA AS T1 INNER JOIN prof AS T2` with two joined tables instead of `FROM students` with a single table. Do apply join condition `ON T1.prof_id = T2.prof_id` to connect the tables instead of no join condition. Do filter with `WHERE T2.first_name = 'Ogdon' AND T2.last_name = 'Zywicki'` using separate name fields instead of `WHERE advisor = 'Ogdon Zywicki'` with a combined field. The amended query now correctly counts students by joining through the relationship table and matching on professor name components, fixing the original logic that relied on a potentially incorrect or non-existent advisor field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE advisor = 'Ogdon Zywicki';",
            "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.first_name = 'Ogdon' AND T2.last_name = 'Zywicki'"
        ],
        "rule_sql": []
    },
    "2047": {
        "db_id": "music_tracker",
        "question": "What is the tag of the album with the highest amount of downloads?",
        "ground_truth": "SELECT T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.releaseType = 'album' ORDER BY T1.totalSnatched DESC LIMIT 1",
        "amends": [
            "Do select `T2.tag` from the `tags` table instead of `tag` from `albums`. Do add `torrents AS T1` as a source table with an `INNER JOIN` to `tags AS T2` on `T1.id = T2.id` instead of querying only the `albums` table. Do add a WHERE filter for `T1.releaseType = 'album'` instead of omitting any filtering condition. Do order by `T1.totalSnatched DESC` instead of `downloads ASC`. The amended query now correctly retrieves the tag from the tags table joined with torrents filtered by album release type and ordered by total snatched count in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tag FROM albums ORDER BY downloads ASC LIMIT 1;",
            "SELECT T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.releaseType = 'album' ORDER BY T1.totalSnatched DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "7183": {
        "db_id": "works_cycles",
        "question": "Which product ID do not have any work order ID?",
        "ground_truth": "SELECT ProductID FROM Product WHERE ProductID NOT IN ( SELECT T1.ProductID FROM Product AS T1 INNER JOIN WorkOrder AS T2 ON T1.ProductID = T2.ProductID )",
        "amends": [
            "Do select `ProductID` instead of `product_id` and use a subquery to find products without work orders instead of checking for NULL. Do reference table `Product` instead of `products` and remove the `WHERE work_order_id IS NULL` filter. Do add a subquery with `INNER JOIN` between `Product` and `WorkOrder` on `ProductID` instead of the simple NULL check. Do use `NOT IN` to exclude products that have work orders instead of relying on a NULL column that may not exist. The amended query now correctly identifies products without any associated work orders by checking the absence of matching records in the WorkOrder table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id FROM products WHERE work_order_id IS NULL;",
            "SELECT ProductID FROM Product WHERE ProductID NOT IN (SELECT DISTINCT ProductID FROM WorkOrder)"
        ],
        "rule_sql": []
    },
    "806": {
        "db_id": "social_media",
        "question": "Give the name of the city of the user who tweeted `One of our favorite stories is @FINRA_News's move to the cloud with AWS Enterprise Support! https://amp.twimg.com/v/991837f1-4815-4edc-a88f-e68ded09a02a`.",
        "ground_truth": "SELECT T2.City FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T1.text = 'One of our favorite stories is @FINRA_News''s move to the cloud with AWS Enterprise Support! https://amp.twimg.com/v/991837f1-4815-4edc-a88f-e68ded09a02a'",
        "amends": [
            "Do select `T2.City` from the `location` table instead of `city` from the `users` table. Do join `twitter AS T1` with `location AS T2` using `INNER JOIN` on `T2.LocationID = T1.LocationID` instead of querying a single `users` table without any joins. Do filter on `T1.text` instead of `tweet` to reference the correct column from the joined table. The amended query now correctly retrieves city information from the location table by joining with the twitter table where the text matches the specified content, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM users WHERE tweet = 'One of our favorite stories is @FINRA_News''s move to the cloud with AWS Enterprise Support! https://amp.twimg.com/v/991837f1-4815-4edc-a88f-e68ded09a02a';",
            "SELECT T2.City \nFROM twitter AS T1 \nINNER JOIN location AS T2 ON T2.LocationID = T1.LocationID \nWHERE T1.text = 'One of our favorite stories is @FINRA_News''s move to the cloud with AWS Enterprise Support! https://amp.twimg.com/v/991837f1-4815-4edc-a88f-e68ded09a02a'"
        ],
        "rule_sql": []
    },
    "1025": {
        "db_id": "computer_student",
        "question": "Between the faculty employee professors, how many teaches high-level or harder undergraduate courses? Indicate each of the professors unique identifying number.",
        "ground_truth": "SELECT COUNT(*) FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE T1.hasPosition = 'Faculty_eme' AND T1.professor = 1 AND T3.courseLevel = 'Level_400'",
        "amends": [
            "Do use `COUNT(*)` without grouping instead of `professor_id, COUNT(*)` with grouping. Do join `person AS T1` with `taughtBy AS T2` on `T1.p_id = T2.p_id` instead of querying only `professors`. Do add a second join to `course AS T3` on `T3.course_id = T2.course_id` instead of omitting course table. Do add filters for `T1.hasPosition = 'Faculty_eme'` and `T1.professor = 1` instead of omitting position and professor status checks. Do use `T3.courseLevel = 'Level_400'` instead of `course_level = 'high-level' OR course_level = 'harder'`. Do remove `GROUP BY professor_id` instead of keeping it. The amended query now correctly counts courses taught by faculty professors at the 400 level instead of counting high-level courses by professor."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professor_id, COUNT(*) \nFROM professors \nWHERE course_level = 'high-level' OR course_level = 'harder' \nGROUP BY professor_id;",
            "SELECT COUNT(*) \nFROM person AS T1\nJOIN taughtBy AS T2 ON T1.p_id = T2.p_id\nJOIN course AS T3 ON T3.course_id = T2.course_id\nWHERE T1.hasPosition = 'Faculty_eme' \nAND T1.professor = 1\nAND T3.courseLevel = 'Level_400'"
        ],
        "rule_sql": []
    },
    "2126": {
        "db_id": "world_development_indicators",
        "question": "Which European countries had the highest private expenditure on health in 2005? List the top ten countries in descending order and find the source of the data.",
        "ground_truth": "SELECT DISTINCT T1.CountryCode, T3.Description FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN CountryNotes AS T3 ON T1.CountryCode = T3.Countrycode WHERE T2.IndicatorName = 'Out-of-pocket health expenditure (% of private expenditure on health)' AND T2.Value > 0 AND T2.year = 2005 ORDER BY T2.Value DESC LIMIT 10",
        "amends": [
            "Do select `T1.CountryCode` and `T3.Description` instead of `country`, `private_expenditure`, and `source`. Do use `DISTINCT` instead of omitting it. Do join `Country AS T1` with `Indicators AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying a single table. Do add a second join to `CountryNotes AS T3` on `T1.CountryCode = T3.Countrycode` instead of omitting this table. Do filter on `T2.IndicatorName = 'Out-of-pocket health expenditure (% of private expenditure on health)'` and `T2.Value > 0` instead of filtering by `continent = 'Europe'`. Do keep the `year = 2005` filter but apply it to `T2.year` instead of the original table. Do order by `T2.Value DESC` instead of `private_expenditure ASC`. The amended query now correctly retrieves distinct country codes with descriptions for countries having positive out-of-pocket health expenditure values in 2005, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, private_expenditure, source FROM health_expenditure WHERE year = 2005 AND continent = 'Europe' ORDER BY private_expenditure ASC LIMIT 10;",
            "SELECT DISTINCT T1.CountryCode, T3.Description\nFROM Country AS T1\nJOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode\nJOIN CountryNotes AS T3 ON T1.CountryCode = T3.Countrycode\nWHERE T2.IndicatorName = 'Out-of-pocket health expenditure (% of private expenditure on health)'\nAND T2.Value > 0\nAND T2.Year = 2005\nORDER BY T2.Value DESC\nLIMIT 10"
        ],
        "rule_sql": []
    },
    "3960": {
        "db_id": "public_review_platform",
        "question": "How long is the Yelp business No. 15098 opened on Monday?",
        "ground_truth": "SELECT SUBSTR(T1.closing_time, 1, 2) + 12 - SUBSTR(T1.opening_time, 1, 2) AS YYSJ FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T2.day_of_week = 'Monday' AND T1.business_id = 15098",
        "amends": [
            "Do use `SUBSTR(T1.closing_time, 1, 2) + 12 - SUBSTR(T1.opening_time, 1, 2) AS YYSJ` instead of simply selecting `hours`. Do join `Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id` instead of querying only the `business_hours` table. Do filter with `T2.day_of_week = 'Monday'` instead of `day = 'Monday'` and maintain `T1.business_id = 15098` instead of `business_id = 15098`. The amended query now correctly calculates business hours by joining to the days table and performing time arithmetic, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hours FROM business_hours WHERE business_id = 15098 AND day = 'Monday';",
            "SELECT SUBSTR(T1.closing_time, 1, 2) + 12 - SUBSTR(T1.opening_time, 1, 2) AS YYSJ\nFROM Business_Hours AS T1\nINNER JOIN Days AS T2 ON T1.day_id = T2.day_id\nWHERE T2.day_of_week = 'Monday' AND T1.business_id = 15098;"
        ],
        "rule_sql": []
    },
    "9032": {
        "db_id": "bike_share_1",
        "question": "What are the average maximum and minimum temperatures in May 2015 when the mean humidity is between 65 and 75?",
        "ground_truth": "SELECT AVG(max_temperature_f), AVG(min_temperature_f) FROM weather WHERE date LIKE '5/%/2015' AND mean_humidity BETWEEN 65 AND 75",
        "amends": [
            "Do use column names `max_temperature_f` and `min_temperature_f` instead of `max_temp` and `min_temp`. Do query from table `weather` instead of `weather_data`. Do filter with `date LIKE '5/%/2015'` for May 2015 instead of separate `month = 'May' AND year = 2015` conditions. Do use `mean_humidity` for the humidity filter instead of `humidity`. Do remove the column aliases `avg_max_temp` and `avg_min_temp` instead of keeping them. The amended query now correctly calculates average temperatures for May 2015 with appropriate humidity filtering using the correct table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(max_temp) as avg_max_temp, AVG(min_temp) as avg_min_temp FROM weather_data WHERE month = 'May' AND year = 2015 AND humidity BETWEEN 65 AND 75",
            "SELECT AVG(max_temperature_f) AS avg_max_temp, AVG(min_temperature_f) AS avg_min_temp FROM weather WHERE date LIKE '5/%/2015' AND mean_humidity BETWEEN 65 AND 75"
        ],
        "rule_sql": []
    },
    "6011": {
        "db_id": "books",
        "question": "How many authors are named Adam?",
        "ground_truth": "SELECT COUNT(*) FROM author WHERE author_name LIKE 'Adam%'",
        "amends": [
            "Do reference table `author` instead of `authors` in the FROM clause. Do use filter `author_name LIKE 'Adam%'` instead of `name = 'Adam'` to match names starting with Adam rather than requiring exact equality. Do maintain the `COUNT(*)` aggregate function to count matching records. The amended query now correctly searches for author names beginning with Adam in the appropriate table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM authors WHERE name = 'Adam';",
            "SELECT COUNT(*) FROM author WHERE author_name LIKE 'Adam%'"
        ],
        "rule_sql": []
    },
    "6967": {
        "db_id": "ice_hockey_draft",
        "question": "List out the name of players who have a height of 5'8\".",
        "ground_truth": "SELECT T2.PlayerName FROM height_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height WHERE T1.height_in_inch = '5''8\"'",
        "amends": [
            "Do select `T2.PlayerName` from the `PlayerInfo` table instead of `name` from the `players` table. Do join `height_info AS T1` with `PlayerInfo AS T2` using `INNER JOIN` on `T1.height_id = T2.height` instead of querying a single table. Do filter on `T1.height_in_inch = '5''8\"'` instead of `height = '5\\'8\"'` to use the correct height column and properly escaped quotes. The amended query now correctly joins the height information table with player data using the appropriate relationship and height measurement format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE height = '5\\'8\\\"';",
            "SELECT T2.PlayerName \nFROM height_info AS T1 \nINNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height \nWHERE T1.height_in_inch = '5''8\"'"
        ],
        "rule_sql": []
    },
    "3156": {
        "db_id": "donor",
        "question": "For all donors from Texas City, list their donation message and name of the project they donated to.",
        "ground_truth": "SELECT T2.donation_message, T1.title FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.donor_city = 'Texas City'",
        "amends": [
            "Do select `T2.donation_message` and `T1.title` instead of `donor_name`, `donation_message`, and `project_name`. Do use `essays AS T1` and `donations AS T2` instead of `donors`, `donations`, and `projects`. Do perform `INNER JOIN` on `T1.projectid = T2.projectid` instead of joining `donors` to `donations` on `donors.donor_id = donations.donor_id` and then joining to `projects` on `donations.project_id = projects.project_id`. Do filter on `T2.donor_city = 'Texas City'` instead of `city = 'Texas City'`. The amended query now correctly retrieves donation messages and essay titles for donations from Texas City by joining the appropriate tables with the correct relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT donor_name, donation_message, project_name FROM donors JOIN donations ON donors.donor_id = donations.donor_id JOIN projects ON donations.project_id = projects.project_id WHERE city = 'Texas City'",
            "SELECT T2.donation_message, T1.title\nFROM essays AS T1\nINNER JOIN donations AS T2 ON T1.projectid = T2.projectid\nWHERE T2.donor_city = 'Texas City'"
        ],
        "rule_sql": []
    },
    "5394": {
        "db_id": "sales",
        "question": "What is the full name of employee who sold 1000 units?",
        "ground_truth": "SELECT DISTINCT T2.FirstName, T2.MiddleInitial, T2.LastName FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE T1.Quantity = 1000",
        "amends": [
            "Do select `DISTINCT T2.FirstName, T2.MiddleInitial, T2.LastName` instead of `first_name, last_name` without distinct. Do use `FROM Sales AS T1 INNER JOIN Employees AS T2` instead of `FROM employees` alone. Do join on `T1.SalesPersonID = T2.EmployeeID` instead of no join condition. Do filter on `T1.Quantity = 1000` instead of `units_sold = 1000`. The amended query now correctly retrieves distinct employee names from the sales join instead of directly querying the employees table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE units_sold = 1000;",
            "SELECT DISTINCT T2.FirstName, T2.MiddleInitial, T2.LastName\nFROM Sales AS T1\nINNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID\nWHERE T1.Quantity = 1000"
        ],
        "rule_sql": []
    },
    "2584": {
        "db_id": "regional_sales",
        "question": "Provide all the orders from WARE-NMK1003. Name the product and sales team for each of these order.",
        "ground_truth": "SELECT DISTINCT T1.`Product Name`, T3.`Sales Team` FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Sales Team` AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE T2.WarehouseCode = 'WARE-NMK1003'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use `T1.`Product Name`` and `T3.`Sales Team`` instead of `product_name` and `sales_team`. Do join `Products AS T1` instead of omitting it. Do join `Sales Orders AS T2` with `T2._ProductID = T1.ProductID` instead of omitting the join. Do join `Sales Team AS T3` with `T3.SalesTeamID = T2._SalesTeamID` instead of omitting the join. Do filter on `T2.WarehouseCode = 'WARE-NMK1003'` instead of `product_id = 'WARE-NMK1003'`. The amended query now correctly retrieves distinct product names and sales teams by joining the necessary tables and filtering on the warehouse code rather than product ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, sales_team FROM orders WHERE product_id = 'WARE-NMK1003';",
            "SELECT DISTINCT T1.\"Product Name\", T3.\"Sales Team\"\nFROM \"Sales Orders\" AS T2\nJOIN Products AS T1 ON T2._ProductID = T1.ProductID\nJOIN \"Sales Team\" AS T3 ON T3.SalesTeamID = T2._SalesTeamID\nWHERE T2.WarehouseCode = 'WARE-NMK1003'"
        ],
        "rule_sql": []
    },
    "7510": {
        "db_id": "image_and_language",
        "question": "What are the id of all the objects belonging to the transportation class?",
        "ground_truth": "SELECT OBJ_CLASS_ID FROM OBJ_CLASSES WHERE OBJ_CLASS IN ('bus', 'train', 'aeroplane', 'car', 'etc')",
        "amends": [
            "Do select `OBJ_CLASS_ID` instead of `id` and do query from `OBJ_CLASSES` instead of `objects`. Do filter with `OBJ_CLASS IN` multiple values instead of `class =` single value, and do use the correct table and column names that match the schema. The amended query now correctly retrieves class IDs for multiple transportation types from the appropriate reference table instead of attempting to find a single transportation class in what appears to be the wrong table structure.",
            "Do use the specific object class values `'bus'`, `'train'`, `'aeroplane'`, `'car'`, and `'etc'` in the `IN` clause instead of the broader set including `'transportation'`, `'vehicle'`, `'bicycle'`, `'motorcycle'`, `'airplane'`, `'boat'`, and `'truck'`. Do include `'aeroplane'` instead of `'airplane'` to match the correct spelling convention. Do add `'etc'` as a catch-all category instead of omitting it. The amended query now correctly filters for the specific object classes required, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM objects WHERE class = 'transportation';",
            "SELECT OBJ_CLASS_ID FROM OBJ_CLASSES WHERE OBJ_CLASS IN ('transportation', 'vehicle', 'car', 'bus', 'train', 'bicycle', 'motorcycle', 'airplane', 'boat', 'truck')",
            "SELECT OBJ_CLASS_ID FROM OBJ_CLASSES WHERE OBJ_CLASS IN ('bus', 'train', 'aeroplane', 'car', 'etc')"
        ],
        "rule_sql": []
    },
    "169": {
        "db_id": "book_publishing_company",
        "question": "List the title, price and publication date for all sales with 'ON invoice' payment terms.",
        "ground_truth": "SELECT T2.title, T2.price, T2.pubdate FROM sales AS T1 INNER JOIN titles AS T2 ON T1.title_id = T2.title_id WHERE T1.payterms = 'ON invoice'",
        "amends": [
            "Do reference columns from the `titles` table instead of the `sales` table for `title` and `price`. Do use `pubdate` instead of `publication_date` as the column name. Do add an `INNER JOIN` to the `titles` table on `T1.title_id = T2.title_id` instead of querying only the `sales` table. Do use `payterms` instead of `payment_terms` as the column name in the WHERE clause. Do add table aliases `T1` for `sales` and `T2` for `titles` instead of using unaliased table names. The amended query now correctly joins the sales and titles tables to retrieve book information while filtering on payment terms."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, price, publication_date FROM sales WHERE payment_terms = 'ON invoice';",
            "SELECT T2.title, T2.price, T2.pubdate \nFROM sales T1 \nINNER JOIN titles T2 ON T1.title_id = T2.title_id \nWHERE T1.payterms = 'ON invoice'"
        ],
        "rule_sql": []
    },
    "8875": {
        "db_id": "cookbook",
        "question": "How many calories on average does a recipe that comes from \"Produce for Better Health Foundation and 5 a Day\" contain?",
        "ground_truth": "SELECT AVG(T2.calories) FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.source = 'Produce for Better Health Foundation and 5 a Day'",
        "amends": [
            "Do reference `T2.calories` from the joined Nutrition table instead of directly selecting `calories` without table specification. Do add `INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id` to properly relate nutrition data to recipes instead of querying a single table. Do filter on `T1.source` with the table alias instead of filtering an unspecified source column. The amended query now correctly joins the Recipe and Nutrition tables to calculate average calories from the appropriate source."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(calories) FROM recipes WHERE source = 'Produce for Better Health Foundation and 5 a Day';",
            "SELECT AVG(T2.calories) AS average_calories\nFROM Recipe AS T1\nINNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id\nWHERE T1.source = 'Produce for Better Health Foundation and 5 a Day';"
        ],
        "rule_sql": []
    },
    "440": {
        "db_id": "movies_4",
        "question": "How many crew are named John Young?",
        "ground_truth": "SELECT COUNT(person_id) FROM person WHERE person_name = 'John Young'",
        "amends": [
            "Do count `person_id` instead of `*` to exclude null values. Do query from `person` table instead of `crew` to access the correct data source. Do use a single `person_name` filter with the full name 'John Young' instead of separate `first_name` and `last_name` conditions on different columns. The amended query now correctly counts persons with the exact name 'John Young' in the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crew WHERE first_name = 'John' AND last_name = 'Young';",
            "SELECT COUNT(person_id) FROM person WHERE person_name = 'John Young';"
        ],
        "rule_sql": []
    },
    "4620": {
        "db_id": "mental_health_survey",
        "question": "List the top three popular responses to the question of the survey in 2017 with the question ID no.85.",
        "ground_truth": "SELECT AnswerText FROM Answer WHERE QuestionID = 85 AND SurveyID = 2017 GROUP BY AnswerText ORDER BY COUNT(AnswerText) DESC LIMIT 3",
        "amends": [
            "Do reference table `Answer` instead of `survey_responses` and column `AnswerText` instead of `response` in the SELECT list and GROUP BY clause. Do use column `QuestionID` instead of `question_id` and `SurveyID` instead of `year` in the WHERE filter conditions. Do order by `COUNT(AnswerText)` instead of ordering by the aliased `count` column. The amended query now correctly references the appropriate table and column names while maintaining the same aggregation and ranking logic.",
            "Do remove the `COUNT(AnswerText) AS count` column from the SELECT list instead of including it, as the RIGHT_SQL only needs the AnswerText values without the count aggregation. Do keep the same FROM source `Answer`, WHERE filters `QuestionID = 85 AND SurveyID = 2017`, GROUP BY clause `AnswerText`, ORDER BY expression `COUNT(AnswerText) DESC`, and LIMIT value `3` unchanged, as these elements remain identical between both queries. The amended query now correctly returns only the AnswerText values while maintaining the same grouping, ordering, and limiting behavior as the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT response, COUNT(*) as count FROM survey_responses WHERE question_id = 85 AND year = 2017 GROUP BY response ORDER BY count DESC LIMIT 3;",
            "SELECT AnswerText, COUNT(AnswerText) AS count\nFROM Answer\nWHERE QuestionID = 85 AND SurveyID = 2017\nGROUP BY AnswerText\nORDER BY COUNT(AnswerText) DESC\nLIMIT 3;",
            "SELECT AnswerText\nFROM Answer\nWHERE QuestionID = 85 AND SurveyID = 2017\nGROUP BY AnswerText\nORDER BY COUNT(AnswerText) DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "4544": {
        "db_id": "student_loan",
        "question": "What is the employment and payment status of student110?",
        "ground_truth": "SELECT T1.bool FROM no_payment_due AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name WHERE T1.name = 'student110'",
        "amends": [
            "Do select `T1.bool` instead of `employment_status, payment_status`. Do use `FROM no_payment_due AS T1 INNER JOIN unemployed AS T2` instead of `FROM students`. Do join on `T1.name = T2.name` instead of no join condition. Do filter with `WHERE T1.name = 'student110'` instead of `WHERE student_id = 'student110'`. The amended query now correctly retrieves boolean payment status from joined tables using name matching instead of student ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employment_status, payment_status FROM students WHERE student_id = 'student110';",
            "SELECT T1.bool FROM no_payment_due AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name WHERE T1.name = 'student110'"
        ],
        "rule_sql": []
    },
    "84": {
        "db_id": "movie_platform",
        "question": "Who was the director of the movie \"Tokyo Eyes\"\uff1f",
        "ground_truth": "SELECT director_name FROM movies WHERE movie_title = 'Tokyo Eyes'",
        "amends": [
            "Do select `director_name` instead of `actor_name` in the SELECT list. Do filter on `movie_title` instead of `title` in the WHERE clause. The amended query now correctly retrieves the director name for the specified movie title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM movies WHERE title = 'Tokyo Eyes';",
            "SELECT director_name FROM movies WHERE movie_title = 'Tokyo Eyes';"
        ],
        "rule_sql": []
    },
    "5961": {
        "db_id": "books",
        "question": "List the author's and publisher's name of the book published on July 10, 1997.",
        "ground_truth": "SELECT T3.author_name, T4.publisher_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE T1.publication_date = '1997-07-10'",
        "amends": [
            "Do add explicit table aliases `T3` and `T4` instead of using unqualified column names. Do join `book AS T1` instead of querying only the `books` table. Do add `INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id` to connect books to authors instead of omitting this relationship. Do add `INNER JOIN author AS T3 ON T3.author_id = T2.author_id` to access author details instead of assuming author_name exists in books. Do add `INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id` to access publisher details instead of assuming publisher_name exists in books. Do use `T1.publication_date` instead of `publish_date` for the date filter. The amended query now correctly joins all necessary tables to retrieve author and publisher names for books published on the specified date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name, publisher_name FROM books WHERE publish_date = '1997-07-10';",
            "SELECT T3.author_name, T4.publisher_name\nFROM book AS T1\nINNER JOIN book_author AS T2 ON T1.book_id = T2.book_id\nINNER JOIN author AS T3 ON T3.author_id = T2.author_id\nINNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id\nWHERE T1.publication_date = '1997-07-10';"
        ],
        "rule_sql": []
    },
    "2006": {
        "db_id": "soccer_2016",
        "question": "Provide the country ID of East London.",
        "ground_truth": "SELECT Country_id FROM City WHERE City_Name = 'East London'",
        "amends": [
            "Do reference the table as `City` instead of `cities` and use column names `Country_id` and `City_Name` instead of `country_id` and `city_name` to match the correct schema. The amended query now correctly retrieves the Country_id from the City table where City_Name equals 'East London', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_id FROM cities WHERE city_name = 'East London';",
            "SELECT Country_id FROM City WHERE City_Name = 'East London';"
        ],
        "rule_sql": []
    },
    "4645": {
        "db_id": "disney",
        "question": "Who is the director of the adventure movie which was released on 2007/3/30?",
        "ground_truth": "SELECT T1.director FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.name WHERE T2.genre = 'Adventure' AND T2.release_date = 'Mar 30, 2007'",
        "amends": [
            "Do select `T1.director` from the `director` table instead of `director` from the `movies` table. Do join `movies_total_gross AS T2` with `INNER JOIN` on `T2.movie_title = T1.name` instead of querying a single table. Do filter on `T2.genre = 'Adventure'` instead of `genre = 'adventure'` with different case sensitivity. Do filter on `T2.release_date = 'Mar 30, 2007'` instead of `release_date = '2007-03-30'` with different date format. The amended query now correctly joins director information with movie details and uses proper table references and date formatting to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director FROM movies WHERE genre = 'adventure' AND release_date = '2007-03-30';",
            "SELECT T1.director \nFROM director AS T1\nINNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.name\nWHERE T2.genre = 'Adventure' AND T2.release_date = 'Mar 30, 2007'"
        ],
        "rule_sql": []
    },
    "1797": {
        "db_id": "soccer_2016",
        "question": "Among the players whose bowling skill is \"Legbreak\", when was the oldest one of them born?",
        "ground_truth": "SELECT MIN(T1.DOB) FROM Player AS T1 INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id WHERE T2.Bowling_Skill = 'Legbreak'",
        "amends": [
            "Do use `MIN` instead of `MAX` for finding the earliest date. Do join `Player` table as `T1` with `Bowling_Style` table as `T2` instead of querying only the `players` table. Do use the join condition `T1.Bowling_skill = T2.Bowling_Id` instead of directly filtering on `bowling_skill`. Do filter on `T2.Bowling_Skill = 'Legbreak'` in the WHERE clause instead of filtering directly on the player's bowling skill attribute. Do select from the joined table structure instead of a single table. The amended query now correctly finds the minimum date of birth for players with Legbreak bowling style by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(birth_date) FROM players WHERE bowling_skill = 'Legbreak';",
            "SELECT MIN(T1.DOB) AS OldestBirthDate\nFROM Player AS T1\nJOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id\nWHERE T2.Bowling_skill = 'Legbreak';"
        ],
        "rule_sql": []
    },
    "8451": {
        "db_id": "mondial_geo",
        "question": "Which company falls under the category of an associated member? Please provide the organization's full name.",
        "ground_truth": "SELECT NAME FROM organization WHERE country IN ( SELECT country FROM politics WHERE dependent != '' )",
        "amends": [
            "Do select `NAME` from the `organization` table instead of `company_name` from `members`. Do use a `WHERE` filter with `country IN` subquery instead of `category = 'associated member'`. Do add a correlated subquery checking `politics.dependent != ''` instead of omitting this business logic. Do remove the simple equality filter and replace it with a country-based membership condition that properly validates organizational relationships through political dependencies.",
            "Do select only `NAME` instead of `o.Name` with table alias. Do remove the unnecessary `organization` table alias `o` instead of keeping it. Do change the WHERE filter to use `country IN` instead of `Abbreviation IN` with a subquery. Do remove the nested subquery referencing `isMember` table instead of including it. Do use a direct subquery `SELECT country FROM politics WHERE dependent != ''` instead of the complex multi-level subquery structure. Do maintain the same `dependent != ''` filter condition but apply it directly to the politics table. The amended query now correctly filters organizations based on countries with non-empty dependent values directly from the politics table, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company_name FROM members WHERE category = 'associated member'",
            "SELECT o.Name \nFROM organization o\nWHERE o.Abbreviation IN (\n    SELECT im.Organization \n    FROM isMember im \n    WHERE im.Country IN (\n        SELECT p.Country \n        FROM politics p \n        WHERE p.Dependent != ''\n    )\n);",
            "SELECT Name FROM organization WHERE Country IN (SELECT Country FROM politics WHERE dependent != '')"
        ],
        "rule_sql": []
    },
    "138": {
        "db_id": "movie_platform",
        "question": "Name all the list titles created by user 4208563.",
        "ground_truth": "SELECT list_title FROM lists WHERE user_id LIKE 4208563",
        "amends": [
            "Do select `list_title` instead of `title` in the SELECT list. Do use `LIKE` operator instead of `=` for the WHERE filter on `user_id`. The amended query now correctly retrieves the list_title column using appropriate filtering that matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM lists WHERE user_id = 4208563",
            "SELECT list_title FROM lists WHERE user_id LIKE '4208563'"
        ],
        "rule_sql": []
    },
    "2213": {
        "db_id": "world_development_indicators",
        "question": "How many countries are having their country's footnotes described as \"unspecified\"? Please provide the full names of any three of those countries.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.CountryCode)  FROM Country AS T1 INNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified' UNION SELECT T1.LongName FROM Country AS T1 INNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified' LIMIT 4",
        "amends": [
            "Do use `COUNT(DISTINCT T1.CountryCode)` instead of `COUNT(*)` to count distinct country codes rather than all rows. Do join `Country AS T1` with `Footnotes AS T2` on `T1.CountryCode = T2.Countrycode` instead of querying only the `countries` table. Do filter on `T2.Description = 'Unspecified' OR T2.Description = 'Not specified'` instead of `footnote = 'unspecified'` to capture both description variants. Do add a `UNION` with a second query selecting `T1.LongName` from the same joined tables and filters instead of having only one query. Do set `LIMIT 4` instead of `LIMIT 3` to return more results. The amended query now correctly counts distinct country codes with unspecified/not specified footnotes while also returning country names, matching the right SQL's behavior.",
            "Do remove the alias `country_count` from the `COUNT` expression instead of keeping it. Do change the first query's `JOIN` to explicit `INNER JOIN` instead of implicit join syntax. Do replace `UNION ALL` with `UNION` instead of keeping duplicate-allowing union. Do remove the `LIMIT 4` from only the second query and apply it to the entire union result instead of partial limiting. Do remove the second query's selection of `T1.LongName` without aggregation instead of mixing incompatible column types in union. The amended query now correctly uses union-compatible column types with proper deduplication and global limiting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE footnote = 'unspecified' LIMIT 3;",
            "SELECT COUNT(DISTINCT T1.CountryCode) AS country_count\nFROM Country AS T1\nJOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified'\n\nUNION ALL\n\nSELECT T1.LongName\nFROM Country AS T1\nJOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified'\nLIMIT 4;",
            "SELECT COUNT(DISTINCT T1.CountryCode) AS count\nFROM Country AS T1\nINNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified'\n\nUNION\n\nSELECT T1.LongName\nFROM Country AS T1\nINNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T2.Description = 'Unspecified' OR T2.Description = 'Not specified'\nLIMIT 4"
        ],
        "rule_sql": []
    },
    "2651": {
        "db_id": "regional_sales",
        "question": "List all orders where its products were shipped from Daly City.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.`City Name` = 'Daly City' THEN T1.OrderNumber END AS T FROM `Sales Orders` T1 INNER JOIN `Store Locations` T2 ON T2.StoreID = T1._StoreID ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `SELECT DISTINCT CASE` instead of a simple `SELECT *`. Do add an `INNER JOIN` on `T2.StoreID = T1._StoreID` instead of querying a single table. Do filter on `T2.City Name = 'Daly City'` in the CASE expression instead of directly filtering `ship_city`. Do wrap the result in an outer query with `WHERE T IS NOT NULL` instead of applying the filter directly. Do return only the calculated column `T` instead of all columns. The amended query now correctly handles the relationship between orders and store locations while filtering for Daly City and eliminating null results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM orders WHERE ship_city = 'Daly City';",
            "SELECT T FROM (\n    SELECT DISTINCT CASE \n        WHEN T2.\"City Name\" = 'Daly City' THEN T1.OrderNumber \n        ELSE NULL \n    END AS T\n    FROM \"Sales Orders\" T1\n    INNER JOIN \"Store Locations\" T2 ON T2.StoreID = T1._StoreID\n) WHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "5950": {
        "db_id": "books",
        "question": "Which shipping method is preferred by customers the most?",
        "ground_truth": "SELECT T2.method_name FROM cust_order AS T1 INNER JOIN shipping_method AS T2 ON T1.shipping_method_id = T2.method_id GROUP BY T2.method_name ORDER BY COUNT(T2.method_id) DESC LIMIT 1",
        "amends": [
            "Do reference the `shipping_method` table through a proper join on `T1.shipping_method_id = T2.method_id` instead of directly selecting from the `orders` table. Do select `T2.method_name` instead of `shipping_method` to get the actual method name rather than an ID. Do use `COUNT(T2.method_id)` in the ORDER BY clause instead of referencing the alias `order_count` to ensure proper aggregation ordering. Do join `cust_order AS T1` with `shipping_method AS T2` instead of querying the `orders` table directly to establish the correct relationship between orders and shipping methods. The amended query now correctly retrieves the most popular shipping method name by joining the appropriate tables and counting method instances.",
            "Do remove `COUNT(T2.method_id) AS order_count` from the SELECT list instead of including it, as only `T2.method_name` is needed for the final output. Do keep the `INNER JOIN` on `T1.shipping_method_id = T2.method_id` unchanged. Do maintain the `GROUP BY T2.method_name` grouping. Do preserve the `ORDER BY COUNT(T2.method_id) DESC` ordering and `LIMIT 1` limit. The amended query now correctly returns only the shipping method name with the highest order count instead of including the count value in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shipping_method, COUNT(*) as order_count FROM orders GROUP BY shipping_method ORDER BY order_count DESC LIMIT 1;",
            "SELECT T2.method_name, COUNT(T2.method_id) AS order_count\nFROM cust_order AS T1\nJOIN shipping_method AS T2 ON T1.shipping_method_id = T2.method_id\nGROUP BY T2.method_name\nORDER BY COUNT(T2.method_id) DESC\nLIMIT 1;",
            "SELECT T2.method_name\nFROM cust_order AS T1\nINNER JOIN shipping_method AS T2 ON T1.shipping_method_id = T2.method_id\nGROUP BY T2.method_name\nORDER BY COUNT(T2.method_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7604": {
        "db_id": "image_and_language",
        "question": "Write the object classes of image ID 22 alongside the object's width and height.",
        "ground_truth": "SELECT T1.W, T1.H, T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.IMG_ID = 22",
        "amends": [
            "Do select `T1.W`, `T1.H`, and `T2.OBJ_CLASS` instead of `object_class`, `object_width`, and `object_height`. Do use `IMG_OBJ AS T1` and `OBJ_CLASSES AS T2` as source tables instead of `images`. Do add `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of omitting the join. Do filter on `T1.IMG_ID = 22` instead of `image_id = 22`. The amended query now correctly joins the object classification table to retrieve the proper class names and matches the intended behavior.",
            "Do reorder the SELECT list to `T1.W, T1.H, T2.OBJ_CLASS` instead of `T2.OBJ_CLASS, T1.W, T1.H` to match the column sequence in the RIGHT_SQL. The JOIN condition `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` and WHERE filter `T1.IMG_ID = 22` remain unchanged, preserving the same logical behavior while only adjusting the output column order. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class, object_width, object_height FROM images WHERE image_id = 22;",
            "SELECT T2.OBJ_CLASS, T1.W, T1.H \nFROM IMG_OBJ AS T1 \nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID \nWHERE T1.IMG_ID = 22",
            "SELECT T1.W, T1.H, T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.IMG_ID = 22"
        ],
        "rule_sql": []
    },
    "7005": {
        "db_id": "works_cycles",
        "question": "Provide all the transactions whereby the quantiy is more than 10,000 pieces. State the product name and the selling price.",
        "ground_truth": "SELECT DISTINCT T1.Name, T1.ListPrice FROM Product AS T1 INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Quantity > 10000",
        "amends": [
            "Do use `DISTINCT T1.Name, T1.ListPrice` instead of `product_name, selling_price` for column selection and aliases. Do add `INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID` instead of querying only the `transactions` table. Do reference `T2.Quantity > 10000` instead of `quantity > 10000` for the WHERE filter, properly qualifying the table source. Do include proper table aliases `Product AS T1` and `TransactionHistory AS T2` instead of unspecified table references. The amended query now correctly joins product and transaction tables to filter high-quantity transactions while returning distinct product details, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, selling_price FROM transactions WHERE quantity > 10000;",
            "SELECT DISTINCT T1.Name, T1.ListPrice\nFROM Product AS T1\nINNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID\nWHERE T2.Quantity > 10000"
        ],
        "rule_sql": []
    },
    "6742": {
        "db_id": "retails",
        "question": "How many orders were shipped in 1994?",
        "ground_truth": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994'",
        "amends": [
            "Do reference the `lineitem` table instead of `orders`, and use `l_shipdate` instead of `shipped_date` for the date filtering. Do use `STRFTIME('%Y', l_shipdate) = '1994'` for precise year extraction instead of the pattern matching `LIKE '1993%'` which could be error-prone with different date formats. Do count `l_orderkey` instead of using `COUNT(*)` to focus on non-null order keys specifically. The amended query now correctly counts line items shipped in 1994 from the appropriate table with proper date handling.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the right query counts all order keys including duplicates rather than only distinct values. Do maintain the same `COUNT(l_orderkey)` column expression instead of changing it. Do preserve the same `FROM lineitem` source table instead of modifying it. Do keep the identical `WHERE STRFTIME('%Y', l_shipdate) = '1994'` filter condition instead of altering it. The amended query now matches the right SQL's behavior by counting all occurrences rather than distinct values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE shipped_date LIKE '1993%';",
            "SELECT COUNT(DISTINCT l_orderkey) \nFROM lineitem \nWHERE STRFTIME('%Y', l_shipdate) = '1994';",
            "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994'"
        ],
        "rule_sql": []
    },
    "8107": {
        "db_id": "university",
        "question": "Calculate the average number of students of all universities in 2012.",
        "ground_truth": "SELECT AVG(num_students) FROM university_year WHERE year = 2012",
        "amends": [
            "Do reference the `num_students` column instead of `student_count` and use the `university_year` table instead of `universities` table, while maintaining the same aggregation function and year filter condition. The amended query now correctly calculates the average number of students from the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(student_count) FROM universities WHERE year = 2012;",
            "SELECT AVG(num_students) AS average_students FROM university_year WHERE year = 2012"
        ],
        "rule_sql": []
    },
    "7060": {
        "db_id": "works_cycles",
        "question": "How many employees with a pay rate of over 35 have more than 10 sick leave hours?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.SickLeaveHours > 10 AND T1.Rate > 35",
        "amends": [
            "Do reference specific columns like `T1.BusinessEntityID` in the COUNT instead of using `COUNT(*)` for all rows. Do join tables with `INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do use table aliases `T1` and `T2` to qualify columns instead of unqualified column names. Do reference the correct column `T1.Rate` for the pay rate condition instead of `pay_rate`. Do use the correct inequality direction `T2.SickLeaveHours > 10` instead of `sick_leave_hours <= 10` to count employees with more than 10 sick leave hours. The amended query now correctly counts employees with a rate over 35 who have more than 10 sick leave hours by properly joining the pay history and employee tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE pay_rate > 35 AND sick_leave_hours <= 10;",
            "SELECT COUNT(T1.BusinessEntityID) \nFROM EmployeePayHistory AS T1\nINNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.Rate > 35 AND T2.SickLeaveHours > 10"
        ],
        "rule_sql": []
    },
    "8088": {
        "db_id": "university",
        "question": "Which country is University of Veterinary Medicine Vienna located in? Give its country id.",
        "ground_truth": "SELECT country_id FROM university WHERE university_name = 'University of Veterinary Medicine Vienna'",
        "amends": [
            "Do reference table `university` instead of `universities` and use column `university_name` instead of `name` for the filter condition, while keeping the same `country_id` selection and equality filter structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_id FROM universities WHERE name = 'University of Veterinary Medicine Vienna';",
            "SELECT country_id FROM university WHERE university_name = 'University of Veterinary Medicine Vienna';"
        ],
        "rule_sql": []
    },
    "4472": {
        "db_id": "student_loan",
        "question": "How many female students are enlisted in the Navy organization?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'navy' AND name NOT IN ( SELECT name FROM male )",
        "amends": [
            "Do count `name` instead of `*` and use table `enlist` instead of `students`. Do filter for `organ = 'navy'` instead of `organization = 'Navy'` and remove the direct `gender = 'male'` filter. Instead, do add a subquery condition `name NOT IN (SELECT name FROM male)` to exclude male records rather than including them directly. Do remove the `WHERE` clause gender filter entirely and replace it with a subquery-based exclusion approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND organization = 'Navy';",
            "SELECT COUNT(name) FROM enlist WHERE organ = 'navy' AND name NOT IN (SELECT name FROM male)"
        ],
        "rule_sql": []
    },
    "8425": {
        "db_id": "mondial_geo",
        "question": "Of all the countries that share territory with more than one continent, in which of them does the average population not exceed 10 inhabitants per square kilometer?",
        "ground_truth": "SELECT NAME FROM country WHERE CODE IN ( SELECT country FROM encompasses GROUP BY country HAVING COUNT(continent) > 1 ) AND population / Area <= 10",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM country c \nJOIN encompasses e ON c.code = e.country \nGROUP BY c.code, c.name \nHAVING COUNT(DISTINCT e.continent) > 1 \nAND AVG(c.population / c.area) <= 10;"
        ],
        "rule_sql": []
    },
    "6691": {
        "db_id": "retails",
        "question": "Which region does \"Supplier#000000129\" belong to?",
        "ground_truth": "SELECT T3.r_name FROM nation AS T1 INNER JOIN supplier AS T2 ON T1.n_nationkey = T2.s_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey WHERE T2.s_name = 'Supplier#000000129'",
        "amends": [
            "Do select `T3.r_name` instead of `region_name` to use the correct column alias from the joined table. Do join `nation AS T1` and `supplier AS T2` with `INNER JOIN` on `T1.n_nationkey = T2.s_nationkey` instead of querying `suppliers` directly without proper joins. Do add `INNER JOIN region AS T3` on `T1.n_regionkey = T3.r_regionkey` instead of omitting the necessary region table join. Do filter on `T2.s_name = 'Supplier#000000129'` instead of `supplier_id = 'Supplier#000000129'` to use the correct supplier name column for the lookup. The amended query now correctly joins through the nation-region hierarchy to find the region name for the specified supplier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name FROM suppliers WHERE supplier_id = 'Supplier#000000129';",
            "SELECT T3.r_name\nFROM supplier AS T2\nINNER JOIN nation AS T1 ON T1.n_nationkey = T2.s_nationkey\nINNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey\nWHERE T2.s_name = 'Supplier#000000129';"
        ],
        "rule_sql": []
    },
    "6806": {
        "db_id": "retails",
        "question": "What is the discounted price of line item number 1?",
        "ground_truth": "SELECT l_extendedprice * (1 - l_discount) FROM lineitem WHERE l_linenumber = 1",
        "amends": [
            "Do select the calculated expression `l_extendedprice * (1 - l_discount)` instead of the simple column `price`. Do use the table alias `lineitem` instead of `line_items`. Do filter on `l_linenumber = 1` instead of `id = 1`. The amended query now correctly calculates the discounted price for the specified line number rather than retrieving a raw price value by ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM line_items WHERE id = 1;",
            "SELECT l_extendedprice * (1 - l_discount) AS discounted_price FROM lineitem WHERE l_linenumber = 1;"
        ],
        "rule_sql": []
    },
    "1837": {
        "db_id": "soccer_2016",
        "question": "Who is the player that has the highest number of roles as a captain for Deccan Chargers?",
        "ground_truth": "SELECT T4.Player_Name FROM Team AS T1 INNER JOIN Player_Match AS T2 ON T1.Team_id = T2.Team_id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id INNER JOIN Player AS T4 ON T2.Player_Id = T4.Player_Id WHERE T1.Team_Name = 'Deccan Chargers' AND T1.Team_Id = 8 AND T3.Role_Desc = 'Captain' AND T3.Role_Id = 1 GROUP BY T4.Player_Id ORDER BY COUNT(T3.Role_Id) DESC LIMIT 1",
        "amends": [
            "Do use explicit table joins with `INNER JOIN` on `T1.Team_id = T2.Team_id`, `T2.Role_Id = T3.Role_Id`, and `T2.Player_Id = T4.Player_Id` instead of querying a single table. Do select `T4.Player_Name` instead of `player_name` and `COUNT(*) as captain_count`. Do add filters for `T1.Team_Name = 'Deccan Chargers'`, `T1.Team_Id = 8`, `T3.Role_Desc = 'Captain'`, and `T3.Role_Id = 1` instead of just `team = 'Deccan Chargers'` and `role = 'captain'`. Do group by `T4.Player_Id` instead of `player_name`. Do order by `COUNT(T3.Role_Id) DESC` instead of `captain_count DESC`. The amended query now correctly joins multiple tables with proper foreign key relationships and specific filtering conditions to match the intended behavior.",
            "Do remove `COUNT(*) as captain_count` from the SELECT list instead of including it, and do remove the alias `T4.Player_Name` instead of keeping it. Do use `Team_id` instead of `Team_Id` in the JOIN condition between `Team` and `Player_Match`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, COUNT(*) as captain_count \nFROM player_matches \nWHERE team = 'Deccan Chargers' AND role = 'captain' \nGROUP BY player_name \nORDER BY captain_count DESC \nLIMIT 1;",
            "SELECT T4.Player_Name, COUNT(*) as captain_count\nFROM Team T1\nINNER JOIN Player_Match T2 ON T1.Team_Id = T2.Team_Id\nINNER JOIN Rolee T3 ON T2.Role_Id = T3.Role_Id\nINNER JOIN Player T4 ON T2.Player_Id = T4.Player_Id\nWHERE T1.Team_Name = 'Deccan Chargers'\nAND T1.Team_Id = 8\nAND T3.Role_Desc = 'Captain'\nAND T3.Role_Id = 1\nGROUP BY T4.Player_Id\nORDER BY COUNT(T3.Role_Id) DESC\nLIMIT 1;",
            "SELECT T4.Player_Name\nFROM Team T1\nINNER JOIN Player_Match T2 ON T1.Team_id = T2.Team_id\nINNER JOIN Rolee T3 ON T2.Role_Id = T3.Role_Id\nINNER JOIN Player T4 ON T2.Player_Id = T4.Player_Id\nWHERE T1.Team_Name = 'Deccan Chargers'\nAND T1.Team_Id = 8\nAND T3.Role_Desc = 'Captain'\nAND T3.Role_Id = 1\nGROUP BY T4.Player_Id\nORDER BY COUNT(T3.Role_Id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "387": {
        "db_id": "retail_complains",
        "question": "Please list the emails of the clients whose complaint date received is 7/3/2014.",
        "ground_truth": "SELECT T1.email FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Date received` = '2014-07-03'",
        "amends": [
            "Do select `T1.email` with table alias qualification instead of unqualified `email`. Do join `client AS T1` with `events AS T2` using `INNER JOIN` on `T1.client_id = T2.Client_ID` instead of querying only the `clients` table without any join. Do filter on `T2.`Date received` = '2014-07-03'` instead of `complaint_date = '2014-03-07'`, correcting both the column reference and date format. The amended query now correctly joins the client and events tables to filter based on the event date rather than a client attribute, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM clients WHERE complaint_date = '2014-03-07';",
            "SELECT T1.email \nFROM client AS T1 \nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID \nWHERE T2.\"Date received\" = '2014-07-03'"
        ],
        "rule_sql": []
    },
    "8283": {
        "db_id": "mondial_geo",
        "question": "For the country in which Olsztyn is located, where is the capital?",
        "ground_truth": "SELECT T1.Capital FROM country AS T1 INNER JOIN city AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Olsztyn'",
        "amends": [
            "Do join `country AS T1` with `city AS T2` on `T1.Code = T2.Country` instead of querying `countries` table directly. Do select `T1.Capital` instead of `capital` from the joined tables. Do add filter `T2.Name = 'Olsztyn'` in the WHERE clause instead of filtering on `name = 'Olsztyn'` against the countries table. The amended query now correctly retrieves the capital by joining country and city tables and filtering on the city name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT capital FROM countries WHERE name = 'Olsztyn';",
            "SELECT T1.Capital FROM country AS T1 JOIN city AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Olsztyn'"
        ],
        "rule_sql": []
    },
    "4019": {
        "db_id": "public_review_platform",
        "question": "List out city name of businesses which have medium length of review.",
        "ground_truth": "SELECT DISTINCT T1.city FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T2.review_length = 'Medium'",
        "amends": [
            "Do use `DISTINCT T1.city` instead of just `city` to eliminate duplicate cities. Do join `Business AS T1` with `Reviews AS T2` on `T1.business_id = T2.business_id` instead of querying only the businesses table. Do filter on `T2.review_length = 'Medium'` with proper case sensitivity instead of using `LENGTH(review) = 'medium'` which incorrectly attempts to use a length function on a string comparison. The amended query now correctly identifies cities with medium-length reviews by joining the appropriate tables and using the proper review_length column with correct case matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM businesses WHERE LENGTH(review) = 'medium';",
            "SELECT DISTINCT T1.city\nFROM Business AS T1\nJOIN Reviews AS T2 ON T1.business_id = T2.business_id\nWHERE T2.review_length = 'Medium'"
        ],
        "rule_sql": []
    },
    "2481": {
        "db_id": "shooting",
        "question": "How many people were injured between 2006 and 2014 as a result of a handgun?",
        "ground_truth": "SELECT COUNT(location) FROM incidents WHERE subject_weapon = 'Handgun' AND subject_statuses = 'Injured' AND date BETWEEN '2006-01-01' AND '2013-12-31'",
        "amends": [
            "Do count `location` instead of `*` to count non-null locations. Do filter on `subject_weapon = 'Handgun'` instead of `weapon = 'handgun'` to use the correct column name and case-sensitive value. Do filter on `subject_statuses = 'Injured'` instead of `injured = 0` to use the correct column and positive condition. Do filter `date` between '2006-01-01' and '2013-12-31' instead of `year` between 2006 and 2014 to use the correct date column and precise date range. The amended query now correctly counts incidents with handguns where subjects were injured within the specified date range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM incidents WHERE weapon = 'handgun' AND year BETWEEN 2006 AND 2014 AND injured = 0;",
            "SELECT COUNT(location) FROM incidents WHERE subject_weapon = 'Handgun' AND subject_statuses = 'Injured' AND date BETWEEN '2006-01-01' AND '2013-12-31'"
        ],
        "rule_sql": []
    },
    "8437": {
        "db_id": "mondial_geo",
        "question": "Which nation has the highest GDP? Please give the nation's full name.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY T2.GDP DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` from the `country` table instead of `name` from the `nations` table. Do join `economy` as `T2` with an `INNER JOIN` on `T1.Code = T2.Country` instead of querying only the `nations` table. Do order by `T2.GDP DESC` instead of `gdp DESC` to reference the correct column from the joined economy table. The amended query now correctly retrieves the country name with the highest GDP by properly joining the country and economy tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM nations ORDER BY gdp DESC LIMIT 1;",
            "SELECT T1.Name \nFROM country AS T1 \nINNER JOIN economy AS T2 ON T1.Code = T2.Country \nORDER BY T2.GDP DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1903": {
        "db_id": "soccer_2016",
        "question": "Which player became the man of the series in the year 2012? Give the name and country of this player.",
        "ground_truth": "SELECT T2.Player_Name, T3.Country_Name FROM Season AS T1 INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE T1.Season_Year = 2012",
        "amends": [
            "Do reference `T2.Player_Name` and `T3.Country_Name` instead of `player_name` and `country`. Do join `Season AS T1` with `Player AS T2` on `T1.Man_of_the_Series = T2.Player_Id` instead of omitting these tables. Do add join to `Country AS T3` on `T2.Country_Name = T3.Country_Id` instead of omitting it. Do filter on `T1.Season_Year = 2012` instead of `year = 2012`. Do remove direct `man_of_series = 'yes'` filter instead of keeping it, as the join condition `T1.Man_of_the_Series = T2.Player_Id` implicitly filters for man of the series players. The amended query now correctly joins through proper table relationships to retrieve player names and countries for man of the series winners in 2012."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, country FROM players WHERE year = 2012 AND man_of_series = 'yes';",
            "SELECT T2.Player_Name, T3.Country_Name\nFROM Season AS T1\nJOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id\nJOIN Country AS T3 ON T2.Country_Name = T3.Country_Id\nWHERE T1.Season_Year = 2012"
        ],
        "rule_sql": []
    },
    "8833": {
        "db_id": "food_inspection",
        "question": "Among violations on 3rd June, 2014, describe any 5 names, located cities and tax codes of the eateries with high risk category.",
        "ground_truth": "SELECT DISTINCT T2.name, T2.city, T2.tax_code FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.risk_category = 'High Risk' AND T1.`date` = '2014-06-03' LIMIT 5",
        "amends": [
            "Do join `violations AS T1` and `businesses AS T2` instead of querying only `eateries`. Do use `INNER JOIN` on `T1.business_id = T2.business_id` instead of no join condition. Do select from joined tables instead of a single table. Do filter on `T1.risk_category = 'High Risk'` instead of `risk_category = 'Low Risk'`. Do filter on `T1.date = '2014-06-03'` instead of `violation_date = '2014-06-03'`. Do add `DISTINCT` to the select list instead of omitting it. The amended query now correctly retrieves high risk violations from the specified date with proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, city, tax_code FROM eateries WHERE violation_date = '2014-06-03' AND risk_category = 'Low Risk' LIMIT 5;",
            "SELECT DISTINCT T2.name, T2.city, T2.tax_code\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T1.date = '2014-06-03'\nAND T1.risk_category = 'High Risk'\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "5474": {
        "db_id": "menu",
        "question": "What is the name of the dish that appeared on the upper left corner on menu page no. 1389?",
        "ground_truth": "SELECT T1.name FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T2.menu_page_id = 1389 AND T2.xpos < 0.25 AND T2.ypos < 0.25",
        "amends": [
            "Do select `T1.name` instead of `dish_name` to use the correct column from the joined table. Do join `Dish AS T1` and `MenuItem AS T2` with `INNER JOIN` on `T1.id = T2.dish_id` instead of querying a single `menu` table. Do filter on `T2.menu_page_id = 1389` instead of `page_number = 1389` to use the proper foreign key column. Do add position filters `T2.xpos < 0.25 AND T2.ypos < 0.25` instead of the string-based `position = 'upper left corner'` to use numeric coordinate comparisons. The amended query now correctly joins the normalized schema tables and uses precise coordinate-based filtering instead of string matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name FROM menu WHERE page_number = 1389 AND position = 'upper left corner';",
            "SELECT T1.name \nFROM Dish AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id\nWHERE T2.menu_page_id = 1389\nAND T2.xpos < 0.25 \nAND T2.ypos < 0.25;"
        ],
        "rule_sql": []
    },
    "7365": {
        "db_id": "works_cycles",
        "question": "What is the difference in percentage between the product descriptions written in Arabic and Thai?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.Name = 'Thai' THEN 1 ELSE 0 END) FROM Culture AS T1 INNER JOIN ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID",
        "amends": [
            "Do use `SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END)` and `SUM(CASE WHEN T1.Name = 'Thai' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN language = 'Arabic' THEN 1 END)` and `COUNT(CASE WHEN language = 'Thai' THEN 1 END)` for proper counting logic. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion. Do change the calculation to `* 100 /` instead of `* 100.0 / COUNT(*)` for percentage calculation between the two language counts. Do join `Culture AS T1` with `ProductModelProductDescriptionCulture AS T2` on `T1.CultureID = T2.CultureID` instead of querying `products` table alone. Do reference `T1.Name` instead of `language` column. The amended query now correctly calculates the percentage difference between Arabic and Thai language counts using proper table relationships and aggregation logic.",
            "Do calculate `percentage_difference` as `(Arabic_count * 100) / Thai_count` instead of `(Arabic_count - Thai_count) * 100 / Arabic_count`. Do use explicit `INNER JOIN` instead of implicit `JOIN`. Do remove the `WHERE` filter `T1.Name IN ('Arabic', 'Thai')` instead of keeping it, as the CASE expressions already handle the filtering. Do remove the subtraction operation `Arabic_count - Thai_count` and division by `Arabic_count` instead of including them, as the correct calculation requires multiplying Arabic count by 100 and dividing by Thai count. The amended query now correctly calculates the percentage ratio between Arabic and Thai cultures rather than the incorrect difference percentage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN language = 'Arabic' THEN 1 END) - COUNT(CASE WHEN language = 'Thai' THEN 1 END)) * 100.0 / COUNT(*) AS percentage_difference\nFROM products;",
            "SELECT \n    (SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Name = 'Thai' THEN 1 ELSE 0 END)) * 100.0 / \n    CAST(SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END) AS REAL) AS percentage_difference\nFROM \n    Culture AS T1\nJOIN \n    ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID\nWHERE \n    T1.Name IN ('Arabic', 'Thai');",
            "SELECT \n    (SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END) * 100.0) / \n    SUM(CASE WHEN T1.Name = 'Thai' THEN 1 ELSE 0 END) AS percentage_difference\nFROM \n    Culture AS T1\nINNER JOIN \n    ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID\nWHERE \n    T1.Name IN ('Arabic', 'Thai')"
        ],
        "rule_sql": []
    },
    "9253": {
        "db_id": "movie_3",
        "question": "Of the movies in which Reese Kilmer acted, what percentage are action movies?",
        "ground_truth": "SELECT CAST(SUM(IIF(T4.name = 'Action', 1, 0)) AS REAL) * 100 / COUNT(T1.actor_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id INNER JOIN category AS T4 ON T3.category_id = T4.category_id WHERE T1.first_name = 'Reese' AND T1.last_name = 'Kilmer'",
        "amends": [
            "Do use table joins with `INNER JOIN` on `actor.actor_id=film_actor.actor_id`, `film_actor.film_id=film_category.film_id`, and `film_category.category_id=category.category_id` instead of querying a single `movies` table. Do filter on `first_name='Reese' AND last_name='Kilmer'` instead of just `actor='Reese Kilmer'`. Do calculate percentage using `CAST(SUM(IIF(name='Action',1,0)) AS REAL)*100/COUNT(actor_id)` instead of `(COUNT(CASE WHEN genre='Action' THEN 1 END)*100.0/COUNT(*))`. Do reference specific table aliases `T1`, `T2`, `T3`, `T4` instead of no table qualifications. The amended query now correctly joins multiple tables to calculate the percentage of Action films for actor Reese Kilmer."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN genre = 'Action' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_action\nFROM movies\nWHERE actor = 'Reese Kilmer';",
            "SELECT CAST(SUM(IIF(T4.name='Action',1,0)) AS REAL)*100/COUNT(T1.actor_id) AS percentage\nFROM actor T1\nINNER JOIN film_actor T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film_category T3 ON T2.film_id = T3.film_id\nINNER JOIN category T4 ON T3.category_id = T4.category_id\nWHERE T1.first_name = 'Reese' AND T1.last_name = 'Kilmer'"
        ],
        "rule_sql": []
    },
    "6234": {
        "db_id": "food_inspection_2",
        "question": "List all inspection IDs where the employee named \"Rosemary Kennedy\" was involved.",
        "ground_truth": "SELECT DISTINCT T2.inspection_id FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T1.first_name = 'Rosemary' AND T1.last_name = 'Kennedy'",
        "amends": [
            "Do use `DISTINCT T2.inspection_id` instead of `inspection_id` without distinct. Do join `employee AS T1` and `inspection AS T2` with `INNER JOIN` on `T1.employee_id = T2.employee_id` instead of querying only the `inspections` table. Do filter on `T1.first_name = 'Rosemary' AND T1.last_name = 'Kennedy'` instead of `employee_name = 'Rosemary Kennedy'` to properly match the separate first and last name fields. The amended query now correctly joins employee and inspection tables to find inspections by matching the employee's first and last name separately, ensuring it returns the intended results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_id FROM inspections WHERE employee_name = 'Rosemary Kennedy';",
            "SELECT DISTINCT T2.inspection_id\nFROM employee AS T1\nINNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nWHERE T1.first_name = 'Rosemary' AND T1.last_name = 'Kennedy'"
        ],
        "rule_sql": []
    },
    "9045": {
        "db_id": "bike_share_1",
        "question": "Which trip had the shortest duration and started at the station that can hold 15 bikes?",
        "ground_truth": "SELECT T1.id FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.dock_count = 15 AND T1.duration = ( SELECT MIN(T1.duration) FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.dock_count = 15 )",
        "amends": [
            "Do select `T1.id` instead of `trip_id, duration, start_station_id`. Do use `INNER JOIN` on `T2.name = T1.start_station_name` instead of a subquery with `IN`. Do add filter `T2.dock_count = 15` instead of `capacity = 15`. Do add condition `T1.duration = (SELECT MIN(T1.duration)...)` instead of `ORDER BY duration ASC LIMIT 1`. Do use table aliases `T1` and `T2` instead of direct table names. Do reference `trip` and `station` tables instead of `trips` and `stations`. The amended query now correctly finds the trip ID with minimum duration from stations having 15 docks, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT trip_id, duration, start_station_id \nFROM trips \nWHERE start_station_id IN (SELECT station_id FROM stations WHERE capacity = 15) \nORDER BY duration ASC \nLIMIT 1;",
            "SELECT T1.id\nFROM trip T1\nINNER JOIN station T2 ON T2.name = T1.start_station_name\nWHERE T2.dock_count = 15\nAND T1.duration = (SELECT MIN(T1.duration) FROM trip T1 INNER JOIN station T2 ON T2.name = T1.start_station_name WHERE T2.dock_count = 15)"
        ],
        "rule_sql": []
    },
    "9162": {
        "db_id": "movie_3",
        "question": "Give the address location of Heather Morris.",
        "ground_truth": "SELECT T1.address FROM address AS T1 INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE T2.first_name = 'HEATHER' AND T2.last_name = 'MORRIS'",
        "amends": [
            "Do select `T1.address` from the `address` table instead of selecting `address` from the `locations` table. Do join `customer AS T2` with `INNER JOIN` on `T1.address_id = T2.address_id` instead of querying a single table. Do filter on `T2.first_name = 'HEATHER'` and `T2.last_name = 'MORRIS'` with uppercase values instead of lowercase 'Heather' and 'Morris', and apply the filters to the customer table instead of the address table. The amended query now correctly retrieves addresses by joining customer information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM locations WHERE first_name = 'Heather' AND last_name = 'Morris';",
            "SELECT T1.address FROM address AS T1 INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE T2.first_name = 'HEATHER' AND T2.last_name = 'MORRIS'"
        ],
        "rule_sql": []
    },
    "2423": {
        "db_id": "superstore",
        "question": "In west superstore, what is the name and the shipping mode of the product that was ordered with the shortest shipment time?",
        "ground_truth": "SELECT DISTINCT T2.`Product Name`, T1.`Ship Mode` FROM west_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Region = 'West' ORDER BY T1.`Ship Date` - T1.`Order Date` LIMIT 1",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `Product Name` from the `product` table instead of `Product_Name` from `Orders`. Do use `Ship Mode` from `west_superstore` instead of `Ship_Mode` from `Orders`. Do join `west_superstore` with `product` on `Product ID` instead of querying only `Orders`. Do filter on `Region` from the `product` table instead of from `Orders`. Do remove the subquery for minimum ship time instead of keeping it. Do add ordering by shipping duration instead of omitting it, and add `LIMIT 1` instead of omitting it. The amended query now correctly retrieves the fastest-shipped product in the West region by joining relevant tables and calculating shipping duration.",
            "Do remove the `AND w.Region = p.Region` join condition instead of including it, and do move the region filter to `WHERE T2.Region = 'West'` instead of `WHERE p.Region = 'West'`. Do simplify the date calculation to `T1.Ship Date - T1.Order Date` instead of using `julianday()` functions. Do use explicit `INNER JOIN` instead of just `JOIN`, and do add table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly filters on the product table's region and calculates date differences directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Product_Name, Ship_Mode \nFROM Orders \nWHERE Ship_Time = (SELECT MIN(Ship_Time) FROM Orders) \nAND Region = 'West';",
            "SELECT DISTINCT p.\"Product Name\", w.\"Ship Mode\"\nFROM west_superstore w\nJOIN product p ON w.\"Product ID\" = p.\"Product ID\" AND w.Region = p.Region\nWHERE p.Region = 'West'\nORDER BY (julianday(w.\"Ship Date\") - julianday(w.\"Order Date\"))\nLIMIT 1;",
            "SELECT DISTINCT \n    p.\"Product Name\",\n    w.\"Ship Mode\"\nFROM west_superstore AS w\nINNER JOIN product AS p ON w.\"Product ID\" = p.\"Product ID\"\nWHERE p.Region = 'West'\nORDER BY (w.\"Ship Date\" - w.\"Order Date\") ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8526": {
        "db_id": "software_company",
        "question": "Among the customers who come from the place with 25746 inhabitants, how many of them are male?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T2.INHABITANTS_K = 25.746 AND T1.SEX = 'Male'",
        "amends": [
            "Do reference `T1.ID` in the COUNT instead of `*` to count specific non-null values. Do join `Customers AS T1` with `Demog AS T2` on `T1.GEOID = T2.GEOID` instead of querying a single table. Do filter on `T2.INHABITANTS_K = 25.746` instead of `inhabitants = 25746` to use the correct column name and decimal value format. Do filter on `T1.SEX = 'Male'` instead of `gender = 'male'` to use the correct column name and case-sensitive value. The amended query now correctly joins demographic data and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE inhabitants = 25746 AND gender = 'male';",
            "SELECT COUNT(T1.ID) \nFROM Customers AS T1\nJOIN Demog AS T2 ON T1.GEOID = T2.GEOID\nWHERE T2.INHABITANTS_K = 25.746 AND T1.SEX = 'Male'"
        ],
        "rule_sql": []
    },
    "1919": {
        "db_id": "soccer_2016",
        "question": "List all Zimbabwean players.",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id WHERE T2.Country_Name = 'Zimbabwea'",
        "amends": [
            "Do use explicit column selection `T1.Player_Name` instead of wildcard `*`. Do join tables with `INNER JOIN Country AS T2` instead of querying a single table. Do specify join condition `ON T1.Country_Name = T2.Country_Id` instead of direct column filtering. Do filter on `T2.Country_Name = 'Zimbabwea'` instead of `country = 'Zimbabwe'` to properly reference the normalized country name through the relationship. The amended query now correctly joins tables and filters through the relationship to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM players WHERE country = 'Zimbabwe';",
            "SELECT T1.Player_Name\nFROM Player AS T1\nINNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id\nWHERE T2.Country_Name = 'Zimbabwea'"
        ],
        "rule_sql": []
    },
    "3404": {
        "db_id": "video_games",
        "question": "What is the genre of the game \"Mario vs. Donkey Kong\"?",
        "ground_truth": "SELECT T1.genre_name FROM genre AS T1 INNER JOIN game AS T2 ON T1.id = T2.genre_id WHERE T2.game_name = 'Mario vs. Donkey Kong'",
        "amends": [
            "Do select `T1.genre_name` from the `genre` table instead of `genre` from the `games` table. Do join `genre AS T1` with `game AS T2` using `INNER JOIN` on `T1.id = T2.genre_id` instead of querying a single table. Do filter on `T2.game_name = 'Mario vs. Donkey Kong'` instead of `title = 'Mario vs. Donkey Kong'` to reference the correct column name and table relationship. The amended query now correctly retrieves genre information through proper table relationships and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE title = 'Mario vs. Donkey Kong';",
            "SELECT T1.genre_name \nFROM genre AS T1 \nINNER JOIN game AS T2 ON T1.id = T2.genre_id \nWHERE T2.game_name = 'Mario vs. Donkey Kong'"
        ],
        "rule_sql": []
    },
    "3172": {
        "db_id": "donor",
        "question": "What is the total amount of all the donations made by the donor who made the highest donation in a single amount? Indicate the essay title to where he/she made his/her biggest donation.",
        "ground_truth": "SELECT T2.donation_total, T1.title FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.donation_total = ( SELECT MAX(donation_total) FROM donations )",
        "amends": [
            "Do select `T2.donation_total` and `T1.title` instead of `d.donor_name`, `SUM(d.amount) as total_donations`, and `e.title as essay_title`. Do join `essays AS T1` with `donations AS T2` on `T1.projectid = T2.projectid` instead of joining `donations d` with `essays e` on `d.essay_id = e.id`. Do filter on `T2.donation_total = (SELECT MAX(donation_total) FROM donations)` instead of `d.amount = (SELECT MAX(amount) FROM donations)`. Do remove `GROUP BY d.donor_name, e.title` instead of keeping it. The amended query now correctly identifies maximum donations by project rather than by donor and essay, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.donor_name, SUM(d.amount) as total_donations, e.title as essay_title\nFROM donations d\nJOIN essays e ON d.essay_id = e.id\nWHERE d.amount = (SELECT MAX(amount) FROM donations)\nGROUP BY d.donor_name, e.title;",
            "SELECT T2.donation_total, T1.title\nFROM essays AS T1\nJOIN donations AS T2 ON T1.projectid = T2.projectid\nWHERE T2.donation_total = (SELECT MAX(donation_total) FROM donations)"
        ],
        "rule_sql": []
    },
    "3388": {
        "db_id": "video_games",
        "question": "Name the game released in 2011.",
        "ground_truth": "SELECT T3.game_name FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T1.release_year = 2011",
        "amends": [
            "Do select `T3.game_name` instead of `name` and change the source table structure completely. Do add `INNER JOIN game_platform AS T1` instead of querying `games` directly. Do add `INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id` instead of missing this join relationship. Do add `INNER JOIN game AS T3 ON T2.game_id = T3.id` instead of not joining to the game table. Do change the filter to `T1.release_year = 2011` instead of `release_year = 2010`, both correcting the year value and specifying the table alias. The amended query now correctly joins through the proper table relationships and filters on the correct year in the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE release_year = 2010;",
            "SELECT T3.game_name\nFROM game_platform AS T1\nINNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id\nINNER JOIN game AS T3 ON T2.game_id = T3.id\nWHERE T1.release_year = 2011"
        ],
        "rule_sql": []
    },
    "4669": {
        "db_id": "disney",
        "question": "Who voiced the villain in \"The Rescuers\"?",
        "ground_truth": "SELECT T1.`voice-actor` FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T2.movie_title = T1.movie WHERE T2.movie_title = 'The Rescuers' AND T1.character = T2.villian",
        "amends": [
            "Do select `T1.voice-actor` instead of `actor_name`. Do use `FROM voice-actors AS T1 INNER JOIN characters AS T2` instead of `FROM actors` alone. Do add join condition `ON T2.movie_title = T1.movie` instead of omitting it. Do change filter to `T2.movie_title = 'The Rescuers'` instead of `movie_title = 'The Rescuers'`. Do add additional filter `T1.character = T2.villian` instead of `character_type = 'hero'`. The amended query now correctly joins voice actors with characters and filters for the specific movie and villain relationship, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE movie_title = 'The Rescuers' AND character_type = 'hero';",
            "SELECT T1.\"voice-actor\" FROM \"voice-actors\" AS T1 INNER JOIN characters AS T2 ON T2.movie_title = T1.movie WHERE T2.movie_title = 'The Rescuers' AND T1.character = T2.villian"
        ],
        "rule_sql": []
    },
    "1221": {
        "db_id": "talkingdata",
        "question": "Please list any five app categories that are related to games, along with their label ID.",
        "ground_truth": "SELECT category, label_id FROM label_categories WHERE category LIKE '%game%' LIMIT 5",
        "amends": [
            "Do query from `label_categories` table instead of `app_categories` table. The amended query now correctly retrieves category and label_id data from the appropriate table while maintaining the same filtering and limiting behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, label_id FROM app_categories WHERE category LIKE '%game%' LIMIT 5;",
            "SELECT category, label_id FROM label_categories WHERE category LIKE '%game%' LIMIT 5;"
        ],
        "rule_sql": []
    },
    "2117": {
        "db_id": "world_development_indicators",
        "question": "List down the World Bank code of the countries whose country note has described \"Data source : Human Mortality Database by University of California, Berkeley, and Max Planck Institute for Demographic Research.\"? Please include their lending category.",
        "ground_truth": "SELECT DISTINCT T1.Wb2code, T1.LendingCategory FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Data source : Human Mortality Database by University of California, Berkeley, and Max Planck Institute for Demographic Research.' AND T1.LendingCategory != ''",
        "amends": [
            "Do use `DISTINCT T1.Wb2code, T1.LendingCategory` instead of `country_code, lending_category` with different column names. Do join `Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode` instead of querying only the `countries` table. Do filter with `T2.Description = 'Data source : Human Mortality Database by University of California, Berkeley, and Max Planck Institute for Demographic Research.'` instead of `country_note LIKE '%Data source : Human Mortality Database by University of California, Berkeley, and Max Planck Institute for Demographic Research.%'` using exact match rather than pattern matching. Do add `AND T1.LendingCategory != ''` instead of omitting the non-empty lending category filter. The amended query now correctly joins tables and uses precise filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code, lending_category FROM countries WHERE country_note LIKE '%Data source : Human Mortality Database by University of California, Berkeley, and Max Planck Institute for Demographic Research.%';",
            "SELECT DISTINCT T1.Wb2Code, T1.LendingCategory\nFROM Country AS T1\nINNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T2.Description = 'Data source : Human Mortality Database by University of California, Berkeley, and Max Planck Institute for Demographic Research.'\nAND T1.LendingCategory != ''"
        ],
        "rule_sql": []
    },
    "967": {
        "db_id": "computer_student",
        "question": "What is the average number of students for each advisor?",
        "ground_truth": "SELECT CAST(COUNT(p_id) AS REAL) / COUNT(DISTINCT p_id_dummy) AS avgnum FROM advisedBy GROUP BY p_id_dummy",
        "amends": [
            "Do use `CAST(COUNT(p_id) AS REAL) / COUNT(DISTINCT p_id_dummy) AS avgnum` instead of `advisor_id, COUNT(student_id)` for the SELECT list. Do change the FROM source to `advisedBy` instead of `students`. Do add `GROUP BY p_id_dummy` instead of `GROUP BY advisor_id`. Do remove the explicit column selection and instead calculate an average ratio using casting and distinct counting. The amended query now correctly computes an average value per grouping dimension rather than simple counts per advisor.",
            "Do remove `p_id_dummy` from the SELECT list instead of including it, as the aggregate calculation `CAST(COUNT(p_id) AS REAL) / COUNT(DISTINCT p_id_dummy)` already provides the desired result without needing to display the grouping column directly. The amended query now correctly focuses on the computed average metric rather than exposing the grouping key in the output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT advisor_id, COUNT(student_id) FROM students GROUP BY advisor_id;",
            "SELECT p_id_dummy, CAST(COUNT(p_id) AS REAL) / COUNT(DISTINCT p_id_dummy) AS avgnum FROM advisedBy GROUP BY p_id_dummy",
            "SELECT CAST(COUNT(p_id) AS REAL) / COUNT(DISTINCT p_id_dummy) AS avgnum FROM advisedBy GROUP BY p_id_dummy"
        ],
        "rule_sql": []
    },
    "5374": {
        "db_id": "sales",
        "question": "List down the first name of customers who placed order for product id 1.",
        "ground_truth": "SELECT T1.FirstName FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T2.ProductID = 1",
        "amends": [
            "Do add `INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID` and `INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID` instead of querying only the `customers` table. Do change the column reference to `T1.FirstName` instead of `first_name` and use table alias `T1` for the `Customers` table. Do move the filter condition to reference `T2.ProductID = 1` instead of `product_id = 1` to properly filter through the joined Sales table. The amended query now correctly joins through the Sales table to establish the relationship between customers and products, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE product_id = 1;",
            "SELECT T1.FirstName \nFROM Customers AS T1\nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID\nWHERE T2.ProductID = 1"
        ],
        "rule_sql": []
    },
    "2629": {
        "db_id": "regional_sales",
        "question": "What is the average unit price of a Cookware product?",
        "ground_truth": "SELECT AVG(REPLACE(T1.`Unit Price`, ',', '')) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T2.`Product Name` = 'Cookware'",
        "amends": [
            "Do use `AVG(REPLACE(T1.Unit Price, ',', ''))` instead of `AVG(price)` to handle comma-formatted numeric values. Do join `Sales Orders AS T1` with `Products AS T2` on `T2.ProductID = T1._ProductID` instead of querying only the products table. Do filter on `T2.Product Name = 'Cookware'` instead of `category = 'Cookware'` to use the correct column name and table reference. Do remove the simple table query approach and instead implement a proper join between sales and product tables to ensure accurate average calculation based on actual sales data rather than product list prices. The amended query now correctly calculates the average unit price for Cookware products from sales transactions with proper numeric formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE category = 'Cookware';",
            "SELECT AVG(REPLACE(T1.\"Unit Price\", ',', '')) AS AverageUnitPrice\nFROM \"Sales Orders\" AS T1\nJOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE T2.\"Product Name\" = 'Cookware'"
        ],
        "rule_sql": []
    },
    "1389": {
        "db_id": "synthea",
        "question": "How many patients are allergic to eggs?",
        "ground_truth": "SELECT COUNT(PATIENT) FROM allergies WHERE DESCRIPTION = 'Allergy to eggs'",
        "amends": [
            "Do query the `allergies` table instead of the `patients` table. Do count the `PATIENT` column instead of using `COUNT(*)`. Do filter on `DESCRIPTION = 'Allergy to eggs'` instead of `allergy = 'eggs'`. The amended query now correctly counts patients with egg allergies from the appropriate allergies table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE allergy = 'eggs';",
            "SELECT COUNT(DISTINCT PATIENT) FROM allergies WHERE DESCRIPTION = 'Allergy to eggs'"
        ],
        "rule_sql": []
    },
    "8611": {
        "db_id": "chicago_crime",
        "question": "Which district had the most number of first degree murders? Give the district number.",
        "ground_truth": "SELECT T2.district_no FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T1.secondary_description = 'FIRST DEGREE MURDER' GROUP BY T2.district_no ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `T2.district_no` instead of `district` to specify the exact column source. Do add `FROM IUCR AS T1 INNER JOIN Crime AS T2` instead of a single table to properly join the crime and IUCR data. Do add join condition `ON T1.iucr_no = T2.iucr_no` instead of missing the relationship between tables. Do add filter `WHERE T1.secondary_description = 'FIRST DEGREE MURDER'` instead of relying on `first_degree_murders` which doesn't exist. Do add `GROUP BY T2.district_no` instead of omitting grouping to aggregate by district. Do change ordering to `ORDER BY COUNT(*) DESC` instead of `ORDER BY first_degree_murders DESC` to count actual murder occurrences. The amended query now correctly identifies the district with the most first degree murders by joining appropriate tables and counting occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM crimes ORDER BY first_degree_murders DESC LIMIT 1;",
            "SELECT T2.district_no\nFROM IUCR AS T1\nINNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no\nWHERE T1.secondary_description = 'FIRST DEGREE MURDER'\nGROUP BY T2.district_no\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6846": {
        "db_id": "retails",
        "question": "Name of customer whose order is applied with the highest discount.",
        "ground_truth": "SELECT T3.c_name FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey INNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey ORDER BY T2.l_discount DESC LIMIT 1",
        "amends": [
            "Do join `orders` and `lineitem` on `o_orderkey = l_orderkey` instead of querying `customers` alone, then join `customer` on `o_custkey = c_custkey` instead of omitting these tables. Do select `T3.c_name` instead of `customer_name` from the wrong table. Do order by `T2.l_discount` instead of `discount` to use the correct discount column from lineitems. The amended query now correctly identifies the customer with the highest order discount by properly joining through the order-lineitem relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY discount DESC LIMIT 1;",
            "SELECT c.c_name\nFROM customer c\nJOIN orders o ON c.c_custkey = o.o_custkey\nJOIN lineitem l ON o.o_orderkey = l.l_orderkey\nORDER BY l.l_discount DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5983": {
        "db_id": "books",
        "question": "Sum the total price of the orders for The Prophet book.",
        "ground_truth": "SELECT SUM(T1.price) FROM order_line AS T1 INNER JOIN book AS T2 ON T1.book_id = T2.book_id WHERE T2.title = 'The Prophet'",
        "amends": [
            "Do specify the table alias `T1.price` instead of just `price` in the SELECT list. Do join `order_line AS T1` with `book AS T2` on `T1.book_id = T2.book_id` instead of querying only the `orders` table. Do filter on `T2.title = 'The Prophet'` instead of `book_title = 'The Prophet'` to correctly reference the book title from the joined table. The amended query now properly aggregates prices from order_line records that correspond to the specified book title through the correct table relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE book_title = 'The Prophet';",
            "SELECT SUM(T1.price) AS total_price\nFROM order_line AS T1\nJOIN book AS T2 ON T1.book_id = T2.book_id\nWHERE T2.title = 'The Prophet'"
        ],
        "rule_sql": []
    },
    "4900": {
        "db_id": "legislator",
        "question": "Which current legislator has served for more terms, Sherrod Brown or Maria Cantwell?",
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.official_full_name = 'Maria Cantwell' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.official_full_name = 'Sherrod Brown' THEN 1 ELSE 0 END) THEN 'Maria Cantwell' ELSE 'Sherrod Brown' END FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide",
        "amends": [
            "Do use `CASE` expressions with conditional aggregation to compare term counts instead of selecting names directly with `COUNT`. Do reference `official_full_name` instead of `name` for the column comparison. Do join `current` table as `T1` with `current-terms` table as `T2` on `bioguide_id` instead of querying a single `legislators` table. Do use `SUM` with conditional logic to count occurrences of each name instead of `COUNT(term_id)` with `GROUP BY`. Do remove the `GROUP BY`, `ORDER BY`, and `LIMIT` clauses since the conditional aggregation returns a single row comparison result instead of multiple grouped rows. Do reference the correct table aliases `T1` and `T2` throughout the query instead of direct table references. The amended query now correctly compares term counts between the two legislators and returns the name with more terms served, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(term_id) as terms_served \nFROM legislators \nWHERE name IN ('Sherrod Brown', 'Maria Cantwell') \nGROUP BY name \nORDER BY terms_served DESC \nLIMIT 1;",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN T1.official_full_name = 'Sherrod Brown' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.official_full_name = 'Maria Cantwell' THEN 1 ELSE 0 END) THEN 'Sherrod Brown'\n        WHEN SUM(CASE WHEN T1.official_full_name = 'Sherrod Brown' THEN 1 ELSE 0 END) < SUM(CASE WHEN T1.official_full_name = 'Maria Cantwell' THEN 1 ELSE 0 END) THEN 'Maria Cantwell'\n        ELSE 'Equal terms'\n    END AS legislator_with_more_terms\nFROM \n    current T1\nJOIN \n    \"current-terms\" T2 ON T1.bioguide_id = T2.bioguide"
        ],
        "rule_sql": []
    },
    "3341": {
        "db_id": "video_games",
        "question": "For all the games which were published by Namco Bandai Games, what percentage of them were adventure games?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T4.genre_name = 'Adventure' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE T3.publisher_name = 'Namco Bandai Games'",
        "amends": [
            "Do join multiple tables including `game`, `game_publisher`, `publisher`, and `genre` instead of querying only the `games` table. Do reference `T4.genre_name` instead of `genre` and `T3.publisher_name` instead of `publisher`. Do use explicit `INNER JOIN` conditions with proper foreign key relationships (`T1.id = T2.game_id`, `T2.publisher_id = T3.id`, `T1.genre_id = T4.id`) instead of assuming direct column access. Do count `T1.id` instead of using `COUNT(*)` for more precise aggregation. Do cast the count to `REAL` instead of using decimal notation for proper floating-point division. Do handle the CASE expression with `ELSE NULL` instead of omitting the ELSE clause. The amended query now correctly calculates the percentage of Adventure games published by Namco Bandai Games using proper table relationships and data types."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN genre = 'Adventure' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM games\nWHERE publisher = 'Namco Bandai Games';",
            "SELECT \n    (CAST(COUNT(CASE WHEN T4.genre_name = 'Adventure' THEN T1.id ELSE NULL END) AS REAL) / COUNT(T1.id)) * 100.0 AS percentage\nFROM \n    game T1\n    INNER JOIN game_publisher T2 ON T1.id = T2.game_id\n    INNER JOIN publisher T3 ON T2.publisher_id = T3.id\n    INNER JOIN genre T4 ON T1.genre_id = T4.id\nWHERE \n    T3.publisher_name = 'Namco Bandai Games';"
        ],
        "rule_sql": []
    },
    "4829": {
        "db_id": "legislator",
        "question": "List the full name of legislators whose born in 1960.",
        "ground_truth": "SELECT official_full_name FROM current WHERE birthday_bio LIKE '1960%'",
        "amends": [
            "Do select `official_full_name` instead of `first_name, last_name` and use the `current` table instead of `legislators`. Do filter with `birthday_bio LIKE '1960%'` instead of `born = '1960'` to match partial year patterns rather than exact string equality. The amended query now correctly retrieves full names from the current table using appropriate birthday filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM legislators WHERE born = '1960';",
            "SELECT official_full_name FROM current WHERE birthday_bio LIKE '1960%'"
        ],
        "rule_sql": []
    },
    "935": {
        "db_id": "cs_semester",
        "question": "Among professors with the highest popularity, how many of their students have research capability of 5?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T1.capability = 5 ORDER BY T2.popularity DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(T1.student_id)` instead of `COUNT(*)` to count specific student records. Do reference tables `RA AS T1` and `prof AS T2` instead of `students s` and `professors p` with different table aliases. Do join on `T1.prof_id = T2.prof_id` instead of `s.professor_id = p.professor_id` with different column names. Do filter on `T1.capability = 5` instead of `s.research_capability = 5` with a different column name. Do completely remove the subquery for maximum popularity and instead add `ORDER BY T2.popularity DESC LIMIT 1` to get the count for the most popular professor's students. Do add explicit ordering and limiting instead of using a subquery comparison. The amended query now correctly counts students with capability 5 for the most popular professor by using ordering and limiting rather than a subquery comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students s\nJOIN professors p ON s.professor_id = p.professor_id\nWHERE s.research_capability = 5\nAND p.popularity = (SELECT MAX(popularity) FROM professors);",
            "SELECT COUNT(T1.student_id) \nFROM RA AS T1 \nJOIN prof AS T2 ON T1.prof_id = T2.prof_id \nWHERE T1.capability = 5 \nORDER BY T2.popularity DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5517": {
        "db_id": "menu",
        "question": "List down the page numbers for menu with dishes on the right upper corner.",
        "ground_truth": "SELECT T2.page_number FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id INNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id WHERE T3.xpos > 0.75 AND T3.ypos < 0.25",
        "amends": [
            "Do add `T2.page_number` in the SELECT list instead of `page_number` alone. Do change the FROM clause to use `Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id INNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id` instead of a single `menus` table. Do add WHERE conditions `T3.xpos > 0.75 AND T3.ypos < 0.25` instead of `dish_location = 'left lower corner'`. The amended query now correctly joins multiple tables and uses precise coordinate-based filtering instead of text-based location matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_number FROM menus WHERE dish_location = 'left lower corner';",
            "SELECT T2.page_number\nFROM Menu AS T1 \nINNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id \nINNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id\nWHERE T3.xpos > 0.75 AND T3.ypos < 0.25;"
        ],
        "rule_sql": []
    },
    "4432": {
        "db_id": "student_loan",
        "question": "State name of disabled students who have the longest duration of absense from school.",
        "ground_truth": "SELECT T1.name FROM disabled AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name ORDER BY T2.month DESC LIMIT 1",
        "amends": [
            "Do select `T1.name` with table alias instead of `name` without qualification. Do use `FROM disabled AS T1` joined with `longest_absense_from_school AS T2` instead of querying `students` table directly. Do perform `INNER JOIN` on `T1.name = T2.name` instead of filtering with `WHERE disabled = 1`. Do order by `T2.month DESC` instead of `absence_duration DESC`. The amended query now correctly joins the disabled students table with absence duration data to find the student with the longest absence period."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE disabled = 1 ORDER BY absence_duration DESC LIMIT 1;",
            "SELECT T1.name\nFROM disabled AS T1\nINNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name\nORDER BY T2.month DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7546": {
        "db_id": "image_and_language",
        "question": "Indicate the bounding box of the image 8.",
        "ground_truth": "SELECT X, Y, W, H FROM IMG_OBJ WHERE IMG_ID = 8",
        "amends": [
            "Do select specific columns `X, Y, W, H` instead of using `*` to select all columns. Do reference table `IMG_OBJ` instead of `images` as the data source. Do use column name `IMG_ID` instead of `image_id` in the WHERE filter condition while maintaining the same filter value of `8`. The amended query now correctly retrieves only the specified dimensional attributes from the appropriate table while matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM images WHERE image_id = 8;",
            "SELECT X, Y, W, H FROM IMG_OBJ WHERE IMG_ID = 8"
        ],
        "rule_sql": []
    },
    "3429": {
        "db_id": "video_games",
        "question": "How many games include the word 'Box' in their name?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T.game_name FROM game AS T WHERE T.game_name LIKE '%Box%' )",
        "amends": [
            "Do reference the table as `game AS T` instead of `games`, do use the column `T.game_name` in the WHERE filter instead of `name`, and do wrap the filtered query in a subquery instead of querying the table directly. The amended query now correctly counts rows from the filtered subquery matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE name LIKE '%Box%';",
            "SELECT COUNT(*) FROM (SELECT * FROM game AS T WHERE T.game_name LIKE '%Box%') AS filtered_games;"
        ],
        "rule_sql": []
    },
    "1712": {
        "db_id": "restaurant",
        "question": "Please name any three restaurants that have an unidentified region.",
        "ground_truth": "SELECT T2.label FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant INNER JOIN geographic AS T3 ON T2.city = T3.city WHERE T3.region = 'unknown' LIMIT 3",
        "amends": [
            "Do select `T2.label` from the `generalinfo` table instead of `name` from `restaurants`. Do join `location AS T1` on `T1.id_restaurant = T2.id_restaurant` and `geographic AS T3` on `T2.city = T3.city` instead of querying a single table. Do filter on `T3.region = 'unknown'` instead of checking `region IS NULL`. The amended query now correctly retrieves restaurant labels from joined tables based on geographic region classification rather than null checks."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE region IS NULL LIMIT 3;",
            "SELECT T2.label \nFROM generalinfo AS T2\nJOIN location AS T1 ON T1.id_restaurant = T2.id_restaurant\nJOIN geographic AS T3 ON T2.city = T3.city\nWHERE T3.region = 'unknown'\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "4535": {
        "db_id": "student_loan",
        "question": "Mention the status of payment of student 299.",
        "ground_truth": "SELECT bool FROM no_payment_due WHERE name = 'student299'",
        "amends": [
            "Do select `bool` from the `no_payment_due` table instead of `payment_status` from the `students` table. Do filter by `name = 'student299'` instead of `student_id = 299`. The amended query now correctly retrieves payment status information from the appropriate table using the correct identifier format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_status FROM students WHERE student_id = 299;",
            "SELECT bool FROM no_payment_due WHERE name = 'student299'"
        ],
        "rule_sql": []
    },
    "2050": {
        "db_id": "music_tracker",
        "question": "Name all the release titles of the \"ep's\" under the alternative tag.",
        "ground_truth": "SELECT T1.groupName FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag LIKE 'alternative' AND T1.releaseType = 'ep'",
        "amends": [
            "Do select `T1.groupName` instead of `title` and change the FROM source to `torrents AS T1` instead of `releases`. Do add an `INNER JOIN` on `tags AS T2` with predicate `T1.id = T2.id` instead of no join. Do change the WHERE filter to `T2.tag LIKE 'alternative' AND T1.releaseType = 'ep'` instead of `tag = 'ep'`, adding both the tag condition and releaseType filter. The amended query now correctly joins torrents with tags and filters for alternative tags with ep release type, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM releases WHERE tag = 'ep'",
            "SELECT T1.groupName FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag LIKE 'alternative' AND T1.releaseType = 'ep'"
        ],
        "rule_sql": []
    },
    "8415": {
        "db_id": "mondial_geo",
        "question": "Which country with a city with a population between 50,000 and 300,000 inhabitants and which is a member of an organization established between 03/01/1991 and 04/30/1991 is also a member of the EBRD?",
        "ground_truth": "SELECT T2.Country FROM country AS T1 INNER JOIN isMember AS T2 ON T1.Code = T2.Country INNER JOIN organization AS T3 ON T3.Country = T2.Country INNER JOIN city AS T4 ON T4.Country = T3.Country WHERE T3.Abbreviation = 'EBRD' AND T4.Population BETWEEN 50000 AND 300000 AND T3.Established BETWEEN '1991-01-31' AND '1991-04-30'",
        "amends": [
            "Do select `T2.Country` instead of `c.name` and use table aliases `T1`, `T2`, `T3`, `T4` instead of `c`, `ct`, `im`, `o`. Do join `isMember AS T2` on `T1.Code = T2.Country` instead of `is_member im` on `c.code = im.country_code`. Do join `organization AS T3` on `T3.Country = T2.Country` instead of `organization o` on `im.organization_id = o.id`. Do join `city AS T4` on `T4.Country = T3.Country` instead of `city ct` on `c.code = ct.country_code`. Do filter on `T3.Abbreviation = 'EBRD'` instead of `o.name = 'EBRD'`. Do filter on `T3.Established BETWEEN '1991-01-31' AND '1991-04-30'` instead of `o.established_date BETWEEN '1991-03-01' AND '1991-04-30'`. The amended query now correctly filters by organization abbreviation rather than name, uses proper join conditions between related tables, and adjusts the date range to match the intended logic.",
            "Do join `organization AS T3` on `T3.Country = T2.Country` instead of `T3.Abbreviation = T2.Organization` to correctly link organizations by country rather than abbreviation. Do join `city AS T4` on `T4.Country = T3.Country` instead of `T4.Country = T1.Code` to ensure cities are filtered by the organization's country rather than the base country table. Do remove the `GROUP BY T2.Country` clause instead of keeping it since the query no longer requires aggregation. The amended query now correctly filters cities based on the organization's country membership and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM country c\nJOIN city ct ON c.code = ct.country_code\nJOIN is_member im ON c.code = im.country_code\nJOIN organization o ON im.organization_id = o.id\nWHERE ct.population BETWEEN 50000 AND 300000\nAND o.established_date BETWEEN '1991-03-01' AND '1991-04-30'\nAND o.name = 'EBRD';",
            "SELECT T2.Country\nFROM country AS T1\nJOIN isMember AS T2 ON T1.Code = T2.Country\nJOIN organization AS T3 ON T3.Abbreviation = T2.Organization\nJOIN city AS T4 ON T4.Country = T1.Code\nWHERE T3.Abbreviation = 'EBRD'\nAND T3.Established BETWEEN '1991-01-31' AND '1991-04-30'\nAND T4.Population BETWEEN 50000 AND 300000\nGROUP BY T2.Country",
            "SELECT T2.Country\nFROM country AS T1\nJOIN isMember AS T2 ON T1.Code = T2.Country\nJOIN organization AS T3 ON T3.Country = T2.Country\nJOIN city AS T4 ON T4.Country = T3.Country\nWHERE T3.Abbreviation = 'EBRD'\nAND T3.Established BETWEEN '1991-01-31' AND '1991-04-30'\nAND T4.Population BETWEEN 50000 AND 300000\nGROUP BY T2.Country"
        ],
        "rule_sql": []
    },
    "7867": {
        "db_id": "world",
        "question": "List all the cities in the country where there is high life expectancy at birth.",
        "ground_truth": "SELECT T2.Name FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY T1.LifeExpectancy DESC LIMIT 1",
        "amends": [
            "Do select `T2.Name` instead of `city_name`. Do use `INNER JOIN` on `T1.Code = T2.CountryCode` instead of a subquery with `country_id IN`. Do add `ORDER BY T1.LifeExpectancy DESC LIMIT 1` instead of filtering by `life_expectancy > 100` without ordering or limiting. Do reference tables as `Country AS T1` and `City AS T2` instead of `cities` and `countries`. The amended query now correctly retrieves the city from the country with the highest life expectancy instead of all cities from countries with life expectancy over 100."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE country_id IN (SELECT country_id FROM countries WHERE life_expectancy > 100);",
            "SELECT T2.Name \nFROM Country AS T1 \nINNER JOIN City AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Code = (\n    SELECT Code \n    FROM Country \n    ORDER BY LifeExpectancy DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "4385": {
        "db_id": "student_loan",
        "question": "Name all students enlisted in the foreign legion.",
        "ground_truth": "SELECT name FROM enlist WHERE organ = 'foreign_legion'",
        "amends": [
            "Do select `name` from the `enlist` table instead of selecting all columns from the `students` table. Do filter on `organ = 'foreign_legion'` instead of filtering on `legion = 'foreign'`. The amended query now correctly retrieves names from the enlist table for the foreign_legion organ, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE legion = 'foreign';",
            "SELECT name FROM enlist WHERE organ = 'foreign_legion'"
        ],
        "rule_sql": []
    },
    "1590": {
        "db_id": "car_retails",
        "question": "Between 8/1/2003 and 8/30/2004, how many checks were issued by Mini Gifts Distributors Ltd.? Please list their check numbers.",
        "ground_truth": "SELECT T1.checkNumber FROM payments AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE T1.paymentDate >= '2003-08-01' AND T1.paymentDate <= '2004-08-30' AND T2.customerName = 'Mini Gifts Distributors Ltd.'",
        "amends": [
            "Do query the `payments` table instead of `checks`, and join with `customers` on `customerNumber` instead of querying a single table. Do select `checkNumber` instead of `COUNT(*)` and `check_number`, removing the aggregate function. Do filter on `customerName` instead of `company_name` for the customer condition. Do use `paymentDate` range filtering with `>=` and `<=` instead of `BETWEEN` for the date range. Do remove the alias `T1` from the column selection instead of keeping it. The amended query now correctly retrieves payment check numbers for the specified customer within the date range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as check_count, check_number \nFROM checks \nWHERE company_name = 'Mini Gifts Distributors Ltd.' \nAND issue_date BETWEEN '2003-08-01' AND '2004-08-30';",
            "SELECT checkNumber FROM payments JOIN customers ON payments.customerNumber = customers.customerNumber WHERE customerName = 'Mini Gifts Distributors Ltd.' AND paymentDate >= '2003-08-01' AND paymentDate <= '2004-08-30'"
        ],
        "rule_sql": []
    },
    "3409": {
        "db_id": "video_games",
        "question": "List the games from the publisher \"Activision\".",
        "ground_truth": "SELECT T3.game_name FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T1.publisher_name = 'Activision'",
        "amends": [
            "Do select `T3.game_name` instead of `*` to specify the exact column needed. Do use `INNER JOIN` with `publisher AS T1` instead of querying `games` directly to properly relate tables through the junction table. Do add `game_publisher AS T2` as a joining table instead of omitting it to connect publishers to games. Do join on `T1.id = T2.publisher_id` and `T2.game_id = T3.id` instead of a single table filter to establish proper relationships. Do filter on `T1.publisher_name = 'Activision'` instead of `publisher = 'Ubisoft'` to correct both the publisher name and column reference. The amended query now correctly retrieves game names for the specified publisher through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM games WHERE publisher = 'Ubisoft';",
            "SELECT T3.game_name \nFROM publisher AS T1\nINNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id\nINNER JOIN game AS T3 ON T2.game_id = T3.id\nWHERE T1.publisher_name = 'Activision'"
        ],
        "rule_sql": []
    },
    "1064": {
        "db_id": "talkingdata",
        "question": "Provide the app users IDs and time for the event ID of 82.",
        "ground_truth": "SELECT T1.app_id, T2.timestamp FROM app_events AS T1 INNER JOIN events AS T2 ON T2.event_id = T1.event_id WHERE T2.event_id = 82",
        "amends": [
            "Do select `T1.app_id` and `T2.timestamp` instead of `user_id` and `event_time`. Do use `FROM app_events AS T1 INNER JOIN events AS T2` instead of `FROM events` alone. Do add join condition `ON T2.event_id = T1.event_id` instead of omitting any join. Do keep `WHERE T2.event_id = 82` filter but apply it to the joined table instead of the original single table. The amended query now correctly joins the two tables and selects the appropriate columns while maintaining the same event filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, event_time FROM events WHERE event_id = 82",
            "SELECT T1.app_id, T2.timestamp FROM app_events AS T1 INNER JOIN events AS T2 ON T2.event_id = T1.event_id WHERE T2.event_id = 82"
        ],
        "rule_sql": []
    },
    "7048": {
        "db_id": "works_cycles",
        "question": "How many assembly items for bicycles aren't finished?",
        "ground_truth": "SELECT COUNT(BillOfMaterialsID) FROM BillOfMaterials WHERE EndDate IS NULL",
        "amends": [
            "Do count `BillOfMaterialsID` instead of counting all rows with `COUNT(*)`. Do query from `BillOfMaterials` table instead of `assembly_items` table. Do filter for `EndDate IS NULL` instead of filtering for `item_type = 'bicycle' AND status != 'finished'`. The amended query now correctly counts active bill of materials records rather than unfinished bicycle assembly items, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM assembly_items WHERE item_type = 'bicycle' AND status != 'finished';",
            "SELECT COUNT(BillOfMaterialsID) FROM BillOfMaterials WHERE EndDate IS NULL;"
        ],
        "rule_sql": []
    },
    "7733": {
        "db_id": "hockey",
        "question": "Which year recorded the most number of goals by a player and how old was the player at the time the most number of goals was achieved by him?",
        "ground_truth": "SELECT T1.year, T1.year - T2.birthYear FROM Scoring AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID GROUP BY T1.year, T1.year - T2.birthYear ORDER BY SUM(T1.G) DESC LIMIT 1",
        "amends": [
            "Do select `T1.year` and `T1.year - T2.birthYear` instead of `year` and `age`. Do use `FROM Scoring AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID` instead of `FROM players` with a subquery. Do add `GROUP BY T1.year, T1.year - T2.birthYear` instead of omitting grouping. Do use `ORDER BY SUM(T1.G) DESC LIMIT 1` instead of `WHERE goals = (SELECT MAX(goals) FROM players)`. Do remove the subquery filter and instead calculate maximum goals through ordering and limiting. The amended query now correctly joins player scoring data with master birth information, groups by year and calculated age, and returns the year and age combination with the highest total goals."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, age FROM players WHERE goals = (SELECT MAX(goals) FROM players);",
            "SELECT T1.year, T1.year - T2.birthYear AS age\nFROM Scoring AS T1 \nINNER JOIN Master AS T2 ON T1.playerID = T2.playerID\nGROUP BY T1.year, T1.year - T2.birthYear\nORDER BY SUM(T1.G) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5222": {
        "db_id": "address",
        "question": "Count the number of postal points under New York-Newark-Jersey City, NY-NJ-PA.",
        "ground_truth": "SELECT COUNT(T2.zip_code) FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'New York-Newark-Jersey City, NY-NJ-PA'",
        "amends": [
            "Do select `COUNT(T2.zip_code)` instead of `COUNT(*)` to count specific zip codes rather than all rows. Do use `CBSA AS T1 INNER JOIN zip_data AS T2` instead of querying `postal_points` directly, adding proper table sources and join relationships. Do join on `T1.CBSA = T2.CBSA` instead of filtering by city and state columns that don't exist in the schema. Do filter with `T1.CBSA_name = 'New York-Newark-Jersey City, NY-NJ-PA'` instead of separate city and state conditions to match the correct metropolitan area identifier. The amended query now correctly counts zip codes within the specified CBSA area using the proper table relationships and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM postal_points WHERE city = 'New York-Newark-Jersey City' AND state = 'NY-NJ-PA';",
            "SELECT COUNT(T2.zip_code) \nFROM CBSA AS T1 \nINNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA \nWHERE T1.CBSA_name = 'New York-Newark-Jersey City, NY-NJ-PA'"
        ],
        "rule_sql": []
    },
    "3584": {
        "db_id": "authors",
        "question": "How many authors were associated with the Microsoft Research when paper number 1 was written?",
        "ground_truth": "SELECT COUNT(PaperId) FROM PaperAuthor WHERE Affiliation LIKE '%Microsoft Research%'",
        "amends": [
            "Do count `PaperId` instead of `*` to exclude null values. Do query from `PaperAuthor` table instead of `authors` to access the correct schema. Do use `LIKE '%Microsoft Research%'` for partial string matching instead of exact equality `= 'Microsoft Research'` to capture variations. Do remove the incorrect `paper_id = 1` filter instead of keeping it to count all relevant records. The amended query now correctly counts PaperId values from PaperAuthor where Affiliation contains 'Microsoft Research', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM authors WHERE affiliation = 'Microsoft Research' AND paper_id = 1;",
            "SELECT COUNT(PaperId) FROM PaperAuthor WHERE Affiliation LIKE '%Microsoft Research%'"
        ],
        "rule_sql": []
    },
    "8382": {
        "db_id": "mondial_geo",
        "question": "How much sea is around the island where Kerinci Mountain is located?",
        "ground_truth": "SELECT COUNT(T4.Sea) FROM mountain AS T1 INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Mountain INNER JOIN island AS T3 ON T3.Name = T2.Island INNER JOIN islandIn AS T4 ON T4.Island = T3.Name WHERE T1.Name = 'Kerinci'",
        "amends": [
            "Do use `COUNT(T4.Sea)` instead of `SUM(sea_area)` to count sea occurrences rather than summing area values. Do join four tables (`mountain`, `mountainOnIsland`, `island`, and `islandIn`) instead of querying only the `islands` table. Do use `INNER JOIN` relationships with proper join conditions (`T1.Name = T2.Mountain`, `T3.Name = T2.Island`, and `T4.Island = T3.Name`) instead of a simple filter on a single table. Do filter on `T1.Name = 'Kerinci'` instead of `mountain_name = 'Kerinci Mountain'` to match the correct table structure and naming convention. The amended query now correctly counts the number of seas associated with Kerinci mountain through the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(sea_area) FROM islands WHERE mountain_name = 'Kerinci Mountain';",
            "SELECT COUNT(T4.Sea) AS sea_count\nFROM mountain T1\nINNER JOIN mountainOnIsland T2 ON T1.Name = T2.Mountain\nINNER JOIN island T3 ON T3.Name = T2.Island\nINNER JOIN islandIn T4 ON T4.Island = T3.Name\nWHERE T1.Name = 'Kerinci';"
        ],
        "rule_sql": []
    },
    "3286": {
        "db_id": "donor",
        "question": "How many teachers have made some type of donation for projects in Chicago?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.teacher_acctid) FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.is_teacher_acct = 't' AND T2.school_city = 'Chicago'",
        "amends": [
            "Do select `COUNT(DISTINCT T2.teacher_acctid)` instead of `COUNT(*)` to count unique teachers rather than all records. Do use `FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid` instead of `FROM teachers` to join the donations and projects tables. Do filter with `T1.is_teacher_acct = 't' AND T2.school_city = 'Chicago'` instead of `city = 'Chicago' AND donation_amount > 0` to check for teacher accounts and Chicago schools rather than direct city and donation amount conditions. The amended query now correctly counts distinct teachers from Chicago schools who have donations through proper table joins and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM teachers WHERE city = 'Chicago' AND donation_amount > 0;",
            "SELECT COUNT(DISTINCT T2.teacher_acctid) \nFROM donations AS T1 \nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid \nWHERE T1.is_teacher_acct = 't' AND T2.school_city = 'Chicago'"
        ],
        "rule_sql": []
    },
    "5026": {
        "db_id": "olympics",
        "question": "At which age did A Lamusi participate in 2012 Summer?",
        "ground_truth": "SELECT T2.age FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '2012 Summer' AND T3.full_name = 'A Lamusi'",
        "amends": [
            "Do join `games AS T1` and `games_competitor AS T2` with `INNER JOIN` on `T1.id = T2.games_id` instead of querying `athletes` table directly. Do add another `INNER JOIN` to `person AS T3` on `T2.person_id = T3.id` instead of omitting the person table relationship. Do filter on `T1.games_name = '2012 Summer'` instead of separate `year = 2012 AND season = 'Summer'` conditions. Do filter on `T3.full_name = 'A Lamusi'` instead of `name = 'A Lamusi'`. Do select `T2.age` from the joined games_competitor table instead of selecting `age` directly from athletes. The amended query now correctly retrieves age through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM athletes WHERE name = 'A Lamusi' AND year = 2012 AND season = 'Summer';",
            "SELECT T2.age \nFROM games AS T1 \nINNER JOIN games_competitor AS T2 ON T1.id = T2.games_id \nINNER JOIN person AS T3 ON T2.person_id = T3.id \nWHERE T1.games_name = '2012 Summer' \nAND T3.full_name = 'A Lamusi'"
        ],
        "rule_sql": []
    },
    "925": {
        "db_id": "cs_semester",
        "question": "What is the name of the most difficult course?",
        "ground_truth": "SELECT name FROM course WHERE diff = ( SELECT MAX(diff) FROM course )",
        "amends": [
            "Do select `name` instead of `course_name` and use a subquery to find the maximum `diff` value instead of ordering by `difficulty` and limiting to one row. Do reference table `course` instead of `courses` and use column `diff` instead of `difficulty`. Do remove the `ORDER BY` and `LIMIT` clauses and instead use a subquery with `MAX(diff)` to correctly identify the course with the highest difficulty value. The amended query now matches the right SQL's behavior by properly finding the course with the maximum difficulty value using a subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses ORDER BY difficulty DESC LIMIT 1;",
            "SELECT name FROM course WHERE diff = (SELECT MAX(diff) FROM course)"
        ],
        "rule_sql": []
    },
    "3019": {
        "db_id": "shakespeare",
        "question": "What are the character names and descriptions of characters in \"Venus and Adonis\"?",
        "ground_truth": "SELECT DISTINCT T4.CharName, T2.Description FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.Title = 'Venus and Adonis'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to remove duplicate character entries. Do select `T4.CharName` and `T2.Description` instead of `character_name` and `description` to reference the proper table aliases. Do join four tables (`works AS T1`, `chapters AS T2`, `paragraphs AS T3`, and `characters AS T4`) instead of querying only the `characters` table to establish proper relationships. Do use `INNER JOIN` with `T1.id = T2.work_id`, `T2.id = T3.chapter_id`, and `T3.character_id = T4.id` instead of no joins to correctly link works to chapters to paragraphs to characters. Do filter on `T1.Title = 'Venus and Adonis'` instead of `play_title = 'Venus and Adonis'` to reference the correct table and column for work titles. The amended query now correctly retrieves distinct character names and their descriptions from the specified work by following the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name, description FROM characters WHERE play_title = 'Venus and Adonis';",
            "SELECT DISTINCT T4.CharName, T2.Description\nFROM works AS T1\nINNER JOIN chapters AS T2 ON T1.id = T2.work_id\nINNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id\nINNER JOIN characters AS T4 ON T3.character_id = T4.id\nWHERE T1.Title = 'Venus and Adonis'"
        ],
        "rule_sql": []
    },
    "8586": {
        "db_id": "chicago_crime",
        "question": "Which district is the community area Lincoln Square grouped into?",
        "ground_truth": "SELECT side FROM Community_Area WHERE community_area_name = 'Lincoln Square'",
        "amends": [
            "Do select `side` instead of `district` from the table. Do reference table `Community_Area` instead of `community_areas`. Do filter on `community_area_name = 'Lincoln Square'` instead of `name = 'Lincoln Square'`. The amended query now correctly retrieves the side information from the Community_Area table based on the community area name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM community_areas WHERE name = 'Lincoln Square';",
            "SELECT side FROM Community_Area WHERE community_area_name = 'Lincoln Square';"
        ],
        "rule_sql": []
    },
    "1727": {
        "db_id": "restaurant",
        "question": "What is the address of the Peking Duck restaurant?",
        "ground_truth": "SELECT T2.street_name FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.label = 'peking duck restaurant'",
        "amends": [
            "Do select `T2.street_name` instead of `name` and use table aliases `T1` and `T2` instead of no aliases. Do join `generalinfo AS T1` with `location AS T2` on `T1.id_restaurant = T2.id_restaurant` instead of querying only the `restaurants` table. Do filter on `T1.label = 'peking duck restaurant'` instead of `cuisine = 'Chinese'`. The amended query now correctly retrieves street names from the location table for specific restaurant labels rather than restaurant names based on cuisine type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE cuisine = 'Chinese'",
            "SELECT T2.street_name \nFROM generalinfo AS T1 \nJOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant \nWHERE T1.label = 'peking duck restaurant'"
        ],
        "rule_sql": []
    },
    "1354": {
        "db_id": "law_episode",
        "question": "What are the keywords of the episode \"Shield\"?",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Shield'",
        "amends": [
            "Do add table `Keyword AS T2` and `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying only the `episodes` table. Do change the source from `episodes` to `Episode AS T1` instead of using the original table name. Do specify the column as `T2.keyword` instead of just `keyword` to indicate the correct table source. Do add the join condition `T1.episode_id = T2.episode_id` instead of missing the relationship between tables. The amended query now correctly retrieves keywords from the related Keyword table instead of attempting to select keywords directly from the episodes table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword FROM episodes WHERE title = 'Shield';",
            "SELECT T2.keyword\nFROM Episode AS T1\nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id\nWHERE T1.title = 'Shield'"
        ],
        "rule_sql": []
    },
    "3350": {
        "db_id": "video_games",
        "question": "How many publishers in Japan released a game on X360 in 2011?",
        "ground_truth": "SELECT COUNT(T3.game_publisher_id) FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE T4.platform_name = 'X360' AND T3.release_year = 2011 AND T1.region_name = 'Japan'",
        "amends": [
            "Do use `COUNT(T3.game_publisher_id)` instead of `COUNT(*)` to count specific publisher relationships. Do join multiple tables including `region AS T1`, `region_sales AS T2`, `game_platform AS T3`, and `platform AS T4` instead of querying only the `publishers` table. Do use `INNER JOIN` with proper join conditions `T1.id = T2.region_id`, `T2.game_platform_id = T3.id`, and `T3.platform_id = T4.id` instead of no joins. Do filter on `T4.platform_name = 'X360'` instead of `platform = 'X360'`, `T3.release_year = 2011` instead of `year = 2011`, and `T1.region_name = 'Japan'` instead of `country = 'Japan'` to correctly reference the appropriate columns from the joined tables. The amended query now properly counts game publishers for X360 platform releases in Japan for 2011 by traversing the correct table relationships.",
            "Do remove `DISTINCT` from the count instead of keeping it, and do count `T3.game_publisher_id` instead of `gp.publisher_id`. Do remove the `INNER JOIN game_publisher gp ON gpl.game_publisher_id = gp.id` table join instead of including it, as the game_publisher_id is already available in the game_platform table. Do keep the same join structure for region, region_sales, game_platform, and platform tables with identical join conditions. Do maintain the same WHERE filter conditions on `platform_name = 'X360'`, `release_year = 2011`, and `region_name = 'Japan'` in the same logical order. The amended query now correctly counts game publishers for X360 platform releases in Japan in 2011 without unnecessary table joins and distinct operations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM publishers WHERE country = 'Japan' AND platform = 'X360' AND year = 2011;",
            "SELECT COUNT(DISTINCT gp.publisher_id) \nFROM region r\nINNER JOIN region_sales rs ON r.id = rs.region_id\nINNER JOIN game_platform gpl ON rs.game_platform_id = gpl.id\nINNER JOIN platform p ON gpl.platform_id = p.id\nINNER JOIN game_publisher gp ON gpl.game_publisher_id = gp.id\nWHERE r.region_name = 'Japan'\nAND p.platform_name = 'X360'\nAND gpl.release_year = 2011",
            "SELECT COUNT(T3.game_publisher_id) \nFROM region AS T1\nINNER JOIN region_sales AS T2 ON T1.id = T2.region_id\nINNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id\nINNER JOIN platform AS T4 ON T3.platform_id = T4.id\nWHERE T4.platform_name = 'X360' \nAND T3.release_year = 2011 \nAND T1.region_name = 'Japan'"
        ],
        "rule_sql": []
    },
    "6009": {
        "db_id": "books",
        "question": "Other than zero, what is the lowest price paid by a customer for an order?",
        "ground_truth": "SELECT MIN(price) FROM order_line WHERE price <> 0",
        "amends": [
            "Do reference table `order_line` instead of `orders` in the FROM clause. Do use inequality filter `<> 0` instead of `> 0` in the WHERE condition to properly exclude zero values while including both positive and negative prices. The amended query now correctly calculates the minimum non-zero price from the order_line table instead of the orders table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(price) FROM orders WHERE price > 0;",
            "SELECT MIN(price) AS lowest_non_zero_price FROM order_line WHERE price <> 0"
        ],
        "rule_sql": []
    },
    "6053": {
        "db_id": "books",
        "question": "Identify the cost difference between Priority and Express shipping methods.",
        "ground_truth": "SELECT SUM(CASE WHEN method_name = 'Priority' THEN cost ELSE 0 END) - SUM(CASE WHEN method_name = 'Express' THEN cost ELSE 0 END) FROM shipping_method",
        "amends": [
            "Do use a single table `shipping_method` instead of self-joining the same table twice as `shipping_methods Priority` and `shipping_methods Express`. Do calculate the cost difference using `SUM(CASE WHEN method_name = 'Priority' THEN cost ELSE 0 END) - SUM(CASE WHEN method_name = 'Express' THEN cost ELSE 0 END)` instead of directly subtracting `Priority.cost - Express.cost`. Do remove the explicit join conditions and WHERE filters for individual method names since the CASE expressions handle the conditional aggregation. The amended query now correctly handles cases where both Priority and Express methods may not exist simultaneously in the same row, preventing null results from the cross join approach, and matches the RIGHT_SQL's behavior by aggregating costs from the same table using conditional summation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Priority.cost - Express.cost AS cost_difference FROM shipping_methods Priority, shipping_methods Express WHERE Priority.method_name = 'Priority' AND Express.method_name = 'Express'",
            "SELECT \n    SUM(CASE WHEN method_name = 'Priority' THEN cost ELSE 0 END) - \n    SUM(CASE WHEN method_name = 'Express' THEN cost ELSE 0 END) AS cost_difference\nFROM shipping_method\nWHERE method_name IN ('Priority', 'Express')"
        ],
        "rule_sql": []
    },
    "5549": {
        "db_id": "menu",
        "question": "Provide the menu page ids of all the menu that includes mashed potatoes.",
        "ground_truth": "SELECT T2.menu_page_id FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Mashed potatoes'",
        "amends": [
            "Do select `T2.menu_page_id` instead of `menu_id` and use table alias `T2` instead of direct column reference. Do join `Dish AS T1` and `MenuItem AS T2` with `INNER JOIN` on `T1.id = T2.dish_id` instead of querying only `menu_items` table. Do filter on `T1.name = 'Mashed potatoes'` with proper capitalization instead of `item_name = 'mashed potatoes'` with lowercase. The amended query now correctly retrieves menu page IDs by joining dish and menu item tables with proper relationship mapping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT menu_id FROM menu_items WHERE item_name = 'mashed potatoes';",
            "SELECT T2.menu_page_id \nFROM Dish AS T1 \nINNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id \nWHERE T1.name = 'Mashed potatoes'"
        ],
        "rule_sql": []
    },
    "658": {
        "db_id": "codebase_comments",
        "question": "Please provide the path of solution of method whose full comment is Feeds data into the parser.",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.FullComment = 'Feeds data into the parser'",
        "amends": [
            "Do select `T1.Path` from `Solution AS T1` instead of `path` from `methods`. Do use `INNER JOIN` on `Method AS T2` with `T1.Id = T2.SolutionId` instead of querying a single table. Do filter on `T2.FullComment = 'Feeds data into the parser'` instead of `comment = 'Feeds data into the parser'`. The amended query now correctly joins the Solution and Method tables to find paths where method comments match the specified text, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path FROM methods WHERE comment = 'Feeds data into the parser';",
            "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.FullComment = 'Feeds data into the parser'"
        ],
        "rule_sql": []
    },
    "4082": {
        "db_id": "public_review_platform",
        "question": "Among the elite users of 10 consecutive year from 2005 to 2014, list down the user ID and their number of compliment on photos.",
        "ground_truth": "SELECT T2.user_id, T2.number_of_compliments FROM Compliments AS T1 INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id INNER JOIN Elite AS T3 ON T2.user_id = T3.user_id WHERE T3.year_id BETWEEN 2005 AND 2014 AND T1.compliment_type = 'photos'",
        "amends": [
            "Do select `T2.user_id` and `T2.number_of_compliments` instead of `user_id` and `COUNT(compliment_photos)`. Do use `FROM Compliments AS T1` with `INNER JOIN Users_Compliments AS T2` on `T1.compliment_id = T2.compliment_id` and `INNER JOIN Elite AS T3` on `T2.user_id = T3.user_id` instead of `FROM elite_years` alone. Do apply `WHERE T3.year_id BETWEEN 2005 AND 2014` and `T1.compliment_type = 'photos'` instead of `WHERE year BETWEEN 2005 AND 2014` and remove the `GROUP BY user_id` and `HAVING COUNT(DISTINCT year) = 10` clauses entirely. The amended query now correctly joins multiple tables with proper filtering conditions to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, COUNT(compliment_photos) \nFROM elite_years \nWHERE year BETWEEN 2005 AND 2014 \nGROUP BY user_id \nHAVING COUNT(DISTINCT year) = 10;",
            "SELECT T2.user_id, T2.number_of_compliments\nFROM Compliments AS T1\nINNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id\nINNER JOIN Elite AS T3 ON T2.user_id = T3.user_id\nWHERE T3.year_id BETWEEN 2005 AND 2014\nAND T1.compliment_type = 'photos'"
        ],
        "rule_sql": []
    },
    "2801": {
        "db_id": "professional_basketball",
        "question": "Who is the coach for 'BOS' team in year 1950. List the coach ID together with the number of game won and lost.",
        "ground_truth": "SELECT coachID, won, lost FROM coaches WHERE year = 1950 AND tmID = 'BOS'",
        "amends": [
            "Do use column names `coachID`, `won`, and `lost` instead of `coach_id`, `wins`, and `losses`. Do filter on `tmID = 'BOS'` instead of `team = 'BOS'` while keeping the `year = 1950` condition. The amended query now correctly references the actual schema columns and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_id, wins, losses FROM coaches WHERE team = 'BOS' AND year = 1950;",
            "SELECT coachID, won, lost FROM coaches WHERE tmID = 'BOS' AND year = 1950;"
        ],
        "rule_sql": []
    },
    "2267": {
        "db_id": "movielens",
        "question": "UK produced what genre of movies?",
        "ground_truth": "SELECT T2.genre FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'UK'",
        "amends": [
            "Do join `movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid` instead of querying only the `movies` table. Do filter on `T1.country = 'UK'` instead of `country = 'USA'`. Do select `T2.genre` from the joined table instead of `genre` from the base table. The amended query now correctly retrieves genre information from the joined relationship table with the proper country filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM movies WHERE country = 'USA';",
            "SELECT DISTINCT T2.genre FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'UK'"
        ],
        "rule_sql": []
    },
    "3162": {
        "db_id": "donor",
        "question": "Name the project that costs the most. How much has been collected from donation and what is the percentage amount still lacking?",
        "ground_truth": "SELECT T1.title, SUM(T3.donation_to_project), CAST((T2.total_price_excluding_optional_support - SUM(T3.donation_to_project)) AS REAL) * 100 / SUM(T3.donation_to_project) FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid ORDER BY T2.total_price_excluding_optional_support DESC LIMIT 1",
        "amends": [
            "Do select `T1.title` and `SUM(T3.donation_to_project)` instead of `project_name` and `total_cost`. Do add `INNER JOIN essays AS T1` and `INNER JOIN donations AS T3` instead of querying only the `projects` table. Do use `T1.projectid = T2.projectid` and `T2.projectid = T3.projectid` join conditions instead of no join predicates. Do calculate the percentage as `CAST((T2.total_price_excluding_optional_support - SUM(T3.donation_to_project)) AS REAL) * 100 / SUM(T3.donation_to_project)` instead of `((total_cost - donations_received) / total_cost * 100)`. Do order by `T2.total_price_excluding_optional_support DESC` instead of `total_cost DESC`. The amended query now correctly joins multiple tables, uses proper aggregate functions, and calculates the percentage based on the appropriate column relationships.",
            "Do remove the `GROUP BY T2.projectid` clause instead of keeping it, as the aggregation without grouping by all non-aggregated columns in the SELECT list would cause incorrect results. Do maintain the same SELECT list with `T1.title`, `SUM(T3.donation_to_project)`, and the calculated percentage expression instead of changing any columns or expressions. Do keep the same FROM clause with `INNER JOIN essays AS T1 ON T1.projectid = T2.projectid` and `INNER JOIN donations AS T3 ON T2.projectid = T3.projectid` instead of modifying the join structure or predicates. Do preserve the ORDER BY T2.total_price_excluding_optional_support DESC and LIMIT 1 clauses instead of altering the sorting or limiting logic. The amended query now correctly calculates the aggregate values without improper grouping and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    project_name,\n    total_cost,\n    donations_received,\n    (total_cost - donations_received) AS amount_still_needed,\n    ((total_cost - donations_received) / total_cost * 100) AS percentage_lacking\nFROM projects\nORDER BY total_cost DESC\nLIMIT 1;",
            "SELECT \n    T1.title,\n    SUM(T3.donation_to_project) AS donations_received,\n    CAST((T2.total_price_excluding_optional_support - SUM(T3.donation_to_project)) AS REAL) * 100 / SUM(T3.donation_to_project) AS percentage_lacking\nFROM \n    projects AS T2\nINNER JOIN essays AS T1 ON T1.projectid = T2.projectid\nINNER JOIN donations AS T3 ON T2.projectid = T3.projectid\nGROUP BY \n    T2.projectid\nORDER BY \n    T2.total_price_excluding_optional_support DESC\nLIMIT 1;",
            "SELECT \n    T1.title,\n    SUM(T3.donation_to_project) AS collected_donation,\n    CAST((T2.total_price_excluding_optional_support - SUM(T3.donation_to_project)) AS REAL) * 100 / SUM(T3.donation_to_project) AS percentage_lacking\nFROM \n    projects AS T2\nINNER JOIN \n    essays AS T1 ON T1.projectid = T2.projectid\nINNER JOIN \n    donations AS T3 ON T2.projectid = T3.projectid\nORDER BY \n    T2.total_price_excluding_optional_support DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5596": {
        "db_id": "shipping",
        "question": "Give the name of the driver of shipment no.1021.",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = '1021'",
        "amends": [
            "Do select `T2.first_name` and `T2.last_name` instead of just `driver_name`. Do join `shipment AS T1` with `driver AS T2` using `INNER JOIN` on `T1.driver_id = T2.driver_id` instead of querying only the `shipments` table. Do filter on `T1.ship_id = '1021'` with string comparison instead of numeric `shipment_id = 1021`. The amended query now correctly retrieves driver details from the related driver table using proper join relationships and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM shipments WHERE shipment_id = 1021",
            "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = '1021'"
        ],
        "rule_sql": []
    },
    "372": {
        "db_id": "retail_complains",
        "question": "Give me the social number and state of the client whose phone number is 100-121-8371.",
        "ground_truth": "SELECT T1.social, T1.state FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T2.state_abbrev = T3.StateCode WHERE T1.phone = '100-121-8371'",
        "amends": [
            "Do select `social` and `state` from the `client` table instead of `social_number` and `state` from `clients`. Do add `INNER JOIN` with `district` on `district_id` instead of omitting it. Do add `INNER JOIN` with `state` on `state_abbrev = StateCode` instead of omitting it. Do reference columns with table aliases `T1.social` and `T1.state` instead of unqualified column names. Do filter on `T1.phone` instead of just `phone`. The amended query now correctly joins through district and state tables to retrieve the appropriate data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT social_number, state FROM clients WHERE phone = '100-121-8371';",
            "SELECT T1.social, T1.state FROM client T1 INNER JOIN district T2 ON T1.district_id = T2.district_id INNER JOIN state T3 ON T2.state_abbrev = T3.StateCode WHERE T1.phone = '100-121-8371'"
        ],
        "rule_sql": []
    },
    "6176": {
        "db_id": "food_inspection_2",
        "question": "Calculate the percentage of inspections with the fine for a minor food safety problem.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN fine = 100 THEN inspection_id END) AS REAL) * 100 / COUNT(inspection_id) FROM violation",
        "amends": [
            "Do use `COUNT(CASE WHEN fine = 100 THEN inspection_id END)` instead of `COUNT(*)` to count specific conditions, and do reference the `violation` table instead of `inspections`. Do calculate the percentage using `CAST(... AS REAL) * 100 / COUNT(inspection_id)` instead of `* 100.0 / (SELECT COUNT(*) FROM inspections)` to avoid a subquery and ensure proper real number division. Do remove the `WHERE fine_amount > 0 AND problem_type = 'minor'` filter instead of keeping it, as the counting logic is now handled within the CASE expression. The amended query now correctly calculates the percentage of inspections with a fine of 100 relative to all inspections in the violation table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM inspections)) AS percentage\nFROM inspections\nWHERE fine_amount > 0 AND problem_type = 'minor';",
            "SELECT \n    CAST(COUNT(CASE WHEN fine = 100 THEN inspection_id END) AS REAL) * 100 / COUNT(inspection_id) AS percentage\nFROM \n    violation;"
        ],
        "rule_sql": []
    },
    "6926": {
        "db_id": "ice_hockey_draft",
        "question": "Please list the names of all the players that are over 90 kg and are right-shooted.",
        "ground_truth": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T2.weight_in_kg > 90 AND T1.shoots = 'R'",
        "amends": [
            "Do use `T1.PlayerName` instead of `name` for the column selection. Do add `INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id` instead of querying only the players table. Do reference `T2.weight_in_kg > 90` instead of `weight > 90` to filter by the joined weight information. Do use `T1.shoots = 'R'` instead of `shoot = 'right'` for the shooting side condition with the correct column name and value format. Do include table aliases `T1` and `T2` instead of omitting them. The amended query now correctly joins player information with weight data and uses proper column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE weight > 90 AND shoot = 'right'",
            "SELECT T1.PlayerName\nFROM PlayerInfo AS T1\nINNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id\nWHERE T2.weight_in_kg > 90\nAND T1.shoots = 'R'"
        ],
        "rule_sql": []
    },
    "1527": {
        "db_id": "synthea",
        "question": "Describe the care plans of patient Major D'Amore's plan of care.",
        "ground_truth": "SELECT DISTINCT T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Major' AND T1.last = 'D''Amore'",
        "amends": [
            "Do select only `T2.DESCRIPTION` instead of all columns with `*`. Do add `DISTINCT` to remove duplicates instead of omitting it. Do change the source to `patients AS T1` joined with `careplans AS T2` using `INNER JOIN` on `T1.patient = T2.PATIENT` instead of querying only the `patients` table. Do add filter conditions `T1.first = 'Major'` and `T1.last = 'D''Amore'` instead of the incorrect `name = \"Major D'Amore\"` filter. The amended query now correctly joins tables and uses proper name field filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM patients WHERE name = \"Major D'Amore\";",
            "SELECT DISTINCT T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Major' AND T1.last = 'D''Amore'"
        ],
        "rule_sql": []
    },
    "8591": {
        "db_id": "chicago_crime",
        "question": "To which community area does the neighborhood Albany Park belong?",
        "ground_truth": "SELECT T2.community_area_name FROM Neighborhood AS T1 INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.neighborhood_name = 'Albany Park'",
        "amends": [
            "Do select `T2.community_area_name` from the `Community_Area` table instead of `community_area` from the `neighborhoods` table. Do add an `INNER JOIN` between `Neighborhood AS T1` and `Community_Area AS T2` on `T1.community_area_no = T2.community_area_no` instead of querying a single table. Do use the correct table name `Neighborhood` instead of `neighborhoods` and maintain the filter `T1.neighborhood_name = 'Albany Park'` instead of the original condition. The amended query now correctly retrieves the community area name through the proper table relationship instead of attempting to access it directly from the neighborhoods table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_area FROM neighborhoods WHERE neighborhood_name = 'Albany Park';",
            "SELECT T2.community_area_name \nFROM Neighborhood AS T1\nINNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no\nWHERE T1.neighborhood_name = 'Albany Park'"
        ],
        "rule_sql": []
    },
    "9070": {
        "db_id": "bike_share_1",
        "question": "When was the bike station from which the bike was borrowed on trip ID4069 installed?",
        "ground_truth": "SELECT T2.installation_date FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.id = 4069",
        "amends": [
            "Do select `T2.installation_date` from the `station` table instead of `installation_date` from the `bike_stations` table. Do join `trip AS T1` and `station AS T2` with an `INNER JOIN` on `T2.name = T1.start_station_name` instead of querying only the `bike_stations` table. Do filter on `T1.id = 4069` instead of `trip_id = 'ID4069'` to use the correct numeric ID value and proper table reference. The amended query now correctly retrieves installation dates by joining trip and station tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT installation_date FROM bike_stations WHERE trip_id = 'ID4069';",
            "SELECT T2.installation_date\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.id = 4069"
        ],
        "rule_sql": []
    },
    "2183": {
        "db_id": "world_development_indicators",
        "question": "Which country have conducted population census from 2010 until 2012 and have completed vital registration?",
        "ground_truth": "SELECT ShortName, LongName FROM Country WHERE LatestPopulationCensus >= 2010 AND LatestPopulationCensus < 2013 AND VitalRegistrationComplete = 'Yes'",
        "amends": [
            "Do select `ShortName` and `LongName` instead of `country`. Do use table `Country` instead of `census_data`. Do filter on `LatestPopulationCensus >= 2010` and `LatestPopulationCensus < 2013` instead of `year BETWEEN 2010 AND 2012`. Do check `VitalRegistrationComplete = 'Yes'` instead of `vital_registration = 'completed'`. The amended query now correctly retrieves country names from the Country table using appropriate census year range and vital registration completion criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM census_data WHERE year BETWEEN 2010 AND 2012 AND vital_registration = 'completed'",
            "SELECT ShortName, LongName FROM Country WHERE LatestPopulationCensus >= 2010 AND LatestPopulationCensus < 2013 AND VitalRegistrationComplete = 'Yes';"
        ],
        "rule_sql": []
    },
    "666": {
        "db_id": "codebase_comments",
        "question": "What is the task of the method that is in the Czech language?",
        "ground_truth": "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE Lang = 'cs'",
        "amends": [
            "Do use `DISTINCT` to eliminate duplicates instead of omitting it. Do use `SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)` for complex string extraction instead of selecting the raw `task` column. Do query from table `Method` instead of `methods`. Do filter on `Lang = 'cs'` instead of `language = 'Czech'`. The amended query now correctly extracts distinct task names from the Method table using Czech language filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT task FROM methods WHERE language = 'Czech';",
            "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) AS task FROM Method WHERE Lang = 'cs';"
        ],
        "rule_sql": []
    },
    "1124": {
        "db_id": "talkingdata",
        "question": "For the event which happened at 23:55:16 on 2016/5/7, in the location coordinate(113, 28), on what device did it happen? Give the name of the device model.",
        "ground_truth": "SELECT T1.device_model FROM phone_brand_device_model2 AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.event_id WHERE T2.longitude = '113' AND T2.latitude = '28' AND T2.timestamp = '2016-05-07 23:55:16'",
        "amends": [
            "Do select `T1.device_model` from `phone_brand_device_model2 AS T1` instead of `device_model` from `events`. Do add `INNER JOIN events AS T2 ON T1.device_id = T2.event_id` instead of querying only the events table. Do change the time filter to `T2.timestamp = '2016-05-07 23:55:16'` instead of separate `time = '23:55:16' AND date = '2016/5/7'`. Do change coordinate filters to `T2.longitude = '113' AND T2.latitude = '28'` instead of `x_coordinate = 113 AND y_coordinate = 28`. The amended query now correctly joins the device model table with events and uses proper timestamp and coordinate column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_model FROM events WHERE time = '23:55:16' AND date = '2016/5/7' AND x_coordinate = 113 AND y_coordinate = 28;",
            "SELECT T1.device_model \nFROM phone_brand_device_model2 AS T1\nINNER JOIN events AS T2 ON T1.device_id = T2.device_id\nWHERE T2.timestamp = '2016-05-07 23:55:16'\nAND T2.longitude = 113\nAND T2.latitude = 28"
        ],
        "rule_sql": []
    },
    "43": {
        "db_id": "movie_platform",
        "question": "What is the average rating score of the movie \"The Crowd\" and who was its director?",
        "ground_truth": "SELECT AVG(T2.rating_score), T1.director_name FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T1.movie_title = 'The Crowd'",
        "amends": [
            "Do specify table aliases `T2.rating_score` and `T1.director_name` instead of ambiguous column references `rating_score` and `director`. Do add `INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id` instead of querying only the `movies` table. Do use `T1.movie_title` filter instead of `title` to match the joined table structure. The amended query now correctly joins the ratings table to calculate average scores and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating_score), director FROM movies WHERE title = 'The Crowd';",
            "SELECT AVG(T2.rating_score) AS average_rating, T1.director_name \nFROM movies AS T1 \nINNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id \nWHERE T1.movie_title = 'The Crowd' \nGROUP BY T1.director_name"
        ],
        "rule_sql": []
    },
    "3346": {
        "db_id": "video_games",
        "question": "Which publisher published the most games?",
        "ground_truth": "SELECT T.publisher_name FROM ( SELECT T2.publisher_name, COUNT(DISTINCT T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id GROUP BY T2.publisher_name ORDER BY COUNT(DISTINCT T1.game_id) DESC LIMIT 1 ) t",
        "amends": [
            "Do join `publisher` table as `T2` instead of querying `games` table directly. Do use `game_publisher` table as `T1` instead of `games` table for the relationship mapping. Do add `INNER JOIN` on `T1.publisher_id = T2.id` instead of missing the join condition. Do select `T2.publisher_name` instead of `publisher` from the base table. Do use `COUNT(DISTINCT T1.game_id)` instead of `COUNT(*)` to count unique games per publisher. Do wrap the query in a subquery `T` instead of using a simple query. Do order by the count expression instead of the alias. The amended query now correctly identifies publishers with their distinct game counts through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher, COUNT(*) as game_count FROM games GROUP BY publisher ORDER BY game_count DESC LIMIT 1;",
            "SELECT T2.publisher_name\nFROM (\n    SELECT T1.publisher_id, COUNT(DISTINCT T1.game_id) AS game_count\n    FROM game_publisher T1\n    INNER JOIN publisher T2 ON T1.publisher_id = T2.id\n    GROUP BY T1.publisher_id\n    ORDER BY COUNT(DISTINCT T1.game_id) DESC\n    LIMIT 1\n) T\nINNER JOIN publisher T2 ON T.publisher_id = T2.id;"
        ],
        "rule_sql": []
    },
    "5877": {
        "db_id": "airline",
        "question": "How many flights from Dallas to Santa Ana departed on time?",
        "ground_truth": "SELECT COUNT(*) FROM Airlines WHERE DEST = 'SNA' AND ORIGIN = 'DFW' AND DEP_DELAY = 0",
        "amends": [
            "Do reference the `Airlines` table instead of `flights`. Do use column names `DEST` and `ORIGIN` with values `'SNA'` and `'DFW'` instead of `destination` and `origin` with values `'Santa Ana'` and `'Dallas'`. Do filter on `DEP_DELAY = 0` instead of `departure_time = scheduled_departure_time`. The amended query now correctly counts flights with no departure delay between Dallas/Fort Worth and Santa Ana airports using the proper airport codes and delay metric."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM flights \nWHERE origin = 'Dallas' \nAND destination = 'Santa Ana' \nAND departure_time = scheduled_departure_time;",
            "SELECT COUNT(*) FROM Airlines WHERE ORIGIN = 'DFW' AND DEST = 'SNA' AND DEP_DELAY = 0;"
        ],
        "rule_sql": []
    },
    "5708": {
        "db_id": "language_corpus",
        "question": "What is the average words of the 10 fewest words title?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN words >= 10 THEN words ELSE 0 END) AS REAL) / SUM(CASE WHEN words >= 10 THEN 1 ELSE 0 END) FROM pages",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN words >= 10 THEN words ELSE 0 END) AS REAL) / SUM(CASE WHEN words >= 10 THEN 1 ELSE 0 END)` instead of `AVG(LENGTH(title) - LENGTH(REPLACE(title, ' ', '')) + 1)` for calculating the average of words only when words count is 10 or more. Do query from `pages` table instead of `articles` table. Do remove `ORDER BY LENGTH(title) - LENGTH(REPLACE(title, ' ', '')) + 1 ASC` and `LIMIT 10` instead of keeping them since the query now returns a single aggregate value rather than multiple ordered rows. The amended query now correctly calculates the average word count only for pages with 10 or more words, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(LENGTH(title) - LENGTH(REPLACE(title, ' ', '')) + 1) FROM articles ORDER BY LENGTH(title) - LENGTH(REPLACE(title, ' ', '')) + 1 ASC LIMIT 10;",
            "SELECT CAST(SUM(CASE WHEN words >= 10 THEN words ELSE 0 END) AS REAL) / SUM(CASE WHEN words >= 10 THEN 1 ELSE 0 END) AS average_words FROM pages;"
        ],
        "rule_sql": []
    },
    "3700": {
        "db_id": "college_completion",
        "question": "What's the number of male Hispanic students who graduated from Central Alabama Community College in 2011 within 100 percent of normal/expected time?",
        "ground_truth": "SELECT SUM(T2.grad_100) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE T1.chronname = 'Central Alabama Community College' AND T2.year = 2011 AND T2.gender = 'M' AND T2.race = 'H'",
        "amends": [
            "Do use `SUM(T2.grad_100)` instead of `COUNT(*)` to sum graduation counts rather than count rows. Do join `institution_details AS T1` and `institution_grads AS T2` on `T1.unitid = T2.unitid` instead of querying a single `students` table. Do filter by `T1.chronname = 'Central Alabama Community College'` instead of `college = 'Central Alabama Community College'` using the correct institution name column. Do use `T2.year = 2011` instead of `graduation_year = 2011` with the proper year column. Do filter by `T2.gender = 'M'` instead of `gender = 'Male'` using the abbreviated gender code. Do filter by `T2.race = 'H'` instead of `ethnicity = 'Hispanic'` using the race code. Do remove the incorrect `graduation_time = 100` filter instead of keeping it, as the graduation data is now properly aggregated in the `grad_100` column. The amended query now correctly calculates Hispanic male graduation counts for the specified institution and year using the proper schema relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'Male' AND ethnicity = 'Hispanic' AND college = 'Central Alabama Community College' AND graduation_year = 2011 AND graduation_time = 100;",
            "SELECT SUM(T2.grad_100) AS graduation_count\nFROM institution_details AS T1\nJOIN institution_grads AS T2 ON T1.unitid = T2.unitid\nWHERE T1.chronname = 'Central Alabama Community College'\nAND T2.year = 2011\nAND T2.gender = 'M'\nAND T2.race = 'H'"
        ],
        "rule_sql": []
    },
    "6724": {
        "db_id": "retails",
        "question": "How many items were shipped on 4th December, 1993?",
        "ground_truth": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_shipdate = '1993-12-04'",
        "amends": [
            "Do select `COUNT(l_linenumber)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do query from `lineitem` table instead of `orders` table to access the correct data source. Do filter on `l_shipdate` column instead of `order_date` column to use the appropriate date field for the shipping date condition. The amended query now correctly counts line items shipped on December 4, 1993, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE order_date = '1993-12-04';",
            "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_shipdate = '1993-12-04';"
        ],
        "rule_sql": []
    },
    "1378": {
        "db_id": "synthea",
        "question": "Give the procedure description of Ms. Jacquelyn Shanahan on 2009/8/9.",
        "ground_truth": "SELECT DISTINCT T2.description FROM patients AS T1 INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Ms.' AND T1.first = 'Jacquelyn' AND T1.last = 'Shanahan' AND T2.DATE = '2009-08-09'",
        "amends": [
            "Do select `T2.description` instead of `procedure_description`. Do join `procedures AS T2` instead of omitting it, with `INNER JOIN` on `T1.patient = T2.PATIENT` instead of no join. Do filter on `T1.prefix = 'Ms.'` instead of omitting it, and use `T2.DATE = '2009-08-09'` instead of `procedure_date = '2009/8/9'`. Do add `DISTINCT` instead of omitting it. The amended query now correctly joins the procedures table and filters by the appropriate date format and prefix condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT procedure_description FROM patients WHERE first_name = 'Jacquelyn' AND last_name = 'Shanahan' AND procedure_date = '2009/8/9'",
            "SELECT DISTINCT T2.DESCRIPTION\nFROM patients AS T1\nINNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT\nWHERE T1.first = 'Jacquelyn' AND T1.last = 'Shanahan' AND T1.prefix = 'Ms.' AND T2.DATE = '2009-08-09'"
        ],
        "rule_sql": []
    },
    "4590": {
        "db_id": "mental_health_survey",
        "question": "Please list all the questions in the mental health survey for 2014.",
        "ground_truth": "SELECT T2.questiontext FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid INNER JOIN Survey AS T3 ON T1.SurveyID = T3.SurveyID WHERE T3.Description LIKE 'mental health survey for 2014' GROUP BY T2.questiontext",
        "amends": [
            "Do select `T2.questiontext` instead of `*` and add explicit column specification. Do change the FROM clause to use `Answer AS T1` instead of `questions` and add two INNER JOINs: first join `Question AS T2` on `T1.QuestionID = T2.questionid` instead of no join, then join `Survey AS T3` on `T1.SurveyID = T3.SurveyID` instead of no join. Do replace the WHERE filter with `T3.Description LIKE 'mental health survey for 2014'` instead of `survey_year = 2014` to properly filter by survey description rather than year. Do add `GROUP BY T2.questiontext` instead of omitting grouping to ensure unique question text results. The amended query now correctly retrieves question texts from the specific mental health survey for 2014 by properly joining the necessary tables and filtering on survey description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM questions WHERE survey_year = 2014;",
            "SELECT T2.questiontext\nFROM Answer AS T1\nINNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid\nINNER JOIN Survey AS T3 ON T1.SurveyID = T3.SurveyID\nWHERE T3.Description LIKE 'mental health survey for 2014'\nGROUP BY T2.questiontext"
        ],
        "rule_sql": []
    },
    "7272": {
        "db_id": "works_cycles",
        "question": "What is the total profit gained by the company from the product that has the highest amount of quantity ordered from online customers? Indicate the name of the product.",
        "ground_truth": "SELECT (T2.ListPrice - T2.StandardCost) * SUM(T1.Quantity), T2.Name FROM ShoppingCartItem AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY T1.ProductID, T2.Name, T2.ListPrice, T2.StandardCost, T1.Quantity ORDER BY SUM(T1.Quantity) DESC LIMIT 1",
        "amends": [
            "Do calculate profit as `(T2.ListPrice - T2.StandardCost) * SUM(T1.Quantity)` instead of `SUM(od.quantityOrdered * (od.priceEach - p.buyPrice))`. Do select `T2.Name` instead of `p.productName`. Do use `INNER JOIN Product AS T2` instead of `JOIN products p` and `JOIN orderdetails od`. Do join on `T1.ProductID = T2.ProductID` instead of `p.productCode = od.productCode`. Do remove the `JOIN orders` clause and `WHERE` filter with subquery for customer type. Do group by `T1.ProductID, T2.Name, T2.ListPrice, T2.StandardCost, T1.Quantity` instead of just `p.productCode`. Do order by `SUM(T1.Quantity)` instead of `SUM(od.quantityOrdered)`. The amended query now correctly calculates profit per product using list and standard costs while removing unnecessary customer filtering.",
            "Do use `ShoppingCartItem` as the FROM source instead of `SalesOrderDetail` and remove the `SalesOrderHeader` join and its `OnlineOrderFlag` filter instead of keeping them. Do reference `T1.Quantity` in both the SELECT expression and ORDER BY instead of `T1.OrderQty`. Do include `T1.Quantity` in the GROUP BY clause instead of omitting it. Do place the calculated profit expression first in the SELECT list instead of second, and remove the `TotalProfit` alias instead of keeping it. Do remove the `ProductName` alias from `T2.Name` instead of including it. The amended query now correctly calculates profit from shopping cart data without unnecessary online order filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.productName, SUM(od.quantityOrdered * (od.priceEach - p.buyPrice)) AS totalProfit\nFROM products p\nJOIN orderdetails od ON p.productCode = od.productCode\nJOIN orders o ON od.orderNumber = o.orderNumber\nWHERE o.customerNumber IN (SELECT customerNumber FROM customers WHERE customerType = 'Online')\nGROUP BY p.productCode\nORDER BY SUM(od.quantityOrdered) DESC\nLIMIT 1;",
            "SELECT \n    T2.Name AS ProductName,\n    (T2.ListPrice - T2.StandardCost) * SUM(T1.OrderQty) AS TotalProfit\nFROM \n    SalesOrderDetail AS T1\nINNER JOIN \n    Product AS T2 ON T1.ProductID = T2.ProductID\nINNER JOIN \n    SalesOrderHeader AS soh ON T1.SalesOrderID = soh.SalesOrderID\nWHERE \n    soh.OnlineOrderFlag = 1\nGROUP BY \n    T1.ProductID, T2.Name, T2.ListPrice, T2.StandardCost\nORDER BY \n    SUM(T1.OrderQty) DESC\nLIMIT 1;",
            "SELECT \n    (T2.ListPrice - T2.StandardCost) * SUM(T1.Quantity) AS TotalProfit,\n    T2.Name\nFROM \n    ShoppingCartItem AS T1\nINNER JOIN \n    Product AS T2 ON T1.ProductID = T2.ProductID\nGROUP BY \n    T1.ProductID, T2.Name, T2.ListPrice, T2.StandardCost, T1.Quantity\nORDER BY \n    SUM(T1.Quantity) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8736": {
        "db_id": "chicago_crime",
        "question": "What is the total population of the neighborhoods Avondale Gardens, Irving Park, Kilbourn Park, Merchant Park, Old Irving Park, and The Villa?",
        "ground_truth": "SELECT SUM(T2.population) AS sum FROM Neighborhood AS T1 INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.neighborhood_name = 'Avondale Gardens' OR T1.neighborhood_name = 'Irving Park' OR T1.neighborhood_name = 'Kilbourn Park' OR T1.neighborhood_name = 'Merchant Park' OR T1.neighborhood_name = 'Old Irving Park' OR T1.neighborhood_name = 'The Villa'",
        "amends": [
            "Do join `Neighborhood AS T1` with `Community_Area AS T2` on `T1.community_area_no = T2.community_area_no` instead of querying only the `neighborhoods` table. Do filter on `T1.neighborhood_name` with OR conditions for each neighborhood instead of using `IN` with neighborhood names. Do sum `T2.population` instead of summing `population` directly from neighborhoods. Do add the alias `AS sum` to the aggregate instead of omitting it. The amended query now correctly joins tables to access population data from the appropriate source and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(population) FROM neighborhoods WHERE name IN ('Avondale Gardens', 'Irving Park', 'Kilbourn Park', 'Merchant Park', 'Old Irving Park', 'The Villa');",
            "SELECT SUM(T2.population) AS sum FROM Neighborhood AS T1 JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.neighborhood_name = 'Avondale Gardens' OR T1.neighborhood_name = 'Irving Park' OR T1.neighborhood_name = 'Kilbourn Park' OR T1.neighborhood_name = 'Merchant Park' OR T1.neighborhood_name = 'Old Irving Park' OR T1.neighborhood_name = 'The Villa'"
        ],
        "rule_sql": []
    },
    "7253": {
        "db_id": "works_cycles",
        "question": "What is the average age of the sales agents in the company by 12/31/2009?",
        "ground_truth": "SELECT AVG(2009 - STRFTIME('%Y', T2.BirthDate)) FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.PersonType = 'SP'",
        "amends": [
            "Do calculate average age using `2009 - STRFTIME('%Y', T2.BirthDate)` instead of directly averaging `age`. Do join `Person AS T1` with `Employee AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single `employees` table. Do filter by `T1.PersonType = 'SP'` instead of `department = 'Sales' AND hire_date <= '2009-12-31'`. The amended query now correctly calculates average age from birth year and filters by person type rather than department and hire date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM employees WHERE department = 'Sales' AND hire_date <= '2009-12-31';",
            "SELECT AVG(2009 - STRFTIME('%Y', T2.BirthDate)) AS average_age\nFROM Person AS T1\nJOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.PersonType = 'SP';"
        ],
        "rule_sql": []
    },
    "8110": {
        "db_id": "university",
        "question": "What is the ID of university with the largest percentage of international students?",
        "ground_truth": "SELECT university_id FROM university_year ORDER BY pct_international_students DESC LIMIT 1",
        "amends": [
            "Do select `university_id` from the `university_year` table instead of `id` from the `universities` table. Do order by `pct_international_students` instead of `international_students` to use the percentage metric rather than absolute count. The amended query now correctly retrieves the university with the highest percentage of international students from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM universities ORDER BY international_students DESC LIMIT 1;",
            "SELECT university_id FROM university_year ORDER BY pct_international_students DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1675": {
        "db_id": "restaurant",
        "question": "List all cities in the Northern California Region.",
        "ground_truth": "SELECT city FROM geographic WHERE region = 'northern california'",
        "amends": [
            "Do select `city` instead of `*` to return only the specific column needed. Do use table `geographic` instead of `cities` as the correct data source. Do filter for region `'northern california'` instead of `'Southern California'` to match the correct region value with proper case sensitivity. The amended query now correctly retrieves city names from the geographic table for the northern california region."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cities WHERE region = 'Southern California';",
            "SELECT city FROM geographic WHERE region = 'northern california';"
        ],
        "rule_sql": []
    },
    "7232": {
        "db_id": "works_cycles",
        "question": "What is the most common first name among the vendor contact?",
        "ground_truth": "SELECT FirstName FROM Person WHERE PersonType = 'VC' GROUP BY FirstName ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `FirstName` instead of `first_name` and remove the `count` alias instead of keeping it. Do use `Person` table instead of `vendor_contacts` and add `WHERE PersonType = 'VC'` filter instead of omitting it. Do move the aggregate function `COUNT(*)` to the `ORDER BY` clause instead of including it in the `SELECT` list. The amended query now correctly filters for vendor contacts in the Person table and orders by count without unnecessary column selection."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, COUNT(*) as count FROM vendor_contacts GROUP BY first_name ORDER BY count DESC LIMIT 1;",
            "SELECT FirstName\nFROM Person\nWHERE PersonType = 'VC'\nGROUP BY FirstName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2219": {
        "db_id": "world_development_indicators",
        "question": "What is the name of the country with the highest percentage of rural population in the overall total population? Indicate the rural population percentage of total population.",
        "ground_truth": "SELECT countryname, MAX(value) FROM indicators WHERE indicatorname = 'Rural population (% of total population)'",
        "amends": [
            "Do select `countryname` and `MAX(value)` instead of `name` and `(rural_population / total_population) * 100 AS rural_percentage`. Do use `FROM indicators` instead of `FROM countries`. Do add `WHERE indicatorname = 'Rural population (% of total population)'` instead of omitting this filter. Do use `MAX(value)` aggregation instead of calculating a percentage from raw columns. Do remove `ORDER BY rural_percentage DESC` and `LIMIT 1` instead of keeping them, as the MAX function already returns the highest value. The amended query now correctly retrieves the maximum rural population percentage from the indicators table using the appropriate indicator name filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, (rural_population / total_population) * 100 AS rural_percentage\nFROM countries\nORDER BY rural_percentage DESC\nLIMIT 1;",
            "SELECT countryname, MAX(value) FROM indicators WHERE indicatorname = 'Rural population (% of total population)'"
        ],
        "rule_sql": []
    },
    "7672": {
        "db_id": "hockey",
        "question": "Please list the awards the players who died in Arlington have won.",
        "ground_truth": "SELECT T2.award FROM Master AS T1 INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID WHERE T1.deathCity = 'Kemptville'",
        "amends": [
            "Do reference the `award` column from the `AwardsPlayers` table instead of `award_name` from `awards`. Do use `INNER JOIN` between `Master` and `AwardsPlayers` tables instead of joining `awards` with `players`. Do join on `playerID` columns instead of `player_id`. Do filter on `deathCity = 'Kemptville'` instead of `death_city = 'Arlington'`. The amended query now correctly matches the intended behavior by using the proper table names, column references, and filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.award_name \nFROM awards a \nJOIN players p ON a.player_id = p.player_id \nWHERE p.death_city = 'Arlington';",
            "SELECT DISTINCT ap.award\nFROM AwardsPlayers ap\nINNER JOIN Master m ON ap.playerID = m.playerID\nWHERE m.deathCity = 'Kemptville'"
        ],
        "rule_sql": []
    },
    "365": {
        "db_id": "retail_complains",
        "question": "Write the complaint ID, call ID, and final phone number of complaints through AVIDAN server from 1/1/2014 to 12/30/2014.",
        "ground_truth": "SELECT `Complaint ID`, call_id, phonefinal FROM callcenterlogs WHERE strftime('%Y', `Date received`) = '2014' AND server = 'AVIDAN'",
        "amends": [
            "Do select `Complaint ID`, `call_id`, and `phonefinal` instead of `complaint_id`, `call_id`, and `phone_number`. Do query from `callcenterlogs` instead of `complaints`. Do filter with `strftime('%Y', `Date received`) = '2014'` instead of `date BETWEEN '2014-01-01' AND '2014-12-30'` to capture the entire year 2014. Do keep the `server = 'AVIDAN'` filter unchanged. The amended query now correctly retrieves 2014 complaints from the callcenterlogs table with proper column names and date filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT complaint_id, call_id, phone_number FROM complaints WHERE server = 'AVIDAN' AND date BETWEEN '2014-01-01' AND '2014-12-30';",
            "SELECT \"Complaint ID\", call_id, phonefinal FROM callcenterlogs WHERE server = 'AVIDAN' AND strftime('%Y', \"Date received\") = '2014';"
        ],
        "rule_sql": []
    },
    "3858": {
        "db_id": "public_review_platform",
        "question": "Please list the business ID of the Yelp_Business with the highest Elitestar rating under the category \"Food\".",
        "ground_truth": "SELECT T2.business_id FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name LIKE 'Food' ORDER BY T3.stars DESC LIMIT 1",
        "amends": [
            "Do join `Categories AS T1` and `Business_Categories AS T2` on `T1.category_id = T2.category_id` instead of querying `Yelp_Business` directly. Do join `Business AS T3` on `T2.business_id = T3.business_id` instead of omitting the business table. Do filter with `T1.category_name LIKE 'Food'` instead of `category = 'Food'`. Do order by `T3.stars DESC` instead of `Elitestar DESC`. Do select `T2.business_id` instead of just `business_id`. The amended query now correctly joins the category and business tables to find businesses in the Food category ordered by star rating."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM Yelp_Business WHERE category = 'Food' ORDER BY Elitestar DESC LIMIT 1;",
            "SELECT T2.business_id \nFROM Categories AS T1 \nJOIN Business_Categories AS T2 ON T1.category_id = T2.category_id \nJOIN Business AS T3 ON T2.business_id = T3.business_id \nWHERE T1.category_name LIKE 'Food' \nORDER BY T3.stars DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7760": {
        "db_id": "hockey",
        "question": "Among the teams that played in 1922's Stanley Cup finals, how many of them had over 20 points in that year?",
        "ground_truth": "SELECT COUNT(T1.tmID) FROM TeamsSC AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = '1922' AND T2.Pts > 20",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `t` and `scf`. Do specify the column `T1.tmID` in the COUNT function instead of using `COUNT(*)`. Do join `TeamsSC` and `Teams` tables instead of `teams` and `stanley_cup_finals`. Do use `INNER JOIN` with the condition `T1.tmID = T2.tmID AND T1.year = T2.year` instead of `JOIN` with `t.team_id = scf.team_id`. Do filter with `T1.year = '1922'` instead of `scf.year = 1922`, using string literal instead of numeric. Do filter with `T2.Pts > 20` instead of `t.points > 20`. The amended query now correctly counts teams from the TeamsSC table that participated in the 1922 Stanley Cup finals and had more than 20 points in the Teams table for that same year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM teams t\nJOIN stanley_cup_finals scf ON t.team_id = scf.team_id\nWHERE scf.year = 1922 AND t.points > 20;",
            "SELECT COUNT(DISTINCT T1.tmID) \nFROM TeamsSC T1\nINNER JOIN Teams T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.year = '1922' AND T2.Pts > 20"
        ],
        "rule_sql": []
    },
    "7238": {
        "db_id": "works_cycles",
        "question": "What is the credit card number for Michelle E Cox?",
        "ground_truth": "SELECT T3.CreditCardID FROM Person AS T1 INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE T1.FirstName = 'Michelle' AND T1.MiddleName = 'E' AND T1.LastName = 'Cox'",
        "amends": [
            "Do select `T3.CreditCardID` instead of `credit_card_number` from the correct table structure. Do add joins to `PersonCreditCard` and `CreditCard` tables instead of querying only the `customers` table. Do use `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` and `T2.CreditCardID = T3.CreditCardID` instead of no joins. Do add filter on `T1.MiddleName = 'E'` instead of omitting the middle name condition. Do reference columns with table aliases `T1.FirstName`, `T1.LastName` instead of unqualified column names. The amended query now correctly joins through the relationship tables to retrieve the credit card ID from the proper source.",
            "Do select `T3.CreditCardID` instead of `T3.CardNumber` in the SELECT list. Do add explicit `AS` aliases for all table references instead of omitting them. The amended query now correctly retrieves the CreditCardID instead of CardNumber and includes proper table aliasing, matching the RIGHT_SQL's behavior.",
            "Do select `T3.CreditCardID` instead of `T3.CardNumber` in the SELECT list. Do add explicit `AS` aliases for all table references instead of omitting them. The amended query now correctly retrieves the CreditCardID instead of CardNumber and includes proper table aliasing while maintaining the same join logic and filter conditions.",
            "Do select `T3.CreditCardID` instead of `T3.CardNumber` in the SELECT list. Do remove the filter on `T1.LastName = 'Cox'` from the WHERE clause instead of keeping it, and do reorder the remaining filters to `T1.FirstName = 'Michelle'`, `T1.MiddleName = 'E'`, and `T1.LastName = 'Cox'` instead of the original sequence. The amended query now correctly retrieves the CreditCardID instead of CardNumber and maintains the proper filter structure to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_card_number FROM customers WHERE first_name = 'Michelle' AND last_name = 'Cox';",
            "SELECT T3.CardNumber\nFROM Person T1\nINNER JOIN PersonCreditCard T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN CreditCard T3 ON T2.CreditCardID = T3.CreditCardID\nWHERE T1.FirstName = 'Michelle' AND T1.MiddleName = 'E' AND T1.LastName = 'Cox'",
            "SELECT T3.CardNumber\nFROM Person T1\nINNER JOIN PersonCreditCard T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN CreditCard T3 ON T2.CreditCardID = T3.CreditCardID\nWHERE T1.FirstName = 'Michelle' \nAND T1.MiddleName = 'E' \nAND T1.LastName = 'Cox'",
            "SELECT T3.CardNumber\nFROM Person AS T1\nINNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID\nWHERE T1.FirstName = 'Michelle' \nAND T1.LastName = 'Cox' \nAND T1.MiddleName = 'E'",
            "SELECT T3.CreditCardID\nFROM Person AS T1\nINNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID\nWHERE T1.FirstName = 'Michelle'\nAND T1.MiddleName = 'E'\nAND T1.LastName = 'Cox'"
        ],
        "rule_sql": []
    },
    "8149": {
        "db_id": "sales_in_weather",
        "question": "How many units of item no.5 were sold in store no.3 in total on days with a total precipitation of over 0.05?",
        "ground_truth": "SELECT SUM(CASE WHEN T3.preciptotal > 0.05 THEN units ELSE 0 END) AS sum FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND T1.item_nbr = 5",
        "amends": [
            "Do use `SUM(CASE WHEN T3.preciptotal > 0.05 THEN units ELSE 0 END)` with alias `sum` instead of `SUM(units_sold)` without conditional logic. Do join `sales_in_weather AS T1` instead of just `sales`, and add `INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr` and `INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr` instead of no joins. Do filter with `T2.store_nbr = 3` and `T1.item_nbr = 5` instead of `store_id = 3` and `item_id = 5`. Do reference precipitation as `T3.preciptotal` in the CASE expression instead of `precipitation` in the WHERE clause. The amended query now correctly aggregates units only when precipitation exceeds 0.05 and matches the intended behavior through proper table relationships.",
            "Do remove the date join condition `T1.date = T3.date` from the weather table join instead of including it, as the precipitation filter does not require date alignment between sales and weather tables. Do change the store filter to use `T2.store_nbr = 3` instead of `T1.store_nbr = 3` to ensure proper filtering through the relation table join. The amended query now correctly sums units only when precipitation exceeds 0.05mm without requiring date matching between sales and weather data, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(units_sold) \nFROM sales \nWHERE item_id = 5 \nAND store_id = 3 \nAND precipitation > 0.05",
            "SELECT SUM(CASE WHEN T3.preciptotal > 0.05 THEN units ELSE 0 END) AS sum\nFROM sales_in_weather AS T1\nINNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr\nINNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr AND T1.date = T3.date\nWHERE T1.store_nbr = 3 AND T1.item_nbr = 5",
            "SELECT SUM(CASE WHEN T3.preciptotal > 0.05 THEN units ELSE 0 END) AS sum\nFROM sales_in_weather AS T1\nINNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr\nINNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr\nWHERE T2.store_nbr = 3 AND T1.item_nbr = 5"
        ],
        "rule_sql": []
    },
    "4379": {
        "db_id": "student_loan",
        "question": "How many disabled students have never been absent from school?",
        "ground_truth": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN disabled AS T2 ON T1.`name` = T2.`name` WHERE T1.`month` = 0",
        "amends": [
            "Do select `COUNT(T1.name)` instead of `COUNT(*)`. Do change the FROM source to `longest_absense_from_school AS T1` instead of `students`. Do add `INNER JOIN disabled AS T2` instead of omitting it. Do use join condition `ON T1.name = T2.name` instead of no join. Do change the WHERE filter to `T1.month = 0` instead of `disabled = 1 AND absences = 0`. The amended query now correctly counts students from the joined tables with the proper month filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE disabled = 1 AND absences = 0;",
            "SELECT COUNT(T1.name) \nFROM longest_absense_from_school AS T1\nINNER JOIN disabled AS T2 ON T1.name = T2.name\nWHERE T1.month = 0"
        ],
        "rule_sql": []
    },
    "4476": {
        "db_id": "student_loan",
        "question": "How many disabled students are female?",
        "ground_truth": "SELECT COUNT(name) FROM disabled WHERE name NOT IN ( SELECT name FROM male )",
        "amends": [
            "Do count `name` instead of `*` and change the source table to `disabled` instead of `students`. Do remove the `WHERE` clause with `gender = 'male' AND disabled = 1` and instead use a subquery filter with `name NOT IN (SELECT name FROM male)` to exclude names found in the male table. The amended query now correctly counts names from the disabled table that are not present in the male table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND disabled = 1;",
            "SELECT COUNT(name) FROM disabled WHERE name NOT IN (SELECT name FROM male)"
        ],
        "rule_sql": []
    },
    "3485": {
        "db_id": "video_games",
        "question": "Calculate the total sales in all regions with game platform ID 66.",
        "ground_truth": "SELECT SUM(T.num_sales) * 100000 FROM region_sales AS T WHERE T.game_platform_id = 66",
        "amends": [
            "Do use `SUM(T.num_sales) * 100000` instead of `SUM(sales)` for the aggregate calculation. Do reference `region_sales AS T` instead of `sales_data` as the table source. Do filter on `T.game_platform_id = 66` instead of `platform_id = 66` for the WHERE condition. Do remove `GROUP BY region` instead of keeping it since the aggregation now calculates a single total value. The amended query now correctly calculates the total sales in hundred-thousands for the specified platform without regional grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(sales) FROM sales_data WHERE platform_id = 66 GROUP BY region;",
            "SELECT SUM(T.num_sales) * 100000 AS total_sales\nFROM region_sales AS T\nWHERE T.game_platform_id = 66"
        ],
        "rule_sql": []
    },
    "8306": {
        "db_id": "mondial_geo",
        "question": "Among the countries with a GDP of over 1000000, how many of them have mountains higher than 1000?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T1.Code INNER JOIN mountain AS T4 ON T4.Name = T2.Mountain WHERE T3.GDP > 1000000 AND T4.Height > 1000",
        "amends": [
            "Do use `COUNT(DISTINCT T1.Name)` instead of `COUNT(*)` to count distinct country names rather than all rows. Do join `country AS T1` instead of `countries c` and use proper table aliases. Do add `INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country` instead of the simple mountain join to establish the geographic relationship. Do add `INNER JOIN economy AS T3 ON T3.Country = T1.Code` instead of omitting the economy table to access GDP data. Do add `INNER JOIN mountain AS T4 ON T4.Name = T2.Mountain` instead of directly joining mountains to properly reference mountain height. Do use `T3.GDP > 1000000` instead of `c.gdp > 1000000` to filter on the correct GDP column from the economy table. Do use `T4.Height > 1000` instead of `m.height > 1000` to filter on the correct height column from the mountain table. The amended query now correctly counts distinct countries with mountains over 1000 meters height and GDP over 1 million by properly joining through all necessary relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM countries c\nJOIN mountains m ON c.country_id = m.country_id\nWHERE c.gdp > 1000000 AND m.height > 1000;",
            "SELECT COUNT(DISTINCT T1.Name) \nFROM country AS T1\nINNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country\nINNER JOIN economy AS T3 ON T3.Country = T1.Code\nINNER JOIN mountain AS T4 ON T4.Name = T2.Mountain\nWHERE T3.GDP > 1000000 AND T4.Height > 1000"
        ],
        "rule_sql": []
    },
    "4759": {
        "db_id": "legislator",
        "question": "How many females were members of the past legislators?",
        "ground_truth": "SELECT COUNT(*) FROM historical WHERE gender_bio = 'F'",
        "amends": [
            "Do reference table `historical` instead of `legislators` and do filter on column `gender_bio` with value `'F'` instead of column `gender` with value `'male'`. The amended query now correctly counts female individuals from the historical table instead of counting males from the legislators table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE gender = 'male';",
            "SELECT COUNT(*) FROM historical WHERE gender_bio = 'F';"
        ],
        "rule_sql": []
    },
    "3971": {
        "db_id": "public_review_platform",
        "question": "Among all attribute names, list down the ID and attribute name which start with \"music\".",
        "ground_truth": "SELECT attribute_id, attribute_name FROM Attributes WHERE attribute_name LIKE 'music%'",
        "amends": [
            "Do select `attribute_id` instead of `ID` to use the correct column name from the schema. Do reference the table as `Attributes` instead of `attributes` to match the proper case-sensitive table name. The amended query now correctly retrieves attribute_id and attribute_name from the Attributes table filtered by music-related attribute names, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ID, attribute_name FROM attributes WHERE attribute_name LIKE 'music%';",
            "SELECT attribute_id, attribute_name FROM Attributes WHERE attribute_name LIKE 'music%'"
        ],
        "rule_sql": []
    },
    "1667": {
        "db_id": "car_retails",
        "question": "List down the customer names with a disputed order status.",
        "ground_truth": "SELECT t1.customerName FROM customers AS t1 INNER JOIN orders AS t2 ON t1.customerNumber = t2.customerNumber WHERE t2.status = 'Disputed'",
        "amends": [
            "Do add `INNER JOIN orders AS t2 ON t1.customerNumber = t2.customerNumber` instead of querying only the `customers` table. Do reference `t2.status` instead of `order_status` in the WHERE clause, and use proper case 'Disputed' instead of 'disputed'. Do qualify the column as `t1.customerName` instead of just `customer_name`. The amended query now correctly joins the orders table to filter on order status and returns the expected results matching the RIGHT_SQL behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE order_status = 'disputed';",
            "SELECT t1.customerName\nFROM customers AS t1\nINNER JOIN orders AS t2 ON t1.customerNumber = t2.customerNumber\nWHERE t2.status = 'Disputed'"
        ],
        "rule_sql": []
    },
    "6857": {
        "db_id": "retails",
        "question": "Please list the names of all the products under the type \"promo brushed steel\".",
        "ground_truth": "SELECT p_name FROM part WHERE p_type = 'PROMO BRUSHED STEEL'",
        "amends": [
            "Do reference column `p_name` instead of `name` and table `part` instead of `products`. Do use filter condition `p_type = 'PROMO BRUSHED STEEL'` instead of `type = 'promo brushed steel'` with proper uppercase formatting. The amended query now correctly retrieves data from the appropriate table with the correct column names and case-sensitive filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products WHERE type = 'promo brushed steel';",
            "SELECT p_name FROM part WHERE p_type = 'PROMO BRUSHED STEEL'"
        ],
        "rule_sql": []
    },
    "1304": {
        "db_id": "law_episode",
        "question": "What are the names of the two people who won an award for their role as directors?",
        "ground_truth": "SELECT T1.name FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T2.Result = 'Winner' AND T2.role = 'director'",
        "amends": [
            "Do join `Person AS T1` with `Award AS T2` on `T1.person_id = T2.person_id` instead of querying only the `people` table. Do filter on `T2.Result = 'Winner'` instead of `awards_won > 0`. Do use `T2.role = 'director'` instead of filtering on the person's role. Do select `T1.name` with table qualification instead of just `name`. Do remove the `LIMIT 2` clause instead of keeping it. The amended query now correctly identifies directors who have actually won awards by joining with the Award table and checking for 'Winner' results, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE role = 'director' AND awards_won > 0 LIMIT 2;",
            "SELECT T1.name FROM Person AS T1 JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T2.result = 'Winner' AND T2.role = 'director'"
        ],
        "rule_sql": []
    },
    "8973": {
        "db_id": "human_resources",
        "question": "What is the average salary of the worst performing managers?",
        "ground_truth": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) FROM employee AS T1 INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.performance = 'Poor' AND T2.positiontitle = 'Manager'",
        "amends": [
            "Do use `AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL))` instead of `AVG(salary)` to properly handle string formatting and numeric conversion. Do join `employee AS T1 INNER JOIN position AS T2 ON T1.positionID = T2.positionID` instead of querying only the `managers` table to correctly relate employee and position data. Do filter with `T1.performance = 'Poor' AND T2.positiontitle = 'Manager'` instead of `performance_rating = 'worst'` to use the correct column names and values while ensuring only manager positions are included. The amended query now correctly calculates average salary for poorly performing managers by joining appropriate tables and handling data type conversions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(salary) FROM managers WHERE performance_rating = 'worst';",
            "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) AS average_salary\nFROM employee AS T1\nINNER JOIN position AS T2 ON T1.positionID = T2.positionID\nWHERE T1.performance = 'Poor' AND T2.positiontitle = 'Manager';"
        ],
        "rule_sql": []
    },
    "5311": {
        "db_id": "beer_factory",
        "question": "What credit card is the most used in the purchase of non-alcoholic beer?",
        "ground_truth": "SELECT T2.CreditCardType FROM rootbeer AS T1 INNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE T3.Alcoholic = 'FALSE' GROUP BY T2.CreditCardType ORDER BY COUNT(T2.CreditCardType) DESC LIMIT 1",
        "amends": [
            "Do select `T2.CreditCardType` instead of `credit_card` and `COUNT(*) as purchase_count`. Do use `FROM rootbeer AS T1` instead of `FROM purchases p` and add `INNER JOIN transaction AS T2` and `INNER JOIN rootbeerbrand AS T3` instead of `JOIN products pr`. Do change the join condition to `T1.RootBeerID = T2.RootBeerID` and `T1.BrandID = T3.BrandID` instead of `p.product_id = pr.product_id`. Do modify the WHERE filter to `T3.Alcoholic = 'FALSE'` instead of `pr.category = 'beer' AND pr.alcoholic = 0`. Do group by `T2.CreditCardType` instead of `credit_card`. Do order by `COUNT(T2.CreditCardType) DESC` instead of `purchase_count ASC`. The amended query now correctly identifies the most popular credit card type for non-alcoholic root beer purchases.",
            "Do remove `COUNT(*) as purchase_count` from the SELECT list instead of including it, as the RIGHT_SQL only selects `T2.CreditCardType`. Do keep the same FROM sources with `rootbeer AS T1` INNER JOIN `transaction AS T2` on `T1.RootBeerID = T2.RootBeerID` and INNER JOIN `rootbeerbrand AS T3` on `T1.BrandID = T3.BrandID`, maintaining the same join conditions. Do preserve the WHERE filter `T3.Alcoholic = 'FALSE'` unchanged. Do maintain GROUP BY `T2.CreditCardType` to group by credit card type. Do keep ORDER BY `COUNT(T2.CreditCardType) DESC` to order by the count of credit card types in descending order. Do retain LIMIT 1 to return only the top result. The amended query now correctly returns only the credit card type with the highest count of non-alcoholic root beer purchases instead of including an unnecessary count column.",
            "Do use backticks around the reserved word `transaction` in the FROM clause instead of leaving it unquoted. The amended query now correctly handles the reserved keyword and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_card, COUNT(*) as purchase_count\nFROM purchases p\nJOIN products pr ON p.product_id = pr.product_id\nWHERE pr.category = 'beer' AND pr.alcoholic = 0\nGROUP BY credit_card\nORDER BY purchase_count ASC\nLIMIT 1;",
            "SELECT T2.CreditCardType, COUNT(*) as purchase_count\nFROM rootbeer AS T1\nINNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID\nINNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID\nWHERE T3.Alcoholic = 'FALSE'\nGROUP BY T2.CreditCardType\nORDER BY COUNT(T2.CreditCardType) DESC\nLIMIT 1;",
            "SELECT T2.CreditCardType\nFROM rootbeer AS T1\nINNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID\nINNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID\nWHERE T3.Alcoholic = 'FALSE'\nGROUP BY T2.CreditCardType\nORDER BY COUNT(T2.CreditCardType) DESC\nLIMIT 1",
            "SELECT T2.CreditCardType\nFROM rootbeer AS T1\nINNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID\nINNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID\nWHERE T3.Alcoholic = 'FALSE'\nGROUP BY T2.CreditCardType\nORDER BY COUNT(T2.CreditCardType) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6749": {
        "db_id": "retails",
        "question": "Provide the order comments for at least 5 orders made by customers in the furniture segment.",
        "ground_truth": "SELECT T1.o_comment FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_mktsegment = 'Furniture' LIMIT 5",
        "amends": [
            "Do use `T1.o_comment` instead of `o.comments` for the column selection. Do reference `customer` as `T2` instead of `customers` as `c` for the table name. Do use `T1.o_custkey = T2.c_custkey` instead of `o.customer_id = c.customer_id` for the join condition. Do use `T2.c_mktsegment = 'Furniture'` instead of `c.segment = 'furniture'` for the filter condition, correcting both the column name and case sensitivity. The amended query now correctly joins on the proper key columns and filters using the accurate market segment column with proper case matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.comments \nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE c.segment = 'furniture'\nLIMIT 5;",
            "SELECT T1.o_comment \nFROM orders T1\nJOIN customer T2 ON T1.o_custkey = T2.c_custkey\nWHERE T2.c_mktsegment = 'Furniture'\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "586": {
        "db_id": "codebase_comments",
        "question": "What is the language of the method used in the solution path \"opendns_diagnosticapp\\windows\\OpenDnsDiagnostic.sln\"?",
        "ground_truth": "SELECT T2.Lang FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'opendns_diagnosticappwindowsOpenDnsDiagnostic.sln'",
        "amends": [
            "Do select `T2.Lang` from the `Method` table instead of `language` from the `solutions` table. Do join `Solution AS T1` with `Method AS T2` using `INNER JOIN` on `T1.Id = T2.SolutionId` instead of querying only the `solutions` table. Do filter on `T1.Path` with the corrected path value 'opendns_diagnosticappwindowsOpenDnsDiagnostic.sln' instead of filtering on `path` with the incorrect backslash-containing value. The amended query now correctly retrieves language information from the Method table joined with Solution table using the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM solutions WHERE path = 'opendns_diagnosticapp\\windows\\OpenDnsDiagnostic.sln';",
            "SELECT T2.Lang FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'opendns_diagnosticappwindowsOpenDnsDiagnostic.sln'"
        ],
        "rule_sql": []
    },
    "2261": {
        "db_id": "movielens",
        "question": "What is the ID of audiences that gave the most rating of 5?",
        "ground_truth": "SELECT userid FROM u2base WHERE rating = 5 GROUP BY userid ORDER BY COUNT(movieid) DESC LIMIT 1",
        "amends": [
            "Do reference table `u2base` instead of `ratings` and column `userid` instead of `audience_id` in the SELECT clause and GROUP BY. Do include column `movieid` in the COUNT aggregation instead of using COUNT(*) to count actual rated movies. Do maintain the same WHERE filter for `rating = 5`, GROUP BY grouping, ORDER BY descending count, and LIMIT 1, but now correctly counting per user's highly-rated movies rather than all records. The amended query now matches the intended behavior of finding the user with the most 5-star ratings based on actual movie ratings.",
            "Do use integer comparison `rating = 5` instead of string comparison `rating = '5'` to match the numeric data type. Do remove the explicit column alias `rating_count` instead of keeping it since it's not needed in the final output. Do move the aggregate function `COUNT(movieid)` to the ORDER BY clause instead of including it in the SELECT list since only userid is needed in the results. The amended query now correctly handles numeric rating values and returns only the userid with the highest movie rating count for rating value 5."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT audience_id FROM ratings WHERE rating = 5 GROUP BY audience_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT userid, COUNT(movieid) AS rating_count\nFROM u2base\nWHERE rating = '5'\nGROUP BY userid\nORDER BY rating_count DESC\nLIMIT 1;",
            "SELECT userid FROM u2base WHERE rating = 5 GROUP BY userid ORDER BY COUNT(movieid) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3816": {
        "db_id": "public_review_platform",
        "question": "Which city has the most businesses whose attribute is full_bar?",
        "ground_truth": "SELECT T1.city FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id WHERE T2.attribute_value LIKE 'full_bar' GROUP BY T1.city",
        "amends": [
            "Do join `Business` and `Business_Attributes` tables on `business_id` instead of querying only the `businesses` table. Do filter on `attribute_value LIKE 'full_bar'` instead of `attribute = 'full_bar'`. Do select only `city` instead of both `city` and `business_count`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them to return all cities rather than just the top one. The amended query now correctly joins related tables and returns all cities with the specified attribute value instead of just the city with the highest count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as business_count \nFROM businesses \nWHERE attribute = 'full_bar' \nGROUP BY city \nORDER BY business_count DESC \nLIMIT 1;",
            "SELECT b.city\nFROM Business b\nJOIN Business_Attributes ba ON b.business_id = ba.business_id\nWHERE ba.attribute_value LIKE 'full_bar'\nGROUP BY b.city"
        ],
        "rule_sql": []
    },
    "5458": {
        "db_id": "sales",
        "question": "How many employees sold over 20,000 quantities of \"Touring-2000 Blue, 50\"?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT SUM(Quantity) FROM Sales WHERE ProductID IN ( SELECT ProductID FROM Products WHERE Name = 'Touring-2000 Blue, 50' ) GROUP BY Quantity, SalesPersonID HAVING SUM(Quantity) > 20000 )",
        "amends": [
            "Do use a subquery with `SUM(Quantity)` instead of directly counting rows. Do filter by `ProductID IN (subquery)` instead of using `product_name` directly. Do group by `Quantity, SalesPersonID` instead of no grouping. Do move the quantity filter to `HAVING SUM(Quantity) > 20000` instead of using `WHERE quantity_sold > 20000`. Do reference the correct table `Sales` instead of `employees` and use proper column names `Quantity` and `ProductID` instead of `quantity_sold` and `product_name`. The amended query now correctly counts salespersons who sold more than 20,000 units of the specific product by using proper aggregation and filtering logic.",
            "Do use `COUNT(*)` on a subquery instead of `COUNT(DISTINCT SalesPersonID)` directly. Do move the `SUM(Quantity)` calculation to the SELECT list of the subquery instead of keeping it in the HAVING clause only. Do add `Quantity` to the GROUP BY clause along with `SalesPersonID` instead of grouping by `SalesPersonID` alone. Do remove the DISTINCT modifier from the count operation instead of preserving it. The amended query now correctly counts the number of salesperson-quantity groups that meet the sales threshold for the specified product, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE quantity_sold > 20000 AND product_name = 'Touring-2000 Blue, 50';",
            "SELECT COUNT(DISTINCT SalesPersonID) \nFROM Sales \nWHERE ProductID IN (\n    SELECT ProductID \n    FROM Products \n    WHERE Name = 'Touring-2000 Blue, 50'\n) \nGROUP BY SalesPersonID \nHAVING SUM(Quantity) > 20000",
            "SELECT COUNT(*)\nFROM (\n    SELECT SalesPersonID, SUM(Quantity) as total_quantity\n    FROM Sales\n    WHERE ProductID IN (\n        SELECT ProductID \n        FROM Products \n        WHERE Name = 'Touring-2000 Blue, 50'\n    )\n    GROUP BY SalesPersonID, Quantity\n    HAVING SUM(Quantity) > 20000\n)"
        ],
        "rule_sql": []
    },
    "2587": {
        "db_id": "regional_sales",
        "question": "Name the sales team name who had orders with the greatest net profit in 2020.",
        "ground_truth": "SELECT T2.`Sales Team` FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T1.OrderDate LIKE '%/%/20' GROUP BY T2.`Sales Team` ORDER BY SUM(REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '')) DESC LIMIT 1",
        "amends": [
            "Do reference the `Sales Team` column from the joined table instead of selecting `sales_team_name` from a single table. Do join `Sales Orders` with `Sales Team` using `INNER JOIN` on `T2.SalesTeamID = T1._SalesTeamID` instead of querying only the `sales_teams` table. Do filter with `T1.OrderDate LIKE '%/%/20'` to capture 2020 dates instead of using `BETWEEN` with specific date strings. Do add `GROUP BY T2.Sales Team` to aggregate by sales team instead of omitting grouping. Do calculate net profit using `SUM(REPLACE(T1.Unit Price, ',', '') - REPLACE(T1.Unit Cost, ',', ''))` for ordering instead of directly ordering by `net_profit`. The amended query now correctly joins the necessary tables, handles comma-formatted numeric values, aggregates profit by sales team, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sales_team_name \nFROM sales_teams \nWHERE order_date BETWEEN '2020-01-01' AND '2020-12-31' \nORDER BY net_profit DESC \nLIMIT 1;",
            "SELECT T2.\"Sales Team\"\nFROM \"Sales Orders\" T1\nINNER JOIN \"Sales Team\" T2 ON T2.SalesTeamID = T1._SalesTeamID\nWHERE T1.OrderDate LIKE '%/%/20'\nGROUP BY T2.\"Sales Team\"\nORDER BY SUM(REPLACE(T1.\"Unit Price\", ',', '') - REPLACE(T1.\"Unit Cost\", ',', '')) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2732": {
        "db_id": "regional_sales",
        "question": "Which sales channel was most preferred in commercializing products in January 2020 based on the number of orders placed?",
        "ground_truth": "SELECT `Sales Channel` FROM `Sales Orders` WHERE OrderDate LIKE '1/%/20' GROUP BY `Sales Channel` ORDER BY COUNT(`Sales Channel`) DESC LIMIT 1",
        "amends": [
            "Do reference the table as `Sales Orders` instead of `orders` and use backticks for the column name `Sales Channel` instead of `sales_channel`. Do use the date filter pattern `1/%/20` instead of `2020-01%` to match the correct date format. Do select only the `Sales Channel` column instead of including both `sales_channel` and `COUNT(*) as order_count`. Do order by `COUNT(Sales Channel)` instead of the alias `order_count` since the alias is not available in the ORDER BY clause. The amended query now correctly identifies the top sales channel by count while using the proper table and column names with appropriate date filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sales_channel, COUNT(*) as order_count\nFROM orders\nWHERE order_date LIKE '2020-01%'\nGROUP BY sales_channel\nORDER BY order_count DESC\nLIMIT 1;",
            "SELECT `Sales Channel` FROM `Sales Orders` WHERE OrderDate LIKE '1/%/20' GROUP BY `Sales Channel` ORDER BY COUNT(`Sales Channel`) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1856": {
        "db_id": "soccer_2016",
        "question": "List the over IDs, ball IDs, and innings numbers of the match ID \"336004\" while the batsman got the maximum scores.",
        "ground_truth": "SELECT Over_Id, Ball_Id, Innings_No FROM Batsman_Scored WHERE Match_Id = 336004 ORDER BY Runs_Scored DESC LIMIT 1",
        "amends": [
            "Do select from `Batsman_Scored` instead of `ball_by_ball` and use `Runs_Scored` instead of `batsman_score`. Do add `ORDER BY Runs_Scored DESC LIMIT 1` instead of using a subquery with `MAX(batsman_score)`. Do use integer value `336004` instead of string `'336004'` for the match_id filter. Do remove the subquery correlation and instead use a simple ordering approach to find the maximum scoring record. The amended query now correctly retrieves the highest scoring ball from the appropriate table using proper column names and efficient limiting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT over_id, ball_id, innings_no FROM ball_by_ball WHERE match_id = '336004' AND batsman_score = (SELECT MAX(batsman_score) FROM ball_by_ball WHERE match_id = '336004')",
            "SELECT Over_Id, Ball_Id, Innings_No FROM Batsman_Scored WHERE Match_Id = 336004 ORDER BY Runs_Scored DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4284": {
        "db_id": "simpson_episodes",
        "question": "What are the episodes that have the average rating with more than 20 of 2-star votes?",
        "ground_truth": "SELECT DISTINCT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 2 AND T2.votes > 20 AND T1.rating > 5.0 AND T1.rating <= 7.0;",
        "amends": [
            "Do select only `episode_id` instead of `episode_id, AVG(rating)` and use `DISTINCT` instead of omitting it. Do join `Episode AS T1` with `Vote AS T2` using `INNER JOIN` on `T2.episode_id = T1.episode_id` instead of querying only `episodes` table. Do add filter conditions `T2.stars = 2` and `T2.votes > 20` instead of `rating = 2` and move the count condition to `WHERE` instead of `HAVING`. Do add additional filters `T1.rating > 5.0` and `T1.rating <= 7.0` instead of omitting them. Do remove `GROUP BY` and `AVG()` aggregation instead of keeping them. The amended query now correctly identifies distinct episodes with specific vote criteria and rating ranges, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id, AVG(rating) as avg_rating \nFROM episodes \nWHERE rating = 2 \nGROUP BY episode_id \nHAVING COUNT(*) > 20;",
            "SELECT DISTINCT T1.episode_id\nFROM Episode AS T1\nINNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE T2.stars = 2\nAND T2.votes > 20\nAND T1.rating > 5.0\nAND T1.rating <= 7.0"
        ],
        "rule_sql": []
    },
    "5494": {
        "db_id": "menu",
        "question": "Name the dishes that were on the menu page ID 174.",
        "ground_truth": "SELECT T2.name FROM MenuItem AS T1 INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE T1.menu_page_id = 174",
        "amends": [
            "Do select `T2.name` from the `Dish` table instead of `dish_name` from `menu_items`. Do join `MenuItem AS T1` with `Dish AS T2` using `INNER JOIN` on `T2.id = T1.dish_id` instead of querying only the `menu_items` table. Do filter on `T1.menu_page_id = 174` instead of `page_id = 174` to correctly reference the joined table's column. The amended query now properly retrieves dish names by joining through the relationship between menu items and dishes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name FROM menu_items WHERE page_id = 174;",
            "SELECT T2.name \nFROM MenuItem AS T1 \nINNER JOIN Dish AS T2 ON T2.id = T1.dish_id \nWHERE T1.menu_page_id = 174"
        ],
        "rule_sql": []
    },
    "3659": {
        "db_id": "authors",
        "question": "State the title of papers published in the Ibm Journal of Research and Development.",
        "ground_truth": "SELECT T2.Title FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.FullName = 'Ibm Journal of Research and Development'",
        "amends": [
            "Do reference `T2.Title` from the `Paper` table instead of `title` from `papers`. Do join `Journal AS T1` with `Paper AS T2` using `INNER JOIN` on `T1.Id = T2.JournalId` instead of querying only the `papers` table. Do filter on `T1.FullName = 'Ibm Journal of Research and Development'` instead of `journal = 'IBM Journal of Research and Development'`. The amended query now correctly joins the Journal and Paper tables to retrieve paper titles based on journal name matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE journal = 'IBM Journal of Research and Development';",
            "SELECT T2.Title \nFROM Journal AS T1 \nINNER JOIN Paper AS T2 ON T1.Id = T2.JournalId \nWHERE T1.FullName = 'Ibm Journal of Research and Development'"
        ],
        "rule_sql": []
    },
    "3458": {
        "db_id": "video_games",
        "question": "In 2010, how many PS3 games were released?",
        "ground_truth": "SELECT COUNT(T3.game_id) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE T1.platform_name = 'PS3' AND T2.release_year = 2010",
        "amends": [
            "Do join tables `platform`, `game_platform`, and `game_publisher` instead of querying a single `games` table. Do use `T1.platform_name = 'PS3'` instead of `platform = 'PS3'` and `T2.release_year = 2010` instead of `year = 2010`. Do count `T3.game_id` instead of using `COUNT(*)` to ensure accurate counting of distinct games. Do add proper join conditions `T1.id = T2.platform_id` and `T2.game_publisher_id = T3.id` instead of missing table relationships. The amended query now correctly counts PS3 games from 2010 by properly navigating the database schema relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE year = 2010 AND platform = 'PS3';",
            "SELECT COUNT(DISTINCT T3.game_id) \nFROM platform T1 \nJOIN game_platform T2 ON T1.id = T2.platform_id \nJOIN game_publisher T3 ON T2.game_publisher_id = T3.id \nWHERE T1.platform_name = 'PS3' AND T2.release_year = 2010"
        ],
        "rule_sql": []
    },
    "8279": {
        "db_id": "mondial_geo",
        "question": "Which two countries share the second highest mountain? Give the country code.",
        "ground_truth": "SELECT T1.Code FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country WHERE T2.Mountain = ( SELECT Name FROM mountain ORDER BY Height DESC LIMIT 1, 1 )",
        "amends": [
            "Do select `T1.Code` from the `country` table instead of `country_code` from `mountains`. Do join `geo_mountain` as `T2` with an `INNER JOIN` on `T1.Code = T2.Country` instead of querying a single table. Do add a subquery to find the second highest mountain by `Height` instead of directly ordering by `elevation`. Do filter with `WHERE T2.Mountain = (subquery)` instead of using `LIMIT 1 OFFSET 1` on the main query. Do reference the correct column names `Height` and `Name` in the mountain table instead of `elevation` from a non-existent table. The amended query now correctly identifies the country code for the second highest mountain by joining through proper relational tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM mountains ORDER BY elevation DESC LIMIT 1 OFFSET 1;",
            "SELECT T1.Code\nFROM country T1\nINNER JOIN geo_mountain T2 ON T1.Code = T2.Country\nWHERE T2.Mountain = (\n    SELECT Name\n    FROM mountain\n    ORDER BY Height DESC\n    LIMIT 1 OFFSET 1\n);"
        ],
        "rule_sql": []
    },
    "4741": {
        "db_id": "legislator",
        "question": "Which current legislator is older, Sherrod Brown or Maria Cantwell?",
        "ground_truth": "SELECT official_full_name FROM current WHERE official_full_name = 'Sherrod Brown' OR official_full_name = 'Maria Cantwell' ORDER BY birthday_bio LIMIT 1",
        "amends": [
            "Do select `official_full_name` instead of using a CASE expression with subqueries. Do query from the `current` table instead of the `legislators` table. Do use a WHERE filter with `OR` conditions for both names instead of separate subqueries. Do add an ORDER BY clause with `birthday_bio` instead of comparing birthdates through subqueries. Do add a LIMIT 1 clause to return only the oldest legislator instead of returning one name through conditional logic. The amended query now correctly identifies the older legislator by directly sorting by birthdate and limiting to the oldest result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN (SELECT birthdate FROM legislators WHERE name = 'Sherrod Brown') > (SELECT birthdate FROM legislators WHERE name = 'Maria Cantwell') \n        THEN 'Sherrod Brown' \n        ELSE 'Maria Cantwell' \n    END AS older_legislator;",
            "SELECT official_full_name FROM current WHERE first_name = 'Sherrod' AND last_name = 'Brown' OR first_name = 'Maria' AND last_name = 'Cantwell' ORDER BY birthday_bio ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4343": {
        "db_id": "simpson_episodes",
        "question": "What is the awarded category that the awarded character Lenny won?",
        "ground_truth": "SELECT DISTINCT T1.award_category FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T2.character = 'Lenny';",
        "amends": [
            "Do use `DISTINCT T1.award_category` instead of `category` to eliminate duplicates from the join results. Do join `Award AS T1 INNER JOIN Character_Award AS T2` instead of querying only the `awards` table to properly relate awards to characters through the junction table. Do use the join condition `ON T1.award_id = T2.award_id` instead of no join condition to correctly link the award and character relationship. Do filter on `T2.character = 'Lenny'` instead of `character = 'Lenny'` to reference the correct table containing character information. The amended query now correctly retrieves distinct award categories for the character Lenny by properly joining the normalized schema tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM awards WHERE character = 'Lenny';",
            "SELECT DISTINCT T1.award_category FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T2.character = 'Lenny'"
        ],
        "rule_sql": []
    },
    "3385": {
        "db_id": "video_games",
        "question": "Name the publisher of the Chronicles of the Sword game.",
        "ground_truth": "SELECT T3.publisher_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE T1.game_name = 'Chronicles of the Sword'",
        "amends": [
            "Do use `T3.publisher_name` instead of `publisher` in the SELECT list. Do add joins to `game_publisher AS T2` and `publisher AS T3` instead of querying only the `games` table. Do use `INNER JOIN` with `T1.id = T2.game_id` and `T2.publisher_id = T3.id` instead of no joins. Do use `T1.game_name` instead of `title` in the WHERE filter. Do reference the correct table aliases throughout the query instead of using bare column names. The amended query now correctly joins through the relationship tables to retrieve publisher information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM games WHERE title = 'Chronicles of the Sword';",
            "SELECT T3.publisher_name \nFROM game AS T1\nINNER JOIN game_publisher AS T2 ON T1.id = T2.game_id\nINNER JOIN publisher AS T3 ON T2.publisher_id = T3.id\nWHERE T1.game_name = 'Chronicles of the Sword'"
        ],
        "rule_sql": []
    },
    "1351": {
        "db_id": "law_episode",
        "question": "Which episode has the highest total number of viewer votes?",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id GROUP BY T1.title ORDER BY SUM(T1.votes) DESC LIMIT 1",
        "amends": [
            "Do select `T1.title` instead of `episode_id, SUM(viewer_votes)` and do use `SUM(T1.votes)` instead of `SUM(viewer_votes)`. Do join `Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id` instead of querying only the `episodes` table. Do group by `T1.title` instead of `episode_id`. Do order by `SUM(T1.votes) DESC` instead of `total_votes ASC` while keeping the `LIMIT 1`. The amended query now correctly joins the Episode and Vote tables to calculate total votes per episode title and returns the highest-voted episode."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id, SUM(viewer_votes) as total_votes FROM episodes GROUP BY episode_id ORDER BY total_votes ASC LIMIT 1;",
            "SELECT T1.title\nFROM Episode AS T1\nINNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id\nGROUP BY T1.title\nORDER BY SUM(T1.votes) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "304": {
        "db_id": "retail_complains",
        "question": "What is the name of the state in which there have been the largest number of complaints with priority 0?",
        "ground_truth": "SELECT T2.state FROM callcenterlogs AS T1 INNER JOIN client AS T2 ON T1.`rand client` = T2.client_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id INNER JOIN state AS T4 ON T3.state_abbrev = T4.StateCode WHERE T1.priority = 0 GROUP BY T2.state ORDER BY COUNT(T2.state) DESC LIMIT 1",
        "amends": [
            "Do use `T2.state` from the `client` table instead of `state` from a non-existent `complaints` table. Do join multiple tables including `callcenterlogs AS T1`, `client AS T2`, `district AS T3`, and `state AS T4` instead of querying a single `complaints` table. Do use `INNER JOIN` with proper join conditions `T1.\\`rand client\\` = T2.client_id`, `T2.district_id = T3.district_id`, and `T3.state_abbrev = T4.StateCode` instead of no joins. Do filter on `T1.priority = 0` instead of `priority = 0`. Do order by `COUNT(T2.state) DESC` instead of `complaint_count ASC`. The amended query now correctly aggregates complaint counts by state from the proper table relationships and returns the state with the highest count of priority 0 complaints.",
            "Do select `T2.state` instead of `T4.State` in the SELECT list. Do use `COUNT(T2.state)` instead of `COUNT(*)` in the ORDER BY clause to count specific non-null values rather than all rows. The amended query now correctly references the state column from the client table instead of the state table, and uses explicit counting of state values rather than counting all rows, ensuring the query matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, COUNT(*) as complaint_count \nFROM complaints \nWHERE priority = 0 \nGROUP BY state \nORDER BY complaint_count ASC \nLIMIT 1;",
            "SELECT T4.State\nFROM callcenterlogs AS T1\nINNER JOIN client AS T2 ON T1.\"rand client\" = T2.client_id\nINNER JOIN district AS T3 ON T2.district_id = T3.district_id\nINNER JOIN state AS T4 ON T3.state_abbrev = T4.StateCode\nWHERE T1.priority = 0\nGROUP BY T4.State\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.state\nFROM callcenterlogs AS T1\nINNER JOIN client AS T2 ON T1.\"rand client\" = T2.client_id\nINNER JOIN district AS T3 ON T2.district_id = T3.district_id\nINNER JOIN state AS T4 ON T3.state_abbrev = T4.StateCode\nWHERE T1.priority = 0\nGROUP BY T2.state\nORDER BY COUNT(T2.state) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "353": {
        "db_id": "retail_complains",
        "question": "Pick 5 clients with 0 priority and write down their last name.",
        "ground_truth": "SELECT T1.last FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T2.priority = 0 LIMIT 5",
        "amends": [
            "Do use `T1.last` instead of `last_name` and add table alias `T1` for the client table. Do add `INNER JOIN callcenterlogs AS T2` instead of querying only the clients table. Do use join condition `ON T1.client_id = T2.\\`rand client\\`` instead of no join condition. Do move the filter to `T2.priority = 0` instead of `priority = 0` to reference the joined table's column. The amended query now correctly joins tables and filters on the callcenterlogs priority column instead of the clients table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM clients WHERE priority = 0 LIMIT 5;",
            "SELECT T1.last \nFROM client AS T1\nINNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.\"rand client\"\nWHERE T2.priority = 0\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "5971": {
        "db_id": "books",
        "question": "What is the publisher name of the book titled The Illuminati?",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T1.title = 'The Illuminati'",
        "amends": [
            "Do join `publisher AS T2` on `T1.publisher_id = T2.publisher_id` instead of querying `books` table directly without the join. Do reference `T2.publisher_name` instead of `publisher_name` to specify the table alias. Do add the `INNER JOIN` clause to properly relate books to publishers instead of assuming the publisher_name exists in the books table. Do use table aliases `T1` for books and `T2` for publisher instead of no aliases. The amended query now correctly retrieves publisher information through the proper relationship between books and publishers tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name FROM books WHERE title = 'The Illuminati';",
            "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T1.title = 'The Illuminati'"
        ],
        "rule_sql": []
    },
    "5500": {
        "db_id": "menu",
        "question": "Provide the numbers of the menu item which includes Fresh lobsters in every style and location where that dish was used on a menu.",
        "ground_truth": "SELECT T2.menu_id, T1.xpos, T1.ypos FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T4.name = 'Fresh lobsters in every style'",
        "amends": [
            "Do select `T2.menu_id`, `T1.xpos`, `T1.ypos` instead of only `menu_item_number`. Do use `INNER JOIN` with `MenuPage AS T2` on `T1.menu_page_id = T2.id` instead of no joins. Do add `INNER JOIN` with `Menu AS T3` on `T2.menu_id = T3.id` instead of omitting it. Do use `INNER JOIN` with `Dish AS T4` on `T1.dish_id = T4.id` instead of filtering directly on dish_name. Do filter on `T4.name = 'Fresh lobsters in every style'` instead of separate `dish_name = 'Fresh lobsters' AND style = 'every' AND location = 'all'` conditions. Do remove the incorrect `style` and `location` filters instead of keeping them. The amended query now correctly joins multiple tables and uses the proper dish name filter to match the intended behavior.",
            "Do select `T2.menu_id`, `T1.xpos`, and `T1.ypos` instead of `T1.id AS menu_item_number` and `T3.location`. Do remove the alias `menu_item_number` instead of keeping it. Do omit `T3.location` instead of including it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT menu_item_number FROM menu_items WHERE dish_name = 'Fresh lobsters' AND style = 'every' AND location = 'all';",
            "SELECT T1.id AS menu_item_number, T3.location\nFROM MenuItem AS T1\nINNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id\nINNER JOIN Menu AS T3 ON T2.menu_id = T3.id\nINNER JOIN Dish AS T4 ON T1.dish_id = T4.id\nWHERE T4.name = 'Fresh lobsters in every style';",
            "SELECT T2.menu_id, T1.xpos, T1.ypos\nFROM MenuItem AS T1\nINNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id\nINNER JOIN Menu AS T3 ON T2.menu_id = T3.id\nINNER JOIN Dish AS T4 ON T1.dish_id = T4.id\nWHERE T4.name = 'Fresh lobsters in every style'"
        ],
        "rule_sql": []
    },
    "3511": {
        "db_id": "authors",
        "question": "How many papers were published in the journal \"Concepts in Magnetic Resonance Part A\"?",
        "ground_truth": "SELECT COUNT(T2.Id) FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.FullName = 'Concepts in Magnetic Resonance Part A'",
        "amends": [
            "Do join `Journal AS T1` and `Paper AS T2` with `INNER JOIN` on `T1.Id = T2.JournalId` instead of querying `papers` table directly without proper table relationships. Do filter on `T1.FullName` instead of `journal` column to reference the correct journal name attribute. Do count `T2.Id` instead of `COUNT(*)` to specifically count paper records. Do reference journal name 'Concepts in Magnetic Resonance Part A' instead of 'Concepts in Magnetic Resonance Part B' to match the intended journal. The amended query now correctly establishes the table relationship and counts papers associated with the specified journal, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE journal = 'Concepts in Magnetic Resonance Part B';",
            "SELECT COUNT(T2.Id) \nFROM Journal AS T1 \nINNER JOIN Paper AS T2 ON T1.Id = T2.JournalId \nWHERE T1.FullName = 'Concepts in Magnetic Resonance Part A'"
        ],
        "rule_sql": []
    },
    "7315": {
        "db_id": "works_cycles",
        "question": "What is the job title of the oldest employee in the company? In which department is he in?",
        "ground_truth": "SELECT T2.JobTitle, T4.Name FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID INNER JOIN Department AS T4 ON T3.DepartmentID = T4.DepartmentID ORDER BY T2.HireDate LIMIT 1",
        "amends": [
            "Do use `T2.JobTitle` and `T4.Name` instead of `job_title` and `department` in the SELECT list. Do join `Person AS T1` with `Employee AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of omitting these tables. Do add `INNER JOIN EmployeeDepartmentHistory AS T3` on `T2.BusinessEntityID = T3.BusinessEntityID` instead of missing this relationship. Do include `INNER JOIN Department AS T4` on `T3.DepartmentID = T4.DepartmentID` instead of not connecting to the department table. Do order by `T2.HireDate` instead of `age` to get the earliest hired employee. The amended query now correctly retrieves the job title and department name of the first hired employee by properly navigating the employee-department relationship through the necessary join chain."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title, department FROM employees ORDER BY age ASC LIMIT 1;",
            "SELECT T2.JobTitle, T4.Name\nFROM Person AS T1\nINNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID\nINNER JOIN Department AS T4 ON T3.DepartmentID = T4.DepartmentID\nORDER BY T2.HireDate ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2374": {
        "db_id": "superstore",
        "question": "Name the item ordered by Jonathan Doherty with the highest quantity in the East region.",
        "ground_truth": "SELECT T3.`Product Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Jonathan Doherty' AND T2.Region = 'East' ORDER BY T1.Quantity DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T3.`Product Name`` instead of `item_name` in the SELECT list. Do join multiple tables `east_superstore AS T1`, `people AS T2`, and `product AS T3` instead of querying only the `orders` table. Do use `INNER JOIN` with `T1.`Customer ID` = T2.`Customer ID`` and `T3.`Product ID` = T1.`Product ID`` instead of no joins. Do filter on `T2.`Customer Name` = 'Jonathan Doherty'` and `T2.Region = 'East'` instead of `customer_name = 'Jonathan Doherty'` and `region = 'East'`. Do order by `T1.Quantity DESC` instead of `quantity DESC`. The amended query now correctly joins related tables to retrieve the product name for the specified customer in the East region with the highest quantity, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT item_name \nFROM orders \nWHERE customer_name = 'Jonathan Doherty' \nAND region = 'East' \nORDER BY quantity DESC \nLIMIT 1;",
            "SELECT T3.\"Product Name\"\nFROM east_superstore AS T1\nINNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" AND T1.Region = T2.Region\nINNER JOIN product AS T3 ON T1.\"Product ID\" = T3.\"Product ID\" AND T1.Region = T3.Region\nWHERE T2.\"Customer Name\" = 'Jonathan Doherty' AND T2.Region = 'East'\nORDER BY T1.Quantity DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8231": {
        "db_id": "mondial_geo",
        "question": "What is the population of African in 'Turks and Caicos Islands'?",
        "ground_truth": "SELECT T2.Percentage * T1.Population FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'African' AND T1.Name = 'Turks and Caicos Islands'",
        "amends": [
            "Do select `T2.Percentage * T1.Population` as a calculated expression instead of just `population`. Do use `FROM country AS T1 INNER JOIN ethnicGroup AS T2` with two joined tables instead of a single `FROM countries` table. Do apply the join condition `ON T1.Code = T2.Country` to establish the relationship between tables instead of no join condition. Do add the filter `T2.Name = 'African'` to specify the ethnic group instead of omitting it. Do change the continent filter to use the table alias `T1.Name = 'Turks and Caicos Islands'` instead of the original `name = 'Turks and Caicos Islands' AND continent = 'Asia'` which incorrectly filtered for Asia. The amended query now correctly calculates the African population percentage for Turks and Caicos Islands instead of attempting to find it as an Asian country."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM countries WHERE name = 'Turks and Caicos Islands' AND continent = 'Asia';",
            "SELECT T2.Percentage * T1.Population \nFROM country AS T1 \nINNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country \nWHERE T1.Name = 'Turks and Caicos Islands' AND T2.Name = 'African'"
        ],
        "rule_sql": []
    },
    "3709": {
        "db_id": "college_completion",
        "question": "Please list the names of the institutes in the state of Alabama whose all graduates in total exceeded 500 in 2011?",
        "ground_truth": "SELECT DISTINCT T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.state = 'Alabama' AND T2.year = 2011 AND T2.race = 'X' AND T2.grad_cohort > 500",
        "amends": [
            "Do use `DISTINCT T1.chronname` instead of `name` without distinct. Do join `institution_details AS T1` and `institution_grads AS T2` instead of querying only `institutes`. Do use `INNER JOIN` on `T2.unitid = T1.unitid` instead of no join condition. Do add filter `T2.race = 'X'` instead of omitting it. Do use `T2.grad_cohort > 500` instead of `graduates > 500`. Do use `T2.year = 2011` instead of `year = 2011` with proper table qualification. The amended query now correctly filters by race and uses proper table joins and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM institutes WHERE state = 'Alabama' AND graduates > 500 AND year = 2011;",
            "SELECT DISTINCT T1.chronname\nFROM institution_details AS T1\nINNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid\nWHERE T1.state = 'Alabama'\nAND T2.year = 2011\nAND T2.race = 'X'\nAND T2.grad_cohort > 500"
        ],
        "rule_sql": []
    },
    "395": {
        "db_id": "retail_complains",
        "question": "List date of the review of the Eagle Capital from Indianapolis, Indiana.",
        "ground_truth": "SELECT T2.Date FROM district AS T1 INNER JOIN reviews AS T2 ON T1.district_id = T2.district_id WHERE T2.Product = 'Eagle Capital' AND T1.city = 'Indianapolis' AND T1.state_abbrev = 'IN'",
        "amends": [
            "Do select `T2.Date` instead of `review_date`. Do join `district AS T1` with `reviews AS T2` using `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only the `reviews` table. Do filter on `T2.Product = 'Eagle Capital'` instead of `company_name = 'Eagle Capital'`. Do filter on `T1.city = 'Indianapolis'` instead of `city = 'Indianapolis'`. Do filter on `T1.state_abbrev = 'IN'` instead of `state = 'Indiana'`. The amended query now correctly joins district information and uses proper table references and state abbreviations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT review_date FROM reviews WHERE company_name = 'Eagle Capital' AND city = 'Indianapolis' AND state = 'Indiana';",
            "SELECT T2.Date\nFROM reviews AS T2\nINNER JOIN district AS T1 ON T1.district_id = T2.district_id\nWHERE T2.Product = 'Eagle Capital'\nAND T1.city = 'Indianapolis'\nAND T1.state_abbrev = 'IN'"
        ],
        "rule_sql": []
    },
    "5249": {
        "db_id": "beer_factory",
        "question": "Please list the dates on which a male customer has purchased more than 3 root beers.",
        "ground_truth": "SELECT T2.TransactionDate FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Gender = 'M' GROUP BY T2.TransactionDate HAVING COUNT(T2.CustomerID) > 3",
        "amends": [
            "Do select `T2.TransactionDate` instead of `purchase_date`. Do use `INNER JOIN` between `customers AS T1` and `transaction AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying a single table. Do filter on `T1.Gender = 'M'` instead of `customer_gender = 'male'`. Do add `GROUP BY T2.TransactionDate` instead of omitting grouping. Do move the count condition to `HAVING COUNT(T2.CustomerID) > 3` instead of using `WHERE quantity > 3`. The amended query now correctly aggregates transaction dates for male customers with more than 3 transactions, matching the intended behavior.",
            "Do use backticks around the reserved keyword `transaction` instead of leaving it unquoted. The amended query now correctly handles the table name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT purchase_date FROM purchases WHERE customer_gender = 'male' AND product_name = 'root beer' AND quantity > 3;",
            "SELECT T2.TransactionDate\nFROM customers AS T1\nINNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Gender = 'M'\nGROUP BY T2.TransactionDate\nHAVING COUNT(T2.CustomerID) > 3",
            "SELECT T2.TransactionDate\nFROM customers AS T1\nINNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Gender = 'M'\nGROUP BY T2.TransactionDate\nHAVING COUNT(T2.CustomerID) > 3"
        ],
        "rule_sql": []
    },
    "7759": {
        "db_id": "hockey",
        "question": "Please list the teams that have played in 1922's Stanley Cup finals.",
        "ground_truth": "SELECT T2.name FROM TeamsSC AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = '1922'",
        "amends": [
            "Do select `T2.name` from the Teams table instead of `team_name` from a non-existent teams table. Do join `TeamsSC AS T1` with `Teams AS T2` using `INNER JOIN` on both `T1.tmID = T2.tmID` and `T1.year = T2.year` instead of querying a single table. Do filter on `T1.year = '1922'` with string comparison instead of numeric `year = 1922`. Do remove the incorrect `competition = 'Stanley Cup finals'` filter instead of keeping it. The amended query now correctly retrieves team names from the proper tables with appropriate join conditions and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE year = 1922 AND competition = 'Stanley Cup finals';",
            "SELECT T2.name \nFROM TeamsSC AS T1 \nINNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year \nWHERE T1.year = '1922'"
        ],
        "rule_sql": []
    },
    "7929": {
        "db_id": "music_platform_2",
        "question": "Find the author, rating and review creation date of review for podcast title 'In The Thick'.",
        "ground_truth": "SELECT T2.author_id, T2.rating, T2.created_at FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'In The Thick' GROUP BY T2.author_id, T2.rating, T2.created_at",
        "amends": [
            "Do select `T2.author_id`, `T2.rating`, and `T2.created_at` instead of `author`, `rating`, and `creation_date`. Do join `podcasts AS T1` with `reviews AS T2` using `INNER JOIN` on `T2.podcast_id = T1.podcast_id` instead of querying only the `reviews` table. Do filter on `T1.title = 'In The Thick'` instead of `podcast_title = 'In The Thick'`. Do add `GROUP BY T2.author_id, T2.rating, T2.created_at` instead of omitting grouping. The amended query now correctly joins tables and uses proper column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author, rating, creation_date FROM reviews WHERE podcast_title = 'In The Thick'",
            "SELECT T2.author_id, T2.rating, T2.created_at\nFROM podcasts AS T1\nINNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id\nWHERE T1.title = 'In The Thick'\nGROUP BY T2.author_id, T2.rating, T2.created_at"
        ],
        "rule_sql": []
    },
    "5641": {
        "db_id": "shipping",
        "question": "What is the last name of driver who transported shipment id 1088?",
        "ground_truth": "SELECT T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = '1088'",
        "amends": [
            "Do select `T2.last_name` from the `driver` table instead of `first_name` from `drivers`. Do join `shipment AS T1` with `driver AS T2` using `INNER JOIN` on `T1.driver_id = T2.driver_id` instead of querying only the `drivers` table. Do filter on `T1.ship_id = '1088'` with string comparison instead of numeric `shipment_id = 1088`. The amended query now correctly retrieves the driver's last name associated with the specific shipment by properly joining the related tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM drivers WHERE shipment_id = 1088;",
            "SELECT T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = '1088'"
        ],
        "rule_sql": []
    },
    "8560": {
        "db_id": "software_company",
        "question": "What is the total number of widowed customers with an age below 50?",
        "ground_truth": "SELECT COUNT(ID) FROM Customers WHERE MARITAL_STATUS = 'Widowed' AND age < 50",
        "amends": [
            "Do count `ID` instead of `*` to count specific non-null identifiers rather than all rows. Do reference table `Customers` instead of `customers` to match the correct case-sensitive table name. Do use filter `age < 50` instead of `age > 50` to correctly count customers under 50 years old rather than over 50. Do maintain the same filter condition `MARITAL_STATUS = 'Widowed'` with proper case handling. The amended query now matches the intended behavior of counting widowed customers under 50 years old."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE marital_status = 'widowed' AND age > 50;",
            "SELECT COUNT(ID) FROM Customers WHERE MARITAL_STATUS = 'Widowed' AND age < 50"
        ],
        "rule_sql": []
    },
    "4059": {
        "db_id": "public_review_platform",
        "question": "Please indicate the closing hours and business days of the businesses with the category named Doctors.",
        "ground_truth": "SELECT DISTINCT T3.opening_time, T3.day_id FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE T2.category_name = 'Doctors'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T3.opening_time` and `T3.day_id` instead of `closing_hours` and `business_days` to retrieve the correct business hour information. Do join four tables (`Business_Categories`, `Categories`, `Business_Hours`, and `Days`) instead of querying only the `businesses` table to properly access the relational data structure. Do use `INNER JOIN` on `T1.category_id = T2.category_id` instead of no join condition to link categories correctly. Do add `INNER JOIN` on `T1.business_id = T3.business_id` instead of omitting the business hours relationship. Do add `INNER JOIN` on `T3.day_id = T4.day_id` instead of omitting the days relationship. Do filter on `T2.category_name = 'Doctors'` instead of `category = 'Doctors'` to use the proper category name column from the joined table. The amended query now correctly retrieves distinct opening times and day IDs for doctor businesses by properly navigating the relational schema.",
            "Do select `T3.opening_time` and `T3.day_id` instead of `T3.closing_time` and `T4.day_of_week`. Do remove the `Days` table alias `T4` from the SELECT list instead of including it, as the join to `Days` table remains but its columns are no longer needed in the output. The FROM clause with all four table joins remains unchanged, and the WHERE filter on `T2.category_name = 'Doctors'` is preserved. The amended query now correctly returns opening times and day IDs for doctor businesses instead of closing times and day names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT closing_hours, business_days FROM businesses WHERE category = 'Doctors';",
            "SELECT DISTINCT T3.closing_time, T4.day_of_week\nFROM Business_Categories T1\nINNER JOIN Categories T2 ON T1.category_id = T2.category_id\nINNER JOIN Business_Hours T3 ON T1.business_id = T3.business_id\nINNER JOIN Days T4 ON T3.day_id = T4.day_id\nWHERE T2.category_name = 'Doctors';",
            "SELECT DISTINCT T3.opening_time, T3.day_id\nFROM Business_Categories T1\nINNER JOIN Categories T2 ON T1.category_id = T2.category_id\nINNER JOIN Business_Hours T3 ON T1.business_id = T3.business_id\nINNER JOIN Days T4 ON T3.day_id = T4.day_id\nWHERE T2.category_name = 'Doctors'"
        ],
        "rule_sql": []
    },
    "8177": {
        "db_id": "sales_in_weather",
        "question": "What is the item number of the product with the highest number of units sold in store number 1 on 1/1/2012?",
        "ground_truth": "SELECT item_nbr FROM sales_in_weather WHERE `date` = '2012-01-01' AND store_nbr = 1 ORDER BY units DESC LIMIT 1",
        "amends": [
            "Do reference `item_nbr` instead of `item_number` and `units` instead of `units_sold` in the SELECT and ORDER BY clauses. Do use table `sales_in_weather` instead of `sales` in the FROM clause. Do reference `store_nbr` instead of `store_number` and use backticks for `date` instead of plain date in the WHERE clause. Do maintain the same filter conditions, ordering direction, and limit, but with corrected column and table names. The amended query now correctly references the intended schema elements and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT item_number FROM sales WHERE store_number = 1 AND date = '2012-01-01' ORDER BY units_sold DESC LIMIT 1;",
            "SELECT item_nbr FROM sales_in_weather WHERE store_nbr = 1 AND `date` = '2012-01-01' ORDER BY units DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8643": {
        "db_id": "chicago_crime",
        "question": "List the community area names in the Northwest.",
        "ground_truth": "SELECT community_area_name FROM Community_Area WHERE side = 'Northwest'",
        "amends": [
            "Do select `community_area_name` instead of `name` from the table. Do reference table `Community_Area` instead of `community_areas` as the source. Do filter on `side = 'Northwest'` instead of `direction = 'Northwest'` for the condition. The amended query now correctly retrieves Northwest community areas using the proper column and table names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM community_areas WHERE direction = 'Northwest';",
            "SELECT community_area_name FROM Community_Area WHERE side = 'Northwest';"
        ],
        "rule_sql": []
    },
    "3354": {
        "db_id": "video_games",
        "question": "What are the names of the games that were published by 505 Games?",
        "ground_truth": "SELECT T3.game_name FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T1.publisher_name = '505 Games'",
        "amends": [
            "Do use proper table joins with `publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id` instead of querying a single `games` table. Do select `T3.game_name` instead of `name` to reference the correct column from the joined table. Do filter on `T1.publisher_name = '505 Games'` instead of `publisher = '505 Games'` to use the proper column name from the publisher table. The amended query now correctly joins the publisher, game_publisher, and game tables to retrieve game names associated with the specified publisher, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE publisher = '505 Games';",
            "SELECT T3.game_name\nFROM publisher AS T1\nINNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id\nINNER JOIN game AS T3 ON T2.game_id = T3.id\nWHERE T1.publisher_name = '505 Games'"
        ],
        "rule_sql": []
    },
    "5506": {
        "db_id": "menu",
        "question": "Where is the place that menu with ID 12472 was created for?",
        "ground_truth": "SELECT location FROM Menu WHERE id = 12472",
        "amends": [
            "Do reference table `Menu` instead of `menus` in the FROM clause. Do filter on column `id` instead of `menu_id` in the WHERE condition. The amended query now correctly retrieves location data from the appropriate table using the proper primary key identifier.",
            "Do select `location` instead of `place` to use the correct column name that matches the database schema. The amended query now matches RIGHT_SQL's behavior by properly retrieving the location data for the specified menu item ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM menus WHERE menu_id = 12472",
            "SELECT place FROM Menu WHERE id = 12472;",
            "SELECT location FROM Menu WHERE id = 12472;"
        ],
        "rule_sql": []
    },
    "824": {
        "db_id": "social_media",
        "question": "What gender of users retweet more than 30 times?",
        "ground_truth": "SELECT DISTINCT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.RetweetCount > 30",
        "amends": [
            "Do use `DISTINCT T2.Gender` in the SELECT list instead of `gender, COUNT(*) as retweet_count` to return unique gender values rather than aggregated counts. Do change the FROM clause to use `twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID` instead of just `users` to properly join the twitter and user tables on the correct relationship. Do move the filter condition to `WHERE T1.RetweetCount > 30` instead of `WHERE retweet_count > 30` to filter on the actual retweet count column from the twitter table rather than the aggregated alias. Do remove the `GROUP BY gender` clause instead of keeping it since the query no longer requires aggregation. The amended query now correctly returns distinct genders of users who have retweet counts exceeding 30, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) as retweet_count FROM users WHERE retweet_count > 30 GROUP BY gender",
            "SELECT DISTINCT T2.Gender\nFROM twitter AS T1\nINNER JOIN user AS T2 ON T1.UserID = T2.UserID\nWHERE T1.RetweetCount > 30"
        ],
        "rule_sql": []
    },
    "8295": {
        "db_id": "mondial_geo",
        "question": "What is the most populated city of the 12th highest density country?",
        "ground_truth": "SELECT T2.Name FROM country AS T1 INNER JOIN city AS T2 ON T1.Code = T2.Country WHERE T1.Name = ( SELECT Name FROM country ORDER BY CAST(Population AS REAL) / Area LIMIT 11, 1 ) ORDER BY T2.Population DESC LIMIT 1",
        "amends": [
            "Do join `country AS T1` and `city AS T2` instead of just `city` and `country`. Do use `T1.Code = T2.Country` as the join condition instead of `city.country_id = country.id`. Do add a subquery to find the country name by calculating population density with `CAST(Population AS REAL) / Area` and selecting the 12th ranked country using `LIMIT 11, 1` instead of filtering by `density_rank = 12`. Do select `T2.Name` instead of `city.name` and order by `T2.Population DESC` instead of `city.population DESC`. The amended query now correctly identifies the 12th most densely populated country and returns its most populous city, matching the RIGHT_SQL's behavior.",
            "Do use a direct subquery with `ORDER BY CAST(Population AS REAL) / Area` instead of nesting an additional subquery with density calculation and filtering. Do remove the unnecessary `WHERE Area > 0` filter instead of keeping it, as the division operation handles zero areas appropriately. Do maintain the same `LIMIT 11, 1` offset logic instead of changing it. Do preserve the `INNER JOIN` between country and city tables instead of modifying the join type. Do keep the same `ORDER BY T2.Population DESC LIMIT 1` structure instead of altering the final sorting and limiting. The amended query now correctly identifies the 12th densest country and finds its most populous city, matching the RIGHT_SQL's behavior.",
            "Do remove the `DESC` keyword from the subquery's `ORDER BY CAST(Population AS REAL) / Area` instead of including it, as the original descending order was incorrect for selecting the 11th row by population density. The amended query now correctly matches the RIGHT_SQL's behavior by maintaining proper ordering semantics in the subquery while preserving all other structural elements including the JOIN condition, WHERE filter, and final ordering by city population."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city.name \nFROM city \nJOIN country ON city.country_id = country.id \nWHERE country.density_rank = 12 \nORDER BY city.population DESC \nLIMIT 1;",
            "SELECT T2.Name\nFROM country AS T1\nJOIN city AS T2 ON T1.Code = T2.Country\nWHERE T1.Name = (\n    SELECT Name\n    FROM (\n        SELECT Name, CAST(Population AS REAL) / Area AS density\n        FROM country\n        WHERE Area > 0\n        ORDER BY density DESC\n        LIMIT 11, 1\n    )\n)\nORDER BY T2.Population DESC\nLIMIT 1;",
            "SELECT T2.Name\nFROM country AS T1\nINNER JOIN city AS T2 ON T1.Code = T2.Country\nWHERE T1.Name = (\n    SELECT Name\n    FROM country\n    ORDER BY CAST(Population AS REAL) / Area DESC\n    LIMIT 11, 1\n)\nORDER BY T2.Population DESC\nLIMIT 1",
            "SELECT T2.Name\nFROM country AS T1\nINNER JOIN city AS T2 ON T1.Code = T2.Country\nWHERE T1.Name = (\n    SELECT Name\n    FROM country\n    ORDER BY CAST(Population AS REAL) / Area\n    LIMIT 11, 1\n)\nORDER BY T2.Population DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5121": {
        "db_id": "address",
        "question": "Calculate the average male median age of all the residential areas in Windham county.",
        "ground_truth": "SELECT SUM(T2.male_median_age) / COUNT(T2.median_age) FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.county = 'WINDHAM'",
        "amends": [
            "Do use `SUM(T2.male_median_age) / COUNT(T2.median_age)` instead of `AVG(female_median_age)` for the calculation. Do join `country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code` instead of querying only `residential_areas`. Do filter on `T1.county = 'WINDHAM'` with uppercase instead of `county = 'Windham'` with mixed case. Do reference `T2.male_median_age` and `T2.median_age` from the joined table instead of `female_median_age` from a single table. The amended query now correctly calculates the average male median age by joining county and zip code data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(female_median_age) FROM residential_areas WHERE county = 'Windham';",
            "SELECT SUM(T2.male_median_age) / COUNT(T2.median_age) AS average_male_median_age\nFROM country AS T1\nINNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code\nWHERE T1.county = 'WINDHAM'"
        ],
        "rule_sql": []
    },
    "106": {
        "db_id": "movie_platform",
        "question": "What is the average score for the movie Versailles Rive-Gauche?",
        "ground_truth": "SELECT AVG(T1.rating_score) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title LIKE 'Versailles Rive-Gauche'",
        "amends": [
            "Do select `AVG(T1.rating_score)` from the ratings table instead of `AVG(rating)` from movies. Do join `ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id` instead of querying only the movies table. Do filter with `T2.movie_title LIKE 'Versailles Rive-Gauche'` instead of `title = 'Versailles Rive-Gauche'` to properly match the movie title. The amended query now correctly calculates average ratings by joining the ratings table with movies and using appropriate column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM movies WHERE title = 'Versailles Rive-Gauche';",
            "SELECT AVG(T1.rating_score) \nFROM ratings AS T1 \nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id \nWHERE T2.movie_title LIKE 'Versailles Rive-Gauche'"
        ],
        "rule_sql": []
    },
    "8286": {
        "db_id": "mondial_geo",
        "question": "What kind of government does Iran have?",
        "ground_truth": "SELECT T2.Government FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Iran'",
        "amends": [
            "Do select `T2.Government` instead of `government_type` from the `politics` table instead of the `countries` table. Do use an `INNER JOIN` between `country AS T1` and `politics AS T2` on `T1.Code = T2.Country` instead of querying a single table. Do filter on `T1.Name = 'Iran'` instead of `name = 'Iran'` to reference the joined table correctly. The amended query now properly joins the country and politics tables to retrieve the government information from the correct source table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT government_type FROM countries WHERE name = 'Iran';",
            "SELECT T2.Government FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Iran'"
        ],
        "rule_sql": []
    },
    "281": {
        "db_id": "retail_complains",
        "question": "What is the number of complaints related to Credit cards came from female clients?",
        "ground_truth": "SELECT COUNT(T1.sex) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.sex = 'Female' AND T2.Product = 'Credit card'",
        "amends": [
            "Do select `COUNT(T1.sex)` instead of `COUNT(*)` to count specific column values rather than all rows. Do use tables `client AS T1` and `events AS T2` instead of just `complaints` to properly join related data sources. Do perform an `INNER JOIN` on `T1.client_id = T2.Client_ID` instead of querying a single table to establish the correct relationship between client and event data. Do filter on `T1.sex = 'Female'` instead of `gender = 'Male'` to target the correct gender column and value. Do filter on `T2.Product = 'Credit card'` instead of `product = 'Credit card'` to reference the product column from the correct joined table. The amended query now correctly counts female clients with credit card events by joining the appropriate tables and filtering on the right columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE product = 'Credit card' AND gender = 'Male';",
            "SELECT COUNT(T1.sex) \nFROM client AS T1 \nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID \nWHERE T1.sex = 'Female' AND T2.Product = 'Credit card'"
        ],
        "rule_sql": []
    },
    "2581": {
        "db_id": "regional_sales",
        "question": "List all the order numbers for In-Store sales and find the city where the store is located.",
        "ground_truth": "SELECT DISTINCT T1.OrderNumber, T2.`City Name` FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID WHERE T1.`Sales Channel` = 'In-Store'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do reference `OrderNumber` and `City Name` instead of `order_number` and `city` with proper column naming. Do use `INNER JOIN` with `StoreID = _StoreID` instead of `JOIN` with `store_id = store_id` to correctly match the join condition. Do reference `Sales Channel` instead of `sales_type` for the filter column. Do use table aliases `T1` and `T2` instead of `o` and `s` for consistency. The amended query now correctly retrieves distinct order numbers with their corresponding city names for in-store sales by properly joining on the correct store ID relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.order_number, s.city\nFROM orders o\nJOIN stores s ON o.store_id = s.store_id\nWHERE o.sales_type = 'In-Store'",
            "SELECT DISTINCT T1.OrderNumber, T2.\"City Name\"\nFROM \"Sales Orders\" T1\nINNER JOIN \"Store Locations\" T2 ON T1._StoreID = T2.StoreID\nWHERE T1.\"Sales Channel\" = 'In-Store';"
        ],
        "rule_sql": []
    },
    "7618": {
        "db_id": "hockey",
        "question": "What is the average weight of players who have height greater than 72 inches.",
        "ground_truth": "SELECT AVG(weight) FROM Master WHERE height > 72",
        "amends": [
            "Do select `AVG(weight)` instead of `AVG(height)` and use table `Master` instead of `players`. Do filter on `height > 72` instead of `weight > 72`, changing both the column and comparison direction. The amended query now correctly calculates average weight for players taller than 72 units, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(height) FROM players WHERE weight > 72;",
            "SELECT AVG(weight) FROM Master WHERE height > 72"
        ],
        "rule_sql": []
    },
    "5128": {
        "db_id": "address",
        "question": "What is the CBSA name and type in York, ME?",
        "ground_truth": "SELECT T1.CBSA_name, T1.CBSA_type FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T2.city = 'York' AND T2.state = 'ME'",
        "amends": [
            "Do add `INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA` instead of querying `cbsa_data` directly. Do change the FROM clause to use `CBSA AS T1` instead of `cbsa_data`. Do reference columns `T1.CBSA_name` and `T1.CBSA_type` instead of `cbsa_name` and `cbsa_type`. Do move the filters `city = 'York'` and `state = 'ME'` to apply to `T2` instead of the original table. The amended query now correctly joins the CBSA table with zip_data to filter based on city and state information from the zip data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cbsa_name, cbsa_type FROM cbsa_data WHERE city = 'York' AND state = 'ME';",
            "SELECT T1.CBSA_name, T1.CBSA_type \nFROM CBSA AS T1 \nINNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA \nWHERE T2.city = 'York' AND T2.state = 'ME'"
        ],
        "rule_sql": []
    },
    "7167": {
        "db_id": "works_cycles",
        "question": "What kind of transaction type for the \"HL Road Frame - Black, 48\" order happened in 2012/12/13?",
        "ground_truth": "SELECT T1.TransactionType FROM TransactionHistory AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'HL Road Frame - Black, 48' AND STRFTIME('%Y-%m-%d',T1.TransactionDate) = '2013-07-31'",
        "amends": [
            "Do join `Product` table via `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying `transactions` table directly without any joins. Do reference `TransactionType` from the joined table instead of `transaction_type` from a single table. Do filter on `T2.Name` instead of `product_name` to use the proper column from the Product table. Do use `STRFTIME('%Y-%m-%d',T1.TransactionDate)` for date formatting instead of direct date comparison with different format. Do filter for date '2013-07-31' instead of '2012/12/13' to match the correct transaction date. The amended query now properly joins product information and uses correct date formatting to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_type FROM transactions WHERE product_name = 'HL Road Frame - Black, 48' AND transaction_date = '2012/12/13';",
            "SELECT T1.TransactionType\nFROM TransactionHistory T1\nINNER JOIN Product T2 ON T1.ProductID = T2.ProductID\nWHERE T2.Name = 'HL Road Frame - Black, 48'\nAND STRFTIME('%Y-%m-%d', T1.TransactionDate) = '2013-07-31'"
        ],
        "rule_sql": []
    },
    "6026": {
        "db_id": "books",
        "question": "Indicate the complete address of customers located in Lazaro Cardenas.",
        "ground_truth": "SELECT street_number, street_name, city, country_id FROM address WHERE city = 'Lazaro Cardenas'",
        "amends": [
            "Do select specific columns `street_number`, `street_name`, `city`, `country_id` instead of using `SELECT *` to retrieve all columns. Do query from the `address` table instead of the `customers` table while maintaining the same `WHERE city = 'Lazaro Cardenas'` filter condition. The amended query now correctly retrieves address information from the appropriate table with explicit column selection, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE city = 'Lazaro Cardenas';",
            "SELECT street_number, street_name, city, country_id FROM address WHERE city = 'Lazaro Cardenas'"
        ],
        "rule_sql": []
    },
    "8171": {
        "db_id": "sales_in_weather",
        "question": "Provide the code summarization for the weather recorded by the weather station which contained the no.2 store on 2013/2/12.",
        "ground_truth": "SELECT T1.codesum FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T1.`date` = '2013-02-12' AND T2.store_nbr = 2",
        "amends": [
            "Do select only `T1.codesum` instead of all columns with `*`. Do join `relation AS T2` with `INNER JOIN` on `T1.station_nbr = T2.station_nbr` instead of querying only the `weather` table. Do filter with `T2.store_nbr = 2` instead of `station_id = 2`. Do use backticks for `date` column instead of unquoted identifier. The amended query now correctly joins weather data with store relations and returns only the codesum for the specified store number on the given date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM weather WHERE station_id = 2 AND date = '2013-02-12';",
            "SELECT T1.codesum FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T2.store_nbr = 2 AND T1.`date` = '2013-02-12'"
        ],
        "rule_sql": []
    },
    "4375": {
        "db_id": "student_loan",
        "question": "Please list the male students that are disabled and have filed for bankruptcy.",
        "ground_truth": "SELECT T1.name, T2.name, T3.name FROM disabled AS T1 INNER JOIN male AS T2 ON T1.`name` = T2.`name` INNER JOIN filed_for_bankrupcy AS T3 ON T1.`name` = T3.`name`",
        "amends": [
            "Do select specific columns `T1.name`, `T2.name`, `T3.name` instead of using `SELECT *`. Do use `INNER JOIN` with table `disabled AS T1` instead of querying `students` table. Do add join condition `T1.name = T2.name` with table `male AS T2` instead of filtering `gender = 'female'`. Do add join condition `T1.name = T3.name` with table `filed_for_bankrupcy AS T3` instead of filtering `disability_status = 'no'` and `bankruptcy_status = 'no'`. Do remove the `WHERE` clause entirely instead of keeping filter conditions. The amended query now correctly joins three tables to find matching names across disabled, male, and bankruptcy-filed individuals, matching the RIGHT_SQL's behavior.",
            "Do add `T2.name, T3.name` to the SELECT list instead of only selecting `T1.name`. Do use backticks around column names in join conditions (`T1.name` = `T2.name` and `T1.name` = `T3.name`) instead of unquoted identifiers. The amended query now correctly returns names from all three joined tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE gender = 'female' AND disability_status = 'no' AND bankruptcy_status = 'no';",
            "SELECT T1.name FROM disabled AS T1 INNER JOIN male AS T2 ON T1.name = T2.name INNER JOIN filed_for_bankrupcy AS T3 ON T1.name = T3.name",
            "SELECT T1.name, T2.name, T3.name \nFROM disabled AS T1 \nINNER JOIN male AS T2 ON `T1`.`name` = `T2`.`name` \nINNER JOIN filed_for_bankrupcy AS T3 ON `T1`.`name` = `T3`.`name`"
        ],
        "rule_sql": []
    },
    "872": {
        "db_id": "cs_semester",
        "question": "Give the number of research postgraduate students.",
        "ground_truth": "SELECT COUNT(student_id) FROM student WHERE type = 'RPG'",
        "amends": [
            "Do reference the `student` table instead of `students`, and use `COUNT(student_id)` instead of `COUNT(*)` to count non-null student IDs. Do filter on `type = 'RPG'` instead of `student_type = 'undergraduate'` to target the correct student category. The amended query now correctly counts RPG students from the proper table while ensuring accurate non-null counting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE student_type = 'undergraduate';",
            "SELECT COUNT(student_id) FROM student WHERE type = 'RPG';"
        ],
        "rule_sql": []
    },
    "5195": {
        "db_id": "address",
        "question": "Indicate the name of the congressman represent in Guanica.",
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE T1.city = 'Guanica'",
        "amends": [
            "Do select `first_name` and `last_name` from the `congress` table instead of just `name` from `congressmen`. Do join three tables using `INNER JOIN` instead of querying a single table. Do add `zip_data` and `zip_congress` tables with proper join conditions on `zip_code` instead of omitting them. Do filter on `city = 'Guanica'` instead of `district = 'Guanica'` to correctly identify the location. Do use the proper relationship chain through `zip_congress` to connect zip codes to congressional districts instead of directly filtering by district name. The amended query now correctly retrieves congress members by joining geographic data through proper relational pathways."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM congressmen WHERE district = 'Guanica';",
            "SELECT c.first_name, c.last_name\nFROM congress c\nINNER JOIN zip_congress zc ON c.cognress_rep_id = zc.district\nINNER JOIN zip_data zd ON zc.zip_code = zd.zip_code\nWHERE zd.city = 'Guanica';"
        ],
        "rule_sql": []
    },
    "2061": {
        "db_id": "music_tracker",
        "question": "Among the releases that were released in 2000, how many of them were released as an album and tagged \"pop\"?",
        "ground_truth": "SELECT COUNT(T1.groupName) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'pop' AND T1.releaseType = 'album' AND T1.groupYear = 2000",
        "amends": [
            "Do select `COUNT(T1.groupName)` instead of `COUNT(*)` to count specific non-null values. Do use `FROM torrents AS T1 INNER JOIN tags AS T2` instead of `FROM releases` to join two tables rather than querying a single table. Do apply join condition `ON T1.id = T2.id` instead of no join condition to properly relate the tables. Do filter with `T2.tag = 'pop'` instead of `tags LIKE '%pop%'` for exact tag matching rather than pattern matching. Do use `T1.releaseType = 'album'` instead of `release_type = 'album'` with the correct table alias and column name. Do filter with `T1.groupYear = 2000` instead of `release_year = 2000` with the proper column reference. The amended query now correctly counts album releases from 2000 with the 'pop' tag by properly joining torrents and tags tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM releases \nWHERE release_year = 2000 \nAND release_type = 'album' \nAND tags LIKE '%pop%';",
            "SELECT COUNT(T1.groupName) \nFROM torrents AS T1 \nINNER JOIN tags AS T2 ON T1.id = T2.id \nWHERE T1.groupYear = 2000 \nAND T1.releaseType = 'album' \nAND T2.tag = 'pop'"
        ],
        "rule_sql": []
    },
    "3438": {
        "db_id": "video_games",
        "question": "How many games are not of the genres 'Role-Playing', 'Shooter' and 'Simulation'?",
        "ground_truth": "SELECT COUNT(T2.id) FROM genre AS T1 INNER JOIN game AS T2 ON T1.id = T2.genre_id WHERE T1.genre_name NOT IN ('Role-Playing', 'Shooter', 'Simulation')",
        "amends": [
            "Do use explicit table joins with `INNER JOIN genre AS T1 ON T1.id = T2.genre_id` instead of querying a single `games` table without proper genre relationship. Do reference the joined table structure by selecting `COUNT(T2.id)` instead of `COUNT(*)` to count specific game records. Do filter on `T1.genre_name` column instead of a non-existent `genre` column in the original table. Do maintain the same `NOT IN` condition with the three excluded genres but apply it to the correct genre name field from the joined genre table. The amended query now properly counts games by joining with the genre table and filtering on actual genre names rather than assuming genre data exists directly in the games table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE genre NOT IN ('Role-Playing', 'Shooter', 'Simulation');",
            "SELECT COUNT(T2.id) \nFROM game AS T2 \nINNER JOIN genre AS T1 ON T1.id = T2.genre_id \nWHERE T1.genre_name NOT IN ('Role-Playing', 'Shooter', 'Simulation')"
        ],
        "rule_sql": []
    },
    "134": {
        "db_id": "movie_platform",
        "question": "For all the movies that were released in 1995, how many lower than 3 ratings did the most popularity movie had?",
        "ground_truth": "SELECT COUNT(T1.rating_score) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.rating_score < 3 AND T2.movie_release_year = 1995 AND T2.movie_popularity = ( SELECT MAX(movie_popularity) FROM movies WHERE movie_release_year = 1995 )",
        "amends": [
            "Do use `rating_score` instead of `rating` in the SELECT clause and change the alias from `r` to `T1`. Do use `movie_release_year` instead of `year` in the WHERE filter and change the alias from `m` to `T2`. Do use `movie_popularity` instead of `popularity` in the subquery and main query comparison. Do remove the GROUP BY clause instead of keeping it since the aggregate COUNT should be applied across all matching rows rather than per movie. Do change the JOIN to an explicit INNER JOIN instead of just JOIN for clarity. Do use consistent table aliases T1 and T2 throughout instead of mixing r and m. The amended query now correctly counts all low ratings for highly popular 1995 movies without unnecessary grouping, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(r.rating) \nFROM movies m\nJOIN ratings r ON m.movie_id = r.movie_id\nWHERE m.year = 1995 \nAND r.rating < 3\nAND m.popularity = (SELECT MAX(popularity) FROM movies WHERE year = 1995)\nGROUP BY m.movie_id",
            "SELECT COUNT(*) AS low_rating_count\nFROM ratings T1\nINNER JOIN movies T2 ON T1.movie_id = T2.movie_id\nWHERE T2.movie_release_year = 1995\nAND T1.rating_score < 3\nAND T2.movie_popularity = (\n    SELECT MAX(movie_popularity)\n    FROM movies\n    WHERE movie_release_year = 1995\n)"
        ],
        "rule_sql": []
    },
    "3395": {
        "db_id": "video_games",
        "question": "How many games were released in 2001?",
        "ground_truth": "SELECT COUNT(T.id) FROM game_platform AS T WHERE T.release_year = 2001",
        "amends": [
            "Do reference the `game_platform` table instead of the `games` table. Do use `COUNT(T.id)` instead of `COUNT(*)` to count specific non-null values. Do filter on `release_year = 2001` instead of `release_year = 2000` to target the correct year. The amended query now correctly counts game platform entries from the year 2001 using the appropriate table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE release_year = 2000;",
            "SELECT COUNT(game_platform.id) FROM game_platform WHERE game_platform.release_year = 2001"
        ],
        "rule_sql": []
    },
    "3195": {
        "db_id": "donor",
        "question": "Among the projects created by a teacher from New York, how many of them have a donor from the same city?",
        "ground_truth": "SELECT COUNT(T1.projectid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.teacher_ny_teaching_fellow = 't' AND T2.donor_city = 'New York'",
        "amends": [
            "Do select `COUNT(T1.projectid)` instead of `COUNT(*)` to count specific project identifiers rather than all rows. Do use `INNER JOIN` between `projects` and `donations` on `T1.projectid = T2.projectid` instead of multiple joins including `teachers` and `donors` tables. Do filter with `T1.teacher_ny_teaching_fellow = 't'` instead of `t.city = 'New York'` to check a boolean flag rather than city location. Do filter with `T2.donor_city = 'New York'` instead of `dr.city = 'New York'` to reference the donation's city directly rather than joining to the donors table. Do remove the `teachers` and `donors` table joins entirely instead of including them, as the required data is available through direct columns in the remaining tables. The amended query now correctly matches the intended behavior by focusing on the essential relationships and using available direct attributes rather than unnecessary table joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM projects p\nJOIN teachers t ON p.teacher_id = t.id\nJOIN donations d ON p.id = d.project_id\nJOIN donors dr ON d.donor_id = dr.id\nWHERE t.city = 'New York' AND dr.city = 'New York';",
            "SELECT COUNT(T1.projectid) \nFROM projects T1\nINNER JOIN donations T2 ON T1.projectid = T2.projectid\nWHERE T1.teacher_ny_teaching_fellow = 't' \nAND T2.donor_city = 'New York'"
        ],
        "rule_sql": []
    },
    "622": {
        "db_id": "codebase_comments",
        "question": "For the method has the summary of \"Refetches the Entity from the persistent storage. Refetch is used to re-load an Entity which is marked \"Out-of-sync\", due to a save action. Refetching an empty Entity has no effect.\", what is its solution path?",
        "ground_truth": "SELECT DISTINCT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Summary = 'Refetches the Entity FROM the persistent storage. Refetch is used to re-load an Entity which is marked \"Out-of-sync\", due to a save action. Refetching an empty Entity has no effect.'",
        "amends": [
            "Do select `DISTINCT T1.Path` instead of `solution_path` without distinct. Do use `FROM Solution AS T1 INNER JOIN Method AS T2` instead of `FROM methods` alone. Do join on `T1.Id = T2.SolutionId` instead of no join condition. Do filter with `T2.Summary = 'Refetches the Entity FROM the persistent storage. Refetch is used to re-load an Entity which is marked \"Out-of-sync\", due to a save action. Refetching an empty Entity has no effect.'` instead of multiple `LIKE` conditions. The amended query now correctly joins tables and uses exact string matching instead of partial pattern matching, ensuring it returns the intended results from the proper table relationships.",
            "Do use the exact string literal `'Refetches the Entity FROM the persistent storage. Refetch is used to re-load an Entity which is marked \"Out-of-sync\", due to a save action. Refetching an empty Entity has no effect.'` in the WHERE filter instead of the incorrect version with lowercase 'from', preserving all other query structure including the SELECT DISTINCT T1.Path column list, INNER JOIN between Solution and Method tables on T1.Id = T2.SolutionId, and the overall query logic. The amended query now correctly matches the intended behavior by using the precise case-sensitive string comparison required for accurate results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT solution_path FROM methods WHERE summary LIKE '%Refetches the Entity from the persistent storage%' AND summary LIKE '%Refetch is used to re-load an Entity%' AND summary LIKE '%Refetching an empty Entity has no effect%';",
            "SELECT DISTINCT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Summary = 'Refetches the Entity from the persistent storage. Refetch is used to re-load an Entity which is marked \"Out-of-sync\", due to a save action. Refetching an empty Entity has no effect.'",
            "SELECT DISTINCT T1.Path\nFROM Solution AS T1\nINNER JOIN Method AS T2 ON T1.Id = T2.SolutionId\nWHERE T2.Summary = 'Refetches the Entity FROM the persistent storage. Refetch is used to re-load an Entity which is marked \"Out-of-sync\", due to a save action. Refetching an empty Entity has no effect.'"
        ],
        "rule_sql": []
    },
    "3054": {
        "db_id": "shakespeare",
        "question": "In Shakespeare's works between 1600 to 1610, how many of these have a character as a \"Third Servingman\"?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.work_id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.DATE BETWEEN 1600 AND 1610 AND T4.CharName = 'Third Servingman'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.work_id)` instead of `COUNT(*)` to count unique works rather than total rows. Do join multiple tables including `works AS T1`, `chapters AS T2`, `paragraphs AS T3`, and `characters AS T4` instead of querying only `shakespeare_works`. Do use `INNER JOIN` with proper join conditions `ON T1.id = T2.work_id`, `ON T2.id = T3.chapter_id`, and `ON T3.character_id = T4.id` instead of no joins. Do filter on `T1.DATE BETWEEN 1600 AND 1610` instead of `year BETWEEN 1600 AND 1610`. Do use exact match `T4.CharName = 'Third Servingman'` instead of pattern matching `characters LIKE '%Third Servingman%'`. The amended query now correctly counts distinct works containing the specific character within the date range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM shakespeare_works \nWHERE year BETWEEN 1600 AND 1610 \nAND characters LIKE '%Third Servingman%';",
            "SELECT COUNT(DISTINCT T2.work_id) \nFROM works AS T1\nINNER JOIN chapters AS T2 ON T1.id = T2.work_id\nINNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id\nINNER JOIN characters AS T4 ON T3.character_id = T4.id\nWHERE T1.Date BETWEEN 1600 AND 1610\nAND T4.CharName = 'Third Servingman'"
        ],
        "rule_sql": []
    },
    "8757": {
        "db_id": "chicago_crime",
        "question": "How many incidents have the general description of \"ASSAULT\" in the IUCR classification?",
        "ground_truth": "SELECT COUNT(*) FROM IUCR WHERE primary_description = 'ASSAULT'",
        "amends": [
            "Do reference the `IUCR` table instead of the `incidents` table. Do use the `primary_description` column instead of the `description` column for filtering assault records. The amended query now correctly counts assault incidents from the appropriate table and column, matching the intended behavior.",
            "Do query only the `IUCR` table instead of joining with `Crime` table. Do remove the `JOIN` condition `c.iucr_no = i.iucr_no` instead of including it. Do keep the `WHERE` filter on `primary_description = 'ASSAULT'` unchanged. The amended query now correctly counts records directly from the IUCR table where the primary description is assault, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM incidents WHERE description = 'ASSAULT';",
            "SELECT COUNT(*) FROM Crime c JOIN IUCR i ON c.iucr_no = i.iucr_no WHERE i.primary_description = 'ASSAULT';",
            "SELECT COUNT(*) FROM IUCR WHERE primary_description = 'ASSAULT';"
        ],
        "rule_sql": []
    },
    "4629": {
        "db_id": "disney",
        "question": "Among the movies in which Alan Tudyk is a voice actor, how many of them were released after 2012?",
        "ground_truth": "SELECT COUNT(T2.movie) FROM characters AS T1 INNER JOIN `voice-actors` AS T2 ON T1.movie_title = T2.movie WHERE T2.`voice-actor` = 'Alan Tudyk' AND SUBSTR(release_date, INSTR(release_date, '-') + 5) > 12",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `m` and `a`. Do change the FROM clause to use `characters AS T1 INNER JOIN \\`voice-actors\\` AS T2` instead of `movies m JOIN actors a`. Do modify the join condition to `T1.movie_title = T2.movie` instead of `m.movie_id = a.movie_id`. Do change the filter to `T2.\\`voice-actor\\` = 'Alan Tudyk'` instead of `a.actor_name = 'Alan Tudyk'`. Do replace the year filter with `SUBSTR(release_date, INSTR(release_date, '-') + 5) > 12` instead of `m.release_year > 2012`. Do select `COUNT(T2.movie)` instead of `COUNT(*)`. The amended query now correctly counts movies where Alan Tudyk is a voice actor rather than a regular actor, using the appropriate tables and date parsing logic.",
            "Do use backticks for `voice-actors` and `voice-actor` column names instead of double quotes to handle special characters properly. Do remove the table alias `T1.` from `release_date` in the SUBSTR function instead of qualifying it since the column exists unambiguously. Do compare against numeric value 12 instead of string '12' in the SUBSTR comparison to ensure proper numeric comparison instead of string comparison. The amended query now correctly handles special characters in identifiers, uses proper column references, and performs numeric comparison for the date substring logic.",
            "Do remove the `CAST(... AS INTEGER)` around the `SUBSTR` expression instead of keeping it, as the comparison with numeric value `12` works correctly without explicit casting when the substring contains numeric year values. Do keep all other elements identical including the `COUNT(T2.movie)` aggregation, `INNER JOIN` between `characters` and `voice-actors` on `T1.movie_title = T2.movie`, the filter on `T2.voice-actor = 'Alan Tudyk'`, and the year extraction logic using `SUBSTR(release_date, INSTR(release_date, '-') + 5) > 12`. The amended query now correctly counts movies featuring Alan Tudyk as a voice actor where the release year exceeds 12, matching the intended behavior without unnecessary type conversion."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies m JOIN actors a ON m.movie_id = a.movie_id WHERE a.actor_name = 'Alan Tudyk' AND m.release_year > 2012;",
            "SELECT COUNT(T2.movie) \nFROM characters AS T1 \nINNER JOIN \"voice-actors\" AS T2 ON T1.movie_title = T2.movie\nWHERE T2.\"voice-actor\" = 'Alan Tudyk' \nAND SUBSTR(T1.release_date, INSTR(T1.release_date, '-') + 5) > '12'",
            "SELECT COUNT(T2.movie)\nFROM characters AS T1\nINNER JOIN `voice-actors` AS T2 ON T1.movie_title = T2.movie\nWHERE T2.`voice-actor` = 'Alan Tudyk'\nAND CAST(SUBSTR(release_date, INSTR(release_date, '-') + 5) AS INTEGER) > 12",
            "SELECT COUNT(T2.movie)\nFROM characters AS T1\nINNER JOIN `voice-actors` AS T2 ON T1.movie_title = T2.movie\nWHERE T2.`voice-actor` = 'Alan Tudyk'\nAND SUBSTR(release_date, INSTR(release_date, '-') + 5) > 12"
        ],
        "rule_sql": []
    },
    "3453": {
        "db_id": "video_games",
        "question": "Which region has the highest number of games sold on all platforms?",
        "ground_truth": "SELECT T.region_name FROM ( SELECT T2.region_name, SUM(T1.num_sales) FROM region_sales AS T1 INNER JOIN region AS T2 ON T1.region_id = T2.id INNER JOIN game_platform AS T3 ON T1.game_platform_id = T3.id INNER JOIN platform AS T4 ON T3.platform_id = T4.id GROUP BY T4.platform_name ORDER BY SUM(T1.num_sales) DESC LIMIT 1 ) t",
        "amends": [
            "Do select `T.region_name` instead of `region` and `COUNT(*) as total_games`. Do use a subquery instead of querying the `games` table directly. Do join `region_sales AS T1` with `region AS T2` on `T1.region_id = T2.id` instead of no joins. Do add joins to `game_platform AS T3` on `T1.game_platform_id = T3.id` and `platform AS T4` on `T3.platform_id = T4.id` instead of omitting these tables. Do aggregate by `T4.platform_name` instead of `region`. Do calculate `SUM(T1.num_sales)` instead of `COUNT(*)`. Do order by `SUM(T1.num_sales) DESC` instead of `total_games DESC`. The amended query now correctly identifies the region with the highest total sales across platforms rather than simply counting games by region.",
            "Do select only `T.region_name` instead of including `SUM(T1.num_sales)` in the outer query. Do use a subquery instead of a simple main query. Do change the join from `JOIN` to explicit `INNER JOIN` for clarity. Do change the GROUP BY to `T4.platform_name` instead of `T2.region_name`. Do order by `SUM(T1.num_sales)` instead of the alias `total_sales`. Do remove the alias `total_sales` from the inner query instead of keeping it. The amended query now correctly returns the region name associated with the platform having the highest total sales, matching the RIGHT_SQL's behavior.",
            "Do select only `T.region_name` in the outer query instead of including the unnecessary alias `T2.region_name`. Do remove the alias `as total_sales` from the aggregate function instead of keeping it. Do use lowercase `t` as the subquery alias instead of uppercase `T`. The amended query now correctly returns only the region name with the highest sales per platform, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as total_games FROM games GROUP BY region ORDER BY total_games DESC LIMIT 1;",
            "SELECT T2.region_name, SUM(T1.num_sales) as total_sales\nFROM region_sales AS T1\nJOIN region AS T2 ON T1.region_id = T2.id\nJOIN game_platform AS T3 ON T1.game_platform_id = T3.id\nJOIN platform AS T4 ON T3.platform_id = T4.id\nGROUP BY T2.region_name\nORDER BY total_sales DESC\nLIMIT 1;",
            "SELECT T2.region_name\nFROM (\n    SELECT T2.region_name, SUM(T1.num_sales) as total_sales\n    FROM region_sales AS T1\n    INNER JOIN region AS T2 ON T1.region_id = T2.id\n    INNER JOIN game_platform AS T3 ON T1.game_platform_id = T3.id\n    INNER JOIN platform AS T4 ON T3.platform_id = T4.id\n    GROUP BY T4.platform_name\n    ORDER BY SUM(T1.num_sales) DESC\n    LIMIT 1\n) AS T",
            "SELECT t.region_name\nFROM (\n    SELECT T2.region_name, SUM(T1.num_sales) as total_sales\n    FROM region_sales AS T1\n    INNER JOIN region AS T2 ON T1.region_id = T2.id\n    INNER JOIN game_platform AS T3 ON T1.game_platform_id = T3.id\n    INNER JOIN platform AS T4 ON T3.platform_id = T4.id\n    GROUP BY T4.platform_name\n    ORDER BY SUM(T1.num_sales) DESC\n    LIMIT 1\n) t"
        ],
        "rule_sql": []
    },
    "4604": {
        "db_id": "mental_health_survey",
        "question": "How many different answers did the question \"Describe the conversation you had with your previous employer about your mental health, including their reactions and actions taken to address your mental health issue/questions.\" get?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.AnswerText) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questiontext LIKE 'Describe the conversation you had with your previous employer about your mental health, including their reactions and actions taken to address your mental health issue/questions.'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.AnswerText)` instead of `COUNT(*)` to count unique answers rather than all rows. Do join `Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid` instead of using a subquery with `WHERE question_id = (SELECT id FROM questions)`. Do filter with `WHERE T2.questiontext LIKE` a specific mental health question text instead of the generic `'%mental health%'` pattern. Do reference tables as `Answer` and `Question` with aliases `T1` and `T2` instead of `answers` and `questions` without aliases. The amended query now correctly counts distinct answers to a specific mental health question using proper join syntax instead of a potentially inefficient subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM answers WHERE question_id = (SELECT id FROM questions WHERE text LIKE '%mental health%');",
            "SELECT COUNT(DISTINCT T1.AnswerText) \nFROM Answer AS T1 \nINNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid \nWHERE T2.questiontext = 'Describe the conversation you had with your previous employer about your mental health, including their reactions and actions taken to address your mental health issue/questions.'"
        ],
        "rule_sql": []
    },
    "6791": {
        "db_id": "retails",
        "question": "How many clients from Mozambique required orders with a low priority order?",
        "ground_truth": "SELECT COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey INNER JOIN orders AS T3 ON T1.c_custkey = T3.o_custkey WHERE T2.n_name = 'MOZAMBIQUE' AND T3.o_orderpriority = '5-LOW'",
        "amends": [
            "Do use `COUNT(T1.c_custkey)` instead of `COUNT(*)` to count specific customer keys. Do join `customer AS T1` with `nation AS T2` on `T1.c_nationkey = T2.n_nationkey` instead of querying a single table. Do add `INNER JOIN orders AS T3` on `T1.c_custkey = T3.o_custkey` instead of omitting the orders table. Do filter on `T2.n_name = 'MOZAMBIQUE'` instead of `country = 'Mozambique'` to use the nation table's name field. Do filter on `T3.o_orderpriority = '5-LOW'` instead of `order_priority = 'low'` to match the correct priority format from the orders table. The amended query now correctly counts customers from Mozambique with low priority orders by properly joining the necessary tables and using the appropriate column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE country = 'Mozambique' AND order_priority = 'low';",
            "SELECT COUNT(T1.c_custkey) \nFROM customer AS T1\nINNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey\nINNER JOIN orders AS T3 ON T1.c_custkey = T3.o_custkey\nWHERE T2.n_name = 'MOZAMBIQUE' \nAND T3.o_orderpriority = '5-LOW'"
        ],
        "rule_sql": []
    },
    "6151": {
        "db_id": "food_inspection_2",
        "question": "What is the assumed name of the business that has the highest total fine in 2014?",
        "ground_truth": "SELECT T.dba_name FROM ( SELECT T1.dba_name, SUM(T3.fine) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y', T2.inspection_date) = '2014' GROUP BY T1.dba_name ORDER BY SUM(T3.fine) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do use `T.dba_name` instead of `business_name` as the output column. Do add a subquery structure instead of a simple WHERE clause with subquery. Do join `establishment AS T1`, `inspection AS T2`, and `violation AS T3` tables instead of querying only a single `businesses` table. Do use `INNER JOIN` on `T1.license_no = T2.license_no` and `T3.inspection_id = T2.inspection_id` instead of no joins. Do filter with `strftime('%Y', T2.inspection_date) = '2014'` instead of `year = 2014`. Do aggregate with `SUM(T3.fine)` and `GROUP BY T1.dba_name` instead of using `total_fine`. Do add `ORDER BY SUM(T3.fine) DESC LIMIT 1` to get the maximum value instead of using a subquery with MAX. The amended query now correctly calculates the business with the highest total fines in 2014 by properly joining establishment, inspection, and violation tables and summing individual fines."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_name FROM businesses WHERE total_fine = (SELECT MAX(total_fine) FROM businesses WHERE year = 2014);",
            "SELECT T1.dba_name\nFROM establishment AS T1\nINNER JOIN inspection AS T2 ON T1.license_no = T2.license_no\nINNER JOIN violation AS T3 ON T3.inspection_id = T2.inspection_id\nWHERE strftime('%Y', T2.inspection_date) = '2014'\nGROUP BY T1.dba_name\nORDER BY SUM(T3.fine) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "294": {
        "db_id": "retail_complains",
        "question": "How many complaints are not in process with an agent?",
        "ground_truth": "SELECT COUNT(outcome) FROM callcenterlogs WHERE outcome != 'AGENT'",
        "amends": [
            "Do select `COUNT(outcome)` instead of `COUNT(*)` to count only non-null outcome values. Do use table `callcenterlogs` instead of `complaints` to query the correct data source. Do filter on `outcome != 'AGENT'` instead of `status != 'in process' AND agent_id IS NOT NULL` to apply the appropriate condition for counting non-agent outcomes. The amended query now correctly counts non-agent outcomes from the callcenterlogs table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE status != 'in process' AND agent_id IS NOT NULL;",
            "SELECT COUNT(outcome) FROM callcenterlogs WHERE outcome != 'AGENT';"
        ],
        "rule_sql": []
    },
    "2592": {
        "db_id": "regional_sales",
        "question": "Among the sales with 40% discount via in-store channel, how many products were shipped from warehouse code of WARE-NMK1003?",
        "ground_truth": "SELECT COUNT(DISTINCT T) FROM ( SELECT CASE  WHEN `Sales Channel` = 'In-Store' AND WarehouseCode = 'WARE-NMK1003' AND `Discount Applied` = '0.4' THEN OrderNumber ELSE NULL END AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "amends": [
            "Do use `COUNT(DISTINCT T)` instead of `COUNT(*)` to count distinct order numbers rather than all rows. Do add a subquery with `CASE` expression instead of querying the table directly. Do reference columns `Sales Channel`, `WarehouseCode`, and `Discount Applied` instead of `channel`, `warehouse_code`, and `discount`. Do use string comparison `'In-Store'` instead of `'in-store'` for case sensitivity. Do use decimal format `'0.4'` instead of integer `40` for the discount value. Do filter with `T IS NOT NULL` in the outer query instead of applying all conditions in the WHERE clause. Do select from table `Sales Orders` instead of `sales`. The amended query now correctly counts distinct order numbers meeting the specified conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM sales \nWHERE discount = 40 \nAND channel = 'in-store' \nAND warehouse_code = 'WARE-NMK1003';",
            "SELECT COUNT(DISTINCT T) \nFROM (\n    SELECT \n        CASE \n            WHEN \"Sales Channel\" = 'In-Store' \n            AND WarehouseCode = 'WARE-NMK1003' \n            AND \"Discount Applied\" = 0.4 \n            AND ShipDate IS NOT NULL \n            THEN OrderNumber \n        END AS T\n    FROM \"Sales Orders\"\n) \nWHERE T IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "5346": {
        "db_id": "beer_factory",
        "question": "Which of the root beer brand have the lowest purchase?",
        "ground_truth": "SELECT T2.BrandName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID GROUP BY T2.BrandID ORDER BY COUNT(T1.BrandID) LIMIT 1",
        "amends": [
            "Do select `T2.BrandName` instead of `brand, MAX(purchase_count)` and remove the aggregate function from the SELECT list. Do join `rootbeer AS T1` with `rootbeerbrand AS T2` using `INNER JOIN` on `T1.BrandID = T2.BrandID` instead of querying a single table `root_beer_sales`. Do group by `T2.BrandID` instead of `brand` to properly aggregate by brand identifier. Do order by `COUNT(T1.BrandID)` instead of `purchase_count ASC` to sort by the actual count of purchases per brand. The amended query now correctly retrieves the brand name with the lowest purchase count by joining the appropriate tables and using proper aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand, MAX(purchase_count) FROM root_beer_sales GROUP BY brand ORDER BY purchase_count ASC LIMIT 1;",
            "SELECT T2.BrandName\nFROM rootbeer AS T1\nINNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID\nGROUP BY T2.BrandID\nORDER BY COUNT(T1.BrandID) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9071": {
        "db_id": "bike_share_1",
        "question": "How many trips with a bike borrowed from the stations in San Francisco were made by a subscriber?",
        "ground_truth": "SELECT COUNT(T1.id) FROM trip AS T1 INNER JOIN station AS T2 ON T2.ID = T1.start_station_id WHERE T2.city = 'San Francisco' AND T1.subscription_type = 'Subscriber'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do reference tables as `trip AS T1` and `station AS T2` instead of `trips t` and `stations s` for proper table naming. Do use `INNER JOIN` with `T2.ID = T1.start_station_id` instead of `JOIN` with `t.start_station_id = s.station_id` for correct column references and join condition. Do filter on `T1.subscription_type = 'Subscriber'` instead of `t.subscriber_type = 'Subscriber'` to use the correct column name. The amended query now correctly counts subscriber trips from San Francisco stations with proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM trips t\nJOIN stations s ON t.start_station_id = s.station_id\nWHERE s.city = 'San Francisco' AND t.subscriber_type = 'Subscriber'",
            "SELECT COUNT(T1.id) \nFROM trip AS T1 \nINNER JOIN station AS T2 ON T2.id = T1.start_station_id \nWHERE T2.city = 'San Francisco' \nAND T1.subscription_type = 'Subscriber'"
        ],
        "rule_sql": []
    },
    "3068": {
        "db_id": "cars",
        "question": "Among the car models introduced in the market in 1970, how many of them have the USA as their origin country?",
        "ground_truth": "SELECT COUNT(*) FROM production AS T1 INNER JOIN country AS T2 ON T1.country = T2.origin WHERE T1.model_year = 1970 AND T2.country = 'USA'",
        "amends": [
            "Do join `production AS T1` and `country AS T2` with `INNER JOIN` on `T1.country = T2.origin` instead of querying only the `cars` table. Do filter on `T1.model_year = 1970` instead of `year = 1970` to reference the correct column from the joined table. Do filter on `T2.country = 'USA'` instead of `origin = 'USA'` to use the proper column from the country table. The amended query now correctly joins production and country data to count USA-made cars from 1970, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE year = 1970 AND origin = 'USA';",
            "SELECT COUNT(*) \nFROM production AS T1\nINNER JOIN country AS T2 ON T1.country = T2.origin\nWHERE T1.model_year = 1970 AND T2.country = 'USA'"
        ],
        "rule_sql": []
    },
    "4714": {
        "db_id": "disney",
        "question": "Provide the names of voice actors for the characters of films directed by Wolfgang Reitherman.",
        "ground_truth": "SELECT T2.hero, T1.`voice-actor` FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T1.movie = T2.movie_title INNER JOIN director AS T3 ON T3.name = T2.movie_title WHERE T3.director = 'Wolfgang Reitherman'",
        "amends": [
            "Do select `T2.hero` and `T1.voice-actor` instead of `va.name` only. Do use `voice-actors` table aliased as `T1` instead of `voice_actors va`. Do join `characters AS T2` on `T1.movie = T2.movie_title` instead of joining on `va.character_id = c.id`. Do add `director AS T3` table instead of omitting it. Do join `T3` on `T3.name = T2.movie_title` instead of joining films on `c.film_id = f.id`. Do filter on `T3.director = 'Wolfgang Reitherman'` instead of `f.director = 'Wolfgang Reitherman'`. The amended query now correctly retrieves hero names and voice actors for films directed by Wolfgang Reitherman using the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT va.name \nFROM voice_actors va\nJOIN characters c ON va.character_id = c.id\nJOIN films f ON c.film_id = f.id\nWHERE f.director = 'Wolfgang Reitherman';",
            "SELECT T2.hero, T1.\"voice-actor\" \nFROM \"voice-actors\" AS T1\nJOIN characters AS T2 ON T1.movie = T2.movie_title\nJOIN director AS T3 ON T3.name = T2.movie_title\nWHERE T3.director = 'Wolfgang Reitherman'"
        ],
        "rule_sql": []
    },
    "4625": {
        "db_id": "disney",
        "question": "Among the movies directed by Wolfgang Reitherman, how many of them were released in December?",
        "ground_truth": "SELECT COUNT(movie_title) FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTR(release_date, INSTR(release_date, '-') + 1, 3) = 'Dec' AND T2.director = 'Wolfgang Reitherman'",
        "amends": [
            "Do select `COUNT(movie_title)` from the `characters` table instead of `COUNT(*)` from the `movies` table. Do join `characters AS T1` with `director AS T2` using `INNER JOIN` on `T1.movie_title = T2.name` instead of querying only the `movies` table. Do filter with `T2.director = 'Wolfgang Reitherman'` instead of `director = 'Wolfgang Reitherman'`. Do use `SUBSTR(release_date, INSTR(release_date, '-') + 1, 3) = 'Dec'` for month extraction instead of `release_date LIKE '%-12-%'`. The amended query now correctly counts movie titles from the joined tables while properly handling the December date filter and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE director = 'Wolfgang Reitherman' AND release_date LIKE '%-12-%';",
            "SELECT COUNT(T1.movie_title) \nFROM characters AS T1 \nINNER JOIN director AS T2 ON T1.movie_title = T2.name \nWHERE T2.director = 'Wolfgang Reitherman' \nAND SUBSTR(T1.release_date, INSTR(T1.release_date, '-') + 1, 3) = 'Dec'"
        ],
        "rule_sql": []
    },
    "9336": {
        "db_id": "movie_3",
        "question": "Calculate the percentage of total payment of MARGARET MOORE customers.",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)) AS REAL) * 100 / SUM(T1.amount) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id",
        "amends": [
            "Do use `CAST(... AS REAL)` for percentage calculation instead of implicit integer division. Do reference columns `T1.amount` and `T2.first_name`, `T2.last_name` instead of `payment_amount` and `customer_name`. Do add `INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id` instead of querying only the payments table. Do use conditional aggregation with `IIF(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)` instead of filtering in the `WHERE` clause. Do calculate the percentage as `SUM(conditional_amount) * 100 / SUM(T1.amount)` instead of using a subquery for the denominator. The amended query now correctly handles customer identification through proper table joins and prevents division by zero issues while maintaining accurate percentage calculations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(payment_amount) / (SELECT SUM(payment_amount) FROM payments)) * 100 AS percentage\nFROM payments\nWHERE customer_name = 'MARGARET MOORE';",
            "SELECT \n    SUM(IIF(T2.first_name = 'MARGARET' AND T2.last_name = 'MOORE', T1.amount, 0)) * 100.0 / SUM(T1.amount) AS percentage\nFROM \n    payment AS T1\nINNER JOIN \n    customer AS T2 ON T1.customer_id = T2.customer_id;"
        ],
        "rule_sql": []
    },
    "7344": {
        "db_id": "works_cycles",
        "question": "How many materials still need to be assembled and have a depth of 2 between each component and their parent product?",
        "ground_truth": "SELECT COUNT(*) FROM BillOfMaterials WHERE BOMLevel = 2 AND EndDate IS NULL",
        "amends": [
            "Do reference table `BillOfMaterials` instead of `materials` in the FROM clause. Do use filter `BOMLevel = 2` instead of `depth = 2` for the level condition. Do add filter `EndDate IS NULL` instead of omitting the date validation. Do remove filter `status = 'needs_assembly'` instead of keeping the status condition. The amended query now correctly counts Bill of Materials items at level 2 that have not ended, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM materials WHERE status = 'needs_assembly' AND depth = 2",
            "SELECT COUNT(*) \nFROM BillOfMaterials \nWHERE BOMLevel = 2 \nAND EndDate IS NULL"
        ],
        "rule_sql": []
    },
    "6016": {
        "db_id": "books",
        "question": "How many customers ordered the book titled \"Anleitung zum Zickigsein\"",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.title = 'Anleitung zum Zickigsein'",
        "amends": [
            "Do join `book AS T1` and `order_line AS T2` on `T1.book_id = T2.book_id` instead of querying only the `customers` table. Do filter on `T1.title` instead of `book_title` to reference the correct table column. Do use the exact string literal 'Anleitung zum Zickigsein' instead of the incorrect column reference. The amended query now correctly counts order lines for the specified book title by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE book_title = 'Anleitung zum Zickigsein'",
            "SELECT COUNT(DISTINCT c.customer_id) \nFROM customer c\nJOIN cust_order co ON c.customer_id = co.customer_id\nJOIN order_line ol ON co.order_id = ol.order_id\nJOIN book b ON ol.book_id = b.book_id\nWHERE b.title = 'Anleitung zum Zickigsein';"
        ],
        "rule_sql": []
    },
    "7813": {
        "db_id": "hockey",
        "question": "In 1976, how many goals achieved by team 'BIR' in Division 'EW'?",
        "ground_truth": "SELECT SUM(T2.G) FROM Teams AS T1 INNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.divID = 'EW' AND T1.tmID = 'BIR' AND T1.year = 1976",
        "amends": [
            "Do join `Teams AS T1` and `Scoring AS T2` with `INNER JOIN` on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of querying a single `matches` table. Do reference `T2.G` for goals instead of `goals` and filter on `T1.divID = 'EW'` instead of `division = 'EW'`. Do filter on `T1.tmID = 'BIR'` instead of `team = 'BIR'` while keeping `T1.year = 1976` unchanged. The amended query now correctly aggregates scoring data from the Scoring table joined with team metadata from the Teams table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(goals) FROM matches WHERE team = 'BIR' AND division = 'EW' AND year = 1976",
            "SELECT SUM(T2.G) AS total_goals\nFROM Teams AS T1\nINNER JOIN Scoring AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.year = 1976\nAND T1.tmID = 'BIR'\nAND T1.divID = 'EW'"
        ],
        "rule_sql": []
    },
    "6852": {
        "db_id": "retails",
        "question": "Among the providers in Argentina, which supplier has an account that is in debt?",
        "ground_truth": "SELECT T1.s_name FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 AND T2.n_name = 'ARGENTINA'",
        "amends": [
            "Do reference the supplier table as `T1` instead of `suppliers` and select `T1.s_name` instead of `supplier_name`. Do join with `nation AS T2` on `T1.s_nationkey = T2.n_nationkey` instead of filtering by country directly. Do filter with `T1.s_acctbal < 0` instead of `account_balance > 0` to find negative balances. Do use `T2.n_name = 'ARGENTINA'` instead of `country = 'Argentina'` to match the nation name in uppercase. The amended query now correctly joins supplier and nation tables to find suppliers from Argentina with negative account balances, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT supplier_name FROM suppliers WHERE country = 'Argentina' AND account_balance > 0;",
            "SELECT T1.s_name\nFROM supplier AS T1\nJOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey\nWHERE T2.n_name = 'ARGENTINA' AND T1.s_acctbal < 0;"
        ],
        "rule_sql": []
    },
    "8659": {
        "db_id": "chicago_crime",
        "question": "How many crimes are commited on January 1, 2018?",
        "ground_truth": "SELECT COUNT(*) FROM Crime WHERE date LIKE '1/1/2018%'",
        "amends": [
            "Do reference table `Crime` instead of `crimes` in the FROM clause. Do use `LIKE '1/1/2018%'` for date pattern matching instead of exact equality `= '2018-01-01'` to accommodate different date formats. The amended query now correctly counts records from the Crime table where the date field contains the pattern for January 1, 2018, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE date = '2018-01-01';",
            "SELECT COUNT(*) FROM Crime WHERE date LIKE '1/1/2018%'"
        ],
        "rule_sql": []
    },
    "1824": {
        "db_id": "soccer_2016",
        "question": "List the id of the player who won the Orange Cap for 2 consecutive seasons.",
        "ground_truth": "SELECT Orange_Cap FROM Season GROUP BY Orange_Cap HAVING COUNT(Season_Year) > 1",
        "amends": [
            "Do select `Orange_Cap` instead of `player_id` and do use `COUNT(Season_Year) > 1` instead of `COUNT(*) = 2`. Do change the FROM clause to use `Season` table instead of `orange_cap_winners` and remove the unnecessary subquery in the WHERE clause. Do remove the redundant GROUP BY clause that was already handled by the HAVING clause. The amended query now correctly identifies players who have won the Orange Cap multiple times by counting distinct seasons rather than using a complex subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id \nFROM orange_cap_winners \nWHERE season IN (SELECT season FROM orange_cap_winners GROUP BY player_id HAVING COUNT(*) >= 2) \nGROUP BY player_id \nHAVING COUNT(*) = 2;",
            "SELECT Orange_Cap\nFROM Season\nGROUP BY Orange_Cap\nHAVING COUNT(DISTINCT Season_Year) > 1"
        ],
        "rule_sql": []
    },
    "5231": {
        "db_id": "address",
        "question": "Calculate the percentage of congress representatives from the Democrat party. Among them, how many postal points are in the Hawaii state?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*), SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END) FROM congress AS T1 INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district",
        "amends": [
            "Do use `SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN party = 'Democrat' THEN 1 END)` to properly count Democrats. Do add `CAST(... AS REAL)` instead of omitting it for accurate percentage calculation. Do change from `COUNT(CASE WHEN state = 'Hawaii' AND party = 'Democrat' THEN postal_point END)` to `SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)` instead of counting postal points to count Hawaii representatives. Do add `FROM congress AS T1 INNER JOIN zip_congress AS T2 ON T1.congress_rep_id = T2.district` instead of using only `congress_representatives` to properly join the required tables. Do remove the column aliases `democrat_percentage` and `hawaii_democrat_postal_points` instead of keeping them. The amended query now correctly calculates percentages and counts with proper table joins and aggregation logic.",
            "Do place the multiplication by 100 after the division instead of before it in the percentage calculation expression. Do maintain the same `INNER JOIN` on `T1.congress_rep_id = T2.district` without changes to join conditions or table sources. The amended query now correctly calculates the percentage by performing division before multiplication and matches the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the division instead of before it in the percentage calculation expression. Do maintain the same `INNER JOIN` on `T1.congress_rep_id = T2.district` without changes to join type or predicate. The amended query now correctly calculates the percentage by performing division before multiplication and matches the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the division instead of before it in the percentage calculation expression. Do maintain the same `INNER JOIN` on `T1.congress_rep_id = T2.district` without changing the join condition or type. Do preserve both aggregate functions `SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END)` and `SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)` without modification. Do keep the `CAST` to `REAL` and the same table aliases `T1` and `T2` from the original query. The amended query now correctly calculates the percentage by performing division before multiplication, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the division instead of before it in the percentage calculation expression. Do maintain the same `INNER JOIN` on `T1.congress_rep_id = T2.district` without changing the join condition or type. Do preserve both aggregate functions `SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END)` and `SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)` without modification. Do keep the `CAST` to `REAL` for the first aggregate calculation. The amended query now correctly calculates the percentage by performing division before multiplication, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN party = 'Democrat' THEN 1 END) * 100.0 / COUNT(*)) AS democrat_percentage,\n    COUNT(CASE WHEN state = 'Hawaii' AND party = 'Democrat' THEN postal_point END) AS hawaii_democrat_postal_points\nFROM congress_representatives;",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100,\n    SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)\nFROM congress AS T1 \nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100,\n    SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)\nFROM congress AS T1 \nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district",
            "SELECT \n    CAST(SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100,\n    SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)\nFROM congress AS T1 \nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district",
            "SELECT \n    CAST(SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100,\n    SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)\nFROM congress AS T1 \nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district",
            "SELECT \n    CAST(SUM(CASE WHEN T1.party = 'Democrat' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100,\n    SUM(CASE WHEN T1.state = 'Hawaii' THEN 1 ELSE 0 END)\nFROM congress AS T1 \nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district"
        ],
        "rule_sql": []
    },
    "2662": {
        "db_id": "regional_sales",
        "question": "Describe the product names delivered in 2021 for the customer \"Sundial\".",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.DeliveryDate LIKE '%/%/21' AND T1.`Customer Names` = 'Sundial ' THEN T3.`Product Name` END AS T FROM Customers T1 INNER JOIN `Sales Orders` T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products T3 ON T3.ProductID = T2._ProductID ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `SELECT DISTINCT CASE` instead of a simple `SELECT product_name`. Do join `Customers T1`, `Sales Orders T2`, and `Products T3` with `INNER JOIN` conditions instead of querying only the `deliveries` table. Do filter with `T2.DeliveryDate LIKE '%/%/21'` and `T1.Customer Names = 'Sundial '` in the CASE expression instead of `WHERE customer_name = 'Sundial' AND delivery_year = 2021`. Do add a trailing space in 'Sundial ' instead of omitting it. Do reference `T3.Product Name` instead of `product_name`. Do add an outer query filtering `WHERE T IS NOT NULL` instead of omitting this null check. The amended query now correctly handles the multi-table relationship and date pattern matching to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM deliveries WHERE customer_name = 'Sundial' AND delivery_year = 2021",
            "SELECT DISTINCT T\nFROM (\n    SELECT DISTINCT \n        CASE \n            WHEN T1.\"Customer Names\" = 'Sundial ' AND T2.DeliveryDate LIKE '%/%/21' \n            THEN T3.\"Product Name\" \n        END AS T\n    FROM Customers T1\n    INNER JOIN \"Sales Orders\" T2 ON T1.CustomerID = T2._CustomerID\n    INNER JOIN Products T3 ON T2._ProductID = T3.ProductID\n)\nWHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "9137": {
        "db_id": "movie_3",
        "question": "Which customer has rented more movies, RUTH MARTINEZ or LINDA WILLIAMS?",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE (T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ') OR (T1.first_name = 'LINDA' AND T1.last_name = 'WILLIAMS') GROUP BY T1.first_name, T1.last_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do select individual `first_name` and `last_name` columns instead of concatenating them as `customer_name`. Do use `INNER JOIN` instead of `LEFT JOIN` for the rental table. Do change the WHERE condition to separate `first_name` and `last_name` comparisons with AND/OR logic instead of concatenated string matching. Do group by `first_name` and `last_name` instead of `customer_id`. Do add a subquery to encapsulate the aggregation logic instead of querying directly. Do order by the count alias `num` instead of `rental_count`. The amended query now correctly filters and aggregates customer rental counts for the specified individuals while matching the RIGHT_SQL's behavior.",
            "Do use table aliases `T1` and `T2` consistently instead of partial aliasing. Do qualify all column references with table aliases like `T1.first_name` instead of unqualified `first_name`. Do add explicit table aliases in the `FROM` clause as `customer AS T1` instead of just `customer c`. Do change the aggregate function to `COUNT(T1.customer_id)` instead of `COUNT(*)` to count specific customer rentals. Do wrap the grouped query in a derived table `T` instead of querying the base tables directly in the outer query. Do select only `T.first_name, T.last_name` in the outer query instead of including the count column. The amended query now correctly uses proper table qualification and returns only the customer names with the highest rental count among the specified customers."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    c.first_name || ' ' || c.last_name AS customer_name,\n    COUNT(r.rental_id) AS rental_count\nFROM customer c\nLEFT JOIN rental r ON c.customer_id = r.customer_id\nWHERE c.first_name || ' ' || c.last_name IN ('RUTH MARTINEZ', 'LINDA WILLIAMS')\nGROUP BY c.customer_id\nORDER BY rental_count DESC\nLIMIT 1;",
            "SELECT first_name, last_name, COUNT(*) AS num\nFROM customer c\nINNER JOIN rental r ON c.customer_id = r.customer_id\nWHERE (first_name = 'RUTH' AND last_name = 'MARTINEZ') \n   OR (first_name = 'LINDA' AND last_name = 'WILLIAMS')\nGROUP BY first_name, last_name\nORDER BY num DESC\nLIMIT 1;",
            "SELECT T.first_name, T.last_name\nFROM (\n    SELECT T1.first_name, T1.last_name, COUNT(T1.customer_id) AS num\n    FROM customer AS T1\n    INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id\n    WHERE (T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ')\n       OR (T1.first_name = 'LINDA' AND T1.last_name = 'WILLIAMS')\n    GROUP BY T1.first_name, T1.last_name\n    ORDER BY num DESC\n    LIMIT 1\n) AS T"
        ],
        "rule_sql": []
    },
    "6296": {
        "db_id": "coinmarketcap",
        "question": "What's the percentage of coins that is higher than the price 1 hour ago in May 29,2013? List the names of these coins.",
        "ground_truth": "SELECT T1.NAME FROM coins AS T1 INNER JOIN historical AS T2 ON T1.ID = T2.coin_id WHERE T2.DATE = '2013-05-29' AND T2.percent_change_1h > 0",
        "amends": [
            "Do select only `T1.NAME` instead of `name` and `percentage_increase`. Do join `historical AS T2` instead of querying only the `coins` table. Do use `INNER JOIN` on `T1.ID = T2.coin_id` instead of no join. Do filter on `T2.DATE = '2013-05-29'` instead of `date = '2013-05-29'`. Do filter on `T2.percent_change_1h > 0` instead of `price > previous_price` and calculating percentage increase. Do remove the `ORDER BY percentage_increase DESC` instead of keeping it. The amended query now correctly joins the historical data table and uses the pre-calculated percent_change_1h field instead of attempting to calculate percentage increase from price fields that may not exist in the coins table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, \n       (price - previous_price) / previous_price * 100 AS percentage_increase\nFROM coins\nWHERE date = '2013-05-29'\n  AND price > previous_price\nORDER BY percentage_increase DESC;",
            "SELECT T1.name\nFROM coins AS T1\nINNER JOIN historical AS T2 ON T1.id = T2.coin_id\nWHERE T2.date = '2013-05-29'\nAND T2.percent_change_1h > 0"
        ],
        "rule_sql": []
    },
    "3633": {
        "db_id": "authors",
        "question": "How many papers were presented at 'ECSQARU' in 2003?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T2.ShortName = 'ECSQARU' AND T1.Year = '2003'",
        "amends": [
            "Do select `COUNT(T1.Id)` instead of `COUNT(*)` to count specific non-null values. Do join `Conference AS T2` instead of omitting it, using `INNER JOIN` on `T1.ConferenceId = T2.Id` instead of directly filtering on conference name. Do filter on `T2.ShortName = 'ECSQARU'` instead of `conference = 'ECSQARU'` to use the proper conference identifier. Do filter on `T1.Year = '2003'` instead of `year = 2002` to correct the year value and use string comparison. The amended query now properly joins conference tables and uses the correct year filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE conference = 'ECSQARU' AND year = 2002;",
            "SELECT COUNT(T1.Id) \nFROM Paper AS T1\nINNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id\nWHERE T2.ShortName = 'ECSQARU' AND T1.Year = '2003'"
        ],
        "rule_sql": []
    },
    "6279": {
        "db_id": "coinmarketcap",
        "question": "How many coins were added in May 2013? Please list the names of coins.",
        "ground_truth": "SELECT COUNT(id) num FROM coins WHERE STRFTIME('%Y-%m', date_added) = '2013-05' UNION ALL SELECT name FROM coins WHERE STRFTIME('%Y-%m', date_added) = '2013-05'",
        "amends": [
            "Do use `COUNT(id)` with alias `num` instead of `COUNT(*) as coin_count`. Do remove `name` from the SELECT list and instead use a separate `UNION ALL` query to select `name`. Do use `STRFTIME('%Y-%m', date_added) = '2013-05'` for precise date filtering instead of `LIKE '2013-05%'`. Do remove the `GROUP BY name` clause entirely instead of keeping it. Do split the query into two separate `SELECT` statements joined with `UNION ALL` instead of a single grouped query. The amended query now correctly returns both the count of coins and their names for May 2013 using proper date handling functions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as coin_count, name FROM coins WHERE added_date LIKE '2013-05%' GROUP BY name;",
            "SELECT COUNT(id) AS num FROM coins WHERE STRFTIME('%Y-%m', date_added) = '2013-05'\nUNION ALL\nSELECT name FROM coins WHERE STRFTIME('%Y-%m', date_added) = '2013-05'"
        ],
        "rule_sql": []
    },
    "7290": {
        "db_id": "works_cycles",
        "question": "Please list the names of the products that have over 3 price changes.",
        "ground_truth": "SELECT T2.Name FROM ProductListPriceHistory AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY T2.Name ORDER BY COUNT(T1.ListPrice) > 3",
        "amends": [
            "Do select `T2.Name` from the `Product` table instead of `name` from `products`. Do join `ProductListPriceHistory AS T1` with `Product AS T2` using `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying a single table. Do add `GROUP BY T2.Name` to aggregate by product name instead of no grouping. Do use `ORDER BY COUNT(T1.ListPrice) > 3` to order by the count condition instead of filtering with `WHERE price > 3`. Do remove the `WHERE` clause entirely instead of keeping a simple price filter. The amended query now correctly aggregates product price history counts and orders by the count condition rather than filtering individual prices.",
            "Do remove the `HAVING COUNT(T1.ListPrice) > 3` clause instead of keeping it, as the RIGHT_SQL does not include any filtering condition. Do keep the `ORDER BY COUNT(T1.ListPrice) > 3` expression instead of removing it, maintaining the sorting logic based on whether the count exceeds three. The amended query now correctly focuses on grouping by product names and ordering by the count condition without unnecessary filtering, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products WHERE price > 3;",
            "SELECT T2.Name \nFROM ProductListPriceHistory AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID \nGROUP BY T2.Name \nHAVING COUNT(T1.ListPrice) > 3 \nORDER BY COUNT(T1.ListPrice) > 3",
            "SELECT T2.Name \nFROM ProductListPriceHistory AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID \nGROUP BY T2.Name \nORDER BY COUNT(T1.ListPrice) > 3"
        ],
        "rule_sql": []
    },
    "3865": {
        "db_id": "public_review_platform",
        "question": "Please list the opening time on Mondays of all the Yelp_Businesses in Anthem that are still running.",
        "ground_truth": "SELECT T1.opening_time FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE T2.day_of_week LIKE 'Monday' AND T3.city LIKE 'Anthem' AND T3.active LIKE 'True' GROUP BY T1.opening_time",
        "amends": [
            "Do use `T1.opening_time` in the SELECT list instead of `name, hours`. Do join `Business_Hours AS T1` instead of querying `Yelp_Businesses` directly. Do add `INNER JOIN Days AS T2 ON T1.day_id = T2.day_id` to properly relate days instead of using string matching on `hours LIKE '%Monday%'`. Do add `INNER JOIN Business AS T3 ON T1.business_id = T3.business_id` to access business information instead of having it in a single table. Do use `T2.day_of_week LIKE 'Monday'` for precise day matching instead of `hours LIKE '%Monday%'`. Do use `T3.city LIKE 'Anthem'` for city filtering instead of `city = 'Anthem'`. Do use `T3.active LIKE 'True'` for business status instead of `is_open = 1`. Do add `GROUP BY T1.opening_time` to aggregate results instead of returning individual records. The amended query now properly structures the business hours data across normalized tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, hours FROM Yelp_Businesses WHERE city = 'Anthem' AND is_open = 1 AND hours LIKE '%Monday%'",
            "SELECT T1.opening_time\nFROM Business_Hours AS T1\nINNER JOIN Days AS T2 ON T1.day_id = T2.day_id\nINNER JOIN Business AS T3 ON T1.business_id = T3.business_id\nWHERE T2.day_of_week LIKE 'Monday'\n  AND T3.city LIKE 'Anthem'\n  AND T3.active LIKE 'True'\nGROUP BY T1.opening_time"
        ],
        "rule_sql": []
    },
    "4402": {
        "db_id": "student_loan",
        "question": "Student21 is enlisted in which organization and has the student been absent?",
        "ground_truth": "SELECT T2.month, T1.organ FROM enlist AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.`name` = T2.`name` WHERE T1.name = 'student21'",
        "amends": [
            "Do select `T2.month` and `T1.organ` instead of `organization_name` and `absent`. Do use `FROM enlist AS T1 INNER JOIN longest_absense_from_school AS T2` instead of `FROM students`. Do join on `T1.name = T2.name` instead of no join condition. Do filter with `T1.name = 'student21'` instead of `student_id = 21`. The amended query now correctly joins the appropriate tables and filters by student name to match the intended behavior.",
            "Do reverse the column order in the SELECT list to `T2.month, T1.organ` instead of `T1.organ, T2.month`. Do add backticks around column names in the JOIN condition as `T1.name` = `T2.name` instead of unquoted identifiers. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and quoted identifiers."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_name, absent FROM students WHERE student_id = 21",
            "SELECT T1.organ, T2.month FROM enlist AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name WHERE T1.name = 'student21'",
            "SELECT T2.`month`, T1.`organ` FROM enlist AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.`name` = T2.`name` WHERE T1.`name` = 'student21'"
        ],
        "rule_sql": []
    },
    "2535": {
        "db_id": "app_store",
        "question": "What are the apps with only 5,000+ installs?",
        "ground_truth": "SELECT DISTINCT App FROM playstore WHERE Installs = '5,000+'",
        "amends": [
            "Do select only `App` instead of all columns with `*`. Do use `DISTINCT` instead of omitting it to remove duplicates. Do filter on `Installs = '5,000+'` instead of `installs <= 5000` to match the exact string format. Do query from `playstore` table instead of `apps` table. Do use proper column name capitalization with `App` and `Installs` instead of lowercase names. The amended query now correctly selects distinct app names with exactly 5,000+ installations from the playstore table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM apps WHERE installs <= 5000;",
            "SELECT DISTINCT App FROM playstore WHERE Installs = '5,000+';"
        ],
        "rule_sql": []
    },
    "8679": {
        "db_id": "chicago_crime",
        "question": "Among the crimes, what percentage are severe?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN index_code = 'I' THEN iucr_no ELSE NULL END) AS REAL) * 100 / COUNT(iucr_no) FROM IUCR",
        "amends": [
            "Do use `COUNT(CASE WHEN index_code = 'I' THEN iucr_no ELSE NULL END)` instead of `COUNT(*)` to count specific conditions. Do reference table `IUCR` instead of `crimes` as the data source. Do remove the `WHERE severity = 'severe'` filter instead of keeping it. Do add explicit `CAST` to `REAL` instead of implicit integer division. Do use `COUNT(iucr_no)` in the denominator instead of a subquery `(SELECT COUNT(*) FROM crimes)`. The amended query now correctly calculates the percentage of records with index_code 'I' relative to all non-null iucr_no values in the IUCR table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM crimes) AS percentage FROM crimes WHERE severity = 'severe';",
            "SELECT \n    (CAST(COUNT(CASE WHEN index_code = 'I' THEN iucr_no ELSE NULL END) AS REAL) / COUNT(iucr_no)) * 100.0 \n    AS percentage_severe\nFROM IUCR;"
        ],
        "rule_sql": []
    },
    "6734": {
        "db_id": "retails",
        "question": "Calculate the total price of orders by Customer#000000013.",
        "ground_truth": "SELECT SUM(T1.o_totalprice) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_name = 'Customer#000000013'",
        "amends": [
            "Do join `customer` table with `orders` using `INNER JOIN` on `T1.o_custkey = T2.c_custkey` instead of querying `orders` alone. Do filter on `T2.c_name = 'Customer#000000013'` instead of filtering directly on `customer_id`. Do reference the price column as `T1.o_totalprice` instead of `price`. The amended query now correctly joins the customer table to filter by customer name and sum the appropriate price column, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE customer_id = 'Customer#000000013';",
            "SELECT SUM(T1.o_totalprice) AS total_price\nFROM orders T1\nINNER JOIN customer T2 ON T1.o_custkey = T2.c_custkey\nWHERE T2.c_name = 'Customer#000000013'"
        ],
        "rule_sql": []
    },
    "5102": {
        "db_id": "address",
        "question": "In which county can you find the city with the highest number of females?",
        "ground_truth": "SELECT T4.county FROM zip_data AS T3 INNER JOIN country AS T4 ON T3.zip_code = T4.zip_code GROUP BY T4.county ORDER BY T3.female_population DESC LIMIT 1",
        "amends": [
            "Do select `T4.county` from the joined tables instead of just `county` from a single table. Do add `zip_data AS T3 INNER JOIN country AS T4 ON T3.zip_code = T4.zip_code` as the data source instead of only `cities`. Do add `GROUP BY T4.county` to aggregate by county instead of omitting grouping. Do order by `T3.female_population DESC` from the joined zip_data table instead of `female_population DESC` from the original cities table. The amended query now correctly joins the necessary tables, groups by county, and uses the appropriate female population data from the zip_data table to find the county with the highest female population."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county FROM cities ORDER BY female_population DESC LIMIT 1;",
            "SELECT T4.county\nFROM zip_data AS T3\nINNER JOIN country AS T4 ON T3.zip_code = T4.zip_code\nGROUP BY T4.county\nORDER BY T3.female_population DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3567": {
        "db_id": "authors",
        "question": "How many papers were preprinted between the years 1990 and 2000?",
        "ground_truth": "SELECT COUNT(id) FROM Paper WHERE Year BETWEEN '1990' AND '2000' AND ConferenceId = 0 AND JournalId = 0",
        "amends": [
            "Do reference table `Paper` instead of `papers` and count `id` instead of `*` to avoid counting NULL values. Do use column `Year` instead of `preprint_date` and wrap the year literals in quotes instead of using bare integers. Do add filters for `ConferenceId = 0` and `JournalId = 0` instead of omitting them to properly identify preprint papers. The amended query now correctly counts preprint papers from 1990 to 2000 by ensuring only records with no associated conference or journal are included."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE preprint_date BETWEEN 1990 AND 2000;",
            "SELECT COUNT(Id) FROM Paper WHERE Year BETWEEN '1990' AND '2000' AND ConferenceId = 0 AND JournalId = 0"
        ],
        "rule_sql": []
    },
    "7602": {
        "db_id": "image_and_language",
        "question": "What object class is in the X and Y coordinates of 126 and 363?",
        "ground_truth": "SELECT T1.IMG_ID, T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.X = 126 AND T1.Y = 363",
        "amends": [
            "Do select `T1.IMG_ID` and `T2.OBJ_CLASS` instead of only `object_class`. Do use `FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2` instead of `FROM objects`. Do add join condition `ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of omitting it. Do qualify column references with table aliases in the WHERE clause as `T1.X` and `T1.Y` instead of unqualified `x` and `y`. The amended query now correctly joins the two tables to retrieve both the image ID and object class information while maintaining the same coordinate filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class FROM objects WHERE x = 126 AND y = 363;",
            "SELECT T1.IMG_ID, T2.OBJ_CLASS \nFROM IMG_OBJ AS T1 \nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID \nWHERE T1.X = 126 AND T1.Y = 363"
        ],
        "rule_sql": []
    },
    "1039": {
        "db_id": "talkingdata",
        "question": "What is the device id of the oldest user?",
        "ground_truth": "SELECT device_id FROM gender_age WHERE age = ( SELECT MAX(age) FROM gender_age )",
        "amends": [
            "Do select `device_id` from `gender_age` instead of `users`. Do add a subquery to filter by `age = (SELECT MAX(age) FROM gender_age)` instead of using `ORDER BY age ASC LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies the device_id associated with the maximum age from the gender_age table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_id FROM users ORDER BY age ASC LIMIT 1;",
            "SELECT device_id FROM gender_age WHERE age = (SELECT MAX(age) FROM gender_age)"
        ],
        "rule_sql": []
    },
    "4124": {
        "db_id": "public_review_platform",
        "question": "What is the review length of user 11021 to business with business ID 3?",
        "ground_truth": "SELECT review_length FROM Reviews WHERE user_id = 11021 AND business_id = 3",
        "amends": [
            "Do reference the `review_length` column directly instead of calculating `LENGTH(review_text)` from the source data. Do use the correct table name `Reviews` (with proper capitalization) instead of `reviews` to match the actual schema. The amended query now correctly retrieves the pre-calculated review length value rather than computing it dynamically, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT LENGTH(review_text) FROM reviews WHERE user_id = 11021 AND business_id = 3;",
            "SELECT review_length FROM Reviews WHERE user_id = 11021 AND business_id = 3;"
        ],
        "rule_sql": []
    },
    "5047": {
        "db_id": "olympics",
        "question": "Which city were the Olympic games held in 1992?",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T3.games_year = 1992",
        "amends": [
            "Do select `T2.city_name` from the `city` table instead of `city` from the `olympic_games` table. Do join `games_city AS T1` and `city AS T2` with `INNER JOIN` on `T1.city_id = T2.id` instead of querying a single table. Do add another `INNER JOIN` to `games AS T3` on `T1.games_id = T3.id` instead of omitting this table relationship. Do filter on `T3.games_year = 1992` instead of `year = 1992` to correctly reference the games year column. The amended query now properly joins the three related tables to retrieve city names for the 1992 Olympic games, matching the correct logic and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM olympic_games WHERE year = 1992;",
            "SELECT T2.city_name \nFROM games_city AS T1\nINNER JOIN city AS T2 ON T1.city_id = T2.id\nINNER JOIN games AS T3 ON T1.games_id = T3.id\nWHERE T3.games_year = 1992"
        ],
        "rule_sql": []
    },
    "5914": {
        "db_id": "books",
        "question": "What is the name of the publisher of the book \"The Illuminati\"?",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T1.title = 'The Illuminati'",
        "amends": [
            "Do select `T2.publisher_name` instead of `author` to retrieve the publisher name rather than the author. Do add `INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id` instead of querying only the books table to properly join with the publisher table. Do reference `T1.title` in the WHERE clause instead of just `title` to use the table alias. The amended query now correctly joins the book and publisher tables to find the publisher name for the specified book title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM books WHERE title = 'The Illuminati';",
            "SELECT T2.publisher_name \nFROM book AS T1 \nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id \nWHERE T1.title = 'The Illuminati'"
        ],
        "rule_sql": []
    },
    "4678": {
        "db_id": "disney",
        "question": "What is the average total gross for the movies featuring Sterling Holloway?",
        "ground_truth": "SELECT SUM(CAST(REPLACE(trim(T2.total_gross, '$'), ',', '') AS REAL)) / COUNT(T2.movie_title) FROM `voice-actors` AS T1 INNER JOIN movies_total_gross AS T2 ON T1.movie = T2.movie_title WHERE T1.`voice-actor` = 'Sterling Holloway'",
        "amends": [
            "Do use `SUM(CAST(REPLACE(trim(T2.total_gross, '$'), ',', '') AS REAL)) / COUNT(T2.movie_title)` instead of `AVG(total_gross)` to properly handle currency formatting and calculate the correct average. Do join `voice-actors` AS T1 INNER JOIN movies_total_gross AS T2 ON T1.movie = T2.movie_title instead of querying only the movies table to establish the relationship between actors and movies. Do filter on `T1.voice-actor = 'Sterling Holloway'` instead of `actor_name = 'Sterling Holloway'` to use the correct column name from the joined table. The amended query now correctly handles dollar-formatted values, joins the necessary tables to connect actors with their movie gross data, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(total_gross) FROM movies WHERE actor_name = 'Sterling Holloway';",
            "SELECT SUM(CAST(REPLACE(TRIM(T2.total_gross, '$'), ',', '') AS REAL)) / COUNT(T2.movie_title) AS average_total_gross\nFROM \"voice-actors\" AS T1\nINNER JOIN movies_total_gross AS T2 ON T1.movie = T2.movie_title\nWHERE T1.\"voice-actor\" = 'Sterling Holloway'"
        ],
        "rule_sql": []
    },
    "3547": {
        "db_id": "authors",
        "question": "Describe the paper title, published year, conference's short name and included author names in the paper ID of 15.",
        "ground_truth": "SELECT DISTINCT T1.Title, T1.Year, T3.ShortName, T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE T1.Id = 15",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct column references without table qualification. Do specify `DISTINCT` in the SELECT clause instead of omitting it to eliminate potential duplicate rows. Do select columns `T1.Title`, `T1.Year`, `T3.ShortName`, and `T2.Name` instead of `title`, `published_year`, `conference_short_name`, and `author_names` to match the actual schema. Do join tables `Paper AS T1`, `PaperAuthor AS T2`, and `Conference AS T3` instead of querying only the `papers` table. Do use `INNER JOIN` on `T1.Id = T2.PaperId` instead of missing the author relationship entirely. Do add `INNER JOIN` on `T1.ConferenceId = T3.Id` instead of omitting the conference table join. Do filter on `T1.Id = 15` instead of `paper_id = 15` to use the correct column name and table alias. The amended query now correctly retrieves paper details with associated author and conference information while preventing duplicate results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, published_year, conference_short_name, author_names FROM papers WHERE paper_id = 15",
            "SELECT DISTINCT T1.Title, T1.Year, T3.ShortName, T2.Name\nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nINNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id\nWHERE T1.Id = 15"
        ],
        "rule_sql": []
    },
    "916": {
        "db_id": "cs_semester",
        "question": "Among students registered for the most difficult course, list the students' full names who got grade A.",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T2.grade = 'A' ORDER BY T3.diff DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `s`, `e`, and `c`. Do select columns `f_name` and `l_name` instead of `first_name` and `last_name`. Do reference table `student` instead of `students`, `registration` instead of `enrollments`, and `course` instead of `courses`. Do remove the filter on `difficulty = 'hardest'` instead of keeping it. Do add `ORDER BY T3.diff DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly identifies the top student by course difficulty rather than filtering for a specific difficulty level."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s\nJOIN enrollments e ON s.student_id = e.student_id\nJOIN courses c ON e.course_id = c.course_id\nWHERE c.difficulty = 'hardest'\nAND e.grade = 'A';",
            "SELECT T1.f_name, T1.l_name\nFROM student T1\nJOIN registration T2 ON T1.student_id = T2.student_id\nJOIN course T3 ON T2.course_id = T3.course_id\nWHERE T2.grade = 'A'\nAND T3.course_id = (\n    SELECT course_id\n    FROM course\n    ORDER BY diff DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "6217": {
        "db_id": "food_inspection_2",
        "question": "What is the percentage of restaurants that paid a fine of 250 among all establishments?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.fine = 250 THEN T1.license_no END) AS REAL) * 100 / COUNT(T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE T1.facility_type = 'Restaurant'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of plain table names. Do calculate percentage using `COUNT(CASE WHEN T3.fine = 250 THEN T1.license_no END)` instead of simple `COUNT(*)` with a `WHERE` filter. Do join `establishment AS T1`, `inspection AS T2`, and `violation AS T3` with proper join conditions instead of querying only the `restaurants` table. Do add join conditions `T1.license_no = T2.license_no` and `T2.inspection_id = T3.inspection_id` instead of missing table relationships. Do add filter `T1.facility_type = 'Restaurant'` instead of assuming a separate `restaurants` table. Do use explicit `CAST` to `REAL` for percentage calculation instead of implicit casting. Do count on `T1.license_no` in both numerator and denominator instead of counting all rows. The amended query now correctly calculates the percentage of restaurant establishments with $250 fines by properly joining related tables and filtering by facility type."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM establishments)) AS percentage\nFROM restaurants\nWHERE fine_amount = 250;",
            "SELECT \n    (CAST(COUNT(CASE WHEN T3.fine = 250 THEN T1.license_no END) AS REAL) / \n     CAST(COUNT(T1.license_no) AS REAL)) * 100.0 AS percentage\nFROM \n    establishment AS T1\nJOIN \n    inspection AS T2 ON T1.license_no = T2.license_no\nJOIN \n    violation AS T3 ON T2.inspection_id = T3.inspection_id\nWHERE \n    T1.facility_type = 'Restaurant';"
        ],
        "rule_sql": []
    },
    "3820": {
        "db_id": "public_review_platform",
        "question": "Which city has the least number of businesses whose amount of funny votes is low?",
        "ground_truth": "SELECT T1.city FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T2.review_votes_funny LIKE 'low' GROUP BY T1.city",
        "amends": [
            "Do specify `T1.city` in the SELECT list instead of just `city` and remove the `business_count` alias and aggregation. Do join `Business AS T1` with `Reviews AS T2` on `T1.business_id = T2.business_id` instead of querying only the `businesses` table. Do filter on `T2.review_votes_funny LIKE 'low'` instead of `funny_votes = 'low'` to properly reference the joined table's column and use pattern matching. Do remove the `ORDER BY business_count DESC LIMIT 1` clause instead of keeping it since the right query returns all matching cities rather than just the top one. The amended query now correctly joins business and review data to find cities with low funny votes and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as business_count \nFROM businesses \nWHERE funny_votes = 'low' \nGROUP BY city \nORDER BY business_count DESC \nLIMIT 1;",
            "SELECT T1.city FROM Business AS T1 JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T2.review_votes_funny LIKE 'low'"
        ],
        "rule_sql": []
    },
    "1847": {
        "db_id": "soccer_2016",
        "question": "What is the total number of won matches of the team named \"Pune Warriors\"?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Team_Name = 'Pune Warriors' THEN 1 ELSE 0 END) FROM Match AS T1 INNER JOIN Team AS T2 ON T2.Team_Id = T1.Match_Winner",
        "amends": [
            "Do use `SUM(CASE WHEN T2.Team_Name = 'Pune Warriors' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific team wins. Do add `INNER JOIN Team AS T2 ON T2.Team_Id = T1.Match_Winner` instead of querying the matches table alone, enabling proper team name lookup. Do reference `T2.Team_Name` instead of `winner` column for accurate team identification. Do use `T1.Match_Winner` instead of direct string comparison to join on the correct foreign key relationship. The amended query now correctly counts wins for Pune Warriors by properly joining the teams table and using conditional aggregation instead of an incorrect filter approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE winner = 'Pune Warriors';",
            "SELECT SUM(CASE WHEN T2.Team_Name = 'Pune Warriors' THEN 1 ELSE 0 END) AS total_wins\nFROM Match AS T1\nINNER JOIN Team AS T2 ON T2.Team_Id = T1.Match_Winner\nWHERE T2.Team_Name = 'Pune Warriors';"
        ],
        "rule_sql": []
    },
    "256": {
        "db_id": "retail_complains",
        "question": "What is the average number of complaints on credit cards filed by clients from New York in the 3 consecutive years starting from 2015?",
        "ground_truth": "SELECT CAST(COUNT(T2.`Complaint ID`) AS REAL) / 3 AS average FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE strftime('%Y', T2.`Date received`) BETWEEN '2015' AND '2017' AND T1.city = 'New York City' AND T2.Product = 'Credit card'",
        "amends": [
            "Do use `CAST(COUNT(T2.\"Complaint ID\") AS REAL) / 3` instead of `AVG(complaints)` to calculate the average over three years. Do join `client AS T1` and `events AS T2` with `INNER JOIN` on `T1.client_id = T2.Client_ID` instead of querying a single `credit_cards` table. Do filter with `strftime('%Y', T2.\"Date received\") BETWEEN '2015' AND '2017'` instead of `year BETWEEN 2015 AND 2017` to extract years from date strings. Do use `T1.city = 'New York City'` instead of `client_state = 'New York'` for location filtering. Do add `T2.Product = 'Credit card'` to filter for credit card products instead of omitting this condition. The amended query now correctly calculates the average number of credit card complaints per year for New York City clients between 2015-2017."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(complaints) FROM credit_cards WHERE client_state = 'New York' AND year BETWEEN 2015 AND 2017",
            "SELECT CAST(COUNT(T2.\"Complaint ID\") AS REAL) / 3 AS average_complaints\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.city = 'New York City'\nAND T2.Product = 'Credit card'\nAND strftime('%Y', T2.\"Date received\") BETWEEN '2015' AND '2017'"
        ],
        "rule_sql": []
    },
    "9332": {
        "db_id": "movie_3",
        "question": "Which actor acted in ANONYMOUS HUMAN?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T3.film_id = T2.film_id WHERE T3.title = 'ANONYMOUS HUMAN'",
        "amends": [
            "Do select `T1.first_name` and `T1.last_name` instead of `actor_name`. Do join `actor AS T1` with `film_actor AS T2` on `T1.actor_id = T2.actor_id` instead of querying only the `actors` table. Do add a second join to `film AS T3` on `T3.film_id = T2.film_id` instead of omitting the film table relationship. Do filter on `T3.title = 'ANONYMOUS HUMAN'` instead of `movie_title = 'ANONYMOUS HUMAN'` to properly reference the film table. The amended query now correctly retrieves actor names by joining through the film_actor relationship table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE movie_title = 'ANONYMOUS HUMAN';",
            "SELECT T1.first_name, T1.last_name\nFROM actor AS T1\nJOIN film_actor AS T2 ON T1.actor_id = T2.actor_id\nJOIN film AS T3 ON T3.film_id = T2.film_id\nWHERE T3.title = 'ANONYMOUS HUMAN'"
        ],
        "rule_sql": []
    },
    "2734": {
        "db_id": "regional_sales",
        "question": "Identify the store location and sales team who processed the sales order 'SO - 0001004'.",
        "ground_truth": "SELECT T3.`Sales Team`, T1.`City Name` FROM `Store Locations` AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._StoreID = T1.StoreID INNER JOIN `Sales Team` AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE T2.OrderNumber = 'SO - 0001004'",
        "amends": [
            "Do select `T3.Sales Team` and `T1.City Name` instead of `store_location` and `sales_team`. Do use `Store Locations` AS T1 and `Sales Orders` AS T2 instead of just `sales_orders`. Do add `INNER JOIN` on `T2._StoreID = T1.StoreID` instead of omitting the store location join. Do add `INNER JOIN` on `T3.SalesTeamID = T2._SalesTeamID` instead of omitting the sales team join. Do filter on `T2.OrderNumber = 'SO - 0001004'` instead of `order_id = 'SO - 0001004'`. The amended query now correctly joins the necessary tables to retrieve the sales team and city name data for the specified order number.",
            "Do reorder the SELECT list to `Sales Team`, `City Name` instead of `City Name`, `Sales Team`. Do use backticks for table and column identifiers instead of double quotes. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_location, sales_team FROM sales_orders WHERE order_id = 'SO - 0001004';",
            "SELECT T1.\"City Name\", T3.\"Sales Team\"\nFROM \"Store Locations\" AS T1\nINNER JOIN \"Sales Orders\" AS T2 ON T2._StoreID = T1.StoreID\nINNER JOIN \"Sales Team\" AS T3 ON T3.SalesTeamID = T2._SalesTeamID\nWHERE T2.OrderNumber = 'SO - 0001004'",
            "SELECT T3.`Sales Team`, T1.`City Name`\nFROM `Sales Orders` AS T2\nINNER JOIN `Store Locations` AS T1 ON T2.`_StoreID` = T1.`StoreID`\nINNER JOIN `Sales Team` AS T3 ON T3.`SalesTeamID` = T2.`_SalesTeamID`\nWHERE T2.`OrderNumber` = 'SO - 0001004'"
        ],
        "rule_sql": []
    },
    "850": {
        "db_id": "social_media",
        "question": "Please list all the cities from where tweets with neutral sentiments were posted.",
        "ground_truth": "SELECT DISTINCT T2.City FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE Sentiment = 0",
        "amends": [
            "Do use `DISTINCT T2.City` instead of `city` to return unique city names. Do join `twitter AS T1` with `location AS T2` on `T1.LocationID = T2.LocationID` instead of querying only the `tweets` table. Do filter by `Sentiment = 0` instead of `sentiment = 'positive'` to use numeric comparison rather than string matching. The amended query now correctly joins tables to retrieve city data from the location table and uses proper numeric sentiment filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM tweets WHERE sentiment = 'positive';",
            "SELECT DISTINCT T2.City FROM twitter AS T1 JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T1.Sentiment = 0"
        ],
        "rule_sql": []
    },
    "5660": {
        "db_id": "shipping",
        "question": "List all the cities where Zachery Hicks transported goods.",
        "ground_truth": "SELECT DISTINCT T3.city_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id INNER JOIN city AS T3 ON T1.city_id = T3.city_id WHERE T2.first_name = 'Zachery' AND T2.last_name = 'Hicks'",
        "amends": [
            "Do select `T3.city_name` instead of `city` and add `DISTINCT` instead of omitting it. Do use `shipment AS T1` joined with `driver AS T2` on `T1.driver_id = T2.driver_id` and `city AS T3` on `T1.city_id = T3.city_id` instead of querying only `cities`. Do filter on `T2.first_name = 'Zachery' AND T2.last_name = 'Hicks'` instead of `transporter_name = 'Zachery Hicks'`. The amended query now correctly retrieves distinct city names by joining related tables and properly filtering on driver names, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities WHERE transporter_name = 'Zachery Hicks';",
            "SELECT DISTINCT T3.city_name FROM shipment AS T1 JOIN driver AS T2 ON T1.driver_id = T2.driver_id JOIN city AS T3 ON T1.city_id = T3.city_id WHERE T2.first_name = 'Zachery' AND T2.last_name = 'Hicks'"
        ],
        "rule_sql": []
    },
    "3037": {
        "db_id": "shakespeare",
        "question": "Please list all of the character descriptions in paragraph 20.",
        "ground_truth": "SELECT T1.Description FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T2.ParagraphNum = 20",
        "amends": [
            "Do select `T1.Description` from the `characters` table instead of selecting all columns from `paragraphs`. Do join `characters AS T1` with `paragraphs AS T2` using `INNER JOIN` instead of querying only the `paragraphs` table. Do use the join condition `T1.id = T2.character_id` instead of filtering by `paragraph_id`. Do filter by `T2.ParagraphNum = 20` instead of filtering by `paragraph_id = 20`. The amended query now correctly retrieves character descriptions for paragraphs with paragraph number 20 instead of incorrectly filtering by paragraph ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM paragraphs WHERE paragraph_id = 20;",
            "SELECT T1.Description \nFROM characters AS T1\nINNER JOIN paragraphs AS T2 ON T1.id = T2.character_id\nWHERE T2.ParagraphNum = 20"
        ],
        "rule_sql": []
    },
    "311": {
        "db_id": "retail_complains",
        "question": "List all the complaints narratives made by the customer named Brenda and last name Mayer.",
        "ground_truth": "SELECT T2.`Consumer complaint narrative` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Brenda' AND T1.last = 'Mayer'",
        "amends": [
            "Do select `T2.Consumer complaint narrative` instead of `narrative` from the wrong table. Do use `client AS T1` and `events AS T2` as source tables instead of just `complaints`. Do add `INNER JOIN` on `T1.client_id = T2.Client_ID` instead of querying a single table. Do filter on `T1.first = 'Brenda'` and `T1.last = 'Mayer'` instead of filtering directly on the events table columns. The amended query now correctly joins client and events tables to find the complaint narrative for the specified client, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT narrative FROM complaints WHERE first_name = 'Brenda' AND last_name = 'Mayer'",
            "SELECT T2.\"Consumer complaint narrative\"\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.first = 'Brenda' AND T1.last = 'Mayer'"
        ],
        "rule_sql": []
    },
    "4812": {
        "db_id": "legislator",
        "question": "What is the gender of the legislator whose address at 317 Russell Senate Office Building Washington DC 20510?",
        "ground_truth": "SELECT T1.gender_bio FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.address = '317 Russell Senate Office Building Washington DC 20510'",
        "amends": [
            "Do select `gender_bio` from the `current` table instead of `gender` from `legislators`. Do join `current-terms` with an `INNER JOIN` on `bioguide_id = bioguide` instead of querying a single table. Do filter on the address condition in the joined `current-terms` table instead of applying it directly to the main table. Do reference the joined table alias `T2` in the WHERE clause instead of applying the filter to the base table. The amended query now correctly retrieves gender information by joining the appropriate tables and filtering on the address field in the terms table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM legislators WHERE address = '317 Russell Senate Office Building Washington DC 20510';",
            "SELECT c.gender_bio \nFROM current c\nINNER JOIN \"current-terms\" ct ON c.bioguide_id = ct.bioguide\nWHERE ct.address = '317 Russell Senate Office Building Washington DC 20510'"
        ],
        "rule_sql": []
    },
    "6752": {
        "db_id": "retails",
        "question": "What is the total number of suppliers from Germany?",
        "ground_truth": "SELECT COUNT(T1.s_suppkey) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T2.n_name = 'GERMANY'",
        "amends": [
            "Do specify `COUNT(T1.s_suppkey)` instead of `COUNT(*)` to count specific non-null values. Do join `supplier AS T1` with `nation AS T2` on `T1.s_nationkey = T2.n_nationkey` instead of querying only the `suppliers` table. Do filter on `T2.n_name = 'GERMANY'` instead of `country = 'France'` to target German suppliers rather than French ones. The amended query now correctly counts suppliers from Germany by joining with the nation table to validate nationality, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE country = 'France';",
            "SELECT COUNT(T1.s_suppkey) \nFROM supplier AS T1 \nJOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey \nWHERE T2.n_name = 'GERMANY'"
        ],
        "rule_sql": []
    },
    "7685": {
        "db_id": "hockey",
        "question": "Show me how many minutes player Id \"valiqst01\" played in the game in 2007 season.",
        "ground_truth": "SELECT Min FROM Goalies WHERE playerID = 'valiqst01' AND year = 2007",
        "amends": [
            "Do select `Min` from the `Goalies` table instead of `SUM(minutes)` from the `player_stats` table. Do use `playerID` as the column name instead of `player_id` for the player identifier filter. Do keep the same `year = 2007` filter condition but apply it to the correct table structure. The amended query now correctly retrieves the minutes played directly from the Goalies table instead of attempting to sum minutes from a player_stats table that doesn't contain the required data structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(minutes) FROM player_stats WHERE player_id = 'valiqst01' AND year = 2007",
            "SELECT Min FROM Goalies WHERE playerID = 'valiqst01' AND year = 2007;"
        ],
        "rule_sql": []
    },
    "5683": {
        "db_id": "shipping",
        "question": "List the driver's name of the shipment with a weight greater than 95% of the average weight of all shipments.",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.weight * 100 > ( SELECT 95 * AVG(weight) FROM shipment )",
        "amends": [
            "Do select `T2.first_name` and `T2.last_name` from the `driver` table instead of just `driver_name` from `shipments`. Do join `shipment AS T1` with `driver AS T2` using `INNER JOIN` on `T1.driver_id = T2.driver_id` instead of querying only the `shipments` table without any join. Do use the filter `T1.weight * 100 >` instead of `weight >` and calculate the threshold as `95 * AVG(weight)` instead of `AVG(weight) * 0.95`. The amended query now correctly retrieves driver names from the driver table while properly filtering shipments based on weight thresholds, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM shipments WHERE weight > (SELECT AVG(weight) * 0.95 FROM shipments);",
            "SELECT T2.first_name, T2.last_name \nFROM shipment AS T1 \nINNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id \nWHERE T1.weight * 100 > 95 * (SELECT AVG(weight) FROM shipment)"
        ],
        "rule_sql": []
    },
    "8901": {
        "db_id": "cookbook",
        "question": "Among the recipes whose source is the National Potato Board, which recipe has the highest calories?",
        "ground_truth": "SELECT T1.title FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.source = 'National Potato Board' ORDER BY T2.calories DESC LIMIT 1",
        "amends": [
            "Do select `T1.title` instead of `recipe_name` and join `Recipe AS T1` with `Nutrition AS T2` on `T1.recipe_id = T2.recipe_id` instead of querying only the `recipes` table. Do change the ORDER BY to `T2.calories DESC` instead of `calories ASC` to sort by descending calories from the Nutrition table rather than ascending from the recipes table. Do keep the WHERE filter on `T1.source = 'National Potato Board'` and LIMIT 1, but now the query correctly joins to access nutrition data and sorts by calories in the proper direction to find the highest-calorie recipe from that source. The amended query now matches the intended behavior of selecting recipe titles with their associated nutrition information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT recipe_name FROM recipes WHERE source = 'National Potato Board' ORDER BY calories ASC LIMIT 1;",
            "SELECT T1.title \nFROM Recipe AS T1 \nJOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id \nWHERE T1.source = 'National Potato Board' \nORDER BY T2.calories DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7823": {
        "db_id": "world",
        "question": "How many countries use Portuguese?",
        "ground_truth": "SELECT SUM(CASE WHEN Language = 'Portuguese' THEN 1 ELSE 0 END) FROM CountryLanguage",
        "amends": [
            "Do use `SUM(CASE WHEN Language = 'Portuguese' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only Portuguese language records. Do reference table `CountryLanguage` instead of `countries` as the correct data source. Do use column `Language` instead of `language` with proper case sensitivity. Do remove the `WHERE` clause filter and instead incorporate the conditional logic within the `CASE` expression to handle the counting semantics correctly. The amended query now matches RIGHT_SQL's behavior by properly counting Portuguese language entries from the correct table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE language = 'Portuguese';",
            "SELECT SUM(CASE WHEN Language = 'Portuguese' THEN 1 ELSE 0 END) AS PortugueseSpeakingCountries FROM CountryLanguage;"
        ],
        "rule_sql": []
    },
    "7269": {
        "db_id": "works_cycles",
        "question": "What product has the fewest online orders from one customer? List the product's class, line of business, and list price.",
        "ground_truth": "SELECT T2.Class, T2.ProductLine, T2.ListPrice FROM ShoppingCartItem AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY T1.ProductID ORDER BY SUM(Quantity) LIMIT 1",
        "amends": [
            "Do select `Class`, `ProductLine`, and `ListPrice` instead of `class`, `line_of_business`, and `list_price`. Do use `INNER JOIN` with `Product` table instead of `JOIN` with `products` table. Do join on `T1.ProductID = T2.ProductID` instead of `p.product_id = o.product_id`. Do remove the `WHERE` filter for `channel = 'online'` instead of keeping it. Do group by `T1.ProductID` instead of `p.product_id`. Do order by `SUM(Quantity)` instead of `COUNT(o.order_id)`. Do use table aliases `T1` for `ShoppingCartItem` and `T2` for `Product` instead of `p` for `products` and `o` for `orders`. The amended query now correctly calculates the product with the lowest total quantity in shopping carts rather than counting online orders."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.class, p.line_of_business, p.list_price\nFROM products p\nJOIN orders o ON p.product_id = o.product_id\nWHERE o.channel = 'online'\nGROUP BY p.product_id\nORDER BY COUNT(o.order_id) ASC\nLIMIT 1;",
            "SELECT T2.Class, T2.ProductLine, T2.ListPrice\nFROM ShoppingCartItem T1\nINNER JOIN Product T2 ON T1.ProductID = T2.ProductID\nGROUP BY T1.ProductID\nORDER BY SUM(T1.Quantity) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "997": {
        "db_id": "computer_student",
        "question": "Please list the IDs of the professors that teaches more than 3 courses.",
        "ground_truth": "SELECT T1.p_id FROM taughtBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.professor = 1 GROUP BY T1.p_id HAVING COUNT(DISTINCT T1.course_id) > 3",
        "amends": [
            "Do use `T1.p_id` instead of `professor_id` and move from `professors` table to `taughtBy AS T1` joined with `person AS T2` instead of querying a single table. Do add `INNER JOIN person AS T2 ON T1.p_id = T2.p_id` instead of omitting the join, and include `WHERE T2.professor = 1` instead of missing this professor filter condition. Do add `GROUP BY T1.p_id` instead of omitting grouping, and move the count condition to `HAVING COUNT(DISTINCT T1.course_id) > 3` instead of using `WHERE COUNT(course_id) > 3` which is invalid syntax. Do use `COUNT(DISTINCT T1.course_id)` instead of `COUNT(course_id)` to count unique courses. The amended query now correctly identifies professors who teach more than 3 distinct courses by properly joining tables, filtering for actual professors, and using valid HAVING clause syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professor_id FROM professors WHERE COUNT(course_id) > 3",
            "SELECT T1.p_id\nFROM taughtBy AS T1\nINNER JOIN person AS T2 ON T1.p_id = T2.p_id\nWHERE T2.professor = 1\nGROUP BY T1.p_id\nHAVING COUNT(DISTINCT T1.course_id) > 3"
        ],
        "rule_sql": []
    },
    "8682": {
        "db_id": "chicago_crime",
        "question": "Which community area has the highest number of crimes reported on the street?",
        "ground_truth": "SELECT T1.community_area_no FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE T2.location_description = 'STREET' GROUP BY T1.community_area_no ORDER BY COUNT(T2.location_description) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of omitting them. Do join `Community_Area` table with `INNER JOIN` on `T2.community_area_no = T1.community_area_no` instead of querying only the `crimes` table. Do reference `T2.location_description` in the WHERE filter instead of just `location_description`. Do group by `T1.community_area_no` instead of `community_area`. Do order by `COUNT(T2.location_description) DESC` instead of `crime_count ASC`. Do remove the column alias `crime_count` instead of keeping it. The amended query now correctly identifies the community area with the highest street crime count by joining the necessary tables and using descending order.",
            "Do select `T1.community_area_no` instead of `T1.community_area_name` in the SELECT list. Do add explicit table aliases with `AS` syntax instead of omitting them. The amended query now correctly returns the community area number instead of the name while maintaining the same join logic, filtering, grouping, and ordering behavior to identify the community area with the most street crimes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_area, COUNT(*) as crime_count FROM crimes WHERE location_description = 'STREET' GROUP BY community_area ORDER BY crime_count ASC LIMIT 1;",
            "SELECT T1.community_area_name\nFROM Community_Area T1\nINNER JOIN Crime T2 ON T2.community_area_no = T1.community_area_no\nWHERE T2.location_description = 'STREET'\nGROUP BY T1.community_area_no\nORDER BY COUNT(T2.location_description) DESC\nLIMIT 1;",
            "SELECT T1.community_area_no\nFROM Community_Area AS T1\nINNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no\nWHERE T2.location_description = 'STREET'\nGROUP BY T1.community_area_no\nORDER BY COUNT(T2.location_description) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4786": {
        "db_id": "legislator",
        "question": "List the full names of Republican legislators who have a nickname.",
        "ground_truth": "SELECT T1.official_full_name FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.party = 'Republican' AND T1.nickname_name IS NOT NULL GROUP BY T1.official_full_name",
        "amends": [
            "Do select `official_full_name` instead of `first_name, last_name`. Do use `current` table as T1 instead of `legislators`. Do add `INNER JOIN` with `current-terms` as T2 on `T1.bioguide_id = T2.bioguide` instead of no join. Do filter on `T2.party = 'Republican'` instead of `party = 'Democrat'`. Do check `T1.nickname_name IS NOT NULL` instead of `nickname IS NOT NULL`. Do add `GROUP BY T1.official_full_name` instead of no grouping. The amended query now correctly retrieves Republican legislators with nicknames from the joined current and current-terms tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM legislators WHERE party = 'Democrat' AND nickname IS NOT NULL;",
            "SELECT T1.official_full_name\nFROM current AS T1\nINNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nWHERE T2.party = 'Republican'\nAND T1.nickname_name IS NOT NULL\nGROUP BY T1.official_full_name"
        ],
        "rule_sql": []
    },
    "8762": {
        "db_id": "chicago_crime",
        "question": "Please list the location coordinates of all the incidents that had happened in the ward represented by alderman Pat Dowell.",
        "ground_truth": "SELECT T2.latitude, T2.longitude FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T1.alderman_first_name = 'Pat' AND T1.alderman_last_name = 'Dowell' AND T2.latitude IS NOT NULL AND T2.longitude IS NOT NULL",
        "amends": [
            "Do select `T2.latitude` and `T2.longitude` from specific tables instead of just `latitude` and `longitude` without table qualification. Do join `Ward AS T1` with `Crime AS T2` on `T1.ward_no = T2.ward_no` instead of querying a single `incidents` table. Do filter on `T1.alderman_first_name = 'Pat'` and `T1.alderman_last_name = 'Dowell'` instead of a single `alderman` column. Do add `T2.latitude IS NOT NULL` and `T2.longitude IS NOT NULL` filters instead of omitting null checks. The amended query now correctly joins ward and crime data while ensuring valid coordinate values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude, longitude FROM incidents WHERE alderman = 'Pat Dowell';",
            "SELECT T2.latitude, T2.longitude\nFROM Ward AS T1\nJOIN Crime AS T2 ON T1.ward_no = T2.ward_no\nWHERE T1.alderman_first_name = 'Pat' \nAND T1.alderman_last_name = 'Dowell'\nAND T2.latitude IS NOT NULL \nAND T2.longitude IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1329": {
        "db_id": "law_episode",
        "question": "List down the titles of the top 3 episodes, from highest to lowest, in terms of their weighted stars.",
        "ground_truth": "SELECT T2.title FROM Vote AS T1 INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE T1.stars BETWEEN 1 AND 10 GROUP BY T2.title ORDER BY CAST(SUM(T1.stars * T1.percent) AS REAL) / 100 DESC LIMIT 3",
        "amends": [
            "Do select `T2.title` from the `Vote` and `Episode` tables instead of selecting `title` from only the `episodes` table. Do add an `INNER JOIN` between `Vote AS T1` and `Episode AS T2` on `T2.episode_id = T1.episode_id` instead of having no join. Do add a `WHERE` filter with `T1.stars BETWEEN 1 AND 10` instead of omitting any filter. Do add a `GROUP BY T2.title` clause instead of having no grouping. Do change the `ORDER BY` to use `CAST(SUM(T1.stars * T1.percent) AS REAL) / 100 DESC` instead of simply `stars DESC`. The amended query now correctly calculates weighted average ratings and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY stars DESC LIMIT 3;",
            "SELECT T2.title \nFROM Vote AS T1\nINNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.stars BETWEEN 1 AND 10\nGROUP BY T2.title\nORDER BY CAST(SUM(T1.stars * T1.percent) AS REAL) / 100 DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "3882": {
        "db_id": "public_review_platform",
        "question": "In users yelping since 2011 to 2013, how many of them have high count of fans?",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year BETWEEN 2011 AND 2013 AND user_fans LIKE 'High'",
        "amends": [
            "Do count `user_id` instead of `*` to avoid counting null values. Do reference table `Users` instead of `users` to match the correct schema. Do filter on `user_yelping_since_year BETWEEN 2011 AND 2013` instead of `yelping_since BETWEEN '2011-01-01' AND '2013-12-31'` to use the correct year-based integer column. Do filter with `user_fans LIKE 'High'` instead of `fans > 1000` to use the categorical fan classification rather than a numeric threshold. The amended query now correctly counts users based on their yelping year range and fan category classification."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE yelping_since BETWEEN '2011-01-01' AND '2013-12-31' AND fans > 1000;",
            "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year BETWEEN 2011 AND 2013 AND user_fans LIKE 'High'"
        ],
        "rule_sql": []
    },
    "873": {
        "db_id": "cs_semester",
        "question": "Which student has the highest gpa? Give the full name.",
        "ground_truth": "SELECT f_name, l_name FROM student WHERE gpa = ( SELECT MAX(gpa) FROM student )",
        "amends": [
            "Do select `f_name, l_name` instead of just `first_name`. Do change the source table to `student` instead of `students`. Do add a `WHERE` filter comparing `gpa` to a subquery `(SELECT MAX(gpa) FROM student)` instead of using `ORDER BY gpa DESC LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies all students with the maximum GPA rather than just returning one arbitrary top student, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM students ORDER BY gpa DESC LIMIT 1;",
            "SELECT f_name, l_name FROM student WHERE gpa = (SELECT MAX(gpa) FROM student)"
        ],
        "rule_sql": []
    },
    "3187": {
        "db_id": "donor",
        "question": "Which projects created by teachers with Doctor Degree where the project have more than 300 students involved. List down the title of the project.",
        "ground_truth": "SELECT T1.title FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.teacher_prefix LIKE 'Dr.' AND T2.students_reached > 300",
        "amends": [
            "Do select `T1.title` from `essays AS T1` instead of `p.title` from `projects p`. Do use `INNER JOIN projects AS T2` instead of joining `teachers t` and `project_students ps`. Do filter with `T2.teacher_prefix LIKE 'Dr.'` instead of `t.degree = 'Doctor Degree'`. Do filter with `T2.students_reached > 300` in the WHERE clause instead of using GROUP BY and HAVING COUNT(ps.student_id) > 300. Do remove the GROUP BY clause instead of keeping it. The amended query now correctly filters by teacher prefix and student reach count directly without aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.title \nFROM projects p\nJOIN teachers t ON p.teacher_id = t.id\nJOIN project_students ps ON p.id = ps.project_id\nWHERE t.degree = 'Doctor Degree'\nGROUP BY p.id\nHAVING COUNT(ps.student_id) > 300;",
            "SELECT T1.title \nFROM essays AS T1\nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid\nWHERE T2.teacher_prefix LIKE 'Dr.' \nAND T2.students_reached > 300"
        ],
        "rule_sql": []
    },
    "3301": {
        "db_id": "donor",
        "question": "List the primary subject of all the donations with a corporate sponsored giftcard.",
        "ground_truth": "SELECT DISTINCT T2.primary_focus_subject FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.payment_included_campaign_gift_card = 't'",
        "amends": [
            "Do select `DISTINCT T2.primary_focus_subject` instead of `donor_name`. Do join `projects AS T2` with `INNER JOIN` on `T1.projectid = T2.projectid` instead of querying only the `donations` table. Do filter on `T1.payment_included_campaign_gift_card = 't'` instead of `giftcard_type = 'corporate sponsored'`. The amended query now correctly retrieves distinct project focus subjects from joined donation and project data based on campaign gift card payments."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT donor_name FROM donations WHERE giftcard_type = 'corporate sponsored'",
            "SELECT DISTINCT T2.primary_focus_subject\nFROM donations AS T1\nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid\nWHERE T1.payment_included_campaign_gift_card = 't'"
        ],
        "rule_sql": []
    },
    "7437": {
        "db_id": "works_cycles",
        "question": "What is the bussiness id for Mr. Hung-Fu Ting?",
        "ground_truth": "SELECT BusinessEntityID FROM Person WHERE Title = 'Mr.' AND FirstName = 'Hung-Fu' AND LastName = 'Ting'",
        "amends": [
            "Do select `BusinessEntityID` from the `Person` table instead of `business_id` from `businesses`. Do filter on `Title = 'Mr.'` and `FirstName = 'Hung-Fu'` and `LastName = 'Ting'` instead of only `first_name = 'Mr. Hung-Fu Ting'`. The amended query now correctly targets the Person table with proper name component separation and title filtering to match the intended result set."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE first_name = 'Mr. Hung-Fu Ting'",
            "SELECT BusinessEntityID FROM Person WHERE Title = 'Mr.' AND FirstName = 'Hung-Fu' AND LastName = 'Ting';"
        ],
        "rule_sql": []
    },
    "3053": {
        "db_id": "shakespeare",
        "question": "Who is the character that said \"This is Illyria, lady.\"?",
        "ground_truth": "SELECT T1.CharName FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T2.PlainText = 'This is Illyria, lady.'",
        "amends": [
            "Do select `T1.CharName` from the `characters` table instead of `character_name` from the `quotes` table. Do join `paragraphs AS T2` with `INNER JOIN` on `T1.id = T2.character_id` instead of querying only the `quotes` table. Do filter on `T2.PlainText = 'This is Illyria, lady.'` instead of `quote_text = 'This is Illyria, lady.'` to reference the correct column from the joined table. The amended query now correctly retrieves character names by joining the appropriate tables and matching the search text in the proper column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM quotes WHERE quote_text = 'This is Illyria, lady.'",
            "SELECT T1.CharName FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T2.PlainText = 'This is Illyria, lady.'"
        ],
        "rule_sql": []
    },
    "8098": {
        "db_id": "university",
        "question": "What is the percentage of the international students in University of Oslo in 2015?",
        "ground_truth": "SELECT T2.pct_international_students FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id WHERE T1.university_name = 'University of Oslo' AND T2.year = 2015",
        "amends": [
            "Do select `T2.pct_international_students` instead of calculating `(international_students / total_students) * 100` with a different formula. Do use `FROM university AS T1 INNER JOIN university_year AS T2` instead of `FROM universities` with a single table. Do add join condition `ON T1.id = T2.university_id` instead of omitting any join. Do change filter to `T1.university_name = 'University of Oslo'` instead of `university_name = 'University of Oslo'` with proper table qualification. Do change year filter to `T2.year = 2015` instead of `year = 2015` with proper table qualification. The amended query now correctly retrieves the pre-calculated percentage from the joined tables instead of attempting to calculate it from raw student counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (international_students / total_students) * 100 AS percentage \nFROM universities \nWHERE university_name = 'University of Oslo' AND year = 2015;",
            "SELECT T2.pct_international_students\nFROM university AS T1\nINNER JOIN university_year AS T2 ON T1.id = T2.university_id\nWHERE T1.university_name = 'University of Oslo'\nAND T2.year = 2015"
        ],
        "rule_sql": []
    },
    "5451": {
        "db_id": "sales",
        "question": "How much is the total amount of sales handled by Heather McBadden?",
        "ground_truth": "SELECT SUM(T2.Quantity * T3.Price) FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T1.FirstName = 'Heather' AND T1.LastName = 'McBadden'",
        "amends": [
            "Do use `SUM(T2.Quantity * T3.Price)` instead of `SUM(amount)` to calculate total sales value. Do join `Employees AS T1` and `Sales AS T2` with `INNER JOIN` on `T1.EmployeeID = T2.SalesPersonID` instead of missing these tables entirely. Do add `INNER JOIN` for `Products AS T3` on `T2.ProductID = T3.ProductID` instead of omitting product information. Do filter with `T1.FirstName = 'Heather' AND T1.LastName = 'McBadden'` instead of `employee_name = 'Heather McBadden'` to properly match the employee by separate name fields. The amended query now correctly calculates total sales value by joining employee, sales, and product tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM sales WHERE employee_name = 'Heather McBadden';",
            "SELECT SUM(T2.Quantity * T3.Price) AS TotalSalesAmount\nFROM Employees AS T1\nINNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID\nINNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID\nWHERE T1.FirstName = 'Heather' AND T1.LastName = 'McBadden'"
        ],
        "rule_sql": []
    },
    "2306": {
        "db_id": "movielens",
        "question": "Which actor has acted in at least 2 French films? Please list their IDs.",
        "ground_truth": "SELECT T2.actorid FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'France' GROUP BY T2.actorid HAVING COUNT(T1.movieid) > 2",
        "amends": [
            "Do join `movies` and `movies2actors` on `movieid` instead of querying `actors` directly. Do filter on `country = 'France'` from the joined `movies` table instead of from a non-existent `actors.country` column. Do aggregate by `actorid` and use `HAVING COUNT(movieid) > 2` instead of filtering `film_count >= 2` directly in `WHERE`. Do select `actorid` from the joined table instead of `actor_id` from a standalone table. The amended query now correctly identifies actors who appeared in more than 2 French movies by joining the relevant tables and using proper aggregation.",
            "Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `JOIN` without aliases. Do reference `T2.actorid` in SELECT instead of just `actorid`. Do use `T1.movieid = T2.movieid` as the join condition instead of `movies2actors.movieid = movies.movieid`. Do keep the `WHERE T1.country = 'France'` filter unchanged. Do change the HAVING condition to `COUNT(T1.movieid) > 2` instead of `COUNT(movies2actors.movieid) >= 2` to use a strict greater than comparison with the aliased table reference. The amended query now correctly filters for actors appearing in more than 2 French movies rather than 2 or more movies."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id FROM actors WHERE country = 'France' AND film_count >= 2;",
            "SELECT actorid \nFROM movies2actors \nJOIN movies ON movies2actors.movieid = movies.movieid \nWHERE movies.country = 'France' \nGROUP BY actorid \nHAVING COUNT(movies2actors.movieid) >= 2",
            "SELECT T2.actorid\nFROM movies AS T1\nINNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid\nWHERE T1.country = 'France'\nGROUP BY T2.actorid\nHAVING COUNT(T1.movieid) > 2"
        ],
        "rule_sql": []
    },
    "1203": {
        "db_id": "talkingdata",
        "question": "Identify all installed and activated apps by their id.",
        "ground_truth": "SELECT app_id FROM app_events WHERE is_active = 1 AND is_installed = 1",
        "amends": [
            "Do select `app_id` from the `app_events` table instead of `app_name` from the `apps` table. Do add filters for `is_active = 1` and `is_installed = 1` instead of filtering for `status = 'installed'`. The amended query now correctly retrieves active installed app identifiers from the event tracking table rather than app names from a general apps table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name FROM apps WHERE status = 'installed';",
            "SELECT app_id FROM app_events WHERE is_installed = 1 AND is_active = 1;"
        ],
        "rule_sql": []
    },
    "4974": {
        "db_id": "olympics",
        "question": "How many athletes from region 151 have won a medal?",
        "ground_truth": "SELECT COUNT(T3.person_id) FROM competitor_event AS T1 INNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id INNER JOIN person_region AS T3 ON T2.person_id = T3.person_id WHERE T3.region_id = 151 AND T1.medal_id != 4",
        "amends": [
            "Do use `COUNT(T3.person_id)` instead of `COUNT(*)` to count specific person identifiers. Do join `competitor_event AS T1` instead of querying `athletes` directly. Do add `INNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id` to connect events to competitors. Do add `INNER JOIN person_region AS T3 ON T2.person_id = T3.person_id` to link competitors to regions. Do filter on `T3.region_id = 151` instead of `region_id = 151` with proper table qualification. Do use `T1.medal_id != 4` instead of `medal IS NOT NULL` to correctly identify non-null medals through the medal_id reference. The amended query now correctly counts athletes with medals from region 151 by properly traversing the relationship chain through the normalized schema.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the query already filters for a specific region and medal condition, making distinct counting unnecessary. The amended query now matches RIGHT_SQL's behavior by counting all person_id values that meet the specified conditions without deduplication."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE region_id = 151 AND medal IS NOT NULL;",
            "SELECT COUNT(DISTINCT T3.person_id) \nFROM competitor_event AS T1\nINNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id\nINNER JOIN person_region AS T3 ON T2.person_id = T3.person_id\nWHERE T3.region_id = 151 AND T1.medal_id != 4",
            "SELECT COUNT(T3.person_id) \nFROM competitor_event AS T1\nINNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id\nINNER JOIN person_region AS T3 ON T2.person_id = T3.person_id\nWHERE T3.region_id = 151 AND T1.medal_id != 4"
        ],
        "rule_sql": []
    },
    "7189": {
        "db_id": "works_cycles",
        "question": "How many of the non-sales employees are married?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.PersonType = 'EM' AND T1.MaritalStatus = 'M'",
        "amends": [
            "Do use explicit column reference `COUNT(T1.BusinessEntityID)` instead of `COUNT(*)` to count specific entities. Do join `Employee AS T1` with `Person AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do filter on `T2.PersonType = 'EM'` to target only employees instead of filtering by department. Do use marital status value `'M'` instead of `'Married'` to match the correct data format. Do remove the department filter entirely instead of including `department != 'Sales'` as the business logic now uses PersonType for employee identification. The amended query now correctly counts married employees by joining necessary tables and using appropriate filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department != 'Sales' AND marital_status = 'Married';",
            "SELECT COUNT(T1.BusinessEntityID) \nFROM Employee AS T1\nJOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T2.PersonType = 'EM' \nAND T1.MaritalStatus = 'M'"
        ],
        "rule_sql": []
    },
    "1377": {
        "db_id": "synthea",
        "question": "State the prevalence rate of condition no. 368581000119106.",
        "ground_truth": "SELECT DISTINCT T1.\"PREVALENCE RATE\" FROM all_prevalences AS T1 INNER JOIN conditions AS T2 ON lower(T1.ITEM) = lower(T2.DESCRIPTION) WHERE T2.code = '368581000119106'",
        "amends": [
            "Do select `DISTINCT T1.\"PREVALENCE RATE\"` instead of `COUNT(*)`. Do add `FROM all_prevalences AS T1 INNER JOIN conditions AS T2` instead of only `FROM conditions`. Do use join condition `ON lower(T1.ITEM) = lower(T2.DESCRIPTION)` instead of no join. Do change filter to `WHERE T2.code = '368581000119106'` instead of `WHERE condition_code = '368581000119106'`. The amended query now correctly joins prevalence data with conditions and returns distinct prevalence rates instead of counting records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM conditions WHERE condition_code = '368581000119106';",
            "SELECT DISTINCT T1.\"PREVALENCE RATE\" \nFROM all_prevalences AS T1 \nINNER JOIN conditions AS T2 \nON lower(T1.ITEM) = lower(T2.DESCRIPTION) \nWHERE T2.code = '368581000119106'"
        ],
        "rule_sql": []
    },
    "1075": {
        "db_id": "talkingdata",
        "question": "How many users of the app were not active when event no.2 happened?",
        "ground_truth": "SELECT COUNT(event_id) FROM app_events WHERE event_id = 2 AND is_active = 0",
        "amends": [
            "Do select `COUNT(event_id)` from `app_events` instead of `COUNT(*)` from `users`. Do add filter `is_active = 0` instead of omitting it. Do remove the `NOT IN` subquery against `events` table instead of keeping it, and do change the table reference to `app_events` instead of `users`. Do keep the `event_id = 2` filter but move it to the main query instead of the subquery. The amended query now correctly counts active events from the appropriate table with proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE user_id NOT IN (SELECT user_id FROM events WHERE event_id = 2);",
            "SELECT COUNT(event_id) FROM app_events WHERE event_id = 2 AND is_active = 0"
        ],
        "rule_sql": []
    },
    "4466": {
        "db_id": "student_loan",
        "question": "How many male stuents do not have payment due?",
        "ground_truth": "SELECT COUNT(T1.name) FROM male AS T1 INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE T2.bool = 'neg'",
        "amends": [
            "Do select `COUNT(T1.name)` instead of `COUNT(*)` to count specific non-null values. Do use `FROM male AS T1 INNER JOIN no_payment_due AS T2` instead of `FROM students` to join specialized tables rather than querying a single table directly. Do apply the join condition `ON T1.name = T2.name` instead of no explicit join, establishing the relationship between the two tables. Do add the filter `WHERE T2.bool = 'neg'` instead of `WHERE gender = 'male' AND payment_due = 0` to use the boolean flag from the joined table rather than direct column comparisons. The amended query now correctly counts male students with no payment due by leveraging properly normalized table structures and explicit join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND payment_due = 0;",
            "SELECT COUNT(T1.name) FROM male AS T1 INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE T2.bool = 'neg'"
        ],
        "rule_sql": []
    },
    "9104": {
        "db_id": "movie_3",
        "question": "How many films have a rental duration of over 6 days?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE rental_duration > 6",
        "amends": [
            "Do use `COUNT(film_id)` instead of `COUNT(*)` to count only non-null film_id values. Do change the WHERE filter to `rental_duration > 6` instead of `rental_duration <= 6` to count films with rental duration exceeding 6 days rather than those with 6 days or less. The amended query now correctly counts films with rental durations greater than 6 days."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film WHERE rental_duration <= 6;",
            "SELECT COUNT(film_id) FROM film WHERE rental_duration > 6"
        ],
        "rule_sql": []
    },
    "6182": {
        "db_id": "food_inspection_2",
        "question": "Provide the categories and fines for the inspections done by Lisa Tillman in January 2014.",
        "ground_truth": "SELECT DISTINCT T4.category, T3.fine FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T1.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE T2.first_name = 'Lisa' AND T2.last_name = 'Tillman' AND strftime('%Y-%m', T1.inspection_date) = '2014-01'",
        "amends": [
            "Do use explicit table joins instead of querying a single table. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do join `employee` table on `employee_id` instead of filtering by inspector name directly. Do join `violation` table on `inspection_id` to access fine information instead of assuming it's in the inspections table. Do join `inspection_point` table on `point_id` to get category information instead of assuming it's in the inspections table. Do use `strftime` function for proper date filtering instead of `LIKE` pattern matching on date strings. Do filter by first and last name separately instead of using a combined inspector name field. The amended query now correctly joins multiple tables to retrieve category and fine data while properly filtering by employee name and date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, fine FROM inspections WHERE inspector = 'Lisa Tillman' AND inspection_date LIKE '2014-01%';",
            "SELECT DISTINCT ip.category, v.fine\nFROM inspection i\nJOIN employee e ON i.employee_id = e.employee_id\nJOIN violation v ON i.inspection_id = v.inspection_id\nJOIN inspection_point ip ON v.point_id = ip.point_id\nWHERE e.first_name = 'Lisa' \nAND e.last_name = 'Tillman'\nAND strftime('%Y-%m', i.inspection_date) = '2014-01';"
        ],
        "rule_sql": []
    },
    "9218": {
        "db_id": "movie_3",
        "question": "Among the films rented by Natalie Meyer, describe the titles and categories of the films which were rented in February 2006.",
        "ground_truth": "SELECT T3.title, T2.name FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id INNER JOIN customer AS T5 ON T4.store_id = T5.store_id INNER JOIN rental AS T6 ON T4.inventory_id = T6.inventory_id WHERE T5.first_name = 'Natalie' AND T5.last_name = 'Meyer' AND STRFTIME('%Y',T3.rental_rate) = '2006' AND STRFTIME('%m',T3.rental_rate) = '2'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title, c.name \nFROM film f \nJOIN film_category fc ON f.film_id = fc.film_id \nJOIN category c ON fc.category_id = c.category_id \nJOIN inventory i ON f.film_id = i.film_id \nJOIN rental r ON i.inventory_id = r.inventory_id \nJOIN customer cu ON r.customer_id = cu.customer_id \nWHERE cu.first_name = 'Natalie' \nAND cu.last_name = 'Meyer' \nAND r.rental_date LIKE '2006-02%'"
        ],
        "rule_sql": []
    },
    "4691": {
        "db_id": "disney",
        "question": "Provide the title, director, and release date of the movie voice-acted by Freddie Jones.",
        "ground_truth": "SELECT T1.movie, T3.director, T2.release_date FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T1.movie = T2.movie_title INNER JOIN director AS T3 ON T3.name = T2.movie_title WHERE T1.`voice-actor` = 'Freddie Jones'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of direct table references. Do select `T1.movie`, `T3.director`, and `T2.release_date` instead of `title`, `director`, and `release_date`. Do join from `voice-actors` AS T1 instead of querying `movies` table. Do add INNER JOIN with `characters` AS T2 on `T1.movie = T2.movie_title` instead of missing this relationship. Do add INNER JOIN with `director` AS T3 on `T3.name = T2.movie_title` instead of omitting director table. Do filter on `T1.voice-actor` = 'Freddie Jones' instead of `voice_actor` column from wrong table. The amended query now correctly joins across multiple tables to find movies with the specified voice actor."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, director, release_date FROM movies WHERE voice_actor = 'Freddie Jones';",
            "SELECT T1.movie, T3.director, T2.release_date \nFROM \"voice-actors\" AS T1\nINNER JOIN characters AS T2 ON T1.movie = T2.movie_title\nINNER JOIN director AS T3 ON T3.name = T2.movie_title\nWHERE T1.\"voice-actor\" = 'Freddie Jones'"
        ],
        "rule_sql": []
    },
    "4464": {
        "db_id": "student_loan",
        "question": "How many of the students joined two organization?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ >= 2",
        "amends": [
            "Do select `COUNT(name)` from the `enlist` table instead of `COUNT(*)` from the `students` table. Do use the filter `organ >= 2` instead of `organization_count = 2` to count records where the organization count is at least 2 rather than exactly 2. The amended query now correctly counts names from the enlist table where the organization value meets the minimum threshold requirement.",
            "Do use a simple `WHERE` filter on `organ >= 2` instead of a subquery with `GROUP BY` and `HAVING COUNT(organ) >= 2`. Do remove the unnecessary subquery structure and `HAVING` clause instead of keeping them. Do filter rows directly in the main query instead of using a derived table approach. The amended query now correctly counts names where organ value is at least 2, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE organization_count = 2;",
            "SELECT COUNT(name) FROM (SELECT name FROM enlist GROUP BY name HAVING COUNT(organ) >= 2)",
            "SELECT COUNT(name) FROM enlist WHERE organ >= 2"
        ],
        "rule_sql": []
    },
    "7320": {
        "db_id": "works_cycles",
        "question": "Which vendor gives the best profit on net for product ID 342?",
        "ground_truth": "SELECT T1.Name FROM Vendor AS T1 INNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.ProductID = 342 ORDER BY T2.LastReceiptCost - T2.StandardPrice DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `vendor_id, MAX(net_profit)` and remove the aggregate function. Do join `Vendor AS T1` with `ProductVendor AS T2` using `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single `sales` table. Do filter on `T2.ProductID = 342` instead of `product_id = 342` but move this condition to the WHERE clause instead of keeping it in the original position. Do order by the calculated expression `T2.LastReceiptCost - T2.StandardPrice DESC` instead of `net_profit DESC` and maintain the `LIMIT 1`. The amended query now correctly retrieves the vendor name with the highest profit margin for product 342 instead of attempting to find maximum net profit from a sales table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_id, MAX(net_profit) FROM sales WHERE product_id = 342 GROUP BY vendor_id ORDER BY net_profit DESC LIMIT 1;",
            "SELECT T1.Name\nFROM Vendor AS T1\nINNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T2.ProductID = 342\nORDER BY (T2.LastReceiptCost - T2.StandardPrice) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1708": {
        "db_id": "restaurant",
        "question": "What is the percentage of restaurants that serve American food in Dublin city?",
        "ground_truth": "SELECT CAST(SUM(IIF(food_type = 'american food', 1, 0)) AS REAL) * 100 / COUNT(id_restaurant) FROM generalinfo WHERE city = 'dublin'",
        "amends": [
            "Do use `SUM(IIF(food_type = 'american food', 1, 0))` instead of `COUNT(CASE WHEN cuisine = 'American' THEN 1 END)` for conditional counting. Do cast the result as `REAL` instead of using `100.0` for floating-point division. Do reference `id_restaurant` in `COUNT()` instead of `COUNT(*)` for specific column counting. Do use `food_type` column with value `'american food'` instead of `cuisine` column with value `'American'` for the food category filter. Do use table `generalinfo` instead of `restaurants` as the data source. The amended query now correctly calculates the percentage of American food restaurants in Dublin with proper type handling and column references.",
            "Do cast the SUM result as `REAL` instead of using implicit conversion, do use lowercase `'dublin'` instead of `'Dublin'` for case-sensitive filtering, and do remove the column alias `percentage` instead of keeping it. The amended query now correctly handles floating-point division by ensuring numeric casting and matches the case-sensitive filter requirement."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN cuisine = 'American' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM restaurants\nWHERE city = 'Dublin';",
            "SELECT \n    (SUM(IIF(food_type = 'american food', 1, 0)) * 100.0 / COUNT(id_restaurant)) AS percentage\nFROM \n    generalinfo\nWHERE \n    city = 'Dublin';",
            "SELECT (SUM(IIF(food_type = 'american food', 1, 0)) * 100.0 / COUNT(id_restaurant)) FROM generalinfo WHERE city = 'dublin';"
        ],
        "rule_sql": []
    },
    "6869": {
        "db_id": "retails",
        "question": "Please list the names of all the suppliers for the part \"hot spring dodger dim light\".",
        "ground_truth": "SELECT T2.s_name FROM partsupp AS T1 INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T3.p_name = 'hot spring dodger dim light'",
        "amends": [
            "Do use `T2.s_name` instead of `supplier_name` for the column selection. Do join `partsupp AS T1` with `supplier AS T2` on `T1.ps_suppkey = T2.s_suppkey` instead of querying `suppliers` directly. Do add an additional join to `part AS T3` on `T1.ps_partkey = T3.p_partkey` instead of omitting the parts table. Do filter on `T3.p_name` instead of `part_name` to correctly reference the part name column from the joined table. The amended query now correctly joins the necessary tables to find suppliers for the specified part name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT supplier_name FROM suppliers WHERE part_name = 'hot spring dodger dim light';",
            "SELECT T2.s_name\nFROM partsupp AS T1\nJOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey\nJOIN part AS T3 ON T1.ps_partkey = T3.p_partkey\nWHERE T3.p_name = 'hot spring dodger dim light';"
        ],
        "rule_sql": []
    },
    "3383": {
        "db_id": "video_games",
        "question": "Provide the games that can be played on the SCD platform.",
        "ground_truth": "SELECT T4.game_name FROM game_platform AS T1 INNER JOIN platform AS T2 ON T1.platform_id = T2.id INNER JOIN game_publisher AS T3 ON T1.game_publisher_id = T3.id INNER JOIN game AS T4 ON T3.game_id = T4.id WHERE T2.platform_name = 'SCD'",
        "amends": [
            "Do select only `T4.game_name` instead of all columns with `*`. Do join multiple tables starting with `game_platform AS T1` instead of querying only `games`. Do use `INNER JOIN platform AS T2` with predicate `T1.platform_id = T2.id` instead of no join. Do add `INNER JOIN game_publisher AS T3` with predicate `T1.game_publisher_id = T3.id` instead of omitting this table. Do add `INNER JOIN game AS T4` with predicate `T3.game_id = T4.id` instead of omitting this table. Do filter on `T2.platform_name = 'SCD'` instead of `platform = 'XBOX'`. The amended query now correctly retrieves game names for the specified platform through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM games WHERE platform = 'XBOX';",
            "SELECT T4.game_name\nFROM game_platform AS T1\nINNER JOIN platform AS T2 ON T1.platform_id = T2.id\nINNER JOIN game_publisher AS T3 ON T1.game_publisher_id = T3.id\nINNER JOIN game AS T4 ON T3.game_id = T4.id\nWHERE T2.platform_name = 'SCD'"
        ],
        "rule_sql": []
    },
    "1605": {
        "db_id": "car_retails",
        "question": "What is the full address of the office where 4 people work and one of them is Sales Representation?",
        "ground_truth": "SELECT T1.addressLine1, T1.addressLine2 FROM customers AS T1 INNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber WHERE T2.jobTitle = 'Sales Rep'",
        "amends": [
            "Do select `T1.addressLine1` and `T1.addressLine2` instead of `address` from a single table. Do join `customers AS T1` with `employees AS T2` using `INNER JOIN` instead of querying only the `offices` table. Do use the join condition `T1.salesRepEmployeeNumber = T2.employeeNumber` instead of no join condition. Do filter on `T2.jobTitle = 'Sales Rep'` instead of `employee_count = 4 AND job_title = 'Sales Representation'`. The amended query now correctly retrieves customer addresses for sales representatives by joining the appropriate tables with the correct relationship and filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM offices WHERE employee_count = 4 AND job_title = 'Sales Representation'",
            "SELECT T1.addressLine1, T1.addressLine2\nFROM customers AS T1\nINNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber\nWHERE T2.jobTitle = 'Sales Rep'"
        ],
        "rule_sql": []
    },
    "1679": {
        "db_id": "restaurant",
        "question": "What type of food is there in the restaurants on Adeline Street in Berkeley city?",
        "ground_truth": "SELECT T1.food_type FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_name = 'adeline st' AND T2.city = 'berkeley'",
        "amends": [
            "Do select `T1.food_type` with table alias qualification instead of unqualified `food_type`. Do use `FROM generalinfo AS T1 INNER JOIN location AS T2` with explicit table aliases and join instead of single table `FROM restaurants`. Do join on `T1.id_restaurant = T2.id_restaurant` instead of no join condition. Do filter on `T2.street_name = 'adeline st'` with lowercase value and column name instead of `street = 'Adeline Street'` with different case and column name. Do filter on `T2.city = 'berkeley'` with lowercase value instead of `city = 'Berkeley'` with different case. The amended query now correctly joins the generalinfo and location tables to retrieve food_type while matching the case-sensitive street and city values in the location table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT food_type FROM restaurants WHERE street = 'Adeline Street' AND city = 'Berkeley';",
            "SELECT T1.food_type FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_name = 'adeline st' AND T2.city = 'berkeley'"
        ],
        "rule_sql": []
    },
    "6953": {
        "db_id": "ice_hockey_draft",
        "question": "How tall is the player from Yale University who picked up 28 penalty minutes in the 2005-2006 season?",
        "ground_truth": "SELECT T3.height_in_cm FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID INNER JOIN height_info AS T3 ON T2.height = T3.height_id WHERE T1.SEASON = '2005-2006' AND T1.TEAM = 'Yale Univ.' AND T1.PIM = 28",
        "amends": [
            "Do select `T3.height_in_cm` instead of `height` from the wrong source. Do use `SeasonStatus AS T1` joined with `PlayerInfo AS T2` on `T1.ELITEID = T2.ELITEID` instead of querying `players` directly. Do add a second join to `height_info AS T3` on `T2.height = T3.height_id` instead of missing this table relationship. Do filter on `T1.SEASON = '2005-2006'` instead of `season = '2005-2006'` from the wrong table. Do use `T1.TEAM = 'Yale Univ.'` instead of `university = 'Yale University'` with the corrected team name. Do filter on `T1.PIM = 28` instead of `penalty_minutes = 28` using the proper column name. The amended query now correctly joins the three tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT height FROM players WHERE university = 'Yale University' AND penalty_minutes = 28 AND season = '2005-2006';",
            "SELECT T3.height_in_cm \nFROM SeasonStatus AS T1\nJOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID\nJOIN height_info AS T3 ON T2.height = T3.height_id\nWHERE T1.SEASON = '2005-2006'\nAND T1.TEAM = 'Yale Univ.'\nAND T1.PIM = 28"
        ],
        "rule_sql": []
    },
    "4170": {
        "db_id": "simpson_episodes",
        "question": "Please list the titles of the episodes that have over 200 voters voting a 10 in star score.",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.votes > 200 AND T2.stars = 10;",
        "amends": [
            "Do reference `T1.title` with table alias instead of just `title`. Do join `Episode AS T1` with `Vote AS T2` on `T2.episode_id = T1.episode_id` instead of querying only the `episodes` table. Do filter on `T2.votes > 200` instead of `voters > 200`. Do filter on `T2.stars = 10` instead of `star_score > 10`. The amended query now correctly joins the Episode and Vote tables to filter based on vote counts and star ratings from the Vote table instead of incorrectly assuming those columns exist in the episodes table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE star_score > 10 AND voters > 200",
            "SELECT T1.title \nFROM Episode AS T1 \nJOIN Vote AS T2 ON T2.episode_id = T1.episode_id \nWHERE T2.stars = 10 AND T2.votes > 200"
        ],
        "rule_sql": []
    },
    "7974": {
        "db_id": "music_platform_2",
        "question": "List the urls for all the \"fiction-science-fiction\" podcasts.",
        "ground_truth": "SELECT itunes_url FROM podcasts WHERE podcast_id IN ( SELECT podcast_id FROM categories WHERE category = 'fiction-science-fiction' )",
        "amends": [
            "Do select `itunes_url` instead of `url` from the podcasts table. Do use a subquery with `podcast_id IN (SELECT podcast_id FROM categories WHERE category = 'fiction-science-fiction')` instead of directly filtering on `genre = 'fiction-science-fiction'` in the WHERE clause. The amended query now correctly joins through the categories table to filter podcasts by category rather than using a non-existent genre column, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT url FROM podcasts WHERE genre = 'fiction-science-fiction';",
            "SELECT itunes_url FROM podcasts WHERE podcast_id IN (SELECT podcast_id FROM categories WHERE category = 'fiction-science-fiction')"
        ],
        "rule_sql": []
    },
    "5633": {
        "db_id": "shipping",
        "question": "What is the model year of the truck used in shipment id 1003?",
        "ground_truth": "SELECT T1.model_year FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = '1003'",
        "amends": [
            "Do specify the table alias `T1.model_year` instead of just `model_year`. Do join `truck AS T1` with `shipment AS T2` instead of querying only the `trucks` table. Do use the join condition `T1.truck_id = T2.truck_id` instead of no join. Do filter on `T2.ship_id = '1003'` instead of `shipment_id = 1003`, using string comparison instead of numeric and referencing the correct column from the joined table. The amended query now correctly retrieves model year by joining truck and shipment tables and filtering on the shipment ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model_year FROM trucks WHERE shipment_id = 1003;",
            "SELECT T1.model_year FROM truck AS T1 JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = '1003'"
        ],
        "rule_sql": []
    },
    "2210": {
        "db_id": "world_development_indicators",
        "question": "What is the series code for Germany and what is its description?",
        "ground_truth": "SELECT T1.Seriescode, T1.Description FROM CountryNotes AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.ShortName = 'Germany'",
        "amends": [
            "Do select `T1.Seriescode` and `T1.Description` instead of `series_code` and `description`. Do use `CountryNotes AS T1` as the main table instead of `series`. Do add an `INNER JOIN` with `Country AS T2` on `T1.CountryCode = T2.CountryCode` instead of no join. Do filter on `T2.ShortName = 'Germany'` instead of `country = 'Germany'`. The amended query now correctly joins the CountryNotes and Country tables to filter by country name rather than assuming a direct country column in the series table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_code, description FROM series WHERE country = 'Germany';",
            "SELECT T1.Seriescode, T1.Description \nFROM CountryNotes AS T1 \nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.ShortName = 'Germany'"
        ],
        "rule_sql": []
    },
    "6174": {
        "db_id": "food_inspection_2",
        "question": "How many inspections were done in January 2011?",
        "ground_truth": "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y-%m', inspection_date) = '2011-01'",
        "amends": [
            "Do use `COUNT(inspection_id)` instead of `COUNT(*)` to count specific non-null values. Do reference table `inspection` instead of `inspections` for correct table name. Do apply `strftime('%Y-%m', inspection_date)` function instead of direct date comparison to filter by year-month instead of exact date. Do filter for `'2011-01'` instead of `'2011-01-01'` to match the year-month pattern. The amended query now correctly counts inspections from January 2011 rather than only those from January 1st, 2011."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE inspection_date = '2011-01-01';",
            "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y-%m', inspection_date) = '2011-01'"
        ],
        "rule_sql": []
    },
    "8667": {
        "db_id": "chicago_crime",
        "question": "List the report number of crimes reported in a community area in the far north side with a population greater than 60,000.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.population > 60000 THEN 1 ELSE 0 END) FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE T1.side = 'Far North '",
        "amends": [
            "Do use `SUM(CASE WHEN T1.population > 60000 THEN 1 ELSE 0 END)` instead of `report_number` in the SELECT list to count qualifying records. Do join `Community_Area AS T1` with `Crime AS T2` on `T2.community_area_no = T1.community_area_no` instead of querying only the `crimes` table. Do filter on `T1.side = 'Far North'` instead of `community_area = 'Far North Side'` to use the correct column name and value. Do remove the direct population filter from WHERE and instead incorporate it into the CASE expression within the aggregate function. The amended query now correctly counts crime reports from community areas on the Far North side with populations exceeding 60000, matching the intended behavior.",
            "Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type, though this is functionally equivalent. Do add a trailing space in the string literal `'Far North '` instead of `'Far North'` to match the exact text comparison requirement. The amended query now correctly matches the RIGHT_SQL's behavior with the precise string filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT report_number FROM crimes WHERE community_area = 'Far North Side' AND population > 60000;",
            "SELECT SUM(CASE WHEN T1.population > 60000 THEN 1 ELSE 0 END) \nFROM Community_Area AS T1\nJOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no\nWHERE T1.side = 'Far North'",
            "SELECT SUM(CASE WHEN T1.population > 60000 THEN 1 ELSE 0 END) \nFROM Community_Area AS T1\nINNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no\nWHERE T1.side = 'Far North '"
        ],
        "rule_sql": []
    },
    "5674": {
        "db_id": "shipping",
        "question": "Provide the destination city of the shipment shipped by January 16, 2017.",
        "ground_truth": "SELECT T2.city_name FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T1.ship_date = '2017-01-16'",
        "amends": [
            "Do select `T2.city_name` from the joined city table instead of `destination_city` from the shipments table directly. Do add `INNER JOIN city AS T2` with join condition `ON T1.city_id = T2.city_id` instead of querying only the shipments table. Do use table alias `T1` for the shipment table instead of referencing it directly. Do filter on `T1.ship_date` instead of `ship_date` to specify the table source. The amended query now correctly joins to the city table to retrieve the city name rather than assuming destination_city exists in the shipments table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination_city FROM shipments WHERE ship_date = '2017-01-16';",
            "SELECT T2.city_name \nFROM shipment AS T1 \nINNER JOIN city AS T2 ON T1.city_id = T2.city_id \nWHERE T1.ship_date = '2017-01-16'"
        ],
        "rule_sql": []
    },
    "5538": {
        "db_id": "menu",
        "question": "Name the dishes that cost 180,000.",
        "ground_truth": "SELECT T1.name FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T2.price = 180000",
        "amends": [
            "Do select `T1.name` from the `Dish` table instead of `dish_name` from `dishes`. Do join `MenuItem AS T2` with `INNER JOIN` on `T1.id = T2.dish_id` instead of querying a single table. Do filter on `T2.price = 180000` as an integer value instead of `price = '180,000'` with string comparison and comma formatting. The amended query now correctly joins tables and uses proper numeric comparison to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name FROM dishes WHERE price = '180,000';",
            "SELECT T1.name \nFROM Dish AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id\nWHERE T2.price = 180000"
        ],
        "rule_sql": []
    },
    "1910": {
        "db_id": "soccer_2016",
        "question": "Identify by their ID all the overs in which the player with ID 7 was on strike.",
        "ground_truth": "SELECT DISTINCT Over_Id FROM Ball_by_Ball WHERE Striker = 7",
        "amends": [
            "Do select `DISTINCT Over_Id` from table `Ball_by_Ball` instead of selecting `over_id` from table `overs`. Do use filter condition `Striker = 7` instead of `striker_id = 7`. The amended query now correctly retrieves distinct over IDs from the Ball_by_Ball table where the striker equals 7, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT over_id FROM overs WHERE striker_id = 7;",
            "SELECT DISTINCT Over_Id FROM Ball_by_Ball WHERE Striker = 7"
        ],
        "rule_sql": []
    },
    "4912": {
        "db_id": "legislator",
        "question": "Among the female legislators, what is the percentage of the senators in Maine?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.type = 'sen' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.type) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.state = 'ME' AND T1.gender_bio = 'F'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.type = 'sen' THEN 1 ELSE 0 END)` with explicit casting to `REAL` instead of `COUNT(*)` for calculating the percentage. Do join `current AS T1` with `current-terms AS T2` on `T1.bioguide_id = T2.bioguide` instead of querying only the `legislators` table. Do filter on `T2.state = 'ME'` instead of `state = 'Maine'` and use `T1.gender_bio = 'F'` instead of `gender = 'F'`. Do calculate the percentage by dividing the sum of senators by the total count of `T2.type` instead of using a subquery for the denominator. The amended query now correctly handles the join between current legislators and their terms while using proper state abbreviations and field names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM legislators WHERE gender = 'F')) AS percentage\nFROM legislators \nWHERE state = 'Maine' AND gender = 'F';",
            "SELECT \n    (SUM(CASE WHEN T2.type = 'sen' THEN 1 ELSE 0 END) * 100.0 / COUNT(T2.type)) AS percentage\nFROM \n    current AS T1\nJOIN \n    \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nWHERE \n    T1.gender_bio = 'F' \n    AND T2.state = 'ME';"
        ],
        "rule_sql": []
    },
    "5738": {
        "db_id": "language_corpus",
        "question": "Please list the top three most frequently occurring words and their ids.",
        "ground_truth": "SELECT word, wid FROM words ORDER BY occurrences DESC LIMIT 3",
        "amends": [
            "Do select `wid` instead of `id` in the SELECT list. Do order by `occurrences` instead of `frequency` in the ORDER BY clause. The amended query now correctly retrieves the word and word ID columns while ordering by occurrence count instead of frequency.",
            "Do remove `occurrences` from the SELECT list instead of including it, and do reorder the remaining columns as `word, wid` instead of `wid, word`. Do keep the `ORDER BY occurrences DESC LIMIT 3` clause unchanged as it correctly sorts and limits the results. The amended query now matches the right SQL's behavior by selecting only the necessary columns in the specified order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word, id FROM words ORDER BY frequency DESC LIMIT 3;",
            "SELECT wid, word, occurrences FROM words ORDER BY occurrences DESC LIMIT 3;",
            "SELECT word, wid FROM words ORDER BY occurrences DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "2144": {
        "db_id": "world_development_indicators",
        "question": "Please list out all annual indicator names of Sudan in 1961?",
        "ground_truth": "SELECT T1.IndicatorName FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE T1.CountryName = 'Sudan' AND T1.Year = 1961 AND T2.Periodicity = 'Annual'",
        "amends": [
            "Do select `T1.IndicatorName` from table `Indicators AS T1` instead of `indicator_name` from `annual_data`. Do add `INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName` instead of omitting the join. Do use filter `T1.CountryName = 'Sudan'` instead of `country = 'Sudan'`. Do use filter `T1.Year = 1961` instead of `year = 1961`. Do add filter `T2.Periodicity = 'Annual'` instead of omitting it. The amended query now correctly joins the Indicators and Series tables to filter by periodicity and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT indicator_name FROM annual_data WHERE country = 'Sudan' AND year = 1961",
            "SELECT T1.IndicatorName \nFROM Indicators AS T1 \nINNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName \nWHERE T1.CountryName = 'Sudan' \nAND T1.Year = 1961 \nAND T2.Periodicity = 'Annual'"
        ],
        "rule_sql": []
    },
    "7380": {
        "db_id": "works_cycles",
        "question": "Which product allows the company to make the highest profit on a single item among those that are the fastest to manufacture? Indicate the rating of the product if there any.",
        "ground_truth": "SELECT T1.Name, T2.Rating FROM Product AS T1 INNER JOIN ProductReview AS T2 ON T1.ProductID = T2.ProductID WHERE T1.DaysToManufacture = ( SELECT DaysToManufacture FROM Product ORDER BY DaysToManufacture LIMIT 1 ) ORDER BY T1.ListPrice - T1.StandardCost DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T2.Rating` instead of `product_name` and `rating`. Do use `INNER JOIN` between `Product` and `ProductReview` on `T1.ProductID = T2.ProductID` instead of querying only the `products` table. Do filter on `T1.DaysToManufacture` matching the minimum manufacturing time via a subquery with `ORDER BY DaysToManufacture LIMIT 1` instead of using `MIN(manufacturing_time)` in a subquery. Do order by `T1.ListPrice - T1.StandardCost` instead of `profit_per_item`. The amended query now correctly joins product and review data, calculates profit dynamically, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, rating \nFROM products \nWHERE manufacturing_time = (SELECT MIN(manufacturing_time) FROM products) \nORDER BY profit_per_item DESC \nLIMIT 1;",
            "SELECT T1.Name, T2.Rating\nFROM Product T1\nINNER JOIN ProductReview T2 ON T1.ProductID = T2.ProductID\nWHERE T1.DaysToManufacture = (\n    SELECT DaysToManufacture \n    FROM Product \n    ORDER BY DaysToManufacture \n    LIMIT 1\n)\nORDER BY (T1.ListPrice - T1.StandardCost) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6583": {
        "db_id": "retail_world",
        "question": "How many companies do ship Northwind's orders?",
        "ground_truth": "SELECT COUNT(ShipperID) FROM Shippers",
        "amends": [
            "Do select `COUNT(ShipperID)` from the `Shippers` table instead of `COUNT(*)` from the `Orders` table. Do remove the `WHERE ShipVia = 'Northwind'` filter instead of keeping it, as the correct approach counts all shippers rather than filtering orders by a specific shipper name. The amended query now correctly counts all shipper records and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Orders WHERE ShipVia = 'Northwind';",
            "SELECT COUNT(ShipperID) FROM Shippers;"
        ],
        "rule_sql": []
    },
    "1104": {
        "db_id": "talkingdata",
        "question": "What is the age of the youngest female user of the app?",
        "ground_truth": "SELECT MIN(age) FROM gender_age WHERE gender = 'F'",
        "amends": [
            "Do use table `gender_age` instead of `users` for the data source. Do use aggregate function `MIN(age)` instead of `MAX(age)` to find the minimum age rather than maximum. Do use filter condition `gender = 'F'` instead of `gender = 'female'` with the abbreviated gender code. The amended query now correctly retrieves the minimum age for female records from the appropriate table using consistent gender coding."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(age) FROM users WHERE gender = 'female';",
            "SELECT MIN(age) FROM gender_age WHERE gender = 'F';"
        ],
        "rule_sql": []
    },
    "5343": {
        "db_id": "beer_factory",
        "question": "What is the transaction ratio being made at Sac State American River Courtyard and Sac State Union?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.LocationName = 'Sac State American River Courtyard' THEN T1.TransactionID ELSE NULL END) AS REAL) * 100 / COUNT(CASE WHEN T2.LocationName = 'Sac State Union' THEN T1.TransactionID ELSE NULL END) FROM `transaction` AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID",
        "amends": [
            "Do reference `T2.LocationName` instead of `location` for location filtering. Do add `INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID` instead of querying from a single table. Do use `T1.TransactionID` in the COUNT expressions instead of the literal `1`. Do add explicit `ELSE NULL` clauses instead of omitting them. Do cast the numerator to `REAL` instead of performing integer division. Do multiply by `100` to calculate a percentage instead of a ratio. Do reference the correct table name `transaction` instead of `transactions`. The amended query now correctly joins location data and calculates the percentage with proper type handling.",
            "Do calculate a ratio of counts using `CASE` expressions instead of computing percentages against a total. Do use `COUNT(CASE WHEN T2.LocationName = 'Sac State American River Courtyard' THEN T1.TransactionID ELSE NULL END)` instead of counting all transactions at both locations. Do divide by `COUNT(CASE WHEN T2.LocationName = 'Sac State Union' THEN T1.TransactionID ELSE NULL END)` instead of using a subquery to get total count. Do cast the numerator to `REAL` instead of using decimal multiplication. Do remove the `GROUP BY T2.LocationName` clause instead of grouping by location name. Do remove the explicit column aliases `TransactionCount` and `TransactionPercentage` instead of keeping them. Do eliminate the `WHERE` filter on location names instead of filtering rows before aggregation. The amended query now correctly computes the ratio of transactions between the two specific locations rather than calculating percentages against a total count, matching the RIGHT_SQL's behavior.",
            "Do multiply the numerator by `100` instead of omitting it to calculate a percentage ratio. Do remove the alias `TransactionRatio` instead of keeping it since the RIGHT_SQL returns an unaliased result. The amended query now correctly calculates the percentage transaction ratio between the two specified locations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN location = 'Sac State American River Courtyard' THEN 1 END) / \n     COUNT(CASE WHEN location = 'Sac State Union' THEN 1 END)) AS transaction_ratio\nFROM transactions;",
            "SELECT \n    T2.LocationName,\n    COUNT(T1.TransactionID) AS TransactionCount,\n    (COUNT(T1.TransactionID) * 100.0 / (SELECT COUNT(*) FROM transaction WHERE LocationID IN (SELECT LocationID FROM location WHERE LocationName IN ('Sac State American River Courtyard', 'Sac State Union')))) AS TransactionPercentage\nFROM \n    transaction AS T1\nINNER JOIN \n    location AS T2 ON T1.LocationID = T2.LocationID\nWHERE \n    T2.LocationName IN ('Sac State American River Courtyard', 'Sac State Union')\nGROUP BY \n    T2.LocationName;",
            "SELECT \n    CAST(COUNT(CASE WHEN T2.LocationName = 'Sac State American River Courtyard' THEN T1.TransactionID ELSE NULL END) AS REAL) / \n    COUNT(CASE WHEN T2.LocationName = 'Sac State Union' THEN T1.TransactionID ELSE NULL END) AS TransactionRatio\nFROM \n    \"transaction\" AS T1\nINNER JOIN \n    location AS T2 ON T1.LocationID = T2.LocationID",
            "SELECT \n    CAST(COUNT(CASE WHEN T2.LocationName = 'Sac State American River Courtyard' THEN T1.TransactionID ELSE NULL END) AS REAL) * 100.0 / \n    COUNT(CASE WHEN T2.LocationName = 'Sac State Union' THEN T1.TransactionID ELSE NULL END)\nFROM \n    \"transaction\" AS T1\nINNER JOIN \n    location AS T2 ON T1.LocationID = T2.LocationID"
        ],
        "rule_sql": []
    },
    "7957": {
        "db_id": "music_platform_2",
        "question": "List the titles of the art category.",
        "ground_truth": "SELECT DISTINCT T2.title FROM categories AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'arts'",
        "amends": [
            "Do use `DISTINCT T2.title` instead of `title` to eliminate duplicates. Do join `categories AS T1` and `reviews AS T2` with `INNER JOIN` on `T2.podcast_id = T1.podcast_id` instead of querying only the `art` table. Do filter on `T1.category = 'arts'` instead of `category = 'art'` to match the correct category value and table reference. The amended query now correctly retrieves distinct review titles from the arts category by properly joining the categories and reviews tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM art WHERE category = 'art'",
            "SELECT DISTINCT T2.title FROM categories AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'arts'"
        ],
        "rule_sql": []
    },
    "9003": {
        "db_id": "bike_share_1",
        "question": "Calculate the average usage of each bike in the third quarter of year 2013. Find the average wind direction within the same period.",
        "ground_truth": "SELECT AVG(T1.duration), AVG(T2.wind_dir_degrees) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), 1, INSTR(T2.date, '/') - 1) IN ('7', '8', '9') AND SUBSTR(CAST(T2.date AS TEXT), -4) = '2013'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do select `AVG(T1.duration)` and `AVG(T2.wind_dir_degrees)` instead of `bike_id`, `AVG(usage)`, and `AVG(wind_direction)`. Do use tables `trip AS T1` and `weather AS T2` instead of `bike_usage`. Do perform an `INNER JOIN` on `T2.zip_code = T1.zip_code` instead of no join. Do filter with `SUBSTR(CAST(T2.date AS TEXT), 1, INSTR(T2.date, '/') - 1) IN ('7', '8', '9')` and `SUBSTR(CAST(T2.date AS TEXT), -4) = '2013'` instead of `year = 2013 AND quarter = 3`. Do remove `GROUP BY bike_id` instead of keeping it. The amended query now correctly joins trip and weather data, filters for Q3 2013 using date parsing, and calculates average duration and wind direction without unnecessary grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bike_id, AVG(usage) as avg_usage, AVG(wind_direction) as avg_wind_direction\nFROM bike_usage\nWHERE year = 2013 AND quarter = 3\nGROUP BY bike_id;",
            "SELECT AVG(T1.duration) AS avg_duration, AVG(T2.wind_dir_degrees) AS avg_wind_direction\nFROM trip AS T1\nINNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code\nWHERE SUBSTR(CAST(T2.date AS TEXT), 1, INSTR(T2.date, '/') - 1) IN ('7', '8', '9')\nAND SUBSTR(CAST(T2.date AS TEXT), -4) = '2013'"
        ],
        "rule_sql": []
    },
    "2768": {
        "db_id": "european_football_1",
        "question": "What was the final score for the game Bursaspor vs Denizlispor on 2009/4/26?",
        "ground_truth": "SELECT FTHG, FTAG FROM matchs WHERE Date = '2009-04-26' AND HomeTeam = 'Bursaspor' AND AwayTeam = 'Denizlispor'",
        "amends": [
            "Do select `FTHG` and `FTAG` instead of `home_score` and `away_score`. Do use table `matchs` instead of `games`. Do format the date as `2009-04-26` instead of `2009/4/26`. Do use column names `HomeTeam` and `AwayTeam` instead of `home_team` and `away_team`. The amended query now correctly retrieves match data with the proper column and table names while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT home_score, away_score FROM games WHERE home_team = 'Bursaspor' AND away_team = 'Denizlispor' AND date = '2009/4/26';",
            "SELECT FTHG, FTAG FROM matchs WHERE HomeTeam = 'Bursaspor' AND AwayTeam = 'Denizlispor' AND Date = '2009-04-26';"
        ],
        "rule_sql": []
    },
    "4680": {
        "db_id": "disney",
        "question": "List the movies and genres released in 2016.",
        "ground_truth": "SELECT movie_title, genre FROM movies_total_gross WHERE SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '2016'",
        "amends": [
            "Do select `movie_title` and `genre` instead of `title` and `genre`. Do use table `movies_total_gross` instead of `movies`. Do filter using `SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '2016'` to extract the year from a date string instead of comparing `release_year = 2016` against a numeric year column. The amended query now correctly extracts year information from a date field and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, genre FROM movies WHERE release_year = 2016;",
            "SELECT movie_title, genre FROM movies_total_gross WHERE SUBSTR(release_date, LENGTH(release_date) - 3, LENGTH(release_date)) = '2016'"
        ],
        "rule_sql": []
    },
    "2299": {
        "db_id": "movielens",
        "question": "List all of the user ids and ages who rated movies with the id 1695219?",
        "ground_truth": "SELECT T2.userid, T2.age FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.movieid = 1695219",
        "amends": [
            "Do join `u2base AS T1` and `users AS T2` with `INNER JOIN` on `T1.userid = T2.userid` instead of querying only the `users` table. Do reference columns as `T2.userid` and `T2.age` instead of `user_id` and `age`. Do filter on `T1.movieid = 1695219` instead of `movie_id = 1695219` to correctly apply the condition to the joined table. The amended query now correctly retrieves user information based on movie ratings rather than attempting to filter a non-existent movie_id column in the users table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, age FROM users WHERE movie_id = 1695219",
            "SELECT T2.userid, T2.age\nFROM u2base AS T1\nINNER JOIN users AS T2 ON T1.userid = T2.userid\nWHERE T1.movieid = 1695219"
        ],
        "rule_sql": []
    },
    "9119": {
        "db_id": "movie_3",
        "question": "Please list the full names of all the actors that have starred in the film ACADEMY DINOSAUR.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.title = 'ACADEMY DINOSAUR'",
        "amends": [
            "Do add explicit table aliases `T1`, `T2`, and `T3` instead of omitting them. Do join `film_actor AS T2` and `film AS T3` instead of using a subquery. Do use `INNER JOIN` on `T1.actor_id = T2.actor_id` and `T2.film_id = T3.film_id` instead of the subquery predicate `film_id = (SELECT film_id FROM film WHERE title = 'ACADEMY DINOSAUR')`. Do move the filter to the main `WHERE` clause with `T3.title = 'ACADEMY DINOSAUR'` instead of the subquery condition. The amended query now correctly retrieves actors through the proper many-to-many relationship via the film_actor junction table and matches the RIGHT_SQL's behavior.",
            "Do select `T1.first_name` and `T1.last_name` as separate columns instead of concatenating them into `full_name`. The amended query now matches RIGHT_SQL's behavior by returning individual name components rather than a combined full name string."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM actor WHERE film_id = (SELECT film_id FROM film WHERE title = 'ACADEMY DINOSAUR')",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM actor AS T1\nINNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film AS T3 ON T2.film_id = T3.film_id\nWHERE T3.title = 'ACADEMY DINOSAUR';",
            "SELECT T1.first_name, T1.last_name\nFROM actor AS T1\nINNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film AS T3 ON T2.film_id = T3.film_id\nWHERE T3.title = 'ACADEMY DINOSAUR'"
        ],
        "rule_sql": []
    },
    "8725": {
        "db_id": "chicago_crime",
        "question": "How many crime against society were reported in Englewood?",
        "ground_truth": "SELECT SUM(CASE WHEN T3.community_area_name = 'Englewood' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no INNER JOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no WHERE T1.crime_against = 'Society'",
        "amends": [
            "Do use `SUM(CASE WHEN T3.community_area_name = 'Englewood' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only Englewood records. Do join `FBI_Code AS T1` and `Crime AS T2` on `T1.fbi_code_no = T2.fbi_code_no` instead of querying a single table. Do join `Community_Area AS T3` on `T2.community_area_no = T3.community_area_no` instead of using a direct neighborhood filter. Do filter on `T1.crime_against = 'Society'` instead of `crime_type = 'crime against society'` to use the correct column and value. Do remove the direct `neighborhood = 'Englewood'` filter and instead handle it through the CASE expression within the SUM aggregation. The amended query now correctly joins the necessary tables and uses proper column references to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE crime_type = 'crime against society' AND neighborhood = 'Englewood';",
            "SELECT SUM(CASE WHEN T3.community_area_name = 'Englewood' THEN 1 ELSE 0 END) AS crime_count\nFROM FBI_Code AS T1\nJOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no\nJOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no\nWHERE T1.crime_against = 'Society';"
        ],
        "rule_sql": []
    },
    "8487": {
        "db_id": "mondial_geo",
        "question": "Provide a full list of countries and its population with more than 70% of Chinese.",
        "ground_truth": "SELECT T1.Name, T1.Population * T2.Percentage FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Chinese' AND T2.Percentage > 70",
        "amends": [
            "Do select `T1.Name` and `T1.Population * T2.Percentage` instead of `country` and `population`. Do join `ethnicGroup AS T2` with `INNER JOIN` on `T1.Code = T2.Country` instead of querying a single table. Do add filter `T2.Name = 'Chinese'` instead of omitting it. Do change the percentage filter to `T2.Percentage > 70` instead of `chinese_percentage > 70`. The amended query now correctly calculates Chinese population by joining country data with ethnic group percentages and filtering for Chinese ethnicity specifically."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, population FROM countries WHERE chinese_percentage > 70;",
            "SELECT T1.Name, T1.Population * T2.Percentage \nFROM country AS T1 \nINNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country \nWHERE T2.Name = 'Chinese' AND T2.Percentage > 70"
        ],
        "rule_sql": []
    },
    "445": {
        "db_id": "movies_4",
        "question": "What is Walt Disney Pictures' most popular movie?",
        "ground_truth": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Walt Disney Pictures' ORDER BY T3.popularity DESC LIMIT 1",
        "amends": [
            "Do join `production_company` as `T1` and `movie_company` as `T2` on `T1.company_id = T2.company_id` instead of querying `movies` directly. Do join `movie` as `T3` on `T2.movie_id = T3.movie_id` instead of missing the relationship between companies and movies. Do filter on `T1.company_name = 'Walt Disney Pictures'` instead of `studio = 'Walt Disney Pictures'` to use the correct company name column. Do select only `T3.title` instead of both `title` and `MAX(popularity)` since the aggregation is unnecessary. Do order by `T3.popularity DESC` instead of ordering by a non-aggregated column in a grouped query. Do remove the `GROUP BY title` clause instead of keeping it since we're selecting a single record with `LIMIT 1`. The amended query now correctly retrieves the most popular movie title from Walt Disney Pictures by properly navigating the company-movie relationship structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MAX(popularity) FROM movies WHERE studio = 'Walt Disney Pictures' GROUP BY title ORDER BY popularity DESC LIMIT 1;",
            "SELECT T3.title \nFROM production_company AS T1 \nJOIN movie_company AS T2 ON T1.company_id = T2.company_id \nJOIN movie AS T3 ON T2.movie_id = T3.movie_id \nWHERE T1.company_name = 'Walt Disney Pictures' \nORDER BY T3.popularity DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4510": {
        "db_id": "student_loan",
        "question": "List out students that enrolled in occ school and enlisted in a fire department.",
        "ground_truth": "SELECT T1.name FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T2.name = T1.name WHERE T2.school = 'occ' AND T1.organ = 'fire_department'",
        "amends": [
            "Do select `T1.name` instead of `*` from all columns. Do change the FROM source to `enlist AS T1` instead of `students` and add an `INNER JOIN` with `enrolled AS T2` on `T2.name = T1.name` instead of querying a single table. Do change the WHERE filter to `T2.school = 'occ'` instead of `school = 'occ'` and `T1.organ = 'fire_department'` instead of `department = 'fire'`. The amended query now correctly joins the enlist and enrolled tables to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE school = 'occ' AND department = 'fire';",
            "SELECT T1.name FROM enlist AS T1 INNER JOIN enrolled AS T2 ON T2.name = T1.name WHERE T2.school = 'occ' AND T1.organ = 'fire_department'"
        ],
        "rule_sql": []
    },
    "1056": {
        "db_id": "talkingdata",
        "question": "What is the percentage of female OPPO users against the male OPPO users?",
        "ground_truth": "SELECT SUM(IIF(T2.gender = 'F', 1, 0)) * 100 / COUNT(T2.device_id) AS perFemale , SUM(IIF(T2.gender = 'M', 1, 0)) * 100 / COUNT(T2.device_id) AS perMale FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'OPPO'",
        "amends": [
            "Do use `SUM(IIF(T2.gender = 'F', 1, 0)) * 100 / COUNT(T2.device_id)` and `SUM(IIF(T2.gender = 'M', 1, 0)) * 100 / COUNT(T2.device_id)` instead of `(COUNT(CASE WHEN gender = 'female' THEN 1 END) * 100.0 / COUNT(CASE WHEN gender = 'male' THEN 1 END))` for calculating separate percentages. Do join `phone_brand_device_model2 AS T1` with `gender_age AS T2` on `T2.device_id = T1.device_id` instead of querying only the `users` table. Do filter on `T1.phone_brand = 'OPPO'` instead of `brand = 'OPPO'`. Do return two separate percentage columns `perFemale` and `perMale` instead of a single ratio column. The amended query now correctly calculates individual gender percentages from the joined tables and matches RIGHT_SQL's behavior.",
            "Do use integer division with `100` instead of floating-point division with `100.0` in both percentage calculations. Do specify `INNER JOIN` explicitly instead of using the implicit `JOIN` syntax. Do remove the unnecessary newlines and formatting whitespace instead of keeping them, as these are purely cosmetic differences that do not affect query logic. The amended query now correctly calculates gender percentages using integer division while maintaining the same join logic and filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'female' THEN 1 END) * 100.0 / COUNT(CASE WHEN gender = 'male' THEN 1 END)) AS percentage_female_to_male\nFROM users\nWHERE brand = 'OPPO';",
            "SELECT \n    SUM(IIF(T2.gender = 'F', 1, 0)) * 100.0 / COUNT(T2.device_id) AS perFemale,\n    SUM(IIF(T2.gender = 'M', 1, 0)) * 100.0 / COUNT(T2.device_id) AS perMale\nFROM \n    phone_brand_device_model2 AS T1\nJOIN \n    gender_age AS T2 ON T2.device_id = T1.device_id\nWHERE \n    T1.phone_brand = 'OPPO'",
            "SELECT \n    SUM(IIF(T2.gender = 'F', 1, 0)) * 100 / COUNT(T2.device_id) AS perFemale,\n    SUM(IIF(T2.gender = 'M', 1, 0)) * 100 / COUNT(T2.device_id) AS perMale\nFROM phone_brand_device_model2 AS T1\nINNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id\nWHERE T1.phone_brand = 'OPPO'"
        ],
        "rule_sql": []
    },
    "3824": {
        "db_id": "public_review_platform",
        "question": "What are the attribute numbers that are related to payment?",
        "ground_truth": "SELECT attribute_id FROM Attributes WHERE attribute_name LIKE '%payment%'",
        "amends": [
            "Do select only `attribute_id` instead of all columns with `*`. Do use the correct table name `Attributes` instead of `attributes`. The amended query now correctly returns only attribute IDs from the Attributes table where the attribute name contains 'payment', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM attributes WHERE attribute_name LIKE '%payment%';",
            "SELECT attribute_id FROM Attributes WHERE attribute_name LIKE '%payment%';"
        ],
        "rule_sql": []
    },
    "3255": {
        "db_id": "donor",
        "question": "List the school districts that have bought resources from Barnes and Noble.",
        "ground_truth": "SELECT T2.school_district FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.vendor_name = 'Barnes and Noble'",
        "amends": [
            "Do select `T2.school_district` instead of `school_district` without table qualification. Do use `FROM resources AS T1 INNER JOIN projects AS T2` instead of `FROM purchases` as the source table. Do join on `T1.projectid = T2.projectid` instead of no join condition. Do filter on `T1.vendor_name = 'Barnes and Noble'` instead of `vendor = 'Barnes & Noble'` with corrected vendor name spelling. Do remove `DISTINCT` instead of keeping it since the join may naturally deduplicate. The amended query now correctly retrieves school districts from the projects table joined with resources rather than directly from a purchases table, using proper table relationships and vendor name matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT school_district FROM purchases WHERE vendor = 'Barnes & Noble';",
            "SELECT T2.school_district FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.vendor_name = 'Barnes and Noble'"
        ],
        "rule_sql": []
    },
    "597": {
        "db_id": "codebase_comments",
        "question": "Please give the url of the repository whose files are contained in solution ID 9?",
        "ground_truth": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 9",
        "amends": [
            "Do add table `Solution AS T2` with `INNER JOIN` on `T1.Id = T2.RepoId` instead of querying only the `repositories` table. Do change the source table to `Repo AS T1` instead of `repositories`. Do change the column reference to `T1.Url` instead of `url`. Do change the filter to `T2.Id = 9` instead of `solution_id = 9`, moving from a direct column filter to a join-based condition. The amended query now correctly joins the tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT url FROM repositories WHERE solution_id = 9;",
            "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 9"
        ],
        "rule_sql": []
    },
    "6958": {
        "db_id": "ice_hockey_draft",
        "question": "List out the name of players who weight 190 lbs.",
        "ground_truth": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T2.weight_in_lbs = 190",
        "amends": [
            "Do use `T1.PlayerName` instead of `name` for the column selection. Do add `PlayerInfo AS T1` and `weight_info AS T2` as joined tables instead of querying only the `players` table. Do use `INNER JOIN` with `ON T1.weight = T2.weight_id` instead of a simple WHERE filter. Do filter with `T2.weight_in_lbs = 190` instead of `weight = '190'` to properly reference the weight value from the joined table and use a numeric comparison instead of a string comparison. The amended query now correctly joins the player information with weight details and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE weight = '190'",
            "SELECT T1.PlayerName \nFROM PlayerInfo AS T1 \nINNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id \nWHERE T2.weight_in_lbs = 190"
        ],
        "rule_sql": []
    },
    "7362": {
        "db_id": "works_cycles",
        "question": "What is the 12th business's first line address?",
        "ground_truth": "SELECT T1.AddressLine1 FROM Address AS T1 INNER JOIN BusinessEntityAddress AS T2 ON T1.AddressID = T2.AddressID WHERE T2.BusinessEntityID = 12",
        "amends": [
            "Do select `AddressLine1` from the `Address` table instead of `address_line_2` from `businesses`. Do add an `INNER JOIN` with `BusinessEntityAddress` on `T1.AddressID = T2.AddressID` instead of no join. Do add a `WHERE` filter for `T2.BusinessEntityID = 12` instead of no filtering. Do remove the `ORDER BY business_id` clause instead of keeping it. Do remove the `LIMIT 1 OFFSET 11` pagination instead of including it. The amended query now correctly retrieves the specific address for business entity 12 instead of an arbitrary address from a different table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address_line_2 FROM businesses ORDER BY business_id LIMIT 1 OFFSET 11;",
            "SELECT AddressLine1 \nFROM Address \nINNER JOIN BusinessEntityAddress ON Address.AddressID = BusinessEntityAddress.AddressID \nWHERE BusinessEntityAddress.BusinessEntityID = 12"
        ],
        "rule_sql": []
    },
    "3436": {
        "db_id": "video_games",
        "question": "List the name of all games published in Japan.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN region_sales AS T4 ON T3.id = T4.game_platform_id INNER JOIN region AS T5 ON T4.region_id = T5.id WHERE T5.region_name = 'Japan'",
        "amends": [
            "Do select `T1.game_name` instead of `title` and use proper table aliases. Do add joins to `game_publisher`, `game_platform`, `region_sales`, and `region` tables instead of querying only the `games` table. Do use `INNER JOIN` on `T1.id = T2.game_id`, `T2.id = T3.game_publisher_id`, `T3.id = T4.game_platform_id`, and `T4.region_id = T5.id` instead of no joins. Do filter on `T5.region_name = 'Japan'` instead of `publisher = 'Japan'` to correctly identify Japanese region sales rather than publisher names. The amended query now properly joins through the relationship chain to filter by region name and returns the correct game names from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM games WHERE publisher = 'Japan';",
            "SELECT T1.game_name\nFROM game T1\nINNER JOIN game_publisher T2 ON T1.id = T2.game_id\nINNER JOIN game_platform T3 ON T2.id = T3.game_publisher_id\nINNER JOIN region_sales T4 ON T3.id = T4.game_platform_id\nINNER JOIN region T5 ON T4.region_id = T5.id\nWHERE T5.region_name = 'Japan'"
        ],
        "rule_sql": []
    },
    "2072": {
        "db_id": "music_tracker",
        "question": "Among the artists from 1980 to 1982. Which artist was tagged as \"disco\"?",
        "ground_truth": "SELECT T1.artist FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'disco' AND T1.groupYear BETWEEN 1980 AND 1982",
        "amends": [
            "Do select `artist` from `torrents` instead of `artist_name` from `artists`. Do join `tags` with `INNER JOIN` on `T1.id = T2.id` instead of querying a single table. Do filter on `T2.tag = 'disco'` in the WHERE clause instead of directly in the table condition. Do filter on `T1.groupYear BETWEEN 1980 AND 1982` instead of `year BETWEEN 1980 AND 1982`. The amended query now correctly joins the torrents and tags tables to filter by both disco tag and year range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT artist_name FROM artists WHERE year BETWEEN 1980 AND 1982 AND tag = 'disco';",
            "SELECT T1.artist \nFROM torrents T1\nINNER JOIN tags T2 ON T1.id = T2.id\nWHERE T2.tag = 'disco'\nAND T1.groupYear BETWEEN 1980 AND 1982"
        ],
        "rule_sql": []
    },
    "243": {
        "db_id": "retail_complains",
        "question": "Please list the full names of all the male clients born after the year 1990.",
        "ground_truth": "SELECT first, middle, last FROM client WHERE year > 1990",
        "amends": [
            "Do select columns `first`, `middle`, and `last` instead of `first_name` and `last_name`. Do use table name `client` instead of `clients`. Do filter on column `year` instead of `birth_year`. Do remove the `gender = 'female'` filter instead of keeping it. The amended query now correctly retrieves the specified columns from the client table for records with year values greater than 1990.",
            "Do remove the filter `sex = 'male'` instead of keeping it, as the right query only filters by `year > 1990` without any gender restriction. The amended query now matches the right SQL's behavior by returning all clients with birth year after 1990 regardless of gender."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE gender = 'female' AND birth_year > 1990;",
            "SELECT first, middle, last FROM client WHERE sex = 'male' AND year > 1990;",
            "SELECT first, middle, last FROM client WHERE year > 1990"
        ],
        "rule_sql": []
    },
    "6015": {
        "db_id": "books",
        "question": "Which books have the most expensive price?",
        "ground_truth": "SELECT T2.title FROM order_line AS T1 INNER JOIN book AS T2 ON T1.book_id = T2.book_id ORDER BY T1.price DESC LIMIT 1",
        "amends": [
            "Do select `T2.title` from specific columns instead of `*` selecting all columns. Do use `order_line AS T1` and `book AS T2` as joined table sources instead of just `books`. Do add `INNER JOIN` with `T1.book_id = T2.book_id` predicate instead of no join condition. Do order by `T1.price DESC` instead of `price ASC`. Do maintain `LIMIT 1` but with the corrected logic. The amended query now correctly identifies the highest-priced book from order records instead of finding the cheapest book from a general books table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM books ORDER BY price ASC LIMIT 1;",
            "SELECT T2.title\nFROM order_line AS T1\nINNER JOIN book AS T2 ON T1.book_id = T2.book_id\nORDER BY T1.price DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "487": {
        "db_id": "movies_4",
        "question": "What is the keyword ID of the movie with the title of \"Sin City\"?",
        "ground_truth": "SELECT T2.keyword_id FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id WHERE T1.title = 'Sin City'",
        "amends": [
            "Do query from `movie` table instead of `movies` table and add `INNER JOIN` with `movie_keywords` table on `T1.movie_id = T2.movie_id` instead of querying a single table. Do select `T2.keyword_id` instead of `movie_id` while maintaining the same `WHERE` filter on `T1.title = 'Sin City'. The amended query now correctly retrieves keyword IDs associated with the specified movie title by joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_id FROM movies WHERE title = 'Sin City';",
            "SELECT T2.keyword_id FROM movie T1 INNER JOIN movie_keywords T2 ON T1.movie_id = T2.movie_id WHERE T1.title = 'Sin City'"
        ],
        "rule_sql": []
    },
    "3389": {
        "db_id": "video_games",
        "question": "How many games can be played on the Wii platform?",
        "ground_truth": "SELECT COUNT(T1.id) FROM game_platform AS T1 INNER JOIN platform AS T2 ON T1.platform_id = T2.id WHERE T2.platform_name = 'Wii'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `game_platform AS T1` and `platform AS T2` instead of querying `games` table alone. Do use `INNER JOIN` with `T1.platform_id = T2.id` instead of filtering directly on platform column. Do filter on `T2.platform_name = 'Wii'` instead of `platform = 'PlayStation'` to correctly reference the platform name from the joined table. The amended query now properly counts games associated with the Wii platform through the correct table relationships.",
            "Do `COUNT(T1.id)` instead of `COUNT(DISTINCT T4.id)` to count platform-specific game instances rather than distinct games. Do remove the joins to `game_publisher AS T3` and `game AS T4` instead of including unnecessary table relationships. Do simplify the FROM clause to only include `game_platform AS T1` and `platform AS T2` instead of the additional joined tables. Do keep the WHERE filter on `T2.platform_name = 'Wii'` as it correctly identifies the target platform. The amended query now correctly counts Wii game platform instances rather than attempting to count distinct games through an overly complex join path."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE platform = 'PlayStation'",
            "SELECT COUNT(DISTINCT T4.id) \nFROM game_platform AS T1\nINNER JOIN platform AS T2 ON T1.platform_id = T2.id\nINNER JOIN game_publisher AS T3 ON T1.game_publisher_id = T3.id\nINNER JOIN game AS T4 ON T3.game_id = T4.id\nWHERE T2.platform_name = 'Wii'",
            "SELECT COUNT(T1.id) \nFROM game_platform AS T1 \nINNER JOIN platform AS T2 ON T1.platform_id = T2.id \nWHERE T2.platform_name = 'Wii'"
        ],
        "rule_sql": []
    },
    "7940": {
        "db_id": "music_platform_2",
        "question": "How many reviews does 'LifeAfter/The Message' have which were rated below 3?",
        "ground_truth": "SELECT COUNT(T2.rating) FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'LifeAfter/The Message' AND T2.rating <= 3",
        "amends": [
            "Do join `podcasts AS T1` and `reviews AS T2` with `INNER JOIN` on `T2.podcast_id = T1.podcast_id` instead of querying only the `reviews` table without any join. Do filter on `T1.title = 'LifeAfter/The Message'` instead of filtering directly on `app_name` in the reviews table. Do count `T2.rating` instead of counting all rows with `COUNT(*)`. Do use the condition `T2.rating <= 3` instead of `rating >= 3` to count ratings that are 3 or below rather than 3 or above. The amended query now correctly counts podcast reviews by joining to the podcasts table and using the appropriate rating threshold, matching the RIGHT_SQL's behavior.",
            "Do use `<= 3` instead of `< 3` in the WHERE filter for the rating condition, which changes the comparison from strictly less than to less than or equal to, thereby including reviews with a rating of exactly 3 instead of excluding them."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE app_name = 'LifeAfter/The Message' AND rating >= 3;",
            "SELECT COUNT(T2.rating) \nFROM podcasts AS T1 \nINNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id \nWHERE T1.title = 'LifeAfter/The Message' \nAND T2.rating < 3",
            "SELECT COUNT(T2.rating) \nFROM podcasts AS T1 \nINNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id \nWHERE T1.title = 'LifeAfter/The Message' AND T2.rating <= 3"
        ],
        "rule_sql": []
    },
    "756": {
        "db_id": "movie",
        "question": "Who played the No.1 character in the credit list of the movie which was released on \"2015/10/26\"?",
        "ground_truth": "SELECT T3.Name FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T1.`Release Date` = '2015-10-26' AND T2.creditOrder = '1'",
        "amends": [
            "Do select `T3.Name` from the `actor` table instead of `actor_name` from the `credits` table. Do join `movie AS T1` and `characters AS T2` with `INNER JOIN` on `T1.MovieID = T2.MovieID` instead of querying a single `credits` table. Do add another `INNER JOIN` to `actor AS T3` on `T3.ActorID = T2.ActorID` instead of omitting this table relationship. Do filter on `T1.Release Date = '2015-10-26'` with proper date format instead of `release_date = '2015/10/26'`. Do use `T2.creditOrder = '1'` instead of `character_number = 1` for the credit position filter. The amended query now correctly joins the three related tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM credits WHERE release_date = '2015/10/26' AND character_number = 1;",
            "SELECT T3.Name \nFROM movie AS T1\nINNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID\nINNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID\nWHERE T1.\"Release Date\" = '2015-10-26' \nAND T2.creditOrder = 1"
        ],
        "rule_sql": []
    },
    "6116": {
        "db_id": "food_inspection_2",
        "question": "Among the facilities that have undergone at least one inspection in 2010, how many of them are in ward no.42?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.ward = 42",
        "amends": [
            "Do `COUNT(DISTINCT T1.license_no)` instead of `COUNT(*)` to count unique licenses rather than all inspection records. Do `INNER JOIN establishment AS T2` instead of `JOIN facilities f` to use the correct table name and alias. Do `ON T1.license_no = T2.license_no` instead of `ON f.facility_id = i.facility_id` to join on license numbers rather than facility IDs. Do `strftime('%Y', T1.inspection_date) = '2010'` instead of `i.inspection_date LIKE '2010%'` for proper year extraction from dates. Do `T2.ward = 42` instead of `f.ward_no = 42` to use the correct column name for ward filtering. The amended query now correctly counts distinct licenses from establishments in ward 42 with inspections in 2010."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM facilities f\nJOIN inspections i ON f.facility_id = i.facility_id\nWHERE i.inspection_date LIKE '2010%' AND f.ward_no = 42;",
            "SELECT COUNT(DISTINCT T1.license_no) \nFROM inspection AS T1\nINNER JOIN establishment AS T2 ON T1.license_no = T2.license_no\nWHERE strftime('%Y', T1.inspection_date) = '2010'\nAND T2.ward = 42"
        ],
        "rule_sql": []
    },
    "4760": {
        "db_id": "legislator",
        "question": "How many male legislators are Roman Catholic?",
        "ground_truth": "SELECT COUNT(*) FROM current WHERE religion_bio = 'Roman Catholic' AND gender_bio = 'M'",
        "amends": [
            "Do reference table `current` instead of `legislators` in the FROM clause. Do use column `religion_bio` with value 'Roman Catholic' instead of `religion` with value 'Catholic' in the WHERE filter. Do use column `gender_bio` with value 'M' instead of `gender` with value 'male' in the WHERE filter. The amended query now correctly counts legislators from the current table with Roman Catholic religion and male gender as specified in the target query."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE gender = 'male' AND religion = 'Catholic';",
            "SELECT COUNT(*) FROM current WHERE religion_bio = 'Roman Catholic' AND gender_bio = 'M';"
        ],
        "rule_sql": []
    },
    "6025": {
        "db_id": "books",
        "question": "Indicate the last number of each street.",
        "ground_truth": "SELECT street_number FROM address",
        "amends": [
            "Do select `street_number` instead of selecting `street` and `MAX(house_number)`. Do query from `address` instead of querying from `addresses`. Do remove the `GROUP BY street` clause instead of keeping it. The amended query now correctly retrieves individual street numbers from the address table rather than attempting to find maximum house numbers grouped by street."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street, MAX(house_number) FROM addresses GROUP BY street;",
            "SELECT street_number FROM address;"
        ],
        "rule_sql": []
    },
    "1977": {
        "db_id": "soccer_2016",
        "question": "Which bowling skills did the players from Zimbabwea have?",
        "ground_truth": "SELECT T1.Bowling_skill FROM Bowling_Style AS T1 INNER JOIN Player AS T2 ON T1.Bowling_Id = T2.Bowling_skill INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE T3.Country_Name = 'Zimbabwea'",
        "amends": [
            "Do select `T1.Bowling_skill` instead of `bowling_style`. Do join `Bowling_Style AS T1` instead of omitting it. Do join `Player AS T2` instead of omitting it. Do join `Country AS T3` instead of omitting it. Do use `INNER JOIN` on `T1.Bowling_Id = T2.Bowling_skill` instead of no join condition. Do use `INNER JOIN` on `T2.Country_Name = T3.Country_Id` instead of no join condition. Do filter on `T3.Country_Name = 'Zimbabwea'` instead of `country = 'Zimbabwea'`. The amended query now correctly joins the necessary tables to retrieve bowling skills for Zimbabwean players."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bowling_style FROM players WHERE country = 'Zimbabwea';",
            "SELECT DISTINCT T1.Bowling_skill \nFROM Bowling_Style AS T1\nINNER JOIN Player AS T2 ON T1.Bowling_Id = T2.Bowling_skill\nINNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id\nWHERE T3.Country_Name = 'Zimbabwea'"
        ],
        "rule_sql": []
    },
    "2376": {
        "db_id": "superstore",
        "question": "Which customer ordered 'Global High-Back Leather Tilter, Burgundy' on 10/13/2013 in the East region?",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T3.`Product Name` = 'Global High-Back Leather Tilter, Burgundy' AND T1.`Order Date` = '2013-10-13' AND T1.Region = 'East'",
        "amends": [
            "Do use `DISTINCT` on `Customer Name` instead of omitting it to remove duplicate customer records. Do reference `east_superstore` as the primary table instead of `customers` and `orders` separately. Do join `people` on `Customer ID` instead of joining `customers` directly. Do join `product` on `Product ID` instead of joining `products` through `order_items`. Do filter on `Region` from `east_superstore` instead of from a `customers` table. Do use backtick-quoted column names like `Customer Name`, `Customer ID`, `Product Name`, and `Product ID` instead of unquoted snake_case names. The amended query now correctly identifies distinct customers from the East region who purchased the specified product on the given date using the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.customer_name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN order_items oi ON o.order_id = oi.order_id\nJOIN products p ON oi.product_id = p.product_id\nWHERE p.product_name = 'Global High-Back Leather Tilter, Burgundy'\nAND o.order_date = '2013-10-13'\nAND c.region = 'East';",
            "SELECT DISTINCT p.\"Customer Name\"\nFROM east_superstore es\nJOIN people p ON es.\"Customer ID\" = p.\"Customer ID\" AND es.Region = p.Region\nJOIN product pr ON es.\"Product ID\" = pr.\"Product ID\" AND es.Region = pr.Region\nWHERE pr.\"Product Name\" = 'Global High-Back Leather Tilter, Burgundy'\nAND es.\"Order Date\" = '2013-10-13'\nAND es.Region = 'East';"
        ],
        "rule_sql": []
    },
    "7514": {
        "db_id": "image_and_language",
        "question": "What is the bounding box of the object with image id 4 and a prediction relationship class id of 144?",
        "ground_truth": "SELECT T2.X, T2.Y, T2.W, T2.H FROM IMG_REL AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.IMG_ID = T2.IMG_ID WHERE T1.PRED_CLASS_ID = 144 AND T1.IMG_ID = 3",
        "amends": [
            "Do select specific columns `T2.X`, `T2.Y`, `T2.W`, `T2.H` instead of using aggregate functions `MIN(x)`, `MIN(y)`, `MAX(x + width)`, `MAX(y + height)`. Do join table `IMG_REL AS T1` with `IMG_OBJ AS T2` using `INNER JOIN` on `T1.IMG_ID = T2.IMG_ID` instead of querying only the `objects` table. Do filter by `T1.PRED_CLASS_ID = 144` instead of `relationship_class_id = 144` and use `T1.IMG_ID = 3` instead of `image_id = 4`. The amended query now correctly retrieves specific coordinate values from joined tables rather than calculating aggregates from a single table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(x), MIN(y), MAX(x + width), MAX(y + height) FROM objects WHERE image_id = 4 AND relationship_class_id = 144;",
            "SELECT T2.X, T2.Y, T2.W, T2.H\nFROM IMG_REL AS T1\nINNER JOIN IMG_OBJ AS T2 ON T1.IMG_ID = T2.IMG_ID\nWHERE T1.PRED_CLASS_ID = 144 AND T1.IMG_ID = 3"
        ],
        "rule_sql": []
    },
    "507": {
        "db_id": "movies_4",
        "question": "Write down the release date of the movies produced by Twentieth Century Fox Film Corporation.",
        "ground_truth": "SELECT T3.release_date FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Twentieth Century Fox Film Corporation'",
        "amends": [
            "Do join `production_company AS T1` and `movie_company AS T2` on `T1.company_id = T2.company_id` instead of querying `movies` directly. Do join `movie AS T3` on `T2.movie_id = T3.movie_id` instead of omitting the necessary table relationships. Do filter on `T1.company_name` instead of `producer` to correctly reference the company name field. Do select `T3.release_date` with proper table qualification instead of just `release_date` from an incorrect table source. The amended query now correctly navigates the relational schema to find movies by production company name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_date FROM movies WHERE producer = 'Twentieth Century Fox Film Corporation';",
            "SELECT T3.release_date\nFROM production_company AS T1\nJOIN movie_company AS T2 ON T1.company_id = T2.company_id\nJOIN movie AS T3 ON T2.movie_id = T3.movie_id\nWHERE T1.company_name = 'Twentieth Century Fox Film Corporation'"
        ],
        "rule_sql": []
    },
    "2270": {
        "db_id": "movielens",
        "question": "Movies with rating 3 are viewed by audiences in which distinct age group?",
        "ground_truth": "SELECT DISTINCT T2.age FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 3",
        "amends": [
            "Do use `T2.age` instead of `age_group` in the SELECT list. Do add `u2base AS T1` and `users AS T2` as FROM sources instead of just `movies`. Do implement `INNER JOIN` on `T1.userid = T2.userid` instead of no join condition. Do change the WHERE filter to `T1.rating = 3` instead of `rating = 3` to reference the correct table. The amended query now correctly retrieves distinct user ages from the joined tables based on ratings."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT age_group FROM movies WHERE rating = 3;",
            "SELECT DISTINCT T2.age\nFROM u2base AS T1\nINNER JOIN users AS T2 ON T1.userid = T2.userid\nWHERE T1.rating = '3';"
        ],
        "rule_sql": []
    },
    "5690": {
        "db_id": "language_corpus",
        "question": "List the page id of wikipedia about Catalan language which have the appearance of the word 'decimal'?",
        "ground_truth": "SELECT T2.pid FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE T1.word = 'decimal'",
        "amends": [
            "Do select `T2.pid` from the `pages_words` table instead of `page_id` from the `wikipedia` table. Do join `words AS T1` and `pages_words AS T2` with an `INNER JOIN` on `T1.wid = T2.wid` instead of querying a single `wikipedia` table. Do filter on `T1.word = 'decimal'` instead of using `title = 'Catalan language'` and `content LIKE '%decimal%'` conditions. The amended query now correctly matches the RIGHT_SQL's behavior by properly joining the words and pages_words tables to find pages containing the specific word 'decimal'."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_id FROM wikipedia WHERE title = 'Catalan language' AND content LIKE '%decimal%';",
            "SELECT T2.pid \nFROM words AS T1 \nINNER JOIN pages_words AS T2 ON T1.wid = T2.wid \nWHERE T1.word = 'decimal'"
        ],
        "rule_sql": []
    },
    "6196": {
        "db_id": "food_inspection_2",
        "question": "List down the phone numbers of employees who did Canvass inspection.",
        "ground_truth": "SELECT DISTINCT T1.phone FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_type = 'Canvass'",
        "amends": [
            "Do select `DISTINCT T1.phone` instead of `phone_number` from a single table. Do add `INNER JOIN inspection AS T2` instead of querying only the employees table. Do use join condition `ON T1.employee_id = T2.employee_id` instead of no join. Do apply filter on `T2.inspection_type = 'Canvass'` instead of filtering on a non-existent column in the employees table. The amended query now correctly joins tables and filters on the inspection table to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM employees WHERE inspection_type = 'Canvass'",
            "SELECT DISTINCT T1.phone\nFROM employee AS T1\nINNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nWHERE T2.inspection_type = 'Canvass'"
        ],
        "rule_sql": []
    },
    "3457": {
        "db_id": "video_games",
        "question": "Indicate the release year of the game with more than 200000 sales in Japan.",
        "ground_truth": "SELECT DISTINCT T3.release_year FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id WHERE T2.num_sales * 100000 > 200000 AND T1.region_name = 'Japan'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the source from `games` to a join between `region`, `region_sales`, and `game_platform` instead of a single table. Do use `INNER JOIN` on `region.id = region_sales.region_id` and `region_sales.game_platform_id = game_platform.id` instead of no joins. Do change the filter to `region_sales.num_sales * 100000 > 200000` instead of `sales_japan > 200000`. Do add condition `region.region_name = 'Japan'` instead of omitting it. Do reference `T3.release_year` instead of just `release_year`. The amended query now correctly calculates sales in proper units and filters for Japan region specifically."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_year FROM games WHERE sales_japan > 200000;",
            "SELECT DISTINCT gp.release_year\nFROM region r\nINNER JOIN region_sales rs ON r.id = rs.region_id\nINNER JOIN game_platform gp ON rs.game_platform_id = gp.id\nWHERE r.region_name = 'Japan' AND rs.num_sales * 100000 > 200000;"
        ],
        "rule_sql": []
    },
    "4310": {
        "db_id": "simpson_episodes",
        "question": "How many title's crew members are working from Casting Department?",
        "ground_truth": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.category = 'Casting Department';",
        "amends": [
            "Do use `Episode` and `Credit` tables with an `INNER JOIN` on `episode_id` instead of querying only the `title_crew` table. Do filter on `category = 'Casting Department'` in the `WHERE` clause instead of filtering on `department = 'Casting Department'`. The amended query now correctly counts credits in the casting department by joining episode and credit tables with proper relationship semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM title_crew WHERE department = 'Casting Department';",
            "SELECT COUNT(*) \nFROM Episode e\nINNER JOIN Credit c ON e.episode_id = c.episode_id\nWHERE c.category = 'Casting Department'"
        ],
        "rule_sql": []
    },
    "8897": {
        "db_id": "cookbook",
        "question": "List all the ingredients for Strawberry Sorbet.",
        "ground_truth": "SELECT T3.name FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T1.title = 'Strawberry Sorbet'",
        "amends": [
            "Do select `T3.name` instead of `*` to retrieve only ingredient names rather than all columns. Do use `Recipe AS T1` joined with `Quantity AS T2` on `T1.recipe_id = T2.recipe_id` instead of querying `ingredients` directly, establishing proper table relationships. Do add `INNER JOIN Ingredient AS T3` on `T3.ingredient_id = T2.ingredient_id` instead of omitting the ingredient table join, connecting to the actual ingredient data. Do filter on `T1.title = 'Strawberry Sorbet'` instead of `recipe_name = 'Strawberry Sorbet'` to use the correct column name from the Recipe table. The amended query now correctly joins the three related tables to retrieve ingredient names for the specified recipe, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM ingredients WHERE recipe_name = 'Strawberry Sorbet';",
            "SELECT T3.name \nFROM Recipe AS T1\nINNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id\nINNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id\nWHERE T1.title = 'Strawberry Sorbet'"
        ],
        "rule_sql": []
    },
    "247": {
        "db_id": "retail_complains",
        "question": "For how long was the complaint filed by Matthew Pierce on 2016/10/28 delayed?",
        "ground_truth": "SELECT 365 * (strftime('%Y', T2.`Date sent to company`) - strftime('%Y', T2.`Date received`)) + 30 * (strftime('%M', T2.`Date sent to company`) - strftime('%M', T2.`Date received`)) + (strftime('%d', T2.`Date sent to company`) - strftime('%d', T2.`Date received`)) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Matthew' AND T1.last = 'Pierce' AND T2.`Date received` = '2016-10-28'",
        "amends": [
            "Do calculate date difference using `strftime` year/month/day components instead of `DATEDIFF` function. Do join `client` table with `events` table using `INNER JOIN` on `client_id = Client_ID` instead of querying a single `complaints` table. Do filter by `first = 'Matthew'` and `last = 'Pierce'` instead of `complainant_name = 'Matthew Pierce'`. Do use date format `'2016-10-28'` with hyphens instead of `'2016/10/28'` with slashes. Do reference columns `Date sent to company` and `Date received` instead of `closed_date` and `filed_date`. The amended query now correctly calculates date difference across year boundaries and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DATEDIFF(closed_date, filed_date) AS delay_days FROM complaints WHERE complainant_name = 'Matthew Pierce' AND filed_date = '2016/10/28';",
            "SELECT \n    (strftime('%s', \"Date sent to company\") - strftime('%s', \"Date received\")) / (24 * 60 * 60) AS delay_days\nFROM \n    events e\nINNER JOIN \n    client c ON e.Client_ID = c.client_id\nWHERE \n    c.first = 'Matthew' \n    AND c.last = 'Pierce' \n    AND e.\"Date received\" = '2016-10-28'"
        ],
        "rule_sql": []
    },
    "4565": {
        "db_id": "student_loan",
        "question": "How many bankrupt students are there in the Marines?",
        "ground_truth": "SELECT COUNT(T1.name) FROM filed_for_bankrupcy AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE T2.organ = 'marines'",
        "amends": [
            "Do use `COUNT(T1.name)` instead of `COUNT(*)` to count specific non-null values. Do join `filed_for_bankrupcy AS T1` and `enlist AS T2` with an `INNER JOIN` on `T1.name = T2.name` instead of querying a single `students` table. Do filter on `T2.organ = 'marines'` instead of `branch = 'Marines' AND status = 'bankrupt'` to correctly identify marines who filed for bankruptcy through the joined tables. The amended query now correctly matches the intended behavior by counting bankrupt individuals from the marines branch through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE branch = 'Marines' AND status = 'bankrupt';",
            "SELECT COUNT(T1.name) \nFROM filed_for_bankrupcy AS T1\nINNER JOIN enlist AS T2 ON T1.name = T2.name\nWHERE T2.organ = 'marines'"
        ],
        "rule_sql": []
    },
    "4558": {
        "db_id": "student_loan",
        "question": "How many students have absences of no more than 3 months?",
        "ground_truth": "SELECT COUNT(name) FROM longest_absense_from_school WHERE month < 3",
        "amends": [
            "Do select `COUNT(name)` instead of `COUNT(*)` to count non-null names rather than all rows. Do use table `longest_absense_from_school` instead of `students` to query from the correct data source. Do filter on `month < 3` instead of `absences <= 3` to properly identify records from the first two months rather than those with few absences. The amended query now correctly counts students with recorded names from the specified early months, matching the intended behavior.",
            "Do use `<` comparison operator for `month < 3` instead of `<=` comparison operator for `month <= 3` in the WHERE filter, which excludes the month value of 3 instead of including it, ensuring only months strictly less than 3 are counted. The amended query now matches RIGHT_SQL's behavior by correctly filtering for months before month 3."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE absences <= 3;",
            "SELECT COUNT(name) FROM longest_absense_from_school WHERE month <= 3;",
            "SELECT COUNT(name) FROM longest_absense_from_school WHERE month < 3"
        ],
        "rule_sql": []
    },
    "4890": {
        "db_id": "legislator",
        "question": "Among the current legislators who have accounts on both http://thomas.gov, how many of them have accounts on instagram?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.bioguide_id) FROM current AS T1 INNER JOIN `social-media` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.thomas_id IS NOT NULL AND T2.instagram IS NOT NULL",
        "amends": [
            "Do use `COUNT(DISTINCT T1.bioguide_id)` instead of `COUNT(*)` to count unique legislators. Do change the FROM clause to `current AS T1 INNER JOIN social-media AS T2` instead of a single `legislators` table. Do use the join condition `ON T1.bioguide_id = T2.bioguide` instead of no join. Do change the WHERE filters to `T1.thomas_id IS NOT NULL` instead of `thomas_gov_account IS NOT NULL` and `T2.instagram IS NOT NULL` instead of `instagram_account IS NOT NULL`. The amended query now correctly joins the current legislators table with social media data and counts distinct bioguide IDs while filtering on the appropriate null checks, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators \nWHERE thomas_gov_account IS NOT NULL \nAND instagram_account IS NOT NULL;",
            "SELECT COUNT(DISTINCT T1.bioguide_id) \nFROM current AS T1 \nINNER JOIN \"social-media\" AS T2 ON T1.bioguide_id = T2.bioguide \nWHERE T1.thomas_id IS NOT NULL AND T2.instagram IS NOT NULL"
        ],
        "rule_sql": []
    },
    "5382": {
        "db_id": "sales",
        "question": "List down all of the sales IDs for sales handled by sales people with first name starting with alphabet \"s\".",
        "ground_truth": "SELECT T1.SalesID FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE SUBSTR(T2.FirstName, 1, 1) = 's'",
        "amends": [
            "Do use `T1.SalesID` instead of `sales_id` and join `Employees AS T2` instead of querying the sales table directly. Do perform an `INNER JOIN` on `T1.SalesPersonID = T2.EmployeeID` instead of filtering by salesperson_first_name directly. Do use `SUBSTR(T2.FirstName, 1, 1) = 's'` instead of `LIKE 's%'` to properly filter employees whose first name starts with 's'. The amended query now correctly joins the sales and employees tables to filter by employee first name instead of incorrectly assuming the sales table contains first name information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sales_id FROM sales WHERE salesperson_first_name LIKE 's%';",
            "SELECT T1.SalesID \nFROM Sales AS T1\nINNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID\nWHERE SUBSTR(T2.FirstName, 1, 1) = 's'"
        ],
        "rule_sql": []
    },
    "7945": {
        "db_id": "music_platform_2",
        "question": "Calculate the percentage of podcasts in the fiction-science-fiction category.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(podcast_id) OR '%' \"percentage\" FROM categories",
        "amends": [
            "Do use `SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to properly count only fiction-science-fiction records. Do calculate percentage as `CAST(... AS REAL) * 100 / COUNT(podcast_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) ...)` to avoid the subquery and use proper division with casting. Do query from `categories` table instead of `podcasts` table to access the correct data source. Do add `OR '%'` to format the result as a percentage string instead of omitting it. Do use `podcast_id` in the denominator count instead of counting all rows to ensure accurate percentage calculation. The amended query now correctly calculates the percentage of fiction-science-fiction podcasts from the categories table.",
            "Do use `OR '%'` instead of `|| '%'` for string concatenation in the percentage calculation. Do use double quotes for the alias `\"percentage\"` instead of `AS percentage` for proper identifier quoting. The amended query now correctly handles string concatenation and alias formatting to match the RIGHT_SQL's behavior.",
            "Do use the string concatenation operator `||` instead of the logical OR operator `OR` for appending the percentage sign. Do maintain the `CAST` function and aggregation logic unchanged instead of altering them. Do preserve the column alias `percentage` with double quotes instead of modifying it. Do keep the table source `FROM categories` unchanged instead of altering the data source. The amended query now correctly concatenates the percentage calculation with the '%' symbol using proper string operations instead of incorrect logical operations.",
            "Do use the concatenation operator `||` instead of the logical OR operator `OR` for string concatenation. Do maintain the `CAST` function and aggregate calculations exactly as they were, preserving the percentage calculation logic. Do keep the column alias `percentage` with double quotes and the FROM clause referencing the `categories` table without any changes to the table source or filters.",
            "Do use the `||` string concatenation operator instead of the `OR` logical operator for appending the percentage sign, as `||` correctly concatenates the numeric result with the '%' string literal to form the final percentage output, while `OR` would incorrectly perform logical comparison between the numeric value and the string. The amended query now correctly calculates and formats the percentage of science fiction podcasts using proper string concatenation syntax."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM podcasts WHERE category = 'fiction-science-fiction')) AS percentage\nFROM podcasts;",
            "SELECT \n    CAST(SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(podcast_id) || '%' AS percentage\nFROM \n    categories;",
            "SELECT CAST(SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(podcast_id) || '%' AS \"percentage\" FROM categories;",
            "SELECT CAST(SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(podcast_id) || '%' AS \"percentage\" FROM categories;",
            "SELECT CAST(SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(podcast_id) || '%' AS \"percentage\" FROM categories",
            "SELECT CAST(SUM(CASE WHEN category = 'fiction-science-fiction' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(podcast_id) || '%' AS \"percentage\" FROM categories"
        ],
        "rule_sql": []
    },
    "7726": {
        "db_id": "hockey",
        "question": "Which country produced the most number of hockey players? Identify which year was most of the hockey players are born.",
        "ground_truth": "SELECT DISTINCT birthCountry, birthYear FROM Master GROUP BY birthCountry, birthYear ORDER BY COUNT(birthCountry) DESC LIMIT 1",
        "amends": [
            "Do select `birthCountry` and `birthYear` instead of `country` and `YEAR(birth_date)` as `birth_year`. Do use `DISTINCT` with `birthCountry` and `birthYear` instead of omitting it. Do group by both `birthCountry` and `birthYear` instead of only `country`. Do order by `COUNT(birthCountry)` instead of `player_count`. Do query from `Master` table instead of `hockey_players`. The amended query now correctly identifies the most common birth country and year combination rather than just the country with the most players.",
            "Do remove the `COUNT(*) as player_count` column and `WHERE birthCountry IS NOT NULL AND birthYear IS NOT NULL` filter instead of including them. Do change the `SELECT` list to `DISTINCT birthCountry, birthYear` instead of aggregating with count. Do modify the `ORDER BY` clause to use `COUNT(birthCountry) DESC` instead of ordering by the removed `player_count` alias. The amended query now correctly returns distinct country-year combinations ordered by frequency rather than counting occurrences with additional filtering.",
            "Do add `DISTINCT` to the SELECT list instead of omitting it, and do change the ORDER BY expression to `COUNT(birthCountry)` instead of `COUNT(*)` to ensure accurate counting of distinct country-year combinations rather than all rows. The amended query now correctly identifies the most frequent birth country and year combination by counting distinct groupings rather than total rows, matching the RIGHT_SQL's behavior.",
            "Do add `GROUP BY birthCountry, birthYear` instead of omitting it, as the ORDER BY clause references an aggregate function COUNT that requires grouping. Do keep `DISTINCT` and maintain the same SELECT list columns `birthCountry, birthYear` instead of changing them. Do preserve the FROM source `Master` and maintain the ORDER BY `COUNT(birthCountry) DESC` with LIMIT 1 instead of altering them. The amended query now correctly groups by both columns before applying the aggregate function in the ORDER BY clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as player_count, YEAR(birth_date) as birth_year\nFROM hockey_players\nGROUP BY country\nORDER BY player_count DESC\nLIMIT 1;",
            "SELECT birthCountry, birthYear, COUNT(*) as player_count\nFROM Master\nWHERE birthCountry IS NOT NULL AND birthYear IS NOT NULL\nGROUP BY birthCountry, birthYear\nORDER BY player_count DESC\nLIMIT 1;",
            "SELECT birthCountry, birthYear\nFROM Master\nGROUP BY birthCountry, birthYear\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT DISTINCT birthCountry, birthYear FROM Master ORDER BY COUNT(birthCountry) DESC LIMIT 1;",
            "SELECT DISTINCT birthCountry, birthYear FROM Master GROUP BY birthCountry, birthYear ORDER BY COUNT(birthCountry) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8844": {
        "db_id": "food_inspection",
        "question": "Among the businesses within the postal code 94117, what is total number of businesses with a high risk category?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.business_id) FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.postal_code = 94117 AND T1.risk_category = 'High Risk'",
        "amends": [
            "Do `COUNT(DISTINCT T2.business_id)` instead of `COUNT(*)` to count unique business IDs rather than all rows. Do join `violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id` instead of querying only the `businesses` table to incorporate violation data. Do filter on `T2.postal_code = 94117` instead of `postal_code = '94117'` to use numeric comparison without quotes. Do filter on `T1.risk_category = 'High Risk'` instead of `risk_category = 'Low Risk'` to target high-risk violations from the violations table rather than low-risk businesses. The amended query now correctly counts distinct businesses with high-risk violations in the specified postal code area."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE postal_code = '94117' AND risk_category = 'Low Risk';",
            "SELECT COUNT(DISTINCT T2.business_id) \nFROM violations AS T1 \nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id \nWHERE T2.postal_code = 94117 \nAND T1.risk_category = 'High Risk'"
        ],
        "rule_sql": []
    },
    "1972": {
        "db_id": "soccer_2016",
        "question": "How many matches did Mohammad Hafeez play?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Player_Name = 'Mohammad Hafeez' THEN 1 ELSE 0 END) FROM Player_Match AS T1 INNER JOIN Player AS T2 ON T1.Player_Id = T2.Player_Id",
        "amends": [
            "Do join `Player_Match` with `Player` on `T1.Player_Id = T2.Player_Id` instead of querying `matches` table alone. Do reference `T2.Player_Name` instead of `player_name` for filtering. Do use `SUM(CASE WHEN T2.Player_Name = 'Mohammad Hafeez' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific player matches. Do add the `INNER JOIN` condition instead of omitting the table relationship. The amended query now correctly counts matches for the specified player by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE player_name = 'Mohammad Hafeez';",
            "SELECT SUM(CASE WHEN p.Player_Name = 'Mohammad Hafeez' THEN 1 ELSE 0 END) AS matches_played\nFROM Player_Match pm\nINNER JOIN Player p ON pm.Player_Id = p.Player_Id\nWHERE p.Player_Name = 'Mohammad Hafeez'"
        ],
        "rule_sql": []
    },
    "8235": {
        "db_id": "mondial_geo",
        "question": "Which country has the highest infant mortality? Also state its population growth.",
        "ground_truth": "SELECT T1.Name, T2.Population_Growth FROM country AS T1 INNER JOIN population AS T2 ON T1.Code = T2.Country ORDER BY T2.Infant_Mortality DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` and `T2.Population_Growth` instead of `country`, `infant_mortality`, and `population_growth`. Do use `FROM country AS T1 INNER JOIN population AS T2` instead of `FROM countries` alone. Do join on `T1.Code = T2.Country` instead of no join condition. Do add `ORDER BY T2.Infant_Mortality DESC LIMIT 1` instead of using a subquery with `WHERE infant_mortality = (SELECT MIN(infant_mortality) FROM countries)`. Do remove the subquery entirely instead of keeping it. The amended query now correctly joins the country and population tables and finds the country with the highest infant mortality rate instead of those with the minimum rate, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, infant_mortality, population_growth \nFROM countries \nWHERE infant_mortality = (SELECT MIN(infant_mortality) FROM countries);",
            "SELECT T1.Name, T2.Population_Growth \nFROM country AS T1 \nINNER JOIN population AS T2 ON T1.Code = T2.Country \nORDER BY T2.Infant_Mortality DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3005": {
        "db_id": "shakespeare",
        "question": "What is the description of the chapter where the character whose abrreviated name is 1Play appeared first?",
        "ground_truth": "SELECT T2.Description FROM paragraphs AS T1 INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id INNER JOIN characters AS T3 ON T1.character_id = T3.id WHERE T3.Abbrev = '1Play' ORDER BY T1.chapter_id LIMIT 1",
        "amends": [
            "Do select `T2.Description` from the `chapters` table instead of `c.description` from the `chapters` table. Do join `paragraphs AS T1` instead of omitting it, and use `INNER JOIN` with `T1.chapter_id = T2.id` instead of directly joining `chapters` to `characters`. Do change the join condition to `INNER JOIN characters AS T3 ON T1.character_id = T3.id` instead of `JOIN characters ch ON c.chapter_id = ch.first_appearance`. Do filter on `T3.Abbrev = '1Play'` instead of `ch.abbreviated_name = '1Play'`. Do add `ORDER BY T1.chapter_id` instead of omitting ordering. The amended query now correctly retrieves chapter descriptions based on paragraph-character relationships rather than incorrect direct chapter-character joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.description FROM chapters c JOIN characters ch ON c.chapter_id = ch.first_appearance WHERE ch.abbreviated_name = '1Play' LIMIT 1;",
            "SELECT T2.Description \nFROM paragraphs AS T1 \nINNER JOIN chapters AS T2 ON T1.chapter_id = T2.id \nINNER JOIN characters AS T3 ON T1.character_id = T3.id \nWHERE T3.Abbrev = '1Play' \nORDER BY T1.chapter_id \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "262": {
        "db_id": "retail_complains",
        "question": "Did Ms. Lyric Emely Taylor provide the consent for result of the complaint call on 2016/5/20?",
        "ground_truth": "SELECT CASE WHEN T2.`Consumer consent provided?` IN (NULL, 'N/A', '') THEN 'No' ELSE 'Yes' END FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Lyric' AND T1.middle = 'Emely' AND T1.last = 'Taylor' AND T1.sex = 'Female' AND T2.`Date received` = '2016-05-20'",
        "amends": [
            "Do select a CASE expression evaluating `Consumer consent provided?` with NULL/N/A/empty handling instead of selecting all columns with a simple `consent` check. Do use `client` and `events` tables with an `INNER JOIN` on `client_id` instead of querying only a `complaints` table. Do filter on separate `first`, `middle`, `last`, and `sex` columns instead of a single `name` field. Do use `Date received` with ISO format '2016-05-20' instead of '2016/5/20'. Do add explicit table aliases `T1` and `T2` instead of no aliases. The amended query now correctly handles consent logic and joins client data with events while maintaining proper date format and name matching.",
            "Do use `IN (NULL, 'N/A', '')` for the consent check instead of `IS NULL OR = '' OR = 'N/A'`. Do return 'Yes' for the ELSE case instead of the original column value. Do change the sex filter to `'Female'` instead of `'Ms.'`. Do remove the alias `consent_status` instead of keeping it. The amended query now correctly handles consent status with proper boolean logic and fixes the gender filter to match the intended criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM complaints WHERE name = 'Ms. Lyric Emely Taylor' AND date = '2016/5/20' AND consent = 'yes';",
            "SELECT \n    CASE \n        WHEN T2.\"Consumer consent provided?\" IS NULL OR T2.\"Consumer consent provided?\" = '' OR T2.\"Consumer consent provided?\" = 'N/A' \n        THEN 'No' \n        ELSE T2.\"Consumer consent provided?\" \n    END AS consent_status\nFROM client T1\nINNER JOIN events T2 ON T1.client_id = T2.Client_ID\nWHERE T1.first = 'Lyric' \n    AND T1.middle = 'Emely' \n    AND T1.last = 'Taylor' \n    AND T1.sex = 'Ms.' \n    AND T2.\"Date received\" = '2016-05-20'",
            "SELECT \n    CASE \n        WHEN T2.\"Consumer consent provided?\" IN (NULL, 'N/A', '') THEN 'No'\n        ELSE 'Yes'\n    END\nFROM client T1\nINNER JOIN events T2 ON T1.client_id = T2.Client_ID\nWHERE T1.first = 'Lyric' \n    AND T1.middle = 'Emely' \n    AND T1.last = 'Taylor' \n    AND T1.sex = 'Female'\n    AND T2.\"Date received\" = '2016-05-20'"
        ],
        "rule_sql": []
    },
    "7711": {
        "db_id": "hockey",
        "question": "When was the birthday for the goalie who had most goal againsts in 1965 season?",
        "ground_truth": "SELECT T1.birthYear, T1.birthMon, birthDay FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 1965 ORDER BY T2.GA DESC LIMIT 1",
        "amends": [
            "Do select `birthYear`, `birthMon`, and `birthDay` from the `Master` table instead of just `birthday` from the `Goalies` table. Do join `Master AS T1` with `Goalies AS T2` using `INNER JOIN` on `T1.playerID = T2.playerID` instead of querying only the `goalies` table. Do filter on `T2.year = 1965` instead of `season = 1965`. Do order by `T2.GA DESC` instead of `goals_against DESC`. The amended query now correctly retrieves complete birth date information by joining player master data with goalie statistics and matches the RIGHT_SQL's behavior.",
            "Do remove the `CAST(T2.GA AS INTEGER)` in the ORDER BY clause instead of casting to integer, instead using the natural ordering of `T2.GA` directly. Do reference `birthDay` without the `T1.` table prefix instead of using the qualified `T1.birthDay` reference. The amended query now correctly sorts by the GA column's natural values without unnecessary type conversion and uses proper column qualification."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthday FROM goalies WHERE season = 1965 ORDER BY goals_against DESC LIMIT 1;",
            "SELECT T1.birthYear, T1.birthMon, T1.birthDay\nFROM Master AS T1\nINNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID\nWHERE T2.year = 1965\nORDER BY CAST(T2.GA AS INTEGER) DESC\nLIMIT 1;",
            "SELECT T1.birthYear, T1.birthMon, T1.birthDay\nFROM Master AS T1\nINNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID\nWHERE T2.year = 1965\nORDER BY T2.GA DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4949": {
        "db_id": "olympics",
        "question": "Which region do most of the athletes are from?",
        "ground_truth": "SELECT T2.region_name FROM person_region AS T1 INNER JOIN noc_region AS T2 ON T1.region_id = T2.id GROUP BY T2.region_name ORDER BY COUNT(T1.person_id) DESC LIMIT 1",
        "amends": [
            "Do select `T2.region_name` instead of `region` and `athlete_count`. Do use `FROM person_region AS T1 INNER JOIN noc_region AS T2` instead of `FROM athletes`. Do join on `T1.region_id = T2.id` instead of no join condition. Do group by `T2.region_name` instead of `region`. Do order by `COUNT(T1.person_id) DESC` instead of `athlete_count ASC`. Do count `T1.person_id` instead of `*`. The amended query now correctly joins the person_region and noc_region tables to count athletes per region and returns the region with the highest count instead of the lowest.",
            "Do remove `COUNT(T1.person_id) AS athlete_count` from the SELECT list instead of including it, as the query only needs to return the region name. Do keep the same FROM clause with `INNER JOIN` on `T1.region_id = T2.id` between `person_region` and `noc_region` tables. Do maintain the same `GROUP BY T2.region_name` grouping. Do preserve the `ORDER BY COUNT(T1.person_id) DESC` ordering by athlete count in descending order. Do retain the `LIMIT 1` clause to return only the top result. The amended query now correctly returns only the region name with the highest athlete count instead of including the count value in the output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as athlete_count FROM athletes GROUP BY region ORDER BY athlete_count ASC LIMIT 1;",
            "SELECT T2.region_name, COUNT(T1.person_id) AS athlete_count\nFROM person_region AS T1\nINNER JOIN noc_region AS T2 ON T1.region_id = T2.id\nGROUP BY T2.region_name\nORDER BY COUNT(T1.person_id) DESC\nLIMIT 1;",
            "SELECT T2.region_name\nFROM person_region AS T1\nINNER JOIN noc_region AS T2 ON T1.region_id = T2.id\nGROUP BY T2.region_name\nORDER BY COUNT(T1.person_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3688": {
        "db_id": "college_completion",
        "question": "List all the public institutes from the state with the least number of graduate cohort in 2013.",
        "ground_truth": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE T2.year = 2013 AND T1.control = 'Public' ORDER BY T2.grad_cohort LIMIT 1",
        "amends": [
            "Do select `T1.chronname` instead of `*` and use explicit column selection. Do join `institution_details AS T1` with `state_sector_grads AS T2` on `T1.state = T2.state` instead of querying a single table with a subquery. Do filter with `T2.year = 2013` and `T1.control = 'Public'` instead of `type = 'public'` and a subquery for state. Do order by `T2.grad_cohort` instead of ordering the subquery by `cohort_size ASC`. Do remove the subquery entirely and instead use a direct join approach. The amended query now correctly matches the intended behavior by joining institution details with graduation data and filtering for public institutions in the specified year.",
            "Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do add `LIMIT 1` instead of omitting it to return only the first result. Do remove `ASC` from the `ORDER BY` clause instead of keeping it since the default ordering is sufficient when using `LIMIT 1`. The amended query now correctly returns only the first institution based on graduation cohort ordering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM institutes WHERE type = 'public' AND state = (SELECT state FROM graduate_cohorts WHERE year = 2013 ORDER BY cohort_size ASC LIMIT 1);",
            "SELECT T1.chronname\nFROM institution_details AS T1\nJOIN state_sector_grads AS T2 ON T1.state = T2.state\nWHERE T2.year = 2013\nAND T1.control = 'Public'\nORDER BY T2.grad_cohort ASC;",
            "SELECT T1.chronname\nFROM institution_details AS T1\nINNER JOIN state_sector_grads AS T2 ON T1.state = T2.state\nWHERE T2.year = 2013 AND T1.control = 'Public'\nORDER BY T2.grad_cohort\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2405": {
        "db_id": "superstore",
        "question": "What product category got the highest profit in the south superstore?",
        "ground_truth": "SELECT T2.Category FROM south_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` ORDER BY T1.Profit DESC LIMIT 1",
        "amends": [
            "Do use `T2.Category` in the SELECT list instead of `category` and remove the `SUM(profit) as total_profit` aggregation. Do change the FROM source to `south_superstore AS T1 INNER JOIN product AS T2` instead of just `superstore`. Do add the join condition `ON T1.Product ID = T2.Product ID` instead of omitting it. Do remove the WHERE filter `region = 'South'` and GROUP BY clause `GROUP BY category` since the filtering is now handled by the south_superstore table. Do change the ORDER BY to `T1.Profit DESC` instead of `total_profit DESC` while keeping the `LIMIT 1`. The amended query now correctly joins the south-specific data with product information to find the highest-profit product category in the South region."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, SUM(profit) as total_profit \nFROM superstore \nWHERE region = 'South' \nGROUP BY category \nORDER BY total_profit DESC \nLIMIT 1;",
            "SELECT T2.Category\nFROM south_superstore AS T1\nINNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\"\nORDER BY T1.Profit DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "647": {
        "db_id": "codebase_comments",
        "question": "How many methods does solution 1 have? And please tell me if solution 1 needs to be compiled.",
        "ground_truth": "SELECT COUNT(T2.SolutionId) , CASE WHEN T1.WasCompiled = 0 THEN 'Needs' ELSE 'NoNeeds' END needToCompile FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.SolutionId = 1",
        "amends": [
            "Do select `COUNT(T2.SolutionId)` and `CASE WHEN T1.WasCompiled = 0 THEN 'Needs' ELSE 'NoNeeds' END` with alias `needToCompile` instead of `COUNT(*)` with alias `method_count` and column `needs_compilation`. Do use `FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId` instead of `FROM solutions` without joins. Do apply filter `WHERE T2.SolutionId = 1` instead of `WHERE solution_id = 1`. Do remove the incorrect column reference `needs_compilation` and instead calculate compilation status through the case expression based on `T1.WasCompiled`. The amended query now correctly counts methods per solution while properly determining compilation needs through table joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS method_count, needs_compilation FROM solutions WHERE solution_id = 1",
            "SELECT COUNT(T2.SolutionId) AS method_count, CASE WHEN T1.WasCompiled = 0 THEN 'Needs' ELSE 'NoNeeds' END AS needToCompile FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.SolutionId = 1"
        ],
        "rule_sql": []
    },
    "1615": {
        "db_id": "car_retails",
        "question": "What was the contact name for the check \"NR157385\"?",
        "ground_truth": "SELECT t2.contactFirstName, t2.contactLastName FROM payments AS t1 INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE t1.checkNumber = 'NR157385'",
        "amends": [
            "Do select `t2.contactFirstName` and `t2.contactLastName` instead of `contact_name` from a single table. Do join `payments AS t1` and `customers AS t2` with an `INNER JOIN` on `t1.customerNumber = t2.customerNumber` instead of querying only the `checks` table. Do filter on `t1.checkNumber = 'NR157385'` instead of `check_number = 'NR157385'` to reference the correct table and column. The amended query now correctly retrieves customer contact information by joining payment and customer data based on the check number."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contact_name FROM checks WHERE check_number = 'NR157385';",
            "SELECT t2.contactFirstName, t2.contactLastName \nFROM payments AS t1 \nINNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber \nWHERE t1.checkNumber = 'NR157385'"
        ],
        "rule_sql": []
    },
    "1095": {
        "db_id": "talkingdata",
        "question": "What is the category that the most app users belong to?",
        "ground_truth": "SELECT T.category FROM ( SELECT T1.category, COUNT(T2.app_id) AS num FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id GROUP BY T1.label_id ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do select `T.category` instead of `category, COUNT(*) as user_count` and change the source to a subquery instead of directly from `users`. Do use `INNER JOIN` between `label_categories AS T1` and `app_labels AS T2` on `T1.label_id = T2.label_id` instead of no join. Do aggregate by `T1.label_id` instead of `category` and count `T2.app_id` instead of all rows. Do order by `T.num DESC` instead of `user_count ASC` while keeping the same `LIMIT 1`. The amended query now correctly calculates the category with the highest number of associated apps through label relationships instead of counting users by category."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(*) as user_count FROM users GROUP BY category ORDER BY user_count ASC LIMIT 1;",
            "SELECT T1.category\nFROM label_categories AS T1\nINNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id\nGROUP BY T1.label_id\nORDER BY COUNT(T2.app_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5536": {
        "db_id": "menu",
        "question": "Write down the image ID, full height, and full width of the menu that were used in the \"100TH ANNIVERSARY OF BIRTH OF DANIEL WEBSTER\" event.",
        "ground_truth": "SELECT T1.image_id, T1.full_height, T1.full_width FROM MenuPage AS T1 INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE T2.event = '100TH ANNIVERSARY OF BIRTH OF DANIEL WEBSTER'",
        "amends": [
            "Do reference columns `T1.image_id`, `T1.full_height`, and `T1.full_width` from table `MenuPage` instead of `image_id`, `height`, and `width` from table `menus`. Do join `MenuPage AS T1` with `Menu AS T2` using `INNER JOIN` on `T2.id = T1.menu_id` instead of querying a single table `menus`. Do filter on `T2.event = '100TH ANNIVERSARY OF BIRTH OF DANIEL WEBSTER'` instead of `event_name = '100TH ANNIVERSARY OF BIRTH OF DANIEL WEBSTER'`. The amended query now correctly joins the related tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id, height, width FROM menus WHERE event_name = '100TH ANNIVERSARY OF BIRTH OF DANIEL WEBSTER';",
            "SELECT T1.image_id, T1.full_height, T1.full_width FROM MenuPage AS T1 INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE T2.event = '100TH ANNIVERSARY OF BIRTH OF DANIEL WEBSTER'"
        ],
        "rule_sql": []
    },
    "434": {
        "db_id": "movies_4",
        "question": "For the movie \"Reign of Fire\", which department was Marcia Ross in?",
        "ground_truth": "SELECT T4.department_name FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id INNER JOIN department AS T4 ON T2.department_id = T4.department_id WHERE T3.person_name = 'Marcia Ross' AND T1.title = 'Reign of Fire'",
        "amends": [
            "Do join multiple tables instead of querying a single table. Do use `INNER JOIN` on `movie.movie_id = movie_crew.movie_id` instead of omitting the movie table. Do use `INNER JOIN` on `person.person_id = movie_crew.person_id` instead of filtering by name directly. Do use `INNER JOIN` on `department.department_id = movie_crew.department_id` instead of selecting department directly. Do filter by `person.person_name = 'Marcia Ross'` instead of `name = 'Marcia Ross'`. Do filter by `movie.title = 'Reign of Fire'` instead of `movie_title = 'Reign of Fire'`. Do select `department.department_name` instead of `department`. The amended query now correctly joins all necessary tables to retrieve the department name with proper foreign key relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department FROM movie_crew WHERE movie_title = 'Reign of Fire' AND name = 'Marcia Ross';",
            "SELECT department.department_name \nFROM movie\nINNER JOIN movie_crew ON movie.movie_id = movie_crew.movie_id\nINNER JOIN person ON person.person_id = movie_crew.person_id\nINNER JOIN department ON department.department_id = movie_crew.department_id\nWHERE movie.title = 'Reign of Fire' AND person.person_name = 'Marcia Ross'"
        ],
        "rule_sql": []
    },
    "768": {
        "db_id": "movie",
        "question": "What is the MPAA rating and title of the movie starred by Leonardo DiCaprio with highest budget?",
        "ground_truth": "SELECT T1.`MPAA Rating`, T1.Title FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T3.Name = 'Leonardo DiCaprio' ORDER BY T1.Budget DESC LIMIT 1",
        "amends": [
            "Do use `T1.MPAA Rating` and `T1.Title` instead of `m.rating` and `m.title` for column selection. Do join `characters AS T2` on `T1.MovieID = T2.MovieID` instead of `stars s` on `m.id = s.movie_id` for the intermediate table. Do join `actor AS T3` on `T3.ActorID = T2.ActorID` instead of `people p` on `s.person_id = p.id` for the actor table. Do filter on `T3.Name = 'Leonardo DiCaprio'` instead of `p.name = 'Leonardo DiCaprio'` for the actor name condition. Do order by `T1.Budget DESC` instead of `m.budget DESC` for the budget ordering. The amended query now correctly joins through the characters table to find movies featuring Leonardo DiCaprio and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.rating, m.title FROM movies m JOIN stars s ON m.id = s.movie_id JOIN people p ON s.person_id = p.id WHERE p.name = 'Leonardo DiCaprio' ORDER BY m.budget DESC LIMIT 1;",
            "SELECT T1.\"MPAA Rating\", T1.Title\nFROM movie AS T1\nJOIN characters AS T2 ON T1.MovieID = T2.MovieID\nJOIN actor AS T3 ON T3.ActorID = T2.ActorID\nWHERE T3.Name = 'Leonardo DiCaprio'\nORDER BY T1.Budget DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8370": {
        "db_id": "mondial_geo",
        "question": "How many people reside in the nation's capital city, which is situated in the nation that attained independence on 8/15/1947?",
        "ground_truth": "SELECT T3.Population FROM politics AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code INNER JOIN city AS T3 ON T3.Name = T2.Capital WHERE T1.Independence = '1947-08-15'",
        "amends": [
            "Do select `T3.Population` instead of `COUNT(*)`. Do use tables `politics AS T1`, `country AS T2`, and `city AS T3` instead of `people`, `cities`, and `nations`. Do join `T1` to `T2` on `T1.Country = T2.Code` instead of joining people to cities on city_id. Do join `T2` to `T3` on `T3.Name = T2.Capital` instead of joining cities to nations on nation_id. Do filter on `T1.Independence = '1947-08-15'` instead of filtering on both capital status and independence date. Do remove the `c.is_capital = 1` filter since the capital relationship is now handled through the join condition. The amended query now correctly retrieves population data from capital cities of countries that gained independence on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people p JOIN cities c ON p.city_id = c.city_id JOIN nations n ON c.nation_id = n.nation_id WHERE c.is_capital = 1 AND n.independence_date = '1947-08-15';",
            "SELECT T3.Population\nFROM politics AS T1\nJOIN country AS T2 ON T1.Country = T2.Code\nJOIN city AS T3 ON T3.Name = T2.Capital\nWHERE T1.Independence = '1947-08-15'"
        ],
        "rule_sql": []
    },
    "7321": {
        "db_id": "works_cycles",
        "question": "What is the current payrate of Rob Walters? Calculate the percentage increment from his previous payrate.",
        "ground_truth": "SELECT T2.Rate , (MAX(T2.Rate) - MIN(T2.Rate)) * 100 / MAX(T2.Rate) FROM Person AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'Rob' AND T1.LastName = 'Walters'",
        "amends": [
            "Do select `T2.Rate` and a percentage calculation using `(MAX(T2.Rate) - MIN(T2.Rate)) * 100 / MAX(T2.Rate)` instead of `current_payrate`, `previous_payrate`, and `(current_payrate - previous_payrate) / previous_payrate * 100`. Do use `FROM Person AS T1 INNER JOIN EmployeePayHistory AS T2` instead of `FROM employees`. Do add join condition `ON T1.BusinessEntityID = T2.BusinessEntityID` instead of omitting it. Do use `WHERE T1.FirstName = 'Rob' AND T1.LastName = 'Walters'` instead of `WHERE name = 'Rob Walters'`. Do remove the `AS percentage_increment` alias instead of keeping it. The amended query now correctly calculates pay rate percentage increment by joining appropriate tables and using proper aggregate functions to find rate differences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    current_payrate, \n    previous_payrate,\n    (current_payrate - previous_payrate) / previous_payrate * 100 AS percentage_increment\nFROM employees\nWHERE name = 'Rob Walters';",
            "SELECT T2.Rate, (MAX(T2.Rate) - MIN(T2.Rate)) * 100 / MAX(T2.Rate) \nFROM Person AS T1 \nINNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID \nWHERE T1.FirstName = 'Rob' AND T1.LastName = 'Walters'"
        ],
        "rule_sql": []
    },
    "7124": {
        "db_id": "works_cycles",
        "question": "How many people work in the finance department?",
        "ground_truth": "SELECT COUNT(T2.BusinessEntityID) FROM Department AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T1.Name = 'Finance'",
        "amends": [
            "Do specify `COUNT(T2.BusinessEntityID)` instead of `COUNT(*)` to count specific employee records. Do join `Department AS T1` and `EmployeeDepartmentHistory AS T2` with `INNER JOIN` on `T1.DepartmentID = T2.DepartmentID` instead of querying only the `employees` table. Do filter on `T1.Name = 'Finance'` instead of `department = 'Finance'` to reference the correct table and column. The amended query now correctly counts employees in the Finance department by properly joining the department and employee history tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department = 'Finance';",
            "SELECT COUNT(T2.BusinessEntityID) \nFROM Department AS T1 \nINNER JOIN EmployeeDepartmentHistory AS T2 ON T1.DepartmentID = T2.DepartmentID \nWHERE T1.Name = 'Finance'"
        ],
        "rule_sql": []
    },
    "3978": {
        "db_id": "public_review_platform",
        "question": "Calculate the percentage of business with attribute name of \"Accepts Credit Cards\".",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.attribute_name = 'Accepts Credit Cards' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.attribute_name) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id",
        "amends": [
            "Do use `SUM(CASE WHEN T1.attribute_name = 'Accepts Credit Cards' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only matching rows. Do join `Attributes AS T1` and `Business_Attributes AS T2` with `INNER JOIN` on `T1.attribute_id = T2.attribute_id` instead of querying only the `business` table. Do calculate the percentage using `* 100 / COUNT(T1.attribute_name)` instead of dividing by a subquery `(SELECT COUNT(*) FROM business)`. Do add explicit `CAST` to `REAL` instead of relying on implicit casting. Do remove the `WHERE` clause filter and instead incorporate the condition within the `CASE` expression. The amended query now correctly calculates the percentage of businesses that accept credit cards by properly joining attribute tables and using conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM business) AS percentage FROM business WHERE attribute_name = 'Accepts Credit Cards'",
            "SELECT \n    CAST(SUM(CASE WHEN T1.attribute_name = 'Accepts Credit Cards' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.attribute_name) AS percentage\nFROM \n    Attributes AS T1\nINNER JOIN \n    Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id;"
        ],
        "rule_sql": []
    },
    "7191": {
        "db_id": "works_cycles",
        "question": "What is the total sick leave hours of employees who do not wish to receive any e-mail promotion?",
        "ground_truth": "SELECT SUM(T1.SickLeaveHours) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.EmailPromotion = 0",
        "amends": [
            "Do join `Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` instead of querying only the `employees` table. Do filter on `T2.EmailPromotion = 0` instead of `email_promotion = 1`. Do reference `T1.SickLeaveHours` with proper table qualification instead of unqualified `sick_leave_hours`. The amended query now correctly joins the necessary tables and applies the proper filter condition to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(sick_leave_hours) FROM employees WHERE email_promotion = 1;",
            "SELECT SUM(T1.SickLeaveHours) AS TotalSickLeaveHours\nFROM Employee AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T2.EmailPromotion = 0"
        ],
        "rule_sql": []
    },
    "6469": {
        "db_id": "retail_world",
        "question": "Calculate the total products that are supplied by Japan suppliers.",
        "ground_truth": "SELECT COUNT(T1.SupplierID) FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T2.Country = 'Japan'",
        "amends": [
            "Do join `Products` with `Suppliers` on `SupplierID` instead of querying `products` alone. Do filter on `T2.Country` instead of the non-existent `supplier_country` column. Do count `T1.SupplierID` instead of using `COUNT(*)` to avoid counting NULL values. The amended query now correctly counts products from Japanese suppliers by properly joining the tables and using the appropriate count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE supplier_country = 'Japan';",
            "SELECT COUNT(T1.SupplierID) \nFROM Products T1\nJOIN Suppliers T2 ON T1.SupplierID = T2.SupplierID\nWHERE T2.Country = 'Japan'"
        ],
        "rule_sql": []
    },
    "7960": {
        "db_id": "music_platform_2",
        "question": "Write the names of the podcasts in the music category that have a rating greater than 3.",
        "ground_truth": "SELECT DISTINCT T2.title FROM categories AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'music' AND T2.rating > 3",
        "amends": [
            "Do select `DISTINCT T2.title` instead of `name` from a different table. Do use `INNER JOIN` between `categories AS T1` and `reviews AS T2` instead of querying only the `podcasts` table. Do join on `T2.podcast_id = T1.podcast_id` instead of no join condition. Do filter `T1.category = 'music'` instead of filtering a non-existent category column in podcasts. Do filter `T2.rating > 3` instead of filtering rating from the wrong table. The amended query now correctly joins categories with reviews to find music podcasts with high ratings, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM podcasts WHERE category = 'music' AND rating > 3;",
            "SELECT DISTINCT T2.title FROM categories AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'music' AND T2.rating > 3"
        ],
        "rule_sql": []
    },
    "5470": {
        "db_id": "menu",
        "question": "How many dishes do not have correct data for the year in which it appeared first?",
        "ground_truth": "SELECT COUNT(*) FROM Dish WHERE first_appeared < 1851 OR first_appeared > 2012",
        "amends": [
            "Do reference table `Dish` instead of `dishes` and use column `first_appeared` instead of `year_first_appeared`. Do remove the `IS NULL` condition and instead filter for `first_appeared < 1851` instead of `< 1800` and `first_appeared > 2012` instead of `> 2023`. The amended query now correctly counts records where the first appearance date falls outside the 1851-2012 range, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dishes WHERE year_first_appeared IS NULL OR year_first_appeared < 1800 OR year_first_appeared > 2023;",
            "SELECT COUNT(*) FROM Dish WHERE first_appeared < 1851 OR first_appeared > 2012;"
        ],
        "rule_sql": []
    },
    "1292": {
        "db_id": "law_episode",
        "question": "What are the titles of the top 3 episodes that received no less than 30 votes in its 10-star rating?",
        "ground_truth": "SELECT T2.title FROM Vote AS T1 INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE T1.votes >= 30 AND T1.stars = 10 ORDER BY T1.votes DESC LIMIT 3",
        "amends": [
            "Do select `T2.title` from the `Episode` table instead of `title` from the `episodes` table. Do join `Vote AS T1` with `Episode AS T2` using `INNER JOIN` on `T2.episode_id = T1.episode_id` instead of querying a single table. Do add filter condition `T1.stars = 10` instead of omitting it. Do change the filter to use `T1.votes >= 30` instead of `votes >= 30` from the wrong table. Do order by `T1.votes DESC` instead of `rating DESC`. The amended query now correctly joins the Vote and Episode tables, applies proper filtering on votes and stars, and sorts by vote count as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE votes >= 30 ORDER BY rating DESC LIMIT 3;",
            "SELECT T2.title \nFROM Vote AS T1 \nINNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id \nWHERE T1.stars = 10 AND T1.votes >= 30 \nORDER BY T1.votes DESC \nLIMIT 3"
        ],
        "rule_sql": []
    },
    "9326": {
        "db_id": "movie_3",
        "question": "Please give the description of the movie starring JENNIFER DAVIS.",
        "ground_truth": "SELECT T3.description FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T3.film_id = T2.film_id WHERE T1.first_name = 'JOHNNY' AND T1.last_name = 'DAVIS'",
        "amends": [
            "Do use a proper three-table join structure with `actor AS T1`, `film_actor AS T2`, and `film AS T3` instead of querying a single `movies` table. Do join `T1.actor_id = T2.actor_id` and `T3.film_id = T2.film_id` instead of no join conditions. Do filter on `T1.first_name = 'JOHNNY' AND T1.last_name = 'DAVIS'` instead of `starring = 'JENNIFER DAVIS'` to correctly identify the actor. Do select `T3.description` from the film table instead of `description` from a movies table. The amended query now properly retrieves film descriptions for the specified actor through the correct relational schema.",
            "Do filter for `first_name = 'JOHNNY'` instead of `first_name = 'JENNIFER'` in the WHERE clause, while keeping the same join structure with `INNER JOIN` on `T1.actor_id = T2.actor_id` and `T3.film_id = T2.film_id`, and maintaining the same column selection of `T3.description`. The amended query now correctly retrieves film descriptions for Johnny Davis instead of Jennifer Davis, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM movies WHERE starring = 'JENNIFER DAVIS'",
            "SELECT T3.description \nFROM actor AS T1 \nJOIN film_actor AS T2 ON T1.actor_id = T2.actor_id \nJOIN film AS T3 ON T3.film_id = T2.film_id \nWHERE T1.first_name = 'JENNIFER' AND T1.last_name = 'DAVIS';",
            "SELECT T3.description \nFROM actor AS T1 \nINNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id \nINNER JOIN film AS T3 ON T3.film_id = T2.film_id \nWHERE T1.first_name = 'JOHNNY' AND T1.last_name = 'DAVIS'"
        ],
        "rule_sql": []
    },
    "3039": {
        "db_id": "shakespeare",
        "question": "What is the description of chapter 18706 in \"All's Well That Ends Well\"?",
        "ground_truth": "SELECT T2.Description FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.id = 18706 AND T1.Title = 'All''s Well That Ends Well'",
        "amends": [
            "Do select `T2.Description` with explicit table alias instead of just `description`. Do join `works AS T1` and use `INNER JOIN chapters AS T2 ON T1.id = T2.work_id` instead of querying only the `chapters` table. Do filter on `T2.id = 18706` instead of `chapter_number = 18706`. Do filter on `T1.Title = 'All''s Well That Ends Well'` instead of `book_title = 'All''s Well That Ends Well'`. The amended query now correctly joins the works table to chapters via work_id and uses proper id-based filtering instead of potentially ambiguous title and chapter number fields, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM chapters WHERE chapter_number = 18706 AND book_title = 'All''s Well That Ends Well';",
            "SELECT T2.Description \nFROM works AS T1 \nINNER JOIN chapters AS T2 ON T1.id = T2.work_id \nWHERE T2.id = 18706 \nAND T1.Title = 'All''s Well That Ends Well'"
        ],
        "rule_sql": []
    },
    "1534": {
        "db_id": "synthea",
        "question": "Who is the 44-year-old patient diagnosed with drug overdose?",
        "ground_truth": "SELECT T2.first, T2.last FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Drug overdose' AND ROUND((strftime('%J', T2.deathdate) - strftime('%J', T2.birthdate)) / 365) = 44",
        "amends": [
            "Do select specific columns `T2.first` and `T2.last` instead of using `SELECT *`. Do join tables with `INNER JOIN conditions AS T1 ON T1.PATIENT = T2.patient` instead of querying only the `patients` table. Do filter on `T1.DESCRIPTION = 'Drug overdose'` instead of `diagnosis = 'drug overdose'`. Do calculate age using `ROUND((strftime('%J', T2.deathdate) - strftime('%J', T2.birthdate)) / 365) = 44` instead of directly comparing `age = 44`. The amended query now correctly joins patient and condition data and calculates age from birth and death dates rather than relying on a static age column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM patients WHERE age = 44 AND diagnosis = 'drug overdose';",
            "SELECT T2.first, T2.last\nFROM patients AS T2\nINNER JOIN conditions AS T1 ON T1.PATIENT = T2.patient\nWHERE T1.DESCRIPTION = 'Drug overdose'\nAND ROUND((strftime('%J', T2.deathdate) - strftime('%J', T2.birthdate)) / 365) = 44"
        ],
        "rule_sql": []
    },
    "125": {
        "db_id": "movie_platform",
        "question": "Show the head portrait of the user who gave the most \"5\" ratings.",
        "ground_truth": "SELECT T2.user_avatar_image_url FROM ratings AS T1 INNER JOIN lists_users AS T2 ON T1.user_id = T2.user_id WHERE T1.rating_score = 5",
        "amends": [
            "Do select `T2.user_avatar_image_url` instead of `u.head_portrait`. Do join `lists_users AS T2` instead of omitting this table. Do use `INNER JOIN` on `T1.user_id = T2.user_id` instead of joining only `users` on `u.user_id = r.user_id`. Do filter by `T1.rating_score = 5` instead of `r.rating = 5`. Do remove `GROUP BY`, `ORDER BY`, and `LIMIT` clauses instead of keeping them. The amended query now correctly retrieves user avatar URLs from the joined lists_users table for users who gave a rating score of 5, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.head_portrait \nFROM users u \nJOIN ratings r ON u.user_id = r.user_id \nWHERE r.rating = 5 \nGROUP BY u.user_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT T2.user_avatar_image_url \nFROM ratings AS T1 \nINNER JOIN lists_users AS T2 ON T1.user_id = T2.user_id \nWHERE T1.rating_score = 5"
        ],
        "rule_sql": []
    },
    "767": {
        "db_id": "movie",
        "question": "Count the male actors born in USA that starred in Ghost.",
        "ground_truth": "SELECT COUNT(*) FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T1.Title = 'Ghost' AND T3.Gender = 'Male' AND T3.`Birth Country` = 'USA'",
        "amends": [
            "Do join `movie AS T1` and `characters AS T2` on `T1.MovieID = T2.MovieID` instead of querying only the `actors` table. Do join `actor AS T3` on `T3.ActorID = T2.ActorID` instead of missing the necessary table relationships. Do filter on `T1.Title = 'Ghost'` instead of `movie_title = 'Ghost'` to reference the correct table and column. Do filter on `T3.Gender = 'Male'` instead of `gender = 'male'` to use proper case and table reference. Do filter on `T3.Birth Country = 'USA'` instead of `country = 'USA'` to reference the correct column name with proper quoting. The amended query now correctly counts actors from the USA who played in the movie 'Ghost' by properly joining the necessary tables and using accurate column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors WHERE gender = 'male' AND country = 'USA' AND movie_title = 'Ghost';",
            "SELECT COUNT(DISTINCT T3.ActorID) \nFROM movie AS T1 \nJOIN characters AS T2 ON T1.MovieID = T2.MovieID \nJOIN actor AS T3 ON T3.ActorID = T2.ActorID \nWHERE T1.Title = 'Ghost' \nAND T3.Gender = 'Male' \nAND T3.\"Birth Country\" = 'USA'"
        ],
        "rule_sql": []
    },
    "4148": {
        "db_id": "citeseer",
        "question": "What is the class label of paper ID 'chakrabarti01integrating'. How many words were cited by this paper ID?",
        "ground_truth": "SELECT DISTINCT T1.class_label, COUNT(T2.word_cited_id) FROM paper AS T1 INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE T1.paper_id = 'chakrabarti01integrating' GROUP BY T1.class_label",
        "amends": [
            "Do use `DISTINCT T1.class_label` instead of `class_label` to eliminate duplicate class labels. Do add table aliases `T1` and `T2` instead of omitting them for clarity. Do change the FROM clause to `paper AS T1 INNER JOIN content AS T2` instead of just `papers` to properly join the paper and content tables. Do add the join condition `ON T1.paper_id = T2.paper_id` instead of omitting it to establish the correct relationship between tables. Do change the COUNT expression to `COUNT(T2.word_cited_id)` instead of `COUNT(*)` to count actual cited words rather than all rows. Do add `GROUP BY T1.class_label` instead of omitting it to properly aggregate counts by class label. Do change the table reference to `paper` instead of `papers` to match the correct table name. The amended query now correctly counts distinct cited words per class label for the specified paper by joining the appropriate tables and using proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT class_label, COUNT(*) as cited_words FROM papers WHERE paper_id = 'chakrabarti01integrating';",
            "SELECT DISTINCT T1.class_label, COUNT(T2.word_cited_id) \nFROM paper AS T1 \nINNER JOIN content AS T2 ON T1.paper_id = T2.paper_id \nWHERE T1.paper_id = 'chakrabarti01integrating' \nGROUP BY T1.class_label"
        ],
        "rule_sql": []
    },
    "841": {
        "db_id": "social_media",
        "question": "What is the gender of the user who has posted the tweet that got the most likes?",
        "ground_truth": "SELECT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID ORDER BY T1.Likes DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` between `twitter` and `user` tables on `T1.UserID = T2.UserID` instead of a subquery that selects from `users` and `tweets` tables separately. Do select `T2.Gender` instead of `gender` from the `users` table. Do add `ORDER BY T1.Likes DESC` and `LIMIT 1` at the query level instead of using a subquery with ordering and limiting. Do remove the `WHERE` clause with subquery filtering instead of keeping it. The amended query now correctly joins the tables to find the gender of the user with the most liked tweet, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE user_id = (SELECT user_id FROM tweets ORDER BY likes DESC LIMIT 1);",
            "SELECT T2.Gender \nFROM twitter T1 \nINNER JOIN user T2 ON T1.UserID = T2.UserID \nORDER BY T1.Likes DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4887": {
        "db_id": "legislator",
        "question": "What is the religion of current legislator Sherrod Brown?",
        "ground_truth": "SELECT religion_bio FROM current WHERE official_full_name = 'Sherrod Brown'",
        "amends": [
            "Do select `religion_bio` instead of `religion` and use table `current` instead of `legislators`. Do filter on `official_full_name = 'Sherrod Brown'` instead of `name = 'Sherrod Brown' AND current = 1`, removing the redundant `current` condition since the table name already implies current records. The amended query now correctly retrieves the religious biography from the current legislators table using the official full name field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT religion FROM legislators WHERE name = 'Sherrod Brown' AND current = 1;",
            "SELECT religion_bio FROM current WHERE official_full_name = 'Sherrod Brown';"
        ],
        "rule_sql": []
    },
    "3177": {
        "db_id": "donor",
        "question": "What is the average amount of donations by people who donated in the project \"Recording Rockin' Readers\"",
        "ground_truth": "SELECT AVG(T3.donation_to_project) FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE T1.title = 'Recording Rockin'' Readers'",
        "amends": [
            "Do join `essays AS T1` and `projects AS T2` on `T1.projectid = T2.projectid` instead of querying `donations` alone, then join `donations AS T3` on `T2.projectid = T3.projectid` instead of omitting these table relationships. Do filter on `T1.title = 'Recording Rockin'' Readers'` instead of `project_name = 'Recording Rockin\\' Readers'` to correctly identify the project through essay titles rather than donation project names. Do select `AVG(T3.donation_to_project)` instead of `AVG(amount)` to reference the correct column name from the joined donations table. The amended query now properly navigates the relationship chain from essays to projects to donations to calculate the average donation amount for the specified project title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(amount) FROM donations WHERE project_name = 'Recording Rockin\\' Readers'",
            "SELECT AVG(T3.donation_to_project) \nFROM essays AS T1\nJOIN projects AS T2 ON T1.projectid = T2.projectid\nJOIN donations AS T3 ON T2.projectid = T3.projectid\nWHERE T1.title = 'Recording Rockin'' Readers'"
        ],
        "rule_sql": []
    },
    "5894": {
        "db_id": "airline",
        "question": "Provide the air carrier description of all flights arriving at Miami.",
        "ground_truth": "SELECT T1.Description FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T2.DEST = 'MIA'",
        "amends": [
            "Do select `T1.Description` from the `Air Carriers` table instead of `carrier_description` from the `flights` table. Do join `Airlines AS T2` using `INNER JOIN` on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of querying the `flights` table directly. Do filter on `T2.DEST = 'MIA'` instead of `destination = 'Miami'` and remove the `departure_city IS NOT NULL` condition instead of keeping it. The amended query now correctly joins carrier information with airline data and uses the proper airport code format, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT carrier_description FROM flights WHERE destination = 'Miami' AND departure_city IS NOT NULL;",
            "SELECT T1.Description \nFROM \"Air Carriers\" AS T1\nINNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nWHERE T2.DEST = 'MIA'"
        ],
        "rule_sql": []
    },
    "1975": {
        "db_id": "soccer_2016",
        "question": "What is the ratio of players with batting hands of left and right?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Batting_hand = 'Left-hand bat' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.Batting_hand = 'Right-hand bat' THEN 1 ELSE 0 END) FROM Player AS T1 INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id",
        "amends": [
            "Do use `SUM` with explicit `ELSE 0` instead of `COUNT` with implicit NULL handling. Do reference `Batting_hand` from joined table `T2` instead of directly from `players`. Do cast the numerator to `REAL` instead of performing integer division. Do join `Player AS T1` with `Batting_Style AS T2` on `T1.Batting_hand = T2.Batting_Id` instead of querying a single table. Do use exact string values 'Left-hand bat' and 'Right-hand bat' instead of 'Left' and 'Right'. Do remove the individual count columns and ratio alias instead of including them in the output. The amended query now correctly handles the schema relationships and ensures proper division with real numbers."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN batting_hand = 'Left' THEN 1 END) AS left_handed,\n    COUNT(CASE WHEN batting_hand = 'Right' THEN 1 END) AS right_handed,\n    COUNT(CASE WHEN batting_hand = 'Left' THEN 1 END) / COUNT(CASE WHEN batting_hand = 'Right' THEN 1 END) AS ratio\nFROM players;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.Batting_hand = 'Left-hand bat' THEN 1 ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN T2.Batting_hand = 'Right-hand bat' THEN 1 ELSE 0 END) AS ratio\nFROM \n    Player AS T1\nJOIN \n    Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id\nWHERE \n    T2.Batting_hand IN ('Left-hand bat', 'Right-hand bat');"
        ],
        "rule_sql": []
    },
    "792": {
        "db_id": "social_media",
        "question": "How many tweets are posted by male users in Argentina?",
        "ground_truth": "SELECT COUNT(T1.TweetID) FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID INNER JOIN user AS T3 ON T1.UserID = T3.UserID WHERE T3.Gender = 'Male' AND T2.Country = 'Argentina'",
        "amends": [
            "Do use `COUNT(T1.TweetID)` instead of `COUNT(*)` to count specific non-null tweet identifiers. Do reference tables as `twitter AS T1`, `location AS T2`, and `user AS T3` with explicit aliases instead of `tweets` and `users` without aliases. Do use `INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID` instead of omitting the location table join entirely. Do join on `T2.LocationID = T1.LocationID` for the location relationship instead of the missing location table. Do use `INNER JOIN user AS T3 ON T1.UserID = T3.UserID` instead of `JOIN users ON tweets.user_id = users.id` with corrected join direction and column references. Do filter on `T3.Gender = 'Male'` instead of `users.gender = 'male'` with proper case sensitivity. Do filter on `T2.Country = 'Argentina'` instead of `users.country = 'Argentina'` to use the location table for country information rather than the user table. The amended query now correctly joins the location table to access country data and uses proper table relationships with explicit aliases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets JOIN users ON tweets.user_id = users.id WHERE users.gender = 'male' AND users.country = 'Argentina';",
            "SELECT COUNT(T1.TweetID) \nFROM twitter AS T1\nINNER JOIN location AS T2 ON T2.LocationID = T1.LocationID\nINNER JOIN user AS T3 ON T1.UserID = T3.UserID\nWHERE T3.Gender = 'Male' AND T2.Country = 'Argentina'"
        ],
        "rule_sql": []
    },
    "5595": {
        "db_id": "shipping",
        "question": "Where was the destination city of shipment no.1701?",
        "ground_truth": "SELECT T2.city_name FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T1.ship_id = '1701'",
        "amends": [
            "Do select `T2.city_name` instead of `origin_city` and do use table aliases `T1` and `T2` instead of direct table names. Do join `shipment AS T1` with `city AS T2` on `T1.city_id = T2.city_id` instead of querying only the `shipments` table. Do filter on `T1.ship_id = '1701'` with string comparison instead of `shipment_id = 1701` with numeric comparison. The amended query now correctly retrieves the city name through a proper join relationship instead of directly selecting from a single table with potentially incorrect column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin_city FROM shipments WHERE shipment_id = 1701;",
            "SELECT T2.city_name FROM shipment AS T1 JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T1.ship_id = '1701'"
        ],
        "rule_sql": []
    },
    "8570": {
        "db_id": "software_company",
        "question": "What is the income of female customers ages from 30 to 55 years old and has an occupation of machine-op-inspct?",
        "ground_truth": "SELECT T2.INCOME_K FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T1.SEX = 'Female' AND T1.age >= 30 AND T1.age <= 55 AND T1.OCCUPATION = 'Machine-op-inspct'",
        "amends": [
            "Do select `T2.INCOME_K` from the `Demog` table instead of `income` from the `customers` table. Do join `Demog AS T2` with `Customers AS T1` using `INNER JOIN` on `T1.GEOID = T2.GEOID` instead of querying only the `customers` table. Do filter on `T1.SEX = 'Female'` instead of `gender = 'male'`. Do use separate conditions `T1.age >= 30 AND T1.age <= 55` instead of `age BETWEEN 30 AND 55`. Do reference `T1.OCCUPATION = 'Machine-op-inspct'` with proper case instead of `occupation = 'machine-op-inspct'`. The amended query now correctly joins demographic data and filters for female customers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT income FROM customers WHERE gender = 'male' AND age BETWEEN 30 AND 55 AND occupation = 'machine-op-inspct';",
            "SELECT T2.INCOME_K \nFROM Customers AS T1\nINNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID\nWHERE T1.SEX = 'Female' \nAND T1.age >= 30 \nAND T1.age <= 55 \nAND T1.OCCUPATION = 'Machine-op-inspct'"
        ],
        "rule_sql": []
    },
    "7725": {
        "db_id": "hockey",
        "question": "How many players were included in the Hall of Fame on average between 1950 and 1980?",
        "ground_truth": "SELECT CAST(COUNT(name) AS REAL) / 30 FROM HOF WHERE year BETWEEN 1950 AND 1980 AND category = 'Player'",
        "amends": [
            "Do calculate `CAST(COUNT(name) AS REAL) / 30` instead of `AVG(COUNT(*))` for the average count per year. Do filter by `category = 'Player'` instead of omitting this condition. Do reference table `HOF` instead of `HallOfFame`. Do remove the `GROUP BY year` clause instead of keeping it, as the right query calculates a single aggregate value across all years rather than per-year averages. The amended query now correctly computes the average number of players inducted per year between 1950 and 1980 by counting total players and dividing by the 30-year span, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(*)) FROM HallOfFame WHERE year BETWEEN 1950 AND 1980 GROUP BY year;",
            "SELECT CAST(COUNT(name) AS REAL) / 30 AS average_players\nFROM HOF\nWHERE year BETWEEN 1950 AND 1980\nAND category = 'Player';"
        ],
        "rule_sql": []
    },
    "8017": {
        "db_id": "university",
        "question": "What is the ranking criteria ID of Brown University in 2014?",
        "ground_truth": "SELECT T1.ranking_criteria_id FROM university_ranking_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T2.university_name = 'Brown University' AND T1.year = 2014",
        "amends": [
            "Do join `university_ranking_year AS T1` with `university AS T2` on `T1.university_id = T2.id` instead of querying `university_rankings` directly. Do reference `T1.ranking_criteria_id` instead of `ranking_criteria_id` without table alias. Do filter on `T2.university_name = 'Brown University'` instead of `university_name` without table qualification. Do filter on `T1.year = 2014` instead of `year` without table qualification. The amended query now correctly joins the university and ranking year tables to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_criteria_id FROM university_rankings WHERE university_name = 'Brown University' AND year = 2014;",
            "SELECT T1.ranking_criteria_id \nFROM university_ranking_year AS T1 \nJOIN university AS T2 ON T1.university_id = T2.id \nWHERE T2.university_name = 'Brown University' \nAND T1.year = 2014"
        ],
        "rule_sql": []
    },
    "1828": {
        "db_id": "soccer_2016",
        "question": "In which country do the majority of the players are from?",
        "ground_truth": "SELECT T1.Country_Name FROM Country AS T1 INNER JOIN Player AS T2 ON T1.Country_Id = T2.Country_Name GROUP BY T2.Country_Name ORDER BY COUNT(T2.Country_Name) DESC LIMIT 1",
        "amends": [
            "Do reference the `Country` table as `T1` and `Player` table as `T2` instead of only using a single `players` table. Do join with `INNER JOIN` on `T1.Country_Id = T2.Country_Name` instead of no join condition. Do select `T1.Country_Name` instead of `country` from the original table. Do group by `T2.Country_Name` instead of `country`. Do order by `COUNT(T2.Country_Name)` instead of the alias `player_count`. The amended query now correctly joins the Country and Player tables to retrieve the country name with the most players.",
            "Do select only `T1.Country_Name` instead of including `COUNT(T2.Country_Name) AS player_count` in the SELECT list. Do join `Country T1` with `Player T2` using `T1.Country_Id = T2.Country_Name` instead of the incorrect join condition. Do group by `T2.Country_Name` instead of the wrong grouping column. Do order by `COUNT(T2.Country_Name) DESC` and limit to `1` row instead of the incorrect result structure. The amended query now correctly returns only the country name with the highest player count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as player_count FROM players GROUP BY country ORDER BY player_count DESC LIMIT 1;",
            "SELECT T1.Country_Name, COUNT(T2.Country_Name) AS player_count\nFROM Country T1\nINNER JOIN Player T2 ON T1.Country_Id = T2.Country_Name\nGROUP BY T2.Country_Name\nORDER BY COUNT(T2.Country_Name) DESC\nLIMIT 1;",
            "SELECT T1.Country_Name \nFROM Country T1 \nINNER JOIN Player T2 ON T1.Country_Id = T2.Country_Name \nGROUP BY T2.Country_Name \nORDER BY COUNT(T2.Country_Name) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3220": {
        "db_id": "donor",
        "question": "Which city does the school that project \"iMath\" donated to in?",
        "ground_truth": "SELECT T1.school_city FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T2.title LIKE 'iMath'",
        "amends": [
            "Do select `T1.school_city` instead of `city`. Do join `projects AS T1` and `essays AS T2` with `INNER JOIN` on `T1.projectid = T2.projectid` instead of querying only `schools`. Do filter with `T2.title LIKE 'iMath'` instead of `project_name = 'iMath'`. The amended query now correctly joins the projects and essays tables to find school cities associated with iMath essays, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM schools WHERE project_name = 'iMath';",
            "SELECT T1.school_city FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T2.title LIKE 'iMath'"
        ],
        "rule_sql": []
    },
    "5233": {
        "db_id": "beer_factory",
        "question": "How many breweries are located in North America?",
        "ground_truth": "SELECT COUNT(BrandID) FROM rootbeerbrand WHERE Country = 'United States'",
        "amends": [
            "Do select `COUNT(BrandID)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference table `rootbeerbrand` instead of `breweries` to query the correct data source. Do filter on `Country = 'United States'` instead of `continent = 'North America'` to apply the appropriate geographic filter. The amended query now correctly counts root beer brands from the United States rather than breweries from North America."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM breweries WHERE continent = 'North America';",
            "SELECT COUNT(BrandID) FROM rootbeerbrand WHERE Country = 'United States';"
        ],
        "rule_sql": []
    },
    "8942": {
        "db_id": "human_resources",
        "question": "Among the employees who are Trainees, how many of them work in New York?",
        "ground_truth": "SELECT COUNT(*) FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID INNER JOIN position AS T3  ON T3.positionID = T1.positionID WHERE T3.positiontitle = 'Trainee' AND T2.state = 'NY'",
        "amends": [
            "Do add joins to `location` and `position` tables instead of querying only the `employees` table. Do join `employee` to `location` on `locationID` instead of filtering directly on `city`. Do join `employee` to `position` on `positionID` instead of filtering directly on `position`. Do filter on `positiontitle = 'Trainee'` instead of `position = 'Trainee'`. Do filter on `state = 'NY'` instead of `city = 'New York'`. The amended query now correctly joins related tables and uses proper foreign key relationships to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE position = 'Trainee' AND city = 'New York';",
            "SELECT COUNT(*) \nFROM employee e\nJOIN position p ON e.positionID = p.positionID\nJOIN location l ON e.locationID = l.locationID\nWHERE p.positiontitle = 'Trainee' \nAND l.state = 'NY'"
        ],
        "rule_sql": []
    },
    "5493": {
        "db_id": "menu",
        "question": "How many pages were there on the menu created on 17th November 1898?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.date = '1898-11-17' THEN 1 ELSE 0 END) FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id",
        "amends": [
            "Do use `SUM(CASE WHEN T1.date = '1898-11-17' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific rows. Do query from `Menu AS T1` instead of `menu_pages` as the base table. Do add `INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id` instead of omitting the join to properly relate the tables. Do filter on `T1.date = '1898-11-17'` instead of `created_date = '1898-11-17'` to use the correct date column from the Menu table. The amended query now correctly counts menu pages associated with menus from the specific date, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menu_pages WHERE created_date = '1898-11-17';",
            "SELECT SUM(CASE WHEN T1.date = '1898-11-17' THEN 1 ELSE 0 END) AS page_count\nFROM Menu AS T1\nINNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id\nWHERE T1.date = '1898-11-17'"
        ],
        "rule_sql": []
    },
    "581": {
        "db_id": "codebase_comments",
        "question": "What is the full comment on the method whose solution path is \"bmatzelle_nini\\Source\\Nini.sln\" with a tokenized name of \"alias text add alias\"?",
        "ground_truth": "SELECT T2.FullComment FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'bmatzelle_niniSourceNini.sln' AND T2.NameTokenized = 'alias text add alias'",
        "amends": [
            "Do select `T2.FullComment` instead of `comment` to reference the correct column from the joined table. Do use `FROM Solution AS T1 INNER JOIN Method AS T2` instead of `FROM methods` to properly join the Solution and Method tables. Do apply the join condition `ON T1.Id = T2.SolutionId` instead of missing the table relationship entirely. Do filter with `T1.Path = 'bmatzelle_niniSourceNini.sln'` instead of `solution_path = 'bmatzelle_nini\\Source\\Nini.sln'` to reference the correct table and column with the proper path format. Do use `T2.NameTokenized = 'alias text add alias'` instead of `tokenized_name = 'alias text add alias'` to reference the correct table's tokenized name column. The amended query now correctly joins the Solution and Method tables and references the appropriate columns to match the intended behavior.",
            "Do use the path value `'bmatzelle_niniSourceNini.sln'` in the WHERE clause instead of `'bmatzelle_nini\\Source\\Nini.sln'` with backslashes, as the correct path format omits directory separator characters that were present in the original query. The amended query now matches RIGHT_SQL's behavior by using the proper path format without backslash characters."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT comment FROM methods WHERE solution_path = 'bmatzelle_nini\\Source\\Nini.sln' AND tokenized_name = 'alias text add alias';",
            "SELECT T2.FullComment FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'bmatzelle_nini\\Source\\Nini.sln' AND T2.NameTokenized = 'alias text add alias'",
            "SELECT T2.FullComment\nFROM Solution AS T1\nINNER JOIN Method AS T2 ON T1.Id = T2.SolutionId\nWHERE T1.Path = 'bmatzelle_niniSourceNini.sln'\nAND T2.NameTokenized = 'alias text add alias'"
        ],
        "rule_sql": []
    },
    "2314": {
        "db_id": "movielens",
        "question": "What horror movies have a running time of at least 2? Please list movie IDs.",
        "ground_truth": "SELECT T1.movieid FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.runningtime >= 2 AND T1.genre = 'Horror'",
        "amends": [
            "Do select `T1.movieid` from the `movies2directors` table instead of `movie_id` from just the `movies` table. Do add an `INNER JOIN` between `movies2directors AS T1` and `movies AS T2` with the predicate `T1.movieid = T2.movieid` instead of querying only the `movies` table. Do change the genre filter to `T1.genre = 'Horror'` instead of `genre = 'horror'` and reference it from the joined table. Do use `T2.runningtime >= 2` instead of `running_time >= 2` while referencing the correct table. The amended query now correctly joins the necessary tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_id FROM movies WHERE genre = 'horror' AND running_time >= 2;",
            "SELECT T1.movieid FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T1.genre = 'Horror' AND T2.runningtime >= 2"
        ],
        "rule_sql": []
    },
    "6118": {
        "db_id": "food_inspection_2",
        "question": "Please list the assumed name of all the facilities that failed an inspection in 2010.",
        "ground_truth": "SELECT DISTINCT T2.dba_name FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE T1.results = 'Fail' AND strftime('%Y', T1.inspection_date) = '2010'",
        "amends": [
            "Do select `T2.dba_name` instead of `facility_name` and add `DISTINCT` instead of omitting it. Do use `inspection AS T1 INNER JOIN establishment AS T2` instead of just `inspections` and join on `T1.license_no = T2.license_no` instead of no join. Do filter on `T1.results = 'Fail'` instead of `result = 'pass'` and use `strftime('%Y', T1.inspection_date) = '2010'` instead of `inspection_year = 2010`. The amended query now correctly identifies establishments with failed inspections in 2010 by joining the inspection and establishment tables and using proper date extraction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT facility_name FROM inspections WHERE inspection_year = 2010 AND result = 'pass';",
            "SELECT DISTINCT T2.dba_name\nFROM inspection AS T1\nINNER JOIN establishment AS T2 ON T1.license_no = T2.license_no\nWHERE T1.results = 'Fail'\nAND strftime('%Y', T1.inspection_date) = '2010'"
        ],
        "rule_sql": []
    },
    "5700": {
        "db_id": "language_corpus",
        "question": "In Abadia, what is the word id of the of the Catalan language that appeared the highest amount of times? Indicate the how many times did they said word id appeared.",
        "ground_truth": "SELECT T2.wid, T2.occurrences FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T1.title = 'Abadia' ORDER BY T2.occurrences DESC LIMIT 1",
        "amends": [
            "Do select `T2.wid` and `T2.occurrences` instead of `word_id` and `COUNT(*) as count`. Do use `FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid` instead of `FROM words` with no join. Do apply filter `WHERE T1.title = 'Abadia'` instead of `WHERE language = 'Catalan' AND city = 'Abadia'`. Do remove `GROUP BY word_id` instead of keeping it since aggregation is no longer needed. Do keep `ORDER BY T2.occurrences DESC LIMIT 1` instead of ordering by the removed count column. The amended query now correctly retrieves word occurrences from joined tables using proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id, COUNT(*) as count \nFROM words \nWHERE language = 'Catalan' AND city = 'Abadia' \nGROUP BY word_id \nORDER BY count DESC \nLIMIT 1;",
            "SELECT T2.wid, T2.occurrences\nFROM pages AS T1 \nINNER JOIN pages_words AS T2 ON T1.pid = T2.pid\nWHERE T1.title = 'Abadia'\nORDER BY T2.occurrences DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3181": {
        "db_id": "donor",
        "question": "How many schools in urban area requested for books resources?",
        "ground_truth": "SELECT COUNT(T2.schoolid) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.resource_type = 'Books' AND T2.school_metro = 'urban'",
        "amends": [
            "Do select `COUNT(T2.schoolid)` from specific joined tables instead of `COUNT(*)` from a single table. Do join `resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid` instead of querying only the `schools` table. Do filter on `T2.resource_type = 'Books'` instead of using `LIKE '%books%'` pattern matching. Do filter on `T2.school_metro = 'urban'` instead of `area = 'urban'`. The amended query now correctly counts schools with book resources in urban areas by properly joining the resources and projects tables with precise filtering conditions.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the right query counts all school IDs rather than distinct values. Do maintain the same `INNER JOIN` on `T1.projectid = T2.projectid` and preserve the identical `WHERE` filters for `T2.resource_type = 'Books'` and `T2.school_metro = 'urban'`. The amended query now matches the right SQL's behavior by returning the total count of school IDs rather than counting distinct school IDs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE area = 'urban' AND resources_requested LIKE '%books%';",
            "SELECT COUNT(DISTINCT T2.schoolid) \nFROM resources AS T1 \nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid \nWHERE T2.resource_type = 'Books' \nAND T2.school_metro = 'urban'",
            "SELECT COUNT(T2.schoolid) \nFROM resources AS T1 \nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid \nWHERE T2.resource_type = 'Books' \nAND T2.school_metro = 'urban'"
        ],
        "rule_sql": []
    },
    "3697": {
        "db_id": "college_completion",
        "question": "How many institutes are private and not-for profit?",
        "ground_truth": "SELECT COUNT(*) FROM institution_details WHERE control = 'Private not-for-profit'",
        "amends": [
            "Do query the `institution_details` table instead of the `institutes` table. Do filter on `control = 'Private not-for-profit'` instead of `type = 'private' AND profit_status = 'for-profit'`. The amended query now correctly counts institutions based on the appropriate table and classification criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM institutes WHERE type = 'private' AND profit_status = 'for-profit';",
            "SELECT COUNT(*) FROM institution_details WHERE control = 'Private not-for-profit';"
        ],
        "rule_sql": []
    },
    "128": {
        "db_id": "movie_platform",
        "question": "Give the url of movie which was rated 5 on 2013/5/3 5:11:17.",
        "ground_truth": "SELECT T2.movie_url FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE rating_score = 5 AND rating_timestamp_utc LIKE '2013-05-03 05:11:17'",
        "amends": [
            "Do select `T2.movie_url` from the `ratings` table instead of `url` from the `movies` table. Do join `movies AS T2` with `ratings AS T1` using `INNER JOIN` on `T1.movie_id = T2.movie_id` instead of querying only the `movies` table without any join. Do filter on `rating_score = 5` instead of `rating = 5` to use the correct column name from the ratings table. Do use `rating_timestamp_utc LIKE '2013-05-03 05:11:17'` with proper date format and LIKE operator instead of `date = '2013/5/3 5:11:17'` with incorrect date format and equality comparison. The amended query now correctly joins the ratings and movies tables to find movies with specific ratings and timestamps, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT url FROM movies WHERE rating = 5 AND date = '2013/5/3 5:11:17';",
            "SELECT T2.movie_url \nFROM ratings AS T1 \nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id \nWHERE T1.rating_score = 5 \nAND T1.rating_timestamp_utc LIKE '2013-05-03 05:11:17'"
        ],
        "rule_sql": []
    },
    "7968": {
        "db_id": "music_platform_2",
        "question": "List all the cagetories for all the podcasts with \"jessica\" in the title.",
        "ground_truth": "SELECT category FROM categories WHERE podcast_id IN ( SELECT podcast_id FROM podcasts WHERE title LIKE '%jessica%' )",
        "amends": [
            "Do query the `categories` table instead of the `podcasts` table. Do use a subquery to filter by `podcast_id` instead of directly filtering categories. Do reference `podcast_id` in the subquery's SELECT list instead of omitting it. Do maintain the `LIKE '%jessica%'` filter on the `title` column in the subquery instead of removing it. The amended query now correctly retrieves categories associated with podcasts matching the title filter rather than attempting to get categories directly from the podcasts table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM podcasts WHERE title LIKE '%jessica%';",
            "SELECT category FROM categories WHERE podcast_id IN (SELECT podcast_id FROM podcasts WHERE title LIKE '%jessica%')"
        ],
        "rule_sql": []
    },
    "5649": {
        "db_id": "shipping",
        "question": "What is the annual revenue of Klett & Sons Repair?",
        "ground_truth": "SELECT annual_revenue FROM customer WHERE cust_name = 'Klett & Sons Repair'",
        "amends": [
            "Do select `annual_revenue` instead of `SUM(amount)` to retrieve the direct revenue value instead of attempting to aggregate. Do query from the `customer` table instead of the `revenue` table to access the correct data source containing customer revenue information. Do filter by `cust_name` instead of `company` to use the appropriate column name for customer identification. The amended query now correctly retrieves the annual revenue value directly from the customer table rather than attempting to sum amounts from a revenue table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM revenue WHERE company = 'Klett & Sons Repair'",
            "SELECT annual_revenue FROM customer WHERE cust_name = 'Klett & Sons Repair';"
        ],
        "rule_sql": []
    },
    "8764": {
        "db_id": "chicago_crime",
        "question": "Please list the case numbers of all the incidents with the generic description of \"BATTERY\" in the IUCR classification.",
        "ground_truth": "SELECT T2.case_number FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T1.primary_description = 'BATTERY'",
        "amends": [
            "Do add table `IUCR AS T1` and `Crime AS T2` with an `INNER JOIN` on `T1.iucr_no = T2.iucr_no` instead of querying only the `incidents` table. Do change the filter to `T1.primary_description = 'BATTERY'` instead of `description = 'BATTERY'` and qualify the column as `T2.case_number` instead of just `case_number`. The amended query now correctly joins the necessary tables to retrieve case numbers based on primary description matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT case_number FROM incidents WHERE description = 'BATTERY';",
            "SELECT T2.case_number FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T1.primary_description = 'BATTERY'"
        ],
        "rule_sql": []
    },
    "8479": {
        "db_id": "mondial_geo",
        "question": "What is the newest established organization where Singapore is a member of?",
        "ground_truth": "SELECT T3.Name FROM country AS T1 INNER JOIN isMember AS T2 ON T1.Code = T2.Country INNER JOIN organization AS T3 ON T3.Country = T2.Country WHERE T1.Name = 'Singapore' ORDER BY T3.Established DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `o` and `m`. Do reference `T3.Name` instead of `o.name` in the SELECT list. Do join `country AS T1` and `isMember AS T2` on `T1.Code = T2.Country` instead of directly joining `organizations` and `members`. Do add an additional `INNER JOIN` with `organization AS T3` on `T3.Country = T2.Country` instead of the single join. Do filter on `T1.Name = 'Singapore'` instead of `m.country = 'Singapore'`. Do order by `T3.Established DESC` instead of `o.established_date ASC`. The amended query now correctly retrieves organizations in Singapore through proper country-organization membership relationships.",
            "Do join `organization` on `T3.Country = T2.Country` instead of `T3.Abbreviation = T2.Organization` in the second INNER JOIN condition. The amended query now correctly matches the organization by country code rather than abbreviation, ensuring proper relationship between the country and its organizational memberships, and now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.name \nFROM organizations o \nJOIN members m ON o.id = m.organization_id \nWHERE m.country = 'Singapore' \nORDER BY o.established_date ASC \nLIMIT 1;",
            "SELECT T3.Name \nFROM country AS T1\nINNER JOIN isMember AS T2 ON T1.Code = T2.Country\nINNER JOIN organization AS T3 ON T3.Abbreviation = T2.Organization\nWHERE T1.Name = 'Singapore'\nORDER BY T3.Established DESC\nLIMIT 1;",
            "SELECT T3.Name \nFROM country AS T1\nINNER JOIN isMember AS T2 ON T1.Code = T2.Country\nINNER JOIN organization AS T3 ON T3.Country = T2.Country\nWHERE T1.Name = 'Singapore'\nORDER BY T3.Established DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6798": {
        "db_id": "retails",
        "question": "What percentage of customers engaged in the household segment are from Iran?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.n_name = 'IRAN', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T1.c_mktsegment = 'HOUSEHOLD'",
        "amends": [
            "Do use `SUM(IIF(T2.n_name = 'IRAN', 1, 0))` instead of `COUNT(CASE WHEN country = 'Iran' THEN 1 END)` for conditional counting. Do join `nation AS T2` on `T1.c_nationkey = T2.n_nationkey` instead of querying only the customers table. Do reference `T2.n_name` for the country check instead of `country`. Do use `T1.c_mktsegment = 'HOUSEHOLD'` instead of `segment = 'household'` for the segment filter. Do cast the sum to `REAL` instead of using `100.0` for floating-point division. Do calculate the percentage using multiplication and division instead of a single expression. The amended query now correctly joins customer and nation tables to identify Iranian customers and calculates the accurate percentage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN country = 'Iran' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM customers\nWHERE segment = 'household';",
            "SELECT \n    (SUM(IIF(T2.n_name = 'IRAN', 1, 0)) * 100.0 / COUNT(*)) AS percentage\nFROM \n    customer AS T1\nJOIN \n    nation AS T2 ON T1.c_nationkey = T2.n_nationkey\nWHERE \n    T1.c_mktsegment = 'HOUSEHOLD'"
        ],
        "rule_sql": []
    },
    "8328": {
        "db_id": "mondial_geo",
        "question": "Calculate the percentage of population in Edmonton city to the population of its province.",
        "ground_truth": "SELECT CAST(T1.Population AS REAL) * 100 / T2.Population FROM city AS T1 INNER JOIN province AS T2 ON T1.Province = T2.Name WHERE T1.Name = 'Edmonton'",
        "amends": [
            "Do use `CAST(T1.Population AS REAL)` instead of `city.population` to ensure floating-point division. Do reference `T2.Population` instead of `province.population` for the denominator. Do use table aliases `T1` and `T2` instead of direct table names. Do join on `T1.Province = T2.Name` instead of `city.province_id = province.id` to match by province name rather than ID. Do calculate `* 100 / T2.Population` instead of `/ province.population) * 100` to properly compute the percentage. The amended query now correctly calculates the percentage using floating-point division and proper join conditions to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (city.population / province.population) * 100 AS percentage\nFROM city\nJOIN province ON city.province_id = province.id\nWHERE city.name = 'Edmonton';",
            "SELECT (CAST(T1.Population AS REAL) * 100 / T2.Population) AS percentage\nFROM city T1\nJOIN province T2 ON T1.Province = T2.Name\nWHERE T1.Name = 'Edmonton';"
        ],
        "rule_sql": []
    },
    "2855": {
        "db_id": "professional_basketball",
        "question": "In 1937, how many teams whose players got at least 500 points?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.name, SUM(T1.points) FROM players_teams AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = 1937 GROUP BY T2.name HAVING SUM(points) >= 500 ) AS T3",
        "amends": [
            "Do join `players_teams` with `teams` on `tmID` and `year` instead of querying `teams` alone. Do aggregate `SUM(points)` instead of counting all rows. Do group by `name` instead of no grouping. Do filter aggregated points with `HAVING SUM(points) >= 500` instead of filtering individual rows with `WHERE points >= 500`. Do use a subquery to count qualifying teams instead of counting directly from the base table. The amended query now correctly counts teams with total player points reaching 500 in 1937 instead of incorrectly counting teams with individual points of 500 or more."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM teams WHERE year = 1937 AND points >= 500;",
            "SELECT COUNT(*) AS team_count\nFROM (\n    SELECT t.name\n    FROM players_teams pt\n    JOIN teams t ON pt.tmID = t.tmID AND pt.year = t.year\n    WHERE pt.year = 1937\n    GROUP BY t.name\n    HAVING SUM(pt.points) >= 500\n) AS qualifying_teams"
        ],
        "rule_sql": []
    },
    "805": {
        "db_id": "social_media",
        "question": "What is the gender of the user who tweeted `tw-715909161071091712`?",
        "ground_truth": "SELECT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.TweetID = 'tw-715909161071091712'",
        "amends": [
            "Do select `T2.Gender` from the `user` table instead of `gender` from the `users` table. Do join `twitter AS T1` with `user AS T2` using `INNER JOIN` on `T1.UserID = T2.UserID` instead of querying a single table. Do filter on `T1.TweetID` instead of `tweet_id` and use the correct table alias and column name. The amended query now correctly retrieves gender information by joining the twitter and user tables on their relationship through UserID, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE tweet_id = 'tw-715909161071091712';",
            "SELECT T2.Gender \nFROM twitter AS T1 \nINNER JOIN user AS T2 ON T1.UserID = T2.UserID \nWHERE T1.TweetID = 'tw-715909161071091712'"
        ],
        "rule_sql": []
    },
    "5797": {
        "db_id": "language_corpus",
        "question": "Which word has the most appearances in the Wikipedia page with the title of \"Agricultura\"? Give the word ID.",
        "ground_truth": "SELECT T2.wid FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T1.title = 'Agricultura' ORDER BY T2.occurrences DESC LIMIT 1",
        "amends": [
            "Do select `T2.wid` from the `pages_words` table instead of `word_id` from the `words` table. Do join `pages AS T1` with `pages_words AS T2` using `INNER JOIN` on `T1.pid = T2.pid` instead of querying only the `words` table. Do filter on `T1.title = 'Agricultura'` instead of `page_title = 'Agricultura'`. Do order by `T2.occurrences DESC` instead of `appearances DESC`. The amended query now correctly retrieves the word ID from the join table using proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id FROM words WHERE page_title = 'Agricultura' ORDER BY appearances DESC LIMIT 1;",
            "SELECT T2.wid \nFROM pages AS T1 \nINNER JOIN pages_words AS T2 ON T1.pid = T2.pid \nWHERE T1.title = 'Agricultura' \nORDER BY T2.occurrences DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2434": {
        "db_id": "superstore",
        "question": "How many of the \"Hon Pagoda Stacking Chairs\" have been sold in total in the west superstore?",
        "ground_truth": "SELECT SUM(T1.Quantity) FROM west_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Product Name` = 'Hon Pagoda Stacking Chairs'",
        "amends": [
            "Do use `SUM(T1.Quantity)` instead of `COUNT(*)` to calculate total quantity rather than row count. Do join `west_superstore AS T1` with `product AS T2` on `T1.Product ID = T2.Product ID` instead of querying a single `sales` table. Do filter on `T2.Product Name = 'Hon Pagoda Stacking Chairs'` instead of filtering both `product_name` and `region` columns. Do remove the `region = 'west'` filter entirely since the `west_superstore` table inherently contains only west region data. The amended query now correctly calculates the total quantity of the specified product from the west region by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE product_name = 'Hon Pagoda Stacking Chairs' AND region = 'west'",
            "SELECT SUM(T1.Quantity) AS total_quantity\nFROM west_superstore AS T1\nJOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\"\nWHERE T2.\"Product Name\" = 'Hon Pagoda Stacking Chairs'"
        ],
        "rule_sql": []
    },
    "2093": {
        "db_id": "world_development_indicators",
        "question": "Please list the countries in Latin America & Caribbean with a note on the series code SM.POP.TOTL.",
        "ground_truth": "SELECT T1.SHORTNAME, T2.Description FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.Region = 'Latin America & Caribbean' AND T2.Seriescode = 'SM.POP.TOTL'",
        "amends": [
            "Do select `T1.SHORTNAME` and `T2.Description` instead of just `country_name`. Do join `Country AS T1` with `CountryNotes AS T2` using `INNER JOIN` on `T1.CountryCode = T2.Countrycode` instead of querying a single table. Do filter on `T1.Region = 'Latin America & Caribbean'` instead of `region` and `T2.Seriescode = 'SM.POP.TOTL'` instead of `series_code`. The amended query now correctly joins the Country and CountryNotes tables to retrieve both the country short name and description for the specified region and series code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE region = 'Latin America & Caribbean' AND series_code = 'SM.POP.TOTL';",
            "SELECT T1.ShortName, T2.Description \nFROM Country AS T1 \nINNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode \nWHERE T1.Region = 'Latin America & Caribbean' \nAND T2.Seriescode = 'SM.POP.TOTL'"
        ],
        "rule_sql": []
    },
    "4200": {
        "db_id": "simpson_episodes",
        "question": "How many times was Ian Maxtone-Graham nominated for an award in Writers Guild of America, USA?",
        "ground_truth": "SELECT COUNT(award_id) FROM Award WHERE person = 'Ian Maxtone-Graham' AND organization = 'Writers Guild of America, USA' AND result = 'Nominee';",
        "amends": [
            "Do select `COUNT(award_id)` from the `Award` table instead of `COUNT(*)` from the `nominations` table. Do use filter conditions `person = 'Ian Maxtone-Graham'` and `organization = 'Writers Guild of America, USA'` instead of `nominee = 'Ian Maxtone-Graham'` and `award = 'Writers Guild of America, USA'`. Do add the additional filter `result = 'Nominee'` instead of omitting it. The amended query now correctly counts award nominations for the specified person and organization while filtering for nominee results only."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM nominations WHERE nominee = 'Ian Maxtone-Graham' AND award = 'Writers Guild of America, USA';",
            "SELECT COUNT(award_id) FROM Award WHERE person = 'Ian Maxtone-Graham' AND organization = 'Writers Guild of America, USA' AND result = 'Nominee'"
        ],
        "rule_sql": []
    },
    "5696": {
        "db_id": "language_corpus",
        "question": "In the Catalan language, which biwords pair appeared the most in this language/page?",
        "ground_truth": "SELECT w1st, w2nd FROM biwords WHERE occurrences = ( SELECT MAX(occurrences) FROM biwords )",
        "amends": [
            "Do select `w1st, w2nd` instead of `biword1, biword2, COUNT(*) as frequency` and remove the `GROUP BY` clause. Do remove the `language = 'Catalan'` filter instead of keeping it. Do change the ordering mechanism to use a subquery that finds `MAX(occurrences)` instead of using `ORDER BY frequency DESC LIMIT 1`. Do remove the explicit `ORDER BY` and `LIMIT` clauses since the subquery handles the maximum occurrence logic. The amended query now correctly retrieves the biword pair with the highest occurrences by comparing against the maximum value in the occurrences column rather than counting frequencies and limiting results.",
            "Do remove the `lid` filter condition referencing the Catalan language lookup instead of including it, as the maximum occurrences should be calculated across all languages rather than being language-specific. Do simplify the subquery to find the global maximum occurrences with `MAX(occurrences) FROM biwords` instead of constraining it to a specific language. Do eliminate the nested subquery that retrieves the language ID from the langs table instead of maintaining this unnecessary correlation. The amended query now correctly identifies the most frequent bigrams across all languages rather than within a single language, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT biword1, biword2, COUNT(*) as frequency FROM biwords WHERE language = 'Catalan' GROUP BY biword1, biword2 ORDER BY frequency DESC LIMIT 1;",
            "SELECT w1st, w2nd\nFROM biwords\nWHERE lid = (SELECT lid FROM langs WHERE lang = 'Catalan')\nAND occurrences = (SELECT MAX(occurrences) FROM biwords WHERE lid = (SELECT lid FROM langs WHERE lang = 'Catalan'))",
            "SELECT w1st, w2nd FROM biwords WHERE occurrences = (SELECT MAX(occurrences) FROM biwords)"
        ],
        "rule_sql": []
    },
    "2527": {
        "db_id": "app_store",
        "question": "Which apps have not been updated since year 2015 and what kind of sentiment users hold on it?",
        "ground_truth": "SELECT DISTINCT App, Sentiment FROM user_reviews WHERE App IN ( SELECT App FROM playstore WHERE CAST(SUBSTR('Last Updated', -4, 4) AS INTEGER) < 2015 )",
        "amends": [
            "Do select `App` and `Sentiment` instead of `app_name` and `sentiment`. Do use `DISTINCT` instead of omitting it. Do query from `user_reviews` instead of `apps`. Do add a subquery filter with `App IN (SELECT App FROM playstore)` instead of a direct WHERE condition. Do use `CAST(SUBSTR('Last Updated', -4, 4) AS INTEGER) < 2015` for date filtering instead of `last_updated >= '2015-01-01'`. Do remove the explicit `IS NOT NULL` check instead of keeping it. The amended query now correctly filters for apps last updated before 2015 and returns distinct app-sentiment pairs from user reviews."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name, sentiment \nFROM apps \nWHERE last_updated >= '2015-01-01' \nAND sentiment IS NOT NULL;",
            "SELECT DISTINCT App, Sentiment\nFROM user_reviews\nWHERE App IN (\n    SELECT App \n    FROM playstore \n    WHERE CAST(SUBSTR('Last Updated', -4, 4) AS INTEGER) < 2015\n)"
        ],
        "rule_sql": []
    },
    "4344": {
        "db_id": "simpson_episodes",
        "question": "What is the name of actor who took the role Smithers?",
        "ground_truth": "SELECT DISTINCT T1.person FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T2.character = 'Smithers';",
        "amends": [
            "Do select `DISTINCT T1.person` instead of `actor_name` from a different table. Do use `Award` and `Character_Award` tables with an `INNER JOIN` on `T1.award_id = T2.award_id` instead of querying only the `actors` table. Do filter on `T2.character = 'Smithers'` instead of `role = 'Smithers'` to correctly identify the character relationship through the award association. The amended query now properly retrieves distinct persons who received awards for the Smithers character instead of incorrectly querying actor names directly from an actors table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE role = 'Smithers';",
            "SELECT DISTINCT T1.person\nFROM Award T1\nINNER JOIN Character_Award T2 ON T1.award_id = T2.award_id\nWHERE T2.character = 'Smithers'"
        ],
        "rule_sql": []
    },
    "45": {
        "db_id": "movie_platform",
        "question": "How many movies have a popularity of more than 400 but less than 500? Indicate the name of the movies and the highest rating score each movie has received.",
        "ground_truth": "SELECT T1.movie_title, MAX(T2.rating_score) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T1.movie_popularity BETWEEN 400 AND 500 GROUP BY T1.movie_title",
        "amends": [
            "Do join `ratings AS T2` on `T1.movie_id = T2.movie_id` instead of querying only the `movies` table. Do reference `T1.movie_title` and `T2.rating_score` instead of `title` and `rating`. Do use `T1.movie_popularity BETWEEN 400 AND 500` instead of `popularity > 400 AND popularity < 500`. Do add table aliases `T1` and `T2` instead of omitting them. The amended query now correctly joins the ratings table to access rating scores and uses proper column references with table aliases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MAX(rating) FROM movies WHERE popularity > 400 AND popularity < 500 GROUP BY title;",
            "SELECT T1.movie_title, MAX(T2.rating_score) AS highest_rating\nFROM movies AS T1\nJOIN ratings AS T2 ON T1.movie_id = T2.movie_id\nWHERE T1.movie_popularity BETWEEN 400 AND 500\nGROUP BY T1.movie_id, T1.movie_title"
        ],
        "rule_sql": []
    },
    "7980": {
        "db_id": "music_platform_2",
        "question": "Which category is the podcast \"Scaling Global\" under?",
        "ground_truth": "SELECT category FROM categories WHERE podcast_id IN ( SELECT podcast_id FROM podcasts WHERE title = 'Scaling Global' )",
        "amends": [
            "Do query the `categories` table instead of the `podcasts` table. Do use a subquery to filter by `podcast_id` instead of directly filtering by `title`. Do add the subquery `SELECT podcast_id FROM podcasts WHERE title = 'Scaling Global'` instead of omitting it. Do reference `podcast_id` in the `IN` clause instead of directly using `title` in the main query. The amended query now correctly retrieves categories by first finding the podcast ID from the podcasts table and then using that to filter the categories table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM podcasts WHERE title = 'Scaling Global';",
            "SELECT category FROM categories WHERE podcast_id IN (SELECT podcast_id FROM podcasts WHERE title = 'Scaling Global')"
        ],
        "rule_sql": []
    },
    "5523": {
        "db_id": "menu",
        "question": "Calculate the total price of items for menu with ID 12882.",
        "ground_truth": "SELECT SUM(T2.price) FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id WHERE T1.menu_id = 12882",
        "amends": [
            "Do join `MenuPage AS T1` and `MenuItem AS T2` with `INNER JOIN` on `T1.id = T2.menu_page_id` instead of querying `items` table directly. Do reference `SUM(T2.price)` from the joined table instead of `SUM(price)` from a single table. Do filter on `T1.menu_id = 12882` through the joined MenuPage table instead of filtering directly on menu_id in the items table. The amended query now correctly aggregates prices from menu items belonging to the specified menu through the proper table relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM items WHERE menu_id = 12882",
            "SELECT SUM(T2.price) AS total_price\nFROM MenuPage AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id\nWHERE T1.menu_id = 12882"
        ],
        "rule_sql": []
    },
    "1917": {
        "db_id": "soccer_2016",
        "question": "In what year did SP Narine win the Orange Cap?",
        "ground_truth": "SELECT T4.Season_Year, T4.Orange_Cap FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id INNER JOIN Season AS T4 ON T3.Season_Id = T4.Season_Id WHERE T1.Player_Name = 'SP Narine' GROUP BY T4.Season_Year, T4.Orange_Cap",
        "amends": [
            "Do select `T4.Season_Year` and `T4.Orange_Cap` instead of just `year`. Do join from `Player` table instead of querying `players` table directly. Do add `INNER JOIN` on `Player_Match` with `T1.Player_Id = T2.Player_Id` instead of missing this relationship. Do add `INNER JOIN` on `Match` with `T2.Match_Id = T3.Match_Id` instead of omitting match data. Do add `INNER JOIN` on `Season` with `T3.Season_Id = T4.Season_Id` instead of not connecting to season information. Do filter on `T1.Player_Name` instead of `name` and maintain the 'SP Narine' condition. Do add `GROUP BY T4.Season_Year, T4.Orange_Cap` instead of omitting grouping. Do remove the `award = 'Orange Cap'` filter instead of keeping it, as the Orange Cap status is now properly retrieved from the Season table. The amended query now correctly joins through the necessary relationship tables to identify seasons where the player won the Orange Cap award."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM players WHERE name = 'SP Narine' AND award = 'Orange Cap';",
            "SELECT T4.Season_Year, T4.Orange_Cap\nFROM Player T1\nINNER JOIN Player_Match T2 ON T1.Player_Id = T2.Player_Id\nINNER JOIN Match T3 ON T2.Match_Id = T3.Match_Id\nINNER JOIN Season T4 ON T3.Season_Id = T4.Season_Id\nWHERE T1.Player_Name = 'SP Narine'\nGROUP BY T4.Season_Year, T4.Orange_Cap"
        ],
        "rule_sql": []
    },
    "5001": {
        "db_id": "olympics",
        "question": "Give the id of the event \"Shooting Mixed Skeet\".",
        "ground_truth": "SELECT id FROM event WHERE event_name = 'Shooting Mixed Skeet'",
        "amends": [
            "Do reference the `id` column instead of `event_id` from the events table. Do use the correct table name `event` instead of `events` while keeping the same `WHERE` filter condition on `event_name = 'Shooting Mixed Skeet'`. The amended query now correctly selects the identifier column from the proper table while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_id FROM events WHERE event_name = 'Shooting Mixed Skeet'",
            "SELECT id FROM event WHERE event_name = 'Shooting Mixed Skeet';"
        ],
        "rule_sql": []
    },
    "8282": {
        "db_id": "mondial_geo",
        "question": "Which city in Japan has the most people in the country?",
        "ground_truth": "SELECT T2.Name FROM country AS T1 INNER JOIN city AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Japan' ORDER BY T2.Population DESC LIMIT 1",
        "amends": [
            "Do select `T2.Name` from the city table instead of `city` from the cities table. Do join `country AS T1` with `city AS T2` using `T1.Code = T2.Country` instead of querying a single table. Do filter on `T1.Name = 'Japan'` instead of `country = 'Japan'`. Do order by `T2.Population DESC` instead of `population DESC`. The amended query now correctly retrieves the largest city in Japan by joining the country and city tables with proper foreign key relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities WHERE country = 'Japan' ORDER BY population DESC LIMIT 1;",
            "SELECT T2.Name \nFROM country AS T1 \nJOIN city AS T2 ON T1.Code = T2.Country \nWHERE T1.Name = 'Japan' \nORDER BY T2.Population DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5160": {
        "db_id": "address",
        "question": "What is the country and state of the city named Dalton?",
        "ground_truth": "SELECT T2.county FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code WHERE T3.city = 'Dalton' GROUP BY T2.county",
        "amends": [
            "Do select `T2.county` instead of `country, state`. Do use `FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code` instead of `FROM cities`. Do filter with `T3.city = 'Dalton'` instead of `name = 'Dalton'`. Do add `GROUP BY T2.county` instead of omitting it. The amended query now correctly joins multiple tables to find the county associated with a city name, matching the intended behavior.",
            "Do remove `T2.state` from the SELECT list instead of including it, as the GROUP BY clause only groups by `T2.county` making the state column redundant and potentially causing incorrect aggregation behavior. The amended query now correctly matches RIGHT_SQL's behavior by selecting only the county column that is properly grouped."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, state FROM cities WHERE name = 'Dalton';",
            "SELECT T2.county, T2.state FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code WHERE T3.city = 'Dalton' GROUP BY T2.county",
            "SELECT T2.county FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state INNER JOIN zip_data AS T3 ON T2.zip_code = T3.zip_code WHERE T3.city = 'Dalton' GROUP BY T2.county"
        ],
        "rule_sql": []
    },
    "3139": {
        "db_id": "cars",
        "question": "How many American cars have an acceleration time of less than 12 seconds?",
        "ground_truth": "SELECT COUNT(*) FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'USA' AND T1.acceleration < 12",
        "amends": [
            "Do add `INNER JOIN production AS T2 ON T1.ID = T2.ID` and `INNER JOIN country AS T3 ON T3.origin = T2.country` instead of querying a single table. Do change the table reference from `cars` to `data AS T1` instead of using the original table name. Do change the filter condition from `acceleration > 12` to `T1.acceleration < 12` instead of using the greater than operator. Do change the country filter from `country = 'USA'` to `T3.country = 'USA'` instead of filtering on the original table's country column. The amended query now correctly joins multiple tables and applies the proper filtering conditions to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'USA' AND acceleration > 12;",
            "SELECT COUNT(*) \nFROM data AS T1\nINNER JOIN production AS T2 ON T1.ID = T2.ID\nINNER JOIN country AS T3 ON T3.origin = T2.country\nWHERE T1.acceleration < 12\nAND T3.country = 'USA'"
        ],
        "rule_sql": []
    },
    "5400": {
        "db_id": "sales",
        "question": "What is the average number of customers per sales person?",
        "ground_truth": "SELECT CAST(COUNT(T1.CustomerID) AS REAL) / COUNT(T3.EmployeeID) FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID",
        "amends": [
            "Do use `CAST(COUNT(T1.CustomerID) AS REAL) / COUNT(T3.EmployeeID)` instead of `AVG(customer_count)` to calculate the ratio of customers to employees. Do join `Customers AS T1` with `Sales AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying only the customers table. Do add `INNER JOIN Employees AS T3` on `T2.SalesPersonID = T3.EmployeeID` instead of omitting both Sales and Employees tables. Do remove the subquery and GROUP BY clause instead of keeping them, as the correct logic requires joining across multiple tables to establish the relationship between customers and sales employees. The amended query now correctly calculates the customer-to-employee ratio by properly joining all relevant tables.",
            "Do remove `DISTINCT` from `COUNT(T1.CustomerID)` instead of keeping `COUNT(DISTINCT T1.CustomerID)` and do remove `DISTINCT` from `COUNT(T3.EmployeeID)` instead of keeping `COUNT(DISTINCT T3.EmployeeID)`. Do omit the alias `AS AverageCustomersPerSalesPerson` instead of including it. The amended query now correctly calculates the ratio of total customers to total employees involved in sales without unnecessary distinct counts and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(customer_count) FROM (SELECT COUNT(*) as customer_count FROM customers GROUP BY sales_person_id);",
            "SELECT CAST(COUNT(DISTINCT T1.CustomerID) AS REAL) / COUNT(DISTINCT T3.EmployeeID) AS AverageCustomersPerSalesPerson\nFROM Customers AS T1\nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID;",
            "SELECT CAST(COUNT(T1.CustomerID) AS REAL) / COUNT(T3.EmployeeID) \nFROM Customers AS T1 \nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID \nINNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID"
        ],
        "rule_sql": []
    },
    "9325": {
        "db_id": "movie_3",
        "question": "Give the full name of the actor with the highest rental rate.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T3.film_id = T2.film_id ORDER BY T3.rental_rate DESC LIMIT 1",
        "amends": [
            "Do add joins to `film_actor` and `film` tables instead of querying only the `actor` table. Do reference `T3.rental_rate` in the ORDER BY instead of the non-existent `rental_rate` column from the actor table. Do use table aliases `T1`, `T2`, and `T3` for clarity instead of no aliases. Do specify the join conditions `T1.actor_id = T2.actor_id` and `T3.film_id = T2.film_id` to properly link the tables instead of missing the necessary relationships. The amended query now correctly retrieves actors based on film rental rates rather than attempting to order by a non-existent column, matching the RIGHT_SQL's behavior.",
            "Do select `first_name` and `last_name` as separate columns instead of concatenating them into `full_name`. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do specify the join condition as `T3.film_id = T2.film_id` instead of `T2.film_id = T3.film_id` to maintain consistent directionality. The amended query now correctly returns separate name columns while preserving the join logic and ordering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM actor ORDER BY rental_rate DESC LIMIT 1;",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM actor T1\nJOIN film_actor T2 ON T1.actor_id = T2.actor_id\nJOIN film T3 ON T2.film_id = T3.film_id\nORDER BY T3.rental_rate DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM actor T1\nINNER JOIN film_actor T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film T3 ON T3.film_id = T2.film_id\nORDER BY T3.rental_rate DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1098": {
        "db_id": "talkingdata",
        "question": "Among all the users who use a vivo device, what is the percentage of the users in the M23-26 user group?",
        "ground_truth": "SELECT SUM(IIF(T1.`group` = 'M23-26', 1.0, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "amends": [
            "Do use `SUM(IIF(T1.group = 'M23-26', 1.0, 0)) / COUNT(T1.device_id)` instead of `(COUNT(CASE WHEN user_group = 'M23-26' THEN 1 END) * 100.0 / COUNT(*))` for the percentage calculation. Do join `gender_age AS T1` with `phone_brand_device_model2 AS T2` on `T1.device_id = T2.device_id` instead of querying only the `users` table. Do filter on `T2.phone_brand = 'vivo'` instead of `device = 'vivo'`. Do reference `T1.device_id` in the count instead of using `COUNT(*)`. The amended query now correctly calculates the percentage of users in the M23-26 group among vivo phone brand users by properly joining the relevant tables and using appropriate aggregation logic.",
            "Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do remove the `* 100.0` multiplication from the percentage calculation instead of including it. Do change the alias from `percentage` to `per` instead of keeping the original name. Do add backticks around the reserved word `group` as `group` instead of leaving it unquoted. The amended query now correctly calculates the proportion without scaling to percentage and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN user_group = 'M23-26' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM users\nWHERE device = 'vivo';",
            "SELECT \n    SUM(IIF(T1.group = 'M23-26', 1.0, 0)) / COUNT(T1.device_id) * 100.0 AS percentage\nFROM \n    gender_age AS T1\nJOIN \n    phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE \n    T2.phone_brand = 'vivo'",
            "SELECT SUM(IIF(T1.`group` = 'M23-26', 1.0, 0)) / COUNT(T1.device_id) AS per\nFROM gender_age AS T1\nINNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE T2.phone_brand = 'vivo'"
        ],
        "rule_sql": []
    },
    "1287": {
        "db_id": "law_episode",
        "question": "In which organization did Constantine Makris win the most awards?",
        "ground_truth": "SELECT T2.organization FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T1.name = 'Constantine Makris' AND T2.result = 'Winner' GROUP BY T2.organization ORDER BY COUNT(T2.award_id) DESC LIMIT 1",
        "amends": [
            "Do join `Person AS T1` and `Award AS T2` on `T1.person_id = T2.person_id` instead of querying only the `awards` table. Do filter by `T1.name = 'Constantine Makris'` and `T2.result = 'Winner'` instead of just `winner = 'Constantine Makris'`. Do select `T2.organization` instead of both `organization` and `COUNT(*) as award_count`. Do group by `T2.organization` instead of just `organization`. Do order by `COUNT(T2.award_id) DESC` instead of `award_count DESC`. The amended query now correctly joins the Person and Award tables, applies proper winner filtering, and counts specific award IDs to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization, COUNT(*) as award_count \nFROM awards \nWHERE winner = 'Constantine Makris' \nGROUP BY organization \nORDER BY award_count DESC \nLIMIT 1;",
            "SELECT T2.organization\nFROM Person AS T1\nJOIN Award AS T2 ON T1.person_id = T2.person_id\nWHERE T1.name = 'Constantine Makris' AND T2.result = 'Winner'\nGROUP BY T2.organization\nORDER BY COUNT(T2.award_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6079": {
        "db_id": "books",
        "question": "What is the average of English books among all books published by Carole Marsh Mysteries?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.language_name = 'English' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) FROM book_language AS T1 INNER JOIN book AS T2 ON T1.language_id = T2.language_id INNER JOIN publisher AS T3 ON T3.publisher_id = T2.publisher_id WHERE T3.publisher_name = 'Carole Marsh Mysteries'",
        "amends": [
            "Do calculate the percentage of English books instead of averaging a non-existent `english_books` column. Do join `book_language` as `T1` and `book` as `T2` on `T1.language_id = T2.language_id` instead of querying only the `books` table. Do join `publisher` as `T3` on `T3.publisher_id = T2.publisher_id` instead of omitting publisher table joins. Do filter on `T3.publisher_name = 'Carole Marsh Mysteries'` instead of `publisher = 'Carole Marsh Mysteries'`. Do use `SUM(CASE WHEN T1.language_name = 'English' THEN 1 ELSE 0 END) / COUNT(*)` with a `CAST` to `REAL` instead of `AVG(english_books)` to properly calculate the English book ratio. The amended query now correctly computes the proportion of English books for the specified publisher."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(english_books) FROM books WHERE publisher = 'Carole Marsh Mysteries';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.language_name = 'English' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS english_book_percentage\nFROM \n    book_language T1\nJOIN \n    book T2 ON T1.language_id = T2.language_id\nJOIN \n    publisher T3 ON T3.publisher_id = T2.publisher_id\nWHERE \n    T3.publisher_name = 'Carole Marsh Mysteries';"
        ],
        "rule_sql": []
    },
    "230": {
        "db_id": "book_publishing_company",
        "question": "Find and list the full name of employees who were hired between 1990 and 1995. Also, arrange them in the descending order of job level.",
        "ground_truth": "SELECT fname, minit, lname FROM employee WHERE STRFTIME('%Y', hire_date) BETWEEN '1990' AND '1995' ORDER BY job_lvl DESC",
        "amends": [
            "Do select `fname`, `minit`, `lname` instead of `first_name`, `last_name`. Do use `STRFTIME('%Y', hire_date)` to extract year instead of direct date range comparison. Do filter years between `'1990'` and `'1995'` instead of the inverted date range `'1995-01-01'` and `'1990-12-31'`. Do order by `job_lvl DESC` instead of `job_level ASC`. Do reference table `employee` instead of `employees`. The amended query now correctly extracts hire years and uses proper date range filtering with descending job level ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE hire_date BETWEEN '1995-01-01' AND '1990-12-31' ORDER BY job_level ASC;",
            "SELECT fname, minit, lname FROM employee WHERE STRFTIME('%Y', hire_date) BETWEEN '1990' AND '1995' ORDER BY job_lvl DESC;"
        ],
        "rule_sql": []
    },
    "2080": {
        "db_id": "music_tracker",
        "question": "How many singles were released between 1979 and 1981 labeled as \"soul\"?",
        "ground_truth": "SELECT COUNT(T2.tag) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'soul' AND T1.groupYear BETWEEN 1979 AND 1981 AND T1.releaseType LIKE 'single'",
        "amends": [
            "Do select `COUNT(T2.tag)` from `torrents AS T1` instead of `COUNT(*)` from `singles`. Do use `INNER JOIN tags AS T2` with `ON T1.id = T2.id` instead of querying a single table. Do filter with `T2.tag = 'soul'` and `T1.groupYear BETWEEN 1979 AND 1981` and `T1.releaseType LIKE 'single'` instead of `genre = 'soul'` and `release_year BETWEEN 1979 AND 1981`. The amended query now correctly counts soul tags from single releases between 1979-1981 by joining torrents and tags tables with proper correlation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM singles WHERE release_year BETWEEN 1979 AND 1981 AND genre = 'soul';",
            "SELECT COUNT(T2.tag) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'soul' AND T1.groupYear BETWEEN 1979 AND 1981 AND T1.releaseType LIKE 'single'"
        ],
        "rule_sql": []
    },
    "663": {
        "db_id": "codebase_comments",
        "question": "What is the task of method number 2?",
        "ground_truth": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE Id = 2",
        "amends": [
            "Do select only the extracted task name using nested `SUBSTR` and `INSTR` functions instead of selecting all columns with `*`. Do filter by `Id = 2` instead of `method_number = 2`. Do use table name `Method` instead of `methods`. The amended query now correctly extracts the task name component from the Name field for the specific method ID.",
            "Do use nested `SUBSTR` functions to extract only the first segment after the initial dot instead of extracting all text after the first dot. Do add a second `INSTR` to find the position of the next dot within the extracted substring instead of omitting this boundary detection. Do specify length parameter `1, INSTR(...)-1` in the outer `SUBSTR` to truncate at the second dot instead of taking the entire remaining string. Do use alias `task` instead of `TaskName` for the result column. The amended query now correctly extracts only the task name portion between the first and second dots instead of potentially including multiple dot-separated segments, matching the RIGHT_SQL's behavior.",
            "Do use `SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)` for the task extraction instead of `SUBSTR(Name, 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)` to properly handle the nested substring operation. Do maintain the same `WHERE Id = 2` filter and `task` column alias instead of changing them. The amended query now correctly extracts the substring between the first and second dots by first isolating the portion after the first dot before applying the second substring operation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM methods WHERE method_number = 2;",
            "SELECT SUBSTR(Name, INSTR(Name, '.') + 1) AS TaskName FROM Method WHERE Id = 2;",
            "SELECT SUBSTR(Name, 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) AS task FROM Method WHERE Id = 2;",
            "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) AS task FROM Method WHERE Id = 2;"
        ],
        "rule_sql": []
    },
    "5234": {
        "db_id": "beer_factory",
        "question": "Please list the names of all the root beer brands that are advertised on facebook.",
        "ground_truth": "SELECT BrandName FROM rootbeerbrand WHERE FacebookPage IS NOT NULL",
        "amends": [
            "Do reference the `BrandName` column instead of `brand_name` and use the correct table name `rootbeerbrand` instead of `root_beer_brands`. Do check for `FacebookPage IS NOT NULL` instead of filtering on `advertised_on = 'facebook'` to properly identify brands with an active Facebook presence rather than those merely advertised on the platform. The amended query now correctly returns brands that have Facebook pages rather than those advertised on Facebook, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand_name FROM root_beer_brands WHERE advertised_on = 'facebook';",
            "SELECT BrandName FROM rootbeerbrand WHERE FacebookPage IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "2477": {
        "db_id": "shooting",
        "question": "How many incidents in which the subject's weapon was a vehicle were investigated by a female officer?",
        "ground_truth": "SELECT COUNT(T1.case_number) FROM incidents AS T1 INNER JOIN officers AS T2 ON T1.case_number = T2.case_number WHERE T1.subject_weapon = 'Vehicle' AND T2.gender = 'F'",
        "amends": [
            "Do use `COUNT(T1.case_number)` instead of `COUNT(*)` to count specific case numbers rather than all rows. Do join on `T1.case_number = T2.case_number` instead of `i.officer_id = o.officer_id` to properly relate incidents to officers through case numbers. Do use `'Vehicle'` instead of `'vehicle'` for case-sensitive subject_weapon matching. Do use `'F'` instead of `'female'` for gender value consistency. The amended query now correctly counts incidents involving vehicles with female officers using proper case number relationships and standardized value formats."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM incidents i\nJOIN officers o ON i.officer_id = o.officer_id\nWHERE i.subject_weapon = 'vehicle' \nAND o.gender = 'female';",
            "SELECT COUNT(T1.case_number) \nFROM incidents T1\nJOIN officers T2 ON T1.case_number = T2.case_number\nWHERE T1.subject_weapon = 'Vehicle' \nAND T2.gender = 'F'"
        ],
        "rule_sql": []
    },
    "4571": {
        "db_id": "mental_health_survey",
        "question": "How many users answered \"No\" to question 19?",
        "ground_truth": "SELECT COUNT(QuestionID) FROM Answer WHERE QuestionID = 19 AND AnswerText LIKE 'No'",
        "amends": [
            "Do select `COUNT(QuestionID)` from the `Answer` table instead of `COUNT(*)` from the `users` table. Do filter on `QuestionID = 19` and `AnswerText LIKE 'No'` instead of filtering on `question_19 = 'Yes'`. The amended query now correctly counts responses to question 19 with 'No' answers from the appropriate Answer table instead of incorrectly counting from a users table with different column semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE question_19 = 'Yes';",
            "SELECT COUNT(QuestionID) FROM Answer WHERE QuestionID = 19 AND AnswerText LIKE 'No'"
        ],
        "rule_sql": []
    },
    "2247": {
        "db_id": "movielens",
        "question": "List the different director IDs of the movies whose user rating is more than 4.",
        "ground_truth": "SELECT DISTINCT T2.directorid FROM u2base AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.rating > 4",
        "amends": [
            "Do use `SELECT DISTINCT T2.directorid` instead of `SELECT director_id` to return unique director identifiers. Do add `FROM u2base AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid` instead of `FROM movies` to properly join the ratings and director mapping tables. Do change the filter to `T1.rating > 4` instead of `user_rating > 4` to filter based on user ratings rather than movie ratings. The amended query now correctly identifies directors whose movies received high user ratings rather than movies with high inherent ratings, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director_id FROM movies WHERE user_rating > 4",
            "SELECT DISTINCT T2.directorid\nFROM u2base AS T1\nINNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid\nWHERE T1.rating > 4"
        ],
        "rule_sql": []
    },
    "2436": {
        "db_id": "superstore",
        "question": "What is the original price of the \"Black Avery Flip-Chart Easel Binder\"?",
        "ground_truth": "SELECT T1.Sales / (1 - T1.Discount) FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Product Name` = 'Blackstonian Pencils'",
        "amends": [
            "Do select `T1.Sales / (1 - T1.Discount)` instead of `price` from the result set. Do add `central_superstore AS T1` and `product AS T2` as data sources instead of only `products`. Do use `INNER JOIN` on `T1.Product ID = T2.Product ID` instead of no join condition. Do filter on `T2.Product Name = 'Blackstonian Pencils'` instead of `name = 'Black Avery Flip-Chart Easel Binder'`. The amended query now correctly calculates the adjusted sales price by joining product tables and applying the discount formula, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM products WHERE name = 'Black Avery Flip-Chart Easel Binder';",
            "SELECT T1.Sales / (1 - T1.Discount) AS original_price\nFROM central_superstore AS T1\nINNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\"\nWHERE T2.\"Product Name\" = 'Blackstonian Pencils'"
        ],
        "rule_sql": []
    },
    "3498": {
        "db_id": "video_games",
        "question": "Give the genre of the following game titled 'Airlock' , 'Airline Tycoon' , and 'Airblade', respectively.",
        "ground_truth": "SELECT T2.genre_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T1.game_name IN ('Airlock', 'Airline Tycoon', 'Airblade')",
        "amends": [
            "Do join `game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id` instead of querying a single `games` table. Do select `T2.genre_name` instead of `genre`. Do filter with `T1.game_name IN ('Airlock', 'Airline Tycoon', 'Airblade')` instead of `title = 'Airlock' OR title = 'Airline Tycoon' OR title = 'Airblade'`. The amended query now correctly retrieves genre names by joining the game and genre tables and using proper IN clause syntax.",
            "Do remove `T1.game_name` from the SELECT list instead of including it, keeping only `T2.genre_name` as the output column. The FROM clause with `INNER JOIN` on `T1.genre_id = T2.id` and WHERE filter on `T1.game_name IN` values remain unchanged. This amendment focuses the query on retrieving only genre names for the specified games rather than returning both game names and genre names together."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE title = 'Airlock' OR title = 'Airline Tycoon' OR title = 'Airblade';",
            "SELECT T1.game_name, T2.genre_name \nFROM game AS T1 \nINNER JOIN genre AS T2 ON T1.genre_id = T2.id \nWHERE T1.game_name IN ('Airlock', 'Airline Tycoon', 'Airblade')",
            "SELECT T2.genre_name \nFROM game AS T1 \nINNER JOIN genre AS T2 ON T1.genre_id = T2.id \nWHERE T1.game_name IN ('Airlock', 'Airline Tycoon', 'Airblade')"
        ],
        "rule_sql": []
    },
    "1944": {
        "db_id": "soccer_2016",
        "question": "When did the Sunrisers Hyderabad win their first match?",
        "ground_truth": "SELECT T1.Match_Date FROM `Match` AS T1 INNER JOIN Team AS T2 ON T1.Match_Winner = T2.Team_Id WHERE T2.Team_Name = 'Sunrisers Hyderabad'",
        "amends": [
            "Do select `T1.Match_Date` instead of `date` and use proper table aliasing. Do add `INNER JOIN Team AS T2` instead of querying only the matches table. Do use join condition `ON T1.Match_Winner = T2.Team_Id` instead of a simple team filter. Do filter with `WHERE T2.Team_Name = 'Sunrisers Hyderabad'` instead of `WHERE team = 'Sunrisers Hyderabad'` to properly reference the team name from the Team table. Do remove `ORDER BY date ASC LIMIT 1` instead of keeping it since the logic now correctly identifies matches by winner rather than needing to find the first occurrence. The amended query now correctly joins the Match and Team tables to find matches won by Sunrisers Hyderabad rather than incorrectly assuming team information is stored directly in the matches table.",
            "Do use backticks around `Match` table name instead of unquoted Match to handle reserved keywords properly. Do maintain the same `INNER JOIN` on `T1.Match_Winner = T2.Team_Id` with identical join conditions. Do keep the same `WHERE` filter on `T2.Team_Name = 'Sunrisers Hyderabad'` without changes. Do remove the `ORDER BY T1.Match_Date ASC` clause instead of including it since ordering is unnecessary when only retrieving the first match date. Do remove the `LIMIT 1` clause instead of keeping it as the query logic should return all matching dates rather than just one. The amended query now correctly returns all match dates where Sunrisers Hyderabad won, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM matches WHERE team = 'Sunrisers Hyderabad' ORDER BY date ASC LIMIT 1;",
            "SELECT T1.Match_Date\nFROM Match AS T1\nINNER JOIN Team AS T2 ON T1.Match_Winner = T2.Team_Id\nWHERE T2.Team_Name = 'Sunrisers Hyderabad'\nORDER BY T1.Match_Date ASC\nLIMIT 1;",
            "SELECT T1.Match_Date\nFROM `Match` AS T1\nINNER JOIN Team AS T2 ON T1.Match_Winner = T2.Team_Id\nWHERE T2.Team_Name = 'Sunrisers Hyderabad'"
        ],
        "rule_sql": []
    },
    "5734": {
        "db_id": "language_corpus",
        "question": "Calculate the average of repetitions in the pages that have a total of 100 different words.",
        "ground_truth": "SELECT CAST(SUM(T2.occurrences) AS REAL) / COUNT(T1.page) FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T1.words = 100",
        "amends": [
            "Do use `CAST(SUM(T2.occurrences) AS REAL) / COUNT(T1.page)` instead of `AVG(repetitions)` for the aggregate calculation. Do add `INNER JOIN pages_words AS T2 ON T1.pid = T2.pid` instead of querying only the `pages` table. Do reference `T1.words = 100` instead of `total_words = 100` in the WHERE clause. Do include table aliases `T1` and `T2` instead of omitting them. The amended query now correctly calculates the average occurrences per page by joining the necessary tables and using proper aggregation with casting to handle real number division."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(repetitions) FROM pages WHERE total_words = 100;",
            "SELECT CAST(SUM(T2.occurrences) AS REAL) / COUNT(T1.page) AS average_occurrences\nFROM pages AS T1\nINNER JOIN pages_words AS T2 ON T1.pid = T2.pid\nWHERE T1.words = 100"
        ],
        "rule_sql": []
    },
    "8947": {
        "db_id": "human_resources",
        "question": "Among the employees who work as a Trainee, how many of them have a salary of over &20,000 a year?",
        "ground_truth": "SELECT COUNT(*) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) > 20000 AND T2.positiontitle = 'Trainee'",
        "amends": [
            "Do join `employee` with `position` using `INNER JOIN` on `T1.positionID = T2.positionID` instead of querying only the `employees` table. Do filter by `T2.positiontitle = 'Trainee'` instead of `position = 'Trainee'`. Do parse and cast the salary using `CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) > 20000` instead of directly comparing `salary > 20000`. The amended query now correctly handles the normalized schema with separate tables and properly processes the formatted salary string to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE position = 'Trainee' AND salary > 20000;",
            "SELECT COUNT(*) \nFROM employee T1\nINNER JOIN position T2 ON T1.positionID = T2.positionID\nWHERE T2.positiontitle = 'Trainee'\nAND CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) > 20000"
        ],
        "rule_sql": []
    },
    "4970": {
        "db_id": "olympics",
        "question": "Calculate the average age of the persons who participated in the 1992 Summer Games.",
        "ground_truth": "SELECT AVG(T2.age) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '1992 Summer'",
        "amends": [
            "Do add table joins with `games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id` instead of querying a single `persons` table. Do reference `T2.age` instead of just `age` for proper column qualification. Do filter on `T1.games_name = '1992 Summer'` instead of `games = '1992 Summer Games'` to use the correct column name and value format. The amended query now correctly joins the necessary tables to calculate average age from the proper relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM persons WHERE games = '1992 Summer Games';",
            "SELECT AVG(T2.age) AS average_age\nFROM games AS T1\nINNER JOIN games_competitor AS T2 ON T1.id = T2.games_id\nINNER JOIN person AS T3 ON T2.person_id = T3.id\nWHERE T1.games_name = '1992 Summer'"
        ],
        "rule_sql": []
    },
    "728": {
        "db_id": "trains",
        "question": "What is the percentage of all the trains with at least 4 cars? List the directions of the said trains.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.trailPosi >= 4 THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM trains AS T1 INNER JOIN ( SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id ) AS T2 ON T1.id = T2.train_id UNION ALL SELECT T1.direction FROM trains AS T1 INNER JOIN ( SELECT train_id, MAX(position) AS trailPosi FROM cars t GROUP BY train_id ) AS T2 ON T1.id = T2.train_id AND T2.trailPosi >= 4",
        "amends": [
            "Do use `CAST(COUNT(CASE WHEN T2.trailPosi >= 4 THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM trains)` for the percentage calculation. Do add `INNER JOIN` with a subquery `(SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id) AS T2` on `T1.id = T2.train_id` instead of querying only the `trains` table. Do move the `cars >= 4` filter to the join condition `AND T2.trailPosi >= 4` instead of the `WHERE` clause. Do remove `GROUP BY direction` and instead add a `UNION ALL` with `SELECT T1.direction` from the joined tables. Do use proper table aliases `T1` and `T2` instead of unaliased table references. The amended query now correctly calculates the percentage of trains with at least 4 cars by joining with the cars table and using proper aggregation, matching the RIGHT_SQL's behavior.",
            "Do remove `T1.direction` from the SELECT list in the first query instead of including it, and do remove the `GROUP BY T1.direction` clause instead of keeping it. Do add `T1.direction` to the SELECT list in the second query instead of omitting it, and do remove the `AND T2.trailPosi >= 4` condition from the JOIN clause instead of keeping it there. Do fix the subquery alias by using `cars t` instead of just `cars` in the second query's subquery. The amended query now correctly calculates the percentage in the first part and returns direction values in the second part, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT direction, COUNT(*) * 100.0 / (SELECT COUNT(*) FROM trains) AS percentage\nFROM trains\nWHERE cars >= 4\nGROUP BY direction;",
            "SELECT \n    CAST(COUNT(CASE WHEN T2.trailPosi >= 4 THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) AS percentage,\n    T1.direction\nFROM \n    trains T1\nINNER JOIN \n    (SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id) AS T2\nON \n    T1.id = T2.train_id\nGROUP BY \n    T1.direction\nUNION ALL\nSELECT \n    CAST(COUNT(CASE WHEN T2.trailPosi >= 4 THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id),\n    T1.direction\nFROM \n    trains T1\nINNER JOIN \n    (SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id) AS T2\nON \n    T1.id = T2.train_id\nAND T2.trailPosi >= 4",
            "SELECT CAST(COUNT(CASE WHEN T2.trailPosi >= 4 THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM trains T1\nINNER JOIN (SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id) AS T2 ON T1.id = T2.train_id\nUNION ALL\nSELECT T1.direction\nFROM trains T1\nINNER JOIN (SELECT train_id, MAX(position) AS trailPosi FROM cars t GROUP BY train_id) AS T2 ON T1.id = T2.train_id\nWHERE T2.trailPosi >= 4"
        ],
        "rule_sql": []
    },
    "7979": {
        "db_id": "music_platform_2",
        "question": "What is the content of the review under the title \"really interesting!\" and is created on 2018-04-24 at 12:05:16?",
        "ground_truth": "SELECT content FROM reviews WHERE title = 'really interesting!' AND created_at = '2018-04-24T12:05:16-07:00'",
        "amends": [
            "Do use ISO 8601 timestamp format `2018-04-24T12:05:16-07:00` with timezone offset instead of naive timestamp format `2018-04-24 12:05:16` without timezone information in the WHERE filter for the created_at column, ensuring proper timezone-aware date comparison instead of potentially incorrect naive timestamp matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT content FROM reviews WHERE title = 'really interesting!' AND created_at = '2018-04-24 12:05:16';",
            "SELECT content FROM reviews WHERE title = 'really interesting!' AND created_at = '2018-04-24T12:05:16-07:00';"
        ],
        "rule_sql": []
    },
    "7313": {
        "db_id": "works_cycles",
        "question": "Name the oldest employee who is working on night shift. How old is the employee?",
        "ground_truth": "SELECT T1.FirstName, T1.LastName , STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', BirthDate) FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE T3.ShiftId = 3 ORDER BY STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', BirthDate) DESC LIMIT 1",
        "amends": [
            "Do select `T1.FirstName`, `T1.LastName`, and an age calculation using `STRFTIME` instead of `name` and `age`. Do use `INNER JOIN` between `Person` and `Employee` on `BusinessEntityID` instead of a single table. Do add another `INNER JOIN` to `EmployeeDepartmentHistory` on `BusinessEntityID` instead of omitting it. Do filter on `T3.ShiftId = 3` instead of `shift = 'night'`. Do order by the calculated age in descending order instead of `age ASC`. The amended query now correctly calculates age from birthdate, joins multiple related tables, filters by shift ID, and returns the oldest employee on night shift, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM employees WHERE shift = 'night' ORDER BY age ASC LIMIT 1;",
            "SELECT \n    T1.FirstName, \n    T1.LastName, \n    STRFTIME('%Y', 'now') - STRFTIME('%Y', T2.BirthDate) AS Age\nFROM \n    Person T1\nINNER JOIN \n    Employee T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN \n    EmployeeDepartmentHistory T3 ON T2.BusinessEntityID = T3.BusinessEntityID\nWHERE \n    T3.ShiftID = 3\nORDER BY \n    Age DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3692": {
        "db_id": "college_completion",
        "question": "Compare the graduate cohort for Auburn University from 2011 to 2013?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.year = 2011 THEN T2.grad_cohort ELSE 0 END), SUM(CASE WHEN T2.year = 2012 THEN T2.grad_cohort ELSE 0 END), SUM(CASE WHEN T2.year = 2013 THEN T2.grad_cohort ELSE 0 END) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE T2.gender = 'B' AND T2.race = 'X' AND T1.chronname = 'Auburn University'",
        "amends": [
            "Do use `SUM` aggregates with conditional `CASE` expressions for `grad_cohort` values from specific years instead of selecting raw `year` and `graduate_cohort` columns. Do join `institution_details` as `T1` with `institution_grads` as `T2` on `T1.unitid = T2.unitid` instead of querying a single `university_data` table. Do add filters for `T2.gender = 'B'` and `T2.race = 'X'` instead of only filtering by university name and year range. Do reference `T1.chronname` for the university name instead of `university` column. Do remove the `ORDER BY year` clause instead of keeping it since the result is aggregated sums. The amended query now correctly calculates aggregated graduate cohort totals for specific demographic criteria across joined institution tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, graduate_cohort FROM university_data WHERE university = 'Auburn University' AND year BETWEEN 2010 AND 2014 ORDER BY year;",
            "SELECT \n    SUM(CASE WHEN T2.year = 2011 THEN CAST(T2.grad_cohort AS INTEGER) ELSE 0 END) AS grad_cohort_2011,\n    SUM(CASE WHEN T2.year = 2012 THEN CAST(T2.grad_cohort AS INTEGER) ELSE 0 END) AS grad_cohort_2012,\n    SUM(CASE WHEN T2.year = 2013 THEN CAST(T2.grad_cohort AS INTEGER) ELSE 0 END) AS grad_cohort_2013\nFROM \n    institution_details T1\nJOIN \n    institution_grads T2 ON T1.unitid = T2.unitid\nWHERE \n    T1.chronname = 'Auburn University'\n    AND T2.year BETWEEN 2011 AND 2013\n    AND T2.gender = 'B'\n    AND T2.race = 'X'"
        ],
        "rule_sql": []
    },
    "3507": {
        "db_id": "video_games",
        "question": "Among games sold in Europe, list the platform ID of games with sales lesser than 30% of the average number of sales.",
        "ground_truth": "SELECT DISTINCT T3.platform_id FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id WHERE T1.region_name = 'Europe' AND T2.num_sales * 100 * 100000 < ( SELECT AVG(T2.num_sales * 100000) * 30 FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'Europe' )",
        "amends": [
            "Do use `DISTINCT T3.platform_id` instead of `platform_id` to eliminate duplicates. Do join `region AS T1` and `region_sales AS T2` with `INNER JOIN` on `T1.id = T2.region_id` instead of querying the `games` table directly. Do add another `INNER JOIN` to `game_platform AS T3` on `T2.game_platform_id = T3.id` instead of missing this table relationship. Do filter with `T1.region_name = 'Europe'` instead of assuming European sales data. Do calculate sales with `T2.num_sales * 100 * 100000` instead of using `europe_sales` directly. Do use a correlated subquery with `AVG(T2.num_sales * 100000) * 30` instead of `AVG(europe_sales) * 0.3` for proper regional average comparison. Do include the same join conditions and region filter in the subquery instead of omitting them. The amended query now correctly identifies platform IDs with European sales below 30% of the regional average."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform_id FROM games WHERE europe_sales < (SELECT AVG(europe_sales) * 0.3 FROM games);",
            "SELECT DISTINCT T3.platform_id\nFROM region AS T1\nINNER JOIN region_sales AS T2 ON T1.id = T2.region_id\nINNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id\nWHERE T1.region_name = 'Europe'\nAND T2.num_sales * 100 * 100000 < (\n    SELECT AVG(T2_sub.num_sales * 100000) * 30\n    FROM region AS T1_sub\n    INNER JOIN region_sales AS T2_sub ON T1_sub.id = T2_sub.region_id\n    WHERE T1_sub.region_name = 'Europe'\n)"
        ],
        "rule_sql": []
    },
    "5304": {
        "db_id": "beer_factory",
        "question": "Find and list the full name and email of the customers who used American Express cards in Sac State Union.",
        "ground_truth": "SELECT DISTINCT T1.First, T1.Last, T1.Email FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN location AS T3 ON T2.LocationID = T3.LocationID WHERE T3.LocationName = 'Sac State Union' AND T2.CreditCardType = 'American Express'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change column references from `first_name, last_name, email` to `T1.First, T1.Last, T1.Email` instead of using direct column names. Do add table aliases with `customers AS T1` instead of using the table name directly. Do add `INNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID` instead of missing this join condition. Do add `INNER JOIN location AS T3 ON T2.LocationID = T3.LocationID` instead of missing this location relationship. Do change filter from `card_type = 'American Express'` to `T2.CreditCardType = 'American Express'` instead of querying the wrong table. Do change filter from `location = 'Sac State Union'` to `T3.LocationName = 'Sac State Union'` instead of querying a non-existent column in the customers table. The amended query now correctly joins through transaction and location tables to filter based on credit card type and location name, matching the RIGHT_SQL's behavior.",
            "Do keep the same `SELECT DISTINCT T1.First, T1.Last, T1.Email` column list instead of changing it. Do maintain the same `FROM customers AS T1 INNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN location AS T3 ON T2.LocationID = T3.LocationID` join structure instead of altering it. Do reorder the `WHERE` clause to place `T3.LocationName = 'Sac State Union'` before `T2.CreditCardType = 'American Express'` instead of the reverse order, though this is purely cosmetic as the logical AND operation is commutative. The amended query now matches RIGHT_SQL's behavior with identical logic and results.",
            "Do use backticks around `transaction` instead of leaving it unquoted as a reserved keyword. The amended query now correctly handles the reserved keyword and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM customers WHERE card_type = 'American Express' AND location = 'Sac State Union';",
            "SELECT DISTINCT T1.First, T1.Last, T1.Email\nFROM customers AS T1\nINNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN location AS T3 ON T2.LocationID = T3.LocationID\nWHERE T2.CreditCardType = 'American Express'\nAND T3.LocationName = 'Sac State Union'",
            "SELECT DISTINCT T1.First, T1.Last, T1.Email\nFROM customers AS T1\nINNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN location AS T3 ON T2.LocationID = T3.LocationID\nWHERE T3.LocationName = 'Sac State Union'\nAND T2.CreditCardType = 'American Express'",
            "SELECT DISTINCT T1.First, T1.Last, T1.Email\nFROM customers AS T1\nINNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN location AS T3 ON T2.LocationID = T3.LocationID\nWHERE T3.LocationName = 'Sac State Union'\nAND T2.CreditCardType = 'American Express'"
        ],
        "rule_sql": []
    },
    "6855": {
        "db_id": "retails",
        "question": "Calculate the percentage of countries that belong to the American region.",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.r_name = 'America', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey",
        "amends": [
            "Do use `SUM(IIF(T1.r_name = 'America', 1, 0))` with explicit table aliases instead of `COUNT(*)` with a simple region filter. Do join `region AS T1` and `nation AS T2` with `INNER JOIN` on `T1.r_regionkey = T2.n_regionkey` instead of querying only the `countries` table. Do calculate the percentage using `CAST(... AS REAL) * 100 / COUNT(T2.n_name)` instead of `(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM countries))`. Do reference the region name as `'America'` instead of `'American'` and use proper table relationships through join keys rather than direct filtering. The amended query now correctly calculates the percentage of nations in the America region relative to all nations using proper table relationships and casting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM countries)) AS percentage FROM countries WHERE region = 'American';",
            "SELECT CAST(SUM(IIF(T1.r_name = 'America', 1, 0)) AS REAL) * 100 / COUNT(T2.n_name) AS percentage\nFROM region AS T1\nINNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey;"
        ],
        "rule_sql": []
    },
    "678": {
        "db_id": "codebase_comments",
        "question": "List 5 github address that the solutions can be implemented without the need of compilation.",
        "ground_truth": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.WasCompiled = 1 LIMIT 5",
        "amends": [
            "Do select `T1.Url` from the `Repo` table instead of `github_address` from the `repositories` table. Do join with `Solution` table using `INNER JOIN` on `T1.Id = T2.RepoId` instead of querying a single table. Do filter on `T2.WasCompiled = 1` instead of `compilation_required = 'no'` to use a boolean integer flag rather than a string value. The amended query now correctly retrieves URLs from repositories that have compiled solutions by joining the appropriate tables and using the correct boolean comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT github_address FROM repositories WHERE compilation_required = 'no' LIMIT 5;",
            "SELECT T1.Url \nFROM Repo T1\nINNER JOIN Solution T2 ON T1.Id = T2.RepoId\nWHERE T2.WasCompiled = 1\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "4554": {
        "db_id": "student_loan",
        "question": "What are the names of the students who joined the Marines?",
        "ground_truth": "SELECT name FROM enlist WHERE organ = 'marines'",
        "amends": [
            "Do reference table `enlist` instead of `students` in the FROM clause. Do use filter condition `organ = 'marines'` instead of `branch = 'Marines'` in the WHERE clause, correcting both the column name and case sensitivity. The amended query now correctly retrieves names from the enlist table where the organ field matches 'marines', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE branch = 'Marines';",
            "SELECT name FROM enlist WHERE organ = 'marines'"
        ],
        "rule_sql": []
    },
    "3558": {
        "db_id": "authors",
        "question": "What is the homepage address for paper \"Energy-efficiency bounds for noise-tolerant dynamic circuits\"?",
        "ground_truth": "SELECT T2.HomePage FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T1.Title = 'Energy-efficiency bounds for noise-tolerant dynamic circuits'",
        "amends": [
            "Do join `Conference` table as `T2` instead of querying only the `papers` table. Do use `INNER JOIN` on `T1.ConferenceId = T2.Id` instead of omitting the join entirely. Do select `T2.HomePage` instead of `homepage` from the wrong table. Do reference tables as `Paper AS T1` and `Conference AS T2` instead of using the singular `papers` table name. The amended query now correctly retrieves the homepage from the Conference table by joining through the conference relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT homepage FROM papers WHERE title = 'Energy-efficiency bounds for noise-tolerant dynamic circuits';",
            "SELECT T2.HomePage \nFROM Paper AS T1 \nINNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id \nWHERE T1.Title = 'Energy-efficiency bounds for noise-tolerant dynamic circuits'"
        ],
        "rule_sql": []
    },
    "2816": {
        "db_id": "professional_basketball",
        "question": "in which year costela01 obtained the best balance of games won as a coach?",
        "ground_truth": "SELECT year FROM coaches WHERE coachID = 'costela01' ORDER BY CAST(won AS REAL) / (won + lost) DESC LIMIT 1",
        "amends": [
            "Do order by `CAST(won AS REAL) / (won + lost) DESC` instead of `wins DESC` to calculate and sort by win percentage rather than using a raw wins count, which provides a more accurate measure of coaching performance by accounting for both wins and losses in the ratio."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM coaches WHERE coachID = 'costela01' ORDER BY wins DESC LIMIT 1;",
            "SELECT year\nFROM coaches\nWHERE coachID = 'costela01'\nORDER BY CAST(won AS REAL) / (won + lost) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4666": {
        "db_id": "disney",
        "question": "List all the songs associated with drama movies.",
        "ground_truth": "SELECT song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T1.genre = 'Drama' GROUP BY song",
        "amends": [
            "Do select `song` instead of `s.title` and use `movies_total_gross` as T1 instead of `songs` and `movies`. Do `INNER JOIN` `characters` as T2 on `T1.movie_title = T2.movie_title` instead of joining `movies` on `s.movie_id = m.id`. Do filter on `T1.genre = 'Drama'` instead of `m.genre = 'drama'` with proper case handling. Do add `GROUP BY song` instead of omitting aggregation grouping. The amended query now correctly retrieves songs from drama movies with proper table relationships and case-sensitive filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.title \nFROM songs s \nJOIN movies m ON s.movie_id = m.id \nWHERE m.genre = 'drama';",
            "SELECT song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T1.genre = 'Drama' GROUP BY song;"
        ],
        "rule_sql": []
    },
    "4593": {
        "db_id": "mental_health_survey",
        "question": "What is the average result of the question \"What is your age?\" in 2014's survey?",
        "ground_truth": "SELECT CAST(SUM(T2.AnswerText) AS REAL) / COUNT(T2.UserID) AS \"avg\" FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2014 AND T1.questiontext LIKE 'What is your age?'",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Question AS T1` and `Answer AS T2` with `INNER JOIN` on `T1.questionid = T2.QuestionID` instead of querying only `survey_responses`. Do calculate average using `CAST(SUM(T2.AnswerText) AS REAL) / COUNT(T2.UserID)` instead of `AVG(age)`. Do filter with `T2.SurveyID = 2014` instead of `year = 2014`. Do filter with `T1.questiontext LIKE 'What is your age?'` instead of `question = 'What is your age?'`. Do select the result with alias `\"avg\"` instead of no alias. The amended query now correctly calculates the average age from the normalized schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM survey_responses WHERE question = 'What is your age?' AND year = 2014;",
            "SELECT CAST(SUM(T2.AnswerText) AS REAL) / COUNT(T2.UserID) AS \"avg\"\nFROM Question AS T1\nINNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID\nWHERE T1.questiontext LIKE 'What is your age?'\nAND T2.SurveyID = 2014"
        ],
        "rule_sql": []
    },
    "1307": {
        "db_id": "law_episode",
        "question": "In what year did the episodes titled DWB get an award?",
        "ground_truth": "SELECT DISTINCT T1.year FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T2.title = 'DWB' AND T1.result = 'Winner'",
        "amends": [
            "Do use `DISTINCT T1.year` instead of `year` to eliminate duplicates. Do join `Award AS T1` and `Episode AS T2` with `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying only the `episodes` table. Do filter on `T2.title = 'DWB'` instead of `title = 'DWB'` with proper table qualification. Do use `T1.result = 'Winner'` instead of `award IS NOT NULL` to specifically check for winning results rather than any non-null award value. The amended query now correctly retrieves distinct years from the joined Award and Episode tables where the episode title matches and the award result is specifically 'Winner', matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM episodes WHERE title = 'DWB' AND award IS NOT NULL;",
            "SELECT DISTINCT T1.year\nFROM Award AS T1\nINNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id\nWHERE T2.title = 'DWB' AND T1.result = 'Winner'"
        ],
        "rule_sql": []
    },
    "8300": {
        "db_id": "mondial_geo",
        "question": "Please list the mountains in the country with the lowest inflation rate.",
        "ground_truth": "SELECT Mountain FROM geo_mountain WHERE Country = ( SELECT Country FROM economy ORDER BY Inflation ASC LIMIT 1 )",
        "amends": [
            "Do reference `Mountain` instead of `m.name` and use table `geo_mountain` instead of `mountains m`. Do use a simple equality condition with subquery instead of a JOIN with `countries c` table. Do remove the explicit JOIN on `m.country_id = c.id` and instead use a direct subquery comparison `Country = (subquery)`. Do change the subquery to select `Country` from `economy` table instead of `countries` table and use `ORDER BY Inflation ASC LIMIT 1` instead of `WHERE c.inflation_rate = (SELECT MIN(inflation_rate) FROM countries)`. Do remove the inflation rate comparison through aggregation and instead use ordering with limit to find the country with lowest inflation. The amended query now correctly identifies mountains in countries with the lowest inflation by using appropriate table relationships and efficient subquery construction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.name \nFROM mountains m\nJOIN countries c ON m.country_id = c.id\nWHERE c.inflation_rate = (SELECT MIN(inflation_rate) FROM countries);",
            "SELECT Mountain FROM geo_mountain WHERE Country = (SELECT Country FROM economy ORDER BY Inflation ASC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "51": {
        "db_id": "movie_platform",
        "question": "What's the description for the movie list \"Short and pretty damn sweet\"?",
        "ground_truth": "SELECT list_description FROM lists WHERE list_title = 'Short and pretty damn sweet'",
        "amends": [
            "Do reference the `list_description` column instead of `description`. Do query from the `lists` table instead of `movie_lists`. Do filter on `list_title = 'Short and pretty damn sweet'` instead of `name = 'Short and pretty damn sweet'`. The amended query now correctly retrieves list descriptions from the appropriate table using the correct column names and filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM movie_lists WHERE name = 'Short and pretty damn sweet';",
            "SELECT list_description FROM lists WHERE list_title = 'Short and pretty damn sweet';"
        ],
        "rule_sql": []
    },
    "5931": {
        "db_id": "books",
        "question": "For the publisher which published the most books, show its name.",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id GROUP BY T2.publisher_name ORDER BY COUNT(T2.publisher_id) DESC LIMIT 1",
        "amends": [
            "Do join `book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id` instead of querying only the `publishers` table. Do group by `T2.publisher_name` instead of omitting grouping. Do select `T2.publisher_name` instead of just `name`. Do order by `COUNT(T2.publisher_id)` instead of `COUNT(*)` to count books per publisher rather than total rows. The amended query now correctly identifies the publisher with the most books by joining the book and publisher tables, grouping by publisher name, and counting the associated books."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM publishers ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.publisher_name\nFROM book AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id\nGROUP BY T2.publisher_name\nORDER BY COUNT(T2.publisher_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "149": {
        "db_id": "movie_platform",
        "question": "Among all movies in the list, calculate the percentage of movies that were never been rated?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.movie_id IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.movie_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id",
        "amends": [
            "Do use `SUM(CASE WHEN T2.movie_id IS NULL THEN 1 ELSE 0 END)` to count null ratings instead of `COUNT(*)` with a `WHERE rating IS NULL` filter. Do add an `INNER JOIN` between `ratings AS T1` and `movies AS T2` on `T1.movie_id = T2.movie_id` instead of querying only the `movies` table. Do calculate the percentage using `CAST(... AS REAL) * 100 / COUNT(T2.movie_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM movies)`. Do remove the subquery for total count and instead use the joined table's count directly. The amended query now correctly handles the join between ratings and movies tables and accurately calculates the percentage of movies without ratings.",
            "Do use `INNER JOIN` between `ratings` and `movies` instead of `LEFT JOIN` from `movies` to `ratings`. Do check for `T2.movie_id IS NULL` in the CASE expression instead of `T1.movie_id IS NULL` to correctly identify unrated movies. Do remove the alias `percentage_unrated` instead of keeping it. The amended query now correctly calculates the percentage of unrated movies by joining the tables properly and checking for missing movie records from the ratings table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM movies)) AS percentage\nFROM movies\nWHERE rating IS NULL;",
            "SELECT CAST(SUM(CASE WHEN T1.movie_id IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.movie_id) AS percentage_unrated\nFROM movies AS T2\nLEFT JOIN ratings AS T1 ON T2.movie_id = T1.movie_id;",
            "SELECT CAST(SUM(CASE WHEN T2.movie_id IS NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.movie_id) \nFROM ratings AS T1 \nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id;"
        ],
        "rule_sql": []
    },
    "6906": {
        "db_id": "retails",
        "question": "How much is the part supply cost for the medium metallic grey dodger linen?",
        "ground_truth": "SELECT T2.ps_supplycost FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE T1.p_name = 'medium metallic grey dodger linen'",
        "amends": [
            "Do reference `partsupp` table instead of `part_supply`, and use `ps_supplycost` column instead of `SUM(ps.supply_cost)`. Do join `part` table instead of `parts`, and use `p_partkey` and `ps_partkey` for the join condition instead of `part_id` to `part_id`. Do remove the separate joins to `colors` and `sizes` tables instead of keeping them, and consolidate the filter conditions into a single `p_name` predicate checking for 'medium metallic grey dodger linen' instead of separate conditions on `color_name`, `size_name`, and `part_name`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. The amended query now correctly retrieves the supply cost directly without aggregation and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(ps.supply_cost) \nFROM part_supply ps\nJOIN parts p ON ps.part_id = p.part_id\nJOIN colors c ON p.color_id = c.color_id\nJOIN sizes s ON p.size_id = s.size_id\nWHERE c.color_name = 'metallic grey' \nAND s.size_name = 'medium'\nAND p.part_name = 'dodger linen'",
            "SELECT ps.ps_supplycost \nFROM partsupp ps\nINNER JOIN part p ON ps.ps_partkey = p.p_partkey\nWHERE p.p_name = 'medium metallic grey dodger linen'"
        ],
        "rule_sql": []
    },
    "6937": {
        "db_id": "ice_hockey_draft",
        "question": "How many games did the tallest player have ever played?",
        "ground_truth": "SELECT T1.GP FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.ELITEID = ( SELECT t.ELITEID FROM PlayerInfo t ORDER BY t.height DESC LIMIT 1 )",
        "amends": [
            "Do select `T1.GP` instead of `COUNT(*)`. Do use `FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID` instead of `FROM games` with a subquery. Do add `WHERE T2.ELITEID = (subquery)` instead of `WHERE player_id IN (subquery)`. Do change the subquery to select `t.ELITEID FROM PlayerInfo t` instead of `player_id FROM players`. Do keep `ORDER BY height DESC LIMIT 1` in the subquery but change the table reference. The amended query now correctly joins tables and selects the appropriate column while maintaining the logic to find the tallest player's data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE player_id IN (SELECT player_id FROM players ORDER BY height DESC LIMIT 1);",
            "SELECT T1.GP\nFROM SeasonStatus AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE T2.ELITEID = (\n    SELECT t.ELITEID\n    FROM PlayerInfo t\n    ORDER BY t.height DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "5737": {
        "db_id": "language_corpus",
        "question": "How many times did the word number 8 appear?",
        "ground_truth": "SELECT occurrences FROM words WHERE wid = 8",
        "amends": [
            "Do select the `occurrences` column instead of using `COUNT(*)` aggregate function. Do filter on `wid = 8` instead of filtering on `word = '8'` where the numeric ID should be compared without quotes. The amended query now correctly retrieves the specific occurrence count for word ID 8 rather than attempting to count rows with a literal string value, matching the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE word = '8';",
            "SELECT occurrences FROM words WHERE wid = 8;"
        ],
        "rule_sql": []
    },
    "4229": {
        "db_id": "simpson_episodes",
        "question": "Provide the number of credits, category, role and birthplace of the crew member who was born in North Korea.",
        "ground_truth": "SELECT DISTINCT T2.credited, T2.category, T2.role, T1.birth_place FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T1.birth_country = 'North Korea';",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T2.credited` instead of `credits` and `T1.birth_place` instead of `birthplace` with proper table aliases. Do add `T2.category` and `T2.role` with explicit table references instead of bare column names. Do change the FROM clause to use `Person AS T1 INNER JOIN Credit AS T2` instead of a single `crew` table. Do add the join condition `ON T1.name = T2.person` instead of no join condition. Do change the filter to `T1.birth_country = 'North Korea'` instead of `birthplace = 'South Korea'` with proper table qualification and corrected country value. The amended query now correctly joins person and credit data while filtering for North Korean birth countries instead of South Korean birthplaces.",
            "Do use `SELECT DISTINCT` with individual columns `credited`, `category`, `role`, and `birth_place` instead of `COUNT(DISTINCT credited)` with aggregation. Do remove the `GROUP BY` clause entirely instead of grouping by `category`, `role`, and `birth_place`. The amended query now returns distinct combinations of the specified columns rather than counting distinct credited values per group, matching the RIGHT_SQL's behavior of listing unique records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credits, category, role, birthplace FROM crew WHERE birthplace = 'South Korea';",
            "SELECT COUNT(DISTINCT T2.credited) AS credits, T2.category, T2.role, T1.birth_place\nFROM Person AS T1\nINNER JOIN Credit AS T2 ON T1.name = T2.person\nWHERE T1.birth_country = 'North Korea'\nGROUP BY T2.category, T2.role, T1.birth_place",
            "SELECT DISTINCT T2.credited, T2.category, T2.role, T1.birth_place\nFROM Person AS T1\nINNER JOIN Credit AS T2 ON T1.name = T2.person\nWHERE T1.birth_country = 'North Korea'"
        ],
        "rule_sql": []
    },
    "7386": {
        "db_id": "works_cycles",
        "question": "What are the full names of the 10 youngest married male production technicians?",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle LIKE 'Production Technician%' AND T1.Gender = 'M' AND T1.MaritalStatus = 'M' ORDER BY T1.BirthDate DESC LIMIT 10",
        "amends": [
            "Do select `FirstName`, `MiddleName`, and `LastName` from the `Person` table instead of `first_name` and `last_name` from `employees`. Do join `Employee` AS `T1` with `Person` AS `T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do filter with `T1.JobTitle LIKE 'Production Technician%'` instead of exact match `job_title = 'Production Technician'`. Do use `T1.Gender = 'M'` instead of `gender = 'Male'` and `T1.MaritalStatus = 'M'` instead of `marital_status = 'Married'`. Do order by `T1.BirthDate DESC` instead of `birth_date ASC`. The amended query now correctly joins employee and person data with proper gender and marital status codes and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE gender = 'Male' AND job_title = 'Production Technician' AND marital_status = 'Married' ORDER BY birth_date ASC LIMIT 10;",
            "SELECT T2.FirstName, T2.MiddleName, T2.LastName\nFROM Employee AS T1\nJOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.JobTitle LIKE 'Production Technician%'\nAND T1.Gender = 'M'\nAND T1.MaritalStatus = 'M'\nORDER BY T1.BirthDate DESC\nLIMIT 10;"
        ],
        "rule_sql": []
    },
    "6516": {
        "db_id": "retail_world",
        "question": "In August of 1996, how many orders were placed by the customer with the highest amount of orders?",
        "ground_truth": "SELECT COUNT(OrderID) FROM Orders WHERE OrderDate LIKE '1996-08%' GROUP BY CustomerID ORDER BY COUNT(OrderID) DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(OrderID)` instead of `COUNT(*)` to count specific non-null values. Do use `OrderDate LIKE '1996-08%'` instead of `strftime('%m', order_date) = '08' AND strftime('%Y', order_date) = '1996'` for simpler date pattern matching without function calls. Do reference `CustomerID` instead of `customer_id` to match the correct column name. The amended query now correctly counts August 1996 orders per customer using proper column references and efficient date filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE strftime('%m', order_date) = '08' AND strftime('%Y', order_date) = '1996' GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT COUNT(OrderID) AS OrderCount\nFROM Orders\nWHERE CustomerID = (\n    SELECT CustomerID\n    FROM Orders\n    WHERE OrderDate LIKE '1996-08%'\n    GROUP BY CustomerID\n    ORDER BY COUNT(OrderID) DESC\n    LIMIT 1\n) AND OrderDate LIKE '1996-08%'"
        ],
        "rule_sql": []
    },
    "2899": {
        "db_id": "professional_basketball",
        "question": "How many players, in games played in 1990, achieved 50% or less of oRebounds than dRebounds.",
        "ground_truth": "SELECT COUNT(playerID) FROM players_teams WHERE CAST(oRebounds AS REAL) * 100 / dRebounds <= 50 AND year = 1990",
        "amends": [
            "Do select `COUNT(playerID)` instead of `COUNT(*)` to count specific player identifiers rather than all rows. Do use table `players_teams` instead of joining `players` with `games` to access the required data in a single table. Do remove the join condition entirely instead of using `ON p.game_id = g.game_id` since the data is now consolidated. Do change the filter to `CAST(oRebounds AS REAL) * 100 / dRebounds <= 50` instead of `p.oRebounds <= p.dRebounds * 0.5` to properly calculate the percentage comparison with explicit casting. Do move the year filter to use column `year` directly instead of referencing `g.year` from the joined table. The amended query now correctly calculates players whose offensive rebounds percentage is 50% or less of defensive rebounds for the year 1990, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players p\nJOIN games g ON p.game_id = g.game_id\nWHERE g.year = 1990\nAND p.oRebounds <= p.dRebounds * 0.5",
            "SELECT COUNT(playerID) \nFROM players_teams \nWHERE year = 1990 \nAND CAST(oRebounds AS REAL) * 100 / dRebounds <= 50"
        ],
        "rule_sql": []
    },
    "3671": {
        "db_id": "authors",
        "question": "Provide the average number of papers that are published in the journal named 'Information Sciences' annually.",
        "ground_truth": "SELECT CAST(COUNT(T2.JournalId) AS REAL) / COUNT(DISTINCT T2.Year) FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.FullName = 'Information Sciences'",
        "amends": [
            "Do use `CAST(COUNT(T2.JournalId) AS REAL) / COUNT(DISTINCT T2.Year)` instead of `AVG(COUNT(*))` to correctly calculate the average papers per year. Do join `Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId` instead of querying only the `papers` table to properly relate journal and paper data. Do filter on `T1.FullName = 'Information Sciences'` instead of `journal_name = 'Information Sciences'` to use the correct column name from the journal table. Do remove `GROUP BY year` instead of keeping it since the right query calculates the overall average across all years rather than per-year averages. The amended query now correctly computes the average number of papers per year for the specified journal."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(*)) FROM papers WHERE journal_name = 'Information Sciences' GROUP BY year;",
            "SELECT CAST(COUNT(T2.JournalId) AS REAL) / COUNT(DISTINCT T2.Year) AS average_papers_per_year\nFROM Journal AS T1\nINNER JOIN Paper AS T2 ON T1.Id = T2.JournalId\nWHERE T1.FullName = 'Information Sciences';"
        ],
        "rule_sql": []
    },
    "3981": {
        "db_id": "public_review_platform",
        "question": "Under the category name of \"Coffee & Tea\", mention any 5 business ID , their state and city.",
        "ground_truth": "SELECT T2.business_id, T3.state, T3.city FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name = 'Coffee & Tea' LIMIT 5",
        "amends": [
            "Do join `Categories AS T1` and `Business_Categories AS T2` on `T1.category_id = T2.category_id` instead of querying `businesses` directly without proper table relationships. Do join `Business AS T3` on `T2.business_id = T3.business_id` instead of missing the necessary business table connection. Do select `T2.business_id` instead of just `business_id` without table qualification. Do select `T3.state` and `T3.city` from the Business table instead of assuming these columns exist in the businesses table. Do use proper table aliases and explicit joins instead of a single table query that cannot resolve the category relationship. The amended query now correctly joins the three required tables to filter businesses by category name and returns the appropriate business details."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id, state, city FROM businesses WHERE category_name = 'Coffee & Tea' LIMIT 5;",
            "SELECT T2.business_id, T3.state, T3.city\nFROM Categories AS T1\nJOIN Business_Categories AS T2 ON T1.category_id = T2.category_id\nJOIN Business AS T3 ON T2.business_id = T3.business_id\nWHERE T1.category_name = 'Coffee & Tea'\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "2181": {
        "db_id": "world_development_indicators",
        "question": "How many countries using the 1993 System of National Accounts methodology?",
        "ground_truth": "SELECT COUNT(CountryCode) FROM Country WHERE SystemOfNationalAccounts = 'Country uses the 1993 System of National Accounts methodology.'",
        "amends": [
            "Do reference table `Country` instead of `countries` and use column `CountryCode` in the `COUNT` function instead of `COUNT(*)`. Do filter on column `SystemOfNationalAccounts` with value 'Country uses the 1993 System of National Accounts methodology.' instead of filtering on column `methodology` with value '1993 System of National Accounts'. The amended query now correctly counts country codes from the appropriate table using the precise filter condition that matches the intended methodology description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE methodology = '1993 System of National Accounts';",
            "SELECT COUNT(CountryCode) FROM Country WHERE SystemOfNationalAccounts = 'Country uses the 1993 System of National Accounts methodology.'"
        ],
        "rule_sql": []
    },
    "5497": {
        "db_id": "menu",
        "question": "List the dishes included on page number 30 with the least in full height.",
        "ground_truth": "SELECT T3.name FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE T1.page_number = 30 ORDER BY T1.full_height DESC, T1.full_height ASC LIMIT 1",
        "amends": [
            "Do select only `T3.name` instead of all columns with `*`. Do add joins to `MenuPage AS T1` and `MenuItem AS T2` instead of querying only `dishes`. Do use `INNER JOIN` on `T1.id = T2.menu_page_id` and `INNER JOIN` on `T2.dish_id = T3.id` instead of no joins. Do filter on `T1.page_number = 30` instead of `page_number = 30`. Do order by `T1.full_height DESC, T1.full_height ASC` instead of only `full_height ASC`. The amended query now correctly joins related tables to find dish names from menu pages with page number 30, ordered by page height with proper table references.",
            "Do add `LIMIT 1` to the `ORDER BY` clause instead of omitting it, which ensures only the single highest full_height record is returned rather than all matching records. The amended query now correctly returns only the top result when ordered by full_height descending, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM dishes WHERE page_number = 30 ORDER BY full_height ASC LIMIT 1;",
            "SELECT T3.name \nFROM MenuPage AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id\nINNER JOIN Dish AS T3 ON T2.dish_id = T3.id\nWHERE T1.page_number = 30\nORDER BY T1.full_height DESC, T1.full_height ASC",
            "SELECT T3.name \nFROM MenuPage AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id\nINNER JOIN Dish AS T3 ON T2.dish_id = T3.id\nWHERE T1.page_number = 30\nORDER BY T1.full_height DESC, T1.full_height ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8403": {
        "db_id": "mondial_geo",
        "question": "What is the GDP for Service of the country with Fuenlabrada as its city.",
        "ground_truth": "SELECT T4.Service * T4.GDP FROM country AS T1 INNER JOIN province AS T2 ON T1.Code = T2.Country INNER JOIN city AS T3 ON T3.Province = T2.Name INNER JOIN economy AS T4 ON T4.Country = T2.Country WHERE T3.Name = 'Fuenlabrada'",
        "amends": [
            "Do select `T4.Service * T4.GDP` as a calculated expression instead of just `GDP`. Do join multiple tables including `country AS T1`, `province AS T2`, `city AS T3`, and `economy AS T4` with `INNER JOIN` relationships instead of querying a single `country_data` table. Do use join conditions `T1.Code = T2.Country`, `T3.Province = T2.Name`, and `T4.Country = T2.Country` instead of no joins. Do filter on `T3.Name = 'Fuenlabrada'` instead of `city = 'Fuenlabrada' AND sector = 'Service'`. Do remove the `sector = 'Service'` filter entirely instead of including it, as the Service data is now properly referenced through the economy table join. The amended query now correctly joins multiple relational tables to calculate the Service sector GDP for the specified city."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT GDP FROM country_data WHERE city = 'Fuenlabrada' AND sector = 'Service';",
            "SELECT T4.Service * T4.GDP AS Service_GDP\nFROM country AS T1\nINNER JOIN province AS T2 ON T1.Code = T2.Country\nINNER JOIN city AS T3 ON T3.Province = T2.Name\nINNER JOIN economy AS T4 ON T4.Country = T2.Country\nWHERE T3.Name = 'Fuenlabrada'"
        ],
        "rule_sql": []
    },
    "3229": {
        "db_id": "donor",
        "question": "How many teachers in Twin Falls have Math & Science as their primary focus area?",
        "ground_truth": "SELECT COUNT(teacher_acctid) FROM projects WHERE school_county = 'Twin Falls' AND primary_focus_area = 'Math & Science'",
        "amends": [
            "Do query the `projects` table instead of the `teachers` table. Do use the `school_county` column for filtering instead of `city`. Do filter on `primary_focus_area` instead of `primary_focus`. Do count `teacher_acctid` instead of using `COUNT(*)`. The amended query now correctly counts teachers in Twin Falls county with Math & Science focus from the projects data instead of incorrectly querying a teachers table with different column names.",
            "Do remove `DISTINCT` from `COUNT(teacher_acctid)` instead of keeping it, as the query should count all teacher accounts meeting the filter criteria rather than counting distinct values only. The amended query now correctly counts all teacher accounts in Twin Falls county with Math & Science focus areas, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM teachers WHERE city = 'Twin Falls' AND primary_focus = 'Math & Science';",
            "SELECT COUNT(DISTINCT teacher_acctid) FROM projects WHERE school_county = 'Twin Falls' AND primary_focus_area = 'Math & Science';",
            "SELECT COUNT(teacher_acctid) FROM projects WHERE school_county = 'Twin Falls' AND primary_focus_area = 'Math & Science';"
        ],
        "rule_sql": []
    },
    "6671": {
        "db_id": "retails",
        "question": "When was the latest date the items of order no.1 were shipped?",
        "ground_truth": "SELECT MAX(l_shipdate) FROM lineitem WHERE l_orderkey = 1",
        "amends": [
            "Do reference `l_shipdate` instead of `shipped_date` in the MAX function. Do query from `lineitem` table instead of `orders` table. Do filter on `l_orderkey = 1` instead of `order_id = 1` in the WHERE clause. The amended query now correctly retrieves the maximum ship date from the lineitem table for the specified order key, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(shipped_date) FROM orders WHERE order_id = 1;",
            "SELECT MAX(l_shipdate) FROM lineitem WHERE l_orderkey = 1;"
        ],
        "rule_sql": []
    },
    "4689": {
        "db_id": "disney",
        "question": "Describe the hero, director, and the release date of Mulan.",
        "ground_truth": "SELECT T1.hero, T2.director, T1.release_date FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T1.movie_title = 'Mulan'",
        "amends": [
            "Do select columns `T1.hero`, `T2.director`, and `T1.release_date` from joined tables instead of `hero`, `director`, and `release_date` from a single table. Do use `FROM characters AS T1 INNER JOIN director AS T2` instead of `FROM movies` to properly join the character and director tables. Do add join condition `ON T1.movie_title = T2.name` instead of omitting any join relationship. Do keep the filter `WHERE T1.movie_title = 'Mulan'` but apply it to the joined table structure instead of a standalone table. The amended query now correctly retrieves hero and release date from the characters table while joining with director information based on movie title matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hero, director, release_date FROM movies WHERE title = 'Mulan';",
            "SELECT T1.hero, T2.director, T1.release_date \nFROM characters AS T1 \nINNER JOIN director AS T2 ON T1.movie_title = T2.name \nWHERE T1.movie_title = 'Mulan'"
        ],
        "rule_sql": []
    },
    "7865": {
        "db_id": "world",
        "question": "How many unofficial languages are used in Italy?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.IsOfficial = 'F' THEN 1 ELSE 0 END) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Italy'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.IsOfficial = 'F' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only non-official languages. Do join `Country AS T1` and `CountryLanguage AS T2` with `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying a single `languages` table. Do filter on `T1.Name = 'Italy'` instead of `country = 'Italy'` to use the country name from the Country table. Do reference `T2.IsOfficial = 'F'` instead of `official = 'no'` to match the correct boolean representation. The amended query now correctly counts non-official languages for Italy by properly joining country and language tables with appropriate filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country = 'Italy' AND official = 'no';",
            "SELECT SUM(CASE WHEN T2.IsOfficial = 'F' THEN 1 ELSE 0 END) AS UnofficialLanguageCount\nFROM Country AS T1\nINNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode\nWHERE T1.Name = 'Italy'"
        ],
        "rule_sql": []
    },
    "6121": {
        "db_id": "food_inspection_2",
        "question": "After Azha Restaurant Inc. passed the inspection on 2010/1/21, when was the follow-up inspection done?",
        "ground_truth": "SELECT T1.followup_to FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE T2.dba_name = 'Azha Restaurant Inc.' AND T1.results = 'Pass' AND T1.inspection_date = '2010-01-21'",
        "amends": [
            "Do select `T1.followup_to` instead of `inspection_date`. Do use `inSPECTION` and `establishment` tables with an `INNER JOIN` on `T1.license_no = T2.license_no` instead of only the `inspections` table. Do filter on `T2.dba_name = 'Azha Restaurant Inc.'` instead of `restaurant_name = 'Azha Restaurant Inc.'`. Do add `T1.results = 'Pass'` instead of omitting it. Do filter on `T1.inspection_date = '2010-01-21'` with date format `'2010-01-21'` instead of `inspection_date > '2010/1/21'`. Do remove `ORDER BY inspection_date ASC` and `LIMIT 1` instead of keeping them. The amended query now correctly retrieves follow-up information for a specific inspection date with proper table joins and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_date FROM inspections WHERE restaurant_name = 'Azha Restaurant Inc.' AND inspection_date > '2010/1/21' ORDER BY inspection_date ASC LIMIT 1;",
            "SELECT T1.followup_to \nFROM inspection T1\nINNER JOIN establishment T2 ON T1.license_no = T2.license_no\nWHERE T2.dba_name = 'Azha Restaurant Inc.'\nAND T1.results = 'Pass'\nAND T1.inspection_date = '2010-01-21'"
        ],
        "rule_sql": []
    },
    "8831": {
        "db_id": "food_inspection",
        "question": "Describe the violation dates, risk categories, descriptions and names of the eateries under Jade Chocolates LLC.",
        "ground_truth": "SELECT T1.`date`, T1.risk_category, T1.description, T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.owner_name = 'Jade Chocolates LLC'",
        "amends": [
            "Do select `T1.date`, `T1.risk_category`, `T1.description`, and `T2.name` instead of `violation_date`, `risk_category`, `description`, and `name`. Do use `violations AS T1` and `businesses AS T2` as sources instead of just `eateries`. Do add `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying a single table. Do filter on `T2.owner_name = 'Jade Chocolates LLC'` instead of `owner = 'Jade Chocolates LLC'`. The amended query now correctly joins violation and business data to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT violation_date, risk_category, description, name FROM eateries WHERE owner = 'Jade Chocolates LLC';",
            "SELECT T1.date, T1.risk_category, T1.description, T2.name\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T2.owner_name = 'Jade Chocolates LLC'"
        ],
        "rule_sql": []
    },
    "7391": {
        "db_id": "works_cycles",
        "question": "How much are the minimum orders of the vendors that are no longer used by the company?",
        "ground_truth": "SELECT T2.MinOrderQty FROM Vendor AS T1 INNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.ActiveFlag = 0 ORDER BY T2.MinOrderQty LIMIT 1",
        "amends": [
            "Do select `T2.MinOrderQty` instead of `MIN(order_amount)` and change the source to `Vendor AS T1 INNER JOIN ProductVendor AS T2` instead of `vendors`. Do use the join condition `T1.BusinessEntityID = T2.BusinessEntityID` instead of no join. Do filter with `T1.ActiveFlag = 0` instead of `status = 'inactive'`. Do add `ORDER BY T2.MinOrderQty` and `LIMIT 1` instead of using the aggregate function MIN. The amended query now correctly retrieves the minimum order quantity from the joined tables with proper filtering and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(order_amount) FROM vendors WHERE status = 'inactive';",
            "SELECT T2.MinOrderQty \nFROM Vendor AS T1 \nINNER JOIN ProductVendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID \nWHERE T1.ActiveFlag = 0 \nORDER BY T2.MinOrderQty \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3691": {
        "db_id": "college_completion",
        "question": "In 2012, how many Asian female graduates were seeking another type of degree or certificate at the 4-year institution at University of Alaska at Anchorage?",
        "ground_truth": "SELECT COUNT(*) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE T2.gender = 'F' AND T2.race = 'A' AND T1.chronname = 'University of Alaska at Anchorage' AND T2.cohort = '4y other'",
        "amends": [
            "Do join `institution_details` and `institution_grads` on `unitid` instead of querying a single `graduates` table. Do filter on `gender = 'F'` and `race = 'A'` instead of `gender = 'Female'` and `race = 'Asian'`. Do filter on `chronname = 'University of Alaska at Anchorage'` instead of `institution = 'University of Alaska at Anchorage'`. Do filter on `cohort = '4y other'` instead of separate `degree_type = 'Another type of degree or certificate'` and `institution_type = '4-year'` conditions. Do remove the `year = 2012` filter instead of keeping it. The amended query now correctly joins the institutional details with graduation data and uses the proper coded values for demographic and program attributes.",
            "Do select `COUNT(*)` instead of `ig.grad_cohort` to return a count instead of individual values. Do use table aliases `T1` and `T2` instead of `id` and `ig` for clarity. Do specify `INNER JOIN` explicitly instead of just `JOIN` for better readability. Do move the `chronname` filter to reference `T1.chronname` instead of `id.chronname` while keeping the same condition. Do keep the gender, race, and cohort filters on `T2` (institution_grads) instead of `ig` but with the same conditions. The amended query now correctly counts records instead of returning individual grad_cohort values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM graduates WHERE year = 2012 AND race = 'Asian' AND gender = 'Female' AND institution = 'University of Alaska at Anchorage' AND degree_type = 'Another type of degree or certificate' AND institution_type = '4-year'",
            "SELECT ig.grad_cohort \nFROM institution_grads ig\nJOIN institution_details id ON ig.unitid = id.unitid\nWHERE id.chronname = 'University of Alaska at Anchorage'\nAND ig.gender = 'F'\nAND ig.race = 'A'\nAND ig.cohort = '4y other'",
            "SELECT COUNT(*)\nFROM institution_details T1\nINNER JOIN institution_grads T2 ON T1.unitid = T2.unitid\nWHERE T1.chronname = 'University of Alaska at Anchorage'\nAND T2.gender = 'F'\nAND T2.race = 'A'\nAND T2.cohort = '4y other'"
        ],
        "rule_sql": []
    },
    "5588": {
        "db_id": "shipping",
        "question": "How much more pounds in total were transported to New York than to Chicago?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.city_name = 'New York' THEN T1.weight ELSE 0 END) - SUM(CASE WHEN T2.city_name = 'Chicago' THEN T1.weight ELSE 0 END) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id",
        "amends": [
            "Do use a single query with conditional aggregation instead of separate subqueries. Do join `shipment` table with `city` table on `city_id` instead of querying `shipments` table directly without proper table relationships. Do reference `T1.weight` instead of `weight_pounds` and `T2.city_name` instead of `destination`. Do use `CASE` expressions within `SUM` aggregates to calculate New York and Chicago weights in a single pass instead of subtracting results from separate queries. Do properly correlate the join condition `T1.city_id = T2.city_id` instead of assuming direct city name matching in the base table. The amended query now correctly handles the data relationships and produces the intended difference calculation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(weight_pounds) FROM shipments WHERE destination = 'New York') - \n    (SELECT SUM(weight_pounds) FROM shipments WHERE destination = 'Chicago') \nAS difference_in_pounds;",
            "SELECT \n    SUM(CASE WHEN T2.city_name = 'New York' THEN T1.weight ELSE 0 END) - \n    SUM(CASE WHEN T2.city_name = 'Chicago' THEN T1.weight ELSE 0 END) AS weight_difference\nFROM \n    shipment T1\nJOIN \n    city T2 ON T1.city_id = T2.city_id\nWHERE \n    T2.city_name IN ('New York', 'Chicago')"
        ],
        "rule_sql": []
    },
    "5111": {
        "db_id": "address",
        "question": "How many males are there in New Haven County's residential areas?",
        "ground_truth": "SELECT SUM(T1.male_population) FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'NEW HAVEN'",
        "amends": [
            "Do use `SUM(T1.male_population)` instead of `COUNT(*)` to aggregate actual population data rather than counting rows. Do source from `zip_data AS T1` instead of `residents` and join with `country AS T2` instead of querying a single table. Do use `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of no join condition. Do filter on `T2.county = 'NEW HAVEN'` instead of `county = 'New Haven'` and remove the unnecessary `gender = 'male'` and `area_type = 'residential'` filters since the male population is already pre-aggregated. The amended query now correctly calculates the total male population for New Haven county by summing pre-aggregated zip code data instead of attempting to count individual resident records with potentially incorrect filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM residents WHERE gender = 'male' AND county = 'New Haven' AND area_type = 'residential';",
            "SELECT SUM(T1.male_population) \nFROM zip_data AS T1 \nINNER JOIN country AS T2 ON T1.zip_code = T2.zip_code \nWHERE T2.county = 'NEW HAVEN'"
        ],
        "rule_sql": []
    },
    "4943": {
        "db_id": "olympics",
        "question": "What are the names of the events under Art Competitions?",
        "ground_truth": "SELECT T2.event_name FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Art Competitions'",
        "amends": [
            "Do select `T2.event_name` from the `event` table instead of `name` from the `events` table. Do join `sport AS T1` with `event AS T2` using `INNER JOIN` on `T1.id = T2.sport_id` instead of querying a single table. Do filter on `T1.sport_name = 'Art Competitions'` instead of `category = 'Art Competitions'`. The amended query now correctly retrieves event names by joining the sport and event tables and filtering on sport name rather than using a non-existent events table with incorrect column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM events WHERE category = 'Art Competitions';",
            "SELECT T2.event_name FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Art Competitions'"
        ],
        "rule_sql": []
    },
    "2675": {
        "db_id": "regional_sales",
        "question": "How many orders through distributor were for the minimum quantity?",
        "ground_truth": "SELECT SUM(CASE WHEN `Order Quantity` = 1 AND `Sales Channel` = 'Distributor' THEN 1 ELSE 0 END) FROM `Sales Orders`",
        "amends": [
            "Do use `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count specific conditional matches. Do reference `Order Quantity` and `Sales Channel` columns instead of `quantity` and `distributor`. Do use equality comparison `= 1` instead of subquery `= (SELECT MAX(quantity) FROM orders)` for quantity filtering. Do use string literal 'Distributor' instead of numeric value 1 for channel identification. Do reference table `Sales Orders` instead of `orders`. Do remove the subquery entirely instead of keeping it for maximum quantity comparison. The amended query now correctly counts orders where quantity equals 1 and sales channel is Distributor, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE quantity = (SELECT MAX(quantity) FROM orders) AND distributor = 1;",
            "SELECT SUM(CASE WHEN \"Order Quantity\" = 1 AND \"Sales Channel\" = 'Distributor' THEN 1 ELSE 0 END) AS order_count FROM \"Sales Orders\""
        ],
        "rule_sql": []
    },
    "6718": {
        "db_id": "retails",
        "question": "What are the names of the parts manufactured by manufacturer 3 that have a supply cost of 1,000?",
        "ground_truth": "SELECT T2.p_name FROM partsupp AS T1 INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey WHERE T1.ps_supplycost = 1000 AND T2.p_mfgr = 'Manufacturer#3'",
        "amends": [
            "Do select `T2.p_name` from the `part` table instead of `part_name` from the `parts` table. Do join `partsupp AS T1` with `part AS T2` using `INNER JOIN` on `T1.ps_partkey = T2.p_partkey` instead of querying a single table. Do filter by `T2.p_mfgr = 'Manufacturer#3'` instead of `manufacturer_id = 3` to use the correct manufacturer identifier format. Do filter by `T1.ps_supplycost = 1000` from the `partsupp` table instead of `supply_cost = 1000` from a non-existent column. The amended query now correctly joins the part and partsupp tables to retrieve part names with the specified supply cost and manufacturer, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT part_name FROM parts WHERE manufacturer_id = 3 AND supply_cost = 1000;",
            "SELECT T2.p_name\nFROM partsupp AS T1\nINNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey\nWHERE T2.p_mfgr = 'Manufacturer#3'\nAND T1.ps_supplycost = 1000"
        ],
        "rule_sql": []
    },
    "6005": {
        "db_id": "books",
        "question": "How much time does it take to update the status of order \"2398\"?",
        "ground_truth": "SELECT strftime('%J', T2.status_date) - strftime('%J', T1.order_date) FROM cust_order AS T1 INNER JOIN order_history AS T2 ON T1.order_id = T2.order_id WHERE T1.order_id = 2398",
        "amends": [
            "Do select `strftime('%J', T2.status_date) - strftime('%J', T1.order_date)` instead of `*` to calculate date differences. Do join `cust_order AS T1 INNER JOIN order_history AS T2 ON T1.order_id = T2.order_id` instead of querying only `orders` to access both order and history data. Do filter on `T1.order_id = 2398` instead of `order_id = 2398` to reference the joined table correctly. The amended query now correctly calculates the duration between order and status dates for the specified order ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM orders WHERE order_id = 2398;",
            "SELECT strftime('%J', T2.status_date) - strftime('%J', T1.order_date) \nFROM cust_order AS T1 \nINNER JOIN order_history AS T2 ON T1.order_id = T2.order_id \nWHERE T1.order_id = 2398"
        ],
        "rule_sql": []
    },
    "4340": {
        "db_id": "simpson_episodes",
        "question": "Among the episodes which have star score greater than 5, how many episodes have air date in 2008?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE strftime('%Y', T1.air_date) = '2008' AND T2.stars > 5;",
        "amends": [
            "Do count `DISTINCT T2.episode_id` instead of `COUNT(*)` to avoid duplicate episode counts. Do join `Vote AS T2` with `Episode AS T1` on `T2.episode_id = T1.episode_id` instead of querying only the episodes table. Do filter by `strftime('%Y', T1.air_date) = '2008'` instead of `air_date LIKE '2008%'` for proper year extraction. Do use `T2.stars > 5` instead of `star_score > 5` to reference the correct column from the Vote table. The amended query now correctly counts distinct episodes from 2008 with votes exceeding 5 stars, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE star_score > 5 AND air_date LIKE '2008%';",
            "SELECT COUNT(DISTINCT T2.episode_id) \nFROM Vote AS T2 \nJOIN Episode AS T1 ON T2.episode_id = T1.episode_id \nWHERE T2.stars > 5 \nAND strftime('%Y', T1.air_date) = '2008'"
        ],
        "rule_sql": []
    },
    "2644": {
        "db_id": "regional_sales",
        "question": "How many sales team were from Northeast?",
        "ground_truth": "SELECT SUM(CASE WHEN Region = 'Northeast' THEN 1 ELSE 0 END) FROM `Sales Team`",
        "amends": [
            "Do use `SUM(CASE WHEN Region = 'Northeast' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only Northeast region records. Do reference table `Sales Team` instead of `sales_team` with proper case sensitivity. Do use column `Region` instead of `region` with proper case sensitivity. The amended query now correctly counts only Northeast region records instead of all records when the region filter is applied."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales_team WHERE region = 'Northeast';",
            "SELECT SUM(CASE WHEN Region = 'Northeast' THEN 1 ELSE 0 END) AS NortheastTeamCount FROM \"Sales Team\";"
        ],
        "rule_sql": []
    },
    "1524": {
        "db_id": "synthea",
        "question": "List all the full names of patients with a condition described as cystitis.",
        "ground_truth": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.patient WHERE T2.DESCRIPTION = 'Cystitis'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and do use aliases `T1.first` and `T1.last` instead of `first_name` and `last_name`. Do add `INNER JOIN conditions AS T2` instead of querying only the `patients` table, and do join on `T1.patient = T2.patient` instead of no join condition. Do move the filter to `T2.DESCRIPTION = 'Cystitis'` instead of `condition = 'cystitis'`, and do use uppercase 'Cystitis' instead of lowercase 'cystitis'. The amended query now correctly identifies patients with cystitis by joining with the conditions table and matching the standardized condition description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM patients WHERE condition = 'cystitis';",
            "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.patient WHERE T2.DESCRIPTION = 'Cystitis'"
        ],
        "rule_sql": []
    },
    "3837": {
        "db_id": "public_review_platform",
        "question": "How long does business number 12 in Scottsdale stay open on day number 3?",
        "ground_truth": "SELECT T2.closing_time - T2.opening_time AS \"hour\" FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE T1.business_id = 12 AND T1.city LIKE 'Scottsdale' AND T2.day_id = 3",
        "amends": [
            "Do add `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying only one table. Do reference `T2.closing_time` and `T2.opening_time` instead of direct column references without table aliases. Do change the alias to `\"hour\"` instead of `hours_open`. Do add table `Business AS T1` instead of omitting it. Do use `T1.city LIKE 'Scottsdale'` instead of `city = 'Scottsdale'` without table qualification. Do use `T2.day_id = 3` instead of `day_of_week = 3` with corrected column name and table alias. Do add `WHERE T1.business_id = 12` instead of filtering only on the business_hours table. The amended query now correctly joins business information with hours data and matches the intended behavior.",
            "Do calculate the hour difference by directly subtracting `T2.closing_time - T2.opening_time` instead of using `strftime('%H', T2.closing_time) - strftime('%H', T2.opening_time)` which extracts only hour components. Do use double quotes for the alias `\"hour\"` instead of unquoted `hour` to match the expected output format. The join logic, table sources, WHERE filters including `T1.business_id = 12`, `T1.city LIKE 'Scottsdale'`, and `T2.day_id = 3` remain unchanged as they were already correct. The amended query now correctly calculates the time difference between opening and closing times rather than just the hour difference, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT closing_time - opening_time AS hours_open FROM business_hours WHERE business_id = 12 AND city = 'Scottsdale' AND day_of_week = 3;",
            "SELECT (strftime('%H', T2.closing_time) - strftime('%H', T2.opening_time)) AS hour\nFROM Business AS T1\nINNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id\nWHERE T1.business_id = 12 \nAND T1.city LIKE 'Scottsdale'\nAND T2.day_id = 3",
            "SELECT (T2.closing_time - T2.opening_time) AS \"hour\"\nFROM Business AS T1\nINNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id\nWHERE T1.business_id = 12\nAND T1.city LIKE 'Scottsdale'\nAND T2.day_id = 3"
        ],
        "rule_sql": []
    },
    "1515": {
        "db_id": "synthea",
        "question": "How many black patients stopped their care plan in 2017?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.patient) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.race = 'black' AND strftime('%Y', T1.STOP) = '2017'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.patient)` instead of `COUNT(*)` to count unique patients rather than all records. Do join `careplans AS T1` with `patients AS T2` on `T1.PATIENT = T2.patient` instead of querying only the patients table. Do filter on `T2.race = 'black'` instead of `race = 'black'` with proper table qualification. Do use `strftime('%Y', T1.STOP) = '2017'` for year extraction instead of `YEAR(stop_date) = 2017` with the correct date column from the careplans table. Do remove the `care_plan_status = 'stopped'` filter instead of keeping it as the condition is handled through the join and date logic. The amended query now correctly counts distinct black patients with care plans stopped in 2017 by properly joining the relevant tables and using appropriate date functions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE race = 'black' AND care_plan_status = 'stopped' AND YEAR(stop_date) = 2017;",
            "SELECT COUNT(DISTINCT T2.patient) \nFROM careplans AS T1 \nJOIN patients AS T2 ON T1.PATIENT = T2.patient \nWHERE T2.race = 'black' \nAND strftime('%Y', T1.STOP) = '2017'"
        ],
        "rule_sql": []
    },
    "7664": {
        "db_id": "hockey",
        "question": "Please list the awards won by coaches who taught the NHL League and have already died.",
        "ground_truth": "SELECT DISTINCT T2.award FROM Master AS T1 INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE T1.deathYear IS NOT NULL AND T2.lgID = 'NHL'",
        "amends": [
            "Do use `DISTINCT` on `award` instead of omitting it. Do select `award` instead of `award_name`. Do join `Master` as `T1` and `AwardsCoaches` as `T2` instead of `awards` and `coaches`. Do use `INNER JOIN` on `T1.coachID = T2.coachID` instead of `JOIN` on `a.coach_id = c.coach_id`. Do filter with `T1.deathYear IS NOT NULL` instead of `c.status = 'dead'`. Do filter with `T2.lgID = 'NHL'` instead of `c.league = 'NHL'`. The amended query now correctly identifies NHL coaches who have died using proper NULL semantics instead of a status field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.award_name \nFROM awards a\nJOIN coaches c ON a.coach_id = c.coach_id\nWHERE c.league = 'NHL' \nAND c.status = 'dead';",
            "SELECT DISTINCT T2.award\nFROM Master T1\nINNER JOIN AwardsCoaches T2 ON T1.coachID = T2.coachID\nWHERE T1.deathYear IS NOT NULL\nAND T2.lgID = 'NHL'"
        ],
        "rule_sql": []
    },
    "1947": {
        "db_id": "soccer_2016",
        "question": "Compute the run rate at the end of 16 overs of the match ID 335999. Please include the name of the \"Man of_the Match\".",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.Toss_Name = 'bat' THEN T3.Runs_Scored ELSE NULL END) AS REAL) / SUM(CASE WHEN T1.Toss_Name = 'field' THEN 1 ELSE 0 END) FROM Toss_Decision AS T1 INNER JOIN Match AS T2 ON T1.Toss_Id = T2.Toss_Decide INNER JOIN Batsman_Scored AS T3 ON T2.Match_Id = T3.Match_Id WHERE T2.Match_Id = 335987 AND T2.Match_Date = '2008-04-18' GROUP BY T3.Over_Id HAVING COUNT(T1.Toss_Name = 'field') = 16",
        "amends": [
            "Do use `CAST(COUNT(CASE WHEN T1.Toss_Name = 'bat' THEN T3.Runs_Scored ELSE NULL END) AS REAL) / SUM(CASE WHEN T1.Toss_Name = 'field' THEN 1 ELSE 0 END)` instead of `(SUM(runs_scored) + SUM(extra_runs)) / 16.0 AS run_rate` for the calculation. Do change the FROM clause to use `Toss_Decision AS T1 INNER JOIN Match AS T2 ON T1.Toss_Id = T2.Toss_Decide INNER JOIN Batsman_Scored AS T3 ON T2.Match_Id = T3.Match_Id` instead of `ball_by_ball b JOIN match m ON b.match_id = m.match_id` with different table sources and join conditions. Do modify the WHERE clause to use `T2.Match_Id = 335987 AND T2.Match_Date = '2008-04-18'` instead of `b.match_id = 335999 AND over_id <= 16` with different filter criteria. Do change the GROUP BY to `T3.Over_Id` instead of `m.match_id, m.man_of_the_match` and add a HAVING clause with `COUNT(T1.Toss_Name = 'field') = 16` instead of omitting it. Do remove the `player_name AS man_of_the_match` column selection instead of including it. The amended query now correctly calculates the ratio based on toss decisions and match conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(runs_scored) + SUM(extra_runs)) / 16.0 AS run_rate,\n    player_name AS man_of_the_match\nFROM \n    ball_by_ball b\nJOIN \n    match m ON b.match_id = m.match_id\nWHERE \n    b.match_id = 335999 \n    AND over_id <= 16\nGROUP BY \n    m.match_id, m.man_of_the_match",
            "SELECT CAST(COUNT(CASE WHEN T1.Toss_Name = 'bat' THEN T3.Runs_Scored ELSE NULL END) AS REAL) / SUM(CASE WHEN T1.Toss_Name = 'field' THEN 1 ELSE 0 END) AS run_rate\nFROM Toss_Decision AS T1 \nINNER JOIN Match AS T2 ON T1.Toss_Id = T2.Toss_Decide \nINNER JOIN Batsman_Scored AS T3 ON T2.Match_Id = T3.Match_Id\nWHERE T2.Match_Id = 335987 AND T2.Match_Date = '2008-04-18'\nGROUP BY T3.Over_Id\nHAVING COUNT(T1.Toss_Name = 'field') = 16"
        ],
        "rule_sql": []
    },
    "8013": {
        "db_id": "university",
        "question": "Provide the ranking system of the ranking criteria named Quality of Education Rank.",
        "ground_truth": "SELECT T1.system_name FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T2.criteria_name = 'Quality of Education Rank'",
        "amends": [
            "Do select `system_name` from the `ranking_system` table instead of `ranking_system` from the `ranking_criteria` table. Do add an `INNER JOIN` between `ranking_system AS T1` and `ranking_criteria AS T2` with the join condition `T1.id = T2.ranking_system_id` instead of querying only the `ranking_criteria` table. Do reference the joined table alias `T1.system_name` in the SELECT clause instead of the original column `ranking_system`. The amended query now correctly retrieves the system name by joining the related tables through their foreign key relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_system FROM ranking_criteria WHERE criteria_name = 'Quality of Education Rank';",
            "SELECT T1.system_name \nFROM ranking_system AS T1\nINNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id\nWHERE T2.criteria_name = 'Quality of Education Rank';"
        ],
        "rule_sql": []
    },
    "1451": {
        "db_id": "synthea",
        "question": "What gender is more prone to 'dander (animal) allergy'?",
        "ground_truth": "SELECT T1.gender FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Dander (animal) allergy' GROUP BY T1.gender ORDER BY COUNT(T1.gender) DESC LIMIT 1",
        "amends": [
            "Do join `patients AS T1` with `allergies AS T2` on `T1.patient = T2.PATIENT` instead of querying only the `patients` table. Do filter on `T2.DESCRIPTION = 'Dander (animal) allergy'` instead of `allergy = 'dander (animal) allergy'`. Do select `T1.gender` instead of both `gender` and `COUNT(*) as count`. Do group by `T1.gender` instead of `gender`. Do order by `COUNT(T1.gender) DESC` instead of `count DESC`. The amended query now correctly joins the allergies table to filter by allergy description and returns only the gender with the highest count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) as count FROM patients WHERE allergy = 'dander (animal) allergy' GROUP BY gender ORDER BY count DESC LIMIT 1;",
            "SELECT T1.gender\nFROM patients AS T1\nJOIN allergies AS T2 ON T1.patient = T2.PATIENT\nWHERE T2.DESCRIPTION = 'Dander (animal) allergy'\nGROUP BY T1.gender\nORDER BY COUNT(T1.gender) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4937": {
        "db_id": "olympics",
        "question": "Show the name of the competitor id 90991.",
        "ground_truth": "SELECT T1.full_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE T2.id = 90991",
        "amends": [
            "Do select `T1.full_name` instead of `competitor_name`. Do use `FROM person AS T1 INNER JOIN games_competitor AS T2` instead of `FROM competitors`. Do add join condition `ON T1.id = T2.person_id` instead of omitting it. Do change filter to `WHERE T2.id = 90991` instead of `WHERE id = 90991`. The amended query now correctly joins person and games_competitor tables to retrieve the full name associated with the competitor ID, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT competitor_name FROM competitors WHERE id = 90991;",
            "SELECT T1.full_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE T2.id = 90991"
        ],
        "rule_sql": []
    },
    "1123": {
        "db_id": "talkingdata",
        "question": "Provide the number of events that happened on 2016/5/6.",
        "ground_truth": "SELECT COUNT(event_id) FROM events WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-06'",
        "amends": [
            "Do count `event_id` instead of `*` to exclude null values. Do use `SUBSTR(timestamp, 1, 10)` to extract the date portion instead of relying on a separate `date` column. Do format the date comparison as `'2016-05-06'` with standard ISO format and hyphens instead of `'2016/5/6'` with slashes and inconsistent month padding. The amended query now correctly counts non-null event IDs for the specified date by extracting from the timestamp field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE date = '2016/5/6';",
            "SELECT COUNT(event_id) FROM events WHERE SUBSTR(timestamp, 1, 10) = '2016-05-06'"
        ],
        "rule_sql": []
    },
    "3112": {
        "db_id": "cars",
        "question": "What is the horsepower and model year of the car named Subaru Dl?",
        "ground_truth": "SELECT T1.horsepower, T2.model_year FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T1.car_name = 'subaru dl'",
        "amends": [
            "Do specify table aliases `T1.horsepower` and `T2.model_year` instead of unqualified column names. Do join `data AS T1` with `production AS T2` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `T1.car_name = 'subaru dl'` instead of `name = 'Toyota Corolla'` to match the correct table and value. The amended query now correctly joins the two tables and filters for the specified car model."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT horsepower, model_year FROM cars WHERE name = 'Toyota Corolla';",
            "SELECT T1.horsepower, T2.model_year FROM data AS T1 JOIN production AS T2 ON T1.ID = T2.ID WHERE T1.car_name = 'subaru dl'"
        ],
        "rule_sql": []
    },
    "5424": {
        "db_id": "sales",
        "question": "Calculate the total quantity of products that are gifts.",
        "ground_truth": "SELECT SUM(T2.Quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Price = 0",
        "amends": [
            "Do join `Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID` instead of querying only the `products` table. Do filter on `T1.Price = 0` instead of `category = 'gift'`. Do aggregate `SUM(T2.Quantity)` from the Sales table instead of `SUM(quantity)` from the Products table. The amended query now correctly calculates total quantities of free products sold by joining the relevant tables and applying the proper price filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM products WHERE category = 'gift';",
            "SELECT SUM(T2.Quantity) AS TotalGiftQuantity\nFROM Products AS T1\nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nWHERE T1.Price = 0"
        ],
        "rule_sql": []
    },
    "3269": {
        "db_id": "donor",
        "question": "How many donations of more than $100 were made for an honoree?",
        "ground_truth": "SELECT COUNT(donationid) FROM donations WHERE dollar_amount = '100_and_up' AND for_honoree = 't'",
        "amends": [
            "Do count `donationid` instead of `*` to exclude null values. Do filter on `dollar_amount = '100_and_up'` instead of `amount > 100` to use the categorical classification. Do filter on `for_honoree = 't'` instead of `honoree_id IS NULL` to properly identify honoree-related donations using the correct boolean flag. The amended query now correctly counts donations in the $100+ category that are designated for honorees."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM donations WHERE amount > 100 AND honoree_id IS NULL;",
            "SELECT COUNT(donationid) FROM donations WHERE dollar_amount = '100_and_up' AND for_honoree = 't'"
        ],
        "rule_sql": []
    },
    "2577": {
        "db_id": "regional_sales",
        "question": "What is the average median income for all City type of stores?",
        "ground_truth": "SELECT AVG(`Median Income`) FROM `Store Locations` WHERE Type = 'City'",
        "amends": [
            "Do reference the column as `Median Income` instead of `income` and use backticks for the column name containing spaces. Do reference the table as `Store Locations` instead of `stores` and use backticks for the table name containing spaces. Do capitalize the filter condition as `Type = 'City'` instead of `type = 'City'` to match the correct column name case. The amended query now correctly calculates the average median income for city store locations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(income) FROM stores WHERE type = 'City';",
            "SELECT AVG(`Median Income`) AS AverageMedianIncome FROM `Store Locations` WHERE Type = 'City';"
        ],
        "rule_sql": []
    },
    "2190": {
        "db_id": "world_development_indicators",
        "question": "In 1960, what is largest population for country with upper middle income?",
        "ground_truth": "SELECT MAX(T2.Value) FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IncomeGroup = 'Upper middle income' AND T2.Year = 1960 AND T2.IndicatorName = 'Population, total'",
        "amends": [
            "Do join `Country` and `Indicators` tables with `INNER JOIN` on `CountryCode` instead of querying a single `countries` table. Do filter on `IndicatorName = 'Population, total'` instead of assuming population data. Do use `T2.Value` for the population values instead of a generic `population` column. Do reference `T1.IncomeGroup` for income level filtering instead of `income_level`. Do specify `T2.Year` for the year filter instead of just `year`. The amended query now correctly joins the necessary tables and filters to retrieve the maximum population value for upper middle income countries in 1960."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(population) FROM countries WHERE year = 1960 AND income_level = 'Upper middle income';",
            "SELECT MAX(T2.Value) AS LargestPopulation\nFROM Country T1\nINNER JOIN Indicators T2 ON T1.CountryCode = T2.CountryCode\nWHERE T1.IncomeGroup = 'Upper middle income'\nAND T2.IndicatorName = 'Population, total'\nAND T2.Year = 1960"
        ],
        "rule_sql": []
    },
    "2859": {
        "db_id": "professional_basketball",
        "question": "How many field goals did George Mikan make overall between 1951 and 1953?",
        "ground_truth": "SELECT COUNT(fg_made) FROM player_allstar WHERE first_name = 'George' AND last_name = 'Mikan' AND season_id BETWEEN 1951 AND 1953",
        "amends": [
            "Do use `COUNT(fg_made)` instead of `SUM(field_goals_made)` for counting field goals. Do query from `player_allstar` table instead of `player_stats` table. Do filter by `first_name = 'George'` and `last_name = 'Mikan'` instead of `player_name = 'George Mikan'` to use separate name columns. Do use `season_id BETWEEN 1951 AND 1953` instead of `year BETWEEN 1951 AND 1953` for the season identifier. The amended query now correctly counts field goals made by George Mikan from the appropriate all-star data table using proper name filtering and season identification.",
            "Do use `COUNT(fg_made)` instead of `SUM(fg_made) AS total_field_goals_made` to count occurrences rather than summing values, and do remove the alias `total_field_goals_made` instead of keeping it. The amended query now correctly counts field goals made rather than summing them, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(field_goals_made) \nFROM player_stats \nWHERE player_name = 'George Mikan' \nAND year BETWEEN 1951 AND 1953;",
            "SELECT SUM(fg_made) AS total_field_goals_made\nFROM player_allstar\nWHERE first_name = 'George' \nAND last_name = 'Mikan'\nAND season_id BETWEEN 1951 AND 1953;",
            "SELECT COUNT(fg_made) FROM player_allstar WHERE first_name = 'George' AND last_name = 'Mikan' AND season_id BETWEEN 1951 AND 1953;"
        ],
        "rule_sql": []
    },
    "5114": {
        "db_id": "address",
        "question": "For the county represented by Thompson Bennie G, how many bad aliases does it have?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.bad_alias) FROM zip_congress AS T1 INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T1.district = T3.cognress_rep_id WHERE T3.first_name = 'Thompson' AND T3.last_name = 'Bennie G'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.bad_alias)` instead of `COUNT(*)` to count distinct bad aliases rather than all rows. Do join `zip_congress AS T1` instead of querying `aliases` alone, and add `INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code` to connect zip codes with bad aliases. Do add `INNER JOIN congress AS T3 ON T1.district = T3.cognress_rep_id` to link districts with congressional representatives instead of filtering by county name directly. Do filter with `T3.first_name = 'Thompson' AND T3.last_name = 'Bennie G'` instead of `county = 'Thompson Bennie G' AND alias_type = 'bad'` to properly match the representative by name components rather than assuming county format. The amended query now correctly counts distinct bad aliases for the specified congressional representative by properly joining through the relational schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM aliases WHERE county = 'Thompson Bennie G' AND alias_type = 'bad';",
            "SELECT COUNT(DISTINCT T2.bad_alias) \nFROM zip_congress AS T1\nINNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code\nINNER JOIN congress AS T3 ON T1.district = T3.cognress_rep_id\nWHERE T3.first_name = 'Thompson' AND T3.last_name = 'Bennie G'"
        ],
        "rule_sql": []
    },
    "7310": {
        "db_id": "works_cycles",
        "question": "List the name of employees who had left the company? When were they hired?",
        "ground_truth": "SELECT T1.FirstName, T1.LastName, T2.HireDate FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE T3.EndDate IS NOT NULL",
        "amends": [
            "Do select `T1.FirstName`, `T1.LastName`, and `T2.HireDate` instead of `name` and `hire_date`. Do use `INNER JOIN` between `Person AS T1` and `Employee AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of a single table. Do add another `INNER JOIN` to `EmployeeDepartmentHistory AS T3` on `T2.BusinessEntityID = T3.BusinessEntityID` instead of omitting this table. Do filter with `T3.EndDate IS NOT NULL` instead of `status = 'active'`. The amended query now correctly retrieves employee hire dates from joined tables with proper department history filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, hire_date FROM employees WHERE status = 'active';",
            "SELECT T1.FirstName, T1.LastName, T2.HireDate\nFROM Person AS T1\nINNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN EmployeeDepartmentHistory AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID\nWHERE T3.EndDate IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "5504": {
        "db_id": "menu",
        "question": "Who is the sponsor of menu with ID 12463?",
        "ground_truth": "SELECT sponsor FROM Menu WHERE id = 12463",
        "amends": [
            "Do reference table `Menu` instead of `menus` in the FROM clause. Do filter on column `id` instead of `menu_id` in the WHERE condition. The amended query now correctly retrieves the sponsor from the Menu table using the appropriate primary key column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sponsor FROM menus WHERE menu_id = 12463;",
            "SELECT sponsor FROM Menu WHERE id = 12463;"
        ],
        "rule_sql": []
    },
    "3939": {
        "db_id": "public_review_platform",
        "question": "How many businesses are opened for 24 hours?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_value LIKE 'TRUE' AND T1.attribute_name LIKE 'Open 24 Hours'",
        "amends": [
            "Do select `COUNT(T2.business_id)` instead of `COUNT(*)` to count specific business IDs rather than all rows. Do use `Attributes AS T1 INNER JOIN Business_Attributes AS T2` instead of querying only the `businesses` table to properly join the attribute metadata with business associations. Do apply the join condition `T1.attribute_id = T2.attribute_id` instead of no join condition to correctly link attributes to businesses. Do filter with `T2.attribute_value LIKE 'TRUE' AND T1.attribute_name LIKE 'Open 24 Hours'` instead of `hours = '24 hours'` to properly identify businesses with the specific 24-hour open attribute set to true. The amended query now correctly identifies businesses marked as open 24 hours through the proper attribute system instead of relying on a potentially incorrect or non-existent hours column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE hours = '24 hours';",
            "SELECT COUNT(T2.business_id) \nFROM Attributes AS T1 \nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id \nWHERE T2.attribute_value LIKE 'TRUE' AND T1.attribute_name LIKE 'Open 24 Hours'"
        ],
        "rule_sql": []
    },
    "3792": {
        "db_id": "public_review_platform",
        "question": "Give the number of \"drive-thru\" businesses in \"Scottsdale\" with business ID number less than \"1000\".",
        "ground_truth": "SELECT T2.business_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T3.business_id < 1000 AND T3.city LIKE 'Scottsdale' AND T1.attribute_name LIKE 'Drive-Thru' AND T2.attribute_value LIKE 'TRUE'",
        "amends": [
            "Do select `T2.business_id` instead of `COUNT(*)`. Do join `Attributes AS T1` and `Business_Attributes AS T2` with `INNER JOIN` on `T1.attribute_id = T2.attribute_id` instead of querying only `businesses`. Do add `Business AS T3` with `INNER JOIN` on `T2.business_id = T3.business_id` instead of omitting these tables. Do filter with `T3.business_id < 1000` instead of `business_id < 1000`. Do filter with `T3.city LIKE 'Scottsdale'` instead of `city = 'Scottsdale'`. Do add `T1.attribute_name LIKE 'Drive-Thru'` and `T2.attribute_value LIKE 'TRUE'` instead of `business_type = 'drive-thru'` to properly check attribute values. The amended query now correctly joins attribute tables and filters based on attribute name and value rather than a direct business_type column.",
            "Do select `T2.business_id` instead of `COUNT(*)` to return individual business IDs rather than an aggregate count. Do remove the redundant `AND T3.city LIKE 'Scottsdale'` filter from the WHERE clause instead of keeping it, as this condition is already handled by the join logic. Do reorder the WHERE conditions for logical clarity instead of the original sequence, though this is purely cosmetic. The amended query now correctly returns business IDs that match the specified criteria rather than counting them, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE business_type = 'drive-thru' AND city = 'Scottsdale' AND business_id < 1000;",
            "SELECT COUNT(*) \nFROM Attributes AS T1\nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\nINNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nWHERE T1.attribute_name LIKE 'Drive-Thru'\nAND T2.attribute_value LIKE 'TRUE'\nAND T3.city LIKE 'Scottsdale'\nAND T3.business_id < 1000",
            "SELECT T2.business_id\nFROM Attributes AS T1\nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\nINNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nWHERE T1.attribute_name LIKE 'Drive-Thru'\nAND T2.attribute_value LIKE 'TRUE'\nAND T3.city LIKE 'Scottsdale'\nAND T3.business_id < 1000"
        ],
        "rule_sql": []
    },
    "1108": {
        "db_id": "talkingdata",
        "question": "List 5 device models that users use to install the app and are active in using the app.",
        "ground_truth": "SELECT T1.device_model FROM phone_brand_device_model2 AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.event_id INNER JOIN app_events AS T3 ON T2.event_id = T3.event_id WHERE T3.is_active = 1 AND T3.is_installed = 1 LIMIT 5",
        "amends": [
            "Do select `T1.device_model` from the `phone_brand_device_model2` table instead of selecting `device_model` from the `users` table. Do add two `INNER JOIN` operations instead of having no joins - joining `events` AS T2 on `T1.device_id = T2.event_id` and joining `app_events` AS T3 on `T2.event_id = T3.event_id`. Do add a `WHERE` clause with filters `T3.is_active = 1` AND `T3.is_installed = 1` instead of having no filtering conditions. The amended query now correctly retrieves device models from the appropriate table with proper join relationships and filtering conditions to match the intended behavior.",
            "Do join `events AS T2` on `T1.device_id = T2.event_id` instead of `T1.device_id = T2.device_id` to correctly match the device identifier with the event identifier. Do remove the `GROUP BY T1.device_model` clause instead of keeping it since there are no aggregate functions in the SELECT list that require grouping. The amended query now matches RIGHT_SQL's behavior by fixing the join condition and eliminating unnecessary grouping.",
            "Do remove `DISTINCT` instead of keeping it. Do change the join condition from `T1.device_id = T2.device_id` to `T1.device_id = T2.event_id` instead of using the wrong column reference. Do keep the same `WHERE` filter conditions `T3.is_installed = 1 AND T3.is_active = 1` instead of changing them. The amended query now correctly joins on the appropriate event identifier and removes the unnecessary distinct clause while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_model FROM users LIMIT 5;",
            "SELECT T1.device_model\nFROM phone_brand_device_model2 AS T1\nINNER JOIN events AS T2 ON T1.device_id = T2.device_id\nINNER JOIN app_events AS T3 ON T2.event_id = T3.event_id\nWHERE T3.is_active = 1 AND T3.is_installed = 1\nGROUP BY T1.device_model\nLIMIT 5",
            "SELECT DISTINCT T1.device_model\nFROM phone_brand_device_model2 AS T1\nINNER JOIN events AS T2 ON T1.device_id = T2.device_id\nINNER JOIN app_events AS T3 ON T2.event_id = T3.event_id\nWHERE T3.is_installed = 1 AND T3.is_active = 1\nLIMIT 5",
            "SELECT T1.device_model\nFROM phone_brand_device_model2 AS T1\nINNER JOIN events AS T2 ON T1.device_id = T2.event_id\nINNER JOIN app_events AS T3 ON T2.event_id = T3.event_id\nWHERE T3.is_installed = 1 AND T3.is_active = 1\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "1780": {
        "db_id": "restaurant",
        "question": "In which region can you find the highest number of Baskin Robbins restaurants?",
        "ground_truth": "SELECT T2.region AS num FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.label = 'baskin robbins' GROUP BY T2.region ORDER BY COUNT(T1.city) DESC LIMIT 1",
        "amends": [
            "Do use `T2.region AS num` instead of `region` and add proper table aliases instead of bare column references. Do join `generalinfo AS T1` with `geographic AS T2` on `T1.city = T2.city` instead of querying only `baskin_robbins` table. Do add `WHERE T1.label = 'baskin robbins'` filter instead of omitting it. Do change `COUNT(*)` to `COUNT(T1.city)` and move the aggregate to the ORDER BY clause instead of using an alias. Do change ordering to `DESC` instead of `ASC` and maintain the `LIMIT 1` clause. The amended query now correctly joins the appropriate tables, filters for Baskin Robbins establishments, counts cities per region, and returns the region with the highest count.",
            "Do use `T2.region AS num` in the SELECT list instead of `T2.region, COUNT(T1.city) AS num` to return the region name as the result instead of a count. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity, though this is functionally equivalent. Do remove the `COUNT(T1.city)` aggregation from the SELECT list instead of including it, as the RIGHT_SQL returns the region name rather than a count of cities. The amended query now correctly returns the region name with alias `num` for the region with the most Baskin Robbins locations, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as restaurant_count FROM baskin_robbins GROUP BY region ORDER BY restaurant_count ASC LIMIT 1;",
            "SELECT T2.region, COUNT(T1.city) AS num\nFROM generalinfo AS T1\nJOIN geographic AS T2 ON T1.city = T2.city\nWHERE T1.label = 'baskin robbins'\nGROUP BY T2.region\nORDER BY COUNT(T1.city) DESC\nLIMIT 1",
            "SELECT T2.region AS num\nFROM generalinfo AS T1\nINNER JOIN geographic AS T2 ON T1.city = T2.city\nWHERE T1.label = 'baskin robbins'\nGROUP BY T2.region\nORDER BY COUNT(T1.city) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "496": {
        "db_id": "movies_4",
        "question": "Provide the genre of a movie title with a tagline of \"A long time ago in a galaxy far, far away\u2026\".",
        "ground_truth": "SELECT T3.genre_name FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T3.genre_id = T2.genre_id WHERE T1.tagline = 'A long time ago in a galaxy far, far away...'",
        "amends": [
            "Do select `T3.genre_name` instead of `title` from the result set. Do add `INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id` and `INNER JOIN genre AS T3 ON T3.genre_id = T2.genre_id` instead of querying only the `movies` table. Do change the table reference to `movie AS T1` instead of `movies` in the FROM clause. Do use `T1.tagline` instead of just `tagline` in the WHERE filter to properly qualify the column reference. The amended query now correctly joins through the genre relationship to return genre names instead of movie titles for films with the specified tagline.",
            "Do use the correct ellipsis character `...` in the tagline filter instead of the longer Unicode ellipsis `\u2026` to ensure proper string matching. The amended query now matches RIGHT_SQL's behavior with the corrected punctuation in the WHERE clause predicate."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE tagline = 'A long time ago in a galaxy far, far away\u2026';",
            "SELECT T3.genre_name \nFROM movie AS T1 \nINNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id \nINNER JOIN genre AS T3 ON T3.genre_id = T2.genre_id \nWHERE T1.tagline = 'A long time ago in a galaxy far, far away\u2026'",
            "SELECT T3.genre_name \nFROM movie AS T1\nINNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id\nINNER JOIN genre AS T3 ON T3.genre_id = T2.genre_id\nWHERE T1.tagline = 'A long time ago in a galaxy far, far away...'"
        ],
        "rule_sql": []
    },
    "7185": {
        "db_id": "works_cycles",
        "question": "State the full name of accountants in the company.",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle = 'Accountant'",
        "amends": [
            "Do select `T2.FirstName`, `T2.MiddleName`, and `T2.LastName` instead of just `first_name`. Do join `Employee AS T1` with `Person AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single `accountants` table. Do filter on `T1.JobTitle = 'Accountant'` instead of `company = 'the company'`. The amended query now correctly retrieves person details by joining employee and person tables based on job title rather than relying on a potentially incorrect company filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM accountants WHERE company = 'the company';",
            "SELECT T2.FirstName, T2.MiddleName, T2.LastName \nFROM Employee AS T1 \nJOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID \nWHERE T1.JobTitle = 'Accountant'"
        ],
        "rule_sql": []
    },
    "5785": {
        "db_id": "language_corpus",
        "question": "Please list all the biwords pairs with \"\u00e0bac\" as its first word.",
        "ground_truth": "SELECT T1.word AS W1, T3.word AS W2 FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd WHERE T1.word = '\u00e0bac'",
        "amends": [
            "Do select specific columns `T1.word AS W1` and `T3.word AS W2` instead of using `SELECT *`. Do add table `words AS T1` with an `INNER JOIN` on `T1.wid = T2.w1st` instead of querying only `biwords`. Do add table `words AS T3` with an `INNER JOIN` on `T3.wid = T2.w2nd` instead of omitting the second words table. Do filter on `T1.word = '\u00e0bac'` instead of filtering directly on `biwords.first_word`. The amended query now correctly joins through the relationship tables to retrieve the actual word pairs instead of just the biwords table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM biwords WHERE first_word = '\u00e0bac';",
            "SELECT T1.word AS W1, T3.word AS W2\nFROM biwords AS T2\nINNER JOIN words AS T1 ON T1.wid = T2.w1st\nINNER JOIN words AS T3 ON T3.wid = T2.w2nd\nWHERE T1.word = '\u00e0bac'"
        ],
        "rule_sql": []
    },
    "1585": {
        "db_id": "car_retails",
        "question": "List the product code of the top five motorcycles, by descending order, the number of quantity in stock.",
        "ground_truth": "SELECT productCode, quantityInStock FROM products WHERE productLine = 'Motorcycles' ORDER BY quantityInStock DESC LIMIT 5",
        "amends": [
            "Do include `quantityInStock` in the SELECT list instead of omitting it. Do change the ORDER BY direction to `DESC` instead of `ASC`. The amended query now correctly returns both product codes and their stock quantities for Motorcycles products, ordered from highest to lowest stock with a limit of 5 results, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT productCode FROM products WHERE productLine = 'Motorcycles' ORDER BY quantityInStock ASC LIMIT 5;",
            "SELECT productCode, quantityInStock \nFROM products \nWHERE productLine = 'Motorcycles' \nORDER BY quantityInStock DESC \nLIMIT 5"
        ],
        "rule_sql": []
    },
    "1189": {
        "db_id": "talkingdata",
        "question": "Among the users who use OPPO, calculate the percentage of those who are under 50 years old.",
        "ground_truth": "SELECT SUM(IIF(T1.age < 50, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO'",
        "amends": [
            "Do use `SUM(IIF(T1.age < 50, 1, 0)) / COUNT(T1.device_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE brand = 'OPPO')` for calculating the percentage. Do join `gender_age AS T1` with `phone_brand_device_model2 AS T2` on `T1.device_id = T2.device_id` instead of querying a single `users` table. Do filter on `T2.phone_brand = 'OPPO'` instead of `brand = 'OPPO'`. Do reference `T1.age` instead of just `age` for the age condition. Do remove the subquery approach and instead perform the calculation directly in the main query using proper table joins and conditional aggregation. The amended query now correctly calculates the percentage of OPPO users under age 50 using the appropriate table structure and join conditions.",
            "Do remove the multiplication by `100.0` from the percentage calculation instead of including it, and change the alias from `percentage_under_50` to `per` instead of keeping the longer name. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` without the INNER keyword. The amended query now correctly calculates the proportion rather than percentage and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE brand = 'OPPO') AS percentage FROM users WHERE brand = 'OPPO' AND age < 50;",
            "SELECT \n    (SUM(IIF(T1.age < 50, 1, 0)) * 100.0 / COUNT(T1.device_id)) AS percentage_under_50\nFROM \n    gender_age AS T1\nJOIN \n    phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE \n    T2.phone_brand = 'OPPO';",
            "SELECT \n    SUM(IIF(T1.age < 50, 1, 0)) / COUNT(T1.device_id) AS per\nFROM \n    gender_age AS T1\nINNER JOIN \n    phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE \n    T2.phone_brand = 'OPPO'"
        ],
        "rule_sql": []
    },
    "4673": {
        "db_id": "disney",
        "question": "Who directed the movie with the most voice actors?",
        "ground_truth": "SELECT T2.director, COUNT(DISTINCT T1.`voice-actor`) FROM `voice-actors` AS T1 INNER JOIN director AS T2 ON T1.movie = T2.name GROUP BY T2.director ORDER BY COUNT(DISTINCT T1.`voice-actor`) DESC LIMIT 1",
        "amends": [
            "Do add `COUNT(DISTINCT T1.`voice-actor`)` and `T2.director` in the SELECT list instead of just `director`. Do change the FROM clause to use `INNER JOIN` between `voice-actors` AS T1 and `director` AS T2 on `T1.movie = T2.name` instead of a single table. Do add `GROUP BY T2.director` instead of omitting grouping. Do change the ORDER BY to use `COUNT(DISTINCT T1.`voice-actor`) DESC` instead of `voice_actors DESC`. The amended query now correctly counts distinct voice actors per director and returns the director with the most voice actors, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director FROM movies ORDER BY voice_actors DESC LIMIT 1;",
            "SELECT T2.director, COUNT(DISTINCT T1.\"voice-actor\") \nFROM \"voice-actors\" AS T1 \nINNER JOIN director AS T2 ON T1.movie = T2.name \nGROUP BY T2.director \nORDER BY COUNT(DISTINCT T1.\"voice-actor\") DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1990": {
        "db_id": "soccer_2016",
        "question": "How many venues are located at Centurion, South Africa?",
        "ground_truth": "SELECT COUNT(T1.Venue_name) FROM Venue AS T1 INNER JOIN City AS T2 ON T1.City_Id = T2.City_Id INNER JOIN Country AS T3 ON T2.Country_Id = T3.Country_Id WHERE T3.country_name = 'South Africa' AND T2.city_name = 'Centurion'",
        "amends": [
            "Do reference the `Venue` table as `T1` instead of `venues`, and add joins to `City` as `T2` and `Country` as `T3` instead of querying a single table. Do join on `T1.City_Id = T2.City_Id` and `T2.Country_Id = T3.Country_Id` instead of filtering directly on city and country names. Do count `T1.Venue_name` instead of `COUNT(*)` to avoid counting null values. Do filter on `T3.country_name = 'South Africa'` and `T2.city_name = 'Centurion'` through the joined tables instead of directly on non-existent `city` and `country` columns. The amended query now correctly counts venues by joining through proper relational tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM venues WHERE city = 'Centurion' AND country = 'South Africa';",
            "SELECT COUNT(T1.Venue_Name) \nFROM Venue T1\nJOIN City T2 ON T1.City_Id = T2.City_Id\nJOIN Country T3 ON T2.Country_id = T3.Country_Id\nWHERE T2.City_Name = 'Centurion' AND T3.Country_Name = 'South Africa'"
        ],
        "rule_sql": []
    },
    "7206": {
        "db_id": "works_cycles",
        "question": "How much is the total bonus received by sales person and what is the percentage of it against the projected yearly sales quota in 2013?",
        "ground_truth": "SELECT SUM(T1.Bonus) , CAST(SUM(T1.Bonus) AS REAL) * 100 / SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013'",
        "amends": [
            "Do use `SUM(T1.Bonus)` and `SUM(T1.SalesQuota)` instead of individual row-level `sp.Bonus` and `sp.SalesQuota` calculations. Do add `INNER JOIN` on `SalesPersonQuotaHistory AS T2` with predicate `T1.BusinessEntityID = T2.BusinessEntityID` instead of omitting this table entirely. Do change the date filter to use `STRFTIME('%Y', T2.QuotaDate) = '2013'` on the joined table instead of `YEAR(sp.BonusDate) = 2013` on the main table. Do remove the individual columns `sp.SalesPersonID`, `sp.FirstName`, `sp.LastName` from the SELECT list and GROUP BY clause instead of including them. Do change the percentage calculation to `CAST(SUM(T1.Bonus) AS REAL) * 100 / SUM(T1.SalesQuota)` instead of `(SUM(sp.Bonus) / sp.SalesQuota) * 100` to properly aggregate before division. The amended query now correctly calculates bonus percentages based on aggregated sales quota data from the appropriate history table.",
            "Do use table aliases `T1` and `T2` consistently throughout the query instead of mixing full table names and aliases. Do remove the column alias `TotalBonus` from the `SUM(sp.Bonus)` expression instead of keeping it. Do reference `T1.SalesQuota` in the calculation instead of `spq.SalesQuota` to correctly access the SalesQuota field from the SalesPerson table. The amended query now correctly calculates the bonus percentage using SalesQuota from the appropriate table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    sp.SalesPersonID,\n    sp.FirstName,\n    sp.LastName,\n    SUM(sp.Bonus) AS TotalBonus,\n    (SUM(sp.Bonus) / sp.SalesQuota) * 100 AS BonusPercentage\nFROM \n    SalesPerson sp\nWHERE \n    YEAR(sp.BonusDate) = 2013\nGROUP BY \n    sp.SalesPersonID, sp.FirstName, sp.LastName, sp.SalesQuota;",
            "SELECT \n    SUM(sp.Bonus) AS TotalBonus,\n    CAST(SUM(sp.Bonus) AS REAL) * 100 / SUM(spq.SalesQuota) AS BonusPercentage\nFROM \n    SalesPerson sp\nINNER JOIN \n    SalesPersonQuotaHistory spq ON sp.BusinessEntityID = spq.BusinessEntityID\nWHERE \n    STRFTIME('%Y', spq.QuotaDate) = '2013'",
            "SELECT \n    SUM(T1.Bonus) AS TotalBonus,\n    CAST(SUM(T1.Bonus) AS REAL) * 100 / SUM(T1.SalesQuota) AS BonusPercentage\nFROM \n    SalesPerson AS T1\nINNER JOIN \n    SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE \n    STRFTIME('%Y', T2.QuotaDate) = '2013'"
        ],
        "rule_sql": []
    },
    "1450": {
        "db_id": "synthea",
        "question": "How many patients with a body weight of more than 100 kg have a 'diabetes self-management plan' care plan?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.patient) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN observations AS T3 ON T2.patient = T3.PATIENT WHERE T3.DESCRIPTION = 'Body Weight' AND T1.DESCRIPTION = 'Diabetes self management plan' AND T3.VALUE > 100 AND T3.UNITS = 'kg'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.patient)` instead of `COUNT(*)` to count unique patients rather than all care plan entries. Do add `observations AS T3` with an `INNER JOIN` on `T2.patient = T3.PATIENT` instead of omitting this table entirely. Do change the join from `JOIN care_plans` to `INNER JOIN careplans AS T1` with the predicate `T1.PATIENT = T2.patient` instead of `p.patient_id = cp.patient_id`. Do move the weight filter to `T3.VALUE > 100` with the additional condition `T3.UNITS = 'kg'` instead of `p.body_weight > 100` without unit validation. Do change the care plan filter to `T1.DESCRIPTION = 'Diabetes self management plan'` instead of `cp.plan_name = 'diabetes self-management plan'`. Do add the condition `T3.DESCRIPTION = 'Body Weight'` instead of omitting this observation type filter. The amended query now correctly counts distinct patients with diabetes care plans who have body weight observations exceeding 100 kg, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients p JOIN care_plans cp ON p.patient_id = cp.patient_id WHERE p.body_weight > 100 AND cp.plan_name = 'diabetes self-management plan';",
            "SELECT COUNT(DISTINCT T2.patient) \nFROM patients AS T2\nINNER JOIN careplans AS T1 ON T1.PATIENT = T2.patient\nINNER JOIN observations AS T3 ON T2.patient = T3.PATIENT\nWHERE T1.DESCRIPTION = 'Diabetes self management plan'\nAND T3.DESCRIPTION = 'Body Weight'\nAND T3.VALUE > 100\nAND T3.UNITS = 'kg'"
        ],
        "rule_sql": []
    },
    "8160": {
        "db_id": "sales_in_weather",
        "question": "Tell the resultant wind speed of station no.9 on 2014/1/15.",
        "ground_truth": "SELECT resultspeed FROM weather WHERE `date` = '2014-01-15' AND station_nbr = 9",
        "amends": [
            "Do select `resultspeed` instead of `temperature` in the SELECT list. Do filter on `station_nbr = 9` instead of `station_id = 9` in the WHERE clause. Do maintain the filter `date = '2014-01-15'` in the WHERE clause but note the column reference uses backticks in the right query. The amended query now correctly retrieves the resultspeed for station number 9 on January 15, 2014, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT temperature FROM weather WHERE station_id = 9 AND date = '2014-01-15';",
            "SELECT resultspeed FROM weather WHERE station_nbr = 9 AND date = '2014-01-15'"
        ],
        "rule_sql": []
    },
    "1417": {
        "db_id": "synthea",
        "question": "Provide at least 5 social security numbers of patients with a prevalent disease with a prevalence percentage lower than 30% of the average prevalence percentage of conditions.",
        "ground_truth": "SELECT DISTINCT T2.ssn FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN all_prevalences AS T3 ON lower(T1.DESCRIPTION) = lower(T3.ITEM) WHERE CAST(T3.\"PREVALENCE PERCENTAGE\" AS REAL) * 100 / ( SELECT AVG('PREVALENCE PERCENTAGE') FROM all_prevalences ) < 30 LIMIT 5",
        "amends": [
            "Do use `DISTINCT T2.ssn` instead of `ssn` to eliminate duplicates. Do join `conditions AS T1` and `patients AS T2` with `INNER JOIN` on `T1.PATIENT = T2.patient` instead of querying `patients` alone. Do add another `INNER JOIN` to `all_prevalences AS T3` on `lower(T1.DESCRIPTION) = lower(T3.ITEM)` instead of missing this table. Do change the filter to compare `CAST(T3.\"PREVALENCE PERCENTAGE\" AS REAL) * 100 / (SELECT AVG('PREVALENCE PERCENTAGE') FROM all_prevalences) < 30` instead of `disease_prevalence < (SELECT AVG(prevalence_percentage) * 0.3 FROM conditions)`. Do add `LIMIT 5` instead of omitting row limiting. The amended query now correctly joins multiple tables, calculates relative prevalence percentages, and matches the RIGHT_SQL's behavior.",
            "Do use single quotes around `'PREVALENCE PERCENTAGE'` in the subquery instead of double quotes, as the RIGHT_SQL correctly handles the column name as a string literal rather than an identifier in the AVG function subquery, which fixes the syntax error while maintaining the same mathematical calculation logic for filtering records where the prevalence percentage is less than 30% of the average."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ssn FROM patients WHERE disease_prevalence < (SELECT AVG(prevalence_percentage) * 0.3 FROM conditions);",
            "SELECT DISTINCT T2.ssn\nFROM conditions AS T1\nINNER JOIN patients AS T2 ON T1.PATIENT = T2.patient\nINNER JOIN all_prevalences AS T3 ON lower(T1.DESCRIPTION) = lower(T3.ITEM)\nWHERE CAST(T3.\"PREVALENCE PERCENTAGE\" AS REAL) * 100 / (SELECT AVG(\"PREVALENCE PERCENTAGE\") FROM all_prevalences) < 30\nLIMIT 5",
            "SELECT DISTINCT T2.ssn\nFROM conditions AS T1\nINNER JOIN patients AS T2 ON T1.PATIENT = T2.patient\nINNER JOIN all_prevalences AS T3 ON lower(T1.DESCRIPTION) = lower(T3.ITEM)\nWHERE CAST(T3.\"PREVALENCE PERCENTAGE\" AS REAL) * 100 / (SELECT AVG('PREVALENCE PERCENTAGE') FROM all_prevalences) < 30\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "6856": {
        "db_id": "retails",
        "question": "Calculate percentage of household segment in Indonesia.",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.c_mktsegment = 'HOUSEHOLD', 1, 0)) AS REAL) * 100 / COUNT(T1.c_mktsegment) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'INDONESIA'",
        "amends": [
            "Do use `SUM(IIF(T1.c_mktsegment = 'HOUSEHOLD', 1, 0))` instead of `COUNT(*)` to count specific segment matches. Do join `customer AS T1` and `nation AS T2` with `INNER JOIN` on `T1.c_nationkey = T2.n_nationkey` instead of querying `households` table directly. Do filter on `T2.n_name = 'INDONESIA'` instead of `country = 'Indonesia'` to use the correct nation name column. Do calculate percentage as `CAST(... AS REAL) * 100 / COUNT(T1.c_mktsegment)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM households)` to properly compute the ratio within the filtered dataset. Do remove the subquery and instead perform the calculation directly on the joined result set. The amended query now correctly calculates the percentage of household segment customers in Indonesia."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM households)) AS percentage\nFROM households \nWHERE country = 'Indonesia';",
            "SELECT \n    CAST(SUM(IIF(T1.c_mktsegment = 'HOUSEHOLD', 1, 0)) AS REAL) * 100 / COUNT(T1.c_mktsegment) AS percentage\nFROM \n    customer AS T1\nINNER JOIN \n    nation AS T2 ON T1.c_nationkey = T2.n_nationkey\nWHERE \n    T2.n_name = 'INDONESIA'"
        ],
        "rule_sql": []
    },
    "784": {
        "db_id": "social_media",
        "question": "Among all the tweets that are reshared, how many of them are posted by a user in Buenos Aires?",
        "ground_truth": "SELECT COUNT(T1.TweetID) FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T2.City = 'Buenos Aires' AND T1.IsReshare = 'TRUE'",
        "amends": [
            "Do reference `T1.TweetID` in the COUNT instead of `*` to count specific non-null values. Do use table aliases `T1` and `T2` instead of `t` and `u` for clarity. Do join `twitter` AS `T1` with `location` AS `T2` on `T2.LocationID = T1.LocationID` instead of joining `tweets` with `users` on `t.user_id = u.user_id` to properly relate location data. Do filter on `T2.City = 'Buenos Aires'` instead of `u.location = 'Buenos Aires'` to use standardized location data. Do filter on `T1.IsReshare = 'TRUE'` instead of `t.retweet_count > 0` to use a boolean flag for reshare identification rather than counting retweets. The amended query now correctly counts reshared tweets from Buenos Aires using proper table relationships and standardized data fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets t JOIN users u ON t.user_id = u.user_id WHERE t.retweet_count > 0 AND u.location = 'Buenos Aires'",
            "SELECT COUNT(T1.TweetID) \nFROM twitter AS T1\nJOIN location AS T2 ON T2.LocationID = T1.LocationID\nWHERE T1.IsReshare = 'TRUE' AND T2.City = 'Buenos Aires'"
        ],
        "rule_sql": []
    },
    "8927": {
        "db_id": "cookbook",
        "question": "Identify recipes with different maximum and minimum quantities.",
        "ground_truth": "SELECT T1.title FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE T2.max_qty <> T2.min_qty",
        "amends": [
            "Do select `T1.title` from `Recipe AS T1` instead of `recipe_id, MAX(quantity), MIN(quantity)` from `recipe_ingredients`. Do use `INNER JOIN Quantity AS T2` instead of no join. Do join on `T1.recipe_id = T2.recipe_id` instead of no join condition. Do filter with `T2.max_qty <> T2.min_qty` in the WHERE clause instead of `max_quantity != min_quantity` in a non-existent HAVING clause. Do remove the GROUP BY clause instead of keeping it. The amended query now correctly retrieves recipe titles where maximum and minimum quantities differ by joining the Recipe and Quantity tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT recipe_id, MAX(quantity) as max_quantity, MIN(quantity) as min_quantity FROM recipe_ingredients GROUP BY recipe_id WHERE max_quantity != min_quantity;",
            "SELECT T1.title FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE T2.max_qty <> T2.min_qty"
        ],
        "rule_sql": []
    },
    "1264": {
        "db_id": "law_episode",
        "question": "How many awards has Rene Balcer been nominated for?",
        "ground_truth": "SELECT COUNT(T2.award_id) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T1.name = 'Rene Balcer'",
        "amends": [
            "Do select `COUNT(T2.award_id)` instead of `COUNT(*)` to count specific awards rather than all rows. Do use `Person AS T1 INNER JOIN Award AS T2` instead of querying only the `awards` table to properly relate persons to their awards. Do join on `T1.person_id = T2.person_id` instead of missing the join condition entirely. Do filter on `T1.name = 'Rene Balcer'` instead of `winner = 'Rene Balcer'` to correctly identify the person by name rather than assuming the winner field contains names. The amended query now properly counts awards for the specific person by joining the relevant tables with correct relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE winner = 'Rene Balcer';",
            "SELECT COUNT(T2.award_id) \nFROM Person AS T1 \nINNER JOIN Award AS T2 ON T1.person_id = T2.person_id \nWHERE T1.name = 'Rene Balcer'"
        ],
        "rule_sql": []
    },
    "4738": {
        "db_id": "legislator",
        "question": "How many current legislators were born after the year 1960?",
        "ground_truth": "SELECT COUNT(bioguide_id) FROM current WHERE birthday_bio >= '1961-01-01'",
        "amends": [
            "Do count `bioguide_id` instead of using `COUNT(*)` to count only non-null values. Do query from `current` table instead of `legislators` to target the correct data source. Do filter on `birthday_bio >= '1961-01-01'` instead of `birth_year > 1960` to use proper date comparison with inclusive logic for January 1st births. The amended query now correctly counts legislators born in 1961 or later using the appropriate date field and table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE birth_year > 1960;",
            "SELECT COUNT(bioguide_id) FROM current WHERE birthday_bio >= '1961-01-01'"
        ],
        "rule_sql": []
    },
    "7805": {
        "db_id": "hockey",
        "question": "List down player ID of players who have passed away.",
        "ground_truth": "SELECT DISTINCT playerID FROM Master WHERE deathYear IS NOT NULL AND playerID IS NOT NULL",
        "amends": [
            "Do select `playerID` instead of `player_id` and use `DISTINCT` instead of omitting it. Do query from `Master` table instead of `players` table. Do filter with `deathYear IS NOT NULL` instead of `status = 'alive'` and add `playerID IS NOT NULL` condition instead of omitting it. The amended query now correctly identifies living players by checking for null death years rather than using a status flag, while ensuring playerID values are not null."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id FROM players WHERE status = 'alive';",
            "SELECT DISTINCT playerID FROM Master WHERE deathYear IS NOT NULL AND playerID IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1042": {
        "db_id": "talkingdata",
        "question": "How many female users over the age of 50 are there?",
        "ground_truth": "SELECT COUNT(gender) FROM gender_age WHERE age > 50 AND gender = 'F'",
        "amends": [
            "Do reference table `gender_age` instead of `users` and count `gender` instead of `*`. Do filter for `age > 50` instead of `age < 50` and use gender value `'F'` instead of `'male'`. The amended query now correctly counts female users over 50 years old from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE gender = 'male' AND age < 50;",
            "SELECT COUNT(gender) FROM gender_age WHERE gender = 'F' AND age > 50"
        ],
        "rule_sql": []
    },
    "5433": {
        "db_id": "sales",
        "question": "List the quantity and price of the product bought by Abigail Henderson.",
        "ground_truth": "SELECT T2.Quantity, T1.Price FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE T3.FirstName = 'Abigail' AND T3.LastName = 'Henderson'",
        "amends": [
            "Do add `T1` and `T2` aliases for table references instead of omitting them. Do change the FROM clause to include `Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID` instead of just `products`. Do change the WHERE filter to `T3.FirstName = 'Abigail' AND T3.LastName = 'Henderson'` instead of `customer_name = 'Abigail Henderson'`. Do add proper join conditions `T1.ProductID = T2.ProductID` and `T2.CustomerID = T3.CustomerID` instead of missing table relationships entirely. The amended query now correctly joins multiple tables and uses proper column references to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT quantity, price FROM products WHERE customer_name = 'Abigail Henderson'",
            "SELECT T2.Quantity, T1.Price \nFROM Products AS T1 \nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID \nINNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID \nWHERE T3.FirstName = 'Abigail' AND T3.LastName = 'Henderson'"
        ],
        "rule_sql": []
    },
    "610": {
        "db_id": "codebase_comments",
        "question": "For the method which got the tokenized name as 'interp parser expr', what is the processed time for its solution?",
        "ground_truth": "SELECT T1.ProcessedTime FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.NameTokenized = 'interp parser expr'",
        "amends": [
            "Do select `T1.ProcessedTime` instead of `processed_time`. Do use `FROM Solution AS T1 INNER JOIN Method AS T2` instead of `FROM methods` alone. Do add join condition `ON T1.Id = T2.SolutionId` instead of omitting any join. Do filter with `T2.NameTokenized = 'interp parser expr'` instead of `tokenized_name = 'interp parser expr'`. The amended query now correctly joins the Solution and Method tables to retrieve the processed time from the appropriate table based on the relationship between solution and method entities."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT processed_time FROM methods WHERE tokenized_name = 'interp parser expr';",
            "SELECT T1.ProcessedTime FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.NameTokenized = 'interp parser expr'"
        ],
        "rule_sql": []
    },
    "2321": {
        "db_id": "movielens",
        "question": "List the user ids and ages who gave the rate 2 to the movie No. 2409051.",
        "ground_truth": "SELECT T1.userid, T1.age FROM users AS T1 INNER JOIN u2base AS T2 ON T1.userid = T2.userid WHERE T2.movieid = '2409051' AND T2.rating = 2",
        "amends": [
            "Do add `INNER JOIN u2base AS T2 ON T1.userid = T2.userid` instead of querying only the `users` table. Do change the source table alias to `users AS T1` instead of using the table name directly. Do reference `T1.userid` and `T1.age` instead of `user_id` and `age`. Do move the rating filter to `T2.rating = 2` instead of `rate = 2` and reference the correct column from the joined table. Do change the movie ID filter to `T2.movieid = '2409051'` instead of `movie_id = 'No. 2409051'`, removing the prefix and using the correct column from the joined table. The amended query now correctly joins the tables to access rating and movie information that was missing from the original single-table approach, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, age FROM users WHERE rate = 2 AND movie_id = 'No. 2409051';",
            "SELECT T1.userid, T1.age\nFROM users AS T1\nINNER JOIN u2base AS T2 ON T1.userid = T2.userid\nWHERE T2.rating = '2' AND T2.movieid = 2409051"
        ],
        "rule_sql": []
    },
    "21": {
        "db_id": "movie_platform",
        "question": "When was the first movie released and who directed it?",
        "ground_truth": "SELECT movie_release_year, director_name FROM movies WHERE movie_release_year IS NOT NULL ORDER BY movie_release_year ASC LIMIT 1",
        "amends": [
            "Do select `movie_release_year` and `director_name` instead of `title` and `director`. Do add `WHERE movie_release_year IS NOT NULL` instead of omitting the filter. Do order by `movie_release_year ASC` instead of `release_date ASC`. The amended query now correctly filters out null release years and uses the appropriate column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, director FROM movies ORDER BY release_date ASC LIMIT 1;",
            "SELECT movie_release_year, director_name FROM movies WHERE movie_release_year IS NOT NULL ORDER BY movie_release_year ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5389": {
        "db_id": "sales",
        "question": "Calculate the total quantity of products with name starting with alphabet \"c\".",
        "ground_truth": "SELECT SUM(T2.Quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE SUBSTR(T1.Name, 1, 1) = 'C'",
        "amends": [
            "Do join `Products AS T1` with `Sales AS T2` on `T1.ProductID = T2.ProductID` instead of querying only the `products` table. Do use `SUM(T2.Quantity)` from the joined `Sales` table instead of `SUM(quantity)` from the base table. Do filter with `SUBSTR(T1.Name, 1, 1) = 'C'` for case-sensitive matching instead of `name LIKE 'c%'` for case-insensitive pattern matching. The amended query now correctly aggregates sales quantities for products starting with 'C' by joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM products WHERE name LIKE 'c%';",
            "SELECT SUM(T2.Quantity) AS TotalQuantity\nFROM Products AS T1\nJOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nWHERE SUBSTR(T1.Name, 1, 1) = 'C'"
        ],
        "rule_sql": []
    },
    "1383": {
        "db_id": "synthea",
        "question": "What kind of condition did Keven Kuhn have from 2016/9/24 to 2016/10/10? Describe the condition.",
        "ground_truth": "SELECT T2.description FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Keven' AND T1.last = 'Kuhn' AND T2.start = '2016-09-24' AND T2.stop = '2016-10-10'",
        "amends": [
            "Do join `patients AS T1` and `conditions AS T2` instead of querying only `patient_conditions`. Do use `T2.description` instead of `condition_description`. Do filter on `T1.first = 'Keven'` and `T1.last = 'Kuhn'` instead of `patient_name = 'Keven Kuhn'`. Do filter on `T2.start = '2016-09-24'` and `T2.stop = '2016-10-10'` instead of `condition_date BETWEEN '2016/9/24' AND '2016/10/10'`. The amended query now correctly joins patient and condition tables with proper date format and name filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT condition_description FROM patient_conditions WHERE patient_name = 'Keven Kuhn' AND condition_date BETWEEN '2016/9/24' AND '2016/10/10';",
            "SELECT T2.DESCRIPTION \nFROM patients AS T1 \nJOIN conditions AS T2 ON T1.patient = T2.PATIENT \nWHERE T1.first = 'Keven' \nAND T1.last = 'Kuhn' \nAND T2.START = '2016-09-24' \nAND T2.STOP = '2016-10-10'"
        ],
        "rule_sql": []
    },
    "3984": {
        "db_id": "public_review_platform",
        "question": "Compare the number of business between the category of \"Men's Clothing\" and \"Women's Clothing\".",
        "ground_truth": "SELECT SUM(CASE WHEN T1.category_name = 'Men''s Clothing' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.category_name = 'Women''s Clothing' THEN 1 ELSE 0 END) AS diff FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id",
        "amends": [
            "Do use `SUM(CASE...ELSE 0 END)` instead of `COUNT(CASE...END)` to properly calculate differences between categories. Do reference `category_name` instead of `category` as the column containing category values. Do join `Categories AS T1` with `Business_Categories AS T2` on `T1.category_id = T2.category_id` instead of querying a single `businesses` table. Do calculate the difference between men's and women's clothing counts as `diff` instead of separate counts for each category. Do remove the `WHERE` filter entirely instead of filtering by category, as the join and case expressions handle the category logic. The amended query now correctly calculates the difference between men's and women's clothing categories through proper table relationships and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN category = 'Men\\'s Clothing' THEN 1 END) AS men_clothing_count,\n    COUNT(CASE WHEN category = 'Women\\'s Clothing' THEN 1 END) AS women_clothing_count\nFROM businesses\nWHERE category IN ('Men\\'s Clothing', 'Women\\'s Clothing');",
            "SELECT \n    SUM(CASE WHEN T1.category_name = 'Men''s Clothing' THEN 1 ELSE 0 END) -\n    SUM(CASE WHEN T1.category_name = 'Women''s Clothing' THEN 1 ELSE 0 END) AS diff\nFROM \n    Categories AS T1\nJOIN \n    Business_Categories AS T2 ON T1.category_id = T2.category_id;"
        ],
        "rule_sql": []
    },
    "3601": {
        "db_id": "authors",
        "question": "List the title and author's name of papers published in the 2007 Neoplasia journal.",
        "ground_truth": "SELECT T1.Title, T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE T3.FullName = 'Neoplasia' AND T1.Year = 2007",
        "amends": [
            "Do use explicit table aliases `T1.Title` and `T2.Name` instead of direct column references `title` and `author_name`. Do add `INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` instead of omitting the join to the PaperAuthor table. Do add `INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id` instead of directly filtering on journal name. Do filter on `T3.FullName = 'Neoplasia'` instead of `journal = 'Neoplasia'` to use the proper journal table relationship. Do keep `T1.Year = 2007` instead of `year = 2007` with proper table qualification. The amended query now correctly joins through the normalized schema to retrieve paper titles and author names from the Neoplasia journal in 2007."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, author_name FROM papers WHERE journal = 'Neoplasia' AND year = 2007;",
            "SELECT T1.Title, T2.Name \nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nINNER JOIN Journal AS T3 ON T1.JournalId = T3.Id\nWHERE T3.FullName = 'Neoplasia' AND T1.Year = 2007"
        ],
        "rule_sql": []
    },
    "4139": {
        "db_id": "citeseer",
        "question": "Among all the citation, what is the percentage of paper ID under the Agents classification?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN class_label = 'Agents' THEN paper_id ELSE NULL END) AS REAL) * 100 / COUNT(paper_id) FROM paper",
        "amends": [
            "Do use `COUNT(CASE WHEN class_label = 'Agents' THEN paper_id ELSE NULL END)` instead of `COUNT(*)` with a `WHERE` filter to properly count only specific rows while maintaining the same denominator. Do reference `class_label` instead of `classification` to match the correct column name. Do use `paper_id` for counting instead of the generic `*` to ensure accurate row counting. Do add explicit `CAST` to `REAL` instead of using decimal notation to ensure proper floating-point division. Do calculate the percentage using division by `COUNT(paper_id)` instead of a subquery to simplify the query structure. Do remove the `FROM papers` clause and subquery instead of keeping them since the calculation is now done in a single table scan. The amended query now correctly calculates the percentage of papers with 'Agents' classification using proper null handling and casting.",
            "Do remove the JOIN clause with the `cites` table instead of including an unnecessary join that doesn't affect the calculation. Do calculate the percentage directly from the `paper` table instead of joining with citation relationships. Do use simpler division syntax with `* 100 / COUNT()` instead of wrapping the entire expression in parentheses and multiplying by `100.0`. Do remove the column alias `percentage` instead of keeping it since the right query doesn't include an explicit alias. The amended query now correctly calculates the percentage of 'Agents' papers directly from the paper table without unnecessary joins, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM citations) AS percentage FROM papers WHERE classification = 'Agents';",
            "SELECT \n    (CAST(COUNT(CASE WHEN p.class_label = 'Agents' THEN p.paper_id ELSE NULL END) AS REAL) / COUNT(p.paper_id)) * 100.0 \n    AS percentage\nFROM paper p\nJOIN cites c ON p.paper_id = c.citing_paper_id OR p.paper_id = c.cited_paper_id;",
            "SELECT CAST(COUNT(CASE WHEN class_label = 'Agents' THEN paper_id ELSE NULL END) AS REAL) * 100 / COUNT(paper_id) FROM paper"
        ],
        "rule_sql": []
    },
    "799": {
        "db_id": "social_media",
        "question": "Give the location id of West Sussex State.",
        "ground_truth": "SELECT DISTINCT LocationID FROM location WHERE State = 'West Sussex'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate results. Do reference `LocationID` instead of `location_id` to match the correct column name. Do query from `location` instead of `locations` to reference the correct table name. Do filter on `State` instead of `state` to use the proper column identifier. The amended query now correctly returns unique location identifiers from the appropriate table with the specified state filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_id FROM locations WHERE state = 'West Sussex';",
            "SELECT DISTINCT LocationID FROM location WHERE State = 'West Sussex';"
        ],
        "rule_sql": []
    },
    "1131": {
        "db_id": "talkingdata",
        "question": "How many users from the group \"F29-32\" who were active in the events on 2016/5/7?",
        "ground_truth": "SELECT COUNT(T1.app_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.event_id = T3.device_id WHERE SUBSTR(T2.`timestamp`, 1, 10) = '2016-05-07' AND T1.is_active = '1' AND T3.`group` = 'F29-32'",
        "amends": [
            "Do select `COUNT(T1.app_id)` from specific column instead of `COUNT(*)` from all columns. Do change FROM clause to use `app_events AS T1` instead of `users` table. Do add `INNER JOIN events AS T2 ON T1.event_id = T2.event_id` instead of no join. Do add `INNER JOIN gender_age AS T3 ON T2.event_id = T3.device_id` instead of no second join. Do change WHERE filter to use `SUBSTR(T2.timestamp, 1, 10) = '2016-05-07'` with proper date format instead of `date = '2016/5/7'`. Do add `T1.is_active = '1'` filter instead of omitting it. Do change group filter to `T3.group = 'F29-32'` with proper table reference instead of `group = 'F29-32'`. The amended query now correctly joins multiple tables, uses proper date handling with substring extraction, and applies appropriate filtering conditions to match the intended behavior.",
            "Do join `gender_age` on `T2.event_id = T3.device_id` instead of `T2.device_id = T3.device_id` to correctly link events to demographic data. Do use string comparison `T1.is_active = '1'` instead of numeric comparison `T1.is_active = 1` to match the data type. Do add backticks around reserved keywords `timestamp` and `group` instead of omitting them to ensure proper parsing. The amended query now correctly counts active app events from May 7, 2016, for the F29-32 demographic group by fixing the join condition and data type handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE group = 'F29-32' AND date = '2016/5/7';",
            "SELECT COUNT(T1.app_id) \nFROM app_events AS T1\nINNER JOIN events AS T2 ON T1.event_id = T2.event_id\nINNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id\nWHERE SUBSTR(T2.timestamp, 1, 10) = '2016-05-07'\nAND T1.is_active = 1\nAND T3.group = 'F29-32'",
            "SELECT COUNT(T1.app_id) \nFROM app_events AS T1\nINNER JOIN events AS T2 ON T1.event_id = T2.event_id\nINNER JOIN gender_age AS T3 ON T2.event_id = T3.device_id\nWHERE SUBSTR(T2.`timestamp`, 1, 10) = '2016-05-07'\nAND T1.is_active = '1'\nAND T3.`group` = 'F29-32'"
        ],
        "rule_sql": []
    },
    "3120": {
        "db_id": "cars",
        "question": "Which country produced the car with the lowest mileage per gallon?",
        "ground_truth": "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country ORDER BY T1.mpg ASC LIMIT 1",
        "amends": [
            "Do add table joins with `data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country` instead of querying only the `cars` table. Do reference the country column as `T3.country` instead of just `country`. Do use `T1.mpg` for ordering instead of `mpg` without table qualification. Do change the sort direction to `ASC` instead of `DESC`. The amended query now correctly joins multiple tables to establish proper relationships and returns the appropriate result matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cars ORDER BY mpg DESC LIMIT 1;",
            "SELECT T3.country\nFROM data AS T1\nINNER JOIN production AS T2 ON T1.ID = T2.ID\nINNER JOIN country AS T3 ON T3.origin = T2.country\nORDER BY T1.mpg ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1246": {
        "db_id": "law_episode",
        "question": "How many keywords are there for season 9, episode 23 of law_and_order?",
        "ground_truth": "SELECT COUNT(T2.keyword) FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.season = 9 AND T1.episode = 23",
        "amends": [
            "Do use `COUNT(T2.keyword)` instead of `COUNT(*)` to count specific keywords rather than all rows. Do join `Episode AS T1` and `Keyword AS T2` with `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying a single `keywords` table. Do filter on `T1.season = 9` and `T1.episode = 23` from the Episode table instead of filtering directly on a combined table with `season`, `episode`, and `show` columns. Do remove the `show = 'law_and_order'` filter instead of including it since the join properly associates episodes with their keywords. The amended query now correctly counts keywords for the specified episode by properly joining normalized tables instead of relying on a denormalized structure.",
            "Do remove the `T1.series = 'law_and_order'` filter from the WHERE clause instead of keeping it, as the right query only filters on season and episode number without the series constraint."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM keywords WHERE season = 9 AND episode = 23 AND show = 'law_and_order';",
            "SELECT COUNT(T2.keyword) \nFROM Episode AS T1 \nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id \nWHERE T1.series = 'law_and_order' AND T1.season = 9 AND T1.episode = 23",
            "SELECT COUNT(T2.keyword) \nFROM Episode AS T1 \nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id \nWHERE T1.season = 9 AND T1.episode = 23"
        ],
        "rule_sql": []
    },
    "2509": {
        "db_id": "genes",
        "question": "Of all the nonessential genes that are not of the motorprotein class and whose phenotype is cell cycle defects, how many do not have a physical type of interaction?",
        "ground_truth": "SELECT COUNT(T1.GeneID) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T2.Type != 'Physical' AND T1.Phenotype = 'Cell cycle defects' AND T1.Class != 'Motorproteins' AND T1.Essential = 'Non-Essential'",
        "amends": [
            "Do select `COUNT(T1.GeneID)` instead of `COUNT(*)`. Do join `Interactions AS T2` with `INNER JOIN` on `T1.GeneID = T2.GeneID1` instead of querying only the `genes` table. Do filter with `T2.Type != 'Physical'` instead of `physical_interaction IS NOT NULL`. Do use `T1.Phenotype = 'Cell cycle defects'` instead of `phenotype = 'cell cycle defects'`. Do filter with `T1.Class != 'Motorproteins'` instead of `class = 'motorprotein'`. Do use `T1.Essential = 'Non-Essential'` instead of `essential = 'nonessential'`. The amended query now correctly counts genes with non-physical interactions that have cell cycle defects phenotype, are not motorproteins, and are non-essential, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM genes \nWHERE essential = 'nonessential' \nAND class = 'motorprotein' \nAND phenotype = 'cell cycle defects' \nAND physical_interaction IS NOT NULL;",
            "SELECT COUNT(T1.GeneID)\nFROM Genes AS T1\nINNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1\nWHERE T1.Essential = 'Non-Essential'\nAND T1.Class != 'Motorproteins'\nAND T1.Phenotype = 'Cell cycle defects'\nAND T2.Type != 'Physical'"
        ],
        "rule_sql": []
    },
    "7462": {
        "db_id": "works_cycles",
        "question": "List the locations ids, compartments and containers for the Lock Ring",
        "ground_truth": "SELECT T2.LocationID, T2.Shelf, T2.Bin FROM Product AS T1 INNER JOIN ProductInventory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name LIKE 'Lock Ring'",
        "amends": [
            "Do select `T2.LocationID`, `T2.Shelf`, and `T2.Bin` instead of `location_id`, `compartment`, and `container`. Do use `Product AS T1` and `ProductInventory AS T2` as source tables instead of just `locations`. Do add an `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of having no join. Do change the filter to `T1.Name LIKE 'Lock Ring'` instead of `item_name = 'Lock Ring'`. The amended query now correctly joins product and inventory tables to retrieve location information for products matching the name pattern."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_id, compartment, container FROM locations WHERE item_name = 'Lock Ring';",
            "SELECT T2.LocationID, T2.Shelf, T2.Bin \nFROM Product AS T1 \nINNER JOIN ProductInventory AS T2 ON T1.ProductID = T2.ProductID \nWHERE T1.Name LIKE 'Lock Ring'"
        ],
        "rule_sql": []
    },
    "7885": {
        "db_id": "world",
        "question": "List down all cities of China.",
        "ground_truth": "SELECT T1.Name FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.Name = 'China'",
        "amends": [
            "Do select `T1.Name` instead of `*` to return only specific columns. Do use `City AS T1` and `Country AS T2` as table sources instead of just `countries`. Do add `INNER JOIN` on `T1.CountryCode = T2.Code` instead of querying a single table. Do filter on `T2.Name = 'China'` instead of `country_name = 'China'` to properly reference the joined table. The amended query now correctly joins tables and returns city names from China, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM countries WHERE country_name = 'China';",
            "SELECT T1.Name FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.Name = 'China'"
        ],
        "rule_sql": []
    },
    "839": {
        "db_id": "social_media",
        "question": "How many reshared tweets have over 100 likes?",
        "ground_truth": "SELECT COUNT(DISTINCT TweetID) FROM twitter WHERE IsReshare = 'TRUE' AND Likes > 100",
        "amends": [
            "Do `COUNT(DISTINCT TweetID)` instead of `COUNT(*)` to count unique tweet identifiers rather than all rows. Do reference table `twitter` instead of `tweets` as the correct data source. Do filter on `IsReshare = 'TRUE'` instead of `reshare_count > 100` to properly identify reshared content using a boolean flag rather than a count threshold. Do keep `Likes > 100` filter unchanged as it correctly identifies highly-liked content. The amended query now correctly counts distinct tweets that are both reshared and have over 100 likes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE reshare_count > 100 AND likes > 100",
            "SELECT COUNT(DISTINCT TweetID) FROM twitter WHERE IsReshare = 'TRUE' AND Likes > 100;"
        ],
        "rule_sql": []
    },
    "7041": {
        "db_id": "works_cycles",
        "question": "Which job title has the lowest pay?",
        "ground_truth": "SELECT T1.JobTitle FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY T2.Rate ASC LIMIT 1",
        "amends": [
            "Do reference `Employee` and `EmployeePayHistory` tables instead of a single `employees` table. Do use `INNER JOIN` on `BusinessEntityID` instead of no join condition. Do select `JobTitle` instead of `job_title` and `MAX(salary)`. Do order by `Rate ASC` instead of `lowest_pay ASC` (which was incorrectly named as it contained maximum values). Do remove the `GROUP BY job_title` and aggregation since the query now finds the single lowest rate directly. The amended query now correctly identifies the job title with the lowest pay rate by joining the appropriate tables and ordering by the actual rate field.",
            "Do select only `JobTitle` instead of including both `JobTitle` and `Rate` in the SELECT list. Do use table aliases `T1` and `T2` instead of `e` and `eph` for consistency. Do maintain the `INNER JOIN` on `BusinessEntityID` between the same tables. Do keep the `ORDER BY Rate ASC` and `LIMIT 1` to find the lowest rate, but now correctly returning only the job title associated with that minimum rate instead of both columns. The amended query now matches RIGHT_SQL's behavior by properly retrieving only the job title for the employee with the lowest pay rate."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title, MAX(salary) as lowest_pay FROM employees GROUP BY job_title ORDER BY lowest_pay ASC LIMIT 1;",
            "SELECT e.JobTitle, eph.Rate \nFROM Employee e\nINNER JOIN EmployeePayHistory eph ON e.BusinessEntityID = eph.BusinessEntityID\nORDER BY eph.Rate ASC\nLIMIT 1;",
            "SELECT T1.JobTitle\nFROM Employee T1\nINNER JOIN EmployeePayHistory T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nORDER BY T2.Rate ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7990": {
        "db_id": "university",
        "question": "What is the student staff ratio of the university with the highest student staff ratio of all time?",
        "ground_truth": "SELECT MAX(student_staff_ratio) FROM university_year WHERE student_staff_ratio = ( SELECT MAX(student_staff_ratio) FROM university_year )",
        "amends": [
            "Do use `MAX(student_staff_ratio)` instead of selecting the raw `student_staff_ratio` column. Do query from `university_year` table instead of `universities` table. Do use a subquery to find the maximum value with `SELECT MAX(student_staff_ratio) FROM university_year` instead of relying on `ORDER BY ASC LIMIT 1`. Do add a WHERE clause to filter for the maximum value with `student_staff_ratio = (subquery)` instead of using ORDER BY/LIMIT. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly identifies the maximum student_staff_ratio value from the university_year table using proper aggregation and subquery logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_staff_ratio FROM universities ORDER BY student_staff_ratio ASC LIMIT 1;",
            "SELECT student_staff_ratio FROM university_year WHERE student_staff_ratio = (SELECT MAX(student_staff_ratio) FROM university_year)"
        ],
        "rule_sql": []
    },
    "1700": {
        "db_id": "restaurant",
        "question": "Please list all of the restaurants that serve European food.",
        "ground_truth": "SELECT label FROM generalinfo WHERE food_type = 'european'",
        "amends": [
            "Do select `label` instead of `*` for the column list. Do use table `generalinfo` instead of `restaurants` as the data source. Do filter on `food_type = 'european'` instead of `cuisine = 'American'` for the WHERE condition. The amended query now correctly retrieves European food types from the general information table rather than American cuisine from restaurants."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM restaurants WHERE cuisine = 'American';",
            "SELECT label FROM generalinfo WHERE food_type = 'european'"
        ],
        "rule_sql": []
    },
    "8242": {
        "db_id": "mondial_geo",
        "question": "Which country has the biggest percentage of the albanian ethnic group?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Albanian' ORDER BY T2.Percentage DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country, MAX(percentage)` to retrieve the country name rather than aggregated data. Do join `country AS T1` with `ethnicGroup AS T2` instead of querying only `ethnic_groups` to properly relate countries with their ethnic groups. Do use `INNER JOIN` with `T1.Code = T2.Country` instead of no join condition to correctly link countries to their ethnic group data. Do filter with `T2.Name = 'Albanian'` instead of `ethnic_group = 'Albanian'` to match the correct column name for ethnic groups. Do add `ORDER BY T2.Percentage DESC LIMIT 1` instead of using `MAX(percentage)` to find the country with the highest Albanian percentage through sorting and limiting rather than aggregation. The amended query now correctly identifies the country with the highest percentage of Albanian population by properly joining tables and using ordering instead of incorrect aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, MAX(percentage) FROM ethnic_groups WHERE ethnic_group = 'Albanian';",
            "SELECT T1.Name \nFROM country AS T1 \nINNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country \nWHERE T2.Name = 'Albanian' \nORDER BY T2.Percentage DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8084": {
        "db_id": "university",
        "question": "Among the universities in Australia, how many of them have a student staff ratio of over 15 in 2011?",
        "ground_truth": "SELECT COUNT(*) FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T3.country_name = 'Australia' AND T2.student_staff_ratio > 15 AND T2.year = 2011",
        "amends": [
            "Do join `university AS T1` with `university_year AS T2` on `T1.id = T2.university_id` instead of querying a single `universities` table. Do add an additional join to `country AS T3` on `T3.id = T1.country_id` instead of directly filtering by country name. Do filter on `T3.country_name = 'Australia'` instead of `country = 'Australia'` to use the proper country table relationship. Do reference `T2.student_staff_ratio` and `T2.year` instead of accessing these columns directly from the universities table, as they belong to the university_year table. The amended query now correctly handles the normalized database schema by properly joining the university, university_year, and country tables to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE country = 'Australia' AND student_staff_ratio > 15 AND year = 2011;",
            "SELECT COUNT(*) \nFROM university AS T1\nJOIN university_year AS T2 ON T1.id = T2.university_id\nJOIN country AS T3 ON T3.id = T1.country_id\nWHERE T3.country_name = 'Australia' \nAND T2.year = 2011 \nAND T2.student_staff_ratio > 15"
        ],
        "rule_sql": []
    },
    "2836": {
        "db_id": "professional_basketball",
        "question": "Who are the coaches for team with winning rate of 80% and above?",
        "ground_truth": "SELECT coachID FROM coaches GROUP BY tmID, coachID, won, lost HAVING CAST(won AS REAL) * 100 / (won + lost) > 80",
        "amends": [
            "Do select `coachID` instead of `coach_name` and do use aggregation with `GROUP BY tmID, coachID, won, lost` instead of selecting from a single table without grouping. Do calculate the winning percentage with `CAST(won AS REAL) * 100 / (won + lost) > 80` in the `HAVING` clause instead of using a simple `winning_rate >= 80` filter in the `WHERE` clause. Do query from the `coaches` table instead of the `teams` table. The amended query now correctly calculates coaches' winning percentages from individual game records rather than relying on a pre-calculated rate column.",
            "Do remove `tmID`, `won`, `lost`, and `winning_percentage` from the SELECT list instead of including them, keeping only `coachID`. Do change the HAVING clause condition to use `>` instead of `>=` for the winning percentage threshold. Do omit the trailing semicolon instead of including it. The amended query now correctly filters for coaches with a winning percentage strictly greater than 80% and returns only their coach IDs, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_name FROM teams WHERE winning_rate >= 80;",
            "SELECT coachID, tmID, won, lost, CAST(won AS REAL) * 100 / (won + lost) AS winning_percentage FROM coaches GROUP BY tmID, coachID, won, lost HAVING CAST(won AS REAL) * 100 / (won + lost) >= 80;",
            "SELECT coachID FROM coaches GROUP BY tmID, coachID, won, lost HAVING CAST(won AS REAL) * 100 / (won + lost) > 80"
        ],
        "rule_sql": []
    },
    "3107": {
        "db_id": "cars",
        "question": "What is the price of the car ID 15?",
        "ground_truth": "SELECT T2.price FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE T1.ID = 15",
        "amends": [
            "Do select `T2.price` from the `price` table instead of `price` from the `cars` table. Do join `data AS T1` with `price AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table without any joins. Do filter on `T1.ID = 15` instead of `car_id = 16`, changing both the table reference and the specific ID value. The amended query now correctly retrieves the price from the joined price table based on the matching ID relationship between the data and price tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM cars WHERE car_id = 16;",
            "SELECT T2.price FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE T1.ID = 15"
        ],
        "rule_sql": []
    },
    "2522": {
        "db_id": "app_store",
        "question": "How many of the users hold neutral attitude on \"10 Best Foods for You\" app and what category is this app?",
        "ground_truth": "SELECT COUNT(T2.App), T1.Category FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = '10 Best Foods for You' AND T2.Sentiment = 'Neutral'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `u` and `a`. Do select `COUNT(T2.App)` and `T1.Category` instead of `COUNT(*) AS user_count` and `category`. Do join `playstore AS T1` with `user_reviews AS T2` instead of `users u` with `apps a`. Do use `INNER JOIN` on `T1.App = T2.App` instead of `JOIN` on `u.app_id = a.id`. Do filter with `T1.App = '10 Best Foods for You'` and `T2.Sentiment = 'Neutral'` instead of `u.attitude = 'neutral'` and `a.name = '10 Best Foods for You'`. Do remove `GROUP BY` instead of keeping it. The amended query now correctly counts neutral sentiment reviews for the specific app without unnecessary grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS user_count, category \nFROM users u \nJOIN apps a ON u.app_id = a.id \nWHERE u.attitude = 'neutral' \nAND a.name = '10 Best Foods for You' \nGROUP BY a.category",
            "SELECT COUNT(T2.App), T1.Category FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = '10 Best Foods for You' AND T2.Sentiment = 'Neutral'"
        ],
        "rule_sql": []
    },
    "162": {
        "db_id": "movie_platform",
        "question": "Between 1/1/2017 to 12/31/2017, how many users who were eligible for trial when they rated the movie \"Patti Smith: Dream of Life\"and what is the image URL to the movie on Mubi?",
        "ground_truth": "SELECT COUNT(T1.user_id), T2.movie_image_url FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE datetime(T1.rating_timestamp_utc) BETWEEN '2017-01-01 00:00:00' AND '2017-12-31 00:00:00'",
        "amends": [
            "Do use `COUNT(T1.user_id)` without `DISTINCT` instead of `COUNT(DISTINCT u.user_id)` to count all ratings rather than unique users. Do reference `T2.movie_image_url` instead of `m.image_url` for the correct column name. Do join `ratings AS T1` and `movies AS T2` with `INNER JOIN` on `T1.movie_id = T2.movie_id` instead of joining through `users` table and using `u.user_id = r.user_id`. Do remove the `users` table and its condition `u.eligible_for_trial = 1` instead of including them. Do use `datetime(T1.rating_timestamp_utc)` for the date filter instead of `r.rating_date` to handle timestamp conversion. Do adjust the date range to `'2017-01-01 00:00:00' AND '2017-12-31 00:00:00'` with full timestamps instead of date-only values. Do remove the movie title filter `m.title = 'Patti Smith: Dream of Life'` instead of keeping it. The amended query now correctly counts ratings within the specified timestamp range without unnecessary user eligibility checks or title filters.",
            "Do remove the alias `user_count` from the `COUNT` aggregation instead of keeping it, and do remove the filter condition `T2.movie_title = 'Patti Smith: Dream of Life'` instead of including it, as the right query only counts ratings within the specified date range without filtering by movie title. The amended query now matches RIGHT_SQL's behavior by focusing solely on rating counts within the 2017 timeframe.",
            "Do remove the filter `T2.movie_title = 'Patti Smith: Dream of Life'` from the WHERE clause instead of keeping it, as the correct query should count all ratings within the specified date range without restricting to a specific movie title. The amended query now matches RIGHT_SQL's behavior by aggregating all user ratings from 2017 without the unnecessary movie title filter.",
            "Do remove the `T2.movie_title = 'Patti Smith: Dream of Life'` filter instead of keeping it, and do remove the `T1.user_eligible_for_trial = 1` condition instead of including it. The amended query now matches RIGHT_SQL's behavior by counting all user ratings within the 2017 date range without additional filtering constraints.",
            "Do remove `T2.movie_title = 'Patti Smith: Dream of Life'` and `T1.user_eligible_for_trial = 1` filters from the WHERE clause instead of keeping them, as these conditions were incorrectly restricting the result set. The amended query now correctly counts all user ratings within the specified date range without the additional filtering constraints, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.user_id), m.image_url \nFROM users u \nJOIN ratings r ON u.user_id = r.user_id \nJOIN movies m ON r.movie_id = m.movie_id \nWHERE m.title = 'Patti Smith: Dream of Life' \nAND r.rating_date BETWEEN '2017-01-01' AND '2017-12-31' \nAND u.eligible_for_trial = 1",
            "SELECT \n    COUNT(T1.user_id) AS user_count,\n    T2.movie_image_url\nFROM \n    ratings AS T1\nINNER JOIN \n    movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE \n    datetime(T1.rating_timestamp_utc) BETWEEN '2017-01-01 00:00:00' AND '2017-12-31 00:00:00'\n    AND T2.movie_title = 'Patti Smith: Dream of Life'",
            "SELECT COUNT(T1.user_id), T2.movie_image_url\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE datetime(T1.rating_timestamp_utc) BETWEEN '2017-01-01 00:00:00' AND '2017-12-31 00:00:00'\nAND T2.movie_title = 'Patti Smith: Dream of Life'",
            "SELECT COUNT(T1.user_id), T2.movie_image_url\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE datetime(T1.rating_timestamp_utc) BETWEEN '2017-01-01 00:00:00' AND '2017-12-31 00:00:00'\nAND T2.movie_title = 'Patti Smith: Dream of Life'\nAND T1.user_eligible_for_trial = 1",
            "SELECT COUNT(T1.user_id), T2.movie_image_url\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE datetime(T1.rating_timestamp_utc) BETWEEN '2017-01-01 00:00:00' AND '2017-12-31 00:00:00'\nAND T2.movie_title = 'Patti Smith: Dream of Life'\nAND T1.user_eligible_for_trial = 1",
            "SELECT COUNT(T1.user_id), T2.movie_image_url\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE datetime(T1.rating_timestamp_utc) BETWEEN '2017-01-01 00:00:00' AND '2017-12-31 00:00:00'\nAND T2.movie_title = 'Patti Smith: Dream of Life'\nAND T1.user_eligible_for_trial = 1"
        ],
        "rule_sql": []
    },
    "8619": {
        "db_id": "chicago_crime",
        "question": "What is the percentage of under $500 thefts among all cases that happened in West Englewood?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.secondary_description = '$500 AND UNDER' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.case_number) FROM Crime AS T1 INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no INNER JOIN Community_Area AS T3 ON T1.community_area_no = T3.community_area_no WHERE T2.primary_description = 'THEFT' AND T3.community_area_name = 'West Englewood'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.secondary_description = '$500 AND UNDER' THEN 1 ELSE 0 END)` instead of `COUNT(*) FILTER (WHERE theft_amount < 500)` for conditional counting. Do add `INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no` and `INNER JOIN Community_Area AS T3 ON T1.community_area_no = T3.community_area_no` instead of querying only the `cases` table. Do filter with `T2.primary_description = 'THEFT'` instead of omitting this crime type specification. Do use `T3.community_area_name = 'West Englewood'` instead of `neighborhood = 'West Englewood'` for the area filter. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion. The amended query now correctly calculates the percentage of theft cases under $500 in West Englewood by properly joining the necessary tables and using the correct column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) FILTER (WHERE theft_amount < 500) * 100.0 / COUNT(*)) AS percentage\nFROM cases\nWHERE neighborhood = 'West Englewood';",
            "SELECT \n    (CAST(SUM(CASE WHEN T2.secondary_description = '$500 AND UNDER' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    Crime AS T1\nINNER JOIN \n    IUCR AS T2 ON T1.iucr_no = T2.iucr_no\nINNER JOIN \n    Community_Area AS T3 ON T1.community_area_no = T3.community_area_no\nWHERE \n    T2.primary_description = 'THEFT'\n    AND T3.community_area_name = 'West Englewood'"
        ],
        "rule_sql": []
    },
    "2972": {
        "db_id": "shakespeare",
        "question": "Which character was mentioned in the paragraph \"Would he do so, I'ld beg your precious mistress, Which he counts but a trifle.\"? Give the character name.",
        "ground_truth": "SELECT T1.CharName FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T2.PlainText = 'Would he do so, I''ld beg your precious mistress,Which he counts but a trifle.'",
        "amends": [
            "Do select `T1.CharName` from the `characters` table instead of `character_name` from `paragraphs`. Do add an `INNER JOIN` on `T1.id = T2.character_id` instead of querying only the `paragraphs` table. Do reference the joined table as `T2` instead of using a single table. Do filter on `T2.PlainText` with the corrected string value instead of `paragraph_text` with the original string. The amended query now correctly joins character data with paragraph text and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM paragraphs WHERE paragraph_text = \"Would he do so, I'ld beg your precious mistress, Which he counts but a trifle.\";",
            "SELECT T1.CharName \nFROM characters T1\nINNER JOIN paragraphs T2 ON T1.id = T2.character_id\nWHERE T2.PlainText = 'Would he do so, I''ld beg your precious mistress, Which he counts but a trifle.'"
        ],
        "rule_sql": []
    },
    "5958": {
        "db_id": "books",
        "question": "What is the total shipping cost of all the orders made by Page Holsey? Indicate how many of the said orders were ordered in 2022.",
        "ground_truth": "SELECT SUM(T3.cost) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Page' AND T1.last_name = 'Holsey' AND STRFTIME('%Y', T2.order_date) = '2022'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `c`, `o`, and implicit references. Do select only `SUM(T3.cost)` instead of `SUM(o.shipping_cost)` and `COUNT(CASE...)`. Do join `customer AS T1` instead of `customers c`. Do join `cust_order AS T2` instead of `orders o`. Do add `INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id` instead of omitting this table. Do move the date filter `STRFTIME('%Y', T2.order_date) = '2022'` to the `WHERE` clause instead of using it in a `COUNT` expression. Do keep the customer name filters `T1.first_name = 'Page' AND T1.last_name = 'Holsey'` in the `WHERE` clause. The amended query now correctly calculates shipping costs from the shipping_method table for orders in 2022 instead of attempting to count orders while summing shipping costs from the wrong table.",
            "Do remove the `COUNT` expression with conditional logic and the `orders_in_2022` alias instead of including them in the SELECT list. Do move the date filter `STRFTIME('%Y', T2.order_date) = '2022'` to the WHERE clause instead of keeping it in the SELECT list as a conditional count. Do add the date filter as an additional WHERE condition instead of omitting it from the filtering logic. The amended query now correctly calculates only the total shipping cost for orders placed in 2022 for the specified customer, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(o.shipping_cost) as total_shipping_cost, \n       COUNT(CASE WHEN strftime('%Y', o.order_date) = '2022' THEN 1 END) as orders_in_2022\nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE c.first_name = 'Page' AND c.last_name = 'Holsey';",
            "SELECT \n    SUM(T3.cost) AS total_shipping_cost,\n    COUNT(CASE WHEN STRFTIME('%Y', T2.order_date) = '2022' THEN 1 END) AS orders_in_2022\nFROM \n    customer AS T1\nINNER JOIN \n    cust_order AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN \n    shipping_method AS T3 ON T3.method_id = T2.shipping_method_id\nWHERE \n    T1.first_name = 'Page' AND T1.last_name = 'Holsey'",
            "SELECT SUM(T3.cost) AS total_shipping_cost\nFROM customer AS T1\nINNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id\nINNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id\nWHERE T1.first_name = 'Page' AND T1.last_name = 'Holsey'\nAND STRFTIME('%Y', T2.order_date) = '2022';"
        ],
        "rule_sql": []
    },
    "8170": {
        "db_id": "sales_in_weather",
        "question": "State the number of stores that belongs to the weather station which recorded the deepest snowfall.",
        "ground_truth": "SELECT T2.store_nbr FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr ORDER BY snowfall DESC LIMIT 1",
        "amends": [
            "Do select `T2.store_nbr` instead of `COUNT(*)` to return individual store numbers rather than an aggregate count. Do use `weather AS T1` and `relation AS T2` as FROM sources instead of only `stores` table. Do implement `INNER JOIN` on `T1.station_nbr = T2.station_nbr` instead of the subquery approach with `WHERE station_id =`. Do remove the `WHERE` filter entirely instead of using it to correlate with a subquery. Do add `ORDER BY snowfall DESC LIMIT 1` to get the top record instead of using a subquery to find the maximum snowfall station. The amended query now correctly joins weather and relation tables to find the store associated with the highest snowfall record, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores WHERE station_id = (SELECT station_id FROM weather_records ORDER BY snowfall DESC LIMIT 1);",
            "SELECT T2.store_nbr\nFROM weather AS T1\nINNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr\nORDER BY T1.snowfall DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3328": {
        "db_id": "video_games",
        "question": "What is the id of the game \"Resident Evil Archives: Resident Evil\"?",
        "ground_truth": "SELECT T.genre_id FROM game AS T WHERE T.game_name = 'Resident Evil Archives: Resident Evil'",
        "amends": [
            "Do reference the table as `game` with alias `T` instead of `games` without an alias. Do select `T.genre_id` instead of `id`. Do filter on `T.game_name` instead of `name`. Do use the correct column name `game_name` instead of `name` to match the schema. The amended query now correctly retrieves the genre_id from the game table using the proper column names and table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM games WHERE name = 'Resident Evil Archives: Resident Evil';",
            "SELECT T.genre_id FROM game T WHERE T.game_name = 'Resident Evil Archives: Resident Evil'"
        ],
        "rule_sql": []
    },
    "1906": {
        "db_id": "soccer_2016",
        "question": "Write the name of the player who was the man of the series more than one time.",
        "ground_truth": "SELECT T2.Player_Name FROM Season AS T1 INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id WHERE T1.Man_of_the_Series > 1",
        "amends": [
            "Do select `T2.Player_Name` from the `Player` table instead of `player_name` from the `players` table. Do join `Season` table with `Player` table using `INNER JOIN` on `T1.Man_of_the_Series = T2.Player_Id` instead of querying a single table. Do filter on `T1.Man_of_the_Series > 1` in the `WHERE` clause instead of `man_of_series_count > 1` since the count logic requires checking the Season table for multiple occurrences rather than a direct count column. The amended query now correctly identifies players who were man of the series more than once by joining the relevant tables and filtering appropriately.",
            "Do remove the `GROUP BY T1.Man_of_the_Series` and `HAVING COUNT(*) > 1` clauses instead of grouping and counting occurrences. Do add a `WHERE T1.Man_of_the_Series > 1` filter instead of using a HAVING clause with count aggregation. Do select only `T2.Player_Name` instead of grouping by the join key. The amended query now correctly filters for Man_of_the_Series values greater than 1 using a WHERE clause rather than incorrectly counting occurrences with grouping, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE man_of_series_count > 1;",
            "SELECT T2.Player_Name\nFROM Season T1\nINNER JOIN Player T2 ON T1.Man_of_the_Series = T2.Player_Id\nGROUP BY T1.Man_of_the_Series\nHAVING COUNT(*) > 1",
            "SELECT T2.Player_Name\nFROM Season T1\nINNER JOIN Player T2 ON T1.Man_of_the_Series = T2.Player_Id\nWHERE T1.Man_of_the_Series > 1"
        ],
        "rule_sql": []
    },
    "8492": {
        "db_id": "mondial_geo",
        "question": "Which country has the 5th highest infant mortality rate?",
        "ground_truth": "SELECT T2.Name FROM population AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code ORDER BY T1.Infant_Mortality DESC LIMIT 4, 1",
        "amends": [
            "Do select `T2.Name` from the `country` table instead of `country` from the `mortality_rates` table. Do join `population AS T1` with `country AS T2` using `INNER JOIN` on `T1.Country = T2.Code` instead of querying a single table without joins. Do order by `T1.Infant_Mortality DESC` instead of `infant_mortality_rate ASC`. Do use `LIMIT 4, 1` syntax instead of `LIMIT 1 OFFSET 4` to achieve the same fifth row result. The amended query now correctly retrieves the country name from the joined tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM mortality_rates ORDER BY infant_mortality_rate ASC LIMIT 1 OFFSET 4;",
            "SELECT T2.Name \nFROM population AS T1 \nINNER JOIN country AS T2 ON T1.Country = T2.Code \nORDER BY T1.Infant_Mortality DESC \nLIMIT 4, 1"
        ],
        "rule_sql": []
    },
    "4721": {
        "db_id": "disney",
        "question": "Who was the first ever Disney villain?",
        "ground_truth": "SELECT villian FROM characters ORDER BY SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) DESC LIMIT 1",
        "amends": [
            "Do select `villian` instead of `name` and do change the source table to `characters` instead of `disney_characters`. Do remove the `WHERE villain = 'first'` filter instead of keeping it and do add an `ORDER BY` clause with `SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) DESC` instead of omitting ordering. The amended query now correctly retrieves the villain from the characters table ordered by the last two characters of the release date in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM disney_characters WHERE villain = 'first' LIMIT 1;",
            "SELECT villian FROM characters ORDER BY SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8650": {
        "db_id": "chicago_crime",
        "question": "List down the neighborhood areas of Douglas.",
        "ground_truth": "SELECT T2.neighborhood_name FROM Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T2.community_area_no = T1.community_area_no WHERE T1.community_area_name = 'Douglas'",
        "amends": [
            "Do select `T2.neighborhood_name` instead of `*` to return specific columns. Do use `Community_Area AS T1 INNER JOIN Neighborhood AS T2` instead of a single `neighborhoods` table to properly join related data. Do apply the join condition `ON T2.community_area_no = T1.community_area_no` instead of no join condition to establish the correct relationship between tables. Do filter on `T1.community_area_name = 'Douglas'` instead of `city = 'Douglas'` to use the appropriate column name and table reference. The amended query now correctly retrieves neighborhood names from the Douglas community area by properly joining the related tables with the correct filtering condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM neighborhoods WHERE city = 'Douglas';",
            "SELECT T2.neighborhood_name \nFROM Community_Area AS T1 \nINNER JOIN Neighborhood AS T2 ON T2.community_area_no = T1.community_area_no \nWHERE T1.community_area_name = 'Douglas'"
        ],
        "rule_sql": []
    },
    "7300": {
        "db_id": "works_cycles",
        "question": "Among the products that get over at least 1 review, how many of them are from the mountain product line?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.ProductLine = 'M' THEN 1 ELSE 0 END) FROM ProductReview AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID GROUP BY T1.ProductID HAVING COUNT(T1.ProductReviewID) > 1",
        "amends": [
            "Do use `SUM(CASE WHEN T2.ProductLine = 'M' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific product line matches. Do join `ProductReview AS T1` and `Product AS T2` instead of `products p` and `reviews r` with different table names. Do use `T1.ProductID = T2.ProductID` as the join condition instead of `p.productCode = r.productCode` with different column names. Do filter for `T2.ProductLine = 'M'` in the CASE expression instead of `p.productLine = 'Mountain'` in the WHERE clause with different values. Do group by `T1.ProductID` instead of `p.productCode` with different column names. Do use `HAVING COUNT(T1.ProductReviewID) > 1` instead of `HAVING COUNT(r.reviewNumber) >= 1` with different column names and threshold values. The amended query now correctly counts products with 'M' product line that have more than one review."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM products p\nJOIN reviews r ON p.productCode = r.productCode\nWHERE p.productLine = 'Mountain'\nGROUP BY p.productCode\nHAVING COUNT(r.reviewNumber) >= 1;",
            "SELECT SUM(CASE WHEN T2.ProductLine = 'M' THEN 1 ELSE 0 END) AS MountainProductCount\nFROM ProductReview AS T1\nJOIN Product AS T2 ON T1.ProductID = T2.ProductID\nGROUP BY T1.ProductID\nHAVING COUNT(T1.ProductReviewID) > 1"
        ],
        "rule_sql": []
    },
    "567": {
        "db_id": "codebase_comments",
        "question": "What is the task of the method whose tokenized name is \"online median filter test median window filling\"?",
        "ground_truth": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'online median filter test median window filling'",
        "amends": [
            "Do select `SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task` instead of simple `task` to extract the substring between dots. Do use table `Method` instead of `methods` as the source table. Do filter on `NameTokenized = 'online median filter test median window filling'` instead of `tokenized_name = 'online median filter test median window filling'` to use the correct column name. The amended query now correctly extracts the task portion from the dot-delimited Name field and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT task FROM methods WHERE tokenized_name = 'online median filter test median window filling';",
            "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) AS task FROM Method WHERE NameTokenized = 'online median filter test median window filling'"
        ],
        "rule_sql": []
    },
    "8810": {
        "db_id": "food_inspection",
        "question": "In 2016, which city has the highest number of establishments with the highest health and safety hazards?",
        "ground_truth": "SELECT T2.city FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2016' AND T1.risk_category = 'High Risk' GROUP BY T2.city ORDER BY COUNT(T2.city) DESC LIMIT 1",
        "amends": [
            "Do select `T2.city` instead of `city` and `COUNT(*) as establishment_count`. Do use `FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id` instead of `FROM establishments`. Do add filter `STRFTIME('%Y', T1.date) = '2016'` instead of `year = 2016` and add `T1.risk_category = 'High Risk'` instead of omitting it. Do use `GROUP BY T2.city` instead of omitting grouping. Do order by `COUNT(T2.city) DESC` instead of `health_safety_hazards DESC`. The amended query now correctly counts high risk violations per city in 2016 and matches the intended behavior.",
            "Do select only `T2.city` instead of including `COUNT(*) as establishment_count` in the SELECT list. Do use `COUNT(T2.city)` instead of `COUNT(*)` in the ORDER BY clause to count non-null city values rather than all rows. The amended query now matches RIGHT_SQL's behavior by returning only the city with the highest count of High Risk violations from 2016."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as establishment_count \nFROM establishments \nWHERE year = 2016 \nORDER BY health_safety_hazards DESC \nLIMIT 1;",
            "SELECT T2.city, COUNT(*) as establishment_count\nFROM violations AS T1 \nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE STRFTIME('%Y', T1.date) = '2016' AND T1.risk_category = 'High Risk'\nGROUP BY T2.city\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT T2.city\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE STRFTIME('%Y', T1.date) = '2016' AND T1.risk_category = 'High Risk'\nGROUP BY T2.city\nORDER BY COUNT(T2.city) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3135": {
        "db_id": "cars",
        "question": "Which country does Chevy C20 come from?",
        "ground_truth": "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T1.car_name = 'chevy c20'",
        "amends": [
            "Do select `T3.country` instead of `country` to specify the table source. Do add `FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country` instead of `FROM cars` to properly join three tables with correct join conditions. Do use `WHERE T1.car_name = 'chevy c20'` instead of `WHERE model = 'Chevy C20'` to reference the correct column name and use case-insensitive matching. The amended query now correctly retrieves country information through proper table relationships and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cars WHERE model = 'Chevy C20';",
            "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T1.car_name = 'chevy c20'"
        ],
        "rule_sql": []
    },
    "7504": {
        "db_id": "image_and_language",
        "question": "How many samples of \"wall\" are there in image no.2353079?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.OBJ_CLASS = 'wall' THEN 1 ELSE 0 END) FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.IMG_ID = 2353079",
        "amends": [
            "Do use `SUM(CASE WHEN T1.OBJ_CLASS = 'wall' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only wall objects. Do join tables `OBJ_CLASSES AS T1` and `IMG_OBJ AS T2` with `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single `samples` table. Do filter on `T2.IMG_ID = 2353079` instead of `image_id = 2353079` to reference the correct column from the joined table. Do remove the direct `material = 'wall'` filter and instead incorporate it into the conditional sum expression to properly count wall objects. The amended query now correctly counts wall objects for the specified image by joining the appropriate tables and using conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM samples WHERE material = 'wall' AND image_id = 2353079;",
            "SELECT SUM(CASE WHEN T1.OBJ_CLASS = 'wall' THEN 1 ELSE 0 END) AS wall_count\nFROM OBJ_CLASSES AS T1\nINNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE T2.IMG_ID = 2353079;"
        ],
        "rule_sql": []
    },
    "2384": {
        "db_id": "superstore",
        "question": "From which city and state does the customer that bought the product with the highest sales?",
        "ground_truth": "SELECT T5.City, T5.State FROM west_superstore AS T1 INNER JOIN east_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN central_superstore AS T3 ON T3.`Customer ID` = T2.`Customer ID` INNER JOIN south_superstore AS T4 ON T4.`Customer ID` = T3.`Customer ID` INNER JOIN people AS T5 ON T5.`Customer ID` = T4.`Customer ID` ORDER BY T2.Sales DESC LIMIT 1",
        "amends": [
            "Do join multiple tables `west_superstore`, `east_superstore`, `central_superstore`, `south_superstore`, and `people` instead of querying only `customers`. Do use `INNER JOIN` conditions on `Customer ID` across all tables instead of no joins. Do select `T5.City` and `T5.State` from the `people` table instead of `city` and `state` from `customers`. Do order by `T2.Sales` from the `east_superstore` table instead of `sales` from `customers`. The amended query now correctly joins customer data across all regional stores and people tables to find the city and state with the highest sales.",
            "Do join individual tables `west_superstore`, `east_superstore`, `central_superstore`, and `south_superstore` directly with `INNER JOIN` conditions instead of using a `UNION ALL` subquery. Do chain the joins sequentially with `T1.Customer ID = T2.Customer ID`, `T3.Customer ID = T2.Customer ID`, and `T4.Customer ID = T3.Customer ID` instead of joining on both `Customer ID` and `Region` from a combined result. Do reference the final `people` table as `T5` and join on `T5.Customer ID = T4.Customer ID` instead of joining the people table directly to the combined subquery. Do order by `T2.Sales DESC` instead of ordering by `combined.Sales DESC`. The amended query now correctly joins all four superstore tables sequentially and links to the people table through the final joined table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, state FROM customers ORDER BY sales DESC LIMIT 1;",
            "SELECT p.City, p.State\nFROM people p\nINNER JOIN (\n    SELECT \"Customer ID\", Region, Sales\n    FROM west_superstore\n    UNION ALL\n    SELECT \"Customer ID\", Region, Sales\n    FROM east_superstore\n    UNION ALL\n    SELECT \"Customer ID\", Region, Sales\n    FROM central_superstore\n    UNION ALL\n    SELECT \"Customer ID\", Region, Sales\n    FROM south_superstore\n) combined ON p.\"Customer ID\" = combined.\"Customer ID\" AND p.Region = combined.Region\nORDER BY combined.Sales DESC\nLIMIT 1;",
            "SELECT T5.City, T5.State\nFROM west_superstore T1\nINNER JOIN east_superstore T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nINNER JOIN central_superstore T3 ON T2.\"Customer ID\" = T3.\"Customer ID\"\nINNER JOIN south_superstore T4 ON T3.\"Customer ID\" = T4.\"Customer ID\"\nINNER JOIN people T5 ON T4.\"Customer ID\" = T5.\"Customer ID\"\nORDER BY T2.Sales DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5998": {
        "db_id": "books",
        "question": "Who is the author who wrote the most books?",
        "ground_truth": "SELECT T1.author_name FROM author AS T1 INNER JOIN book_author AS T2 ON T1.author_id = T2.author_id GROUP BY T1.author_name ORDER BY COUNT(T2.author_id) DESC LIMIT 1",
        "amends": [
            "Do select `author_name` from the `author` table instead of `author` from the `books` table. Do join `book_author` with `author` on `author_id` instead of querying only the `books` table. Do group by `author_name` instead of grouping by `author`. Do order by `COUNT(author_id)` in descending order instead of ordering by `book_count` in ascending order. Do use an aggregate count on the join table's `author_id` instead of counting all rows from the source table. The amended query now correctly identifies authors based on their actual book relationships rather than assuming author names exist directly in the books table.",
            "Do use `T1.author_name` in the SELECT list instead of `a.author_name` and do not include the `book_count` alias in the SELECT list instead of including it. Do use `INNER JOIN` with table aliases `author AS T1` and `book_author AS T2` instead of `JOIN` with aliases `a` and `ba`. Do use the join condition `T1.author_id = T2.author_id` instead of `a.author_id = ba.author_id`. Do move the aggregate function `COUNT(T2.author_id)` to the ORDER BY clause instead of using the alias `book_count` from the SELECT list. The amended query now correctly orders by the actual count value rather than an alias, ensuring proper sorting behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author, COUNT(*) as book_count FROM books GROUP BY author ORDER BY book_count ASC LIMIT 1;",
            "SELECT a.author_name, COUNT(ba.author_id) AS book_count\nFROM author a\nJOIN book_author ba ON a.author_id = ba.author_id\nGROUP BY a.author_name\nORDER BY book_count DESC\nLIMIT 1;",
            "SELECT T1.author_name\nFROM author AS T1\nINNER JOIN book_author AS T2 ON T1.author_id = T2.author_id\nGROUP BY T1.author_name\nORDER BY COUNT(T2.author_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1554": {
        "db_id": "car_retails",
        "question": "How many customers have a credit limit of not more than 100,000 and which customer made the highest total payment amount for the year 2004?",
        "ground_truth": "SELECT ( SELECT COUNT(customerNumber) FROM customers WHERE creditLimit <= 100000 AND customerNumber IN ( SELECT customerNumber FROM payments WHERE STRFTIME('%Y', paymentDate) = '2004' ) ), T1.customerName FROM customers AS T1 INNER JOIN payments AS T2 ON T1.customerNumber = T2.customerNumber WHERE T1.creditLimit <= 100000 AND STRFTIME('%Y', T2.paymentDate) = '2004' GROUP BY T1.customerNumber, T1.customerName ORDER BY SUM(T2.amount) DESC LIMIT 1",
        "amends": [
            "Do use a scalar subquery to calculate `COUNT(customerNumber)` for customers meeting both credit limit and payment year conditions instead of counting all rows from the joined result. Do `INNER JOIN` payments instead of `LEFT JOIN` to ensure only customers with payments are included. Do add explicit table aliases `T1` and `T2` instead of implicit aliases. Do change the date function to `STRFTIME('%Y', paymentDate)` instead of `YEAR(paymentDate)` for SQLite compatibility. Do add `T1.customerName` to the `GROUP BY` clause instead of omitting it. Do order by `SUM(T2.amount)` instead of `MAX(p.amount)` to get the total payment amount per customer. Do remove the alias `highest_payment` from the select list since it's no longer used. The amended query now correctly calculates the count of qualified customers and returns the customer with the highest total payments in 2004.",
            "Do use a scalar subquery `(SELECT COUNT(customerNumber) FROM customers WHERE creditLimit <= 100000 AND customerNumber IN (SELECT customerNumber FROM payments WHERE STRFTIME('%Y', paymentDate) = '2004'))` instead of `COUNT(DISTINCT T1.customerNumber)` in the SELECT list. Do remove `SUM(T2.amount) AS total_payment` from the SELECT list instead of keeping it. Do change the ORDER BY clause to reference `SUM(T2.amount) DESC` instead of the alias `total_payment DESC`. The amended query now correctly calculates the count of qualifying customers in a subquery while maintaining the original row-level aggregation for customer details, matching the RIGHT_SQL's behavior.",
            "Do remove the `customer_count` alias from the subquery in the SELECT list instead of keeping it. Do remove the explicit `T1.customerNumber` column from the main SELECT list instead of including it, as it's already part of the GROUP BY clause. Do add the `AS` keyword for table aliases in the FROM clause instead of omitting it for both `customers AS T1` and `payments AS T2`. The amended query now correctly matches RIGHT_SQL's behavior by focusing on customer names while maintaining the same filtering and aggregation logic.",
            "Do move the subquery `(SELECT COUNT(customerNumber) FROM customers WHERE creditLimit <= 100000 AND customerNumber IN (SELECT customerNumber FROM payments WHERE STRFTIME('%Y', paymentDate) = '2004'))` to the SELECT list instead of keeping it as a separate column alias. Do add `T1.customerNumber` to the GROUP BY clause instead of omitting it, grouping by both `T1.customerNumber` and `T1.customerName` instead of just `T1.customerName` alone. The amended query now correctly returns both the count of qualifying customers and individual customer names with proper grouping, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS customer_count, \n       c.customerName, \n       MAX(p.amount) AS highest_payment\nFROM customers c\nLEFT JOIN payments p ON c.customerNumber = p.customerNumber\nWHERE c.creditLimit <= 100000\nAND YEAR(p.paymentDate) = 2004\nGROUP BY c.customerNumber\nORDER BY highest_payment DESC\nLIMIT 1;",
            "SELECT \n    COUNT(DISTINCT T1.customerNumber) AS customer_count,\n    T1.customerName,\n    SUM(T2.amount) AS total_payment\nFROM \n    customers T1\nINNER JOIN \n    payments T2 ON T1.customerNumber = T2.customerNumber\nWHERE \n    T1.creditLimit <= 100000\n    AND STRFTIME('%Y', T2.paymentDate) = '2004'\nGROUP BY \n    T1.customerNumber, T1.customerName\nORDER BY \n    total_payment DESC\nLIMIT 1",
            "SELECT \n    (SELECT COUNT(customerNumber) \n     FROM customers \n     WHERE creditLimit <= 100000 \n     AND customerNumber IN (\n         SELECT customerNumber \n         FROM payments \n         WHERE STRFTIME('%Y', paymentDate) = '2004'\n     )) AS customer_count,\n    T1.customerNumber,\n    T1.customerName\nFROM customers T1\nINNER JOIN payments T2 ON T1.customerNumber = T2.customerNumber\nWHERE T1.creditLimit <= 100000\nAND STRFTIME('%Y', T2.paymentDate) = '2004'\nGROUP BY T1.customerNumber, T1.customerName\nORDER BY SUM(T2.amount) DESC\nLIMIT 1",
            "SELECT \n    T1.customerName,\n    (SELECT COUNT(customerNumber) \n     FROM customers \n     WHERE creditLimit <= 100000 \n     AND customerNumber IN (\n         SELECT customerNumber \n         FROM payments \n         WHERE STRFTIME('%Y', paymentDate) = '2004'\n     )) AS customer_count\nFROM \n    customers AS T1\nINNER JOIN \n    payments AS T2 ON T1.customerNumber = T2.customerNumber\nWHERE \n    T1.creditLimit <= 100000\n    AND STRFTIME('%Y', T2.paymentDate) = '2004'\nGROUP BY \n    T1.customerName\nORDER BY \n    SUM(T2.amount) DESC\nLIMIT 1",
            "SELECT \n    (SELECT COUNT(customerNumber) \n     FROM customers \n     WHERE creditLimit <= 100000 \n     AND customerNumber IN (\n         SELECT customerNumber \n         FROM payments \n         WHERE STRFTIME('%Y', paymentDate) = '2004'\n     )) AS customer_count,\n    T1.customerName\nFROM customers AS T1\nINNER JOIN payments AS T2 ON T1.customerNumber = T2.customerNumber\nWHERE T1.creditLimit <= 100000\nAND STRFTIME('%Y', T2.paymentDate) = '2004'\nGROUP BY T1.customerNumber, T1.customerName\nORDER BY SUM(T2.amount) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5629": {
        "db_id": "shipping",
        "question": "Among all shipments delivered by Sue Newel, identify the percentage of shipments that were placed by Autoware Inc.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.cust_name = 'Autoware Inc' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS per FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id INNER JOIN customer AS T3 ON T3.cust_id = T1.cust_id WHERE T2.first_name = 'Sue' AND T2.last_name = 'Newell'",
        "amends": [
            "Do use `SUM(CASE WHEN T3.cust_name = 'Autoware Inc' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN customer_name = 'Autoware Inc.' THEN 1 END)` for proper conditional counting. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion. Do join `driver AS T2` on `T1.driver_id = T2.driver_id` instead of filtering by `delivery_person`. Do join `customer AS T3` on `T3.cust_id = T1.cust_id` instead of referencing `customer_name` directly. Do filter with `T2.first_name = 'Sue' AND T2.last_name = 'Newell'` instead of `delivery_person = 'Sue Newel'` for proper name matching. Do use table aliases `T1`, `T2`, `T3` instead of direct table references. The amended query now correctly joins related tables and handles name matching through proper relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN customer_name = 'Autoware Inc.' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM shipments\nWHERE delivery_person = 'Sue Newel';",
            "SELECT \n    (CAST(SUM(CASE WHEN T3.cust_name = 'Autoware Inc' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100.0 AS percentage\nFROM \n    shipment AS T1\nJOIN \n    driver AS T2 ON T1.driver_id = T2.driver_id\nJOIN \n    customer AS T3 ON T1.cust_id = T3.cust_id\nWHERE \n    T2.first_name = 'Sue' AND T2.last_name = 'Newell';"
        ],
        "rule_sql": []
    },
    "7583": {
        "db_id": "image_and_language",
        "question": "What is the image ID with a predicted class of \"parked on\"?",
        "ground_truth": "SELECT DISTINCT T1.IMG_ID FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T2.PRED_CLASS = 'parked on'",
        "amends": [
            "Do select `DISTINCT T1.IMG_ID` from `IMG_REL AS T1` instead of `image_id` from `predictions`. Do use `INNER JOIN PRED_CLASSES AS T2` with predicate `T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` instead of querying a single table. Do filter on `T2.PRED_CLASS = 'parked on'` instead of `predicted_class = 'parked on'`. The amended query now correctly joins the image relation table with the prediction classes table to resolve class IDs to class names and returns distinct image IDs, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id FROM predictions WHERE predicted_class = 'parked on';",
            "SELECT DISTINCT T1.IMG_ID FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T2.PRED_CLASS = 'parked on'"
        ],
        "rule_sql": []
    },
    "7388": {
        "db_id": "works_cycles",
        "question": "What is the profit on net of the products that have exactly 200 maximum order quantity? Indicate the name of the vendors to which these products were purchased from.",
        "ground_truth": "SELECT T1.LastReceiptCost - T1.StandardPrice, T2.Name FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.MaxOrderQty = 200",
        "amends": [
            "Do use `T1.LastReceiptCost - T1.StandardPrice` as the first column expression instead of `p.product_name`, and `T2.Name` as the second column instead of `v.vendor_name`, while removing `p.profit_on_net` from the SELECT list. Do change the FROM clause to use `ProductVendor AS T1` instead of `products p` and `Vendor AS T2` instead of `vendors v`. Do modify the JOIN condition to use `T1.BusinessEntityID = T2.BusinessEntityID` instead of `p.vendor_id = v.vendor_id`. Do change the WHERE filter to use `T1.MaxOrderQty = 200` instead of `p.max_order_quantity = 200`. Do remove the `ORDER BY p.profit_on_net DESC` clause entirely instead of keeping it. The amended query now correctly calculates cost difference and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name, v.vendor_name, p.profit_on_net \nFROM products p \nJOIN vendors v ON p.vendor_id = v.vendor_id \nWHERE p.max_order_quantity = 200 \nORDER BY p.profit_on_net DESC;",
            "SELECT \n    T1.LastReceiptCost - T1.StandardPrice AS profit_on_net,\n    T2.Name AS vendor_name\nFROM \n    ProductVendor AS T1\nJOIN \n    Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE \n    T1.MaxOrderQty = 200"
        ],
        "rule_sql": []
    },
    "6003": {
        "db_id": "books",
        "question": "What is the book with the most orders?",
        "ground_truth": "SELECT T2.title FROM order_line AS T1 INNER JOIN book AS T2 ON T1.book_id = T2.book_id GROUP BY T2.title ORDER BY COUNT(T1.book_id) DESC LIMIT 1",
        "amends": [
            "Do select `T2.title` from the `book` table instead of `book_title` from the `books` table. Do join `order_line AS T1` with `book AS T2` on `T1.book_id = T2.book_id` instead of querying a single table. Do add `GROUP BY T2.title` and aggregate with `COUNT(T1.book_id)` instead of using a simple `order_count` column. Do order by the count of ordered books instead of a pre-aggregated order count. The amended query now correctly calculates the most frequently ordered book by counting actual order line items rather than relying on a potentially incorrect pre-calculated value, matching the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(T1.book_id) AS order_count` column from the SELECT list instead of including it. Do change the ORDER BY clause to use `COUNT(T1.book_id) DESC` instead of referencing the removed alias `order_count DESC`. Do keep the explicit `INNER JOIN` syntax instead of the implicit `JOIN` keyword, though this is a cosmetic difference. The amended query now correctly orders by the actual aggregate count rather than an alias that cannot be referenced in ORDER BY when using aggregation, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT book_title FROM books ORDER BY order_count DESC LIMIT 1;",
            "SELECT T2.title, COUNT(T1.book_id) AS order_count\nFROM order_line AS T1\nJOIN book AS T2 ON T1.book_id = T2.book_id\nGROUP BY T2.title\nORDER BY order_count DESC\nLIMIT 1;",
            "SELECT T2.title\nFROM order_line AS T1\nINNER JOIN book AS T2 ON T1.book_id = T2.book_id\nGROUP BY T2.title\nORDER BY COUNT(T1.book_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "9404": {
        "db_id": "movie_3",
        "question": "List down the actor ID of actors with Dee as their last name.",
        "ground_truth": "SELECT actor_id FROM actor WHERE last_name = 'Dee'",
        "amends": [
            "Do reference table `actor` instead of `actors` in the FROM clause. Do filter on `last_name = 'Dee'` instead of `first_name = 'Dee'` in the WHERE condition. The amended query now correctly retrieves actor IDs based on last name rather than first name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id FROM actors WHERE first_name = 'Dee';",
            "SELECT actor_id FROM actor WHERE last_name = 'Dee';"
        ],
        "rule_sql": []
    },
    "5505": {
        "db_id": "menu",
        "question": "What is the event sponsored by the Republican House?",
        "ground_truth": "SELECT event FROM Menu WHERE sponsor = 'REPUBLICAN HOUSE'",
        "amends": [
            "Do select `event` from table `Menu` instead of `event_name` from table `events`. Do filter for sponsor `REPUBLICAN HOUSE` instead of `Democrat`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_name FROM events WHERE sponsor = 'Democrat'",
            "SELECT event FROM Menu WHERE sponsor = 'REPUBLICAN HOUSE';"
        ],
        "rule_sql": []
    },
    "1677": {
        "db_id": "restaurant",
        "question": "How many restaurants can we find at number 871 on its street?",
        "ground_truth": "SELECT COUNT(id_restaurant) FROM location WHERE street_num = 871",
        "amends": [
            "Do select `COUNT(id_restaurant)` instead of `COUNT(*)` to count specific non-null identifiers rather than all rows. Do query from `location` table instead of `restaurants` table to access the correct data source containing street number information. Do filter on `street_num = 871` instead of `street_number = 871` to use the correct column name and value format. The amended query now correctly counts restaurant locations at the specified street address."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE street_number = 871;",
            "SELECT COUNT(id_restaurant) FROM location WHERE street_num = 871"
        ],
        "rule_sql": []
    },
    "1074": {
        "db_id": "talkingdata",
        "question": "Among the LG brand users, calculate the percentage of the Nexus 5 model user. What is the ratio of male and female users of it?",
        "ground_truth": "SELECT SUM(IIF(T1.device_model = 'Nexus 5', 1, 0)) * 100 / COUNT(T1.device_id) AS per , SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) / SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0)) AS r FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'LG'",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` instead of `COUNT(CASE WHEN condition THEN 1 END)` for conditional counting. Do reference `T1.device_model` instead of `model` and `T1.phone_brand` instead of `brand` from the correct table. Do add an `INNER JOIN` on `gender_age AS T2` with predicate `T2.device_id = T1.device_id` instead of omitting the join entirely. Do change the male-female ratio calculation to filter by `device_model = 'Nexus 5'` in both numerator and denominator instead of calculating the ratio across all records. Do use `T1.device_id` for the total count instead of `COUNT(*)`. Do reference `T2.gender` values 'M' and 'F' instead of 'male' and 'female'. The amended query now correctly joins the necessary tables and calculates the Nexus 5 percentage and gender ratio specifically for Nexus 5 devices, matching the RIGHT_SQL's behavior.",
            "Do use `SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) / SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0))` for the male-to-female ratio calculation instead of separate male and female ratio calculations. Do simplify column aliases to `per` and `r` instead of `nexus_5_percentage`, `male_ratio`, and `female_ratio`. Do remove the explicit `* 1.0` multiplication since integer division would yield the same result in this context. The amended query now correctly calculates the male-to-female ratio directly and matches the RIGHT_SQL's behavior.",
            "Do use integer division `100 / COUNT` instead of floating-point division `100.0 / COUNT` in the percentage calculation. Do remove the multiplication by `1.0` in the ratio calculation instead of keeping it, as integer division suffices. Do remove the parentheses around the entire expressions instead of including them, as they are unnecessary for the arithmetic operations. The amended query now correctly calculates the percentage of Nexus 5 devices among LG phones and the male-to-female ratio of Nexus 5 users without unnecessary type conversions or grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN model = 'Nexus 5' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_nexus5,\n    (COUNT(CASE WHEN gender = 'male' THEN 1 END) * 1.0 / COUNT(CASE WHEN gender = 'female' THEN 1 END)) AS male_female_ratio\nFROM users\nWHERE brand = 'LG';",
            "SELECT \n    (SUM(IIF(T1.device_model = 'Nexus 5', 1, 0)) * 100.0 / COUNT(T1.device_id)) AS nexus_5_percentage,\n    (SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) * 1.0 / \n     SUM(IIF(T1.device_model = 'Nexus 5', 1, 0))) AS male_ratio,\n    (SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0)) * 1.0 / \n     SUM(IIF(T1.device_model = 'Nexus 5', 1, 0))) AS female_ratio\nFROM phone_brand_device_model2 AS T1\nINNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id\nWHERE T1.phone_brand = 'LG'",
            "SELECT \n    (SUM(IIF(T1.device_model = 'Nexus 5', 1, 0)) * 100.0 / COUNT(T1.device_id)) AS per,\n    (SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) * 1.0 / \n     SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0))) AS r\nFROM phone_brand_device_model2 AS T1\nINNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id\nWHERE T1.phone_brand = 'LG'",
            "SELECT \n    (100 * SUM(IIF(T1.device_model = 'Nexus 5', 1, 0)) / COUNT(T1.device_id)) AS per,\n    SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'M', 1, 0)) / SUM(IIF(T1.device_model = 'Nexus 5' AND T2.gender = 'F', 1, 0)) AS r\nFROM \n    phone_brand_device_model2 AS T1\nINNER JOIN \n    gender_age AS T2 ON T2.device_id = T1.device_id\nWHERE \n    T1.phone_brand = 'LG'"
        ],
        "rule_sql": []
    },
    "2713": {
        "db_id": "regional_sales",
        "question": "Please indicate total order quantity of product Candles and calculate the percentage of such product among all the orders.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.`Product Name` = 'Candles' THEN T2.`Order Quantity` ELSE 0 END), CAST(SUM(CASE WHEN T1.`Product Name` = 'Candles' THEN T2.`Order Quantity` ELSE 0 END) AS REAL) * 100 / SUM(T2.`Order Quantity`) FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Store Locations` AS T3 ON T3.StoreID = T2._StoreID",
        "amends": [
            "Do add explicit table aliases `T1`, `T2`, and `T3` instead of querying a single table. Do use `INNER JOIN` on `Products AS T1` instead of omitting the Products table. Do add `INNER JOIN` on `Sales Orders AS T2` with predicate `T2._ProductID = T1.ProductID` instead of missing the join condition. Do add `INNER JOIN` on `Store Locations AS T3` with predicate `T3.StoreID = T2._StoreID` instead of omitting this table entirely. Do reference `T1.`Product Name`` instead of `product_name` and `T2.`Order Quantity`` instead of `quantity` to match the actual column names. Do remove the alias `total_candles` instead of keeping it. Do use explicit `CAST` to `REAL` for the percentage calculation instead of implicit casting. Do move the division operation to the denominator position `* 100 / SUM(T2.`Order Quantity``)` instead of `(/ SUM(quantity)) * 100` for correct mathematical order. The amended query now correctly joins multiple tables and calculates percentages with proper column references and casting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    SUM(CASE WHEN product_name = 'Candles' THEN quantity ELSE 0 END) as total_candles,\n    (SUM(CASE WHEN product_name = 'Candles' THEN quantity ELSE 0 END) / SUM(quantity)) * 100 as percentage\nFROM orders;",
            "SELECT \n    SUM(T2.\"Order Quantity\") AS total_order_quantity,\n    CAST(SUM(T2.\"Order Quantity\") * 100 AS REAL) / (SELECT SUM(\"Order Quantity\") FROM \"Sales Orders\") AS percentage\nFROM \n    Products AS T1\nINNER JOIN \n    \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID\nINNER JOIN \n    \"Store Locations\" AS T3 ON T3.StoreID = T2._StoreID\nWHERE \n    T1.\"Product Name\" = 'Candles';"
        ],
        "rule_sql": []
    },
    "795": {
        "db_id": "social_media",
        "question": "Among all the tweets with a positive sentiment, what is the percentage of those posted by a male user?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID) AS per FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.Sentiment > 0",
        "amends": [
            "Do use `SUM(CASE WHEN T2.Gender = 'Male' THEN 1.0 ELSE 0 END)` instead of `COUNT(CASE WHEN u.gender = 'male' THEN 1 END)` to properly calculate the male count with decimal precision. Do use `INNER JOIN` instead of `JOIN` for explicit join type clarity. Do reference `T1.UserID = T2.UserID` instead of `t.user_id = u.user_id` with proper table aliases. Do use `COUNT(T1.TweetID)` instead of `COUNT(*)` to count specific tweet identifiers rather than all rows. Do use table aliases `T1` and `T2` instead of `t` and `u` for consistent naming. Do reference `T2.Gender` with proper capitalization instead of `u.gender` with lowercase. Do use `'Male'` with proper case instead of `'male'` for gender value matching. The amended query now correctly calculates the percentage of male users among positive sentiment tweets with proper decimal handling and explicit counting logic.",
            "Do use `SUM(CASE WHEN T2.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID)` as the expression instead of multiplying by `100.0` to calculate a ratio rather than a percentage. Do alias the result as `per` instead of `percentage_male` for a shorter column name. Do remove the unnecessary parentheses around the division operation for cleaner syntax. The amended query now correctly calculates the male ratio without percentage conversion and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.gender = 'male' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male\nFROM tweets t\nJOIN users u ON t.user_id = u.user_id\nWHERE t.sentiment > 0",
            "SELECT \n    (SUM(CASE WHEN T2.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID)) * 100.0 AS percentage_male\nFROM \n    twitter T1\nINNER JOIN \n    user T2 ON T1.UserID = T2.UserID\nWHERE \n    T1.Sentiment > 0;",
            "SELECT SUM(CASE WHEN T2.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID) AS per\nFROM twitter T1\nINNER JOIN user T2 ON T1.UserID = T2.UserID\nWHERE T1.Sentiment > 0"
        ],
        "rule_sql": []
    },
    "6114": {
        "db_id": "food_inspection_2",
        "question": "Among the facilities that have undergone at least one inspection in 2010, how many of them are restaurants or cafeterias?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.license_no) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T1.inspection_date) = '2010' AND T2.facility_type = 'Restaurant'",
        "amends": [
            "Do `COUNT(DISTINCT T1.license_no)` instead of `COUNT(*)` to count unique licenses rather than all inspection records. Do `FROM inspection AS T1` and `establishment AS T2` instead of `facilities f` and `inspections i` to use the correct table names and aliases. Do `INNER JOIN` on `T1.license_no = T2.license_no` instead of `JOIN` on `f.facility_id = i.facility_id` to join by license number rather than facility ID. Do `strftime('%Y', T1.inspection_date) = '2010'` instead of `i.inspection_date LIKE '2010%'` to properly extract the year from the date. Do `T2.facility_type = 'Restaurant'` instead of `f.facility_type IN ('restaurant', 'cafeteria')` to filter for only restaurant facilities with exact case matching. The amended query now correctly counts distinct restaurant licenses inspected in 2010."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM facilities f\nJOIN inspections i ON f.facility_id = i.facility_id\nWHERE i.inspection_date LIKE '2010%'\nAND f.facility_type IN ('restaurant', 'cafeteria');",
            "SELECT COUNT(DISTINCT T1.license_no) \nFROM inspection AS T1\nINNER JOIN establishment AS T2 ON T1.license_no = T2.license_no\nWHERE strftime('%Y', T1.inspection_date) = '2010'\nAND T2.facility_type = 'Restaurant'"
        ],
        "rule_sql": []
    },
    "692": {
        "db_id": "trains",
        "question": "What is the shape of the tail car on train no.1?",
        "ground_truth": "SELECT shape FROM cars WHERE train_id = 1 AND position = 4",
        "amends": [
            "Do select `shape` from the `cars` table instead of `tail_car_shape` from the `trains` table. Do filter with `train_id = 1 AND position = 4` instead of `train_number = 1` to correctly identify the specific car's shape rather than attempting to get tail car shape directly from the trains table. The amended query now properly retrieves the shape of the car in position 4 of train 1, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tail_car_shape FROM trains WHERE train_number = 1;",
            "SELECT shape FROM cars WHERE train_id = 1 AND position = 4;"
        ],
        "rule_sql": []
    },
    "7762": {
        "db_id": "hockey",
        "question": "Which team got the most wins in the Stanley Cup finals?",
        "ground_truth": "SELECT T2.name FROM TeamsSC AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year GROUP BY T2.name ORDER BY SUM(T1.W) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` instead of `team_name` and `COUNT(*) as wins`. Do use `FROM TeamsSC AS T1 INNER JOIN Teams AS T2` instead of `FROM stanley_cup_finals` with a single table. Do add join condition `ON T1.tmID = T2.tmID AND T1.year = T2.year` instead of no join condition. Do change aggregation to `SUM(T1.W)` instead of `COUNT(*)` for wins calculation. Do remove `WHERE result = 'win'` filter instead of keeping it. Do keep `GROUP BY T2.name` and `ORDER BY SUM(T1.W) DESC LIMIT 1` similar to the original structure. The amended query now correctly joins team tables with proper identifiers and uses actual win counts instead of result-based counting.",
            "Do remove `SUM(T1.W) as wins` from the SELECT list instead of including it, as the query only needs to return the team name. Do keep the same `INNER JOIN` on `T1.tmID = T2.tmID AND T1.year = T2.year` to maintain proper table correlation. Do preserve the `GROUP BY T2.name` to ensure correct aggregation. Do maintain the `ORDER BY SUM(T1.W) DESC` to sort by total wins in descending order. Do retain `LIMIT 1` to return only the top team. The amended query now correctly returns only the team name with the highest total wins, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, COUNT(*) as wins FROM stanley_cup_finals WHERE result = 'win' GROUP BY team_name ORDER BY wins DESC LIMIT 1;",
            "SELECT T2.name, SUM(T1.W) as wins\nFROM TeamsSC AS T1\nINNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nGROUP BY T2.name\nORDER BY SUM(T1.W) DESC\nLIMIT 1;",
            "SELECT T2.name\nFROM TeamsSC AS T1\nINNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nGROUP BY T2.name\nORDER BY SUM(T1.W) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2135": {
        "db_id": "world_development_indicators",
        "question": "In 2005, which series codes use the International Monetary Fund, Balance of Payments Statistics Yearbook and data files source?",
        "ground_truth": "SELECT T1.Seriescode, T2.Source FROM Footnotes AS T1 INNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode WHERE T1.Year LIKE '%2005%' AND T2.Source LIKE 'International Monetary Fund%'",
        "amends": [
            "Do select `T1.Seriescode` and `T2.Source` instead of only `series_code`. Do use `FROM Footnotes AS T1 INNER JOIN Series AS T2` instead of `FROM data_sources`. Do join on `T1.Seriescode = T2.SeriesCode` instead of no join condition. Do use `WHERE T1.Year LIKE '%2005%'` instead of `year = 2005`. Do use `T2.Source LIKE 'International Monetary Fund%'` instead of `source = 'International Monetary Fund, Balance of Payments Statistics Yearbook and data files'`. The amended query now correctly joins the Footnotes and Series tables with appropriate pattern matching for year and source values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_code FROM data_sources WHERE year = 2005 AND source = 'International Monetary Fund, Balance of Payments Statistics Yearbook and data files';",
            "SELECT T1.Seriescode, T2.Source \nFROM Footnotes AS T1 \nINNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode \nWHERE T1.Year LIKE '%2005%' \nAND T2.Source LIKE 'International Monetary Fund%'"
        ],
        "rule_sql": []
    },
    "4731": {
        "db_id": "disney",
        "question": "What is the difference in the current gross of Cars and its sequel, Cars 2? Which movie is more popular?",
        "ground_truth": "SELECT SUM(CASE WHEN movie_title = 'Cars' THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END), SUM(CASE WHEN movie_title = 'Cars 2' THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) FROM movies_total_gross",
        "amends": [
            "Do use `SUM` with `CASE` expressions to aggregate values from a single table scan instead of multiple scalar subqueries. Do reference `movie_title` and `inflation_adjusted_gross` columns instead of `title` and `gross`. Do apply data cleaning with `trim(inflation_adjusted_gross, '$')` and `REPLACE(..., ',', '')` to handle currency formatting instead of assuming clean numeric values. Do cast to `REAL` for proper numeric comparison instead of using raw string values. Do calculate both sums in a single query from `movies_total_gross` table instead of separate subqueries from `movies` table. The amended query now correctly handles formatted currency values and performs efficient single-table aggregation to match the RIGHT_SQL's behavior.",
            "Do remove the `gross_difference` calculation and `more_popular_movie` case expression from the SELECT list instead of including them. Do remove the WHERE filter `movie_title IN ('Cars', 'Cars 2')` instead of keeping it, as the CASE expressions already handle filtering by movie title. Do remove column aliases `cars_gross` and `cars2_gross` instead of assigning them. The amended query now matches RIGHT_SQL's behavior by focusing only on the two aggregate sums without additional calculations or filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT gross FROM movies WHERE title = 'Cars') - (SELECT gross FROM movies WHERE title = 'Cars 2') AS gross_difference,\n    CASE \n        WHEN (SELECT gross FROM movies WHERE title = 'Cars') > (SELECT gross FROM movies WHERE title = 'Cars 2') THEN 'Cars'\n        ELSE 'Cars 2'\n    END AS more_popular_movie",
            "SELECT \n    SUM(CASE WHEN movie_title = 'Cars' THEN CAST(REPLACE(TRIM(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) AS cars_gross,\n    SUM(CASE WHEN movie_title = 'Cars 2' THEN CAST(REPLACE(TRIM(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) AS cars2_gross,\n    SUM(CASE WHEN movie_title = 'Cars' THEN CAST(REPLACE(TRIM(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) - \n    SUM(CASE WHEN movie_title = 'Cars 2' THEN CAST(REPLACE(TRIM(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) AS gross_difference,\n    CASE \n        WHEN SUM(CASE WHEN movie_title = 'Cars' THEN CAST(REPLACE(TRIM(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) > \n             SUM(CASE WHEN movie_title = 'Cars 2' THEN CAST(REPLACE(TRIM(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) \n        THEN 'Cars' \n        ELSE 'Cars 2' \n    END AS more_popular_movie\nFROM movies_total_gross\nWHERE movie_title IN ('Cars', 'Cars 2');",
            "SELECT \n    SUM(CASE WHEN movie_title = 'Cars' THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) AS cars_gross,\n    SUM(CASE WHEN movie_title = 'Cars 2' THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) AS cars2_gross\nFROM movies_total_gross"
        ],
        "rule_sql": []
    },
    "7577": {
        "db_id": "image_and_language",
        "question": "Based on image 5, what is the percentage of images that belong windows object class?",
        "ground_truth": "SELECT CAST(COUNT(T1.OBJ_SAMPLE_ID) AS REAL) * 100 / COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE 0 END) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'windows'",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` with proper join conditions instead of querying a single table. Do change the FROM clause to use `INNER JOIN` between `IMG_OBJ AS T1` and `OBJ_CLASSES AS T2` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying only the `images` table. Do replace the simple `COUNT(*)` with `COUNT(T1.OBJ_SAMPLE_ID)` for the numerator and a conditional `COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE 0 END)` for the denominator instead of using a subquery. Do add explicit `CAST` to `REAL` for proper division instead of implicit casting. Do move the filter condition to reference `T2.OBJ_CLASS = 'windows'` instead of `object_class = 'windows'` on the wrong table. Do remove the percentage calculation subquery and instead perform direct arithmetic with proper table references. The amended query now correctly calculates the percentage using proper table relationships and conditional counting logic.",
            "Do calculate the percentage as `COUNT(T1.OBJ_SAMPLE_ID) * 100 / COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE NULL END) / COUNT(T1.OBJ_SAMPLE_ID) * 100.0` to properly handle the division operation and use `0` instead of `NULL` in the conditional count. Do remove the alias `percentage` instead of keeping it for consistency with the simplified output structure. The amended query now correctly computes the percentage by counting all object sample IDs and dividing by the count of specific image IDs, matching the intended behavior.",
            "Do move the filter `T2.OBJ_CLASS = 'windows'` from the CASE expression to the WHERE clause instead of filtering by `T1.IMG_ID = 5` in WHERE. Do remove the conditional CASE expression around `T1.OBJ_SAMPLE_ID` in the COUNT function and instead count all `T1.OBJ_SAMPLE_ID` directly instead of using conditional logic. Do change the numerator calculation to count all matching records instead of only those meeting the window condition. Do maintain the same JOIN structure and denominator calculation but with corrected filtering logic that properly identifies windows objects. The amended query now correctly calculates the percentage of windows objects by filtering on the class condition in WHERE instead of using conditional aggregation, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM images)) AS percentage FROM images WHERE object_class = 'windows';",
            "SELECT \n    (CAST(COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE NULL END) AS REAL) / \n     CAST(COUNT(T1.OBJ_SAMPLE_ID) AS REAL)) * 100.0 AS percentage\nFROM IMG_OBJ AS T1\nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE T2.OBJ_CLASS = 'windows'",
            "SELECT \n    CAST(COUNT(CASE WHEN T2.OBJ_CLASS = 'windows' THEN T1.OBJ_SAMPLE_ID ELSE NULL END) * 100.0 / COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE 0 END) AS REAL) AS percentage\nFROM \n    IMG_OBJ AS T1\nINNER JOIN \n    OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE \n    T1.IMG_ID = 5",
            "SELECT \n    CAST(COUNT(T1.OBJ_SAMPLE_ID) AS REAL) * 100 / \n    COUNT(CASE WHEN T1.IMG_ID = 5 THEN 1 ELSE 0 END) AS percentage\nFROM \n    IMG_OBJ AS T1\nINNER JOIN \n    OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE \n    T2.OBJ_CLASS = 'windows'"
        ],
        "rule_sql": []
    },
    "9022": {
        "db_id": "bike_share_1",
        "question": "Write down the times when there is no available bike to borrow in a station. List down the stations name and location coordinate.",
        "ground_truth": "SELECT T2.time, T1.name, T1.lat, T1.long FROM station AS T1 INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE T2.bikes_available = 0",
        "amends": [
            "Do select `T2.time`, `T1.name`, `T1.lat`, and `T1.long` instead of `station_name` and `location_coordinate`. Do use `station AS T1` and `status AS T2` tables instead of just `stations`. Do add `INNER JOIN` on `T2.station_id = T1.id` instead of no join condition. Do filter on `T2.bikes_available = 0` instead of `available_bikes = 0`. The amended query now correctly joins station and status tables to find stations with no available bikes at specific times."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name, location_coordinate FROM stations WHERE available_bikes = 0;",
            "SELECT T2.time, T1.name, T1.lat, T1.long\nFROM station AS T1\nINNER JOIN status AS T2 ON T2.station_id = T1.id\nWHERE T2.bikes_available = 0;"
        ],
        "rule_sql": []
    },
    "257": {
        "db_id": "retail_complains",
        "question": "What is the percentage of the increase of complaints filed by the clients from New York from the year 2016 to the year 2017?",
        "ground_truth": "SELECT 100.0 * (SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2017' THEN 1 ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2016' THEN 1 ELSE 0 END)) / SUM(CASE WHEN strftime('%Y', T2.`Date received`) = '2016' THEN 1 ELSE 0 END) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'New York City'",
        "amends": [
            "Do use `SUM(CASE ... END)` with explicit `ELSE 0` instead of `COUNT(CASE ... END)` to properly calculate differences. Do extract year from `strftime('%Y', T2.\\`Date received\\`)` instead of relying on a `year` column. Do join `client AS T1` and `events AS T2` on `T1.client_id = T2.Client_ID` instead of querying a single `complaints` table. Do filter on `T1.city = 'New York City'` instead of `client_state = 'New York'`. Do multiply by `100.0` at the beginning of the expression instead of at the end to maintain calculation precedence. The amended query now correctly calculates percentage increase using proper table relationships and date handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN year = 2017 THEN 1 END) - COUNT(CASE WHEN year = 2016 THEN 1 END)) * 100.0 / COUNT(CASE WHEN year = 2016 THEN 1 END) AS percentage_increase\nFROM complaints\nWHERE client_state = 'New York'\nAND year IN (2016, 2017);",
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', T2.\"Date received\") = '2017' THEN 1 ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', T2.\"Date received\") = '2016' THEN 1 ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN strftime('%Y', T2.\"Date received\") = '2016' THEN 1 ELSE 0 END) AS percentage_increase\nFROM \n    client AS T1\nJOIN \n    events AS T2 ON T1.client_id = T2.Client_ID\nWHERE \n    T1.city = 'New York City'"
        ],
        "rule_sql": []
    },
    "236": {
        "db_id": "book_publishing_company",
        "question": "Calculate the average level difference between the Marketing editors hired by the US and non-US publishers?",
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN T1.country = 'USA' THEN job_lvl ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.country = 'USA' THEN 1 ELSE 0 END)) - (CAST(SUM(CASE WHEN T1.country != 'USA' THEN job_lvl ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.country != 'USA' THEN 1 ELSE 0 END)) FROM publishers AS T1 INNER JOIN employee AS T2 ON T1.pub_id = T2.pub_id INNER JOIN jobs AS T3 ON T2.job_id = T3.job_id WHERE T3.job_desc = 'Managing Editor'",
        "amends": [
            "Do calculate average level differences using explicit sum and count operations with conditional aggregation instead of a simple AVG of differences. Do use `publishers` and `employee` tables joined on `pub_id` instead of self-joining `editors` and `publishers` tables. Do filter for `job_desc = 'Managing Editor'` in the WHERE clause instead of filtering for department='Marketing'. Do handle country comparisons using conditional CASE statements within aggregates instead of separate table joins for US vs non-US publishers. Do use proper table aliases `T1`, `T2`, `T3` instead of `e1`, `e2`, `p1`, `p2`. Do explicitly cast sums to REAL for proper division instead of relying on implicit casting. Do remove the incorrect self-join condition `e1.editor_id = e2.editor_id` which would compare the same editor. The amended query now correctly calculates the average level difference between US and non-US managing editors using proper conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(e1.level - e2.level) AS avg_level_difference\nFROM editors e1\nJOIN publishers p1 ON e1.publisher_id = p1.publisher_id\nJOIN editors e2 ON e1.editor_id = e2.editor_id\nJOIN publishers p2 ON e2.publisher_id = p2.publisher_id\nWHERE e1.department = 'Marketing' \nAND e2.department = 'Marketing'\nAND p1.country = 'US'\nAND p2.country != 'US';",
            "SELECT \n    (SUM(CASE WHEN p.country = 'USA' THEN e.job_lvl ELSE 0 END) * 1.0 / SUM(CASE WHEN p.country = 'USA' THEN 1 ELSE 0 END)) - \n    (SUM(CASE WHEN p.country != 'USA' THEN e.job_lvl ELSE 0 END) * 1.0 / SUM(CASE WHEN p.country != 'USA' THEN 1 ELSE 0 END)) AS avg_level_difference\nFROM employee e\nJOIN publishers p ON e.pub_id = p.pub_id\nJOIN jobs j ON e.job_id = j.job_id\nWHERE j.job_desc = 'Managing Editor';"
        ],
        "rule_sql": []
    },
    "1155": {
        "db_id": "talkingdata",
        "question": "How many events have happened on the device of the youngest female user?",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM events AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T2.gender = 'F' GROUP BY T1.event_id, T2.age ORDER BY T2.age LIMIT 1",
        "amends": [
            "Do use `COUNT(T1.event_id)` with explicit column reference instead of `COUNT(*)` for aggregation. Do add `INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id` instead of using a subquery for device lookup. Do filter with `T2.gender = 'F'` instead of `gender = 'female'` for gender condition. Do add `GROUP BY T1.event_id, T2.age` instead of omitting grouping for proper aggregation. Do add `ORDER BY T2.age` instead of ordering by age in the subquery. Do add `LIMIT 1` at the query level instead of within a subquery. Do remove the correlated subquery entirely instead of using it for device filtering. The amended query now correctly joins tables and aggregates events by gender and age with proper grouping and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE device_id = (SELECT device_id FROM users WHERE gender = 'female' ORDER BY age ASC LIMIT 1);",
            "SELECT COUNT(T1.event_id) \nFROM events AS T1\nINNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id\nWHERE T2.gender = 'F'\nGROUP BY T1.event_id, T2.age\nORDER BY T2.age\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8837": {
        "db_id": "food_inspection",
        "question": "List the names and business certificates of the eateries which got inspection score under 50.",
        "ground_truth": "SELECT T2.name, T2.business_id FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score < 50",
        "amends": [
            "Do select `T2.name` and `T2.business_id` instead of `name` and `business_certificate`. Do join `inspections AS T1` with `businesses AS T2` on `T1.business_id = T2.business_id` instead of querying only the `eateries` table. Do filter on `T1.score < 50` instead of `inspection_score > 50`. The amended query now correctly retrieves business names and IDs from businesses with inspection scores below 50 by joining the inspections and businesses tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, business_certificate FROM eateries WHERE inspection_score > 50;",
            "SELECT T2.name, T2.business_id\nFROM inspections AS T1\nJOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T1.score < 50;"
        ],
        "rule_sql": []
    },
    "5177": {
        "db_id": "address",
        "question": "What are the zip code for the Senate house?",
        "ground_truth": "SELECT T2.zip_code FROM congress AS T1 INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district WHERE T1.House = 'House of Repsentatives' GROUP BY T2.zip_code",
        "amends": [
            "Do select `T2.zip_code` from `congress AS T1` instead of `zip_code` from `houses`. Do use `INNER JOIN` on `zip_congress AS T2` with predicate `T1.congress_rep_id = T2.district` instead of no join. Do filter with `T1.House = 'House of Representatives'` instead of `type = 'Senate'`. Do add `GROUP BY T2.zip_code` instead of omitting grouping. The amended query now correctly retrieves zip codes from the joined congressional data with proper filtering and grouping.",
            "Do use the correct spelling `'House of Repsentatives'` in the WHERE filter instead of the misspelled `'House of Representatives'`. The amended query now matches RIGHT_SQL's behavior with the corrected filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM houses WHERE type = 'Senate'",
            "SELECT T2.zip_code\nFROM congress AS T1\nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district\nWHERE T1.House = 'House of Representatives'\nGROUP BY T2.zip_code",
            "SELECT T2.zip_code\nFROM congress AS T1\nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district\nWHERE T1.House = 'House of Repsentatives'\nGROUP BY T2.zip_code"
        ],
        "rule_sql": []
    },
    "3193": {
        "db_id": "donor",
        "question": "Please list the types of resources that the vendor Lakeshore Learning Materials has provided for the projects.",
        "ground_truth": "SELECT DISTINCT project_resource_type FROM resources WHERE vendor_name = 'Lakeshore Learning Materials'",
        "amends": [
            "Do select `project_resource_type` instead of `resource_type` and add `DISTINCT` instead of omitting it. Do query from `resources` table instead of `vendors` table while keeping the same `WHERE` filter condition on `vendor_name = 'Lakeshore Learning Materials'`. The amended query now correctly retrieves distinct project resource types from the resources table for the specified vendor."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT resource_type FROM vendors WHERE vendor_name = 'Lakeshore Learning Materials';",
            "SELECT DISTINCT project_resource_type FROM resources WHERE vendor_name = 'Lakeshore Learning Materials';"
        ],
        "rule_sql": []
    },
    "6818": {
        "db_id": "retails",
        "question": "How many Japanese suppliers have their accounts in debt?",
        "ground_truth": "SELECT COUNT(T1.s_suppkey) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 AND T2.n_name = 'JAPAN'",
        "amends": [
            "Do reference specific columns like `T1.s_suppkey` instead of using `COUNT(*)` for more precise counting. Do join `supplier AS T1` with `nation AS T2` on `T1.s_nationkey = T2.n_nationkey` instead of querying a single table without joins. Do filter on `T1.s_acctbal < 0` instead of `account_balance > 0` to capture negative account balances. Do use `T2.n_name = 'JAPAN'` instead of `country = 'Japan'` to filter by nation name from the joined table. The amended query now correctly counts suppliers from Japan with negative account balances by properly joining the supplier and nation tables and using the appropriate filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE country = 'Japan' AND account_balance > 0;",
            "SELECT COUNT(T1.s_suppkey) \nFROM supplier AS T1 \nJOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey \nWHERE T2.n_name = 'JAPAN' AND T1.s_acctbal < 0"
        ],
        "rule_sql": []
    },
    "3432": {
        "db_id": "video_games",
        "question": "What publishers have the word 'Entertainment' in their name?",
        "ground_truth": "SELECT T.publisher_name FROM publisher AS T WHERE T.publisher_name LIKE '%Entertainment%'",
        "amends": [
            "Do specify `T.publisher_name` in the SELECT list instead of using `*` to select all columns. Do use the table alias `T` for the `publisher` table instead of referencing the table directly as `publishers`. Do reference the column as `T.publisher_name` in the WHERE clause instead of just `name`. The amended query now correctly selects only the publisher name from the publisher table with proper table aliasing and column references, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM publishers WHERE name LIKE '%Entertainment%';",
            "SELECT T.publisher_name FROM publisher T WHERE T.publisher_name LIKE '%Entertainment%'"
        ],
        "rule_sql": []
    },
    "2926": {
        "db_id": "professional_basketball",
        "question": "How many games did team of the scoring champion win in 2001 NBA season?",
        "ground_truth": "SELECT T2.W FROM teams AS T1 INNER JOIN series_post AS T2 ON T1.tmID = T2.tmIDLoser AND T1.year = T2.year WHERE T2.year = 2001 ORDER BY T1.o_fgm DESC LIMIT 1",
        "amends": [
            "Do select `T2.W` instead of `COUNT(*)`. Do use `FROM teams AS T1 INNER JOIN series_post AS T2` instead of `FROM games` with a subquery. Do join on `T1.tmID = T2.tmIDLoser AND T1.year = T2.year` instead of filtering by `team_id` from a subquery. Do filter with `WHERE T2.year = 2001` instead of `season = '2001'` and remove the `result = 'win'` condition. Do add `ORDER BY T1.o_fgm DESC LIMIT 1` instead of omitting ordering and limiting. Do remove the nested subqueries for maximum points per game and instead use a direct join approach. The amended query now correctly retrieves the W column from series_post for the team with the highest offensive field goals made in 2001, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE team_id = (SELECT team_id FROM players WHERE points_per_game = (SELECT MAX(points_per_game) FROM players WHERE season = '2001')) AND season = '2001' AND result = 'win';",
            "SELECT T2.W \nFROM teams AS T1 \nINNER JOIN series_post AS T2 ON T1.tmID = T2.tmIDLoser AND T1.year = T2.year \nWHERE T2.year = 2001 \nORDER BY T1.o_fgm DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "9403": {
        "db_id": "movie_3",
        "question": "How many films have a duration between 100 to 110 minutes?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE length BETWEEN 100 AND 110",
        "amends": [
            "Do use `COUNT(film_id)` instead of `COUNT(*)` to count only non-null film_id values. Do reference table `film` instead of `films` to use the correct table name. Do use `BETWEEN 100 AND 110` filter instead of `duration < 100 OR duration > 110` to properly include films with length between 100 and 110 minutes inclusive, rather than excluding them. Do remove the incorrect `duration` column reference and use `length` instead to match the actual column name. The amended query now correctly counts films within the specified length range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE duration < 100 OR duration > 110;",
            "SELECT COUNT(film_id) FROM film WHERE length BETWEEN 100 AND 110;"
        ],
        "rule_sql": []
    },
    "3475": {
        "db_id": "video_games",
        "question": "What is the genre of the game \"Grand Theft Auto V\"?",
        "ground_truth": "SELECT T2.genre_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T1.game_name = 'Grand Theft Auto V'",
        "amends": [
            "Do select `T2.genre_name` from the genre table instead of `genre` from the games table. Do join `game AS T1` with `genre AS T2` on `T1.genre_id = T2.id` instead of querying a single table. Do filter on `T1.game_name = 'Grand Theft Auto V'` instead of `title = 'Grand Theft Auto V'` to use the correct column name from the joined table. The amended query now properly retrieves genre information through a table join relationship instead of assuming the genre exists directly in the games table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE title = 'Grand Theft Auto V';",
            "SELECT T2.genre_name FROM game AS T1 JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T1.game_name = 'Grand Theft Auto V'"
        ],
        "rule_sql": []
    },
    "4884": {
        "db_id": "legislator",
        "question": "Please list the official full names of all the current legislators who have served in the U.S. House.",
        "ground_truth": "SELECT official_full_name FROM current WHERE house_history_id IS NOT NULL",
        "amends": [
            "Do select `official_full_name` instead of `first_name, last_name`. Do use table `current` instead of `legislators`. Do filter with `house_history_id IS NOT NULL` instead of `chamber = 'House' AND current_member = 1`. The amended query now correctly retrieves full names from the current table where house history information exists, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM legislators WHERE chamber = 'House' AND current_member = 1",
            "SELECT official_full_name FROM current WHERE house_history_id IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "585": {
        "db_id": "codebase_comments",
        "question": "In \"maxild_playground\\Playground.sln\", what is the time of sampling for the method \"GitHubRepo.Cli.GitHubClientWrapper.GetReleases\"?",
        "ground_truth": "SELECT T2.SampledAt FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.Path = 'maxild_playgroundPlayground.sln' AND T2.Name = 'GitHubRepo.Cli.GitHubClientWrapper.GetReleases'",
        "amends": [
            "Do select `T2.SampledAt` instead of `sampling_time` and use table aliases `T1` and `T2` instead of direct table names. Do join `Solution AS T1` and `Method AS T2` with `INNER JOIN` on `T1.Id = T2.SolutionId` instead of querying a single table `maxild_playground`. Do filter on `T1.Path = 'maxild_playgroundPlayground.sln'` instead of omitting this condition, and do filter on `T2.Name = 'GitHubRepo.Cli.GitHubClientWrapper.GetReleases'` instead of `method_name = 'GitHubRepo.Cli.GitHubClientWrapper.GetReleases'`. The amended query now correctly retrieves sampling time from the Method table joined with Solution table using proper relationships.",
            "Do use the path value 'maxild_playgroundPlayground.sln' instead of 'maxild_playground\\Playground.sln' in the WHERE clause filter on T1.Path, removing the backslash character that was incorrectly included. The amended query now correctly matches the RIGHT_SQL's behavior with the proper path filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sampling_time FROM maxild_playground WHERE method_name = 'GitHubRepo.Cli.GitHubClientWrapper.GetReleases';",
            "SELECT T2.SampledAt\nFROM Solution AS T1\nINNER JOIN Method AS T2 ON T1.Id = T2.SolutionId\nWHERE T1.Path = 'maxild_playground\\Playground.sln'\nAND T2.Name = 'GitHubRepo.Cli.GitHubClientWrapper.GetReleases'",
            "SELECT T2.SampledAt\nFROM Solution AS T1\nINNER JOIN Method AS T2 ON T1.Id = T2.SolutionId\nWHERE T1.Path = 'maxild_playgroundPlayground.sln'\nAND T2.Name = 'GitHubRepo.Cli.GitHubClientWrapper.GetReleases'"
        ],
        "rule_sql": []
    },
    "7393": {
        "db_id": "works_cycles",
        "question": "What is the primary type of all single female employees hired between 1/1/2008 to 12/31/2008?",
        "ground_truth": "SELECT T2.PersonType FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Gender = 'F' AND T1.MaritalStatus = 'S' AND STRFTIME('%Y-%m-%d', T1.HireDate) BETWEEN '2008-1-1' AND '2008-12-31' GROUP BY T2.PersonType ORDER BY COUNT(T2.PersonType) DESC LIMIT 1",
        "amends": [
            "Do select `T2.PersonType` instead of `primary_type` and add aggregation with `GROUP BY T2.PersonType` and `ORDER BY COUNT(T2.PersonType) DESC LIMIT 1` instead of omitting grouping and ordering. Do join `Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` instead of querying only `employees` table. Do filter with `T1.Gender = 'F'` instead of `gender = 'Female'` and add `T1.MaritalStatus = 'S'` instead of omitting it. Do use `STRFTIME('%Y-%m-%d', T1.HireDate)` for date formatting instead of direct `hire_date` comparison and adjust date format to `'2008-1-1'` instead of `'2008-01-01'`. The amended query now correctly joins tables, applies proper filters, formats dates appropriately, and returns the most common PersonType with count-based ordering.",
            "Do remove `COUNT(T2.PersonType) AS count` from the SELECT list instead of including it, as only `T2.PersonType` is needed. Do keep the same `FROM` sources with `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of changing it. Do maintain the same `WHERE` filters for `T1.Gender = 'F'`, `T1.MaritalStatus = 'S'`, and the date range on `T1.HireDate` instead of modifying them. Do preserve the `GROUP BY T2.PersonType` instead of altering it. Do retain the `ORDER BY COUNT(T2.PersonType) DESC` and `LIMIT 1` instead of changing the ordering or limit. The amended query now correctly returns only the PersonType with the highest count instead of including the count value itself, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT primary_type FROM employees WHERE gender = 'Female' AND hire_date BETWEEN '2008-01-01' AND '2008-12-31'",
            "SELECT T2.PersonType, COUNT(T2.PersonType) AS count\nFROM Employee AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.Gender = 'F'\nAND T1.MaritalStatus = 'S'\nAND STRFTIME('%Y-%m-%d', T1.HireDate) BETWEEN '2008-1-1' AND '2008-12-31'\nGROUP BY T2.PersonType\nORDER BY COUNT(T2.PersonType) DESC\nLIMIT 1;",
            "SELECT T2.PersonType\nFROM Employee AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.Gender = 'F'\nAND T1.MaritalStatus = 'S'\nAND STRFTIME('%Y-%m-%d', T1.HireDate) BETWEEN '2008-1-1' AND '2008-12-31'\nGROUP BY T2.PersonType\nORDER BY COUNT(T2.PersonType) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5667": {
        "db_id": "shipping",
        "question": "What model year of truck delivered the ship ID 1233?",
        "ground_truth": "SELECT T1.model_year FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = '1233'",
        "amends": [
            "Do use `T1.model_year` with table alias instead of bare `model_year`. Do add `INNER JOIN shipment AS T2` instead of querying only the trucks table. Do specify join condition `ON T1.truck_id = T2.truck_id` instead of missing the table relationship. Do filter on `T2.ship_id = '1233'` with string comparison instead of `ship_id = 1233` with numeric comparison against the wrong table. The amended query now correctly joins tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model_year FROM trucks WHERE ship_id = 1233;",
            "SELECT T1.model_year FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = '1233'"
        ],
        "rule_sql": []
    },
    "947": {
        "db_id": "cs_semester",
        "question": "For the students with an intelligence of 5, list the full name and courses taken by them who have less than a 3 GPA.",
        "ground_truth": "SELECT T1.f_name, T1.l_name, T3.name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T1.intelligence = 5 AND T1.gpa < 3",
        "amends": [
            "Do select `T1.f_name`, `T1.l_name`, and `T3.name` instead of `first_name`, `last_name`, and `course_name`. Do use explicit table aliases `T1`, `T2`, and `T3` instead of no aliases. Do add `INNER JOIN registration AS T2` and `INNER JOIN course AS T3` instead of querying only the `students` table. Do join on `T1.student_id = T2.student_id` and `T2.course_id = T3.course_id` instead of having no joins. Do change the filter to `T1.gpa < 3` instead of `GPA >= 3` while keeping `T1.intelligence = 5`. The amended query now correctly joins related tables and applies the proper GPA filter to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, course_name FROM students WHERE intelligence = 5 AND GPA >= 3",
            "SELECT T1.f_name, T1.l_name, T3.name\nFROM student AS T1\nINNER JOIN registration AS T2 ON T1.student_id = T2.student_id\nINNER JOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T1.intelligence = 5 AND T1.gpa < 3"
        ],
        "rule_sql": []
    },
    "4486": {
        "db_id": "student_loan",
        "question": "Among all students, calculate the percentage of disabled students.",
        "ground_truth": "SELECT CAST(COUNT(T2.name) AS REAL) * 100 / COUNT(T1.name) FROM person AS T1 LEFT JOIN disabled AS T2 ON T2.name = T1.name",
        "amends": [
            "Do use `CAST(COUNT(T2.name) AS REAL)` instead of `COUNT(*) * 100.0` for precise percentage calculation. Do reference `person AS T1` and `disabled AS T2` tables instead of only `students`. Do implement `LEFT JOIN disabled AS T2 ON T2.name = T1.name` instead of filtering with `WHERE disability_status = 'disabled'` to include all persons in the denominator. Do calculate percentage as `COUNT(T2.name) * 100 / COUNT(T1.name)` instead of using a subquery `(SELECT COUNT(*) FROM students)` for the total count. Do remove the alias `percentage_disabled` instead of keeping it. The amended query now correctly handles the percentage calculation by joining tables and properly counting disabled individuals against the total population."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students)) AS percentage_disabled FROM students WHERE disability_status = 'disabled';",
            "SELECT CAST(COUNT(T2.name) AS REAL) * 100 / COUNT(T1.name) FROM person AS T1 LEFT JOIN disabled AS T2 ON T2.name = T1.name;"
        ],
        "rule_sql": []
    },
    "8267": {
        "db_id": "mondial_geo",
        "question": "What is the average population growth rate of countries where more than 3 languages are used?",
        "ground_truth": "SELECT SUM(T3.Population_Growth) / COUNT(T3.Country) FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country INNER JOIN population AS T3 ON T3.Country = T2.Country WHERE T2.Country IN ( SELECT Country FROM language GROUP BY Country HAVING COUNT(Country) > 3 ) GROUP BY T3.Country",
        "amends": [
            "Do use `SUM(T3.Population_Growth) / COUNT(T3.Country)` instead of `AVG(population_growth_rate)` to calculate the average manually. Do add `FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country INNER JOIN population AS T3 ON T3.Country = T2.Country` instead of the single table reference, introducing proper joins between country, language, and population tables. Do change the filter to `WHERE T2.Country IN (SELECT Country FROM language GROUP BY Country HAVING COUNT(Country) > 3)` instead of `WHERE language_count > 3`, using a subquery to identify countries with more than 3 languages. Do add `GROUP BY T3.Country` instead of omitting it, ensuring the calculation is performed per country. The amended query now correctly joins multiple tables and calculates average population growth for countries with more than 3 languages, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(population_growth_rate) FROM countries WHERE language_count > 3;",
            "SELECT SUM(T3.Population_Growth) / COUNT(T3.Country) AS average_population_growth\nFROM country AS T1 \nINNER JOIN language AS T2 ON T1.Code = T2.Country \nINNER JOIN population AS T3 ON T3.Country = T2.Country\nWHERE T2.Country IN (\n    SELECT Country \n    FROM language \n    GROUP BY Country \n    HAVING COUNT(Country) > 3\n)\nGROUP BY T3.Country"
        ],
        "rule_sql": []
    },
    "1843": {
        "db_id": "soccer_2016",
        "question": "List the player's name of Mumbai Indians in the match ID 335990.",
        "ground_truth": "SELECT T3.Team_Name FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T2.Player_Id = T1.Player_Id INNER JOIN Team AS T3 ON T3.Team_Id = T2.Team_Id WHERE T2.Match_Id = 335990 AND T3.Team_Name = 'Mumbai Indians' GROUP BY T3.Team_Name",
        "amends": [
            "Do use `T3.Team_Name` in the SELECT list instead of `player_name` and add `GROUP BY T3.Team_Name` instead of omitting it. Do join `Player AS T1` with `Player_Match AS T2` on `T2.Player_Id = T1.Player_Id` instead of querying only the `players` table, and join `Team AS T3` on `T3.Team_Id = T2.Team_Id` instead of missing these table relationships entirely. Do filter on `T2.Match_Id = 335990` and `T3.Team_Name = 'Mumbai Indians'` in the WHERE clause instead of filtering directly on `team_name` from a single table. The amended query now correctly retrieves team names through proper table joins and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE team_name = 'Mumbai Indians' AND match_id = 335990;",
            "SELECT T3.Team_Name\nFROM Player AS T1\nJOIN Player_Match AS T2 ON T2.Player_Id = T1.Player_Id\nJOIN Team AS T3 ON T3.Team_Id = T2.Team_Id\nWHERE T2.Match_Id = 335990 AND T3.Team_Name = 'Mumbai Indians'\nGROUP BY T3.Team_Name"
        ],
        "rule_sql": []
    },
    "4184": {
        "db_id": "simpson_episodes",
        "question": "List the name of all awards along with the award category, nominated by Marc Wilmore.",
        "ground_truth": "SELECT award_id, award_category FROM Award WHERE person = 'Marc Wilmore';",
        "amends": [
            "Do select `award_id` and `award_category` instead of `a.name` and `a.category`. Do query from `Award` table instead of joining `awards` and `nominations` tables. Do use filter `person = 'Marc Wilmore'` instead of `n.nominee = 'Marc Wilmore'` and remove the join condition entirely. The amended query now correctly retrieves award information directly from the Award table using the person filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.name, a.category FROM awards a JOIN nominations n ON a.id = n.award_id WHERE n.nominee = 'Marc Wilmore'",
            "SELECT award_id, award_category FROM Award WHERE person = 'Marc Wilmore'"
        ],
        "rule_sql": []
    },
    "4416": {
        "db_id": "student_loan",
        "question": "What is the ratio of disable female to male students?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100 / COUNT(T2.name) FROM disabled AS T1 LEFT JOIN male AS T2 ON T1.`name` = T2.`name`",
        "amends": [
            "Do use a single query with `LEFT JOIN` between `disabled` and `male` tables instead of separate subqueries counting female and male students. Do calculate the percentage of disabled students not in the male table using `SUM(IIF(T2.name IS NULL, 1, 0))` instead of computing a ratio between female and male disabled counts. Do cast the result as `REAL` and multiply by 100 for percentage calculation instead of a simple division ratio. Do reference tables `disabled AS T1` and `male AS T2` with proper join condition `ON T1.name = T2.name` instead of filtering by gender and disabled status in subqueries. The amended query now correctly calculates the percentage of disabled students who are not male, matching the RIGHT_SQL's behavior.",
            "Do use `COUNT(T2.name)` instead of `COUNT(*)` in the denominator calculation. Do maintain the `LEFT JOIN` on `T1.name = T2.name` between the `disabled` and `male` tables. Do preserve the `CAST` to `REAL` and the percentage calculation logic with `SUM(IIF(T2.name IS NULL, 1, 0)) * 100`. The amended query now correctly calculates the percentage of records in the disabled table that don't have matching names in the male table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM students WHERE gender = 'female' AND disabled = 1) / \n    (SELECT COUNT(*) FROM students WHERE gender = 'male' AND disabled = 1) \nAS female_to_male_ratio;",
            "SELECT \n    CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100.0 / COUNT(*) AS percentage\nFROM \n    disabled AS T1\nLEFT JOIN \n    male AS T2 ON T1.name = T2.name;",
            "SELECT CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100.0 / COUNT(T2.name) AS percentage\nFROM disabled AS T1\nLEFT JOIN male AS T2 ON T1.name = T2.name;"
        ],
        "rule_sql": []
    },
    "250": {
        "db_id": "retail_complains",
        "question": "Among all the clients from the New York city, how many of them have filed a complaint on the issue of Deposits and withdrawals?",
        "ground_truth": "SELECT COUNT(T2.Issue) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.Issue = 'Deposits and withdrawals' AND T1.city = 'New York City'",
        "amends": [
            "Do join `client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID` instead of querying only `clients` table. Do count `T2.Issue` instead of `COUNT(*)`. Do filter on `T2.Issue = 'Deposits and withdrawals'` instead of `complaint_type = 'Deposits and withdrawals'`. Do filter on `T1.city = 'New York City'` instead of `city = 'New York'`. The amended query now correctly joins related tables and counts specific issues while using the proper city name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE city = 'New York' AND complaint_type = 'Deposits and withdrawals';",
            "SELECT COUNT(T2.Issue) \nFROM client AS T1 \nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID \nWHERE T1.city = 'New York City' \nAND T2.Issue = 'Deposits and withdrawals'"
        ],
        "rule_sql": []
    },
    "137": {
        "db_id": "movie_platform",
        "question": "For all the users who gave \"A Shot in the Dark\" a rating, how many percent of them is a paying subscriber?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.user_has_payment_method = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists_users AS T3 ON T1.user_id = T3.user_id WHERE T2.movie_title = 'A Shot in the Dark'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.user_has_payment_method = 1 THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN u.subscription_status = 'paid' THEN r.user_id END)` for counting paying users. Do join `movies AS T2` on `T1.movie_id = T2.movie_id` instead of omitting the movies table. Do join `lists_users AS T3` on `T1.user_id = T3.user_id` instead of joining `users u` on `r.user_id = u.user_id`. Do use `T2.movie_title = 'A Shot in the Dark'` instead of `r.movie_title = 'A Shot in the Dark'` for filtering by movie title. Do calculate the percentage as `CAST(... AS REAL) * 100 / COUNT(*)` instead of `* 100.0 / COUNT(DISTINCT r.user_id)`. Do remove the `DISTINCT` modifier from the count operations. The amended query now correctly calculates the percentage of users with payment methods who rated the specified movie."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN u.subscription_status = 'paid' THEN r.user_id END) * 100.0 / COUNT(DISTINCT r.user_id)) AS percentage_paying_subscribers\nFROM ratings r\nJOIN users u ON r.user_id = u.user_id\nWHERE r.movie_title = 'A Shot in the Dark';",
            "SELECT \n    CAST(SUM(CASE WHEN T3.user_has_payment_method = '1' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentage_paying_subscribers\nFROM \n    ratings T1\nJOIN \n    movies T2 ON T1.movie_id = T2.movie_id\nJOIN \n    lists_users T3 ON T1.user_id = T3.user_id\nWHERE \n    T2.movie_title = 'A Shot in the Dark';"
        ],
        "rule_sql": []
    },
    "3483": {
        "db_id": "video_games",
        "question": "Compute the average number of sales in region ID 3.",
        "ground_truth": "SELECT AVG(T.num_sales * 100000) FROM region_sales AS T WHERE T.region_id = 3",
        "amends": [
            "Do use the `region_sales` table with alias `T` instead of the `sales` table. Do calculate the average of `T.num_sales * 100000` instead of just `quantity`. Do reference the column as `T.region_id` instead of just `region_id` while keeping the same filter condition `= 3`. The amended query now correctly calculates the scaled average sales figure for the specified region."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(quantity) FROM sales WHERE region_id = 3;",
            "SELECT AVG(T.num_sales * 100000) FROM region_sales T WHERE T.region_id = 3"
        ],
        "rule_sql": []
    },
    "5089": {
        "db_id": "address",
        "question": "Please list the zip_codes of all the residential areas in Huntingdon county with over 30 employees.",
        "ground_truth": "SELECT DISTINCT T1.zip_code FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'HUNTINGDON' AND T1.employees > 30",
        "amends": [
            "Do use `DISTINCT T1.zip_code` instead of just `zip_code` to eliminate duplicates. Do join `zip_data AS T1` with `country AS T2` instead of querying only `residential_areas`. Do use `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of no join condition. Do filter on `T2.county = 'HUNTINGDON'` instead of `county = 'Huntingdon'` with corrected case sensitivity. Do keep `T1.employees > 30` filter but reference it through the joined table instead of standalone. The amended query now correctly joins the necessary tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM residential_areas WHERE county = 'Huntingdon' AND employees > 30;",
            "SELECT DISTINCT T1.zip_code\nFROM zip_data AS T1\nINNER JOIN country AS T2 ON T1.zip_code = T2.zip_code\nWHERE T2.county = 'HUNTINGDON' AND T1.employees > 30;"
        ],
        "rule_sql": []
    },
    "6785": {
        "db_id": "retails",
        "question": "How many suppliers from Egypt have a debit balance?",
        "ground_truth": "SELECT COUNT(T1.s_suppkey) FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 AND T2.n_name = 'EGYPT'",
        "amends": [
            "Do reference the `supplier` table as `T1` instead of `suppliers`, and add an `INNER JOIN` to the `nation` table as `T2` on `T1.s_nationkey = T2.n_nationkey` instead of querying a single table. Do count `T1.s_suppkey` instead of using `COUNT(*)` for more precise counting. Do filter on `T1.s_acctbal < 0` instead of `balance > 0` to find negative account balances. Do filter on `T2.n_name = 'EGYPT'` instead of `country = 'Egypt'` to use the joined nation table's name field with uppercase comparison. The amended query now correctly joins supplier and nation tables to count Egyptian suppliers with negative account balances."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE country = 'Egypt' AND balance > 0;",
            "SELECT COUNT(T1.s_suppkey) \nFROM supplier AS T1 \nINNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey \nWHERE T2.n_name = 'EGYPT' AND T1.s_acctbal < 0"
        ],
        "rule_sql": []
    },
    "4021": {
        "db_id": "public_review_platform",
        "question": "Among the businesses which have short length of review, which one located in Phoenix?",
        "ground_truth": "SELECT DISTINCT T1.business_id FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'Phoenix' AND T2.review_length = 'Short'",
        "amends": [
            "Do select `DISTINCT T1.business_id` instead of `name` from the result set. Do join `Business AS T1 INNER JOIN Reviews AS T2` instead of querying only the `businesses` table. Do use the join condition `T1.business_id = T2.business_id` instead of no join. Do filter on `T1.city = 'Phoenix'` instead of `city = 'Phoenix'` to specify the table alias. Do filter on `T2.review_length = 'Short'` instead of `LENGTH(review) > 1000` to use a categorical value rather than a length calculation. The amended query now correctly retrieves distinct business IDs from Phoenix with short reviews by properly joining the Business and Reviews tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE city = 'Phoenix' AND LENGTH(review) > 1000;",
            "SELECT DISTINCT T1.business_id\nFROM Business AS T1\nINNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id\nWHERE T1.city = 'Phoenix' AND T2.review_length = 'Short'"
        ],
        "rule_sql": []
    },
    "4225": {
        "db_id": "simpson_episodes",
        "question": "Mention the episode ID, title and any three keywords of the episode which get the most number of votes in star classification of worst.",
        "ground_truth": "SELECT DISTINCT T3.episode_id, T2.title, T1.keyword FROM Keyword AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Vote AS T3 ON T2.episode_id = T3.episode_id WHERE T3.stars = 1 ORDER BY T3.votes DESC LIMIT 3;",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `T3.episode_id`, `T2.title`, and `T1.keyword` instead of `episode_id`, `title`, `keyword1`, `keyword2`, `keyword3`. Do join `Keyword AS T1` instead of omitting it, with `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of no join. Do join `Episode AS T2` instead of querying `episodes` directly, and add `INNER JOIN Vote AS T3` on `T2.episode_id = T3.episode_id` instead of omitting the Vote table. Do add `WHERE T3.stars = 1` filter instead of omitting it, and change `ORDER BY T3.votes DESC` instead of `votes DESC`. Do set `LIMIT 3` instead of `LIMIT 1`. The amended query now correctly finds the top 3 episodes with 1-star votes by joining necessary tables and applying proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id, title, keyword1, keyword2, keyword3 \nFROM episodes \nORDER BY votes DESC \nLIMIT 1;",
            "SELECT DISTINCT T3.episode_id, T2.title, T1.keyword\nFROM Keyword AS T1\nINNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id\nINNER JOIN Vote AS T3 ON T2.episode_id = T3.episode_id\nWHERE T3.stars = 1\nORDER BY T3.votes DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "988": {
        "db_id": "computer_student",
        "question": "How many basic or medium undergraduate courses are taught by a professor?",
        "ground_truth": "SELECT COUNT(*) FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id INNER JOIN person AS T3 ON T3.p_id = T2.p_id WHERE T1.courseLevel = 'Level_300' AND T3.professor = 1",
        "amends": [
            "Do join `course AS T1` with `taughtBy AS T2` on `T1.course_id = T2.course_id` instead of querying only the `courses` table, then join `person AS T3` on `T3.p_id = T2.p_id` instead of omitting these necessary table relationships. Do filter on `T1.courseLevel = 'Level_300'` instead of `level = 'basic' OR level = 'medium'`, and do filter on `T3.professor = 1` instead of `instructor_title = 'professor'` to properly check the professor status through the correct table and column. The amended query now correctly counts courses at level 300 taught by professors through the proper table relationships and filtering logic.",
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT T1.course_id)` to count all matching rows rather than distinct course IDs. Do remove the explicit `DISTINCT` modifier instead of keeping it since the join structure ensures unique counting without it. Do specify `INNER JOIN` explicitly for both joins instead of implicit `JOIN` syntax for clarity, though this is functionally equivalent. The amended query now correctly counts all course instances meeting the Level_300 and professor criteria rather than distinct courses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE (level = 'basic' OR level = 'medium') AND instructor_title = 'professor';",
            "SELECT COUNT(DISTINCT T1.course_id) \nFROM course AS T1 \nJOIN taughtBy AS T2 ON T1.course_id = T2.course_id \nJOIN person AS T3 ON T3.p_id = T2.p_id \nWHERE T1.courseLevel = 'Level_300' \nAND T3.professor = 1",
            "SELECT COUNT(*)\nFROM course AS T1\nINNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id\nINNER JOIN person AS T3 ON T3.p_id = T2.p_id\nWHERE T1.courseLevel = 'Level_300'\nAND T3.professor = 1"
        ],
        "rule_sql": []
    },
    "3499": {
        "db_id": "video_games",
        "question": "Calculate the total number of sales in North America.",
        "ground_truth": "SELECT SUM(T2.num_sales) * 100000 AS nums FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'North America'",
        "amends": [
            "Do use `SUM(T2.num_sales) * 100000 AS nums` instead of `COUNT(*)` to calculate the scaled sales total rather than counting rows. Do join `region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id` instead of querying only the `sales` table to properly relate regions to their sales data. Do filter on `T1.region_name = 'North America'` instead of `region = 'North America'` to use the correct column name from the joined region table. The amended query now correctly calculates the total sales value for North America by joining the appropriate tables and using the proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE region = 'North America';",
            "SELECT SUM(T2.num_sales) * 100000 AS nums\nFROM region AS T1 \nINNER JOIN region_sales AS T2 ON T1.id = T2.region_id\nWHERE T1.region_name = 'North America'"
        ],
        "rule_sql": []
    },
    "7774": {
        "db_id": "hockey",
        "question": "In the year 2000, which team has played the most games against the Buffalo Sabres?",
        "ground_truth": "SELECT T3.name FROM TeamVsTeam AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.oppID = T2.tmID INNER JOIN Teams AS T3 ON T1.year = T3.year AND T1.tmID = T3.tmID WHERE T1.year = 2000 AND T2.name = 'Buffalo Sabres' GROUP BY T3.name ORDER BY SUM(T2.G) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `TeamVsTeam AS T1` with `Teams AS T2` on `T1.year = T2.year AND T1.oppID = T2.tmID` instead of filtering on opponent name directly. Do add a second join to `Teams AS T3` on `T1.year = T3.year AND T1.tmID = T3.tmID` instead of selecting from a single table. Do filter on `T2.name = 'Buffalo Sabres'` instead of `opponent = 'Buffalo Sabres'`. Do select `T3.name` instead of `team_name`. Do aggregate with `SUM(T2.G)` instead of `COUNT(*)` for games played calculation. Do order by `SUM(T2.G) DESC` instead of `games_played DESC`. The amended query now correctly joins through the relationship tables to identify games against Buffalo Sabres and sums actual games played rather than counting rows.",
            "Do remove `SUM(T2.G) AS games_played` from the SELECT list instead of including it, as only `T3.name` is needed in the final output. Do change the implicit `JOIN` to explicit `INNER JOIN` for both table joins instead of using the shorthand syntax, though this is primarily a cosmetic change. The WHERE clause with `T1.year = 2000 AND T2.name = 'Buffalo Sabres'`, GROUP BY on `T3.name`, ORDER BY on `SUM(T2.G) DESC`, and LIMIT 1 remain unchanged as they correctly identify games involving Buffalo Sabres in 2000 and return the team with the most games played against them. The amended query now matches RIGHT_SQL's behavior by focusing only on retrieving the team name without the aggregate calculation in the result set."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, COUNT(*) as games_played \nFROM games \nWHERE year = 2000 AND opponent = 'Buffalo Sabres' \nGROUP BY team_name \nORDER BY games_played DESC \nLIMIT 1;",
            "SELECT T3.name, SUM(T2.G) AS games_played\nFROM TeamVsTeam AS T1\nJOIN Teams AS T2 ON T1.year = T2.year AND T1.oppID = T2.tmID\nJOIN Teams AS T3 ON T1.year = T3.year AND T1.tmID = T3.tmID\nWHERE T1.year = 2000 AND T2.name = 'Buffalo Sabres'\nGROUP BY T3.name\nORDER BY SUM(T2.G) DESC\nLIMIT 1;",
            "SELECT T3.name\nFROM TeamVsTeam AS T1\nINNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.oppID = T2.tmID\nINNER JOIN Teams AS T3 ON T1.year = T3.year AND T1.tmID = T3.tmID\nWHERE T1.year = 2000 AND T2.name = 'Buffalo Sabres'\nGROUP BY T3.name\nORDER BY SUM(T2.G) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8995": {
        "db_id": "bike_share_1",
        "question": "Name the station and city with the most borrowed bike.",
        "ground_truth": "SELECT T2.start_station_name, T1.city FROM station AS T1 INNER JOIN trip AS T2 ON T2.start_station_name = T1.name GROUP BY T2.start_station_name ORDER BY COUNT(T2.start_station_name) DESC LIMIT 1",
        "amends": [
            "Do select `T2.start_station_name` and `T1.city` instead of `station_name` and `city`. Do join `station AS T1` with `trip AS T2` using `INNER JOIN` on `T2.start_station_name = T1.name` instead of querying only the `stations` table. Do add `GROUP BY T2.start_station_name` instead of omitting grouping. Do order by `COUNT(T2.start_station_name) DESC` instead of `bike_count DESC`. The amended query now correctly identifies the most frequently used starting station by counting trip occurrences rather than relying on bike inventory counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name, city FROM stations ORDER BY bike_count DESC LIMIT 1;",
            "SELECT T2.start_station_name, T1.city\nFROM station AS T1\nINNER JOIN trip AS T2 ON T2.start_station_name = T1.name\nGROUP BY T2.start_station_name\nORDER BY COUNT(T2.start_station_name) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2110": {
        "db_id": "world_development_indicators",
        "question": "List down the series codes in which the topic is about Environment: Emissions and the license type is restricted. Please include their alpha code.",
        "ground_truth": "SELECT SeriesCode FROM Series WHERE Topic = 'Environment: Emissions' AND LicenseType = 'Restricted'",
        "amends": [
            "Do select only `SeriesCode` instead of both `series_code` and `alpha_code`. Do use exact column name `SeriesCode` instead of lowercase `series_code`. Do remove the `alpha_code` column instead of including it. Do use exact table name `Series` instead of lowercase `series`. Do use exact condition value `Restricted` instead of lowercase `restricted` for the LicenseType filter. The amended query now correctly retrieves only the SeriesCode column with proper case sensitivity matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_code, alpha_code FROM series WHERE topic = 'Environment: Emissions' AND license_type = 'restricted';",
            "SELECT SeriesCode FROM Series WHERE Topic = 'Environment: Emissions' AND LicenseType = 'Restricted';"
        ],
        "rule_sql": []
    },
    "4703": {
        "db_id": "disney",
        "question": "What movies did director Jack Kinney direct?",
        "ground_truth": "SELECT name FROM director WHERE director = 'Jack Kinney'",
        "amends": [
            "Do select only `name` from the `director` table instead of selecting all columns from the `movies` table. Do query the `director` table instead of the `movies` table while keeping the filter condition `director = 'Jack Kinney'` unchanged. The amended query now correctly retrieves director names from the appropriate table instead of attempting to find movies by a director name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM movies WHERE director = 'Jack Kinney';",
            "SELECT name FROM director WHERE director = 'Jack Kinney';"
        ],
        "rule_sql": []
    },
    "7936": {
        "db_id": "music_platform_2",
        "question": "What is the name of the podcast in which a commentor left a comment with the title 'Long time listener, calling it quits?' Include the URL of the podcast as well.",
        "ground_truth": "SELECT podcast_id, itunes_url FROM podcasts WHERE podcast_id = ( SELECT podcast_id FROM reviews WHERE title = 'Long time listener, calling it quits' )",
        "amends": [
            "Do select `podcast_id` and `itunes_url` instead of `podcast_name` and `url`. Do use a subquery in the WHERE clause to filter by `podcast_id` from the `reviews` table where `title` matches the condition instead of directly filtering on `comment_title` in the `podcasts` table. Do reference `title` instead of `comment_title` and ensure the subquery correctly correlates the podcast ID from reviews to the main query. The amended query now correctly retrieves podcast information based on review titles rather than attempting to filter on a non-existent column in the podcasts table.",
            "Do use `=` instead of `IN` for the subquery predicate since it returns a single value. Do remove the question mark from the literal string filter `'Long time listener, calling it quits'` instead of `'Long time listener, calling it quits?'` to match the exact title value. The amended query now correctly uses equality comparison for a single-value subquery result and matches the exact review title filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT podcast_name, url FROM podcasts WHERE comment_title = 'Long time listener, calling it quits';",
            "SELECT podcast_id, itunes_url FROM podcasts WHERE podcast_id IN (SELECT podcast_id FROM reviews WHERE title = 'Long time listener, calling it quits?')",
            "SELECT podcast_id, itunes_url FROM podcasts WHERE podcast_id = (SELECT podcast_id FROM reviews WHERE title = 'Long time listener, calling it quits')"
        ],
        "rule_sql": []
    },
    "325": {
        "db_id": "retail_complains",
        "question": "Please list any two clients with their full names who have been tagged as \"Older American\" by the company without seeking their permission.",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.Tags = 'Older American' AND T2.`Consumer consent provided?` IN (NULL, 'N/A', '') LIMIT 2",
        "amends": [
            "Do select `T1.first`, `T1.middle`, `T1.last` instead of `first_name`, `last_name`. Do use `INNER JOIN` on `events AS T2` with predicate `T1.client_id = T2.Client_ID` instead of querying only the `clients` table. Do filter on `T2.Tags = 'Older American'` instead of `tag = 'Older American'`. Do use `T2.Consumer consent provided? IN (NULL, 'N/A', '')` instead of `permission_granted = 0`. The amended query now correctly joins the client and events tables to filter based on event tags and consent status, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE tag = 'Older American' AND permission_granted = 0 LIMIT 2;",
            "SELECT T1.first, T1.middle, T1.last\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T2.Tags = 'Older American'\nAND T2.\"Consumer consent provided?\" IN (NULL, 'N/A', '')\nLIMIT 2"
        ],
        "rule_sql": []
    },
    "7298": {
        "db_id": "works_cycles",
        "question": "Please give all the list prices of the product LL Fork.",
        "ground_truth": "SELECT T2.ListPrice FROM Product AS T1 INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'LL Fork'",
        "amends": [
            "Do select `T2.ListPrice` instead of `price` and add `Product AS T1` and `ProductListPriceHistory AS T2` as data sources instead of only `products`. Do use `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of no join condition. Do filter on `T1.Name = 'LL Fork'` instead of `product_name = 'LL Fork'`. The amended query now correctly retrieves the list price from the price history table joined to the product table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM products WHERE product_name = 'LL Fork';",
            "SELECT T2.ListPrice \nFROM Product AS T1 \nINNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID \nWHERE T1.Name = 'LL Fork'"
        ],
        "rule_sql": []
    },
    "5911": {
        "db_id": "airline",
        "question": "Among the flights of the air carrier described as American Airlines, what is the percentage of the flights with earlier departure?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.DEP_DELAY < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description LIKE '%American Airlines%'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.DEP_DELAY < 0 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN departure_time < '12:00:00' THEN 1 END)` for counting early departures based on delay rather than time threshold. Do join `Air Carriers` AS T1 with `Airlines` AS T2 on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of querying a single `flights` table. Do filter with `T1.Description LIKE '%American Airlines%'` instead of `carrier = 'American Airlines'` to match carrier descriptions containing the airline name. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion for percentage calculation accuracy. Do remove the percentage calculation denominator placement from the column alias instead of including it in the expression structure. The amended query now correctly identifies early departures using delay-based logic and properly joins carrier reference data with flight operations data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN departure_time < '12:00:00' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_early_departures\nFROM flights\nWHERE carrier = 'American Airlines';",
            "SELECT \n    (SUM(CASE WHEN T2.DEP_DELAY < 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage_early_departures\nFROM \n    \"Air Carriers\" AS T1\nJOIN \n    Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nWHERE \n    T1.Description LIKE '%American Airlines%';"
        ],
        "rule_sql": []
    },
    "9405": {
        "db_id": "movie_3",
        "question": "Among the active customers, how many of them have Nina as their first name?",
        "ground_truth": "SELECT COUNT(customer_id) FROM customer WHERE first_name = 'Nina' AND active = 1",
        "amends": [
            "Do count `customer_id` instead of `*` to exclude NULL values. Do reference table `customer` instead of `customers` to use the correct table name. Do filter on `active = 1` instead of `status = 'active'` to use the proper boolean column and numeric value format. The amended query now correctly counts active customers named Nina while handling NULL values appropriately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE first_name = 'Nina' AND status = 'active';",
            "SELECT COUNT(customer_id) FROM customer WHERE first_name = 'Nina' AND active = 1;"
        ],
        "rule_sql": []
    },
    "7879": {
        "db_id": "world",
        "question": "List down languages used in Malaysia.",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Malaysia'",
        "amends": [
            "Do join `Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do select `T2.Language` from the joined table instead of `language` from a single table. Do filter on `T1.Name = 'Malaysia'` instead of `country = 'Malaysia'` to use the correct column name from the joined schema. The amended query now correctly retrieves language data by joining the Country and CountryLanguage tables on their relationship key."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE country = 'Malaysia';",
            "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Malaysia'"
        ],
        "rule_sql": []
    },
    "5936": {
        "db_id": "books",
        "question": "How many books did David Foster Wallace write?",
        "ground_truth": "SELECT COUNT(T1.title) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'David Foster Wallace'",
        "amends": [
            "Do join `book AS T1` with `book_author AS T2` on `T1.book_id = T2.book_id` and `author AS T3` on `T3.author_id = T2.author_id` instead of querying only the `books` table. Do filter on `T3.author_name = 'David Foster Wallace'` instead of `author = 'David Foster Wallace'` to properly reference the author table. Do count `T1.title` instead of `COUNT(*)` to count specific book titles rather than all rows. The amended query now correctly joins the necessary tables to establish the relationship between books and authors and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE author = 'David Foster Wallace';",
            "SELECT COUNT(T1.title) \nFROM book AS T1 \nJOIN book_author AS T2 ON T1.book_id = T2.book_id \nJOIN author AS T3 ON T3.author_id = T2.author_id \nWHERE T3.author_name = 'David Foster Wallace'"
        ],
        "rule_sql": []
    },
    "3315": {
        "db_id": "video_games",
        "question": "Which publisher has published the most games?",
        "ground_truth": "SELECT T.publisher_name FROM ( SELECT T2.publisher_name, COUNT(DISTINCT T2.id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id GROUP BY T1.publisher_id ORDER BY COUNT(T2.id) DESC LIMIT 1 ) t",
        "amends": [
            "Do select `publisher_name` instead of `publisher` and move the selection to a subquery instead of a simple query. Do join `game_publisher` with `publisher` on `publisher_id = id` instead of querying only the `games` table. Do use `COUNT(DISTINCT id)` instead of `COUNT(*)` to count distinct games. Do order by `COUNT(id) DESC` instead of `game_count ASC` to find the publisher with the most games. Do group by `publisher_id` instead of `publisher` for proper aggregation. The amended query now correctly identifies the publisher with the highest distinct game count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher, COUNT(*) as game_count FROM games GROUP BY publisher ORDER BY game_count ASC LIMIT 1;",
            "SELECT publisher_name \nFROM publisher \nWHERE id = (\n    SELECT publisher_id \n    FROM game_publisher \n    GROUP BY publisher_id \n    ORDER BY COUNT(DISTINCT game_id) DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "4035": {
        "db_id": "public_review_platform",
        "question": "Which year has the most elite users?",
        "ground_truth": "SELECT year_id FROM Elite GROUP BY year_id ORDER BY COUNT(user_id) DESC LIMIT 1",
        "amends": [
            "Do reference table `Elite` instead of `users` and use column `year_id` instead of `year`. Do remove the `WHERE elite = 1` filter since the Elite table inherently contains only elite users. Do change the aggregation to count `user_id` instead of using `COUNT(*)` for more precise user counting. Do select only `year_id` instead of both `year` and `user_count` in the SELECT list. Do move the count expression from the SELECT list to the ORDER BY clause instead of selecting it as a column. The amended query now correctly identifies the year with the most elite users by counting distinct user IDs from the dedicated Elite table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as user_count FROM users WHERE elite = 1 GROUP BY year ORDER BY user_count DESC LIMIT 1;",
            "SELECT year_id FROM Elite GROUP BY year_id ORDER BY COUNT(DISTINCT user_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3833": {
        "db_id": "public_review_platform",
        "question": "What are the categories that business number 15 belongs to?",
        "ground_truth": "SELECT T2.category_name FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id WHERE T1.business_id = 15",
        "amends": [
            "Do select `T2.category_name` instead of `*` to retrieve only the category name instead of all columns. Do add `Business_Categories AS T1` and `Categories AS T2` tables instead of querying only the `businesses` table. Do use `INNER JOIN` on `T1.category_id = T2.category_id` instead of no join condition. Do filter on `T1.business_id = 15` instead of `business_id = 15` to reference the correct table's column. The amended query now correctly retrieves category names for business ID 15 by joining the appropriate tables with proper relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM businesses WHERE business_id = 15;",
            "SELECT T2.category_name \nFROM Business_Categories AS T1 \nINNER JOIN Categories AS T2 ON T1.category_id = T2.category_id \nWHERE T1.business_id = 15"
        ],
        "rule_sql": []
    },
    "4688": {
        "db_id": "disney",
        "question": "Which movies had the main character named Donald Duck and who directed them?",
        "ground_truth": "SELECT T1.movie_title, T2.director FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T1.hero = 'Donald Duck'",
        "amends": [
            "Do select `movie_title` and `director` instead of `title` and `director_name`. Do use table aliases `T1` and `T2` instead of `m` and `d`. Do join `characters AS T1` with `director AS T2` instead of `movies` with `directors`. Do use join condition `T1.movie_title = T2.name` instead of `m.director_id = d.director_id`. Do filter on `T1.hero = 'Donald Duck'` instead of `m.main_character = 'Donald Duck'`. The amended query now correctly retrieves movie titles and directors based on Donald Duck characters instead of movies with Donald Duck as main character."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, d.director_name \nFROM movies m \nJOIN directors d ON m.director_id = d.director_id \nWHERE m.main_character = 'Donald Duck';",
            "SELECT T1.movie_title, T2.director\nFROM characters AS T1\nJOIN director AS T2 ON T1.movie_title = T2.name\nWHERE T1.hero = 'Donald Duck'"
        ],
        "rule_sql": []
    },
    "5598": {
        "db_id": "shipping",
        "question": "Show the population of the city which was the destination of shipment no.1398.",
        "ground_truth": "SELECT T2.population FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T1.ship_id = '1398'",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `shipment AS T1` with `city AS T2` on `T1.city_id = T2.city_id` instead of using a subquery. Do select `T2.population` instead of just `population`. Do filter on `T1.ship_id = '1398'` instead of using a subquery with `shipment_id = 1398`. Do use string literal `'1398'` instead of numeric 1398. The amended query now correctly retrieves population data through a proper join relationship between shipment and city tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM cities WHERE city_id = (SELECT destination_city FROM shipments WHERE shipment_id = 1398);",
            "SELECT T2.population \nFROM shipment AS T1 \nJOIN city AS T2 ON T1.city_id = T2.city_id \nWHERE T1.ship_id = '1398'"
        ],
        "rule_sql": []
    },
    "5082": {
        "db_id": "address",
        "question": "What is the total number of households in Arecibo county?",
        "ground_truth": "SELECT SUM(T1.households) FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'ARECIBO'",
        "amends": [
            "Do use `SUM(T1.households)` instead of `COUNT(*)` to aggregate actual household counts rather than counting rows. Do join `zip_data AS T1` with `country AS T2` instead of querying `households` table directly to access the correct data structure. Do use `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of no join to properly relate zip code data with county information. Do filter on `T2.county = 'ARECIBO'` instead of `county = 'Arecibo'` to use the correct table reference and uppercase county name format. The amended query now correctly sums household counts from zip data filtered by county rather than counting rows from an incorrect table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM households WHERE county = 'Arecibo';",
            "SELECT SUM(T1.households) AS total_households\nFROM zip_data AS T1\nINNER JOIN country AS T2 ON T1.zip_code = T2.zip_code\nWHERE T2.county = 'ARECIBO'"
        ],
        "rule_sql": []
    },
    "9195": {
        "db_id": "movie_3",
        "question": "Among the classic movies, how many movies have a rental rate of less than 1?",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T3.rental_rate < 1 AND T2.name = 'Classics'",
        "amends": [
            "Do use explicit table joins with `film_category AS T1 INNER JOIN category AS T2` and `INNER JOIN film AS T3` instead of querying a single non-existent `movies` table. Do reference the correct category name column `T2.name = 'Classics'` instead of `category = 'Classic'` with incorrect spelling. Do filter on `T3.rental_rate < 1` instead of `rental_rate > 1` with the wrong comparison operator. Do count specific film IDs with `COUNT(T1.film_id)` instead of `COUNT(*)` for more precise aggregation. The amended query now correctly joins the three required tables, uses proper column references, and implements the intended filtering logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE category = 'Classic' AND rental_rate > 1;",
            "SELECT COUNT(T1.film_id) \nFROM film_category AS T1 \nINNER JOIN category AS T2 ON T1.category_id = T2.category_id \nINNER JOIN film AS T3 ON T1.film_id = T3.film_id \nWHERE T2.name = 'Classics' AND T3.rental_rate < 1"
        ],
        "rule_sql": []
    },
    "992": {
        "db_id": "computer_student",
        "question": "Please list the IDs of the advisors of the students who are in the 5th year of their program.",
        "ground_truth": "SELECT T1.p_id_dummy FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.yearsInProgram = 'Year_5'",
        "amends": [
            "Do select `T1.p_id_dummy` instead of `advisor_id`. Do use `FROM advisedBy AS T1 INNER JOIN person AS T2` instead of `FROM students`. Do add join condition `ON T1.p_id = T2.p_id` instead of omitting it. Do filter with `WHERE T2.yearsInProgram = 'Year_5'` instead of `WHERE year = 5`. The amended query now correctly retrieves advisor IDs from the advisedBy table joined with person records, filtering for those in their fifth year of the program."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT advisor_id FROM students WHERE year = 5",
            "SELECT T1.p_id_dummy FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.yearsInProgram = 'Year_5'"
        ],
        "rule_sql": []
    },
    "3550": {
        "db_id": "authors",
        "question": "Write down the author name, affiliation, jounal short name and full name of the paper \"Decreased Saliva Secretion and Down-Regulation of AQP5 in Submandibular Gland in Irradiated Rats\".",
        "ground_truth": "SELECT T2.Name, T2.Affiliation, T3.ShortName, T3.FullName FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE T1.Title = 'Decreased Saliva Secretion and Down-Regulation of AQP5 in Submandibular Gland in Irradiated Rats'",
        "amends": [
            "Do use explicit table aliases `T2.Name`, `T2.Affiliation`, `T3.ShortName`, and `T3.FullName` instead of direct column references without table qualification. Do join `PaperAuthor AS T2` on `T1.Id = T2.PaperId` instead of querying from a single `papers` table. Do add `INNER JOIN Journal AS T3` on `T1.JournalId = T3.Id` instead of omitting the journal table join. Do reference the correct table name `Paper` instead of `papers`. Do use the correct column names `Name` and `Affiliation` from the `PaperAuthor` table instead of `author_name` and `affiliation`. Do use the correct column names `ShortName` and `FullName` from the `Journal` table instead of `journal_short_name` and `journal_full_name`. The amended query now correctly joins the necessary tables to retrieve author and journal information associated with the specified paper title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name, affiliation, journal_short_name, journal_full_name \nFROM papers \nWHERE title = 'Decreased Saliva Secretion and Down-Regulation of AQP5 in Submandibular Gland in Irradiated Rats'",
            "SELECT T2.Name, T2.Affiliation, T3.ShortName, T3.FullName\nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nINNER JOIN Journal AS T3 ON T1.JournalId = T3.Id\nWHERE T1.Title = 'Decreased Saliva Secretion and Down-Regulation of AQP5 in Submandibular Gland in Irradiated Rats'"
        ],
        "rule_sql": []
    },
    "9276": {
        "db_id": "movie_3",
        "question": "Indicate the name of the actors of the films rated as 'Parents Strongly Precautioned' with the highest replacement cost.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.rating = 'PG-13' ORDER BY T3.replacement_cost DESC LIMIT 1",
        "amends": [
            "Do filter on `T3.rating = 'PG-13'` instead of `c.name = 'Parents Strongly Precautioned'`. Do remove the joins to `film_category` and `category` tables instead of including them. Do use table aliases `T1`, `T2`, and `T3` instead of `a`, `fa`, and `f`. The amended query now correctly filters by film rating rather than category name and eliminates unnecessary table joins, matching the RIGHT_SQL's behavior.",
            "Do remove the subquery filter on `replacement_cost` instead of keeping it, and do add `ORDER BY T3.replacement_cost DESC LIMIT 1` instead of ordering by `T1.last_name, T1.first_name` without limiting results. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`, and do add table aliases with `AS` instead of omitting them. The amended query now correctly finds the single actor from PG-13 films with the highest replacement cost instead of potentially returning multiple actors with maximum replacement cost values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.first_name, a.last_name\nFROM actor a\nJOIN film_actor fa ON a.actor_id = fa.actor_id\nJOIN film f ON fa.film_id = f.film_id\nJOIN film_category fc ON f.film_id = fc.film_id\nJOIN category c ON fc.category_id = c.category_id\nWHERE c.name = 'Parents Strongly Precautioned'\nORDER BY f.replacement_cost DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM actor T1\nJOIN film_actor T2 ON T1.actor_id = T2.actor_id\nJOIN film T3 ON T2.film_id = T3.film_id\nWHERE T3.rating = 'PG-13'\nAND T3.replacement_cost = (\n    SELECT MAX(replacement_cost)\n    FROM film\n    WHERE rating = 'PG-13'\n)\nORDER BY T1.last_name, T1.first_name;",
            "SELECT T1.first_name, T1.last_name\nFROM actor AS T1\nINNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film AS T3 ON T2.film_id = T3.film_id\nWHERE T3.rating = 'PG-13'\nORDER BY T3.replacement_cost DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5333": {
        "db_id": "beer_factory",
        "question": "List down the brand names of root beer that gained a 5-star rating from a customer's review in 2013. Calculate the unit profit available to wholesalers for each brand.",
        "ground_truth": "SELECT T1.BrandName, T1.CurrentRetailPrice - T1.WholesaleCost AS result FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T2.StarRating = 5 AND T2.ReviewDate BETWEEN '2013-01-01' AND '2013-12-31'",
        "amends": [
            "Do use `BrandName` and `CurrentRetailPrice - WholesaleCost AS result` instead of `brand_name` and `retail_price - cost AS unit_profit`. Do join `rootbeerbrand AS T1` with `rootbeerreview AS T2` on `T1.BrandID = T2.BrandID` instead of joining `root_beer_products` with `reviews` on `product_id`. Do filter with `T2.StarRating = 5` instead of `rating = 5`. Do use `T2.ReviewDate BETWEEN '2013-01-01' AND '2013-12-31'` for date filtering instead of `YEAR(review_date) = 2013`. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly matches the intended behavior by using proper table relationships and precise date range filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand_name, (retail_price - cost) AS unit_profit\nFROM root_beer_products\nJOIN reviews ON root_beer_products.product_id = reviews.product_id\nWHERE rating = 5 AND YEAR(review_date) = 2013\nORDER BY unit_profit DESC;",
            "SELECT \n    T1.BrandName,\n    T1.CurrentRetailPrice - T1.WholesaleCost AS result\nFROM \n    rootbeerbrand AS T1\nJOIN \n    rootbeerreview AS T2 ON T1.BrandID = T2.BrandID\nWHERE \n    T2.StarRating = 5\n    AND T2.ReviewDate BETWEEN '2013-01-01' AND '2013-12-31'"
        ],
        "rule_sql": []
    },
    "6874": {
        "db_id": "retails",
        "question": "Please list the names of all the suppliers for the part with the highest retail price.",
        "ground_truth": "SELECT T3.s_phone FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T1.p_size DESC LIMIT 1",
        "amends": [
            "Do change the SELECT list to `T3.s_phone` instead of `s.name`. Do change the FROM clause to use `part AS T1` instead of `suppliers s` and add `partsupp AS T2` and `supplier AS T3` instead of just `parts p`. Do change the join structure to `INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey` and `INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey` instead of `JOIN parts p ON s.id = p.supplier_id`. Do change the WHERE filter to `T1.p_name = 'hot spring dodger dim light'` instead of the subquery `p.retail_price = (SELECT MAX(retail_price) FROM parts)`. Do add `ORDER BY T1.p_size DESC LIMIT 1` instead of omitting ordering and limiting. Do remove the subquery and correlation entirely instead of keeping it. The amended query now correctly retrieves the supplier phone for a specific part with proper joins and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name FROM suppliers s JOIN parts p ON s.id = p.supplier_id WHERE p.retail_price = (SELECT MAX(retail_price) FROM parts)",
            "SELECT T3.s_phone \nFROM part AS T1\nINNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey\nINNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey\nWHERE T1.p_name = 'hot spring dodger dim light'\nORDER BY T1.p_size DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1648": {
        "db_id": "car_retails",
        "question": "Which customer ordered 1939 'Chevrolet Deluxe Coupe' at the highest price?",
        "ground_truth": "SELECT t4.customerName FROM products AS t1 INNER JOIN orderdetails AS t2 ON t1.productCode = t2.productCode INNER JOIN orders AS t3 ON t2.orderNumber = t3.orderNumber INNER JOIN customers AS t4 ON t3.customerNumber = t4.customerNumber WHERE t1.productName = '1939 Chevrolet Deluxe Coupe' ORDER BY t2.priceEach DESC LIMIT 1",
        "amends": [
            "Do use `t4.customerName` instead of `customer_name` in the SELECT list. Do join `products AS t1` instead of directly referencing `products`, and add `orderdetails AS t2` as an intermediate table instead of omitting it. Do use `INNER JOIN` with `t1.productCode = t2.productCode` instead of joining directly on `orders.product_id = products.product_id`. Do join `orders AS t3` on `t2.orderNumber = t3.orderNumber` instead of `customers.customer_id = orders.customer_id`. Do join `customers AS t4` on `t3.customerNumber = t4.customerNumber` instead of the previous customer-orders join. Do filter for `t1.productName = '1939 Chevrolet Deluxe Coupe'` instead of `products.product_name = 'Chevrolet Deluxe Coupe' AND orders.year = 1939`. Do order by `t2.priceEach DESC` instead of `orders.price ASC`. The amended query now correctly matches the intended behavior by properly traversing the database schema through orderdetails and using the correct product name filter and sort order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name \nFROM customers \nJOIN orders ON customers.customer_id = orders.customer_id \nJOIN products ON orders.product_id = products.product_id \nWHERE products.product_name = 'Chevrolet Deluxe Coupe' \nAND orders.year = 1939 \nORDER BY orders.price ASC \nLIMIT 1;",
            "SELECT t4.customerName\nFROM products AS t1\nINNER JOIN orderdetails AS t2 ON t1.productCode = t2.productCode\nINNER JOIN orders AS t3 ON t2.orderNumber = t3.orderNumber\nINNER JOIN customers AS t4 ON t3.customerNumber = t4.customerNumber\nWHERE t1.productName = '1939 Chevrolet Deluxe Coupe'\nORDER BY t2.priceEach DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1102": {
        "db_id": "talkingdata",
        "question": "What is the age of the oldest male user of the app?",
        "ground_truth": "SELECT MAX(age) FROM gender_age WHERE gender = 'M'",
        "amends": [
            "Do use table `gender_age` instead of `users` for the data source. Do use aggregate function `MAX(age)` instead of `MIN(age)` to find the maximum age rather than the minimum. Do use filter condition `gender = 'M'` instead of `gender = 'male'` to match the correct gender code format. The amended query now correctly retrieves the maximum age for male individuals from the appropriate table with proper gender filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(age) FROM users WHERE gender = 'male';",
            "SELECT MAX(age) FROM gender_age WHERE gender = 'M';"
        ],
        "rule_sql": []
    },
    "5932": {
        "db_id": "books",
        "question": "How many books were published by Kensington?",
        "ground_truth": "SELECT COUNT(T1.book_id) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Kensington'",
        "amends": [
            "Do join `book` AS `T1` with `publisher` AS `T2` on `T1.publisher_id = T2.publisher_id` instead of querying `books` table directly. Do filter on `T2.publisher_name = 'Kensington'` instead of `publisher = 'Penguin'`. Do count `T1.book_id` instead of `COUNT(*)`. The amended query now correctly counts books by joining with the publisher table and filtering on publisher name rather than relying on a publisher column in the books table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher = 'Penguin'",
            "SELECT COUNT(T1.book_id) \nFROM book AS T1 \nJOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id \nWHERE T2.publisher_name = 'Kensington'"
        ],
        "rule_sql": []
    },
    "8674": {
        "db_id": "chicago_crime",
        "question": "List the case number of the crimes in wards with population below 52000 that have beat greater than the 90% of the average beat of all crimes.",
        "ground_truth": "SELECT COUNT(T1.report_no) FROM Crime AS T1 INNER JOIN Ward AS T2 ON T1.ward_no = T2.ward_no WHERE T2.Population < 52000 AND T1.beat > ( SELECT AVG(T1.beat) * 0.9 FROM Crime AS T1 INNER JOIN Ward AS T2 ON T1.ward_no = T2.ward_no WHERE T2.Population < 52000 )",
        "amends": [
            "Do use `COUNT(T1.report_no)` instead of selecting `case_number` directly. Do join `Crime AS T1` with `Ward AS T2` on `T1.ward_no = T2.ward_no` instead of querying only the `crimes` table. Do filter on `T2.Population < 52000` instead of `ward_population < 52000`. Do keep the beat filter condition but apply it to `T1.beat` instead of just `beat`. Do modify the subquery to also join `Crime AS T1` with `Ward AS T2` on `T1.ward_no = T2.ward_no` and filter on `T2.Population < 52000` instead of using a simple average from the crimes table alone. The amended query now correctly counts crime reports from wards with populations below 52000 where the beat exceeds 90% of the average beat for such wards, matching the intended behavior.",
            "Do select `COUNT(T1.report_no)` instead of `T1.case_number` to count reports rather than list case numbers. Do use `INNER JOIN` instead of `JOIN` for explicit join clarity. Do reference `T1.beat` in the subquery instead of `T3.beat` to maintain correlation with the outer query's table aliases. Do remove the subquery's table aliases `T3` and `T4` and instead reuse `T1` and `T2` to properly correlate the subquery with the outer query's conditions. The amended query now correctly counts crime reports where the beat exceeds 90% of the average beat for crimes in wards with population under 52000, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT case_number \nFROM crimes \nWHERE ward_population < 52000 \nAND beat > (SELECT AVG(beat) * 0.9 FROM crimes);",
            "SELECT T1.case_number\nFROM Crime AS T1\nJOIN Ward AS T2 ON T1.ward_no = T2.ward_no\nWHERE T2.Population < 52000\nAND T1.beat > (\n    SELECT AVG(T3.beat) * 0.9\n    FROM Crime AS T3\n    JOIN Ward AS T4 ON T3.ward_no = T4.ward_no\n    WHERE T4.Population < 52000\n)",
            "SELECT COUNT(T1.report_no)\nFROM Crime AS T1\nINNER JOIN Ward AS T2 ON T1.ward_no = T2.ward_no\nWHERE T2.Population < 52000\nAND T1.beat > (\n    SELECT AVG(T1_inner.beat) * 0.9\n    FROM Crime AS T1_inner\n    INNER JOIN Ward AS T2_inner ON T1_inner.ward_no = T2_inner.ward_no\n    WHERE T2_inner.Population < 52000\n)"
        ],
        "rule_sql": []
    },
    "3444": {
        "db_id": "video_games",
        "question": "List by name all the games released in the year 2010.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id WHERE T3.release_year = '2010'",
        "amends": [
            "Do select `T1.game_name` instead of `name` and change the source table structure. Do add `INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id` and `INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id` instead of querying a single table. Do filter on `T3.release_year = '2010'` instead of `release_year = 2010`, adding proper table qualification and string literal syntax. Do remove `ORDER BY name` instead of keeping it as the ordering is no longer needed. The amended query now correctly joins through the publisher and platform relationships to find games released in 2010, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE release_year = 2010 ORDER BY name;",
            "SELECT T1.game_name\nFROM game AS T1\nINNER JOIN game_publisher AS T2 ON T1.id = T2.game_id\nINNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id\nWHERE T3.release_year = '2010'"
        ],
        "rule_sql": []
    },
    "1537": {
        "db_id": "synthea",
        "question": "What is the care plan for the patient with social security number 999-15-3685?",
        "ground_truth": "SELECT DISTINCT T1.DESCRIPTION FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.ssn = '999-15-3685'",
        "amends": [
            "Do select `T1.DESCRIPTION` instead of `*` and add `DISTINCT` instead of omitting it. Do change the FROM clause to use `careplans AS T1 INNER JOIN patients AS T2` instead of just `patients` and add the join condition `ON T1.PATIENT = T2.patient` instead of omitting it. Do move the filter from `WHERE ssn = '999-15-3685'` to `WHERE T2.ssn = '999-15-3685'` to properly reference the joined table. The amended query now correctly retrieves distinct care plan descriptions for the specified patient instead of all patient columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM patients WHERE ssn = '999-15-3685';",
            "SELECT DISTINCT T1.DESCRIPTION FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.ssn = '999-15-3685'"
        ],
        "rule_sql": []
    },
    "6249": {
        "db_id": "coinmarketcap",
        "question": "Name the coin that has the highest market capitalization for all transactions in 2018.",
        "ground_truth": "SELECT T1.name FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T2.date LIKE '2018%' AND T2.market_cap = ( SELECT MAX(market_cap) FROM historical WHERE STRFTIME('%Y', date) = '2018' )",
        "amends": [
            "Do select `T1.name` from the `coins` table instead of `coin_name` from `transactions`. Do join `historical` as `T2` with an `INNER JOIN` on `T1.id = T2.coin_id` instead of querying a single table. Do filter with `T2.date LIKE '2018%'` instead of `year = 2018`. Do use a subquery to find the maximum market cap with `STRFTIME('%Y', date) = '2018'` instead of simple ordering. Do remove the `ORDER BY market_cap DESC LIMIT 1` clause and instead filter for records where `T2.market_cap` equals the maximum market cap of 2018. The amended query now correctly identifies coins by their maximum market cap in 2018 through proper table relationships and subquery filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coin_name FROM transactions WHERE year = 2018 ORDER BY market_cap DESC LIMIT 1;",
            "SELECT T1.name\nFROM coins T1\nINNER JOIN historical T2 ON T1.id = T2.coin_id\nWHERE T2.date LIKE '2018%'\nAND T2.market_cap = (\n    SELECT MAX(market_cap)\n    FROM historical\n    WHERE date LIKE '2018%'\n)"
        ],
        "rule_sql": []
    },
    "3434": {
        "db_id": "video_games",
        "question": "List the name of all games published by 'Pioneer LDC'.",
        "ground_truth": "SELECT T3.game_name FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T1.publisher_name = 'Pioneer LDC'",
        "amends": [
            "Do use explicit table joins with `INNER JOIN` on `T1.id = T2.publisher_id` and `T2.game_id = T3.id` instead of querying a single table. Do select `T3.game_name` instead of `title` from the appropriate table. Do reference `T1.publisher_name` in the WHERE clause instead of `publisher` from a non-existent column. Do add the necessary table aliases and join conditions instead of omitting the proper table relationships. The amended query now correctly retrieves game names by joining through the publisher relationship structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM games WHERE publisher = 'Pioneer LDC';",
            "SELECT g.game_name \nFROM publisher p\nINNER JOIN game_publisher gp ON p.id = gp.publisher_id\nINNER JOIN game g ON gp.game_id = g.id\nWHERE p.publisher_name = 'Pioneer LDC'"
        ],
        "rule_sql": []
    },
    "8593": {
        "db_id": "chicago_crime",
        "question": "Please list the names of all the neighborhoods in the community area with the most population.",
        "ground_truth": "SELECT T1.neighborhood_name FROM Neighborhood AS T1 INNER JOIN Community_Area AS T2 ON T2.community_area_no = T2.community_area_no ORDER BY T2.population DESC LIMIT 1",
        "amends": [
            "Do select `T1.neighborhood_name` from the `Neighborhood` table instead of `name` from `neighborhoods`. Do join `Community_Area AS T2` using `INNER JOIN` instead of querying a single table. Do use the correct join condition `T1.community_area_no = T2.community_area_no` instead of the incorrect self-reference `T2.community_area_no = T2.community_area_no`. Do order by `T2.population DESC` instead of `population DESC`. The amended query now correctly retrieves the neighborhood name from the joined tables based on population ranking.",
            "Do use the correct join condition `T2.community_area_no = T2.community_area_no` instead of the incorrect `T1.community_area_no = T2.community_area_no` which would create a proper self-join condition rather than joining between different tables. The amended query now correctly matches the RIGHT_SQL's behavior with the fixed join predicate.",
            "Do add `LIMIT 1` to the `ORDER BY` clause instead of omitting it, which ensures only the single highest population result is returned instead of all results ordered by population. The amended query now matches RIGHT_SQL's behavior by limiting to one record."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM neighborhoods ORDER BY population DESC LIMIT 1;",
            "SELECT T1.neighborhood_name \nFROM Neighborhood AS T1\nINNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no\nORDER BY T2.population DESC\nLIMIT 1;",
            "SELECT T1.neighborhood_name \nFROM Neighborhood AS T1\nINNER JOIN Community_Area AS T2 ON T2.community_area_no = T2.community_area_no\nORDER BY T2.population DESC;",
            "SELECT T1.neighborhood_name \nFROM Neighborhood AS T1\nINNER JOIN Community_Area AS T2 ON T2.community_area_no = T2.community_area_no\nORDER BY T2.population DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4266": {
        "db_id": "simpson_episodes",
        "question": "How many recipients of the Primetime Emmy Award category that were born in the USA? Find the percentage of Americans in the total number of the country.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS num , CAST(SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.award_category = 'Primetime Emmy' AND T2.person = 'Dan Castellaneta';",
        "amends": [
            "Do use `SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN country = 'USA' THEN 1 END)` for counting American recipients. Do add explicit `ELSE 0` instead of omitting it in the conditional sum. Do use `CAST(... AS REAL)` instead of implicit `* 100.0` for percentage calculation. Do join `Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person` instead of querying a single table. Do filter on `T2.award_category = 'Primetime Emmy'` instead of `category = 'Primetime Emmy Award'`. Do add additional filter `T2.person = 'Dan Castellaneta'` instead of omitting it. Do reference `T1.birth_country` instead of `country` and use proper table aliases throughout. The amended query now correctly calculates statistics for a specific person's Emmy awards using proper table relationships and filtering.",
            "Do remove the `total_recipients` column and rename `american_recipients` to `num` instead of keeping both columns with their original names. Do change the calculation order to `* 100 / COUNT(*)` instead of `/ COUNT(*) * 100` to ensure proper mathematical precedence. Do remove the `percentage_americans` alias instead of keeping it. The amended query now correctly calculates the percentage with proper operator precedence and matches the RIGHT_SQL's behavior.",
            "Do add explicit column `num` and separate calculation of `CAST(SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)` instead of combining them into a single `percentage` calculation. Do use explicit `CAST` to `REAL` for proper division instead of implicit casting with `100.0`. Do maintain the same `FROM` clause with `INNER JOIN` on `T1.name = T2.person` and identical `WHERE` filters for `T2.award_category = 'Primetime Emmy'` and `T2.person = 'Dan Castellaneta'`. The amended query now correctly separates the count and percentage calculations while maintaining the same join logic and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS total_recipients,\n    COUNT(CASE WHEN country = 'USA' THEN 1 END) AS american_recipients,\n    (COUNT(CASE WHEN country = 'USA' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_americans\nFROM emmy_award_recipients\nWHERE category = 'Primetime Emmy Award';",
            "SELECT \n    SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS american_recipients,\n    COUNT(*) AS total_recipients,\n    CAST(SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS percentage_americans\nFROM \n    Person AS T1 \nINNER JOIN \n    Award AS T2 ON T1.name = T2.person\nWHERE \n    T2.award_category = 'Primetime Emmy'\n    AND T2.person = 'Dan Castellaneta'",
            "SELECT \n    SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS percentage\nFROM \n    Person AS T1 \nINNER JOIN \n    Award AS T2 ON T1.name = T2.person\nWHERE \n    T2.award_category = 'Primetime Emmy' \n    AND T2.person = 'Dan Castellaneta'",
            "SELECT \n    SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS num,\n    CAST(SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM \n    Person AS T1 \n    INNER JOIN Award AS T2 ON T1.name = T2.person \nWHERE \n    T2.award_category = 'Primetime Emmy' \n    AND T2.person = 'Dan Castellaneta'"
        ],
        "rule_sql": []
    },
    "5928": {
        "db_id": "books",
        "question": "Which city does the address id 547 belong to?",
        "ground_truth": "SELECT city FROM address WHERE address_id = 547",
        "amends": [
            "Do reference table `address` instead of `addresses` in the FROM clause while keeping the same SELECT list and WHERE filter unchanged, maintaining the correct table name that matches the actual schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM addresses WHERE address_id = 547;",
            "SELECT city FROM address WHERE address_id = 547"
        ],
        "rule_sql": []
    },
    "7466": {
        "db_id": "works_cycles",
        "question": "Who owns the email address \"regina7@adventure-works.com\"?",
        "ground_truth": "SELECT T2.FirstName, T2.LastName FROM EmailAddress AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.EmailAddress = 'regina7@adventure-works.com'",
        "amends": [
            "Do select specific columns `T2.FirstName` and `T2.LastName` instead of selecting all columns with `*`. Do join from `EmailAddress AS T1` instead of querying only the `users` table. Do use `INNER JOIN` on `Person AS T2` with the predicate `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do filter on `T1.EmailAddress` instead of filtering on `email` column. The amended query now correctly retrieves person information by joining the email address table with the person table using the proper business entity relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM users WHERE email = 'regina7@adventure-works.com';",
            "SELECT T2.FirstName, T2.LastName FROM EmailAddress AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.EmailAddress = 'regina7@adventure-works.com'"
        ],
        "rule_sql": []
    },
    "2726": {
        "db_id": "regional_sales",
        "question": "Among the products with an order quantity of no less than 5 that was shipped in the month of May 2019, what is the name of the product with the lowest net profit?",
        "ground_truth": "SELECT T2.`Product Name` FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T1.`Order Quantity` > 5 AND ShipDate LIKE '5/%/19' ORDER BY REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '') ASC LIMIT 1",
        "amends": [
            "Do select `T2.Product Name` instead of `ProductName`. Do use `INNER JOIN` with `Products AS T2` instead of `JOIN Products p`. Do join on `T2.ProductID = T1._ProductID` instead of `p.ProductID = od.ProductID`. Do use table alias `T1` for `Sales Orders` instead of `Orders o`. Do filter with `T1.Order Quantity > 5` instead of `od.Quantity >= 5`. Do use `ShipDate LIKE '5/%/19'` instead of `o.ShippedDate LIKE '2019-05%'`. Do order by `REPLACE(T1.Unit Price, ',', '') - REPLACE(T1.Unit Cost, ',', '')` instead of `od.UnitPrice * od.Quantity`. The amended query now correctly calculates profit margin for ordering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ProductName \nFROM Products p\nJOIN OrderDetails od ON p.ProductID = od.ProductID\nJOIN Orders o ON od.OrderID = o.OrderID\nWHERE od.Quantity >= 5\nAND o.ShippedDate LIKE '2019-05%'\nORDER BY (od.UnitPrice * od.Quantity) ASC\nLIMIT 1;",
            "SELECT T2.\"Product Name\"\nFROM \"Sales Orders\" AS T1\nINNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE T1.\"Order Quantity\" >= 5\nAND T1.ShipDate LIKE '5/%/19'\nORDER BY (REPLACE(T1.\"Unit Price\", ',', '') - REPLACE(T1.\"Unit Cost\", ',', ''))\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7773": {
        "db_id": "hockey",
        "question": "Among the coaches who taught the teams in 1922's Stanley Cup finals, how many of them are from the USA?",
        "ground_truth": "SELECT COUNT(DISTINCT T3.coachID) FROM Coaches AS T1 INNER JOIN TeamsSC AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.year = 1922 AND T3.birthCountry = 'USA'",
        "amends": [
            "Do use `COUNT(DISTINCT T3.coachID)` instead of `COUNT(*)` to count unique coaches rather than all rows. Do join `TeamsSC AS T2` with conditions `T1.year = T2.year AND T1.tmID = T2.tmID` instead of joining `teams` and `stanley_cup_finals` separately. Do join `Master AS T3` on `T1.coachID = T3.coachID` instead of filtering coaches directly. Do filter on `T2.year = 1922` instead of `scf.year = 1922`. Do filter on `T3.birthCountry = 'USA'` instead of `c.nationality = 'USA'` to use the correct nationality attribute. The amended query now correctly counts distinct American coaches who participated in the 1922 Stanley Cup finals."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM coaches c\nJOIN teams t ON c.team_id = t.team_id\nJOIN stanley_cup_finals scf ON t.team_id = scf.team_id\nWHERE scf.year = 1922\nAND c.nationality = 'USA';",
            "SELECT COUNT(DISTINCT T3.coachID) \nFROM Coaches AS T1\nJOIN TeamsSC AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID\nJOIN Master AS T3 ON T1.coachID = T3.coachID\nWHERE T2.year = 1922 \nAND T3.birthCountry = 'USA'"
        ],
        "rule_sql": []
    },
    "2227": {
        "db_id": "world_development_indicators",
        "question": "Which country has the highest population in largest city for 19 consecutive years starting from 1960? Indicate the region to which the country is located.",
        "ground_truth": "SELECT T2.CountryCode, T2.Region FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IndicatorName = 'Population in largest city' AND T1.Year >= 1960 AND T1.Year < 1980 ORDER BY T2.Region DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` between `Indicators` and `Country` on `CountryCode` instead of joining `countries`, `regions`, and `cities` tables. Do filter on `IndicatorName = 'Population in largest city'` instead of calculating maximum population from cities. Do use `Year >= 1960 AND Year < 1980` instead of `year BETWEEN 1960 AND 1978`. Do select `CountryCode` and `Region` instead of `country` and `region` names. Do remove `GROUP BY` and population-based ordering instead of grouping by country ID and ordering by population. Do order by `Region DESC` instead of population descending. The amended query now correctly filters for population indicator data within the specified year range and returns the appropriate result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name AS country, r.name AS region\nFROM countries c\nJOIN regions r ON c.region_id = r.id\nJOIN cities ct ON c.id = ct.country_id\nWHERE ct.population = (SELECT MAX(population) FROM cities WHERE year BETWEEN 1960 AND 1978)\nAND ct.year BETWEEN 1960 AND 1978\nGROUP BY c.id\nORDER BY ct.population DESC\nLIMIT 1;",
            "SELECT c.CountryCode, c.Region\nFROM Indicators i\nINNER JOIN Country c ON i.CountryCode = c.CountryCode\nWHERE i.IndicatorName = 'Population in largest city'\nAND i.Year >= 1960 AND i.Year < 1980\nORDER BY c.Region DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2017": {
        "db_id": "soccer_2016",
        "question": "How many players played as a captain in season year 2008?",
        "ground_truth": "SELECT COUNT(T1.Player_Id) FROM Player_Match AS T1 INNER JOIN Match AS T2 ON T1.Match_Id = T2.Match_Id INNER JOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id WHERE T3.Role_Desc = 'Captain' AND T2.Match_Date LIKE '2008%'",
        "amends": [
            "Do select `COUNT(T1.Player_Id)` from specific columns instead of `COUNT(*)` from all rows. Do use `Player_Match AS T1` joined with `Match AS T2` on `T1.Match_Id = T2.Match_Id` instead of querying only the `players` table. Do add an additional join to `Rolee AS T3` on `T1.Role_Id = T3.Role_Id` instead of omitting this relationship. Do filter on `T3.Role_Desc = 'Captain'` instead of `captain = 'yes'` to use proper role descriptions. Do filter on `T2.Match_Date LIKE '2008%'` for date-based matching instead of `season_year = 2008` for year filtering. The amended query now correctly counts captains by joining through the proper relationship tables and using date pattern matching for the 2008 season."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE captain = 'yes' AND season_year = 2008;",
            "SELECT COUNT(T1.Player_Id) \nFROM Player_Match AS T1\nJOIN Match AS T2 ON T1.Match_Id = T2.Match_Id\nJOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id\nWHERE T3.Role_Desc = 'Captain'\nAND T2.Match_Date LIKE '2008%'"
        ],
        "rule_sql": []
    },
    "5263": {
        "db_id": "beer_factory",
        "question": "For the root beer brand which got the review with the content of \"The quintessential dessert root beer. No ice cream required.\", what is the current retail price of the root beer?",
        "ground_truth": "SELECT T1.CurrentRetailPrice - T1.WholesaleCost AS price FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T2.Review = 'The quintessential dessert root beer. No ice cream required.'",
        "amends": [
            "Do select `T1.CurrentRetailPrice - T1.WholesaleCost AS price` instead of just `retail_price`. Do use `FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2` instead of `FROM root_beers`. Do join on `T1.BrandID = T2.BrandID` instead of no join condition. Do filter with `WHERE T2.Review =` instead of `WHERE review_content =`. The amended query now correctly calculates price difference and joins related tables to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT retail_price FROM root_beers WHERE review_content = 'The quintessential dessert root beer. No ice cream required.'",
            "SELECT T1.CurrentRetailPrice - T1.WholesaleCost AS price\nFROM rootbeerbrand AS T1 \nINNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID\nWHERE T2.Review = 'The quintessential dessert root beer. No ice cream required.'"
        ],
        "rule_sql": []
    },
    "8795": {
        "db_id": "food_inspection",
        "question": "Which business had the lowest score for the unscheduled routine inspection on 2016/9/26? Give the name of the business.",
        "ground_truth": "SELECT T2.name FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE score = ( SELECT MIN(score) FROM inspections WHERE `date` = '2016-09-26' AND type = 'Routine - Unscheduled' ) AND T1.`date` = '2016-09-26' AND T1.type = 'Routine - Unscheduled'",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` directly from businesses. Do join `inspections AS T1` with `businesses AS T2` on `T1.business_id = T2.business_id` instead of querying businesses alone. Do move the `WHERE` clause before `ORDER BY` instead of after it. Do filter by `score = (SELECT MIN(score)...` subquery instead of ordering by score with limit. Do use exact date and type values `'2016-09-26'` and `'Routine - Unscheduled'` instead of `'2016-09-26'` and `'unscheduled routine inspection'`. Do reference table aliases `T1.date` and `T1.type` instead of unqualified columns. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the subquery handles finding the minimum score. The amended query now correctly identifies businesses with the minimum inspection score on the specified date and type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses ORDER BY score DESC LIMIT 1 WHERE inspection_date = '2016-09-26' AND inspection_type = 'unscheduled routine inspection';",
            "SELECT T2.name\nFROM inspections AS T1\nJOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T1.date = '2016-09-26' \nAND T1.type = 'Routine - Unscheduled'\nAND T1.score = (SELECT MIN(score) FROM inspections WHERE date = '2016-09-26' AND type = 'Routine - Unscheduled')"
        ],
        "rule_sql": []
    },
    "1829": {
        "db_id": "soccer_2016",
        "question": "How many Orange Cap awards were won by CH Gayle?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.Player_Name = 'CH Gayle' THEN 1 ELSE 0 END) AS cnt FROM Player AS T1 INNER JOIN Season AS T2 ON T1.Player_Id = T2.Orange_Cap",
        "amends": [
            "Do reference the `Player` table as `T1` and join with `Season` as `T2` on `T1.Player_Id = T2.Orange_Cap` instead of querying `orange_cap_awards` directly. Do use `SUM(CASE WHEN T1.Player_Name = 'CH Gayle' THEN 1 ELSE 0 END)` with alias `cnt` instead of `COUNT(*)` to count only specific player occurrences. Do add the `INNER JOIN` relationship between player and season tables instead of omitting the join logic. The amended query now correctly counts occurrences of 'CH Gayle' as orange cap winner through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orange_cap_awards WHERE player_name = 'CH Gayle';",
            "SELECT SUM(CASE WHEN T1.Player_Name = 'CH Gayle' THEN 1 ELSE 0 END) AS cnt\nFROM Player T1\nINNER JOIN Season T2 ON T1.Player_Id = T2.Orange_Cap;"
        ],
        "rule_sql": []
    },
    "6833": {
        "db_id": "retails",
        "question": "What are the clerks of orders with line items shipped by mail?",
        "ground_truth": "SELECT T1.o_clerk FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T2.l_shipmode = 'MAIL'",
        "amends": [
            "Do add `INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey` instead of querying only the `orders` table. Do change the column reference to `T1.o_clerk` instead of just `clerk` and add table alias `T1` to the `orders` table. Do move the filter condition to `T2.l_shipmode = 'MAIL'` instead of `ship_mode = 'mail'` on the orders table, and change the case to uppercase 'MAIL' instead of lowercase 'mail'. The amended query now correctly joins orders with lineitem to filter on the ship mode from the lineitem table and returns the clerk from orders, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT clerk FROM orders WHERE ship_mode = 'mail'",
            "SELECT DISTINCT T1.o_clerk\nFROM orders AS T1\nINNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey\nWHERE T2.l_shipmode = 'MAIL'"
        ],
        "rule_sql": []
    },
    "454": {
        "db_id": "movies_4",
        "question": "How many horror movies are there?",
        "ground_truth": "SELECT COUNT(T1.movie_id) FROM movie_genres AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.genre_id WHERE T2.genre_name = 'Horror'",
        "amends": [
            "Do `COUNT(T1.movie_id)` instead of `COUNT(*)` to count specific movie IDs rather than all rows. Do join `movie_genres AS T1` and `genre AS T2` with `INNER JOIN` on `T1.genre_id = T2.genre_id` instead of querying a single `movies` table. Do filter on `T2.genre_name = 'Horror'` instead of `genre = 'comedy'` to correctly reference the genre name from the joined table and target horror movies rather than comedy. The amended query now properly counts horror movies by joining the movie_genres and genre tables with the correct relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE genre = 'comedy';",
            "SELECT COUNT(T1.movie_id) FROM movie_genres AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.genre_id WHERE T2.genre_name = 'Horror'"
        ],
        "rule_sql": []
    },
    "7911": {
        "db_id": "world",
        "question": "How many cities are there in the country with the surface area of 652090?",
        "ground_truth": "SELECT T2.Name, COUNT(T1.Name) FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.SurfaceArea = 652090 GROUP BY T2.Name",
        "amends": [
            "Do add `T2.Name` and `COUNT(T1.Name)` to the SELECT list instead of only `COUNT(*)`. Do add `FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code` instead of only `FROM city`. Do change the WHERE filter to `T2.SurfaceArea = 652090` instead of `surface_area = 652090`. Do add `GROUP BY T2.Name` instead of omitting grouping. The amended query now correctly joins the City and Country tables, filters on the country's surface area rather than the city's, and groups the count of cities by country name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM city WHERE surface_area = 652090;",
            "SELECT T2.Name, COUNT(T1.Name) \nFROM City AS T1 \nINNER JOIN Country AS T2 ON T1.CountryCode = T2.Code \nWHERE T2.SurfaceArea = 652090 \nGROUP BY T2.Name"
        ],
        "rule_sql": []
    },
    "9386": {
        "db_id": "movie_3",
        "question": "How many titles did Mary Smith rent in 2005? Determine the percentage of titles rented in June 2005.",
        "ground_truth": "SELECT COUNT(T2.rental_id) , CAST(SUM(IIF(STRFTIME('%m',T2.rental_date) = '7', 1, 0)) AS REAL) * 100 / COUNT(T2.rental_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'Maria' AND T1.last_name = 'Miller' AND STRFTIME('%Y',T2.rental_date) = '2005'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS total_titles,\n    (SELECT COUNT(*) FROM rental r \n     JOIN customer c ON r.customer_id = c.customer_id \n     JOIN inventory i ON r.inventory_id = i.inventory_id \n     JOIN film f ON i.film_id = f.film_id \n     WHERE c.first_name = 'Mary' AND c.last_name = 'Smith' \n     AND strftime('%Y-%m', r.rental_date) = '2005-06') * 100.0 / COUNT(*) AS june_percentage\nFROM rental r\nJOIN customer c ON r.customer_id = c.customer_id\nJOIN inventory i ON r.inventory_id = i.inventory_id\nJOIN film f ON i.film_id = f.film_id\nWHERE c.first_name = 'Mary' AND c.last_name = 'Smith'\nAND strftime('%Y', r.rental_date) = '2005';"
        ],
        "rule_sql": []
    },
    "6980": {
        "db_id": "ice_hockey_draft",
        "question": "Who is the oldest player who played for Avangard Omsk during the regular season in 2000-2001?",
        "ground_truth": "SELECT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '2000-2001' AND T1.GAMETYPE = 'Regular Season' AND T1.TEAM = 'Avangard Omsk' ORDER BY T2.birthdate ASC LIMIT 1",
        "amends": [
            "Do select `T2.PlayerName` instead of `name, MAX(age)` and remove the aggregate function. Do use `FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID` instead of `FROM players` with different table names and join condition. Do change the filter `T1.TEAM = 'Avangard Omsk'` instead of `team = 'Avangard Omsk'` with proper table qualification. Do use `T1.SEASON = '2000-2001'` instead of `season = '2000-2001'` with proper table qualification. Do change `T1.GAMETYPE = 'Regular Season'` instead of `game_type = 'regular'` with different value format. Do add `ORDER BY T2.birthdate ASC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the youngest player from the specified team and season using proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, MAX(age) FROM players WHERE team = 'Avangard Omsk' AND season = '2000-2001' AND game_type = 'regular';",
            "SELECT T2.PlayerName\nFROM SeasonStatus AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE T1.TEAM = 'Avangard Omsk'\nAND T1.SEASON = '2000-2001'\nAND T1.GAMETYPE = 'Regular Season'\nORDER BY T2.birthdate ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2852": {
        "db_id": "professional_basketball",
        "question": "From 1950 to 1970, what is the maximum point of players whose teams were ranked 1?",
        "ground_truth": "SELECT MAX(T2.points) FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year BETWEEN 1950 AND 1970 AND T1.rank = 1",
        "amends": [
            "Do join `teams AS T1` and `players_teams AS T2` with `INNER JOIN` on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of querying only `players` table. Do filter on `T1.rank = 1` instead of `team_rank = 1`. Do reference `MAX(T2.points)` from the joined table instead of `MAX(points)` from a single table. Do include the year filter on `T1.year BETWEEN 1950 AND 1970` instead of applying it to the wrong table context. The amended query now correctly calculates maximum points for players on first-ranked teams within the specified years by properly joining team ranking data with player statistics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(points) FROM players WHERE team_rank = 1 AND year BETWEEN 1950 AND 1970;",
            "SELECT MAX(T2.points) AS max_points\nFROM teams AS T1\nINNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.year BETWEEN 1950 AND 1970\nAND T1.rank = 1;"
        ],
        "rule_sql": []
    },
    "1293": {
        "db_id": "law_episode",
        "question": "Who is the youngest person to ever play a \"clerk\" role in the series?",
        "ground_truth": "SELECT T2.name FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T1.role = 'Clerk' AND T2.birthdate IS NOT NULL ORDER BY T2.birthdate LIMIT 1",
        "amends": [
            "Do select `T2.name` instead of `name, MIN(age)` and remove the aggregate function. Do use `FROM Credit AS T1 INNER JOIN Person AS T2` instead of `FROM actors` with proper table aliases and join specification. Do change the join condition to `ON T2.person_id = T1.person_id` instead of no join condition. Do change the WHERE filter to `T1.role = 'Clerk'` with proper table reference and case sensitivity instead of `role = 'clerk'`. Do add `AND T2.birthdate IS NOT NULL` instead of omitting the NULL check. Do change ORDER BY to `T2.birthdate` instead of `age ASC` and remove the GROUP BY clause entirely. Do maintain `LIMIT 1` but with the corrected logic. The amended query now correctly retrieves the youngest clerk with a valid birthdate using proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, MIN(age) FROM actors WHERE role = 'clerk' GROUP BY name ORDER BY age ASC LIMIT 1;",
            "SELECT T2.name\nFROM Credit AS T1\nINNER JOIN Person AS T2 ON T2.person_id = T1.person_id\nWHERE T1.role = 'Clerk'\nAND T2.birthdate IS NOT NULL\nORDER BY T2.birthdate DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7689": {
        "db_id": "hockey",
        "question": "Did legendsID \"P194502\" personally attend his Hall of Fame dedication?",
        "ground_truth": "SELECT IIF(T1.note = 'posthumous', 'YES', 'NO') FROM AwardsMisc AS T1 RIGHT JOIN Master AS T2 ON T1.ID = T2.playerID WHERE T2.legendsID = 'P194502'",
        "amends": [
            "Do select `IIF(T1.note = 'posthumous', 'YES', 'NO')` instead of `*` from all columns. Do change the FROM clause to use `AwardsMisc AS T1 RIGHT JOIN Master AS T2` instead of just `legends`. Do add the join condition `ON T1.ID = T2.playerID` instead of omitting it. Do move the filter to `WHERE T2.legendsID = 'P194502'` instead of `WHERE legendsID = 'P194502' AND hall_of_fame_dedication = 'attended'`. Do remove the `hall_of_fame_dedication` filter instead of keeping it. The amended query now correctly retrieves posthumous award status through a right join between AwardsMisc and Master tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM legends WHERE legendsID = 'P194502' AND hall_of_fame_dedication = 'attended';",
            "SELECT IIF(T1.note = 'posthumous', 'YES', 'NO') \nFROM AwardsMisc AS T1 \nRIGHT JOIN Master AS T2 ON T1.ID = T2.playerID \nWHERE T2.legendsID = 'P194502'"
        ],
        "rule_sql": []
    },
    "4468": {
        "db_id": "student_loan",
        "question": "Among the unemployed students, how many of them have no payment due?",
        "ground_truth": "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE T2.bool = 'neg'",
        "amends": [
            "Do select `COUNT(T1.name)` from a specific column instead of `COUNT(*)` from all rows. Do use `FROM unemployed AS T1 INNER JOIN no_payment_due AS T2` with explicit table aliases and join instead of `FROM students` with a single table. Do specify the join condition `ON T1.name = T2.name` instead of filtering with separate WHERE conditions. Do add the filter `WHERE T2.bool = 'neg'` instead of filtering for `payment_due IS NULL` and `employment_status = 'unemployed'` directly. The amended query now correctly joins the specialized unemployed and no_payment_due tables with proper correlation and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed' AND payment_due IS NULL;",
            "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE T2.bool = 'neg'"
        ],
        "rule_sql": []
    },
    "4210": {
        "db_id": "simpson_episodes",
        "question": "In \"No Loan Again, Naturally\", how many stars received votes of no more than 50?",
        "ground_truth": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.title = 'No Loan Again, Naturally' AND T2.votes < 50;",
        "amends": [
            "Do query from `Episode AS T1` and `Vote AS T2` instead of the incorrect `stars` table. Do use `INNER JOIN` on `T2.episode_id = T1.episode_id` instead of missing the join entirely. Do filter on `T1.title = 'No Loan Again, Naturally'` instead of the incorrect `movie_title` column. Do use `T2.votes < 50` instead of `votes <= 50` to properly exclude the 50-vote threshold. The amended query now correctly counts episodes with the specified title having fewer than 50 votes by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stars WHERE movie_title = 'No Loan Again, Naturally' AND votes <= 50;",
            "SELECT COUNT(*) \nFROM Episode AS T1 \nINNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id \nWHERE T1.title = 'No Loan Again, Naturally' \nAND T2.votes < 50"
        ],
        "rule_sql": []
    },
    "6775": {
        "db_id": "retails",
        "question": "Calculate the difference in the average retail price of parts shipped via ship and air.",
        "ground_truth": "SELECT (CAST(SUM(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)) AS REAL) / SUM(IIF(T3.l_shipmode = 'SHIP', 1, 0))) - (CAST(SUM(IIF(T3.l_shipmode = 'AIR', T1.p_retailprice, 0)) AS REAL) / SUM(IIF(T3.l_shipmode = 'AIR', 1, 0))) FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_suppkey = T3.l_suppkey",
        "amends": [
            "Do use conditional aggregation with `IIF` functions to calculate separate averages for different ship modes instead of subtracting two identical `AVG` calls. Do join through `partsupp` table using `T2.ps_suppkey = T3.l_suppkey` instead of directly joining `parts` to `lineitem` on `p.partkey = l.partkey`. Do filter by `l_shipmode` values 'SHIP' and 'AIR' within the conditional expressions instead of using `WHERE` clause with `o.shippriority`. Do remove the `orders` table join entirely instead of including it. Do add explicit `CAST` to `REAL` for division operations instead of relying on implicit casting. Do use table aliases `T1`, `T2`, `T3` consistently instead of single-letter aliases. The amended query now correctly calculates the difference between average retail prices for SHIP vs AIR shipment modes by properly handling the conditional averages through partsupp relationship.",
            "Do calculate averages using explicit `SUM(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)) / SUM(IIF(T3.l_shipmode = 'SHIP', 1, 0))` instead of `AVG(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, NULL))` to properly handle conditional averaging. Do remove the `T2.ps_partkey = T3.l_partkey` join condition from the `INNER JOIN` between `partsupp` and `lineitem` instead of including it. Do remove the `WHERE T3.l_shipmode IN ('SHIP', 'AIR')` filter instead of keeping it since the conditional logic in the IIF expressions already handles the shipmode filtering. The amended query now correctly calculates separate averages for SHIP and AIR modes without the unnecessary join condition and filter, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(p.retailprice) - AVG(p.retailprice) \nFROM parts p\nJOIN lineitem l ON p.partkey = l.partkey\nJOIN orders o ON l.orderkey = o.orderkey\nWHERE o.shippriority = 'SHIP' OR o.shippriority = 'AIR';",
            "SELECT \n    CAST(AVG(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, NULL)) AS REAL) - \n    CAST(AVG(IIF(T3.l_shipmode = 'AIR', T1.p_retailprice, NULL)) AS REAL) AS price_difference\nFROM \n    part T1\nJOIN \n    partsupp T2 ON T1.p_partkey = T2.ps_partkey\nJOIN \n    lineitem T3 ON T2.ps_suppkey = T3.l_suppkey AND T2.ps_partkey = T3.l_partkey\nWHERE \n    T3.l_shipmode IN ('SHIP', 'AIR')",
            "SELECT \n    (SUM(IIF(T3.l_shipmode = 'SHIP', T1.p_retailprice, 0)) / CAST(SUM(IIF(T3.l_shipmode = 'SHIP', 1, 0)) AS REAL)) - \n    (SUM(IIF(T3.l_shipmode = 'AIR', T1.p_retailprice, 0)) / CAST(SUM(IIF(T3.l_shipmode = 'AIR', 1, 0)) AS REAL)) AS price_difference\nFROM \n    part T1\nINNER JOIN \n    partsupp T2 ON T1.p_partkey = T2.ps_partkey\nINNER JOIN \n    lineitem T3 ON T2.ps_suppkey = T3.l_suppkey"
        ],
        "rule_sql": []
    },
    "3828": {
        "db_id": "public_review_platform",
        "question": "Please state any three business numbers in AZ state that have received the \"Great experience\" review stars.",
        "ground_truth": "SELECT DISTINCT T2.business_id FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T2.state LIKE 'AZ' AND T1.review_stars = 5 LIMIT 3",
        "amends": [
            "Do join `Business` table instead of querying only `reviews` table. Do use `INNER JOIN` on `business_id` instead of no join. Do reference `T2.business_id` in SELECT instead of just `business_id`. Do add `DISTINCT` instead of returning duplicates. Do filter on `T2.state LIKE 'AZ'` instead of `state = 'AZ'` to handle potential variations. Do filter on `T1.review_stars = 5` instead of `stars = 'Great experience'` to use numeric comparison rather than text. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins business data and uses appropriate numeric filtering for star ratings."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM reviews WHERE state = 'AZ' AND stars = 'Great experience' LIMIT 3;",
            "SELECT DISTINCT T2.business_id\nFROM Reviews T1\nINNER JOIN Business T2 ON T1.business_id = T2.business_id\nWHERE T2.state LIKE 'AZ' AND T1.review_stars = 5\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "1181": {
        "db_id": "talkingdata",
        "question": "Between device ID of \"-9215352913819630000\" and \"-9222956879900150000\", mention the age and gender of device user who participated more events.",
        "ground_truth": "SELECT T.age, T.gender FROM ( SELECT T2.age, T2.gender, COUNT(T1.device_id) AS num FROM events AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T1.device_id BETWEEN -9215352913819630000 AND -9222956879900150000 GROUP BY T2.age, T2.gender ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do add a subquery with `INNER JOIN` on `gender_age` table with join condition `T1.device_id = T2.device_id` instead of querying only the `events` table. Do change the WHERE filter to use `BETWEEN` range condition for device IDs instead of OR conditions with specific values. Do add aggregate function `COUNT(T1.device_id)` with alias `num` instead of counting all rows with `COUNT(*)`. Do group by `T2.age, T2.gender` instead of grouping by `device_id`. Do move the ordering to use the computed count alias `T.num` instead of the raw count. Do select from the derived table `T` with explicit table aliases `T.age, T.gender` instead of direct column references. The amended query now correctly joins demographic data and counts events per age-gender combination to find the most frequent demographic profile within the specified device ID range.",
            "Do reverse the `BETWEEN` range to `-9215352913819630000 AND -9222956879900150000` instead of `-9222956879900150000 AND -9215352913819630000` to ensure proper numeric ordering. Do maintain the same `SELECT` list with `T.age, T.gender`, `FROM` sources with `events AS T1` and `gender_age AS T2`, `INNER JOIN` on `T1.device_id = T2.device_id`, `GROUP BY T2.age, T2.gender`, `ORDER BY T.num DESC`, and `LIMIT 1` structure. The amended query now correctly filters the device_id range and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age, gender FROM events WHERE device_id = '-9215352913819630000' OR device_id = '-9222956879900150000' GROUP BY device_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T.age, T.gender\nFROM (\n    SELECT T2.age, T2.gender, COUNT(T1.device_id) AS num\n    FROM events T1\n    INNER JOIN gender_age T2 ON T1.device_id = T2.device_id\n    WHERE T1.device_id BETWEEN -9222956879900150000 AND -9215352913819630000\n    GROUP BY T2.age, T2.gender\n) T\nORDER BY T.num DESC\nLIMIT 1",
            "SELECT T.age, T.gender\nFROM (\n    SELECT T2.age, T2.gender, COUNT(T1.device_id) AS num\n    FROM events AS T1\n    INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id\n    WHERE T1.device_id BETWEEN -9215352913819630000 AND -9222956879900150000\n    GROUP BY T2.age, T2.gender\n) AS T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6228": {
        "db_id": "food_inspection_2",
        "question": "Provide the last name of the employee involved in the inspection ID 52256.",
        "ground_truth": "SELECT DISTINCT T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_id = 52256",
        "amends": [
            "Do select `T1.last_name` instead of `first_name` and add `DISTINCT` instead of omitting it. Do add `INNER JOIN inspection AS T2` instead of querying only the employees table, with join condition `ON T1.employee_id = T2.employee_id` instead of no join. Do keep the filter `WHERE T2.inspection_id = 52256` but apply it to the joined inspection table instead of the employees table directly. The amended query now correctly retrieves distinct last names by joining the relevant tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE inspection_id = 52256;",
            "SELECT DISTINCT T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_id = 52256"
        ],
        "rule_sql": []
    },
    "4273": {
        "db_id": "simpson_episodes",
        "question": "What are the top five most popular episodes?",
        "ground_truth": "SELECT episode_id FROM Episode ORDER BY votes DESC LIMIT 5;",
        "amends": [
            "Do select `episode_id` instead of `episode_name` and `COUNT(*) as view_count`. Do remove the `COUNT(*)` aggregate and `GROUP BY episode_name` instead of keeping them. Do change the source table to `Episode` instead of `episodes`. Do change the ordering to `votes DESC` instead of `view_count DESC`. Do remove the alias `view_count` instead of keeping it. The amended query now correctly selects episode IDs ordered by vote counts rather than counting views by episode name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_name, COUNT(*) as view_count FROM episodes GROUP BY episode_name ORDER BY view_count DESC LIMIT 5;",
            "SELECT episode_id FROM Episode ORDER BY votes DESC LIMIT 5"
        ],
        "rule_sql": []
    },
    "8585": {
        "db_id": "chicago_crime",
        "question": "How many community areas are there in Central Chicago?",
        "ground_truth": "SELECT COUNT(*) FROM Community_Area WHERE side = 'Central'",
        "amends": [
            "Do reference the table as `Community_Area` instead of `community_areas`. Do filter on the column `side` with value `'Central'` instead of filtering on `region` with value `'Central Chicago'`. The amended query now correctly counts records from the Community_Area table where the side is Central, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM community_areas WHERE region = 'Central Chicago';",
            "SELECT COUNT(*) FROM Community_Area WHERE side = 'Central';"
        ],
        "rule_sql": []
    },
    "5331": {
        "db_id": "beer_factory",
        "question": "What is the precise coordinate of Sac State Union?",
        "ground_truth": "SELECT T2.Latitude, T2.Longitude FROM location AS T1 INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE T1.LocationName = 'Sac State Union'",
        "amends": [
            "Do select `T2.Latitude` and `T2.Longitude` from the `geolocation` table instead of `latitude` and `longitude` from the `buildings` table. Do join `location AS T1` with `geolocation AS T2` using `INNER JOIN` on `T1.LocationID = T2.LocationID` instead of querying only the `buildings` table. Do filter on `T1.LocationName = 'Sac State Union'` instead of `name = 'Sac State Union'` to correctly reference the location name column. The amended query now properly retrieves geolocation data through table relationships instead of assuming all data exists in a single table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude, longitude FROM buildings WHERE name = 'Sac State Union';",
            "SELECT T2.Latitude, T2.Longitude \nFROM location AS T1 \nINNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID \nWHERE T1.LocationName = 'Sac State Union'"
        ],
        "rule_sql": []
    },
    "3795": {
        "db_id": "public_review_platform",
        "question": "List the names of business in AZ with a rating of 5.",
        "ground_truth": "SELECT business_id FROM Business WHERE state LIKE 'AZ' AND stars = 5",
        "amends": [
            "Do select `business_id` instead of `name` and use table `Business` instead of `businesses`. Do use filter `stars = 5` instead of `rating = 5` and maintain the `state LIKE 'AZ'` condition instead of `state = 'AZ'`. The amended query now correctly retrieves business identifiers with five-star ratings in Arizona, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE state = 'AZ' AND rating = 5;",
            "SELECT business_id FROM Business WHERE state LIKE 'AZ' AND stars = 5"
        ],
        "rule_sql": []
    },
    "5077": {
        "db_id": "olympics",
        "question": "How many female competitors were from Iran?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Iran' AND T3.gender = 'F'",
        "amends": [
            "Do use explicit table joins with `noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id` instead of querying a single `competitors` table. Do filter by `T1.region_name = 'Iran'` instead of `country = 'Iran'` and `T3.gender = 'F'` instead of `gender = 'Male'`. Do count specific column `COUNT(T2.person_id)` instead of `COUNT(*)` to avoid counting null values. The amended query now correctly joins the necessary tables to establish the proper relationships between regions and persons, ensuring accurate counting of female individuals from Iran."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM competitors WHERE country = 'Iran' AND gender = 'Male';",
            "SELECT COUNT(T2.person_id) \nFROM noc_region AS T1 \nINNER JOIN person_region AS T2 ON T1.id = T2.region_id \nINNER JOIN person AS T3 ON T2.person_id = T3.id \nWHERE T1.region_name = 'Iran' AND T3.gender = 'F'"
        ],
        "rule_sql": []
    },
    "1195": {
        "db_id": "talkingdata",
        "question": "Among the male users, how many users use device model of Desire 820?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Desire 820' AND T1.gender = 'M'",
        "amends": [
            "Do select `COUNT(T1.device_id)` from the `gender_age` table instead of `COUNT(*)` from the `users` table. Do join `phone_brand_device_model2` as `T2` with an `INNER JOIN` on `T1.device_id = T2.device_id` instead of querying a single table without joins. Do filter on `T2.device_model = 'Desire 820'` and `T1.gender = 'M'` instead of `gender = 'male'` and `device_model = 'Desire 820'` using different column references and gender value representation. The amended query now correctly counts device IDs from the joined tables with proper gender filtering and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE gender = 'male' AND device_model = 'Desire 820';",
            "SELECT COUNT(T1.device_id) \nFROM gender_age T1\nINNER JOIN phone_brand_device_model2 T2 ON T1.device_id = T2.device_id\nWHERE T1.gender = 'M' AND T2.device_model = 'Desire 820'"
        ],
        "rule_sql": []
    },
    "7302": {
        "db_id": "works_cycles",
        "question": "How many products that take more than 2 days to make are out of stock?",
        "ground_truth": "SELECT COUNT(T2.ProductID) FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T1.OnOrderQty IS NULL OR T1.OnOrderQty = 0",
        "amends": [
            "Do select `COUNT(T2.ProductID)` instead of `COUNT(*)` to count specific non-null product IDs rather than all rows. Do use `FROM ProductVendor AS T1 INNER JOIN Product AS T2` instead of `FROM products` to join two tables rather than querying a single table. Do apply join condition `ON T1.ProductID = T2.ProductID` instead of no join condition to properly relate vendor and product data. Do use WHERE filter `T1.OnOrderQty IS NULL OR T1.OnOrderQty = 0` instead of `production_days > 2 AND stock_quantity = 0` to check for missing or zero order quantities rather than production days and stock levels. Do remove the incorrect production days and stock quantity filters entirely instead of keeping them. The amended query now correctly counts products from vendors with no pending orders by joining the appropriate tables and using the proper null/zero quantity check.",
            "Do remove the `T2.DaysToManufacture > 2` filter from the `WHERE` clause instead of keeping it, as the right query only requires checking for `T1.OnOrderQty IS NULL OR T1.OnOrderQty = 0` conditions without the additional manufacturing days constraint. The amended query now matches RIGHT_SQL's behavior by focusing solely on the vendor order quantity conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE production_days > 2 AND stock_quantity = 0;",
            "SELECT COUNT(T2.ProductID) \nFROM ProductVendor AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID \nWHERE T2.DaysToManufacture > 2 \nAND (T1.OnOrderQty IS NULL OR T1.OnOrderQty = 0)",
            "SELECT COUNT(T2.ProductID) \nFROM ProductVendor AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID \nWHERE T1.OnOrderQty IS NULL OR T1.OnOrderQty = 0"
        ],
        "rule_sql": []
    },
    "9222": {
        "db_id": "movie_3",
        "question": "How much percentage of the film did Mary Keitel perform more than Angela Witherspoon?",
        "ground_truth": "SELECT CAST((SUM(IIF(T1.first_name = 'ANGELA' AND T1.last_name = 'WITHERSPOON', 1, 0)) - SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0))) AS REAL) * 100 / SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0)) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` instead of `COUNT(CASE WHEN condition THEN 1 END)` for conditional counting. Do calculate the percentage as `(Angela_count - Mary_count) * 100 / Mary_count` instead of `Mary_count * 100 / Angela_count` to show how much more frequent Angela is than Mary. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of implicit `JOIN` with single-letter aliases. Do cast the result to `REAL` instead of using `100.0` for floating-point division. Do remove the unnecessary join to the `film` table instead of including it. Do use uppercase literal strings `'ANGELA'` and `'WITHERSPOON'` instead of mixed case for case-insensitive matching. The amended query now correctly calculates the percentage difference between the two actor counts and matches the RIGHT_SQL's behavior.",
            "Do use `T1` table for both actor conditions instead of mixing `T1` and `T2` tables. Do remove the unnecessary second `film_actor` join and second `actor` join instead of keeping redundant joins. Do simplify the FROM clause to only `actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id` instead of multiple complex joins. Do change the calculation order to `(SUM(...) - SUM(...)) * 100 / SUM(...)` instead of `(SUM(...) - SUM(...)) * 100 AS REAL / SUM(...)`. Do remove the WHERE clause entirely instead of filtering on specific actor names since the IIF conditions handle the filtering within the aggregates. The amended query now correctly calculates the percentage difference using a single actor table reference and proper join structure, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN a.first_name = 'Mary' AND a.last_name = 'Keitel' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN a.first_name = 'Angela' AND a.last_name = 'Witherspoon' THEN 1 END)) AS percentage_more\nFROM actor a\nJOIN film_actor fa ON a.actor_id = fa.actor_id\nJOIN film f ON fa.film_id = f.film_id;",
            "SELECT CAST((SUM(IIF(T2.first_name = 'ANGELA' AND T2.last_name = 'WITHERSPOON', 1, 0)) - SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0))) * 100 AS REAL) / SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0)) AS percentage_difference\nFROM film_actor fa1\nINNER JOIN actor T1 ON fa1.actor_id = T1.actor_id\nINNER JOIN film_actor fa2 ON fa1.film_id = fa2.film_id\nINNER JOIN actor T2 ON fa2.actor_id = T2.actor_id\nWHERE T1.first_name = 'MARY' AND T1.last_name = 'KEITEL'\nAND T2.first_name = 'ANGELA' AND T2.last_name = 'WITHERSPOON';",
            "SELECT \n    (SUM(IIF(T1.first_name = 'ANGELA' AND T1.last_name = 'WITHERSPOON', 1, 0)) - \n     SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0))) * 100.0 / \n    SUM(IIF(T1.first_name = 'MARY' AND T1.last_name = 'KEITEL', 1, 0)) AS percentage_difference\nFROM \n    actor AS T1 \nINNER JOIN \n    film_actor AS T2 ON T1.actor_id = T2.actor_id;"
        ],
        "rule_sql": []
    },
    "2689": {
        "db_id": "regional_sales",
        "question": "How many different time zones are there in the Northeast region?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.`Time Zone`) FROM Regions AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StateCode = T1.StateCode WHERE T1.Region = 'Northeast'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.\"Time Zone\")` instead of `COUNT(*)` to count distinct time zones rather than all rows. Do join `Regions AS T1` and `\"Store Locations\" AS T2` with `INNER JOIN` on `T2.StateCode = T1.StateCode` instead of querying only the `time_zones` table. Do filter on `T1.Region = 'Northeast'` instead of filtering on a non-existent `region` column in the wrong table. The amended query now correctly counts distinct time zones from store locations in the Northeast region by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM time_zones WHERE region = 'Northeast';",
            "SELECT COUNT(DISTINCT T2.\"Time Zone\") \nFROM Regions AS T1\nINNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode\nWHERE T1.Region = 'Northeast'"
        ],
        "rule_sql": []
    },
    "4642": {
        "db_id": "disney",
        "question": "Who is the voice actor of the hero character from the movie The Little Mermaid?",
        "ground_truth": "SELECT T2.`voice-actor` FROM characters AS T1 INNER JOIN `voice-actors` AS T2 ON T2.movie = T1.movie_title WHERE T1.movie_title = 'The Little Mermaid' AND T2.character = T1.hero",
        "amends": [
            "Do select `T2.voice-actor` instead of `actor_name`. Do use `INNER JOIN` between `characters AS T1` and `voice-actors AS T2` instead of querying only `voice_actors`. Do join on `T2.movie = T1.movie_title` instead of no join condition. Do filter with `T1.movie_title = 'The Little Mermaid'` instead of applying it directly to the voice_actors table. Do add join predicate `T2.character = T1.hero` instead of filtering for `character_type = 'villain'`. The amended query now correctly retrieves voice actors for heroes in the specified movie by properly joining character and voice actor tables with appropriate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM voice_actors WHERE movie_title = 'The Little Mermaid' AND character_type = 'villain';",
            "SELECT T2.\"voice-actor\"\nFROM characters AS T1\nINNER JOIN \"voice-actors\" AS T2 ON T2.movie = T1.movie_title AND T2.character = T1.hero\nWHERE T1.movie_title = 'The Little Mermaid'"
        ],
        "rule_sql": []
    },
    "5525": {
        "db_id": "menu",
        "question": "Among the dishes, how many of them are for free?",
        "ground_truth": "SELECT COUNT(*) FROM Dish WHERE lowest_price = 0",
        "amends": [
            "Do reference table `Dish` instead of `dishes` and filter on column `lowest_price` instead of `price` for the zero value condition, instead of using the incorrect table name and column reference. The amended query now correctly counts records where the lowest price equals zero in the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dishes WHERE price = 0;",
            "SELECT COUNT(*) FROM Dish WHERE lowest_price = 0;"
        ],
        "rule_sql": []
    },
    "8959": {
        "db_id": "human_resources",
        "question": "Give the full address of the office of the highest paid manager.",
        "ground_truth": "SELECT T2.address FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID INNER JOIN position AS T3  ON T3.positionID = T1.positionID WHERE T3.positiontitle = 'Manager' ORDER BY T1.salary DESC LIMIT 1",
        "amends": [
            "Do select `T2.address` from the `location` table instead of `address` from `offices`. Do use `INNER JOIN` between `employee` and `location` on `T1.locationID = T2.locationID` instead of querying `offices` directly. Do add an additional `INNER JOIN` to `position` on `T3.positionID = T1.positionID` instead of filtering by `manager_id`. Do filter with `T3.positiontitle = 'Manager'` in the `WHERE` clause instead of using a subquery to find managers. Do apply `ORDER BY T1.salary DESC LIMIT 1` at the main query level instead of using a subquery with ordering and limiting. The amended query now correctly identifies the highest-paid manager's address by joining through proper relationship tables instead of relying on a potentially incorrect manager_id reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM offices WHERE manager_id = (SELECT id FROM managers ORDER BY salary DESC LIMIT 1);",
            "SELECT T2.address \nFROM employee T1\nINNER JOIN location T2 ON T1.locationID = T2.locationID\nINNER JOIN position T3 ON T1.positionID = T3.positionID\nWHERE T3.positiontitle = 'Manager'\nORDER BY T1.salary DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "9072": {
        "db_id": "bike_share_1",
        "question": "On the day with the hottest temperature ever in 2014, how many bike trips started from the station 2nd at Folsom?",
        "ground_truth": "SELECT COUNT(T1.start_station_name) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.date LIKE '%2014%' AND T2.zip_code = 94107 AND T1.start_station_name = '2nd at Folsom' ORDER BY T2.max_temperature_f DESC LIMIT 1",
        "amends": [
            "Do select `COUNT(T1.start_station_name)` instead of `COUNT(*)`. Do use `trip AS T1` and `weather AS T2` as source tables instead of only `bike_trips`. Do add `INNER JOIN` on `T2.zip_code = T1.zip_code` instead of no join. Do change the WHERE filter to `T2.date LIKE '%2014%'` and `T2.zip_code = 94107` instead of the subquery `date = (SELECT MAX(temperature) FROM weather WHERE year = 2014)`. Do add `ORDER BY T2.max_temperature_f DESC LIMIT 1` instead of omitting ordering and limiting. Do remove the incorrect subquery that compared date to temperature maximum. The amended query now correctly joins trip and weather data, filters by zip code and year pattern, and returns the count for the specified station with proper temperature-based ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM bike_trips \nWHERE start_station = '2nd at Folsom' \nAND date = (SELECT MAX(temperature) FROM weather WHERE year = 2014)",
            "SELECT COUNT(T1.start_station_name) \nFROM trip AS T1\nINNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code\nWHERE T2.date LIKE '%2014%' \nAND T2.zip_code = '94107'\nAND T1.start_station_name = '2nd at Folsom'\nORDER BY T2.max_temperature_f DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "77": {
        "db_id": "movie_platform",
        "question": "Among the users who are trailists when rating the movie \"When Will I Be Loved\", how many of them have rated \"1\" on the movie?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'When Will I Be Loved' AND T1.rating_score = 1 AND T1.user_trialist = 1",
        "amends": [
            "Do count `T1.user_id` instead of `COUNT(*)` to count specific user IDs rather than all rows. Do use table aliases `T1` for `ratings` and `T2` for `movies` instead of `u`, `r`, and `m` for `users`, `ratings`, and `movies`. Do remove the `users` table entirely instead of joining it, as the user status check is now handled through `T1.user_trialist`. Do filter on `T2.movie_title` instead of `m.title` to match the correct column name. Do filter on `T1.rating_score` instead of `r.rating` to use the proper rating column. Do add the condition `T1.user_trialist = 1` instead of checking `u.status = 'trailist'` to directly filter trialist users from the ratings table. The amended query now correctly counts users who gave a 1-star rating to the specified movie while being trialists, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM users u\nJOIN ratings r ON u.user_id = r.user_id\nJOIN movies m ON r.movie_id = m.movie_id\nWHERE u.status = 'trailist' \nAND m.title = 'When Will I Be Loved'\nAND r.rating = 1;",
            "SELECT COUNT(DISTINCT T1.user_id) \nFROM ratings T1\nJOIN movies T2 ON T1.movie_id = T2.movie_id\nWHERE T2.movie_title = 'When Will I Be Loved'\nAND T1.rating_score = 1\nAND T1.user_trialist = 1"
        ],
        "rule_sql": []
    },
    "7134": {
        "db_id": "works_cycles",
        "question": "How much do the works data saved in English and Arabic differ from one another?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.Name = 'English' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END) FROM Culture AS T1 INNER JOIN ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID WHERE T1.Name = 'English' OR T1.Name = 'Arabic'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.Name = 'English' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END)` instead of subtracting separate `COUNT(*)` subqueries. Do join `Culture AS T1` with `ProductModelProductDescriptionCulture AS T2` on `T1.CultureID = T2.CultureID` instead of querying a non-existent `works` table. Do filter with `WHERE T1.Name = 'English' OR T1.Name = 'Arabic'` instead of separate subquery conditions. Do remove the unnecessary subquery structure and instead perform the calculation directly in the main query. The amended query now correctly calculates the difference between English and Arabic culture entries while properly joining the required tables and filtering for the specific cultures."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM works WHERE language = 'English') - \n    (SELECT COUNT(*) FROM works WHERE language = 'Arabic') AS difference",
            "SELECT \n    SUM(CASE WHEN T1.Name = 'English' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.Name = 'Arabic' THEN 1 ELSE 0 END) AS Difference\nFROM \n    Culture AS T1\nJOIN \n    ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID\nWHERE \n    T1.Name = 'English' OR T1.Name = 'Arabic'"
        ],
        "rule_sql": []
    },
    "676": {
        "db_id": "codebase_comments",
        "question": "How many path does the github address \"https://github.com/jeffdik/tachy.git\" have?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.Path) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Url = 'https://github.com/jeffdik/tachy.git'",
        "amends": [
            "Do select `COUNT(DISTINCT T2.Path)` instead of `COUNT(*)` to count distinct paths rather than all rows. Do use `Repo AS T1` and `Solution AS T2` as table sources instead of `github_repositories` alone. Do add `INNER JOIN` on `T1.Id = T2.RepoId` instead of having no join condition. Do filter on `T1.Url` instead of `url` to reference the correct table alias. The amended query now correctly counts distinct solution paths from the joined repository table rather than counting all rows from a single table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM github_repositories WHERE url = 'https://github.com/jeffdik/tachy.git';",
            "SELECT COUNT(DISTINCT T2.Path) \nFROM Repo AS T1 \nINNER JOIN Solution AS T2 ON T1.Id = T2.RepoId \nWHERE T1.Url = 'https://github.com/jeffdik/tachy.git'"
        ],
        "rule_sql": []
    },
    "1864": {
        "db_id": "soccer_2016",
        "question": "Among the players who were born in 1977, provide names and birthdates of the players from England.",
        "ground_truth": "SELECT T2.Player_Name, T2.DOB FROM Country AS T1 INNER JOIN Player AS T2 ON T2.Country_Name = T1.Country_Id WHERE T2.DOB LIKE '1977%' AND T1.Country_Name = 'England'",
        "amends": [
            "Do select `T2.Player_Name` and `T2.DOB` instead of `name` and `birthdate`. Do use `INNER JOIN` between `Country AS T1` and `Player AS T2` on `T2.Country_Name = T1.Country_Id` instead of querying a single table. Do filter with `T2.DOB LIKE '1977%'` instead of `birth_year = 1977` to handle date string matching. Do filter with `T1.Country_Name = 'England'` instead of `country = 'England'` to reference the joined table. The amended query now correctly joins tables and uses proper date filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, birthdate FROM players WHERE birth_year = 1977 AND country = 'England';",
            "SELECT T2.Player_Name, T2.DOB\nFROM Country AS T1\nINNER JOIN Player AS T2 ON T2.Country_Name = T1.Country_Id\nWHERE T2.DOB LIKE '1977%'\nAND T1.Country_Name = 'England'"
        ],
        "rule_sql": []
    },
    "1402": {
        "db_id": "synthea",
        "question": "How many conditions did Tyree Eichmann have?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.DESCRIPTION) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Tyree' AND T1.last = 'Eichmann'",
        "amends": [
            "Do select `COUNT(DISTINCT T2.DESCRIPTION)` instead of `COUNT(*)`. Do add `patients AS T1` as a source table instead of omitting it. Do use `INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT` instead of querying `conditions` alone. Do add filter `T1.first = 'Tyree' AND T1.last = 'Eichmann'` instead of filtering by `patient_name = 'Tyree Eichmann'`. The amended query now correctly counts distinct condition descriptions for the specific patient by joining the patients and conditions tables and using proper name filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM conditions WHERE patient_name = 'Tyree Eichmann';",
            "SELECT COUNT(DISTINCT T2.DESCRIPTION) \nFROM patients AS T1 \nINNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT \nWHERE T1.first = 'Tyree' AND T1.last = 'Eichmann'"
        ],
        "rule_sql": []
    },
    "1725": {
        "db_id": "restaurant",
        "question": "How many restaurants are on Irving Street?",
        "ground_truth": "SELECT COUNT(id_restaurant) FROM location WHERE street_name = 'irving'",
        "amends": [
            "Do reference the `location` table instead of `restaurants` for the data source. Do count `id_restaurant` instead of using `COUNT(*)` to count specific restaurant identifiers. Do filter on `street_name = 'irving'` instead of `street = 'Irving Street'` to match the correct column name and case-insensitive street value. The amended query now correctly counts restaurants located on Irving Street using the appropriate table structure and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE street = 'Irving Street';",
            "SELECT COUNT(id_restaurant) FROM location WHERE street_name = 'irving';"
        ],
        "rule_sql": []
    },
    "2284": {
        "db_id": "movielens",
        "question": "For different directors who direct well, how many of them have directed an action film?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.directorid) FROM movies2directors AS T2 INNER JOIN directors AS T3 ON T2.directorid = T3.directorid WHERE T2.genre = 'Action' AND T3.d_quality = 4",
        "amends": [
            "Do use `T2.directorid` instead of `director` in the SELECT list. Do join `movies2directors AS T2` and `directors AS T3` with `INNER JOIN` on `T2.directorid = T3.directorid` instead of querying only the `movies` table. Do filter on `T2.genre = 'Action'` instead of `genre = 'Action'`. Do replace the subquery checking `AVG(rating) > 8.0` with a direct filter `T3.d_quality = 4` instead of using a correlated subquery. Do remove the DISTINCT modifier from the COUNT function instead of keeping it, as the join condition ensures uniqueness. The amended query now correctly counts directors of action movies with quality rating 4 by leveraging proper table relationships instead of relying on a potentially inefficient subquery.",
            "Do add `DISTINCT` to `COUNT(T2.directorid)` instead of counting duplicate director IDs, which ensures each director is counted only once even if they have multiple Action genre movies with quality rating 4, thus providing the correct count of unique directors rather than the total number of movie-director associations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT director) \nFROM movies \nWHERE genre = 'Action' \nAND director IN (\n    SELECT director \n    FROM movies \n    GROUP BY director \n    HAVING AVG(rating) > 8.0\n);",
            "SELECT COUNT(T2.directorid) \nFROM movies2directors AS T2 \nINNER JOIN directors AS T3 ON T2.directorid = T3.directorid \nWHERE T2.genre = 'Action' AND T3.d_quality = 4",
            "SELECT COUNT(DISTINCT T2.directorid) \nFROM movies2directors AS T2 \nINNER JOIN directors AS T3 ON T2.directorid = T3.directorid \nWHERE T2.genre = 'Action' AND T3.d_quality = 4"
        ],
        "rule_sql": []
    },
    "1731": {
        "db_id": "restaurant",
        "question": "What is the review of the restaurant at 8440 Murray Ave?",
        "ground_truth": "SELECT T2.review FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.street_name = 'murray ave' AND T1.street_num = 8440",
        "amends": [
            "Do select `T2.review` instead of `*` to retrieve only the review column. Do join `location AS T1` and `generalinfo AS T2` instead of querying only `restaurants` to combine data from multiple tables. Do use `INNER JOIN` on `T1.id_restaurant = T2.id_restaurant` instead of no join condition to properly relate the tables. Do filter on `T1.street_name = 'murray ave'` and `T1.street_num = 8440` instead of `address = '8440 Murray Ave'` to match the structured address components separately. The amended query now correctly retrieves reviews by joining location and general info tables with proper address filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM restaurants WHERE address = '8440 Murray Ave';",
            "SELECT T2.review FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.street_name = 'murray ave' AND T1.street_num = 8440"
        ],
        "rule_sql": []
    },
    "9126": {
        "db_id": "movie_3",
        "question": "How many films are there under the category of \"Horror\"?",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id WHERE T2.name = 'Horror'",
        "amends": [
            "Do select `COUNT(T1.film_id)` instead of `COUNT(*)` to count specific film records. Do join `film_category AS T1` and `category AS T2` with `INNER JOIN` on `T1.category_id = T2.category_id` instead of querying a single `films` table. Do filter on `T2.name = 'Horror'` instead of `category = 'Horror'` to use the proper category name field from the joined category table. The amended query now correctly counts horror films by joining the film_category and category tables and filtering on the category name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE category = 'Horror';",
            "SELECT COUNT(T1.film_id) \nFROM film_category AS T1 \nINNER JOIN category AS T2 ON T1.category_id = T2.category_id \nWHERE T2.name = 'Horror'"
        ],
        "rule_sql": []
    },
    "1352": {
        "db_id": "law_episode",
        "question": "Who was the actor who was portraying \"Alex Brown\" and has been credited?",
        "ground_truth": "SELECT T1.name FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.person_id = T2.person_id WHERE T2.role = 'Alex Brown' AND T2.credited = 'true'",
        "amends": [
            "Do use `T1.name` from the `Person` table instead of `actor_name` from a non-existent `actors` table. Do join `Credit AS T2` with `INNER JOIN` on `T1.person_id = T2.person_id` instead of querying a single table. Do filter on `T2.role = 'Alex Brown'` instead of `character_name = 'Alex Brown'` to reference the correct column. Do use `T2.credited = 'true'` with boolean string instead of `credited = 'yes'` to match the expected data format. The amended query now correctly retrieves actor names by joining person and credit tables with proper relationship mapping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE character_name = 'Alex Brown' AND credited = 'yes';",
            "SELECT T1.name \nFROM Person AS T1\nINNER JOIN Credit AS T2 ON T1.person_id = T2.person_id\nWHERE T2.role = 'Alex Brown' AND T2.credited = 'true'"
        ],
        "rule_sql": []
    },
    "7338": {
        "db_id": "works_cycles",
        "question": "What are the differences between the 288th salesperson's predicted annual sales and his or her actual sales thus far?",
        "ground_truth": "SELECT SalesYTD - SalesQuota FROM SalesPerson WHERE BusinessEntityID = 288",
        "amends": [
            "Do reference `SalesYTD` and `SalesQuota` columns instead of `predicted_sales` and `actual_sales`. Do use the `SalesPerson` table instead of `salespersons`. Do filter on `BusinessEntityID = 288` instead of `id = 288`. The amended query now correctly calculates the difference between year-to-date sales and sales quota for the specified salesperson.",
            "Do calculate `SalesYTD - SalesQuota` instead of `SalesQuota - SalesYTD` to correctly compute the difference between actual sales and quota. Do remove the alias `AS difference` instead of keeping it since the column naming is unnecessary for this calculation. The amended query now correctly subtracts the quota from actual sales year-to-date and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT predicted_sales - actual_sales AS difference FROM salespersons WHERE id = 288;",
            "SELECT SalesQuota - SalesYTD AS difference FROM SalesPerson WHERE BusinessEntityID = 288;",
            "SELECT SalesYTD - SalesQuota FROM SalesPerson WHERE BusinessEntityID = 288;"
        ],
        "rule_sql": []
    },
    "8407": {
        "db_id": "mondial_geo",
        "question": "How many deserts are not located in a single country? Name them.",
        "ground_truth": "SELECT Desert FROM geo_desert GROUP BY Desert HAVING COUNT(DISTINCT Country) > 1",
        "amends": [
            "Do select `Desert` instead of `COUNT(*)`, and do add `GROUP BY Desert` instead of omitting it. Do change the source table to `geo_desert` instead of `deserts`, and do move the filter to `HAVING COUNT(DISTINCT Country) > 1` instead of `WHERE country IS NULL`. Do remove the aggregate function from the SELECT list and instead use it in the HAVING clause to filter groups. The amended query now correctly identifies deserts that span multiple countries rather than counting records with null country values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM deserts WHERE country IS NULL;",
            "SELECT Desert FROM geo_desert GROUP BY Desert HAVING COUNT(DISTINCT Country) > 1"
        ],
        "rule_sql": []
    },
    "7142": {
        "db_id": "works_cycles",
        "question": "What's Emma H Harris's Business Entity ID number?",
        "ground_truth": "SELECT BusinessEntityID FROM Person WHERE FirstName = 'Emma' AND LastName = 'Harris'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT BusinessEntityID FROM Person WHERE FirstName = 'Emma' AND LastName = 'Harris';"
        ],
        "rule_sql": []
    },
    "7214": {
        "db_id": "works_cycles",
        "question": "What is the name of the territory assigned to the sales person with business id \"277\"?",
        "ground_truth": "SELECT T2.Name FROM SalesPerson AS T1 INNER JOIN SalesTerritory AS T2 ON T1.TerritoryID = T2.TerritoryID WHERE T1.BusinessEntityID = 277",
        "amends": [
            "Do select `T2.Name` from the joined table instead of `territory_name` from a single table. Do join `SalesPerson AS T1` with `SalesTerritory AS T2` using `INNER JOIN` on `T1.TerritoryID = T2.TerritoryID` instead of querying only `sales_territories`. Do filter on `T1.BusinessEntityID = 277` instead of `business_id = '277'`, using a numeric value instead of a string literal. The amended query now correctly retrieves the territory name by joining the sales person with their associated territory and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT territory_name FROM sales_territories WHERE business_id = '277';",
            "SELECT T2.Name \nFROM SalesPerson AS T1 \nINNER JOIN SalesTerritory AS T2 ON T1.TerritoryID = T2.TerritoryID \nWHERE T1.BusinessEntityID = 277"
        ],
        "rule_sql": []
    },
    "1529": {
        "db_id": "synthea",
        "question": "Among the patients who have been using Penicillin V Potassium 250 MG, what percentage of patients are female?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Penicillin V Potassium 250 MG'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END)` with explicit ELSE 0 instead of `COUNT(CASE WHEN gender = 'Female' THEN 1 END)` to properly count female patients. Do add `INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT` instead of querying only the patients table, to properly link medication data. Do move the medication filter to `WHERE T2.DESCRIPTION = 'Penicillin V Potassium 250 MG'` instead of filtering on a non-existent medication column in the patients table. Do use `CAST(... AS REAL)` for precise division instead of implicit floating-point conversion. Do reference `T1.patient` in the COUNT instead of `*` to count distinct patients with the medication. Do use table alias `T1` for patients and reference `T1.gender` instead of unqualified column names. The amended query now correctly calculates the percentage of female patients prescribed the specific medication by properly joining the medication data and using accurate counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM patients\nWHERE medication = 'Penicillin V Potassium 250 MG';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.patient) * 100.0 AS percentage_female\nFROM \n    patients AS T1\nINNER JOIN \n    medications AS T2 ON T1.patient = T2.PATIENT\nWHERE \n    T2.DESCRIPTION = 'Penicillin V Potassium 250 MG'"
        ],
        "rule_sql": []
    },
    "9082": {
        "db_id": "bike_share_1",
        "question": "How many bicycle trip were made within San Jose city during August 2013?",
        "ground_truth": "SELECT COUNT(T2.id) FROM station AS T1 INNER JOIN trip AS T2 ON T2.start_station_name = T1.name WHERE T1.city = 'San Jose' AND T2.start_date LIKE '8/%/2013%' AND T2.start_station_name LIKE 'San Jose%' AND T2.end_station_name LIKE 'San Jose%'",
        "amends": [
            "Do join `station AS T1` and `trip AS T2` with `INNER JOIN` on `T2.start_station_name = T1.name` instead of querying only `trips` table without any joins. Do filter on `T1.city = 'San Jose'` instead of `city = 'San Jose'` to reference the correct table. Do use `T2.start_date LIKE '8/%/2013%'` instead of `start_date LIKE '2013-08%'` for proper date format matching. Do add filters `T2.start_station_name LIKE 'San Jose%'` and `T2.end_station_name LIKE 'San Jose%'` instead of omitting these station name conditions. Do count `T2.id` instead of `COUNT(*)` to count specific trip records. The amended query now correctly counts trips from San Jose stations with proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trips WHERE city = 'San Jose' AND start_date LIKE '2013-08%'",
            "SELECT COUNT(T2.id) \nFROM station AS T1 \nINNER JOIN trip AS T2 ON T2.start_station_name = T1.name \nWHERE T1.city = 'San Jose' \nAND T2.start_date LIKE '8/%/2013%' \nAND T2.start_station_name LIKE 'San Jose%' \nAND T2.end_station_name LIKE 'San Jose%'"
        ],
        "rule_sql": []
    },
    "4664": {
        "db_id": "disney",
        "question": "Which director has made the most movies?",
        "ground_truth": "SELECT director, COUNT(name) FROM director GROUP BY director ORDER BY COUNT(name) DESC LIMIT 1",
        "amends": [
            "Do reference the `director` table instead of the `movies` table in the FROM clause. Do count `name` column instead of using `COUNT(*)` to count all rows. Do order by `COUNT(name)` instead of the alias `movie_count` to reference the actual aggregate expression. Do remove the column alias `as movie_count` instead of keeping it since it's not referenced in the ORDER BY. The amended query now correctly counts movies per director from the appropriate table and orders by the actual count value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director, COUNT(*) as movie_count FROM movies GROUP BY director ORDER BY movie_count DESC LIMIT 1;",
            "SELECT director, COUNT(name) FROM director GROUP BY director ORDER BY COUNT(name) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "791": {
        "db_id": "social_media",
        "question": "What is the gender of the user who has posted the tweet that is seen by the most number of unique users?",
        "ground_truth": "SELECT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID ORDER BY T1.Reach DESC LIMIT 1",
        "amends": [
            "Do select `T2.Gender` instead of `u.gender`. Do use `twitter AS T1` and `user AS T2` as table sources instead of `users u`, `tweets t`, and `views v`. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.UserID = T2.UserID` instead of joining multiple tables with different join conditions. Do remove the `GROUP BY t.tweet_id` clause instead of keeping it. Do order by `T1.Reach DESC` instead of `COUNT(DISTINCT v.user_id) DESC`. Do remove the unnecessary joins to `tweets` and `views` tables instead of including them. The amended query now correctly retrieves the gender associated with the user who has the highest reach from the twitter table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.gender \nFROM users u\nJOIN tweets t ON u.user_id = t.user_id\nJOIN views v ON t.tweet_id = v.tweet_id\nGROUP BY t.tweet_id\nORDER BY COUNT(DISTINCT v.user_id) DESC\nLIMIT 1;",
            "SELECT T2.Gender\nFROM twitter AS T1\nINNER JOIN user AS T2 ON T1.UserID = T2.UserID\nORDER BY T1.Reach DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5922": {
        "db_id": "books",
        "question": "What is the cheapest order price of the book \"The Little House\"?",
        "ground_truth": "SELECT MIN(T2.price) FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.title = 'The Little House'",
        "amends": [
            "Do use `MIN(T2.price)` instead of `MAX(price)` to find the minimum price rather than maximum. Do join `book AS T1` and `order_line AS T2` with `INNER JOIN` on `T1.book_id = T2.book_id` instead of querying only the `orders` table. Do filter on `T1.title = 'The Little House'` instead of `book_title = 'The Little House'` to reference the correct table and column. Do remove the direct table reference to `orders` and instead use the joined `order_line` table for price data. The amended query now correctly finds the minimum price for the specified book by properly joining the relevant tables and using the appropriate aggregate function."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(price) FROM orders WHERE book_title = 'The Little House';",
            "SELECT MIN(T2.price) AS cheapest_price\nFROM book AS T1\nINNER JOIN order_line AS T2 ON T1.book_id = T2.book_id\nWHERE T1.title = 'The Little House'"
        ],
        "rule_sql": []
    },
    "3125": {
        "db_id": "cars",
        "question": "What is the average price per car produced in Japan?",
        "ground_truth": "SELECT AVG(T1.price) FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'Japan'",
        "amends": [
            "Do specify the table alias `T1.price` instead of just `price` in the SELECT list. Do add joins to `production AS T2` and `country AS T3` instead of querying only the `cars` table. Do use `INNER JOIN` with `T1.ID = T2.ID` and `T3.origin = T2.country` instead of no joins. Do filter on `T3.country = 'Japan'` instead of `country = 'Japan'` to reference the correct table. The amended query now correctly joins the necessary tables to calculate the average price for Japanese cars and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM cars WHERE country = 'Japan';",
            "SELECT AVG(T1.price) AS average_price\nFROM price AS T1\nINNER JOIN production AS T2 ON T1.ID = T2.ID\nINNER JOIN country AS T3 ON T3.origin = T2.country\nWHERE T3.country = 'Japan'"
        ],
        "rule_sql": []
    },
    "7892": {
        "db_id": "world",
        "question": "What country has the largest surface area?",
        "ground_truth": "SELECT Name FROM Country ORDER BY SurfaceArea DESC LIMIT 1",
        "amends": [
            "Do reference the `Name` column instead of `name` to match the correct column name. Do use `SurfaceArea` for ordering instead of `population` to sort by the correct metric. Do reference the `Country` table instead of `countries` to use the correct table name. The amended query now correctly selects the country with the largest surface area instead of the most populous country."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries ORDER BY population DESC LIMIT 1;",
            "SELECT Name FROM Country ORDER BY SurfaceArea DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4649": {
        "db_id": "disney",
        "question": "How many movies did Wolfgang Reitherman direct?",
        "ground_truth": "SELECT COUNT(name) FROM director WHERE director = 'Wolfgang Reitherman'",
        "amends": [
            "Do query the `director` table instead of the `movies` table. Do count the `name` column instead of using `COUNT(*)`. Do keep the filter `director = 'Wolfgang Reitherman'` unchanged. The amended query now correctly counts directors by name in the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE director = 'Wolfgang Reitherman';",
            "SELECT COUNT(name) FROM director WHERE director = 'Wolfgang Reitherman'"
        ],
        "rule_sql": []
    },
    "3600": {
        "db_id": "authors",
        "question": "Find the names of papers which are published in the year 1996.",
        "ground_truth": "SELECT Title FROM Paper WHERE year = 1996",
        "amends": [
            "Do reference the table as `Paper` instead of `papers` and use the column name `Title` instead of `title` in the SELECT list. Do use the integer value `1996` without quotes instead of the string literal `'1996'` in the WHERE filter to ensure proper numeric comparison. The amended query now correctly matches the RIGHT_SQL's behavior with proper table and column references and appropriate data type handling for the year filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE year = '1996';",
            "SELECT Title FROM Paper WHERE Year = 1996"
        ],
        "rule_sql": []
    },
    "2275": {
        "db_id": "movielens",
        "question": "What is the difference of female and male audiences in number who viewed horror movies?",
        "ground_truth": "SELECT SUM(IIF(T2.u_gender = 'F', 1, 0)) - SUM(IIF(T2.u_gender = 'M', 1, 0)) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid INNER JOIN movies2directors AS T3 ON T3.movieid = T1.movieid WHERE T3.genre = 'horror'",
        "amends": [
            "Do use `SUM(IIF(T2.u_gender = 'F', 1, 0)) - SUM(IIF(T2.u_gender = 'M', 1, 0))` instead of `COUNT(CASE WHEN gender = 'male' THEN 1 END) - COUNT(CASE WHEN gender = 'female' THEN 1 END)` for the gender difference calculation. Do join `users AS T2` with `ON T1.userid = T2.userid` instead of the previous table structure. Do add `INNER JOIN movies2directors AS T3` with `ON T3.movieid = T1.movieid` instead of joining directly to movies. Do use `WHERE T3.genre = 'horror'` instead of `movies.genre = 'horror'` to filter by genre. The amended query now correctly calculates the gender difference using SUM with IIF conditions and properly joins through the movies2directors table to access genre information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN gender = 'male' THEN 1 END) - COUNT(CASE WHEN gender = 'female' THEN 1 END) AS gender_difference\nFROM audiences\nJOIN movies ON audiences.movie_id = movies.id\nWHERE movies.genre = 'horror';",
            "SELECT SUM(IIF(T2.u_gender = 'F', 1, 0)) - SUM(IIF(T2.u_gender = 'M', 1, 0)) AS gender_difference\nFROM u2base AS T1\nINNER JOIN users AS T2 ON T1.userid = T2.userid\nINNER JOIN movies2directors AS T3 ON T3.movieid = T1.movieid\nWHERE T3.genre = 'horror';"
        ],
        "rule_sql": []
    },
    "1337": {
        "db_id": "law_episode",
        "question": "Which episodes are nominated for an awards but not win?",
        "ground_truth": "SELECT T1.episode FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T2.result = 'Nominee'",
        "amends": [
            "Do select `T1.episode` instead of `episode_title` and use `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying a single table. Do filter on `T2.result = 'Nominee'` instead of separate `nominated = 'yes' AND won = 'yes'` conditions. Do add the `Award AS T2` table instead of omitting it to properly join award information. The amended query now correctly retrieves episodes that are nominees by joining the Episode and Award tables with appropriate filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_title FROM episodes WHERE nominated = 'yes' AND won = 'yes';",
            "SELECT T1.episode\nFROM Episode AS T1\nINNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id\nWHERE T2.result = 'Nominee'"
        ],
        "rule_sql": []
    },
    "2794": {
        "db_id": "european_football_1",
        "question": "How many final-time home-team goals were there in total in all the matches of the Bundesliga division in the 2021 season?",
        "ground_truth": "SELECT SUM(T1.FTHG) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'Bundesliga' AND T1.season = 2021",
        "amends": [
            "Do join `matchs AS T1` with `divisions AS T2` on `T1.Div = T2.division` instead of querying a single table. Do filter by `T2.name = 'Bundesliga'` instead of `division = 'Bundesliga'` to reference the joined table. Do use column `T1.FTHG` for the sum instead of `home_team_goals` to match the correct schema. Do remove the `time_period = 'final'` filter instead of keeping it as it's not needed in the correct logic. The amended query now correctly aggregates goals from the appropriate joined tables with proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(home_team_goals) FROM matches WHERE division = 'Bundesliga' AND season = 2021 AND time_period = 'final';",
            "SELECT SUM(T1.FTHG) AS total_home_goals\nFROM matchs AS T1\nJOIN divisions AS T2 ON T1.Div = T2.division\nWHERE T2.name = 'Bundesliga' AND T1.season = 2021"
        ],
        "rule_sql": []
    },
    "6728": {
        "db_id": "retails",
        "question": "Calculate the percentage of manufactured parts by Manufacturer#3.",
        "ground_truth": "SELECT CAST(SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) AS REAL) * 100 / COUNT(p_partkey) FROM part",
        "amends": [
            "Do use `SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0))` instead of `COUNT(*)` with a `WHERE` filter to properly count only matching rows while preserving the total count denominator. Do reference `p_mfgr` column instead of `manufacturer_id` to match the correct column name. Do use `CAST(... AS REAL)` instead of implicit integer division to ensure proper percentage calculation with decimal precision. Do reference `p_partkey` in the denominator instead of a separate subquery for the total count to improve efficiency. Do remove the `WHERE` clause filter and instead incorporate the condition within the `IIF` function to maintain the correct ratio calculation. Do change the table reference from `parts` to `part` to match the correct table name.",
            "Do place the multiplication by 100 after the division instead of before it, changing `* 100 / COUNT(p_partkey)` instead of `/ COUNT(p_partkey) * 100`, to ensure proper calculation order where the percentage is computed by first dividing the count of matching parts by the total count and then multiplying by 100. Do remove the alias `percentage` instead of keeping it, as the right SQL omits the column alias. The amended query now correctly calculates the percentage of parts from Manufacturer#3 by fixing the mathematical operation order.",
            "Do place the multiplication by 100 after the SUM operation instead of after the division, changing `SUM(IIF(...)) / COUNT(...) * 100` to `SUM(IIF(...)) * 100 / COUNT(...)` to correctly calculate the percentage by scaling the numerator before division rather than scaling the final result, which ensures proper percentage computation when dealing with integer division semantics. The amended query now matches RIGHT_SQL's behavior.",
            "Do add `CAST(... AS REAL)` around the `SUM(IIF(...))` expression instead of omitting it to ensure proper floating-point division instead of integer division, which would truncate the percentage result. The amended query now matches RIGHT_SQL's behavior by correctly calculating the percentage as a real number rather than an integer."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM parts)) AS percentage FROM parts WHERE manufacturer_id = 3;",
            "SELECT CAST(SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) AS REAL) / COUNT(p_partkey) * 100 AS percentage\nFROM part;",
            "SELECT CAST(SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) AS REAL) / COUNT(p_partkey) * 100 FROM part;",
            "SELECT SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) * 100 / COUNT(p_partkey) FROM part;",
            "SELECT CAST(SUM(IIF(p_mfgr = 'Manufacturer#3', 1, 0)) AS REAL) * 100 / COUNT(p_partkey) FROM part;"
        ],
        "rule_sql": []
    },
    "4740": {
        "db_id": "legislator",
        "question": "What is the google entity ID of current legislator Sherrod Brown?",
        "ground_truth": "SELECT google_entity_id_id FROM current WHERE official_full_name = 'Sherrod Brown'",
        "amends": [
            "Do select `google_entity_id_id` instead of `google_entity_id`. Do use table `current` instead of `legislators`. Do filter on `official_full_name = 'Sherrod Brown'` instead of `name = 'Sherrod Brown' AND current = 1`. The amended query now correctly retrieves the google_entity_id_id from the current table using the official full name filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT google_entity_id FROM legislators WHERE name = 'Sherrod Brown' AND current = 1;",
            "SELECT google_entity_id_id FROM current WHERE official_full_name = 'Sherrod Brown';"
        ],
        "rule_sql": []
    },
    "2746": {
        "db_id": "european_football_1",
        "question": "What is the name of all the teams that played in the EFL League One division?",
        "ground_truth": "SELECT T1.HomeTeam,T1.AwayTeam FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div=T2.division WHERE T2.name = 'EFL League One' and T1.Div = 'E2' ",
        "amends": [
            "Do select `T1.HomeTeam` and `T1.AwayTeam` instead of `team_name` from a single table. Do use `FROM matchs AS T1 INNER JOIN divisions AS T2` instead of `FROM teams` alone, adding a join between matchs and divisions tables. Do use join condition `ON T1.Div=T2.division` to properly relate the tables. Do add filter `WHERE T2.name = 'EFL League One'` instead of filtering on division directly, and do include additional filter `T1.Div = 'E2'` instead of omitting it. The amended query now correctly retrieves home and away teams from matchs joined with divisions, filtering for EFL League One matches with the proper division code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE division = 'EFL Championship';",
            "SELECT DISTINCT T1.HomeTeam, T1.AwayTeam \nFROM matchs AS T1 \nINNER JOIN divisions AS T2 ON T1.Div = T2.division \nWHERE T2.name = 'EFL League One' AND T1.Div = 'E2'"
        ],
        "rule_sql": []
    },
    "1173": {
        "db_id": "talkingdata",
        "question": "Describe the number of app IDs and location of the event ID \"79641\".",
        "ground_truth": "SELECT COUNT(T1.app_id), T2.longitude, T2.latitude FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id WHERE T1.event_id = 79641 GROUP BY T2.longitude, T2.latitude",
        "amends": [
            "Do specify `COUNT(T1.app_id)` instead of `COUNT(app_id)` to clarify the table source. Do add table aliases `T1` and `T2` instead of omitting them. Do change the FROM clause to `app_events AS T1 INNER JOIN events AS T2` instead of just `events` to properly join the tables. Do add the join condition `ON T1.event_id = T2.event_id` instead of omitting it. Do change the WHERE filter to `T1.event_id = 79641` instead of `event_id = 79641` to specify the correct table. Do add `GROUP BY T2.longitude, T2.latitude` instead of omitting grouping. Do include both `T2.longitude` and `T2.latitude` in the SELECT list instead of just `location`. The amended query now correctly aggregates app counts by geographic coordinates through proper table joining and grouping.",
            "Do place `COUNT(T1.app_id)` first in the SELECT list instead of after `T2.longitude` and `T2.latitude`. Do remove the alias `AS app_count` instead of keeping it. The amended query now correctly matches the RIGHT_SQL's behavior with identical column ordering and without the unnecessary alias."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(app_id), location FROM events WHERE event_id = 79641",
            "SELECT T2.longitude, T2.latitude, COUNT(T1.app_id) AS app_count\nFROM app_events AS T1 \nINNER JOIN events AS T2 ON T1.event_id = T2.event_id\nWHERE T1.event_id = 79641\nGROUP BY T2.longitude, T2.latitude",
            "SELECT COUNT(T1.app_id), T2.longitude, T2.latitude\nFROM app_events AS T1\nINNER JOIN events AS T2 ON T1.event_id = T2.event_id\nWHERE T1.event_id = 79641\nGROUP BY T2.longitude, T2.latitude"
        ],
        "rule_sql": []
    },
    "8228": {
        "db_id": "mondial_geo",
        "question": "Provide the country with republic government which has the highest population growth?",
        "ground_truth": "SELECT T2.Country FROM population AS T1 INNER JOIN politics AS T2 ON T1.Country = T2.Country WHERE T2.Government = 'republic' ORDER BY T1.Population_Growth DESC LIMIT 1",
        "amends": [
            "Do join `population` and `politics` tables with `INNER JOIN` on `T1.Country = T2.Country` instead of querying only the `countries` table. Do select `T2.Country` instead of just `country`. Do filter on `T2.Government = 'republic'` instead of `government = 'republic'`. Do order by `T1.Population_Growth DESC` instead of `population DESC`. The amended query now correctly joins the required tables and uses the appropriate population growth metric for sorting while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM countries WHERE government = 'republic' ORDER BY population DESC LIMIT 1;",
            "SELECT T2.Country \nFROM population T1 \nINNER JOIN politics T2 ON T1.Country = T2.Country \nWHERE T2.Government = 'republic' \nORDER BY T1.Population_Growth DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2344": {
        "db_id": "movielens",
        "question": "What is the total amount male and female actors who were casted in movie ID 1684910 and what is the proportion between the highest quality actors against the worst quality of actors? Indicate your answer in percentage. List the the director as well as the genre.",
        "ground_truth": "SELECT SUM(IIF(a_gender = 'M', 1, 0)) , SUM(IIF(a_gender = 'F', 1, 0)) , CAST(SUM(IIF(a_quality = 5, 1, 0)) AS REAL) * 100 / COUNT(*) , CAST(SUM(IIF(a_quality = 0, 1, 0)) AS REAL) * 100 / COUNT(*), ( SELECT directorid FROM movies2directors WHERE movieid = 1684910 ) , ( SELECT genre FROM movies2directors WHERE movieid = 1684910 ) FROM actors WHERE actorid IN ( SELECT actorid FROM movies2actors WHERE movieid = 1684910 )",
        "amends": [
            "Do use `SUM(IIF(a_gender = 'M', 1, 0))` and `SUM(IIF(a_gender = 'F', 1, 0))` instead of `COUNT(CASE WHEN a.gender = 'M' THEN 1 END)` and `COUNT(CASE WHEN a.gender = 'F' THEN 1 END)` for gender counts. Do calculate quality percentages with `CAST(SUM(IIF(a_quality = 5, 1, 0)) AS REAL) * 100 / COUNT(*)` and `CAST(SUM(IIF(a_quality = 0, 1, 0)) AS REAL) * 100 / COUNT(*)` instead of `(MAX(a.quality) / MIN(a.quality)) * 100` for quality proportion. Do retrieve director and genre through subqueries `(SELECT directorid FROM movies2directors WHERE movieid = 1684910)` and `(SELECT genre FROM movies2directors WHERE movieid = 1684910)` instead of joining multiple tables. Do filter actors using `WHERE actorid IN (SELECT actorid FROM movies2actors WHERE movieid = 1684910)` instead of complex table joins. Do remove `GROUP BY d.name, g.genre` since aggregation is now handled differently. The amended query now correctly calculates quality percentages and uses proper table relationships to match the intended behavior.",
            "Do move the `directorid` and `genre` subqueries from the SELECT list to the end instead of placing them at the beginning. Do remove the column aliases `AS directorid` and `AS genre` instead of keeping them. Do remove the table alias `a` from all column references instead of using it. Do use direct column references `a_gender` and `a_quality` instead of qualified references `a.a_gender` and `a.a_quality`. The amended query now correctly aggregates actor data while maintaining the same subquery logic for director and genre information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    d.name AS director,\n    g.genre,\n    COUNT(CASE WHEN a.gender = 'M' THEN 1 END) AS male_actors,\n    COUNT(CASE WHEN a.gender = 'F' THEN 1 END) AS female_actors,\n    (MAX(a.quality) / MIN(a.quality)) * 100 AS quality_proportion_percentage\nFROM \n    movies m\nJOIN \n    directors d ON m.director_id = d.id\nJOIN \n    movie_genres mg ON m.id = mg.movie_id\nJOIN \n    genres g ON mg.genre_id = g.id\nJOIN \n    casts c ON m.id = c.movie_id\nJOIN \n    actors a ON c.actor_id = a.id\nWHERE \n    m.id = 1684910\nGROUP BY \n    d.name, g.genre;",
            "SELECT \n    (SELECT directorid FROM movies2directors WHERE movieid = 1684910) AS directorid,\n    (SELECT genre FROM movies2directors WHERE movieid = 1684910) AS genre,\n    SUM(IIF(a.a_gender = 'M', 1, 0)) AS male_actors,\n    SUM(IIF(a.a_gender = 'F', 1, 0)) AS female_actors,\n    CAST(SUM(IIF(a.a_quality = 5, 1, 0)) AS REAL) * 100 / COUNT(*) AS highest_quality_percentage,\n    CAST(SUM(IIF(a.a_quality = 0, 1, 0)) AS REAL) * 100 / COUNT(*) AS worst_quality_percentage\nFROM actors a\nWHERE a.actorid IN (SELECT actorid FROM movies2actors WHERE movieid = 1684910);",
            "SELECT \n    SUM(IIF(a_gender = 'M', 1, 0)) AS male_actors,\n    SUM(IIF(a_gender = 'F', 1, 0)) AS female_actors,\n    CAST(SUM(IIF(a_quality = 5, 1, 0)) AS REAL) * 100 / COUNT(*) AS highest_quality_percentage,\n    CAST(SUM(IIF(a_quality = 0, 1, 0)) AS REAL) * 100 / COUNT(*) AS worst_quality_percentage,\n    (SELECT directorid FROM movies2directors WHERE movieid = 1684910) AS directorid,\n    (SELECT genre FROM movies2directors WHERE movieid = 1684910) AS genre\nFROM actors\nWHERE actorid IN (SELECT actorid FROM movies2actors WHERE movieid = 1684910)"
        ],
        "rule_sql": []
    },
    "6930": {
        "db_id": "ice_hockey_draft",
        "question": "How many right-shooted players have a height of 5'7''?",
        "ground_truth": "SELECT COUNT(T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch = '5''7\"' AND T1.shoots = 'R'",
        "amends": [
            "Do select `COUNT(T1.ELITEID)` instead of `COUNT(*)` and use table alias `T1` instead of direct table reference. Do join `height_info AS T2` with `INNER JOIN` on `T1.height = T2.height_id` instead of querying the `players` table directly without any joins. Do filter on `T2.height_in_inch = '5''7\"'` instead of `height = '5\\'7\"'` and use `T1.shoots = 'R'` instead of `shoot_side = 'left'`. The amended query now correctly counts elite players by joining height information and filtering on the proper height measurement and shooting side, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE shoot_side = 'left' AND height = '5\\'7\\\"';",
            "SELECT COUNT(T1.ELITEID) \nFROM PlayerInfo AS T1\nINNER JOIN height_info AS T2 ON T1.height = T2.height_id\nWHERE T2.height_in_inch = '5''7\"' \nAND T1.shoots = 'R'"
        ],
        "rule_sql": []
    },
    "8582": {
        "db_id": "software_company",
        "question": "Find the response status to customer whose geographic ID of 134.",
        "ground_truth": "SELECT T2.RESPONSE FROM Customers AS T1 INNER JOIN mailings3 AS T2 ON T1.ID = T2.REFID WHERE T1.GEOID = 134",
        "amends": [
            "Do select `T2.RESPONSE` instead of `status`. Do add `INNER JOIN mailings3 AS T2` instead of omitting it. Do use join condition `T1.ID = T2.REFID` instead of no join. Do reference `T1.GEOID` instead of `geographic_id`. The amended query now correctly joins the customers and mailings3 tables to retrieve the response from mailings rather than the status from customers, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT status FROM customers WHERE geographic_id = 134",
            "SELECT T2.RESPONSE \nFROM Customers AS T1 \nINNER JOIN mailings3 AS T2 ON T1.ID = T2.REFID \nWHERE T1.GEOID = 134"
        ],
        "rule_sql": []
    },
    "5461": {
        "db_id": "sales",
        "question": "List the first name of all the customers whose last name is Chen.",
        "ground_truth": "SELECT FirstName, LastName FROM Customers WHERE LastName = 'Chen'",
        "amends": [
            "Do select `FirstName, LastName` instead of just `first_name`. Do reference table `Customers` instead of `customers`. Do filter on `LastName = 'Chen'` instead of `first_name = 'Chen'`. The amended query now correctly retrieves both name columns from the proper table with the appropriate filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE first_name = 'Chen';",
            "SELECT FirstName, LastName FROM Customers WHERE LastName = 'Chen'"
        ],
        "rule_sql": []
    },
    "5303": {
        "db_id": "beer_factory",
        "question": "What is the difference in the average number of sales per day of root beer brands that contain honey and that don\u2019t contain honey.",
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN T1.Honey = 'TRUE' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T3.TransactionDate)) - (CAST(SUM(CASE WHEN T1.Honey <> 'TRUE' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T3.TransactionDate)) FROM rootbeerbrand AS T1 INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID INNER JOIN `transaction` AS T3 ON T2.RootBeerID = T3.RootBeerID",
        "amends": [
            "Do calculate the difference between average honey-brand sales and non-honey sales using `SUM(CASE WHEN T1.Honey = 'TRUE' THEN 1 ELSE 0 END)` divided by `COUNT(DISTINCT T3.TransactionDate)` instead of using `AVG(CASE WHEN brand_name LIKE '%honey%' THEN daily_sales ELSE 0 END)` with ELSE 0. Do join `rootbeerbrand AS T1` with `rootbeer AS T2` on `T1.BrandID = T2.BrandID` instead of querying a single table. Do add a second join to `transaction AS T3` on `T2.RootBeerID = T3.RootBeerID` instead of omitting transaction data. Do use explicit boolean comparison `T1.Honey = 'TRUE'` instead of string pattern matching `LIKE '%honey%'`. Do count distinct transaction dates for normalization instead of averaging daily sales values directly. Do cast sums to REAL for proper division instead of implicit casting. The amended query now correctly calculates the average sales difference per transaction date between honey and non-honey root beer brands.",
            "Do cast both SUM aggregates to REAL instead of multiplying by 1.0 for proper floating-point division. Do use `<>` operator instead of `!=` for the second CASE condition. Do add explicit `INNER JOIN` keywords instead of just `JOIN` for clarity. Do quote the reserved word `transaction` as backticks instead of leaving it unquoted. Do remove the column alias `avg_sales_difference` instead of keeping it since the RIGHT_SQL omits it. The amended query now correctly handles floating-point precision with CAST and uses standard SQL operators and syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    AVG(CASE WHEN brand_name LIKE '%honey%' THEN daily_sales ELSE 0 END) - \n    AVG(CASE WHEN brand_name NOT LIKE '%honey%' THEN daily_sales ELSE 0 END) AS sales_difference\nFROM root_beer_sales;",
            "SELECT \n    (SUM(CASE WHEN T1.Honey = 'TRUE' THEN 1 ELSE 0 END) * 1.0 / COUNT(DISTINCT T3.TransactionDate)) - \n    (SUM(CASE WHEN T1.Honey != 'TRUE' THEN 1 ELSE 0 END) * 1.0 / COUNT(DISTINCT T3.TransactionDate)) AS avg_sales_difference\nFROM \n    rootbeerbrand AS T1\nJOIN \n    rootbeer AS T2 ON T1.BrandID = T2.BrandID\nJOIN \n    transaction AS T3 ON T2.RootBeerID = T3.RootBeerID;",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.Honey = 'TRUE' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T3.TransactionDate)) - \n    (CAST(SUM(CASE WHEN T1.Honey <> 'TRUE' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T3.TransactionDate))\nFROM \n    rootbeerbrand AS T1\nINNER JOIN \n    rootbeer AS T2 ON T1.BrandID = T2.BrandID\nINNER JOIN \n    \"transaction\" AS T3 ON T2.RootBeerID = T3.RootBeerID;"
        ],
        "rule_sql": []
    },
    "5037": {
        "db_id": "olympics",
        "question": "State the name of the city that held game id 3.",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE T1.games_id = 3",
        "amends": [
            "Do select `T2.city_name` from the `city` table instead of `city` from the `games` table. Do join `games_city AS T1` and `city AS T2` with an `INNER JOIN` on `T1.city_id = T2.id` instead of querying only the `games` table. Do filter on `T1.games_id = 3` instead of `game_id = 3` to properly reference the join relationship. The amended query now correctly retrieves city information through the appropriate table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM games WHERE game_id = 3;",
            "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE T1.games_id = 3"
        ],
        "rule_sql": []
    },
    "1482": {
        "db_id": "synthea",
        "question": "How many male patients are diagnosed with hypertension as compared to female patients?",
        "ground_truth": "SELECT COUNT(DISTINCT CASE WHEN T2.gender = 'M' THEN T2.patient END) AS Male , COUNT(DISTINCT CASE WHEN T2.gender = 'F' THEN T2.patient END) AS Female FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Hypertension'",
        "amends": [
            "Do use `COUNT(DISTINCT CASE WHEN T2.gender = 'M' THEN T2.patient END)` and `COUNT(DISTINCT CASE WHEN T2.gender = 'F' THEN T2.patient END)` instead of simple `COUNT(*)` to count distinct patients by gender. Do join `conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient` instead of querying only the `patients` table to incorporate condition data. Do filter on `T1.DESCRIPTION = 'Hypertension'` instead of `diagnosis = 'hypertension'` to use the correct condition description field. Do remove `GROUP BY gender` and `ORDER BY patient_count DESC` instead of keeping them since the aggregation now handles gender separation within the SELECT clause. The amended query now correctly counts distinct hypertensive patients by gender using proper table relationships and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    gender,\n    COUNT(*) as patient_count\nFROM patients\nWHERE diagnosis = 'hypertension'\nGROUP BY gender\nORDER BY patient_count DESC;",
            "SELECT \n    COUNT(DISTINCT CASE WHEN T2.gender = 'M' THEN T2.patient END) AS male_patients,\n    COUNT(DISTINCT CASE WHEN T2.gender = 'F' THEN T2.patient END) AS female_patients\nFROM \n    conditions AS T1 \nINNER JOIN \n    patients AS T2 ON T1.PATIENT = T2.patient\nWHERE \n    T1.DESCRIPTION = 'Hypertension'"
        ],
        "rule_sql": []
    },
    "2978": {
        "db_id": "shakespeare",
        "question": "How many chapters does the character Demetrius show in the story?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.chapter_id) FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T1.CharName = 'Demetrius'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.chapter_id)` instead of `COUNT(*)` to count unique chapters instead of all rows. Do add `INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id` instead of omitting the join to access chapter information. Do reference `T1.CharName` instead of `name` for the correct column name. Do add table alias `T1` for characters instead of using the table name directly. The amended query now correctly counts distinct chapters containing the character instead of simply counting character occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM characters WHERE name = 'Demetrius';",
            "SELECT COUNT(DISTINCT T2.chapter_id) \nFROM characters AS T1 \nINNER JOIN paragraphs AS T2 ON T1.id = T2.character_id \nWHERE T1.CharName = 'Demetrius'"
        ],
        "rule_sql": []
    },
    "1452": {
        "db_id": "synthea",
        "question": "On what dates did the billable period begin for patients with the last name Dickinson?",
        "ground_truth": "SELECT DISTINCT T2.BILLABLEPERIOD FROM patients AS T1 INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE T1.last = 'Dickinson'",
        "amends": [
            "Do use `DISTINCT T2.BILLABLEPERIOD` instead of `billable_period_start_date` without distinct. Do add `INNER JOIN claims AS T2` instead of querying only the patients table. Do use join condition `ON T1.patient = T2.PATIENT` instead of no join. Do use filter `T1.last = 'Dickinson'` instead of `last_name = 'Dickinson'`. Do reference table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins to the claims table to retrieve billable periods and uses proper table aliasing and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT billable_period_start_date FROM patients WHERE last_name = 'Dickinson';",
            "SELECT DISTINCT T2.BILLABLEPERIOD\nFROM patients AS T1\nINNER JOIN claims AS T2 ON T1.patient = T2.PATIENT\nWHERE T1.last = 'Dickinson'"
        ],
        "rule_sql": []
    },
    "142": {
        "db_id": "movie_platform",
        "question": "Provide list titles created by user who are eligible for trial when he created the list.",
        "ground_truth": "SELECT DISTINCT T2.list_title FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T1.user_eligible_for_trial = 1",
        "amends": [
            "Do select `DISTINCT T2.list_title` instead of `title` without distinct. Do use `lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id` instead of querying only from `lists` with subqueries. Do filter with `T1.user_eligible_for_trial = 1` instead of using nested subqueries checking `trial_eligible = 1` and comparing `created_at` with `trial_start_date`. Do remove the subquery-based user filtering and date comparison logic instead of keeping the complex nested subquery structure. The amended query now correctly joins the user eligibility information directly from the lists_users table and eliminates the performance issues of correlated subqueries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM lists WHERE user_id IN (SELECT user_id FROM users WHERE trial_eligible = 1) AND created_at < (SELECT trial_start_date FROM users WHERE users.user_id = lists.user_id);",
            "SELECT DISTINCT T2.list_title\nFROM lists_users AS T1\nINNER JOIN lists AS T2 ON T1.list_id = T2.list_id\nWHERE T1.user_eligible_for_trial = '1';"
        ],
        "rule_sql": []
    },
    "9311": {
        "db_id": "movie_3",
        "question": "What are the addresses of the inactive customers?",
        "ground_truth": "SELECT T2.address FROM customer AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE T1.active = 0",
        "amends": [
            "Do select `T2.address` from the address table instead of `address` from the customers table. Do join `customer AS T1` with `address AS T2` using `INNER JOIN` on `T1.address_id = T2.address_id` instead of querying only the customers table. Do filter on `T1.active = 0` instead of `status = 'active'` to correctly identify inactive customers. The amended query now properly retrieves addresses from the joined address table based on customer activity status, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM customers WHERE status = 'active';",
            "SELECT T2.address FROM customer AS T1 INNER JOIN address AS T2 ON T1.address_id = T2.address_id WHERE T1.active = 0"
        ],
        "rule_sql": []
    },
    "3664": {
        "db_id": "authors",
        "question": "Calculate the average of authors for each paper from the year of 1990 to 2000.",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT T2.AuthorId) AS REAL) / COUNT(DISTINCT T1.Title) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Year BETWEEN 1990 AND 2000",
        "amends": [
            "Do use `COUNT(DISTINCT T2.AuthorId) / COUNT(DISTINCT T1.Title)` instead of `AVG(author_count)` to calculate the average authors per paper. Do join `Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` instead of querying only the `papers` table to access author information. Do filter on `T1.Year BETWEEN 1990 AND 2000` instead of `year BETWEEN 1990 AND 2000` with proper table qualification. Do remove `GROUP BY paper_id` instead of grouping by individual papers since the query now calculates an overall average across all papers. Do add explicit `CAST(... AS REAL)` instead of relying on implicit casting for proper division. The amended query now correctly calculates the average number of distinct authors per paper across the specified time period.",
            "Do count distinct `T1.Title` instead of distinct `T1.Id` in the denominator calculation. The amended query now correctly matches the RIGHT_SQL's behavior by using title for paper counting instead of ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paper_id, AVG(author_count) as avg_authors\nFROM papers\nWHERE year BETWEEN 1990 AND 2000\nGROUP BY paper_id;",
            "SELECT CAST(COUNT(DISTINCT T2.AuthorId) AS REAL) / COUNT(DISTINCT T1.Id) AS avg_authors_per_paper\nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nWHERE T1.Year BETWEEN 1990 AND 2000",
            "SELECT CAST(COUNT(DISTINCT T2.AuthorId) AS REAL) / COUNT(DISTINCT T1.Title) AS average_authors_per_paper\nFROM Paper AS T1 \nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nWHERE T1.Year BETWEEN 1990 AND 2000"
        ],
        "rule_sql": []
    },
    "1029": {
        "db_id": "computer_student",
        "question": "Among the students being advised by advisors, which students' year in the program do the advisors advise the majority of?",
        "ground_truth": "SELECT T2.yearsInProgram FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.student = 1 GROUP BY T2.yearsInProgram ORDER BY COUNT(T1.p_id_dummy) DESC LIMIT 1",
        "amends": [
            "Do select `T2.yearsInProgram` instead of `s.year` and `COUNT(*) as student_count`. Do use `INNER JOIN` between `advisedBy AS T1` and `person AS T2` instead of `JOIN` between `students s` and `advisors a`. Do join on `T1.p_id = T2.p_id` instead of `s.advisor_id = a.advisor_id`. Do add `WHERE T2.student = 1` filter instead of omitting it. Do group by `T2.yearsInProgram` instead of `s.year`. Do order by `COUNT(T1.p_id_dummy) DESC` instead of `student_count DESC`. The amended query now correctly counts advised students by years in program and matches the intended behavior.",
            "Do remove `COUNT(*) as student_count` from the SELECT list instead of including it. Do add `LIMIT 1` to the ORDER BY clause instead of omitting it, which restricts the result to only the top row with the highest count. The amended query now matches RIGHT_SQL's behavior by returning only the yearsInProgram value with the highest count of advised students rather than all counts by year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.year, COUNT(*) as student_count\nFROM students s\nJOIN advisors a ON s.advisor_id = a.advisor_id\nGROUP BY s.year\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT T2.yearsInProgram, COUNT(*) as student_count\nFROM advisedBy AS T1\nINNER JOIN person AS T2 ON T1.p_id = T2.p_id\nWHERE T2.student = 1\nGROUP BY T2.yearsInProgram\nORDER BY COUNT(T1.p_id_dummy) DESC;",
            "SELECT T2.yearsInProgram\nFROM advisedBy AS T1\nINNER JOIN person AS T2 ON T1.p_id = T2.p_id\nWHERE T2.student = 1\nGROUP BY T2.yearsInProgram\nORDER BY COUNT(T1.p_id_dummy) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2824": {
        "db_id": "professional_basketball",
        "question": "Among the players from the ABA league, how many of them have the center position?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.playerID) FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.lgID = 'ABA' AND (T1.pos = 'C' OR T1.pos = 'F-C')",
        "amends": [
            "Do add `players_teams` table with `INNER JOIN` on `T1.playerID = T2.playerID` instead of querying only the `players` table. Do change the count to `COUNT(DISTINCT T1.playerID)` instead of `COUNT(*)` to count unique players. Do use `T2.lgID = 'ABA'` filter instead of `league = 'ABA'` to check league membership from the join table. Do change the position filter to `(T1.pos = 'C' OR T1.pos = 'F-C')` instead of `position = 'Center'` to include both center and forward-center positions. Do add table aliases `T1` and `T2` instead of using unaliased table references. The amended query now correctly counts distinct ABA players who played center or forward-center positions by joining with team membership data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE league = 'ABA' AND position = 'Center';",
            "SELECT COUNT(DISTINCT T1.playerID) \nFROM players T1\nINNER JOIN players_teams T2 ON T1.playerID = T2.playerID\nWHERE T2.lgID = 'ABA' \nAND (T1.pos = 'C' OR T1.pos = 'F-C')"
        ],
        "rule_sql": []
    },
    "4934": {
        "db_id": "olympics",
        "question": "Give the name of the tallest athlete from Sweden.",
        "ground_truth": "SELECT T3.full_name FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Sweden' ORDER BY T3.height DESC LIMIT 1",
        "amends": [
            "Do use `T3.full_name` instead of `name` for the SELECT column. Do join multiple tables with `INNER JOIN noc_region AS T1` and `INNER JOIN person_region AS T2 ON T1.id = T2.region_id` and `INNER JOIN person AS T3 ON T2.person_id = T3.id` instead of querying a single `athletes` table. Do filter on `T1.region_name = 'Sweden'` instead of `country = 'Sweden'`. Do order by `T3.height DESC` instead of `height DESC`. The amended query now correctly joins the necessary tables to find Swedish athletes and returns their full names ordered by height."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM athletes WHERE country = 'Sweden' ORDER BY height DESC LIMIT 1;",
            "SELECT T3.full_name\nFROM noc_region AS T1\nINNER JOIN person_region AS T2 ON T1.id = T2.region_id\nINNER JOIN person AS T3 ON T2.person_id = T3.id\nWHERE T1.region_name = 'Sweden'\nORDER BY T3.height DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3094": {
        "db_id": "cars",
        "question": "What is the fastest car made by Japan?",
        "ground_truth": "SELECT T1.car_name FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'Japan' ORDER BY T1.horsepower DESC LIMIT 1",
        "amends": [
            "Do select `T1.car_name` instead of `*` to specify the exact column needed. Do use `FROM data AS T1` joined with `production AS T2` on `T1.ID = T2.ID` and `country AS T3` on `T3.origin = T2.country` instead of the single table `cars`. Do filter on `T3.country = 'Japan'` instead of `country = 'Japan'` to properly reference the joined country table. Do order by `T1.horsepower DESC` instead of `speed DESC` to use the correct performance metric. The amended query now correctly joins multiple tables to establish proper relationships and uses appropriate column references throughout, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cars WHERE country = 'Japan' ORDER BY speed DESC LIMIT 1;",
            "SELECT T1.car_name FROM data AS T1 JOIN production AS T2 ON T1.ID = T2.ID JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'Japan' ORDER BY T1.horsepower DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "2656": {
        "db_id": "regional_sales",
        "question": "Among the products sold in Maricopa County, which was the least sold?",
        "ground_truth": "SELECT T1.`Product Name` FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Store Locations` AS T3 ON T3.StoreID = T2._StoreID WHERE T3.County = 'Maricopa County' ORDER BY T2.`Order Quantity` ASC LIMIT 1",
        "amends": [
            "Do select `T1.Product Name` instead of `product_name, MIN(quantity_sold)` and remove the aggregate function. Do join `Products AS T1` and `Sales Orders AS T2` with `INNER JOIN` on `T2._ProductID = T1.ProductID` instead of querying only the `sales` table. Do add another `INNER JOIN` to `Store Locations AS T3` on `T3.StoreID = T2._StoreID` instead of omitting this table. Do move the county filter to `T3.County = 'Maricopa County'` instead of `county = 'Maricopa'` and use the full county name. Do remove the `GROUP BY` clause instead of grouping by `product_name`. Do order by `T2.Order Quantity` instead of `quantity_sold` and maintain the `ASC` direction and `LIMIT 1`. The amended query now correctly joins the necessary tables to filter by county and find the product with the smallest order quantity in Maricopa County."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, MIN(quantity_sold) \nFROM sales \nWHERE county = 'Maricopa' \nGROUP BY product_name \nORDER BY quantity_sold ASC \nLIMIT 1;",
            "SELECT T1.\"Product Name\"\nFROM Products AS T1\nINNER JOIN \"Sales Orders\" AS T2 ON T2._ProductID = T1.ProductID\nINNER JOIN \"Store Locations\" AS T3 ON T3.StoreID = T2._StoreID\nWHERE T3.County = 'Maricopa County'\nORDER BY T2.\"Order Quantity\" ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1694": {
        "db_id": "restaurant",
        "question": "Indicate the street numbers where Aux Delices Vietnamese Restaurant are located.",
        "ground_truth": "SELECT DISTINCT T1.street_num FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.label = 'aux delices vietnamese restaurant'",
        "amends": [
            "Do select `street_num` from the `location` table instead of `street_number` from `restaurants`. Do join `generalinfo` as `T2` on `T1.id_restaurant = T2.id_restaurant` instead of querying a single table. Do filter on `T2.label = 'aux delices vietnamese restaurant'` with case-insensitive matching instead of `name = 'Aux Delices Vietnamese Restaurant'`. Do add `DISTINCT` to eliminate duplicates instead of omitting it. The amended query now correctly retrieves the street number by joining location and general information tables with proper case handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street_number FROM restaurants WHERE name = 'Aux Delices Vietnamese Restaurant';",
            "SELECT DISTINCT l.street_num FROM location l JOIN generalinfo g ON l.id_restaurant = g.id_restaurant WHERE LOWER(g.label) = 'aux delices vietnamese restaurant';"
        ],
        "rule_sql": []
    },
    "2116": {
        "db_id": "world_development_indicators",
        "question": "What is the short name of the country in which the \"Net bilateral aid flows from DAC donors, Sweden (current US$)\" indicator hit the 570,000 value in 1970?",
        "ground_truth": "SELECT T2.ShortName FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IndicatorName = 'Net bilateral aid flows FROM DAC donors, Sweden (current US$)' AND T1.Year = 1970 AND T1.Value = 570000",
        "amends": [
            "Do select `T2.ShortName` from the `Country` table instead of `short_name` from `countries`. Do join `Indicators AS T1` with `Country AS T2` using `INNER JOIN` on `T1.CountryCode = T2.CountryCode` instead of querying a single table. Do filter on `T1.IndicatorName` instead of `indicator`, keeping the same value condition. Do maintain the same `year` and `value` filters but apply them to the `T1` table instead of the original table. The amended query now correctly joins the indicator and country tables to retrieve the country name associated with specific indicator values, matching the RIGHT_SQL's behavior.",
            "Do use the exact string literal 'Net bilateral aid flows FROM DAC donors, Sweden (current US$)' with uppercase 'FROM' instead of 'Net bilateral aid flows from DAC donors, Sweden (current US$)' with lowercase 'from' in the WHERE clause filter on T1.IndicatorName. The amended query now correctly matches the RIGHT_SQL's behavior by preserving the exact case-sensitive indicator name as specified in the data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT short_name FROM countries WHERE indicator = 'Net bilateral aid flows from DAC donors, Sweden (current US$)' AND value = 570000 AND year = 1970;",
            "SELECT T2.ShortName\nFROM Indicators AS T1\nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T1.IndicatorName = 'Net bilateral aid flows from DAC donors, Sweden (current US$)'\nAND T1.Year = 1970\nAND T1.Value = 570000",
            "SELECT T2.ShortName\nFROM Indicators AS T1\nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T1.IndicatorName = 'Net bilateral aid flows FROM DAC donors, Sweden (current US$)'\nAND T1.Year = 1970\nAND T1.Value = 570000"
        ],
        "rule_sql": []
    },
    "2333": {
        "db_id": "movielens",
        "question": "Which actor has appeared in the most films?",
        "ground_truth": "SELECT actorid FROM movies2actors GROUP BY actorid ORDER BY COUNT(movieid) DESC LIMIT 1",
        "amends": [
            "Do reference `actorid` instead of `actor_id` and `movieid` instead of `film_id` in the SELECT list and aggregate function. Do use table `movies2actors` instead of `film_actor` as the FROM source. Do remove the alias `film_count` from the COUNT expression instead of keeping it. Do reference `movieid` in the ORDER BY clause instead of the removed alias `film_count`, and maintain the DESC ordering and LIMIT 1. The amended query now correctly identifies the actor with the most movie appearances using the proper table and column names.",
            "Do remove `COUNT(movieid)` from the SELECT list instead of including it, as the query only needs to return the actorid with the highest movie count rather than displaying the count value itself. Do maintain the `GROUP BY actorid` clause to aggregate by actor instead of omitting it. Do preserve the `ORDER BY COUNT(movieid) DESC` to sort by descending movie count instead of changing the ordering. Do keep the `LIMIT 1` to return only the top result instead of removing it. The amended query now correctly returns only the actorid with the highest number of movie appearances, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id, COUNT(film_id) as film_count FROM film_actor GROUP BY actor_id ORDER BY film_count DESC LIMIT 1;",
            "SELECT actorid, COUNT(movieid) FROM movies2actors GROUP BY actorid ORDER BY COUNT(movieid) DESC LIMIT 1;",
            "SELECT actorid FROM movies2actors GROUP BY actorid ORDER BY COUNT(movieid) DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "419": {
        "db_id": "movies_4",
        "question": "When was the release date of the latest movie in which Dariusz Wolski worked as a crew member?",
        "ground_truth": "SELECT T1.release_date FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T3.person_name = 'Dariusz Wolski' ORDER BY T1.release_date DESC LIMIT 1",
        "amends": [
            "Do join `movie` with `movie_crew` on `movie_id` instead of querying only the `movies` table. Do add a join to `person` on `person_id` instead of filtering directly on `crew_member`. Do filter on `person_name` instead of `crew_member` to properly identify the individual. Do select the actual `release_date` column instead of using `MAX()` aggregation. Do add `ORDER BY release_date DESC` with `LIMIT 1` instead of using `MAX()` to get the latest date. The amended query now correctly retrieves the most recent release date for movies involving Dariusz Wolski by properly joining through the relationship tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(release_date) FROM movies WHERE crew_member = 'Dariusz Wolski';",
            "SELECT m.release_date \nFROM movie m\nJOIN movie_crew mc ON m.movie_id = mc.movie_id\nJOIN person p ON mc.person_id = p.person_id\nWHERE p.person_name = 'Dariusz Wolski'\nORDER BY m.release_date DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "912": {
        "db_id": "cs_semester",
        "question": "Describe the students' full names and GPAs under the supervision of the most popular professor.",
        "ground_truth": "SELECT T3.f_name, T3.l_name, T3.gpa FROM prof AS T1 INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id ORDER BY T1.popularity DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `s` and `p`. Do select columns `f_name`, `l_name`, and `gpa` from `T3` instead of `first_name`, `last_name`, and `gpa` from `s`. Do join `prof AS T1` and `RA AS T2` on `T1.prof_id = T2.prof_id` instead of joining `students s` and `professors p` on `s.professor_id = p.professor_id`. Do add an additional `INNER JOIN` to `student AS T3` on `T2.student_id = T3.student_id` instead of omitting it. Do remove the `WHERE` clause with subquery instead of keeping it. Do add `ORDER BY T1.popularity DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the student details associated with the most popular professor based on the popularity column rather than using a subquery to find the professor with the most students."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.last_name, s.gpa \nFROM students s\nJOIN professors p ON s.professor_id = p.professor_id\nWHERE p.professor_id = (\n    SELECT professor_id \n    FROM students \n    GROUP BY professor_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)",
            "SELECT T3.f_name, T3.l_name, T3.gpa\nFROM prof AS T1\nINNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id\nINNER JOIN student AS T3 ON T2.student_id = T3.student_id\nORDER BY T1.popularity DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7231": {
        "db_id": "works_cycles",
        "question": "What is the total cost for all the orders placed on 5/29/2013?",
        "ground_truth": "SELECT SUM(TotalDue) FROM PurchaseOrderHeader WHERE OrderDate LIKE '2013-05-29%'",
        "amends": [
            "Do reference the correct table `PurchaseOrderHeader` instead of `orders`. Do use the correct column `TotalDue` for summation instead of `price`. Do use the correct date column `OrderDate` instead of `order_date`. Do employ a `LIKE` pattern match `'2013-05-29%'` to capture all orders from that date instead of exact equality `= '2013-05-29'` to properly handle datetime values that include time components. The amended query now correctly sums total due amounts for all purchase orders placed on May 29, 2013, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE order_date = '2013-05-29';",
            "SELECT SUM(TotalDue) AS TotalCost FROM PurchaseOrderHeader WHERE OrderDate LIKE '2013-05-29%';"
        ],
        "rule_sql": []
    },
    "3190": {
        "db_id": "donor",
        "question": "Among all the donors from New York, how many of them are teachers?",
        "ground_truth": "SELECT COUNT(donationid) FROM donations WHERE is_teacher_acct = 't' AND donor_city = 'New York'",
        "amends": [
            "Do count `donationid` instead of `*` to count specific non-null values. Do query the `donations` table instead of `donors` to access donation records. Do filter on `is_teacher_acct = 't'` instead of `occupation = 'teacher'` to use the correct teacher account flag. Do filter on `donor_city = 'New York'` instead of `state = 'New York'` to use city-level location data rather than state. The amended query now correctly counts teacher donations from New York city rather than attempting to count donors by state and occupation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM donors WHERE state = 'New York' AND occupation = 'teacher';",
            "SELECT COUNT(donationid) FROM donations WHERE donor_city = 'New York' AND is_teacher_acct = 't'"
        ],
        "rule_sql": []
    },
    "8333": {
        "db_id": "mondial_geo",
        "question": "Name all the volcano mountains between the height of 2000 to 4000.",
        "ground_truth": "SELECT Name FROM mountain WHERE Type = 'volcano' AND Height BETWEEN 2000 AND 4000",
        "amends": [
            "Do reference table `mountain` instead of `mountains` and use column names `Name`, `Type`, and `Height` instead of `name`, `type`, and `height` to match the correct schema. The amended query now correctly selects from the proper table with the appropriate column casing."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM mountains WHERE type = 'volcano' AND height BETWEEN 2000 AND 4000;",
            "SELECT Name FROM mountain WHERE Type = 'volcano' AND Height BETWEEN 2000 AND 4000;"
        ],
        "rule_sql": []
    },
    "7389": {
        "db_id": "works_cycles",
        "question": "What is the full name of the non-sales employee who made the most number of rejected purchase orders?",
        "ground_truth": "SELECT T2.FirstName, T2.LastName FROM PurchaseOrderHeader AS T1 INNER JOIN Person AS T2 ON T1.EmployeeID = T2.BusinessEntityID WHERE T2.PersonType = 'EM' AND T1.Status = 3 GROUP BY T2.FirstName, T2.LastName ORDER BY COUNT(T1.PurchaseOrderID) DESC LIMIT 1",
        "amends": [
            "Do select `FirstName` and `LastName` from `Person` instead of `first_name` and `last_name` from `employees`. Do join `PurchaseOrderHeader` with `Person` on `EmployeeID = BusinessEntityID` instead of joining `employees` with `purchase_orders` on `employee_id = employee_id`. Do filter with `PersonType = 'EM'` instead of `department != 'Sales'` and use `Status = 3` instead of `status = 'Rejected'`. Do group by `FirstName` and `LastName` instead of `employee_id`. The amended query now correctly identifies employees by their person type and uses proper status codes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.first_name, e.last_name\nFROM employees e\nJOIN purchase_orders po ON e.employee_id = po.employee_id\nWHERE e.department != 'Sales' AND po.status = 'Rejected'\nGROUP BY e.employee_id\nORDER BY COUNT(po.purchase_order_id) DESC\nLIMIT 1;",
            "SELECT p.FirstName, p.LastName\nFROM Person p\nJOIN Employee e ON p.BusinessEntityID = e.BusinessEntityID\nJOIN PurchaseOrderHeader poh ON e.BusinessEntityID = poh.EmployeeID\nWHERE p.PersonType = 'EM'\nAND poh.Status = 3\nGROUP BY p.FirstName, p.LastName\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6794": {
        "db_id": "retails",
        "question": "Indicate the name of the parts without discount.",
        "ground_truth": "SELECT T3.p_name FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T2.l_discount = 0.0000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM parts WHERE discount IS NULL;"
        ],
        "rule_sql": []
    },
    "6230": {
        "db_id": "food_inspection_2",
        "question": "List point level of inspections with no fine.",
        "ground_truth": "SELECT DISTINCT T1.point_level FROM inspection_point AS T1 INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE T2.fine = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT point_level FROM inspections WHERE fine IS NULL;"
        ],
        "rule_sql": []
    },
    "4549": {
        "db_id": "student_loan",
        "question": "Provide the name of disabled male students that are unemployed.",
        "ground_truth": "SELECT T2.NAME FROM unemployed AS T1 INNER JOIN male AS T2 ON T1.name = T2.name INNER JOIN disabled AS T3 ON T3.name = T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE gender = 'male' AND employment_status = 'unemployed' AND disability_status = 'disabled';"
        ],
        "rule_sql": []
    },
    "1642": {
        "db_id": "car_retails",
        "question": "Which is the most ordered quantity product? What is its expected profit margin per piece?",
        "ground_truth": "SELECT productName, MSRP - buyPrice FROM products WHERE productCode = ( SELECT productCode FROM orderdetails ORDER BY quantityOrdered DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, MAX(quantity) as max_quantity, (price - cost) as profit_margin FROM orders GROUP BY product_name ORDER BY max_quantity DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5724": {
        "db_id": "language_corpus",
        "question": "What is the pair of words that is repeated the most times? Identify them by their ID.",
        "ground_truth": "SELECT w1st, w2nd FROM biwords WHERE occurrences = ( SELECT MAX(occurrences) FROM biwords )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word1, word2, COUNT(*) as count FROM word_pairs GROUP BY word1, word2 ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4491": {
        "db_id": "student_loan",
        "question": "Define the gender of \"student995\" and his/her enrolled schools.",
        "ground_truth": "SELECT IIF(T2.name IS NULL, 'female', 'male') AS gen , T1.school FROM enrolled AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name WHERE T1.name = 'student995'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, school_name FROM students WHERE student_id = 'student995'"
        ],
        "rule_sql": []
    },
    "5968": {
        "db_id": "books",
        "question": "Who authored the book with greatest number of pages?",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id ORDER BY T1.num_pages DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM books ORDER BY pages DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7658": {
        "db_id": "hockey",
        "question": "Please list the awards the coaches who are born in Canada have won.",
        "ground_truth": "SELECT DISTINCT T2.award FROM Master AS T1 INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE T1.birthCountry = 'Canada'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT award_name FROM coaches WHERE country = 'Canada'"
        ],
        "rule_sql": []
    },
    "5616": {
        "db_id": "shipping",
        "question": "How many shipments did Holger Nohr transport to North Las Vegas overall?",
        "ground_truth": "SELECT COUNT(*) FROM driver AS T1 INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id INNER JOIN city AS T3 ON T3.city_id = T2.city_id WHERE T1.first_name = 'Holger' AND T1.last_name = 'Nohr' AND T3.city_name = 'North Las Vegas'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE transporter = 'Holger Nohr' AND destination = 'North Las Vegas';"
        ],
        "rule_sql": []
    },
    "1794": {
        "db_id": "soccer_2016",
        "question": "Among the players who use the right hand as their batting hand, how many of them were born after 1985?",
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T1.DOB, 1, 4) > 1985 THEN 1 ELSE 0 END) FROM Player AS T1 INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id WHERE T2.Batting_Hand = 'Right-hand bat'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE batting_hand = 'right' AND birth_year > 1985;"
        ],
        "rule_sql": []
    },
    "1789": {
        "db_id": "soccer_2016",
        "question": "For how many times has player no.41 won the \"man of the match\" award?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM `Match` WHERE Man_of_the_Match = 41",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE player_of_match = 41"
        ],
        "rule_sql": []
    },
    "4437": {
        "db_id": "student_loan",
        "question": "State name of unemployed students who have the longest duration of absense from school.",
        "ground_truth": "SELECT T1.name FROM longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name ORDER BY T1.month DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE employment_status = 'unemployed' ORDER BY absence_duration DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5024": {
        "db_id": "olympics",
        "question": "What is the game name that was held in Beijing in 2008?",
        "ground_truth": "SELECT T3.games_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T2.city_name = 'Beijing' AND T3.games_year = 2008",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM olympic_games WHERE city = 'Beijing' AND year = 2008;"
        ],
        "rule_sql": []
    },
    "1196": {
        "db_id": "talkingdata",
        "question": "Among the users who are above 20, how many users use device model of ELIFE E7 Mini?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'ELIFE E7 Mini' AND T1.age > 20",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age > 20 AND device_model = 'ELIFE E7 Mini';"
        ],
        "rule_sql": []
    },
    "5875": {
        "db_id": "airline",
        "question": "How many flights on the 1st of August 2018 were coming from Allentown, Pennsylvania?",
        "ground_truth": "SELECT COUNT(*) FROM Airlines WHERE FL_DATE = '2018/8/1' AND ORIGIN = 'ABE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE date = '2018-08-01' AND origin_city = 'Allentown' AND origin_state = 'Pennsylvania';"
        ],
        "rule_sql": []
    },
    "4940": {
        "db_id": "olympics",
        "question": "What is the percentage of male athletes from Estonia?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'M' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.person_id) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Estonia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN gender = 'Male' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male\nFROM athletes\nWHERE country = 'Estonia';"
        ],
        "rule_sql": []
    },
    "3982": {
        "db_id": "public_review_platform",
        "question": "Describe category name which had above 10% in comparing with all business and categories.",
        "ground_truth": "SELECT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id GROUP BY T2.category_id HAVING COUNT(T2.business_id) > ( SELECT COUNT(T3.business_id) FROM Business_Categories AS T3 ) * 0.1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category_name, COUNT(*) * 100.0 / (SELECT COUNT(*) FROM business) AS percentage FROM categories GROUP BY category_name HAVING percentage > 10 ORDER BY percentage DESC;"
        ],
        "rule_sql": []
    },
    "6950": {
        "db_id": "ice_hockey_draft",
        "question": "Among all players drafted by the Toronto Maple Leafs in 2008, identify the player with the highest prospects for the draft.",
        "ground_truth": "SELECT PlayerName FROM PlayerInfo WHERE overallby = 'Toronto Maple Leafs' AND draftyear = '2008' ORDER BY CSS_rank DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, MAX(draft_prospects) as highest_prospects\nFROM nhl_draft\nWHERE team = 'Toronto Maple Leafs' AND year = 2008\nGROUP BY player_name\nORDER BY highest_prospects DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6128": {
        "db_id": "food_inspection_2",
        "question": "How many restaurants were inspected on 2015/5/8?",
        "ground_truth": "SELECT COUNT(T2.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T2.inspection_date = '2015-05-08' AND T1.facility_type = 'Restaurant'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE inspection_date = '2015/5/8';"
        ],
        "rule_sql": []
    },
    "2369": {
        "db_id": "superstore",
        "question": "List the products ordered by Becky Martin around the Central region.",
        "ground_truth": "SELECT DISTINCT T3.`Product Name` FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T2.`Product ID` WHERE T1.`Customer Name` = 'Becky Martin' AND T3.Region = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name\nFROM products p\nJOIN orders o ON p.product_id = o.product_id\nJOIN customers c ON o.customer_id = c.customer_id\nJOIN regions r ON c.region_id = r.region_id\nWHERE c.customer_name = 'Becky Martin'\nAND r.region_name = 'Central'\nORDER BY p.product_name;"
        ],
        "rule_sql": []
    },
    "706": {
        "db_id": "trains",
        "question": "Trains that run in which direction have more rectangle-shaped cars in total?",
        "ground_truth": "SELECT T1.direction FROM trains AS T1 INNER JOIN ( SELECT train_id, COUNT(id) AS rectCarsNum FROM cars WHERE shape = 'rectangle' GROUP BY train_id ) AS T2 ON T1.id = T2.train_id ORDER BY T2.rectCarsNum DESC",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT direction, COUNT(*) as rectangle_cars \nFROM trains \nJOIN cars ON trains.train_id = cars.train_id \nWHERE car_shape = 'rectangle' \nGROUP BY direction \nORDER BY rectangle_cars DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1686": {
        "db_id": "restaurant",
        "question": "In how many counties is there a street called Appian Way?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.county) FROM location AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.street_name = 'appian way'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM streets WHERE street_name = 'Appian Way';"
        ],
        "rule_sql": []
    },
    "7995": {
        "db_id": "university",
        "question": "In 2014, what is the name of the university which was considered a leader in the publications rank?",
        "ground_truth": "SELECT T3.university_name FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE T1.criteria_name = 'Publications Rank' AND T2.year = 2014 AND T1.id = 17 ORDER BY T2.score DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM universities WHERE year = 2014 AND publications_rank = 'leader';"
        ],
        "rule_sql": []
    },
    "5760": {
        "db_id": "language_corpus",
        "question": "How many times that the word pair of \"barcelona\" and \"precolombina\" occur?",
        "ground_truth": "SELECT SUM(occurrences) FROM biwords WHERE w1st = ( SELECT wid FROM words WHERE word = 'barcelona' ) AND w2nd = ( SELECT wid FROM words WHERE word = 'precolombina' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM text_table WHERE text LIKE '%barcelona%' OR text LIKE '%precolombina%';"
        ],
        "rule_sql": []
    },
    "5099": {
        "db_id": "address",
        "question": "How many post offices are there in New York?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.zip_code) FROM state AS T1 INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE T1.abbreviation = 'NY' AND T2.type = 'Post Office'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM post_offices WHERE state = 'California';"
        ],
        "rule_sql": []
    },
    "2889": {
        "db_id": "professional_basketball",
        "question": "List the full name and age of the player when he won the \"Finals MVP\" in 2003.",
        "ground_truth": "SELECT T1.firstName, T1.middleName, T1.lastName , 2003 - strftime('%Y', T1.birthDate) FROM awards_players AS T2 JOIN players AS T1 ON T2.playerID = T1.playerID WHERE T2.award = 'Finals MVP' AND T2.year = 2003",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM players WHERE award = 'Finals MVP' AND year = 2003;"
        ],
        "rule_sql": []
    },
    "3904": {
        "db_id": "public_review_platform",
        "question": "Find out which business is opened for 24/7 and list out what is the business attribute.",
        "ground_truth": "SELECT T5.attribute_name FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id INNER JOIN Business_Attributes AS T4 ON T3.business_id = T4.business_id INNER JOIN Attributes AS T5 ON T4.attribute_id = T5.attribute_id WHERE T2.day_id LIKE '1' AND '2' AND '3' AND '4' AND '5' AND '6' AND '7' AND T1.opening_time = T1.closing_time GROUP BY T5.attribute_name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_name, attribute_name \nFROM businesses b\nJOIN business_attributes ba ON b.business_id = ba.business_id\nWHERE b.hours = '24/7'\nORDER BY business_name;"
        ],
        "rule_sql": []
    },
    "515": {
        "db_id": "movies_4",
        "question": "Calculate the revenues made by Fantasy Films and Live Entertainment.",
        "ground_truth": "SELECT SUM(T3.revenue) FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name IN ('Fantasy Films', 'Live Entertainment')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(revenue) FROM companies WHERE company_name = 'Fantasy Films' OR company_name = 'Live Entertainment';"
        ],
        "rule_sql": []
    },
    "6830": {
        "db_id": "retails",
        "question": "Which nation does the supplier with the account balance of \"4393.04\" belong to?",
        "ground_truth": "SELECT T2.n_name FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal = 4393.04",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n_name FROM nation WHERE s_acctbal = '4393.04'"
        ],
        "rule_sql": []
    },
    "6908": {
        "db_id": "retails",
        "question": "What are the names of the parts that have a part supply cost of at least 1,000?",
        "ground_truth": "SELECT T1.p_name FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE T2.ps_supplycost > 1000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM parts WHERE supply_cost > 1000;"
        ],
        "rule_sql": []
    },
    "2151": {
        "db_id": "world_development_indicators",
        "question": "Mention the series code of countries using Hong Kong dollar as their currency unit.",
        "ground_truth": "SELECT T2.SeriesCode FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.CurrencyUnit = 'Hong Kong dollar'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_code FROM countries WHERE currency_unit = 'Hong Kong dollar';"
        ],
        "rule_sql": []
    },
    "5214": {
        "db_id": "address",
        "question": "Give the alias of the cities with an Asian population of 7.",
        "ground_truth": "SELECT T1.alias FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.asian_population = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_alias FROM cities WHERE asian_population = 7;"
        ],
        "rule_sql": []
    },
    "4998": {
        "db_id": "olympics",
        "question": "What is the average age of the athletes from the United States of America who competed in the 2016 Summer Olympics?",
        "ground_truth": "SELECT AVG(T2.age) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person_region AS T3 ON T2.person_id = T3.person_id INNER JOIN noc_region AS T4 ON T3.region_id = T4.id WHERE T1.games_name = '2016 Summer' AND T4.region_name = 'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM athletes WHERE country = 'United States of America' AND olympics = '2016 Summer Olympics';"
        ],
        "rule_sql": []
    },
    "8147": {
        "db_id": "sales_in_weather",
        "question": "How many units of item no.5 were sold in store no.3 on the day the temperature range was the biggest?",
        "ground_truth": "SELECT t2.units FROM relation AS T1 INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T1.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND T2.item_nbr = 5 ORDER BY t3.tmax - t3.tmin DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) \nFROM sales \nWHERE item_id = 5 \nAND store_id = 3 \nAND date = (SELECT date FROM weather ORDER BY (max_temp - min_temp) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "2429": {
        "db_id": "superstore",
        "question": "How many orders with a quantity greater than 5 have been shipped by the fastest delivery method?",
        "ground_truth": "SELECT COUNT(DISTINCT `Order ID`) FROM central_superstore WHERE Quantity > 5 AND `Ship Mode` = 'First Class'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE quantity > 5 AND delivery_method = 'Fastest' AND status = 'shipped';"
        ],
        "rule_sql": []
    },
    "6656": {
        "db_id": "retail_world",
        "question": "Mention the first name of employee who took care the order id 10250.",
        "ground_truth": "SELECT T1.FirstName, T1.LastName FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE T2.OrderID = 10250",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE order_id = 10250"
        ],
        "rule_sql": []
    },
    "2200": {
        "db_id": "world_development_indicators",
        "question": "Which country has the lowest percentage of arable land?",
        "ground_truth": "SELECT CountryName FROM Indicators WHERE IndicatorName LIKE 'Arable land (% of land area)' ORDER BY Value DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, MIN(arable_land_percentage) FROM countries;"
        ],
        "rule_sql": []
    },
    "5469": {
        "db_id": "sales",
        "question": "Find and list the products that sold below the average quantity.",
        "ground_truth": "SELECT DISTINCT T2.Name FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Quantity < ( SELECT AVG(Quantity) FROM Sales )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, quantity FROM sales WHERE quantity > (SELECT AVG(quantity) FROM sales)"
        ],
        "rule_sql": []
    },
    "2959": {
        "db_id": "shakespeare",
        "question": "How many paragraphs are there in Act 1, Scene 1 in Twelfth Night?",
        "ground_truth": "SELECT SUM(T3.ParagraphNum) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id WHERE T2.Act = 1 AND T2.Scene = 1 AND T1.Title = 'Twelfth Night'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE act = 1 AND scene = 1 AND play = 'Twelfth Night';"
        ],
        "rule_sql": []
    },
    "5829": {
        "db_id": "airline",
        "question": "How many flights on 2018/8/1 were operated by American Airlines Inc.?",
        "ground_truth": "SELECT COUNT(*) FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN `Air Carriers` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE T2.FL_DATE = '2018/8/1' AND T3.Description = 'American Airlines Inc.: AA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE date = '2018/8/1' AND carrier = 'American Airlines Inc.'"
        ],
        "rule_sql": []
    },
    "8759": {
        "db_id": "chicago_crime",
        "question": "Among the crimes with no arrest made, how many of them happened in the ward represented by alderman Pat Dowell?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.alderman_last_name = 'Dowell' THEN 1 ELSE 0 END) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.arrest = 'FALSE' AND T1.alderman_first_name = 'Pat'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM crimes \nWHERE arrest = 'false' \nAND ward = 'Pat Dowell';"
        ],
        "rule_sql": []
    },
    "3881": {
        "db_id": "public_review_platform",
        "question": "List down the business ID with a star range from 2 to 3, located at Mesa.",
        "ground_truth": "SELECT business_id FROM Business WHERE city LIKE 'Mesa' AND stars BETWEEN 2 AND 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE stars BETWEEN 2 AND 3 AND city = 'Mesa';"
        ],
        "rule_sql": []
    },
    "2730": {
        "db_id": "regional_sales",
        "question": "What is the amount of discount applied to the product with the highest net profit and what is the name of the said product?",
        "ground_truth": "SELECT T1.`Unit Price` * T1.`Discount Applied`, T2.`Product Name` FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID ORDER BY REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '') DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, discount_amount \nFROM products \nORDER BY net_profit DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2024": {
        "db_id": "soccer_2016",
        "question": "How many matches did team Kings XI Punjab win in season year 2008?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.Match_Id) FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner INNER JOIN Player_Match AS T3 ON T1.Team_Id = T3.Team_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id WHERE T1.Team_Name = 'Kings XI Punjab' AND T4.Season_Year = 2008",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE team1 = 'Kings XI Punjab' AND season = 2008;"
        ],
        "rule_sql": []
    },
    "5126": {
        "db_id": "address",
        "question": "Name both the alias and the bad alias of zip code 38015.",
        "ground_truth": "SELECT T1.alias, T2.bad_alias FROM alias AS T1 INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE T1.zip_code = 38015",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT alias, bad_alias FROM zip_codes WHERE zip_code = 38015;"
        ],
        "rule_sql": []
    },
    "8452": {
        "db_id": "mondial_geo",
        "question": "Which nations have a boundary with the Kalahari Desert?",
        "ground_truth": "SELECT T3.Name FROM desert AS T1 INNER JOIN geo_desert AS T2 ON T1.Name = T2.Desert INNER JOIN country AS T3 ON T3.Code = T2.Country WHERE T1.Name = 'Kalahari'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE desert_name = 'Kalahari Desert';"
        ],
        "rule_sql": []
    },
    "7866": {
        "db_id": "world",
        "question": "What city in Russia has the least population?",
        "ground_truth": "SELECT T2.Name FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Russian Federation' ORDER BY T2.Population ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities WHERE country = 'Russia' ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8210": {
        "db_id": "sales_in_weather",
        "question": "What is the ratio of the highest and lowest temperature in store 11?",
        "ground_truth": "SELECT CAST((MAX(T1.tmax) - MIN(T1.tmin)) AS REAL) / MIN(T1.tmin) FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T2.store_nbr = 11",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(temperature) / MIN(temperature) FROM store_data WHERE store_id = 11;"
        ],
        "rule_sql": []
    },
    "5186": {
        "db_id": "address",
        "question": "What is the name of the state with the most counties?",
        "ground_truth": "SELECT T1.name FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state GROUP BY T2.state ORDER BY COUNT(T2.county) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state_name FROM states ORDER BY COUNT(county_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1169": {
        "db_id": "talkingdata",
        "question": "Provide the number of events participated by the device users at coordinates of (80,37).",
        "ground_truth": "SELECT COUNT(event_id) FROM events WHERE longitude = 80 AND latitude = 37",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE device_id IN (SELECT id FROM devices WHERE x_coordinate = 80 AND y_coordinate = 37);"
        ],
        "rule_sql": []
    },
    "4158": {
        "db_id": "simpson_episodes",
        "question": "Which crew member of the simpson 20s is the oldest?",
        "ground_truth": "SELECT name FROM Person WHERE birthdate IS NOT NULL ORDER BY birthdate ASC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM crew_members WHERE show = 'The Simpsons' AND decade = '20s' ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3598": {
        "db_id": "authors",
        "question": "List the names of authors affiliated with the University of Oxford in alphabetical order.",
        "ground_truth": "SELECT Name FROM Author WHERE Affiliation = 'University of Oxford' ORDER BY Name ASC",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM authors WHERE affiliation = 'University of Oxford' ORDER BY name DESC;"
        ],
        "rule_sql": []
    },
    "5042": {
        "db_id": "olympics",
        "question": "What is the percentage of the people who are under 35 and participated in the summer season?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.age < 35 THEN 1 END) AS REAL) * 100 / COUNT(T2.games_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Summer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM people WHERE age < 35)) AS percentage FROM participants WHERE season = 'summer'"
        ],
        "rule_sql": []
    },
    "4991": {
        "db_id": "olympics",
        "question": "How many times was Larysa Semenivna Latynina (Diriy-) declared as champion in Gymnastics Women's Individual All-Around?",
        "ground_truth": "SELECT COUNT(T1.id) FROM event AS T1 INNER JOIN competitor_event AS T2 ON T1.id = T2.event_id INNER JOIN games_competitor AS T3 ON T2.competitor_id = T3.id INNER JOIN person AS T4 ON T3.person_id = T4.id WHERE T4.full_name = 'Larysa Semenivna Latynina (Diriy-)' AND T1.event_name LIKE 'Gymnastics Women%s Individual All-Around' AND T2.medal_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE name = 'Larysa Semenivna Latynina (Diriy-)' AND sport = 'Gymnastics' AND event = 'Women''s Individual All-Around' AND medal = 'Gold';"
        ],
        "rule_sql": []
    },
    "8687": {
        "db_id": "chicago_crime",
        "question": "Find the community area where the least number of domestic crimes happened.",
        "ground_truth": "SELECT T2.community_area_no FROM Crime AS T1 INNER JOIN Community_Area AS T2 ON T2.community_area_no = T1.community_area_no WHERE T1.domestic = 'TRUE' GROUP BY T2.community_area_no ORDER BY COUNT(T2.community_area_no) ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_area, COUNT(*) as crime_count FROM crimes WHERE crime_type = 'domestic' GROUP BY community_area ORDER BY crime_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5909": {
        "db_id": "airline",
        "question": "Among the flights with air carrier \"Southwest Airlines Co.: WN\", provide the tail number of flights with an actual elapsed time lower than the 80% of the average actual elapsed time of listed flights.",
        "ground_truth": "SELECT T2.TAIL_NUM FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Southwest Airlines Co.: WN' AND T2.ACTUAL_ELAPSED_TIME < ( SELECT AVG(ACTUAL_ELAPSED_TIME) * 0.8 FROM Airlines )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Tail_Number \nFROM flights \nWHERE Air_Carrier = 'Southwest Airlines Co.: WN' \nAND Actual_Elapsed_Time < (SELECT AVG(Actual_Elapsed_Time) * 0.8 FROM flights);"
        ],
        "rule_sql": []
    },
    "4772": {
        "db_id": "legislator",
        "question": "How many times did Richard Durbin become a legislator in district 20?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.district = 20 THEN 1 ELSE 0 END) AS count FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.first_name = 'Richard' AND T1.last_name = 'Durbin'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE name = 'Richard Durbin' AND district = 20;"
        ],
        "rule_sql": []
    },
    "456": {
        "db_id": "movies_4",
        "question": "How many animators does Movie No. 129 have?",
        "ground_truth": "SELECT COUNT(movie_id) FROM movie_crew WHERE movie_id = 129 AND job = 'Animation'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM animators WHERE movie_id = 129;"
        ],
        "rule_sql": []
    },
    "1359": {
        "db_id": "synthea",
        "question": "According to the observation on 2008/3/11, what was the height of Elly Koss?",
        "ground_truth": "SELECT T2.value, T2.units FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.date = '2008-03-11' AND T2.description = 'Body Height'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT height FROM observations WHERE name = 'Elly Koss' AND date = '2008/3/11';"
        ],
        "rule_sql": []
    },
    "7919": {
        "db_id": "music_platform_2",
        "question": "What is the percentage of the podcast that are categorized in four or more categories?",
        "ground_truth": "SELECT COUNT(T1.podcast_id) FROM ( SELECT podcast_id FROM categories GROUP BY podcast_id HAVING COUNT(category) >= 4 ) AS T1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM podcasts)) AS percentage\nFROM \n    podcasts\nWHERE \n    (SELECT COUNT(*) FROM podcast_categories WHERE podcast_id = podcasts.id) >= 4;"
        ],
        "rule_sql": []
    },
    "4132": {
        "db_id": "public_review_platform",
        "question": "Among the active businesses located at Goodyear, AZ, list the category and atrributes of business with a high review count.",
        "ground_truth": "SELECT T3.category_name, T5.attribute_name FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id INNER JOIN Business_Attributes AS T4 ON T1.business_id = T4.business_id INNER JOIN Attributes AS T5 ON T4.attribute_id = T5.attribute_id WHERE T1.review_count = 'High' AND T1.city = 'Goodyear' AND T1.state = 'AZ' AND T1.active = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, attributes FROM businesses WHERE city = 'Goodyear' AND state = 'AZ' AND is_active = 1 ORDER BY review_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3270": {
        "db_id": "donor",
        "question": "How many resources with a unit price less than 15 are not technology type? List them by vendor id",
        "ground_truth": "SELECT vendorid FROM resources WHERE project_resource_type = 'Technology' AND item_unit_price <= 15",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_id, COUNT(*) \nFROM resources \nWHERE unit_price < 15 AND type = 'technology' \nGROUP BY vendor_id"
        ],
        "rule_sql": []
    },
    "8103": {
        "db_id": "university",
        "question": "Calculate the number of international students of University of Wisconsin-Madison in 2013.",
        "ground_truth": "SELECT CAST(T1.num_students * T1.pct_international_students AS REAL) / 100 FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2013 AND T2.university_name = 'University of Wisconsin-Madison'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university = 'University of Wisconsin-Madison' AND year = 2013 AND nationality != 'USA';"
        ],
        "rule_sql": []
    },
    "1468": {
        "db_id": "synthea",
        "question": "In 2010, how many single patients took Nitrofurantoin 5 mg/ML [Furadantin] to cure cystitis?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.marital = 'S' AND T2.REASONDESCRIPTION = 'Cystitis' AND T2.DESCRIPTION = 'Nitrofurantoin 5 MG/ML [Furadantin]' AND strftime('%Y', T2.START) = '2010'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients \nWHERE year = 2010 \nAND marital_status = 'single' \nAND medication = 'Nitrofurantoin 5 mg/ML [Furadantin]' \nAND condition = 'cystitis'"
        ],
        "rule_sql": []
    },
    "4537": {
        "db_id": "student_loan",
        "question": "How many students have absent from school?",
        "ground_truth": "SELECT COUNT(name) FROM longest_absense_from_school WHERE month > 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE attendance_status = 'present';"
        ],
        "rule_sql": []
    },
    "1202": {
        "db_id": "talkingdata",
        "question": "How many different models does the HTC brand have?",
        "ground_truth": "SELECT COUNT(device_model) FROM phone_brand_device_model2 WHERE phone_brand = 'HTC'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE brand = 'HTC';"
        ],
        "rule_sql": []
    },
    "1821": {
        "db_id": "soccer_2016",
        "question": "How many matches were played on May 2008?",
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(Match_Date, 7, 1) = '5' THEN 1 ELSE 0 END) FROM `Match` WHERE SUBSTR(Match_Date, 1, 4) = '2008'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE month = 'May' AND year = 2008;"
        ],
        "rule_sql": []
    },
    "9416": {
        "db_id": "movie_3",
        "question": "What is the address of Mary Smith?",
        "ground_truth": "SELECT T1.address FROM address AS T1 INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE T2.first_name = 'MARY' AND T2.last_name = 'SMITH'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM users WHERE first_name = 'Mary' AND last_name = 'Smith';"
        ],
        "rule_sql": []
    },
    "2986": {
        "db_id": "shakespeare",
        "question": "What is the title of the first ever work of William Shakespeare?",
        "ground_truth": "SELECT Title FROM works WHERE Date = ( SELECT MIN(Date) FROM works )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM works WHERE author = 'William Shakespeare' ORDER BY publication_year ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6710": {
        "db_id": "retails",
        "question": "When was the order with the highest amount of total price shipped?",
        "ground_truth": "SELECT T2.l_shipdate FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY T1.o_totalprice DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shipped_date FROM orders ORDER BY total_price ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "840": {
        "db_id": "social_media",
        "question": "What is the total number of tweets sent by male users on Mondays?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.TweetID) FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T2.Gender = 'Male' AND T1.Weekday = 'Monday'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets t JOIN users u ON t.user_id = u.user_id WHERE u.gender = 'male' AND strftime('%w', t.created_at) = '1';"
        ],
        "rule_sql": []
    },
    "5945": {
        "db_id": "books",
        "question": "What is the full name of the customer who owns the \"aalleburtonkc@yellowbook.com\" e-mail address?",
        "ground_truth": "SELECT first_name, last_name FROM customer WHERE email = 'aalleburtonkc@yellowbook.com'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE email = 'aalleburtonkc@yellowbook.com';"
        ],
        "rule_sql": []
    },
    "3771": {
        "db_id": "public_review_platform",
        "question": "In which year did the user who has given the most number of \"short\" tips join the Yelp?",
        "ground_truth": "SELECT T2.user_yelping_since_year FROM Tips AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE T1.tip_length LIKE 'short' GROUP BY T2.user_yelping_since_year ORDER BY COUNT(T1.tip_length) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.yelping_since_year \nFROM user u\nJOIN tip t ON u.user_id = t.user_id\nWHERE t.tip_text LIKE '%short%'\nGROUP BY u.user_id\nORDER BY COUNT(t.tip_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2928": {
        "db_id": "professional_basketball",
        "question": "What is the number of NBA titles that Ray Allen has won throughout his NBA career?",
        "ground_truth": "SELECT COUNT(T1.playerID) FROM player_allstar AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE first_name = 'Ray' AND last_name = 'Allen'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM nba_titles WHERE player_name = 'Ray Allen';"
        ],
        "rule_sql": []
    },
    "9304": {
        "db_id": "movie_3",
        "question": "How many of the actors are named \"Dan\"?",
        "ground_truth": "SELECT COUNT(actor_id) FROM actor WHERE first_name = 'Dan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors WHERE first_name = 'Dan';"
        ],
        "rule_sql": []
    },
    "1831": {
        "db_id": "soccer_2016",
        "question": "What is the name of the team that won the most number of matches in season 1?",
        "ground_truth": "SELECT Team_Name FROM Team WHERE Team_Id = ( SELECT Match_Winner FROM `Match` WHERE season_Id = 1 GROUP BY Match_Winner ORDER BY COUNT(Match_Winner) DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE season = 1 GROUP BY team_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7949": {
        "db_id": "music_platform_2",
        "question": "What is the rating and category of the podcast entitled Sitcomadon?",
        "ground_truth": "SELECT DISTINCT T3.rating, T1.category FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id INNER JOIN reviews AS T3 ON T3.podcast_id = T2.podcast_id WHERE T2.title = 'Sitcomadon'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating, category FROM podcasts WHERE title = 'Sitcomadon';"
        ],
        "rule_sql": []
    },
    "3743": {
        "db_id": "college_completion",
        "question": "In year 2010 at schools located in Hawaii, what is the percentage of schools offers an associate's degree?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.level = '2-year' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.level) FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T2.state = 'Hawaii' AND T2.year = 2010",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN degree_offered = 'Associate' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM schools\nWHERE year = 2010 AND state = 'Hawaii';"
        ],
        "rule_sql": []
    },
    "3491": {
        "db_id": "video_games",
        "question": "List down the game platform ID and region name where the games achieved 20000 sales and below.",
        "ground_truth": "SELECT T2.game_platform_id, T1.region_name FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T2.num_sales * 100000 <= 20000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform_id, region_name FROM sales WHERE sales > 20000"
        ],
        "rule_sql": []
    },
    "5167": {
        "db_id": "address",
        "question": "List the bad alias of the postal point located in Camuy.",
        "ground_truth": "SELECT T1.bad_alias FROM avoid AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.city = 'Camuy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bad_alias FROM postal_points WHERE location = 'Camuy';"
        ],
        "rule_sql": []
    },
    "5218": {
        "db_id": "address",
        "question": "Count the number of postal points in the district represented by Kirkpatrick Ann.",
        "ground_truth": "SELECT COUNT(T2.zip_code) FROM congress AS T1 INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district WHERE T1.first_name = 'Kirkpatrick' AND T1.last_name = 'Ann'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM postal_points WHERE district = 'Kirkpatrick Ann';"
        ],
        "rule_sql": []
    },
    "1996": {
        "db_id": "soccer_2016",
        "question": "What is the venue for the match ID 829768?",
        "ground_truth": "SELECT T1.Venue_Name FROM Venue AS T1 INNER JOIN Match AS T2 ON T1.venue_id = T2.venue_id WHERE T2.match_id = 829768",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue FROM matches WHERE match_id = '829768';"
        ],
        "rule_sql": []
    },
    "2184": {
        "db_id": "world_development_indicators",
        "question": "Which country have the highest CO2 emissions in 1960?",
        "ground_truth": "SELECT CountryName FROM Indicators WHERE Year = 1960 AND IndicatorName = 'CO2 emissions (metric tons per capita)' ORDER BY Value DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM co2_emissions WHERE year = 1960 ORDER BY emissions ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7493": {
        "db_id": "image_and_language",
        "question": "Provide the number of predicted classes.",
        "ground_truth": "SELECT COUNT(PRED_CLASS_ID) FROM PRED_CLASSES",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM predictions WHERE class IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1295": {
        "db_id": "law_episode",
        "question": "List the names of all the cast members in the series.",
        "ground_truth": "SELECT T2.name FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T1.category = 'Cast'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM series WHERE role = 'cast_member';"
        ],
        "rule_sql": []
    },
    "5435": {
        "db_id": "sales",
        "question": "In customers with the first name of Erica, how many of them bought a quantity below 200?",
        "ground_truth": "SELECT COUNT(T1.ProductID) FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.FirstName = 'Erica' AND T1.Quantity < 200",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE c.first_name = 'Erica' AND o.quantity > 200;"
        ],
        "rule_sql": []
    },
    "6242": {
        "db_id": "food_inspection_2",
        "question": "What is the category of the inspection of the establishment named \"J & J FOOD\"?",
        "ground_truth": "SELECT DISTINCT T4.category FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE T1.dba_name = 'J & J FOOD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM inspections WHERE establishment_name = 'J & J FOOD';"
        ],
        "rule_sql": []
    },
    "3741": {
        "db_id": "college_completion",
        "question": "In female students in year 2012, how many of them from a state with number of schools ranges from 10 to 20?",
        "ground_truth": "SELECT COUNT(T2.race) FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T2.gender = 'F' AND schools_count BETWEEN 10 AND 20 AND T2.year = 2012",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students \nWHERE gender = 'female' \nAND year = 2012 \nAND state IN (\n    SELECT state \n    FROM schools \n    GROUP BY state \n    HAVING COUNT(*) BETWEEN 10 AND 20\n)"
        ],
        "rule_sql": []
    },
    "7756": {
        "db_id": "hockey",
        "question": "Please list the first 3 teams that got the most penalty minutes in 2006.",
        "ground_truth": "SELECT name FROM Teams WHERE year = 2006 GROUP BY tmID, name ORDER BY SUM(PIM) DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, SUM(penalty_minutes) as total_penalty_minutes \nFROM games \nWHERE year = 2006 \nGROUP BY team_name \nORDER BY total_penalty_minutes DESC \nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "592": {
        "db_id": "codebase_comments",
        "question": "What is the github address of the repository that contains files used by solution ID12?",
        "ground_truth": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 12",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT github_address FROM repositories WHERE solution_id = 12;"
        ],
        "rule_sql": []
    },
    "2018": {
        "db_id": "soccer_2016",
        "question": "Which teams did SC Ganguly join in season year 2008?",
        "ground_truth": "SELECT T5.Team_Name FROM Player AS T1 INNER JOIN Match AS T2 ON T1.Player_Id = T2.Man_of_the_Match INNER JOIN Player_Match AS T3 ON T3.Player_Id = T1.Player_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id INNER JOIN Team AS T5 ON T3.Team_Id = T5.Team_Id WHERE T4.Season_Year = 2008 AND T1.Player_Name = 'SC Ganguly' GROUP BY T5.Team_Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE player_name = 'SC Ganguly' AND season_year = 2008;"
        ],
        "rule_sql": []
    },
    "8169": {
        "db_id": "sales_in_weather",
        "question": "Provide the sunrise time recorded by the home weather station of store no.30 on 2014/2/21.",
        "ground_truth": "SELECT T1.sunrise FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T1.`date` = '2014-02-21' AND store_nbr = 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sunrise_time FROM weather_stations WHERE store_id = 30 AND date = '2014-02-21';"
        ],
        "rule_sql": []
    },
    "7271": {
        "db_id": "works_cycles",
        "question": "What is the full name of the second oldest person in the company at the time he was hired?",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1, 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY age DESC LIMIT 1 OFFSET 1;"
        ],
        "rule_sql": []
    },
    "3298": {
        "db_id": "donor",
        "question": "What is the name of the vendor that the project \"Bloody Times\" uses for their resources?",
        "ground_truth": "SELECT T3.vendor_name FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN resources AS T3 ON T2.projectid = T3.projectid WHERE T1.title = 'Bloody Times'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name FROM vendors WHERE project_name = 'Bloody Times';"
        ],
        "rule_sql": []
    },
    "3539": {
        "db_id": "authors",
        "question": "In papers with journal IDs from 200 to 300 and with its short name starts with A, what is the percentage of papers with conference ID of 0?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.ConferenceId = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ConferenceId) FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE T1.JournalId BETWEEN 200 AND 300 AND T2.ShortName LIKE 'A%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN conference_id = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM papers\nWHERE journal_id BETWEEN 200 AND 300\nAND short_name LIKE 'A%';"
        ],
        "rule_sql": []
    },
    "5350": {
        "db_id": "beer_factory",
        "question": "What is the percentage of female customers who subscribed to the email list?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN Gender = 'F' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(SubscribedToEmailList) FROM customers WHERE SubscribedToEmailList = 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM customers WHERE gender = 'Female')) AS percentage FROM customers WHERE subscribed_to_email = 1 AND gender = 'Male';"
        ],
        "rule_sql": []
    },
    "2033": {
        "db_id": "soccer_2016",
        "question": "What is the average of Indian players that were born between 1975 and 1985 among all players?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Country_Name = 'India' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Player_Id) FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_ID WHERE strftime('%Y', T1.DOB) BETWEEN '1975' AND '1985'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(CASE WHEN nationality = 'Indian' AND birth_year BETWEEN 1975 AND 1985 THEN 1 ELSE 0 END) FROM players;"
        ],
        "rule_sql": []
    },
    "6894": {
        "db_id": "retails",
        "question": "What is the profit for part no.98768 in order no.1?",
        "ground_truth": "SELECT T1.l_extendedprice * (1 - T1.l_discount) - T2.ps_supplycost * T1.l_quantity FROM lineitem AS T1 INNER JOIN partsupp AS T2 ON T1.l_suppkey = T2.ps_suppkey WHERE T1.l_orderkey = 1 AND T1.l_partkey = 98768",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity * price) AS profit FROM order_details WHERE part_no = 98768 AND order_no = 1;"
        ],
        "rule_sql": []
    },
    "1089": {
        "db_id": "talkingdata",
        "question": "Among all the times event no.2 happened when the app user was not active, when was the earliest time this situation happened?",
        "ground_truth": "SELECT T2.timestamp FROM app_events AS T1 INNER JOIN events AS T2 ON T2.event_id = T1.event_id WHERE T1.is_active = 0 AND T2.event_id = 2 ORDER BY T2.timestamp LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(event_time) FROM events WHERE event_no = 2 AND user_active = 1;"
        ],
        "rule_sql": []
    },
    "2439": {
        "db_id": "superstore",
        "question": "How many furniture products had been shipped by standard class in the East superstore?",
        "ground_truth": "SELECT COUNT(T2.Category) FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.`Ship Mode` = 'Standard Class'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE product_category = 'Furniture' AND shipping_mode = 'Standard Class' AND region = 'East';"
        ],
        "rule_sql": []
    },
    "4873": {
        "db_id": "legislator",
        "question": "How many Jewish legislators do not have facebook?",
        "ground_truth": "SELECT COUNT(T3.bioguide_id) FROM ( SELECT T1.bioguide_id FROM current AS T1 INNER JOIN `social-media` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.facebook IS NULL GROUP BY T1.bioguide_id ) T3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE religion = 'Jewish' AND facebook IS NULL;"
        ],
        "rule_sql": []
    },
    "3416": {
        "db_id": "video_games",
        "question": "How many games did BMG Interactive Entertainment release in 2012?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.game_id) FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id WHERE T3.release_year = 2012",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE publisher = 'BMG Interactive Entertainment' AND release_year = 2013;"
        ],
        "rule_sql": []
    },
    "296": {
        "db_id": "retail_complains",
        "question": "In which region have the most 1-star reviews been done?",
        "ground_truth": "SELECT T3.Region FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T2.state_abbrev = T3.StateCode WHERE T1.Stars = 1 GROUP BY T3.Region ORDER BY COUNT(T3.Region) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as review_count FROM reviews WHERE rating = 1 GROUP BY region ORDER BY review_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "248": {
        "db_id": "retail_complains",
        "question": "What is the full name of the client whose complaint on 2017/3/27 was received by MICHAL?",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T2.`Date received` = '2017-03-27' AND T2.server = 'MICHAL'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name FROM clients WHERE complaint_date = '2017/3/27' AND received_by = 'MICHAL';"
        ],
        "rule_sql": []
    },
    "1742": {
        "db_id": "restaurant",
        "question": "How many cities are located in the Bay Area?",
        "ground_truth": "SELECT COUNT(city) FROM geographic WHERE region = 'bay area'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE region = 'Bay Area';"
        ],
        "rule_sql": []
    },
    "5726": {
        "db_id": "language_corpus",
        "question": "Calculate the average number of different words that appear on all pages whose title begins with A.",
        "ground_truth": "SELECT AVG(words) FROM pages WHERE title LIKE 'A%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(DISTINCT word)) FROM words JOIN pages ON words.page_id = pages.id WHERE pages.title LIKE 'A%'"
        ],
        "rule_sql": []
    },
    "1660": {
        "db_id": "car_retails",
        "question": "How many transactions payment made by customer that is lower than 10000. Group the result by year.",
        "ground_truth": "SELECT STRFTIME('%Y', t1.paymentDate), COUNT(t1.customerNumber) FROM payments AS t1 WHERE t1.amount < 10000 GROUP BY STRFTIME('%Y', t1.paymentDate)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT YEAR(transaction_date) as year, COUNT(*) as transaction_count\nFROM transactions\nWHERE payment_amount > 10000\nGROUP BY YEAR(transaction_date)"
        ],
        "rule_sql": []
    },
    "7448": {
        "db_id": "works_cycles",
        "question": "With 100$, how many Cable Lock can you buy?",
        "ground_truth": "SELECT 100 / T2.ListPrice FROM Product AS T1 INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Cable Lock'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT 100 / price AS quantity FROM products WHERE name = 'Cable Lock';"
        ],
        "rule_sql": []
    },
    "9": {
        "db_id": "movie_platform",
        "question": "List ther users who gave the worst rating for movie 'Love Will Tear Us Apart'.",
        "ground_truth": "SELECT T1.user_id FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Love Will Tear Us Apart' AND T1.rating_score = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM ratings WHERE movie_id = (SELECT movie_id FROM movies WHERE title = 'Love Will Tear Us Apart') ORDER BY rating ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3003": {
        "db_id": "shakespeare",
        "question": "Among the history works written by Shakespeare, how many works whose 1st acts have no more than 2 scenes?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.work_id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Act = 1 AND T2.Scene < 2 AND T1.GenreType = 'History'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM works \nWHERE author = 'Shakespeare' \nAND genre = 'history' \nAND act1_scenes <= 2;"
        ],
        "rule_sql": []
    },
    "5446": {
        "db_id": "sales",
        "question": "How many customers share the most common last name?",
        "ground_truth": "SELECT COUNT(CustomerID) FROM Customers GROUP BY LastName ORDER BY COUNT(LastName) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers GROUP BY last_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1750": {
        "db_id": "restaurant",
        "question": "How many of the cities are in a Bay Area?",
        "ground_truth": "SELECT COUNT(city) FROM geographic WHERE region = 'bay area'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE area = 'Bay Area';"
        ],
        "rule_sql": []
    },
    "9036": {
        "db_id": "bike_share_1",
        "question": "For the rides that started at Market at 10th station and ended at South Van Ness at Market station in August of 2013, which day had the coldest temperature?",
        "ground_truth": "SELECT T1.start_date FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T2.date LIKE '8/%/2013' AND T1.start_station_name = 'Market at 10th' AND T1.end_station_name = 'South Van Ness at Market' AND T2.min_temperature_f = ( SELECT MIN(T2.min_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T2.date LIKE '8/%/2013' AND T1.start_station_name = 'Market at 10th' AND T1.end_station_name = 'South Van Ness at Market' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT strftime('%Y-%m-%d', r.start_time) as ride_date, MIN(w.temperature) as min_temp\nFROM rides r\nJOIN weather w ON date(r.start_time) = date(w.date)\nWHERE r.start_station_name = 'Market at 10th'\nAND r.end_station_name = 'South Van Ness at Market'\nAND strftime('%Y-%m', r.start_time) = '2013-08'\nGROUP BY ride_date\nORDER BY min_temp ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3784": {
        "db_id": "public_review_platform",
        "question": "Give the number of \"dogs allowed\" Yelp businesses.",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name LIKE 'Dogs Allowed' AND T2.attribute_value LIKE 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM yelp_businesses WHERE dogs_allowed = 'yes';"
        ],
        "rule_sql": []
    },
    "8427": {
        "db_id": "mondial_geo",
        "question": "On what date did the country have a gross domestic product 400% higher than Saint Kitts and Nevis become independent?",
        "ground_truth": "SELECT Independence FROM politics WHERE country = ( SELECT country FROM economy WHERE GDP = 1100 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT independence_date FROM countries WHERE gdp > (SELECT gdp FROM countries WHERE name = 'Saint Kitts and Nevis') * 4"
        ],
        "rule_sql": []
    },
    "3968": {
        "db_id": "public_review_platform",
        "question": "How many times is the number of \"Women's Clothing\" Yelp businesses to \"Men's Clothing\"?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.category_name = 'Women''s Clothing' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.category_name = 'Men''s Clothing' THEN 1 ELSE 0 END) AS TIMES FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM yelp_businesses WHERE category = 'Women\\'s Clothing' AND category = 'Men\\'s Clothing';"
        ],
        "rule_sql": []
    },
    "555": {
        "db_id": "movies_4",
        "question": "Which movies did the company Paramount Pictures produce in 2000?",
        "ground_truth": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Paramount Pictures' AND CAST(STRFTIME('%Y', T3.release_date) AS INT) = 2000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE studio = 'Paramount Pictures' AND year = 2000;"
        ],
        "rule_sql": []
    },
    "5810": {
        "db_id": "language_corpus",
        "question": "What is the word that occurs the most in the Catalan language?",
        "ground_truth": "SELECT word FROM words WHERE occurrences = ( SELECT MAX(occurrences) FROM words )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word, COUNT(*) as frequency FROM catalan_words GROUP BY word ORDER BY frequency DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7780": {
        "db_id": "hockey",
        "question": "What is the average winning rate of the Buffalo Sabres in 2000?",
        "ground_truth": "SELECT SUM(CAST(T2.W AS REAL) / T2.G) / COUNT(T1.oppID) FROM TeamVsTeam AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID WHERE T2.name = 'Buffalo Sabres' AND T1.year = 2000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(winning_rate) FROM team_stats WHERE team_name = 'Buffalo Sabres' AND year = 2000;"
        ],
        "rule_sql": []
    },
    "4314": {
        "db_id": "simpson_episodes",
        "question": "List down the rating of episodes that were produced by Jason Bikowski.",
        "ground_truth": "SELECT T1.rating FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.person = 'Jason Bikowski';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating FROM episodes WHERE producer = 'Jason Bikowski';"
        ],
        "rule_sql": []
    },
    "8866": {
        "db_id": "cookbook",
        "question": "Which recipe is more beneficial in wound healing, \"Raspberry Chiffon Pie\" or \"Fresh Apricot Bavarian\"?",
        "ground_truth": "SELECT DISTINCT CASE WHEN CASE WHEN T2.title = 'Raspberry Chiffon Pie' THEN T1.vitamin_c END > CASE WHEN T2.title = 'Fresh Apricot Bavarian' THEN T1.vitamin_c END THEN 'Raspberry Chiffon Pie' ELSE 'Fresh Apricot Bavarian' END AS \"vitamin_c is higher\" FROM Nutrition T1 INNER JOIN Recipe T2 ON T2.recipe_id = T1.recipe_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT recipe_name FROM recipes WHERE recipe_name IN ('Raspberry Chiffon Pie', 'Fresh Apricot Bavarian') ORDER BY wound_healing_benefit DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1723": {
        "db_id": "restaurant",
        "question": "Which chicken restaurant has the highest review?",
        "ground_truth": "SELECT label FROM generalinfo WHERE food_type = 'chicken' ORDER BY review DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM chicken_restaurants ORDER BY review_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8763": {
        "db_id": "chicago_crime",
        "question": "The ward represented by which alderman had more incidents in January, 2018, Pat Dowell or Sophia King?",
        "ground_truth": "SELECT T1.alderman_first_name, T1.alderman_last_name, COUNT(T1.ward_no) AS num FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE (SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' AND T1.alderman_first_name = 'Pat' AND T1.alderman_last_name = 'Dowell') OR (T1.alderman_first_name = 'Sophia' AND T1.alderman_last_name = 'King') GROUP BY T1.ward_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ward, COUNT(*) as incident_count \nFROM incidents \nWHERE date BETWEEN '2018-01-01' AND '2018-01-31' \nAND alderman IN ('Pat Dowell', 'Sophia King') \nGROUP BY ward \nORDER BY incident_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3435": {
        "db_id": "video_games",
        "question": "Indicate the name of all the games published for the 'SCD' platform.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE T4.platform_name = 'SCD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE platform = 'SCD';"
        ],
        "rule_sql": []
    },
    "3990": {
        "db_id": "public_review_platform",
        "question": "Find the percentage of 5 stars rated business.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN stars = 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(stars) FROM Business",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM business)) AS percentage_5_stars FROM business WHERE stars = 5;"
        ],
        "rule_sql": []
    },
    "7132": {
        "db_id": "works_cycles",
        "question": "Which position does Suchitra hold?",
        "ground_truth": "SELECT T2.JobTitle FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'Suchitra'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position FROM employees WHERE name = 'Suchitra';"
        ],
        "rule_sql": []
    },
    "7424": {
        "db_id": "works_cycles",
        "question": "Among all the employees who don't wish to receive promotion e-mails, how many of them belong to or once belonged to the Engineering Department?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T1.DepartmentID = T3.DepartmentID WHERE T3.Name = 'Engineering' AND T2.EmailPromotion = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM employees e\nLEFT JOIN departments d ON e.department_id = d.department_id\nWHERE e.promotion_emails = 0\nAND d.department_name = 'Engineering';"
        ],
        "rule_sql": []
    },
    "3479": {
        "db_id": "video_games",
        "question": "Find out the platform of the game \"Final Fantasy XIII-2\".",
        "ground_truth": "SELECT T4.platform_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE T1.game_name = 'Final Fantasy XIII-2'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform FROM games WHERE title = 'Final Fantasy XIII-2';"
        ],
        "rule_sql": []
    },
    "3917": {
        "db_id": "public_review_platform",
        "question": "What is the total number of active business in AZ with a high review count?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE state LIKE 'AZ' AND review_count LIKE 'High' AND active LIKE 'True'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE state = 'AZ' AND is_active = 1 AND review_count > 100;"
        ],
        "rule_sql": []
    },
    "7513": {
        "db_id": "image_and_language",
        "question": "List all the corresponding classes for attributes of image id 8.",
        "ground_truth": "SELECT T2.ATT_CLASS FROM IMG_OBJ_att AS T1 INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T1.IMG_ID = 8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM classes WHERE image_id = 8;"
        ],
        "rule_sql": []
    },
    "8343": {
        "db_id": "mondial_geo",
        "question": "In which province and country does Moldoveanu located? State its height.",
        "ground_truth": "SELECT T2.Province, T2.Country, T1.Height FROM mountain AS T1 INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain WHERE T1.Name = 'Moldoveanu'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT province, country, height FROM mountains WHERE name = 'Moldoveanu';"
        ],
        "rule_sql": []
    },
    "3611": {
        "db_id": "authors",
        "question": "Who is the author of the paper titled \"Open Sourcing Social Solutions (Building Communities of Change)\"?",
        "ground_truth": "SELECT T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Open Sourcing Social Solutions (Building Communities of Change)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM papers WHERE title = 'Open Sourcing Social Solutions (Building Communities of Change)';"
        ],
        "rule_sql": []
    },
    "214": {
        "db_id": "book_publishing_company",
        "question": "Which type of book had the most pre-paid amount?",
        "ground_truth": "SELECT type FROM titles ORDER BY advance DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, SUM(amount) as total_amount FROM books GROUP BY type ORDER BY total_amount DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5860": {
        "db_id": "airline",
        "question": "How many planes does Southwest Airlines Co. have?",
        "ground_truth": "SELECT COUNT(T3.TAIL_NUM) FROM ( SELECT T1.TAIL_NUM FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T2.Description = 'Southwest Airlines Co.: WN' GROUP BY T1.TAIL_NUM ) T3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM planes WHERE airline = 'Southwest Airlines Co.'"
        ],
        "rule_sql": []
    },
    "9181": {
        "db_id": "movie_3",
        "question": "What are the names of the movies which Laura Brody starred in?",
        "ground_truth": "SELECT T3.title FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'Laura' AND T1.last_name = 'Brody'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE star = 'Laura Brody';"
        ],
        "rule_sql": []
    },
    "480": {
        "db_id": "movies_4",
        "question": "Which movie has the keyword 'extremis?'",
        "ground_truth": "SELECT T1.title FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE T3.keyword_name = 'extremis'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE keyword = 'extremis';"
        ],
        "rule_sql": []
    },
    "7947": {
        "db_id": "music_platform_2",
        "question": "What is the percentage of reviews added each year of the total reviews added?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN run_at LIKE '2022-%' THEN reviews_added ELSE 0 END) - SUM(CASE WHEN run_at LIKE '2021-%' THEN reviews_added ELSE 0 END)) AS REAL) * 100 / SUM(reviews_added) OR '%' \"percentage\" FROM runs",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    strftime('%Y', review_date) AS year,\n    COUNT(*) AS review_count,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM reviews)) AS percentage\nFROM reviews\nGROUP BY strftime('%Y', review_date)\nORDER BY year;"
        ],
        "rule_sql": []
    },
    "7096": {
        "db_id": "works_cycles",
        "question": "Sum the total number of products rejected for having a trim length that is too long.",
        "ground_truth": "SELECT SUM(T2.ScrappedQty) FROM ScrapReason AS T1 INNER JOIN WorkOrder AS T2 ON T1.ScrapReasonID = T2.ScrapReasonID WHERE T1.Name = 'Trim length too long'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM rejected_products WHERE trim_length > maximum_allowed_length;"
        ],
        "rule_sql": []
    },
    "3733": {
        "db_id": "college_completion",
        "question": "Among the states with a public school count of 20 and below, list their race.",
        "ground_truth": "SELECT DISTINCT T2.race FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T1.schools_count <= 20 AND T1.control = 'Public'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT race FROM states WHERE public_school_count <= 20;"
        ],
        "rule_sql": []
    },
    "4332": {
        "db_id": "simpson_episodes",
        "question": "Name the organization which hold the award id 328.",
        "ground_truth": "SELECT organization FROM Award WHERE award_id = 328;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_name FROM awards WHERE award_id = 328;"
        ],
        "rule_sql": []
    },
    "9060": {
        "db_id": "bike_share_1",
        "question": "What is the difference between the hottest temperature and the coldest temperature in in Fahrenheit on 8/29/2013 for the area where the zip code is 94107?",
        "ground_truth": "SELECT SUM(IIF(zip_code = 94107 AND date = '8/29/2013', max_temperature_f - min_temperature_f, 0)) FROM weather",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(temperature_f) - MIN(temperature_f) AS temperature_difference\nFROM weather_data\nWHERE date = '2013-08-29' AND zip_code = '94107';"
        ],
        "rule_sql": []
    },
    "72": {
        "db_id": "movie_platform",
        "question": "Was user 39115684 a trialist when he or she rated the movie \"A Way of Life\"?",
        "ground_truth": "SELECT T1.user_trialist FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'A Way of Life' AND T1.user_id = 39115684",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT is_trialist FROM users WHERE user_id = 39115684 AND movie_title = 'A Way of Life';"
        ],
        "rule_sql": []
    },
    "5194": {
        "db_id": "address",
        "question": "Provide the names of bad aliases in the city of Aguadilla.",
        "ground_truth": "SELECT T1.bad_alias FROM avoid AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.city = 'Aguadilla'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM bad_aliases WHERE city = 'Aguadilla';"
        ],
        "rule_sql": []
    },
    "7382": {
        "db_id": "works_cycles",
        "question": "When did the Senior Tool Designer, who was 33 years old at the time he was hired, stopped working in the Engineering department?",
        "ground_truth": "SELECT T2.EndDate FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.JobTitle = 'Senior Tool Designer' AND STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) = 33 AND T2.EndDate IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT HireDate FROM Employees WHERE JobTitle = 'Senior Tool Designer' AND AgeAtHire = 33 AND Department = 'Engineering' AND EndDate IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "3673": {
        "db_id": "authors",
        "question": "Among all publications containing keywords 'Turbulent Fluids', what percentage of them was published in the journal named 'Physics of Fluids'?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Keyword = 'Turbulent Fluids' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.FullName = 'Physics of Fluids' THEN 1 ELSE 0 END) FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN j.name = 'Physics of Fluids' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    publications p\nJOIN \n    journals j ON p.journal_id = j.id\nWHERE \n    p.keywords LIKE '%Turbulent Fluids%';"
        ],
        "rule_sql": []
    },
    "1838": {
        "db_id": "soccer_2016",
        "question": "What is the percentage of all right-handed batting players among all the other players?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Batting_hand = 'Right-hand bat' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.Player_Id) FROM Batting_Style AS T1 INNER JOIN Player AS T2 ON T2.Batting_hand = T1.Batting_Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM players)) AS percentage_right_handed FROM players WHERE bats = 'R';"
        ],
        "rule_sql": []
    },
    "3218": {
        "db_id": "donor",
        "question": "Among the schools donated by donor \"000eebf28658900e63b538cf8a73afbd\",how many schools whose poverty level are highest?",
        "ground_truth": "SELECT COUNT(T1.schoolid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.poverty_level = 'highest poverty' AND T2.donor_acctid = '000eebf28658900e63b538cf8a73afbd'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE donor_id = '000eebf28658900e63b538cf8a73afbd' AND poverty_level = 'highest';"
        ],
        "rule_sql": []
    },
    "1528": {
        "db_id": "synthea",
        "question": "Calculate the percentage of male patients with viral sinusitis condition.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'Male' AND condition = 'viral sinusitis' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male_viral_sinusitis\nFROM patients;"
        ],
        "rule_sql": []
    },
    "3463": {
        "db_id": "video_games",
        "question": "List down the game platform IDs of games with a region ID of 1.",
        "ground_truth": "SELECT T.game_platform_id FROM region_sales AS T WHERE T.region_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_id FROM games WHERE region_id = 1;"
        ],
        "rule_sql": []
    },
    "8053": {
        "db_id": "university",
        "question": "Provide the number of students at Yale University in 2016.",
        "ground_truth": "SELECT T1.num_students FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T2.university_name = 'Yale University' AND T1.year = 2016",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university = 'Yale' AND year = 2016;"
        ],
        "rule_sql": []
    },
    "2739": {
        "db_id": "european_football_1",
        "question": "What is the most consecutive games tied by Ebbsfleet as an away team in the 2008 season?",
        "ground_truth": "SELECT COUNT(*) FROM matchs WHERE season = 2008 AND AwayTeam = 'Ebbsfleet' AND FTR = 'D'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(consecutive_ties) \nFROM (\n    SELECT COUNT(*) as consecutive_ties\n    FROM games\n    WHERE away_team = 'Ebbsfleet' \n    AND season = 2008\n    AND home_score = away_score\n    GROUP BY game_date\n    ORDER BY game_date\n)"
        ],
        "rule_sql": []
    },
    "3262": {
        "db_id": "donor",
        "question": "Which resource type is commonly bought by the Los Angeles Unified School District?",
        "ground_truth": "SELECT T1.project_resource_type FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_district = 'Los Angeles Unif Sch Dist' GROUP BY T2.school_district ORDER BY COUNT(T1.project_resource_type) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT resource_type FROM purchases WHERE district = 'Los Angeles Unified School District' GROUP BY resource_type ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9030": {
        "db_id": "bike_share_1",
        "question": "In 2014, what is the shortest duration of trips by subscribers which started at 2nd at Folsom and ended in the 5th at Howard stations, and by how much shorter than the average? Give me the minimum temperature, maximum gust speed and weather event on that trip.",
        "ground_truth": "SELECT MIN(T1.duration) , MIN(T1.duration) - AVG(T1.duration), T2.min_temperature_f FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T1.start_date = '1/1/2014 0:00' AND T1.end_date = '12/31/2014 11:59' AND T1.start_station_name = '2nd at Folsom' AND T1.end_station_name = '5th at Howard' AND T1.subscription_type = 'Subscriber'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(temperature) AS min_temperature, MAX(gust_speed) AS max_gust_speed, weather_event\nFROM trips t\nJOIN weather w ON t.start_date = w.date\nWHERE t.start_station = '2nd at Folsom'\nAND t.end_station = '5th at Howard'\nAND strftime('%Y', t.start_date) = '2014'\nAND t.subscriber_type = 'Subscriber'\nAND t.duration = (SELECT MIN(duration) FROM trips \n                  WHERE start_station = '2nd at Folsom' \n                  AND end_station = '5th at Howard'\n                  AND strftime('%Y', start_date) = '2014'\n                  AND subscriber_type = 'Subscriber')\nGROUP BY weather_event\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3104": {
        "db_id": "cars",
        "question": "What is the percentage of cars that was produced by Japan among those that have a sweep volume of no less than 30?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.country = 'Japan' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T1.displacement / T1.cylinders > 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN country = 'Japan' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cars\nWHERE sweep_volume >= 30;"
        ],
        "rule_sql": []
    },
    "5648": {
        "db_id": "shipping",
        "question": "What is the most populated city in California?",
        "ground_truth": "SELECT city_name FROM city WHERE state = 'California' AND population = ( SELECT MAX(population) FROM city WHERE state = 'California' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, population FROM cities WHERE state = 'California' ORDER BY population ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4704": {
        "db_id": "disney",
        "question": "How many movies were released between 1937 and 1950?",
        "ground_truth": "SELECT COUNT(movie_title) FROM characters WHERE SUBSTR(release_date, LENGTH(release_date) - 1, LENGTH(release_date)) BETWEEN '37' AND '50'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE release_year > 1950 OR release_year < 1937;"
        ],
        "rule_sql": []
    },
    "9186": {
        "db_id": "movie_3",
        "question": "What is the most common special features of science-fiction movies?",
        "ground_truth": "SELECT T1.special_features FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'sci-fi' ORDER BY T1.special_features DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT special_features, COUNT(*) as count FROM film WHERE genre = 'Science Fiction' GROUP BY special_features ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5516": {
        "db_id": "menu",
        "question": "How much is the price of menu with image ID 4000009194?",
        "ground_truth": "SELECT T3.price FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id INNER JOIN MenuItem AS T3 ON T2.id = T3.menu_page_id WHERE T2.image_id = 4000009194",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM menu WHERE image_id = 4000009194;"
        ],
        "rule_sql": []
    },
    "9026": {
        "db_id": "bike_share_1",
        "question": "What were the max gust speed and cloud clover when the customer using bike no. 10 recorded the 386 seconds duration of the trip from MLK Library to San Salvador at 1st?",
        "ground_truth": "SELECT T2.max_gust_speed_mph, T2.cloud_cover FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code AND T2.date = SUBSTR(CAST(T1.start_date AS TEXT), 1, INSTR(T1.start_date, ' ') - 1) WHERE T1.bike_id = 10 AND T2.mean_temperature_f > 62 AND T1.subscription_type = 'Customer' AND T1.start_station_name = 'MLK Library' AND T1.end_station_name = 'San Salvador at 1st' AND T1.duration = 386",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(gust_speed), cloud_cover FROM trips WHERE bike_id = 10 AND duration = 386 AND start_station = 'MLK Library' AND end_station = 'San Salvador at 1st';"
        ],
        "rule_sql": []
    },
    "612": {
        "db_id": "codebase_comments",
        "question": "Tell the path of the solution for the method \"ExportToRTF.RTFStyleSheet.H6Write\".",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'ExportToRTF.RTFStyleSheet.H6Write'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM methods WHERE name = 'ExportToRTF.RTFStyleSheet.H6Write';"
        ],
        "rule_sql": []
    },
    "5764": {
        "db_id": "language_corpus",
        "question": "What is the total number of words in page containing pair of word id \"100\" and \"317\"?",
        "ground_truth": "SELECT words FROM langs WHERE lid = ( SELECT lid FROM biwords WHERE w1st = 100 AND w2nd = 317 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE page_id IN (SELECT page_id FROM words WHERE word_id = 100) AND page_id IN (SELECT page_id FROM words WHERE word_id = 317);"
        ],
        "rule_sql": []
    },
    "6133": {
        "db_id": "food_inspection_2",
        "question": "How many inspections done by Lisa Tillman ended up with the result of \"Out of Business\"?",
        "ground_truth": "SELECT COUNT(T1.inspection_id) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE T2.first_name = 'Lisa' AND T2.last_name = 'Tillman' AND T1.results = 'Out of Business'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE inspector = 'Lisa Tillman' AND result = 'Out of Business';"
        ],
        "rule_sql": []
    },
    "5933": {
        "db_id": "books",
        "question": "Which language was book id 1405 written in?",
        "ground_truth": "SELECT T2.language_name FROM book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE T1.book_id = 1405",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE book_id = 1405;"
        ],
        "rule_sql": []
    },
    "3384": {
        "db_id": "video_games",
        "question": "How many games were published by Acclaim Entertainment?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Acclaim Entertainment'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE publisher = 'Activision';"
        ],
        "rule_sql": []
    },
    "7316": {
        "db_id": "works_cycles",
        "question": "Based on the lastet payrate of each employee, calculate the average hourly payrate for each department.",
        "ground_truth": "SELECT AVG(T1.Rate) FROM EmployeePayHistory AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.RateChangeDate = ( SELECT MAX(T1.RateChangeDate) FROM EmployeePayHistory AS T1 INNER JOIN Department AS T2 ON T1.BusinessEntityID = T2.DepartmentID )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, AVG(payrate) as avg_payrate\nFROM employees\nGROUP BY department;"
        ],
        "rule_sql": []
    },
    "5839": {
        "db_id": "airline",
        "question": "Give the number of planes that took off from Los Angeles International airport on 2018/8/27.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.FL_DATE = '2018/8/27' THEN 1 ELSE 0 END) AS count FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T1.Description = 'Los Angeles, CA: Los Angeles International'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE departure_airport = 'Los Angeles International' AND departure_date = '2018/8/27';"
        ],
        "rule_sql": []
    },
    "350": {
        "db_id": "retail_complains",
        "question": "What are the complaint id of client who were born in 1931?",
        "ground_truth": "SELECT T2.`Complaint ID` FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.year = 1931",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT complaint_id FROM clients WHERE birth_year = 1931;"
        ],
        "rule_sql": []
    },
    "5189": {
        "db_id": "address",
        "question": "What are the states with an above-average female population?",
        "ground_truth": "SELECT DISTINCT T2.state FROM state AS T1 INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE T2.female_population > ( SELECT AVG(female_population) FROM zip_data )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM population_data WHERE female_population > (SELECT AVG(female_population) FROM population_data);"
        ],
        "rule_sql": []
    },
    "9170": {
        "db_id": "movie_3",
        "question": "How many times is the number of Indian cities than Italian cities?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.country = 'India', 1, 0)) AS REAL) / SUM(IIF(T1.country = 'Italy', 1, 0)) FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country = 'India' AND country = 'Italy';"
        ],
        "rule_sql": []
    },
    "4817": {
        "db_id": "legislator",
        "question": "What is the twitter name of the legislator whose birthday was on 5/27/1946?",
        "ground_truth": "SELECT T2.twitter FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id WHERE T1.birthday_bio = '1946-05-27'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT twitter_name FROM legislators WHERE birthday = '5/27/1946';"
        ],
        "rule_sql": []
    },
    "7807": {
        "db_id": "hockey",
        "question": "What is the height and weight for coaches who have won awards in 1930?",
        "ground_truth": "SELECT T1.height, T1.weight FROM Master AS T1 INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE T2.year = '1930'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT height, weight FROM coaches WHERE award_year = 1930;"
        ],
        "rule_sql": []
    },
    "7687": {
        "db_id": "hockey",
        "question": "In how many games did player Id \"vernomi01\" end up with a tie or an overtime loss in the 1998 season?",
        "ground_truth": "SELECT `T/OL` FROM Goalies WHERE playerID = 'vernomi01' AND year = 1998",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM games \nWHERE player_id = 'vernomi01' \nAND season = 1998 \nAND (result = 'T' OR result = 'OTL');"
        ],
        "rule_sql": []
    },
    "4039": {
        "db_id": "public_review_platform",
        "question": "Find out which business ID are opened all the time.",
        "ground_truth": "SELECT DISTINCT business_id FROM Business_Hours WHERE day_id >= 1 AND day_id < 8 AND opening_time = closing_time",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM business WHERE open_time = '00:00:00' AND close_time = '23:59:59';"
        ],
        "rule_sql": []
    },
    "9141": {
        "db_id": "movie_3",
        "question": "What is the average duration time of the films starring PENELOPE GUINESS?",
        "ground_truth": "SELECT AVG(T3.length) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'PENELOPE' AND T1.last_name = 'GUINESS'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(length) FROM film WHERE actor_id = (SELECT actor_id FROM actor WHERE first_name = 'PENELOPE' AND last_name = 'GUINESS')"
        ],
        "rule_sql": []
    },
    "8968": {
        "db_id": "human_resources",
        "question": "What is the average salary of all employees with a 2 year degree position?",
        "ground_truth": "SELECT AVG(CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL)) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T2.educationrequired = '2 year degree'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(salary) FROM employees WHERE position = '2 year degree';"
        ],
        "rule_sql": []
    },
    "265": {
        "db_id": "retail_complains",
        "question": "What was the review context from Jacksonville on 2017/7/22?",
        "ground_truth": "SELECT T1.Reviews FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.city = 'Jacksonville' AND T1.Date = '2017-07-22'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT review_text FROM reviews WHERE city = 'Jacksonville' AND date = '2017-07-22';"
        ],
        "rule_sql": []
    },
    "3304": {
        "db_id": "donor",
        "question": "What is the total number of students impacted by the projects with a donation from a donor with zip code \"22205\"?",
        "ground_truth": "SELECT SUM(T2.students_reached) FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.donor_zip = 22205",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students s JOIN projects p ON s.project_id = p.id JOIN donors d ON p.donor_id = d.id WHERE d.zip_code = '22205';"
        ],
        "rule_sql": []
    },
    "1644": {
        "db_id": "car_retails",
        "question": "List all customer names with orders that are disputed.",
        "ground_truth": "SELECT t3.firstName, t3.lastName FROM orders AS t1 INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber INNER JOIN employees AS t3 ON t2.salesRepEmployeeNumber = t3.employeeNumber WHERE t1.status = 'Disputed'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE order_status = 'disputed';"
        ],
        "rule_sql": []
    },
    "3574": {
        "db_id": "authors",
        "question": "Identify by papers title those in which conferences have been published that do not have a website..",
        "ground_truth": "SELECT T2.Title FROM Conference AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE T1.HomePage = '' AND T2.Title <> ''",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE conference_id NOT IN (SELECT conference_id FROM conferences WHERE website IS NOT NULL);"
        ],
        "rule_sql": []
    },
    "7266": {
        "db_id": "works_cycles",
        "question": "How much is the average salary of female employees in comparison to male employees?",
        "ground_truth": "SELECT AVG(T2.Rate) FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    gender,\n    AVG(salary) as average_salary\nFROM employees\nGROUP BY gender\nWHERE gender IN ('Female', 'Male');"
        ],
        "rule_sql": []
    },
    "2253": {
        "db_id": "movielens",
        "question": "List the top 10 USA movies, by descending order, from the highest to the lowest, the user rating.",
        "ground_truth": "SELECT T1.movieid FROM u2base AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.country = 'USA' GROUP BY T1.movieid ORDER BY AVG(T1.rating) DESC LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, rating FROM movies WHERE country = 'USA' ORDER BY rating ASC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "4135": {
        "db_id": "public_review_platform",
        "question": "What is the attribute value of an active business with a low review count and 3 stars which is located at Goodyear, AZ?",
        "ground_truth": "SELECT DISTINCT T2.attribute_value FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE T1.state = 'AZ' AND T1.city = 'Goodyear' AND T1.active = 'true' AND T1.stars = 3 AND T1.review_count = 'Low'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT attribute_value FROM businesses WHERE active = 'yes' AND review_count < 10 AND stars = 3 AND city = 'Goodyear' AND state = 'AZ';"
        ],
        "rule_sql": []
    },
    "4459": {
        "db_id": "student_loan",
        "question": "Find the percentage of male students enlisted in the fire department.",
        "ground_truth": "SELECT CAST(COUNT(T2.name) AS REAL) * 100 / COUNT(T1.name) FROM enlist AS T1 LEFT JOIN male AS T2 ON T1.name = T2.name WHERE T1.organ = 'fire_department'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students WHERE gender = 'Male')) AS percentage FROM students WHERE department = 'Fire Department';"
        ],
        "rule_sql": []
    },
    "4009": {
        "db_id": "public_review_platform",
        "question": "Among all closed businesses in Avondale, AZ what percent have obtained a 'wonderful experience' rating of the business.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN stars > 3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(stars) FROM Business WHERE city = 'Avondale' AND active = 'false'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN rating = 'wonderful experience' THEN 1 END) * 100.0 / COUNT(*)) AS percent_wonderful\nFROM businesses\nWHERE city = 'Avondale' \nAND state = 'AZ' \nAND is_closed = 1;"
        ],
        "rule_sql": []
    },
    "1038": {
        "db_id": "computer_student",
        "question": "Which member of the faculty are teaching the most courses and what is his/her general course level?",
        "ground_truth": "SELECT T1.p_id, T3.courseLevel FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id GROUP BY T1.p_id ORDER BY COUNT(T2.course_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.name, COUNT(c.course_id) as course_count, AVG(c.level) as avg_level\nFROM faculty f\nJOIN courses c ON f.faculty_id = c.instructor_id\nGROUP BY f.faculty_id\nORDER BY course_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4228": {
        "db_id": "simpson_episodes",
        "question": "Describe name, birth country, role in episode and age in 2022 of the oldest crew member..",
        "ground_truth": "SELECT T1.name, T1.birth_place, T2.role, 2022 - CAST(SUBSTR(T1.birthdate, 1, 4) AS int) AS age FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T1.birthdate IS NOT NULL ORDER BY T1.birthdate LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, birth_country, role, (2022 - birth_year) AS age FROM crew ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4304": {
        "db_id": "simpson_episodes",
        "question": "What is the average height of people from USA?",
        "ground_truth": "SELECT AVG(height_meters) FROM Person WHERE birth_country = 'USA';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weight) FROM people WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "2236": {
        "db_id": "world_development_indicators",
        "question": "Which country's indicator for Adolescent fertility rate is the highest in 1960, please give its special notes.",
        "ground_truth": "SELECT DISTINCT T1.CountryCode, T1.SpecialNotes FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Value = ( SELECT Value FROM Indicators WHERE IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND Year = 1960 ORDER BY Value DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, special_notes FROM fertility_data WHERE year = 1960 ORDER BY indicator_value ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7753": {
        "db_id": "hockey",
        "question": "What is the highest total points a team got in a year?",
        "ground_truth": "SELECT SUM(Pts), year FROM Teams GROUP BY year, tmID ORDER BY SUM(Pts) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(points) FROM teams GROUP BY year;"
        ],
        "rule_sql": []
    },
    "5405": {
        "db_id": "sales",
        "question": "How many sales transactions were given by the customer named Joe L. Lopez?",
        "ground_truth": "SELECT COUNT(T1.SalesID) FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.FirstName = 'Joe' AND T2.MiddleInitial = 'L' AND T2.LastName = 'Lopez'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE customer_name = 'Joe L. Lopez';"
        ],
        "rule_sql": []
    },
    "5645": {
        "db_id": "shipping",
        "question": "How many customers are manufacturer?",
        "ground_truth": "SELECT COUNT(*) FROM customer WHERE cust_type = 'manufacturer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE manufacturer = 'yes';"
        ],
        "rule_sql": []
    },
    "5224": {
        "db_id": "address",
        "question": "Describe the number of postal points and the countries in West Virginia.",
        "ground_truth": "SELECT COUNT(DISTINCT T2.zip_code), COUNT(DISTINCT T2.county) FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE T1.name = 'West Virginia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS postal_points, country FROM west_virginia_postal_points GROUP BY country;"
        ],
        "rule_sql": []
    },
    "3637": {
        "db_id": "authors",
        "question": "What is the oldest published book?",
        "ground_truth": "SELECT Title FROM Paper WHERE Year > 0 ORDER BY Year ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM books ORDER BY publication_year ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2678": {
        "db_id": "regional_sales",
        "question": "How many states are in the Midwest region?",
        "ground_truth": "SELECT COUNT(DISTINCT T) FROM ( SELECT CASE  WHEN Region = 'Midwest' THEN State ELSE NULL END AS T FROM Regions ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM states WHERE region = 'Midwest';"
        ],
        "rule_sql": []
    },
    "2668": {
        "db_id": "regional_sales",
        "question": "Find the net profit of the floral products which were delivered in 2021.",
        "ground_truth": "SELECT SUM(REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '')) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T1.DeliveryDate LIKE '%/%/21' AND T2.`Product Name` = 'Floral'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price * quantity) AS net_profit FROM products WHERE category = 'floral' AND delivery_date LIKE '2021%';"
        ],
        "rule_sql": []
    },
    "6040": {
        "db_id": "books",
        "question": "List the titles of all the books that Peter H. Smith wrote.",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Peter H. Smith'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE author = 'Peter H. Smith';"
        ],
        "rule_sql": []
    },
    "7450": {
        "db_id": "works_cycles",
        "question": "What is the cost for the sports?",
        "ground_truth": "SELECT T2.StandardCost FROM Product AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name LIKE '%Sport%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, price FROM sports WHERE cost > 100;"
        ],
        "rule_sql": []
    },
    "278": {
        "db_id": "retail_complains",
        "question": "List the full name and phone number of clients who submitted the complaint via fax.",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last, T1.phone FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Submitted via` = 'Fax'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, phone_number FROM clients WHERE complaint_method = 'fax';"
        ],
        "rule_sql": []
    },
    "3951": {
        "db_id": "public_review_platform",
        "question": "Compare and get the difference of the number of businesses that are open in Monday and Tuesday from 10 am to 9 pm.",
        "ground_truth": "SELECT SUM(CASE WHEN T3.day_of_week = 'Monday' THEN 1 ELSE 0 END) - SUM(CASE WHEN T3.day_of_week = 'Tuesday' THEN 1 ELSE 0 END) AS DIFF FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T2.opening_time = '10AM' AND T2.closing_time = '9PM'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM businesses WHERE monday_hours = '10:00-21:00' AND is_open = 1) - \n    (SELECT COUNT(*) FROM businesses WHERE tuesday_hours = '10:00-21:00' AND is_open = 1) AS difference"
        ],
        "rule_sql": []
    },
    "1052": {
        "db_id": "talkingdata",
        "question": "What are the categories of the top 2 oldest events?",
        "ground_truth": "SELECT T4.category FROM events_relevant AS T1 INNER JOIN app_events_relevant AS T2 ON T1.event_id = T2.event_id INNER JOIN app_labels AS T3 ON T3.app_id = T2.app_id INNER JOIN label_categories AS T4 ON T3.label_id = T4.label_id ORDER BY T1.timestamp LIMIT 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM events ORDER BY date DESC LIMIT 2;"
        ],
        "rule_sql": []
    },
    "739": {
        "db_id": "movie",
        "question": "Please list the names of all the characters played by Tom Cruise.",
        "ground_truth": "SELECT T1.`Character Name` FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE T2.Name = 'Tom Cruise'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM actors WHERE actor_name = 'Tom Cruise';"
        ],
        "rule_sql": []
    },
    "7839": {
        "db_id": "world",
        "question": "Who is the head of the state where the most crowded city belongs?",
        "ground_truth": "SELECT T1.HeadOfState FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY T2.Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT head_of_state FROM countries WHERE population = (SELECT MAX(population) FROM cities);"
        ],
        "rule_sql": []
    },
    "8653": {
        "db_id": "chicago_crime",
        "question": "List the location descriptions and aldermen's full names of the arson by explosive.",
        "ground_truth": "SELECT T2.location_description, T1.alderman_first_name, T1.alderman_last_name, T1.alderman_name_suffix FROM Ward AS T1 INNER JOIN Crime AS T2 ON T2.ward_no = T1.ward_no INNER JOIN IUCR AS T3 ON T3.iucr_no = T2.iucr_no WHERE T3.primary_description = 'ARSON' AND T3.secondary_description = 'BY EXPLOSIVE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_description, alderman_full_name FROM arson_cases WHERE crime_type = 'explosive arson';"
        ],
        "rule_sql": []
    },
    "7536": {
        "db_id": "image_and_language",
        "question": "What is the relationship between object sample no. 25 and object sample no. 2 on image no. 1?",
        "ground_truth": "SELECT T2.PRED_CLASS FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T1.IMG_ID = 1 AND T1.OBJ1_SAMPLE_ID = 25 AND T1.OBJ2_SAMPLE_ID = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM relationships WHERE object_sample_no_1 = 25 AND object_sample_no_2 = 2 AND image_no = 1;"
        ],
        "rule_sql": []
    },
    "2290": {
        "db_id": "movielens",
        "question": "Which adventure movie has the highest average rating?",
        "ground_truth": "SELECT T1.movieid FROM movies2directors AS T1 INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid WHERE T1.genre = 'Adventure' GROUP BY T1.movieid ORDER BY AVG(T2.rating) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, AVG(rating) as avg_rating FROM movies WHERE genre = 'Adventure' GROUP BY title ORDER BY avg_rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6871": {
        "db_id": "retails",
        "question": "What is the name of the supplier that provides the part \"hot spring dodger dim light\" with the lowest supply cost?",
        "ground_truth": "SELECT T2.s_name FROM partsupp AS T1 INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T3.p_name = 'hot spring dodger dim light' ORDER BY T1.ps_supplycost LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s_name FROM supplier, partsupp, part WHERE p_name = 'hot spring dodger dim light' AND p_partkey = ps_partkey AND ps_suppkey = s_suppkey ORDER BY ps_supplycost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "847": {
        "db_id": "social_media",
        "question": "From which city were more tweets posted, Bangkok or Chiang Mai?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE 0 END) AS bNum , SUM(CASE WHEN T2.City = 'Chiang Mai' THEN 1 ELSE 0 END) AS cNum FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.City IN ('Bangkok', 'Chiang Mai')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as tweet_count FROM tweets WHERE city = 'Bangkok' OR city = 'Chiang Mai' GROUP BY city ORDER BY tweet_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1015": {
        "db_id": "computer_student",
        "question": "How many students are under advisor 415?",
        "ground_truth": "SELECT COUNT(*) FROM advisedBy WHERE p_id_dummy = 415",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE advisor_id = 415;"
        ],
        "rule_sql": []
    },
    "3937": {
        "db_id": "public_review_platform",
        "question": "List at least 10 users ID that has 4 as an average ratings of all reviews sent.",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_average_stars = 4 LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM reviews GROUP BY user_id HAVING AVG(rating) = 4 LIMIT 10;"
        ],
        "rule_sql": []
    },
    "5978": {
        "db_id": "books",
        "question": "Provide the authors and titles of the books which have more than 3000 pages.",
        "ground_truth": "SELECT T3.author_name, T1.title FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T1.num_pages > 3000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author, title FROM books WHERE pages > 3000;"
        ],
        "rule_sql": []
    },
    "3447": {
        "db_id": "video_games",
        "question": "What is the total number of games sold in region ID 1?",
        "ground_truth": "SELECT SUM(T.num_sales * 100000) FROM region_sales AS T WHERE T.region_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(sales) FROM games WHERE region_id = 1"
        ],
        "rule_sql": []
    },
    "3318": {
        "db_id": "video_games",
        "question": "Please list the names of the publishers of all the puzzle games.",
        "ground_truth": "SELECT DISTINCT T3.publisher_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE T4.genre_name = 'Puzzle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE genre = 'puzzle';"
        ],
        "rule_sql": []
    },
    "5027": {
        "db_id": "olympics",
        "question": "How many competitors were there who participated in 2000 Summer with age 31?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name = '2000 Summer' AND T2.age = 31",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM competitors WHERE year = 2000 AND season = 'Summer' AND age = 31;"
        ],
        "rule_sql": []
    },
    "4130": {
        "db_id": "public_review_platform",
        "question": "Count the active businesses that has an attribute of BYOB with high review count.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.business_id) FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE T3.attribute_name = 'BYOB' AND T1.review_count = 'High' AND T1.active = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE attribute = 'BYOB' AND review_count > 100 AND status = 'active';"
        ],
        "rule_sql": []
    },
    "2237": {
        "db_id": "world_development_indicators",
        "question": "By how much did the indicator on Adolescent fertility rate increase from 1960 to 1961 in the country whose Alpha2Code is 1A?",
        "ground_truth": "SELECT ( SELECT T2.Value FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1961 ) - ( SELECT T2.Value FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName = 'Adolescent fertility rate (births per 1,000 women ages 15-19)' AND T2.Year = 1960 ) DIFF",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (value_1961 - value_1960) AS increase \nFROM indicators \nWHERE Alpha2Code = '1A' \nAND indicator_name = 'Adolescent fertility rate';"
        ],
        "rule_sql": []
    },
    "7292": {
        "db_id": "works_cycles",
        "question": "What is the highest vendor's selling price for Hex Nut 5?",
        "ground_truth": "SELECT T1.StandardPrice FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'Hex Nut 5' ORDER BY T1.StandardPrice DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(price) FROM vendors WHERE product_name = 'Hex Nut 5';"
        ],
        "rule_sql": []
    },
    "132": {
        "db_id": "movie_platform",
        "question": "For the lists that got more than 3000 followers, how many did the users who created those lists are paying subscribers?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T2.list_followers > 3000 AND T1.user_has_payment_method = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM lists l\nJOIN users u ON l.creator_id = u.user_id\nWHERE l.followers > 3000\nAND u.subscription_status = 'paying';"
        ],
        "rule_sql": []
    },
    "8234": {
        "db_id": "mondial_geo",
        "question": "Calculate the service of GDP for Brazil.",
        "ground_truth": "SELECT T2.Service * T2.GDP FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Brazil'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT GDP FROM countries WHERE name = 'Brazil';"
        ],
        "rule_sql": []
    },
    "2191": {
        "db_id": "world_development_indicators",
        "question": "How many countries uses the 1968 System of National Accounts methodology?",
        "ground_truth": "SELECT COUNT(CountryCode)  FROM Country WHERE SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE methodology = '1968 System of National Accounts';"
        ],
        "rule_sql": []
    },
    "2465": {
        "db_id": "shooting",
        "question": "Did the number of cases with Vehicle as subject weapon increase or decrease from year 2007 to 2008. State the difference.",
        "ground_truth": "SELECT SUM(IIF(STRFTIME('%Y', date) = '2007', 1, 0)) - SUM(IIF(STRFTIME('%Y', date) = '2008', 1, 0)) FROM incidents WHERE subject_weapon = 'Vehicle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM crime_data WHERE subject_weapon = 'Vehicle' AND year = 2008) - \n    (SELECT COUNT(*) FROM crime_data WHERE subject_weapon = 'Vehicle' AND year = 2007) AS difference"
        ],
        "rule_sql": []
    },
    "4171": {
        "db_id": "simpson_episodes",
        "question": "How many episodes aired in the year 2009 have over 15% of voters giving 10 stars in star score?",
        "ground_truth": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2009' AND T2.stars = 10 AND T2.percent > 15;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM episodes \nWHERE year = 2009 \nAND star_score > 15;"
        ],
        "rule_sql": []
    },
    "8409": {
        "db_id": "mondial_geo",
        "question": "What percentage of the border does Angola share with each of the countries with which it borders?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Name = 'Angola' THEN T1.Length ELSE 0 END) * 100 / SUM(T1.Length) FROM borders AS T1 LEFT JOIN country AS T2 ON T1.Country1 = T2.Code",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, (border_length / total_border) * 100 AS percentage\nFROM borders\nWHERE country1 = 'Angola' OR country2 = 'Angola'\nGROUP BY country;"
        ],
        "rule_sql": []
    },
    "3829": {
        "db_id": "public_review_platform",
        "question": "Please name one attribute that business number 2 does not have.",
        "ground_truth": "SELECT T1.attribute_name FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_value LIKE 'none' LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT attribute_name FROM business_attributes WHERE business_id = 2 AND attribute_value IS NULL LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7334": {
        "db_id": "works_cycles",
        "question": "Find the vendor with the least average lead time for Product ID 348.",
        "ground_truth": "SELECT T2.Name FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.ProductID = 348 ORDER BY T1.AverageLeadTime ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_id, AVG(lead_time) as avg_lead_time \nFROM product_vendors \nWHERE product_id = 348 \nGROUP BY vendor_id \nORDER BY avg_lead_time DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2197": {
        "db_id": "world_development_indicators",
        "question": "What South Asian nations have low incomes? Please include the entire names of the nations in your answer.",
        "ground_truth": "SELECT LongName FROM Country WHERE IncomeGroup = 'Low income' AND Region = 'South Asia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE region = 'South Asia' AND income_level = 'low';"
        ],
        "rule_sql": []
    },
    "4302": {
        "db_id": "simpson_episodes",
        "question": "List down person's name who has nickname.",
        "ground_truth": "SELECT name FROM Person WHERE nickname IS NOT NULL;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM person WHERE nickname IS NULL;"
        ],
        "rule_sql": []
    },
    "2301": {
        "db_id": "movielens",
        "question": "List the cast and the director of the movie with the id 1949144.",
        "ground_truth": "SELECT T1.actorid, T2.directorid FROM movies2actors AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.movieid = 1949144",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cast, director FROM movies WHERE id = 1949144;"
        ],
        "rule_sql": []
    },
    "8941": {
        "db_id": "human_resources",
        "question": "How much higher is James Johnson's salary from the minimum salary of his title?",
        "ground_truth": "SELECT CAST(REPLACE(SUBSTR(T1.salary, 4), ',', '') AS REAL) - CAST(REPLACE(SUBSTR(T2.minsalary, 4), ',', '') AS REAL) AS diff FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.lastname = 'Johnson' AND T1.firstname = 'James'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT salary - MIN(salary) AS salary_difference \nFROM employees \nWHERE name = 'James Johnson'"
        ],
        "rule_sql": []
    },
    "4591": {
        "db_id": "mental_health_survey",
        "question": "According to 2016's survey, what is the number of users with a mental health disorder in the past?",
        "ground_truth": "SELECT COUNT(T2.UserID) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2016 AND T1.questiontext LIKE 'Have you had a mental health disorder in the past?' AND T2.AnswerText = 'Yes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM survey_data WHERE year = 2016 AND mental_health_disorder = 'yes' AND past_disorder = 'yes';"
        ],
        "rule_sql": []
    },
    "3913": {
        "db_id": "public_review_platform",
        "question": "Find out which hotel and travel business having the most review? Calculate the standard deviation of the review star for this business.",
        "ground_truth": "SELECT T2.category_id FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Reviews AS T3 ON T3.business_id = T1.business_id WHERE T2.category_name = 'Hotels & Travel' GROUP BY T2.category_id ORDER BY COUNT(T2.category_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    b.name AS business_name,\n    COUNT(r.review_id) AS review_count,\n    STDDEV(r.stars) AS star_stddev\nFROM business b\nJOIN review r ON b.business_id = r.business_id\nWHERE b.categories LIKE '%Hotel%' OR b.categories LIKE '%Travel%'\nGROUP BY b.business_id\nORDER BY review_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1209": {
        "db_id": "talkingdata",
        "question": "How many men under the age of 23 have apps installed but are not active on their devices?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id WHERE T1.gender = 'M' AND T3.is_active = 0 AND T1.age < 23",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE gender = 'male' AND age < 23 AND apps_installed > 0 AND last_active_date IS NULL;"
        ],
        "rule_sql": []
    },
    "621": {
        "db_id": "codebase_comments",
        "question": "Give the repository ID for the solution of method \"Kalibrasi.Data.EntityClasses.THistoryJadwalEntity.GetSingleTjadwal\".",
        "ground_truth": "SELECT DISTINCT T1.RepoId FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'Kalibrasi.Data.EntityClasses.THistoryJadwalEntity.GetSingleTjadwal'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT repository_id FROM repositories WHERE method_name = 'Kalibrasi.Data.EntityClasses.THistoryJadwalEntity.GetSingleTjadwal'"
        ],
        "rule_sql": []
    },
    "7486": {
        "db_id": "image_and_language",
        "question": "Please list the IDs of all the images with more than 2 pairs of object samples with the relation \"parked on\".",
        "ground_truth": "SELECT T2.IMG_ID FROM PRED_CLASSES AS T1 INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T1.PRED_CLASS = 'parked on' AND T2.OBJ1_SAMPLE_ID != T2.OBJ2_SAMPLE_ID GROUP BY T2.IMG_ID HAVING COUNT(T2.IMG_ID) > 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id FROM object_relations WHERE relation_type = 'parked on' GROUP BY image_id HAVING COUNT(*) > 2;"
        ],
        "rule_sql": []
    },
    "1586": {
        "db_id": "car_retails",
        "question": "Among the German customers, how many of the them has credit limit of zero?",
        "ground_truth": "SELECT COUNT(customerNumber) FROM customers WHERE creditLimit = 0 AND country = 'Germany'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE country = 'Germany' AND creditLimit > 0;"
        ],
        "rule_sql": []
    },
    "9424": {
        "db_id": "movie_3",
        "question": "Please give the full name of the customer who had made the biggest amount of payment in one single film rental.",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id ORDER BY T1.amount DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name\nFROM customer c\nJOIN payment p ON c.customer_id = p.customer_id\nGROUP BY c.customer_id\nORDER BY SUM(p.amount) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4588": {
        "db_id": "mental_health_survey",
        "question": "Please list all the common questions in 2014's survey and 2016's survey.",
        "ground_truth": "SELECT T1.questiontext FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID IN (2014, 2016) GROUP BY T1.questiontext",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT question FROM survey_2014 INTERSECT SELECT question FROM survey_2016 WHERE year = 2014 OR year = 2016;"
        ],
        "rule_sql": []
    },
    "5033": {
        "db_id": "olympics",
        "question": "What is the sport name of \"Cross Country Skiing Men's 10/15 kilometres Pursuit\" event?",
        "ground_truth": "SELECT T1.sport_name FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T2.event_name LIKE 'Cross Country Skiing Men%s 10/15 kilometres Pursuit'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sport_name FROM events WHERE event_name = 'Cross Country Skiing Men\\'s 10/15 kilometres Pursuit';"
        ],
        "rule_sql": []
    },
    "1480": {
        "db_id": "synthea",
        "question": "What care plans have been received by Mrs. Elly Koss during year 1970?",
        "ground_truth": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND strftime('%Y', T2.START) = '2013'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM care_plans WHERE patient_name = 'Mrs. Elly Koss' AND year = 1970;"
        ],
        "rule_sql": []
    },
    "8101": {
        "db_id": "university",
        "question": "How many female students were there in Pierre and Marie Curie University in 2015?",
        "ground_truth": "SELECT CAST(T1.num_students * T1.pct_female_students AS REAL) / 100 FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2015 AND T2.university_name = 'Pierre and Marie Curie University'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university = 'Pierre and Marie Curie University' AND year = 2015 AND gender = 'female';"
        ],
        "rule_sql": []
    },
    "7425": {
        "db_id": "works_cycles",
        "question": "How many employees came into the Quality Assurance Group in the year 2007?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T2.GroupName = 'Quality Assurance' AND STRFTIME('%Y', T1.StartDate) = '2007'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE department = 'Quality Assurance Group' AND hire_date LIKE '2007%';"
        ],
        "rule_sql": []
    },
    "12": {
        "db_id": "movie_platform",
        "question": "For all movies where users left a critic, find the movie name, user, rating and critics comments from the user.",
        "ground_truth": "SELECT T2.movie_title, T1.user_id, T1.rating_score, T1.critic FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.critic IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_name, user, rating, critics_comments FROM movies WHERE critics_comments IS NOT NULL"
        ],
        "rule_sql": []
    },
    "1201": {
        "db_id": "talkingdata",
        "question": "Indicate the location of all the events that occurred on April 30, 2016.",
        "ground_truth": "SELECT longitude, latitude FROM events WHERE date(timestamp) = '2016-04-30'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM events WHERE date = '2016-04-30';"
        ],
        "rule_sql": []
    },
    "444": {
        "db_id": "movies_4",
        "question": "Who played Captain Jack Sparrow in all of the Pirates of the Caribbean movies?",
        "ground_truth": "SELECT DISTINCT T3.person_name FROM movie AS T1 INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T2.character_name = 'Captain Jack Sparrow' AND T1.title LIKE 'Pirates of the Caribbean%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM movies WHERE character_name = 'Captain Jack Sparrow' AND movie_title LIKE '%Pirates of the Caribbean%';"
        ],
        "rule_sql": []
    },
    "4581": {
        "db_id": "mental_health_survey",
        "question": "What is the percentage of the the users who would bring up a mental health issue with a potential employer in an interview?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN T1.AnswerText LIKE 'Yes' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 12",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users) AS percentage\nFROM users \nWHERE mental_health_issue = 'yes'"
        ],
        "rule_sql": []
    },
    "6349": {
        "db_id": "retail_world",
        "question": "Tell the country name of the supplier for \"Scottish Longbreads\".",
        "ground_truth": "SELECT T2.Country FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.ProductName = 'Scottish Longbreads'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM suppliers WHERE product_name = 'Scottish Longbreads';"
        ],
        "rule_sql": []
    },
    "8483": {
        "db_id": "mondial_geo",
        "question": "What is the population of the country with the highest infant mortality rate?",
        "ground_truth": "SELECT T1.Population FROM country AS T1 INNER JOIN population AS T2 ON T1.Code = T2.Country ORDER BY T2.Infant_Mortality DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM countries ORDER BY infant_mortality_rate ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5172": {
        "db_id": "address",
        "question": "Compare the numbers of postal points under Smith Adrian and Heck Joe.",
        "ground_truth": "SELECT CASE WHEN COUNT(CASE WHEN T1.first_name = 'Smith' AND T1.last_name = 'Adrian' THEN T2.zip_code ELSE NULL END) > COUNT(CASE WHEN T1.first_name = 'Heck' AND T1.last_name = 'Joe' THEN T2.zip_code ELSE NULL END) THEN 'Smith Adrian>Heck Joe' ELSE 'Smith Adrian<=Heck Joe' END AS COMPARE FROM congress AS T1 INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM postal_points WHERE name = 'Smith Adrian' AND name = 'Heck Joe';"
        ],
        "rule_sql": []
    },
    "5507": {
        "db_id": "menu",
        "question": "Please describe the menu sponsored by Noviomagus physically.",
        "ground_truth": "SELECT physical_description FROM Menu WHERE sponsor = 'Noviomagus'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM menu_items WHERE sponsor = 'Noviomagus' ORDER BY physical_description;"
        ],
        "rule_sql": []
    },
    "1951": {
        "db_id": "soccer_2016",
        "question": "Which season has the fewest number of matches?",
        "ground_truth": "SELECT Season_Id FROM `Match` GROUP BY Season_Id ORDER BY COUNT(Match_Id) LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT season, COUNT(*) as match_count FROM matches GROUP BY season ORDER BY match_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1309": {
        "db_id": "law_episode",
        "question": "How many stars did the episodes in which Donna Villella worked?",
        "ground_truth": "SELECT COUNT(T3.person_id) FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE T3.name = 'Donna Villella'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stars WHERE actor_name = 'Donna Villella'"
        ],
        "rule_sql": []
    },
    "5758": {
        "db_id": "language_corpus",
        "question": "List out the title of Catalan language Wikipedia page that has wikipedia revision page id as 106601.",
        "ground_truth": "SELECT title FROM pages WHERE revision = 106601",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM wikipedia WHERE language = 'Catalan' AND revision_id = 106601;"
        ],
        "rule_sql": []
    },
    "4338": {
        "db_id": "simpson_episodes",
        "question": "List out the title of episodes which have star score of 2.",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 2;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE star_score = 2;"
        ],
        "rule_sql": []
    },
    "2611": {
        "db_id": "regional_sales",
        "question": "State the delivery date of cookware.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT IIF(T2.`Product Name` = 'Cookware', T1.DeliveryDate, NULL) AS T FROM `Sales Orders` T1 INNER JOIN Products T2 ON T2.ProductID = T1._ProductID ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT delivery_date FROM cookware WHERE product_name = 'cookware';"
        ],
        "rule_sql": []
    },
    "6190": {
        "db_id": "food_inspection_2",
        "question": "Calculate the average inspections per year done by Jessica Anthony from 2010 to 2017.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.first_name = 'Jessica' AND T1.last_name = 'Anthony' THEN T2.inspection_id ELSE 0 END) AS REAL) / 8 FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y', T2.inspection_date) BETWEEN '2010' AND '2017'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(inspection_count) FROM inspections WHERE inspector_name = 'Jessica Anthony' AND year BETWEEN 2010 AND 2017"
        ],
        "rule_sql": []
    },
    "1090": {
        "db_id": "talkingdata",
        "question": "Please list the IDs of the events happened on all the vivo devices.",
        "ground_truth": "SELECT T2.event_id FROM phone_brand_device_model2 AS T1 INNER JOIN events AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'vivo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_id FROM events WHERE device_type = 'vivo'"
        ],
        "rule_sql": []
    },
    "5087": {
        "db_id": "address",
        "question": "In which county is the residential area with the highest average income per household located?",
        "ground_truth": "SELECT T2.county FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'ARECIBO' GROUP BY T2.county ORDER BY T1.avg_income_per_household DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county FROM residential_areas ORDER BY average_income DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3050": {
        "db_id": "shakespeare",
        "question": "Give the title and the characters name of the most recent work of Shakespeare.",
        "ground_truth": "SELECT T1.Title, T4.CharName FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id ORDER BY T1.Date DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, character_name FROM shakespeare_works ORDER BY year DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3353": {
        "db_id": "video_games",
        "question": "List the names of all the publishers who published one game only.",
        "ground_truth": "SELECT T.publisher_name FROM ( SELECT T2.publisher_name, COUNT(DISTINCT T1.game_id) FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id GROUP BY T2.publisher_name HAVING COUNT(DISTINCT T1.game_id) = 1 ) t",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM publishers WHERE COUNT(game_id) = 1;"
        ],
        "rule_sql": []
    },
    "2025": {
        "db_id": "soccer_2016",
        "question": "How many seasons did Pune Warriors participate in?",
        "ground_truth": "SELECT COUNT(T.Season_Year) FROM ( SELECT T4.Season_Year FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner INNER JOIN Player_Match AS T3 ON T1.Team_Id = T3.Team_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id WHERE T1.Team_Name = 'Pune Warriors' GROUP BY T4.Season_Year ) T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM seasons WHERE team = 'Pune Warriors';"
        ],
        "rule_sql": []
    },
    "3022": {
        "db_id": "shakespeare",
        "question": "List the scenes and descriptions in Act 1 of \" Pericles, Prince of Tyre\".",
        "ground_truth": "SELECT T2.Scene, T2.Description FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.LongTitle = 'Pericles, Prince of Tyre' AND T2.Act = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT scene, description FROM scenes WHERE act = 1 AND play = 'Pericles, Prince of Tyre';"
        ],
        "rule_sql": []
    },
    "2729": {
        "db_id": "regional_sales",
        "question": "Between 2018 to 2020, what is the average amount of shipped orders per year under Carl Nguyen?",
        "ground_truth": "SELECT CAST(COUNT(T1.OrderNumber) AS REAL) / 3 FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE (T2.`Sales Team` = 'Carl Nguyen' AND ShipDate LIKE '%/%/18') OR (T2.`Sales Team` = 'Carl Nguyen' AND ShipDate LIKE '%/%/19') OR (T2.`Sales Team` = 'Carl Nguyen' AND ShipDate LIKE '%/%/20')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(total_amount) as average_amount\nFROM orders\nWHERE salesperson = 'Carl Nguyen'\nAND order_date BETWEEN '2018-01-01' AND '2020-12-31'\nGROUP BY YEAR(order_date)"
        ],
        "rule_sql": []
    },
    "8494": {
        "db_id": "mondial_geo",
        "question": "What river has the 17th-longest length overall? Specify it's length.",
        "ground_truth": "SELECT Name, Length FROM river ORDER BY Length DESC LIMIT 16, 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, length FROM rivers ORDER BY length DESC LIMIT 1 OFFSET 16;"
        ],
        "rule_sql": []
    },
    "2508": {
        "db_id": "genes",
        "question": "Taking all the essential genes of the transcription factors class located in the nucleus as a reference, how many of them carry out a genetic-type interaction with another gene? List them.",
        "ground_truth": "SELECT T2.GeneID1 FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Localization = 'nucleus' AND T1.Class = 'Transcription factors' AND T1.Essential = 'Essential' AND T2.Expression_Corr != 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM genes \nWHERE gene_class = 'transcription factors' \nAND location = 'nucleus' \nAND is_essential = 1 \nAND interaction_type = 'genetic'"
        ],
        "rule_sql": []
    },
    "5988": {
        "db_id": "books",
        "question": "How many percent of orders in 2020 used international shipping?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cust_order AS T1 INNER JOIN shipping_method AS T2 ON T1.shipping_method_id = T2.method_id WHERE STRFTIME('%Y', T1.order_date) = '2020'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN shipping_type = 'international' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM orders\nWHERE order_date LIKE '2020%';"
        ],
        "rule_sql": []
    },
    "7287": {
        "db_id": "works_cycles",
        "question": "Please list the reviewers who have given the highest rating for a medium class, women's product.",
        "ground_truth": "SELECT T1.ReviewerName FROM ProductReview AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Class = 'M' AND T2.Style = 'W' AND T1.Rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reviewer_name FROM reviews WHERE product_class = 'medium' AND gender = 'women' ORDER BY rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7721": {
        "db_id": "hockey",
        "question": "How many former athletes go on to become coaches after retiring?",
        "ground_truth": "SELECT COUNT(playerID) FROM Master WHERE playerID IS NOT NULL AND coachID IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE retired = 'yes' AND occupation = 'coach';"
        ],
        "rule_sql": []
    },
    "981": {
        "db_id": "computer_student",
        "question": "Who are the professors who gave advice to students in the 12th years of program?",
        "ground_truth": "SELECT T1.p_id_dummy FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.yearsInProgram = 'Year_12'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT p.name \nFROM professors p\nJOIN advice a ON p.professor_id = a.professor_id\nJOIN students s ON a.student_id = s.student_id\nWHERE s.program_year = 12;"
        ],
        "rule_sql": []
    },
    "1657": {
        "db_id": "car_retails",
        "question": "How many motorcycles have been ordered in 2004?",
        "ground_truth": "SELECT SUM(t2.quantityOrdered) FROM orders AS t1 INNER JOIN orderdetails AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN products AS t3 ON t2.productCode = t3.productCode WHERE t3.productLine = 'motorcycles' AND STRFTIME('%Y', t1.orderDate) = '2004'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE product_type = 'motorcycle' AND order_date LIKE '2004%';"
        ],
        "rule_sql": []
    },
    "81": {
        "db_id": "movie_platform",
        "question": "What's the average rating score of the movie \"A Way of Life\"?",
        "ground_truth": "SELECT AVG(T1.rating_score) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'A Way of Life'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM movies WHERE title = 'A Way of Life';"
        ],
        "rule_sql": []
    },
    "9193": {
        "db_id": "movie_3",
        "question": "How many cities are there in the United States?",
        "ground_truth": "SELECT COUNT(T2.city) FROM country AS T1 INNER JOIN city AS T2 ON T1.country_id = T2.country_id WHERE T1.country = 'United States'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "7895": {
        "db_id": "world",
        "question": "How many countries have no GNP?",
        "ground_truth": "SELECT COUNT(*) FROM Country WHERE GNP = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM country WHERE GNP IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "9183": {
        "db_id": "movie_3",
        "question": "What is the full name of the customer who rented movies for 7 consecutive days?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM customer AS T1 INNER JOIN ( SELECT customer_id, COUNT(*) AS num_days FROM ( SELECT *, date(days, '-' || rn || ' day') AS results FROM ( SELECT customer_id, days, row_number() OVER (PARTITION BY customer_id ORDER BY days) AS rn FROM ( SELECT DISTINCT customer_id, date(rental_date) AS days FROM rental ) ) ) GROUP BY customer_id, results HAVING num_days = 7 ) AS T2 ON T1.customer_id = T2.customer_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name \nFROM customers c\nJOIN rentals r ON c.customer_id = r.customer_id\nWHERE DATEDIFF(MAX(r.rental_date), MIN(r.rental_date)) = 6\nGROUP BY c.customer_id\nHAVING COUNT(DISTINCT r.rental_date) = 7;"
        ],
        "rule_sql": []
    },
    "1094": {
        "db_id": "talkingdata",
        "question": "Among the users who uses a vivo device, how many of them are female and under 30?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'F' AND T2.phone_brand = 'vivo' AND T1.age < 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE device = 'vivo' AND gender = 'female' AND age > 30;"
        ],
        "rule_sql": []
    },
    "5138": {
        "db_id": "address",
        "question": "State the male population for all zip code which were under the Berlin, NH CBSA.",
        "ground_truth": "SELECT T2.male_population FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'Berlin, NH' GROUP BY T2.male_population",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, male_population FROM population_data WHERE cbsa = 'Berlin, NH' AND gender = 'male';"
        ],
        "rule_sql": []
    },
    "8686": {
        "db_id": "chicago_crime",
        "question": "What is the most reported crime in the Northwest side?",
        "ground_truth": "SELECT T3.secondary_description FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no INNER JOIN IUCR AS T3 ON T3.iucr_no = T2.iucr_no WHERE T1.side = 'Northwest ' GROUP BY T3.secondary_description ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT crime_type, COUNT(*) as report_count FROM crimes WHERE side = 'Northwest' GROUP BY crime_type ORDER BY report_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7905": {
        "db_id": "world",
        "question": "What are the districts that belong to the country with the lowest surface area?",
        "ground_truth": "SELECT T1.District FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code ORDER BY T2.SurfaceArea ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM country WHERE surface_area = (SELECT MIN(surface_area) FROM country);"
        ],
        "rule_sql": []
    },
    "3401": {
        "db_id": "video_games",
        "question": "List the platforms that release the most games each year.",
        "ground_truth": "SELECT T1.platform_name FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id GROUP BY T2.release_year, T1.platform_name ORDER BY COUNT(DISTINCT T3.game_id) DESC",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, platform, COUNT(*) as game_count \nFROM games \nGROUP BY year, platform \nORDER BY year, game_count DESC;"
        ],
        "rule_sql": []
    },
    "734": {
        "db_id": "movie",
        "question": "Which movie is the character Dr. Archibald 'Moonlight' Graham from?",
        "ground_truth": "SELECT T1.Title FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T2.`Character Name` = 'Dr. Archibald ''Moonlight'' Graham'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_title FROM movies WHERE character_name = 'Dr. Archibald Moonlight Graham';"
        ],
        "rule_sql": []
    },
    "5795": {
        "db_id": "language_corpus",
        "question": "For the biwords pair that appears \"116430\" times, what is the second word of the pair?",
        "ground_truth": "SELECT T1.word FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w2nd WHERE T2.occurrences = 116430",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT second_word FROM biwords WHERE frequency = 116430 LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8070": {
        "db_id": "university",
        "question": "Among the universities with over 20000 students in 2011, how many of them have an international students percentage of over 25% in the same year?",
        "ground_truth": "SELECT COUNT(*) FROM university_year WHERE year = 2011 AND pct_international_students > 25 AND num_students > 20000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM universities \nWHERE students > 20000 \nAND international_students_percentage > 25 \nAND year = 2011"
        ],
        "rule_sql": []
    },
    "920": {
        "db_id": "cs_semester",
        "question": "Provide the registered courses' names by undergraduate students with GPA of 3.7 and above.",
        "ground_truth": "SELECT DISTINCT T1.f_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T1.type = 'UG' AND T1.gpa > 3.7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name FROM courses WHERE student_type = 'undergraduate' AND gpa >= 3.7;"
        ],
        "rule_sql": []
    },
    "348": {
        "db_id": "retail_complains",
        "question": "How many clients who live in New York City have the complaint outcome as \"AGENT\"?",
        "ground_truth": "SELECT COUNT(T2.`rand client`) FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.city = 'New York City' AND T2.outcome = 'AGENT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE city = 'New York' AND complaint_outcome = 'AGENT';"
        ],
        "rule_sql": []
    },
    "5686": {
        "db_id": "language_corpus",
        "question": "List the page number for Catalan language wikipedia pages containing the word 'Art' in the page title.",
        "ground_truth": "SELECT page FROM pages WHERE title LIKE 'Art%' OR title LIKE '%Art%' OR title LIKE '%Art'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_id FROM page WHERE page_title LIKE '%Art%' AND page_lang = 'Catalan';"
        ],
        "rule_sql": []
    },
    "4049": {
        "db_id": "public_review_platform",
        "question": "How many business are opened for more than 8 hour in Mesa and what is the percentage of the active businesses?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.active = 'true' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) AS ACT FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'Mesa'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS total_businesses,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM businesses WHERE city = 'Mesa')) AS percentage\nFROM businesses \nWHERE city = 'Mesa' \nAND (closing_time - opening_time) > 8;"
        ],
        "rule_sql": []
    },
    "4056": {
        "db_id": "public_review_platform",
        "question": "How many businesses id are rated more than 4?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE stars > 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE rating > 4;"
        ],
        "rule_sql": []
    },
    "4243": {
        "db_id": "simpson_episodes",
        "question": "List the categories for which Bonita Pietila was given credit and her role in creating the episodes.",
        "ground_truth": "SELECT DISTINCT category, role FROM Credit WHERE person = 'Bonita Pietila';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, role FROM episodes WHERE name = 'Bonita Pietila';"
        ],
        "rule_sql": []
    },
    "2311": {
        "db_id": "movielens",
        "question": "Please list director IDs who have the quality of at least 3 and have made at least 2 different genres of movies.",
        "ground_truth": "SELECT T1.directorid FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE T1.d_quality >= 3 GROUP BY T1.directorid HAVING COUNT(T2.movieid) >= 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director_id \nFROM directors \nWHERE quality >= 3 \nGROUP BY director_id \nHAVING COUNT(*) >= 2"
        ],
        "rule_sql": []
    },
    "7029": {
        "db_id": "works_cycles",
        "question": "Which customer has the highest subtotal amount of sales orders whose assigned to the salesperson with the highest bonus?",
        "ground_truth": "SELECT T1.CustomerID FROM SalesOrderHeader AS T1 INNER JOIN SalesPerson AS T2 ON T1.SalesPersonID = T2.BusinessEntityID ORDER BY T1.SubTotal DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.CustomerName, SUM(so.SubTotal) as TotalSales\nFROM Customers c\nJOIN SalesOrders so ON c.CustomerID = so.CustomerID\nJOIN SalesPersons sp ON so.SalesPersonID = sp.SalesPersonID\nWHERE sp.Bonus = (SELECT MAX(Bonus) FROM SalesPersons)\nGROUP BY c.CustomerID\nORDER BY TotalSales DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1234": {
        "db_id": "talkingdata",
        "question": "What is the percentage of users who are in the same behavior category as \"Academic Information\"?",
        "ground_truth": "SELECT SUM(IIF(T1.category = 'Academic Information', 1.0, 0)) / COUNT(T2.app_id) AS per FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users)) AS percentage\nFROM users \nWHERE behavior_category = 'Academic Information';"
        ],
        "rule_sql": []
    },
    "2215": {
        "db_id": "world_development_indicators",
        "question": "What portion of the nations in Latin America and the Caribbean had more than 50% of their land used for agriculture in 1961?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Value > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.CountryCode) FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Year = 1961 AND T2.Region = 'Latin America & Caribbean' AND indicatorname = 'Agricultural land (% of land area)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) / (SELECT COUNT(*) FROM nations WHERE region = 'Latin America and Caribbean') AS portion\nFROM nations \nWHERE region = 'Latin America and Caribbean' \nAND agricultural_land_percentage > 50 \nAND year = 1961;"
        ],
        "rule_sql": []
    },
    "2930": {
        "db_id": "professional_basketball",
        "question": "Among the coaches who won the 'NBA coach of the year' award from 1971 - 1975, how many of them were in 'POR' team?",
        "ground_truth": "SELECT COUNT(T1.id) FROM awards_coaches AS T1 INNER JOIN teams AS T2 ON T1.year = T2.year WHERE T1.year BETWEEN 1971 AND 1975 AND T1.award = 'NBA Coach of the Year' AND T2.tmID = 'POR'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM coaches \nWHERE award = 'NBA coach of the year' \nAND year BETWEEN 1971 AND 1975 \nAND team = 'POR';"
        ],
        "rule_sql": []
    },
    "5337": {
        "db_id": "beer_factory",
        "question": "List out the root beers bought by Tim Ocel and Dawn Childress.",
        "ground_truth": "SELECT T2.RootBeerID FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T2.CustomerID = T1.CustomerID WHERE (T1.First = 'Tim' AND T1.Last = 'Ocel') OR (T1.First = 'Dawn' AND T1.Last = 'Childress')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM purchases WHERE customer_name IN ('Tim Ocel', 'Dawn Childress') AND product_type = 'soda';"
        ],
        "rule_sql": []
    },
    "9091": {
        "db_id": "bike_share_1",
        "question": "How many bikes could Evelyn Park and Ride hold and how many users who started on that station are subscribers?",
        "ground_truth": "SELECT SUM(T2.dock_count), COUNT(T1.subscription_type) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.name = 'Evelyn Park and Ride' AND T1.start_station_name = T2.name AND T1.subscription_type = 'Subscriber'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT capacity, COUNT(*) AS subscriber_count\nFROM stations s\nJOIN trips t ON s.station_id = t.start_station_id\nWHERE s.name = 'Evelyn Park and Ride'\nAND t.subscription_type = 'Subscriber';"
        ],
        "rule_sql": []
    },
    "5083": {
        "db_id": "address",
        "question": "Which residential area in Arecibo county has the highest average house value? Please give its zip_code.",
        "ground_truth": "SELECT T1.zip_code FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'ARECIBO' ORDER BY T1.avg_house_value DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM residential_areas WHERE county = 'Arecibo' ORDER BY house_value DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6845": {
        "db_id": "retails",
        "question": "List the phone numbers of customers whose order priority is urgent.",
        "ground_truth": "SELECT T2.c_phone FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T1.o_orderpriority = '1-URGENT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers WHERE order_priority = 'urgent';"
        ],
        "rule_sql": []
    },
    "3317": {
        "db_id": "video_games",
        "question": "In which year was Panzer Tactics released on DS?",
        "ground_truth": "SELECT T4.release_year FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN game AS T3 ON T1.game_id = T3.id INNER JOIN game_platform AS T4 ON T1.id = T4.game_publisher_id INNER JOIN platform AS T5 ON T4.platform_id = T5.id WHERE T3.game_name = 'Panzer Tactics' AND T5.platform_name = 'DS'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_year FROM games WHERE title = 'Panzer Tactics' AND platform = 'DS';"
        ],
        "rule_sql": []
    },
    "9322": {
        "db_id": "movie_3",
        "question": "Please indicate the full name of actor id 5.",
        "ground_truth": "SELECT first_name, last_name FROM actor WHERE actor_id = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM actors WHERE actor_id = 5;"
        ],
        "rule_sql": []
    },
    "2396": {
        "db_id": "superstore",
        "question": "List the products that were ordered by Anne McFarland from the Western store.",
        "ground_truth": "SELECT DISTINCT T3.`Product Name` FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Anne McFarland'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name \nFROM products p\nJOIN order_details od ON p.product_id = od.product_id\nJOIN orders o ON od.order_id = o.order_id\nJOIN customers c ON o.customer_id = c.customer_id\nJOIN stores s ON o.store_id = s.store_id\nWHERE c.first_name = 'Anne' \nAND s.store_name = 'Western'"
        ],
        "rule_sql": []
    },
    "2262": {
        "db_id": "movielens",
        "question": "What are the ID of actors that had worked together with director 22397? What was the genre of that movie?",
        "ground_truth": "SELECT T2.actorid, T4.genre FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid INNER JOIN movies2directors AS T4 ON T1.movieid = T4.movieid WHERE T4.directorid = 22397",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.actor_id, m.genre \nFROM actors a \nJOIN movies m ON a.movie_id = m.movie_id \nWHERE m.director_id = 22397 \nGROUP BY a.actor_id, m.genre"
        ],
        "rule_sql": []
    },
    "486": {
        "db_id": "movies_4",
        "question": "List down five movie titles that were released before 2000.",
        "ground_truth": "SELECT title FROM movie WHERE CAST(STRFTIME('%Y', release_date) AS INT) < 2000 LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE release_year > 2000 LIMIT 5;"
        ],
        "rule_sql": []
    },
    "7236": {
        "db_id": "works_cycles",
        "question": "Where does the person with the BusinessEntityID \"5555\" live?",
        "ground_truth": "SELECT T3.City, T3.AddressLine1 FROM BusinessEntityAddress AS T1 INNER JOIN AddressType AS T2 ON T1.AddressTypeID = T2.AddressTypeID INNER JOIN Address AS T3 ON T1.AddressID = T3.AddressID WHERE T1.BusinessEntityID = 5555 AND T2.Name = 'Home'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM Person WHERE BusinessEntityID = '5555';"
        ],
        "rule_sql": []
    },
    "3653": {
        "db_id": "authors",
        "question": "What is the homepage URL for the journal that published the most papers?",
        "ground_truth": "SELECT T2.HomePage FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id GROUP BY T1.JournalId ORDER BY COUNT(T1.JournalId) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT homepage FROM journal ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3349": {
        "db_id": "video_games",
        "question": "What are the names of the publishers who published the oldest games?",
        "ground_truth": "SELECT DISTINCT T3.publisher_name FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id ORDER BY T1.release_year LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name FROM publishers ORDER BY release_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "270": {
        "db_id": "retail_complains",
        "question": "For all the complaint callers on 2017/3/27, what percentage of the clients are females?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.sex = 'Female' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.sex) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Date received` = '2017-03-27'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS female_percentage\nFROM clients\nWHERE call_date = '2017-03-27'\nAND complaint_type IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "9383": {
        "db_id": "movie_3",
        "question": "Identify the full name of the customer, who has the following email address: SHEILA.WELLS@sakilacustomer.org.",
        "ground_truth": "SELECT first_name, last_name FROM customer WHERE email = 'SHEILA.WELLS@sakilacustomer.org'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customer WHERE email = 'SHEILA.WELLS@sakilacustomer.org';"
        ],
        "rule_sql": []
    },
    "559": {
        "db_id": "movies_4",
        "question": "What is the role of Mark Hammel?",
        "ground_truth": "SELECT T2.job FROM person AS T1 INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Mark Hammel'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role FROM actors WHERE name = 'Mark Hammel';"
        ],
        "rule_sql": []
    },
    "2519": {
        "db_id": "app_store",
        "question": "How many apps have rating of 5?",
        "ground_truth": "SELECT COUNT(App) FROM playstore WHERE Rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM apps WHERE rating = 4;"
        ],
        "rule_sql": []
    },
    "7906": {
        "db_id": "world",
        "question": "List down the country names of countries that have a GNP lower than 1000 and have Dutch as their language.",
        "ground_truth": "SELECT T2.Name FROM CountryLanguage AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.GNP < 1000 AND T1.IsOfficial = 'T' AND T1.Language = 'Dutch'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country.Name FROM Country JOIN CountryLanguage ON Country.Code = CountryLanguage.CountryCode WHERE Country.GNP > 1000 AND CountryLanguage.Language = 'Dutch';"
        ],
        "rule_sql": []
    },
    "6355": {
        "db_id": "retail_world",
        "question": "How many customers are there in the country with the highest number of customers?",
        "ground_truth": "SELECT COUNT(CustomerID) FROM Customers GROUP BY Country ORDER BY COUNT(CustomerID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE country = (SELECT country FROM customers GROUP BY country ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "1556": {
        "db_id": "car_retails",
        "question": "Which two products has the highest and lowest expected profits? Determine the total price for each product in terms of the largest quantity that was ordered.",
        "ground_truth": "SELECT T2.productName, SUM(T1.quantityOrdered * T1.priceEach) FROM orderdetails AS T1 INNER JOIN ( SELECT productCode, productName FROM products ORDER BY MSRP - buyPrice DESC LIMIT 1 ) AS T2 ON T1.productCode = T2.productCode UNION SELECT T2.productName, SUM(quantityOrdered * priceEach) FROM orderdetails AS T1 INNER JOIN ( SELECT productCode, productName FROM products ORDER BY MSRP - buyPrice ASC LIMIT 1 ) AS T2 ON T1.productCode = T2.productCode",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    p.ProductName,\n    MAX(od.Quantity) as MaxQuantity,\n    p.UnitPrice * MAX(od.Quantity) as TotalPrice,\n    (p.UnitPrice - p.Cost) * MAX(od.Quantity) as ExpectedProfit\nFROM \n    Products p\nJOIN \n    OrderDetails od ON p.ProductID = od.ProductID\nGROUP BY \n    p.ProductID\nORDER BY \n    ExpectedProfit DESC\nLIMIT 2;"
        ],
        "rule_sql": []
    },
    "2944": {
        "db_id": "professional_basketball",
        "question": "Which team did the youngest player who could be in F-G position play in the NBA?",
        "ground_truth": "SELECT T1.tmID FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN players AS T3 ON T2.playerID = T3.playerID WHERE T3.pos = 'F-G' AND T2.lgID = 'NBA' ORDER BY T3.birthDate DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team FROM players WHERE position = 'F-G' ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3370": {
        "db_id": "video_games",
        "question": "In which platform does the game titled 15 Days available?",
        "ground_truth": "SELECT T1.platform_name FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id INNER JOIN game AS T4 ON T3.game_id = T4.id WHERE T4.game_name = 'Counter Force'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform FROM games WHERE title = '15 Days';"
        ],
        "rule_sql": []
    },
    "8911": {
        "db_id": "cookbook",
        "question": "Provide the ingredients and maximum quantities of the recipe which can serve 7 people.",
        "ground_truth": "SELECT T3.name, T2.max_qty FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T1.servings = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ingredients, MAX(quantity) FROM recipes WHERE servings = 7;"
        ],
        "rule_sql": []
    },
    "2496": {
        "db_id": "genes",
        "question": "For the pairs of genes with one having 8 chromosomes and the other having 6 chromosomes, what is the highest expression correlation score?",
        "ground_truth": "SELECT T2.Expression_Corr FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Chromosome = 6 OR T1.Chromosome = 8 ORDER BY T2.Expression_Corr DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(correlation_score) \nFROM gene_pairs \nWHERE gene1_chromosomes = 8 AND gene2_chromosomes = 6;"
        ],
        "rule_sql": []
    },
    "2216": {
        "db_id": "world_development_indicators",
        "question": "What are the full names of the countries in South Asia that belongs to the low income group?",
        "ground_truth": "SELECT LongName FROM Country WHERE IncomeGroup = 'Low income' AND Region = 'South Asia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE region = 'South Asia' AND income_group = 'Low income';"
        ],
        "rule_sql": []
    },
    "3119": {
        "db_id": "cars",
        "question": "Among the cars from Asia, list the IDs of cars that were introduced in 1979.",
        "ground_truth": "SELECT T1.ID FROM production AS T1 INNER JOIN country AS T2 ON T1.country = T2.origin WHERE T2.country = 'Japan' AND T1.model_year = 1979",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT car_id FROM cars WHERE continent = 'Asia' AND year_introduced = 1979;"
        ],
        "rule_sql": []
    },
    "2712": {
        "db_id": "regional_sales",
        "question": "List the name of the customer with the most number of order quantity from 2018 to 2020.",
        "ground_truth": "SELECT T1.`Customer Names` FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID WHERE T2.OrderDate LIKE '%/%/18' OR T2.OrderDate LIKE '%/%/19' OR T2.OrderDate LIKE '%/%/20' ORDER BY T2.`Order Quantity` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name \nFROM customers \nWHERE order_date BETWEEN '2018-01-01' AND '2020-12-31' \nGROUP BY customer_name \nORDER BY COUNT(*) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3274": {
        "db_id": "donor",
        "question": "What are the vendors of the book-type projects? List them with the project ID.",
        "ground_truth": "SELECT DISTINCT vendorid, projectid FROM resources WHERE project_resource_type = 'Books'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor, project_id FROM projects WHERE type = 'book'"
        ],
        "rule_sql": []
    },
    "8051": {
        "db_id": "university",
        "question": "How many universities had above 30% of international students in 2013?",
        "ground_truth": "SELECT COUNT(*) FROM university_year WHERE pct_international_students > 30 AND year = 2013",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM universities WHERE international_students > 30 AND year = 2013;"
        ],
        "rule_sql": []
    },
    "856": {
        "db_id": "cs_semester",
        "question": "How many professors are more popular than Zhou Zhihua?",
        "ground_truth": "SELECT COUNT(prof_id) FROM prof WHERE popularity > ( SELECT popularity FROM prof WHERE first_name = 'Zhihua' AND last_name = 'Zhou' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE popularity > (SELECT popularity FROM professors WHERE name = 'Zhou Zhihua')"
        ],
        "rule_sql": []
    },
    "9074": {
        "db_id": "bike_share_1",
        "question": "List out all end stations for a bicycle that were making a trip starting from 2nd at South Park station? Only retain the unique value.",
        "ground_truth": "SELECT DISTINCT end_station_name FROM trip WHERE start_station_name = '2nd at South Park'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT start_station_name FROM trips WHERE end_station_name = '2nd at South Park';"
        ],
        "rule_sql": []
    },
    "9190": {
        "db_id": "movie_3",
        "question": "What is the rental price per day of the most expensive children's film?",
        "ground_truth": "SELECT T1.rental_rate FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Children' ORDER BY T1.rental_rate / T1.rental_duration DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rental_rate FROM film WHERE category = 'Children' ORDER BY rental_rate DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7211": {
        "db_id": "works_cycles",
        "question": "How many products with the id \"989\" were sold in August 2013?",
        "ground_truth": "SELECT SUM(Quantity) FROM TransactionHistory WHERE TransactionDate LIKE '2013-08%' AND TransactionType = 'S' AND ProductID = 989",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE product_id = '989' AND month = 'August' AND year = 2013;"
        ],
        "rule_sql": []
    },
    "5577": {
        "db_id": "menu",
        "question": "What is the average number of dishes per menu page of menu ID12882?",
        "ground_truth": "SELECT CAST(COUNT(dish_id) AS REAL) / COUNT(T3.page_count) FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id WHERE T2.menu_id = 12882",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(dish_count) FROM menu_pages WHERE menu_id = 12882;"
        ],
        "rule_sql": []
    },
    "9233": {
        "db_id": "movie_3",
        "question": "List the inventory ID of the film titled \"African Egg\".",
        "ground_truth": "SELECT T2.inventory_id FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE T1.title = 'African Egg'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inventory_id FROM inventory WHERE title = 'African Egg'"
        ],
        "rule_sql": []
    },
    "5522": {
        "db_id": "menu",
        "question": "Calculate the total dish count for menu with uuid of \"510d47e4-2958-a3d9-e040-e00a18064a99\" & \"510d47e4-295a-a3d9-e040-e00a18064a99\".",
        "ground_truth": "SELECT SUM(CASE WHEN T2.uuid = '510d47e4-2958-a3d9-e040-e00a18064a99' THEN T1.dish_count ELSE 0 END) - SUM(CASE WHEN T2.uuid = '510d47e4-295a-a3d9-e040-e00a18064a99' THEN T1.dish_count ELSE 0 END) FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menu WHERE uuid = '510d47e4-2958-a3d9-e040-e00a18064a99' OR uuid = '510d47e4-295a-a3d9-e040-e00a18064a99';"
        ],
        "rule_sql": []
    },
    "1110": {
        "db_id": "talkingdata",
        "question": "How many users belong to \"game-Art Style\" category?",
        "ground_truth": "SELECT COUNT(T1.app_id) FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id WHERE T2.category = 'game-Art Style'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE category = 'game-Art Style';"
        ],
        "rule_sql": []
    },
    "6773": {
        "db_id": "retails",
        "question": "What percentage of customers from the African region is in the household segment?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.r_name = 'AFRICA', 1, 0)) AS REAL) * 100 / COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN customer AS T3 ON T1.n_nationkey = T3.c_nationkey WHERE T3.c_mktsegment = 'HOUSEHOLD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.segment = 'household' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM customers c\nJOIN regions r ON c.region_id = r.region_id\nWHERE r.region_name = 'Africa';"
        ],
        "rule_sql": []
    },
    "8058": {
        "db_id": "university",
        "question": "Calculate the number of female students at Arizona State University in 2014.",
        "ground_truth": "SELECT CAST(T2.num_students * T2.pct_female_students AS REAL) / 100 FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id WHERE T1.university_name = 'Arizona State University' AND T2.year = 2014",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND university = 'Arizona State University' AND year = 2014;"
        ],
        "rule_sql": []
    },
    "1891": {
        "db_id": "soccer_2016",
        "question": "Calculate the average runs scored during the first half of all first innings.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN 1 < Over_Id AND Over_Id < 25 THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(Runs_Scored) FROM Batsman_Scored WHERE Innings_No = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(runs) FROM innings WHERE inning_number = 1 AND half = 'first' AND over_number <= 25"
        ],
        "rule_sql": []
    },
    "4201": {
        "db_id": "simpson_episodes",
        "question": "What is the name of the person that has the highest number of nominated award but didn't win?",
        "ground_truth": "SELECT person FROM Award WHERE result = 'Nominee' GROUP BY person ORDER BY COUNT(person) DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE nominated_awards = (SELECT MAX(nominated_awards) FROM people) AND won_awards = 0;"
        ],
        "rule_sql": []
    },
    "903": {
        "db_id": "cs_semester",
        "question": "What is the average number of students who registered for the courses with a difficulty of 4?",
        "ground_truth": "SELECT CAST(COUNT(T1.student_id) AS REAL) / COUNT(DISTINCT T2.course_id) FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.diff = 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(students_registered) FROM courses WHERE difficulty = 4;"
        ],
        "rule_sql": []
    },
    "3785": {
        "db_id": "public_review_platform",
        "question": "How many hours does the Yelp business No. \"5734\" open on Saturday?",
        "ground_truth": "SELECT T1.closing_time - T1.opening_time AS \"hour\" FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T2.day_of_week LIKE 'Saturday' AND T1.business_id = 5734",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(hours) FROM business_hours WHERE business_id = '5734' AND day = 'Saturday';"
        ],
        "rule_sql": []
    },
    "7557": {
        "db_id": "image_and_language",
        "question": "How many samples of animal objects are there in image no.660?",
        "ground_truth": "SELECT COUNT(T1.IMG_ID) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'animal' AND T1.IMG_ID = 660",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM samples WHERE image_id = 660 AND object_type = 'animal';"
        ],
        "rule_sql": []
    },
    "4149": {
        "db_id": "citeseer",
        "question": "List all paper ID and its class type with more than 20 cited words.",
        "ground_truth": "SELECT DISTINCT T1.paper_id, T1.class_label FROM paper AS T1 INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id GROUP BY T2.paper_id, T1.class_label HAVING COUNT(T2.word_cited_id) > 20",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paper_id, class_type FROM papers WHERE cited_words > 20"
        ],
        "rule_sql": []
    },
    "3719": {
        "db_id": "college_completion",
        "question": "Give the web site address for the school in \"PA\" state with the highest latitude.",
        "ground_truth": "SELECT DISTINCT T1.site FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE T2.state_abbr = 'PA' AND T1.lat_y = ( SELECT MAX(T1.lat_y) FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE T2.state_abbr = 'PA' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT website FROM schools WHERE state = 'PA' ORDER BY latitude DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5587": {
        "db_id": "shipping",
        "question": "What is the maximum weight being transported to New York during a single shipment?",
        "ground_truth": "SELECT MAX(T1.weight) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T2.city_name = 'New York'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM shipments WHERE destination = 'New York' GROUP BY shipment_id;"
        ],
        "rule_sql": []
    },
    "3392": {
        "db_id": "video_games",
        "question": "Provide the platform where the Panzer Tactics can be played.",
        "ground_truth": "SELECT T4.platform_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN game_platform AS T3 ON T2.id = T3.game_publisher_id INNER JOIN platform AS T4 ON T3.platform_id = T4.id WHERE T1.game_name = 'Panzer Tactics'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform FROM games WHERE title = 'Panzer Tactics';"
        ],
        "rule_sql": []
    },
    "298": {
        "db_id": "retail_complains",
        "question": "How many cases of billing dispute issues occurred in the Mountain division?",
        "ground_truth": "SELECT COUNT(T1.Issue) FROM events AS T1 INNER JOIN client AS T2 ON T1.Client_ID = T2.client_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.Issue = 'Billing disputes' AND T3.division = 'Mountain'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM issues WHERE division = 'Mountain' AND issue_type = 'billing dispute';"
        ],
        "rule_sql": []
    },
    "5175": {
        "db_id": "address",
        "question": "Provide the zip codes and the congress representatives' names of the postal points which are affiliated with Readers Digest.",
        "ground_truth": "SELECT T1.zip_code, T3.first_name, T3.last_name FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE T1.organization = 'Readers Digest'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, representative_name FROM postal_points WHERE affiliation = 'Readers Digest';"
        ],
        "rule_sql": []
    },
    "8324": {
        "db_id": "mondial_geo",
        "question": "In which province is city Glenrothes located? What is the capital of the province?",
        "ground_truth": "SELECT T2.Province, T1.Capital FROM province AS T1 INNER JOIN city AS T2 ON T1.Name = T2.Province AND T1.Country = T2.Country WHERE T2.Name = 'Glenrothes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT province.name, province.capital FROM city JOIN province ON city.province_id = province.id WHERE city.name = 'Glenrothes';"
        ],
        "rule_sql": []
    },
    "193": {
        "db_id": "book_publishing_company",
        "question": "List all the titles and year to date sales by author who are not on contract.",
        "ground_truth": "SELECT T1.title_id, T1.ytd_sales FROM titles AS T1 INNER JOIN titleauthor AS T2 ON T1.title_id = T2.title_id INNER JOIN authors AS T3 ON T2.au_id = T3.au_id WHERE T3.contract = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, ytd_sales FROM authors WHERE contract = 0"
        ],
        "rule_sql": []
    },
    "474": {
        "db_id": "movies_4",
        "question": "What is the gender of the character 'USAF Master Sgt. Epps?'",
        "ground_truth": "SELECT T2.gender FROM movie_cast AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.gender_id WHERE T1.character_name = 'USAF Master Sgt. Epps'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM characters WHERE name = 'USAF Master Sgt. Epps';"
        ],
        "rule_sql": []
    },
    "4209": {
        "db_id": "simpson_episodes",
        "question": "How many 10 star votes did the top 4 episodes with the highest rating received?",
        "ground_truth": "SELECT SUM(T1.votes) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 10 ORDER BY T1.rating DESC LIMIT 4;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id, COUNT(*) as vote_count \nFROM votes \nWHERE rating = 10 \nGROUP BY episode_id \nORDER BY vote_count DESC \nLIMIT 4;"
        ],
        "rule_sql": []
    },
    "7890": {
        "db_id": "world",
        "question": "What city has the highest population?",
        "ground_truth": "SELECT Name FROM City ORDER BY Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities ORDER BY population ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8432": {
        "db_id": "mondial_geo",
        "question": "What is the geographic location of Aarhus city? Please provide the answer with the coordinates of the location.",
        "ground_truth": "SELECT Longitude, Latitude FROM city WHERE Name = 'Aarhus'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name, latitude, longitude FROM cities WHERE city_name = 'Aarhus';"
        ],
        "rule_sql": []
    },
    "8603": {
        "db_id": "chicago_crime",
        "question": "What is the average number of crimes in a neighborhood in Central Chicago?",
        "ground_truth": "SELECT CAST(COUNT(T1.report_no) AS REAL) / COUNT(T2.community_area_no) FROM Crime AS T1 INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE T2.side = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(crime_count) FROM crimes WHERE neighborhood = 'Central Chicago';"
        ],
        "rule_sql": []
    },
    "6046": {
        "db_id": "books",
        "question": "List every book that Ursola Purdy has ordered.",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE T4.first_name = 'Ursola' AND T4.last_name = 'Purdy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT b.title FROM books b JOIN orders o ON b.book_id = o.book_id JOIN customers c ON o.customer_id = c.customer_id WHERE c.first_name = 'Ursola'"
        ],
        "rule_sql": []
    },
    "3855": {
        "db_id": "public_review_platform",
        "question": "Under which categories is Yelp_Business no. 1?",
        "ground_truth": "SELECT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE T2.business_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM Yelp_Business WHERE business_id = 1;"
        ],
        "rule_sql": []
    },
    "4494": {
        "db_id": "student_loan",
        "question": "Among the students who have been absent for four months, provide any five students' names and enlisted organizations.",
        "ground_truth": "SELECT T2.name, T2.organ FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T2.name = T1.name WHERE T1.month = 4 LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, organization FROM students WHERE absences = 4 LIMIT 5;"
        ],
        "rule_sql": []
    },
    "1871": {
        "db_id": "soccer_2016",
        "question": "Which team did CK Kapugedera belong to? How many matches did he play?",
        "ground_truth": "SELECT T3.Team_Name, COUNT(T2.Match_Id) FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T2.Player_Id = T1.Player_Id INNER JOIN Team AS T3 ON T3.Team_Id = T2.Team_Id WHERE T1.Player_Name = 'CK Kapugedera'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team, COUNT(*) as matches_played FROM players WHERE name = 'CK Kapugedera' GROUP BY team;"
        ],
        "rule_sql": []
    },
    "2850": {
        "db_id": "professional_basketball",
        "question": "How many players received Rookie of the Year award from 1969 to 2010?",
        "ground_truth": "SELECT COUNT(playerID) FROM awards_players WHERE year BETWEEN 1969 AND 2010 AND award = 'Rookie of the Year'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE award_name = 'Rookie of the Year' AND year BETWEEN 1969 AND 2010;"
        ],
        "rule_sql": []
    },
    "800": {
        "db_id": "social_media",
        "question": "How many reshared tweets are there in Texas?",
        "ground_truth": "SELECT COUNT(T1.TweetID) FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T2.State = 'Texas' AND T1.IsReshare = 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE state = 'Texas' AND is_reshare = 1;"
        ],
        "rule_sql": []
    },
    "5378": {
        "db_id": "sales",
        "question": "What is the last name of sales person for sales id 100?",
        "ground_truth": "SELECT T1.LastName FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID WHERE T2.SalesID = 100",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM sales_persons WHERE sales_id = 100;"
        ],
        "rule_sql": []
    },
    "7808": {
        "db_id": "hockey",
        "question": "How much is the total goals for player with player ID aaltoan01 and how old is this person?",
        "ground_truth": "SELECT SUM(T2.G), STRFTIME('%Y', CURRENT_TIMESTAMP) - T1.birthyear FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T1.playerID = 'aaltoan01' GROUP BY T1.birthyear",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(goals) as total_goals, age FROM players WHERE player_id = 'aaltoan01';"
        ],
        "rule_sql": []
    },
    "6250": {
        "db_id": "coinmarketcap",
        "question": "What is the total value of Argentum coined traded in the past 24 hours on 2016/10/11.",
        "ground_truth": "SELECT T2.volume_24h FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Argentum' AND T2.date = '2016-10-11'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount * price) AS total_value FROM trades WHERE coin_symbol = 'Argentum' AND timestamp >= '2016-10-10 00:00:00' AND timestamp <= '2016-10-11 00:00:00';"
        ],
        "rule_sql": []
    },
    "1230": {
        "db_id": "talkingdata",
        "question": "When did event number 7 happen for user number -8022267440849930000?",
        "ground_truth": "SELECT T1.timestamp FROM events_relevant AS T1 INNER JOIN app_events AS T2 ON T1.event_id = T2.event_id WHERE T2.app_id = -8022267440849930000 AND T1.event_id = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_time FROM events WHERE user_id = -8022267440849930000 AND event_id = 7;"
        ],
        "rule_sql": []
    },
    "905": {
        "db_id": "cs_semester",
        "question": "How many students taking a bachelor's degree received an A in all of the courses that they took?",
        "ground_truth": "SELECT COUNT(T2.student_id) FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE T2.grade = 'A' AND T1.type = 'UG'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students s\nJOIN grades g ON s.student_id = g.student_id\nWHERE s.degree = 'Bachelor' \nAND g.grade = 'A';"
        ],
        "rule_sql": []
    },
    "1120": {
        "db_id": "talkingdata",
        "question": "Give the number of device models for \"\u4e2d\u5174\" phone brand.",
        "ground_truth": "SELECT COUNT(device_id) FROM phone_brand_device_model2 WHERE device_model = '\u4e2d\u5174'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM phones WHERE brand = '\u4e2d\u5174';"
        ],
        "rule_sql": []
    },
    "7056": {
        "db_id": "works_cycles",
        "question": "Among the employees who have a pay rate of above 40, how many of them are male?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Gender = 'M' THEN 1 ELSE 0 END) FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Rate > 40",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE pay_rate > 40 AND gender = 'male';"
        ],
        "rule_sql": []
    },
    "9052": {
        "db_id": "bike_share_1",
        "question": "Which were the trips that started at Mountain View City Hall and ended on a rainy day?",
        "ground_truth": "SELECT T1.id FROM trip AS T1 INNER JOIN weather AS T2 WHERE T2.events = 'Rain' AND T1.start_station_name = 'Mountain View City Hall'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM trips WHERE start_station = 'Mountain View City Hall' AND weather = 'rainy';"
        ],
        "rule_sql": []
    },
    "3476": {
        "db_id": "video_games",
        "question": "List down the names of the games in the racing genre.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T2.genre_name = 'Racing'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE genre = 'Action';"
        ],
        "rule_sql": []
    },
    "5719": {
        "db_id": "language_corpus",
        "question": "List down the words with word id from 1 to 10 and write down a paired word for each of them.",
        "ground_truth": "SELECT T1.word AS W1, T3.word AS W2 FROM words AS T1 LEFT JOIN biwords AS T2 ON T1.wid = T2.w1st LEFT JOIN words AS T3 ON T3.wid = T2.w2nd WHERE T1.wid <= 10 GROUP BY T1.wid",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id, word FROM words WHERE word_id BETWEEN 1 AND 10"
        ],
        "rule_sql": []
    },
    "9049": {
        "db_id": "bike_share_1",
        "question": "Please calculate the average duration of trips started at South Van Ness at Market in 2015.",
        "ground_truth": "SELECT AVG(duration) FROM trip WHERE start_date LIKE '%2015%' AND start_station_name = 'South Van Ness at Market'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM trips WHERE start_station = 'South Van Ness at Market' AND year = 2015;"
        ],
        "rule_sql": []
    },
    "22": {
        "db_id": "movie_platform",
        "question": "What is the user ID of the user, who was a subscriber when he created the list, who created a list for 10 consecutive years? If there are multiple users, indicate each of their user IDs.",
        "ground_truth": "SELECT user_id FROM lists_users WHERE user_subscriber = 1 GROUP BY user_id HAVING MAX(SUBSTR(list_creation_date_utc, 1, 4)) - MIN(SUBSTR(list_creation_date_utc, 1, 4)) >= 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id \nFROM lists \nWHERE subscriber_status = 'subscriber' \nGROUP BY user_id \nHAVING COUNT(DISTINCT YEAR(created_date)) = 10;"
        ],
        "rule_sql": []
    },
    "8332": {
        "db_id": "mondial_geo",
        "question": "List all the mountains that are volcanic along with its longitude and latitude.",
        "ground_truth": "SELECT Name, Latitude, Longitude FROM mountain WHERE Type = 'volcano'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT mountain_name, longitude, latitude FROM mountains WHERE volcanic = 'yes';"
        ],
        "rule_sql": []
    },
    "3514": {
        "db_id": "authors",
        "question": "How many papers were published in 2011 in the journal whose short name is \"Mol Brain\"?",
        "ground_truth": "SELECT COUNT(T2.Id) FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T2.Year = 2011 AND T1.ShortName = 'Mol Brain'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE year = 2011 AND journal_short_name = 'Mol Brain';"
        ],
        "rule_sql": []
    },
    "494": {
        "db_id": "movies_4",
        "question": "State the genre of the movie title with a runtime of only 14 minutes.",
        "ground_truth": "SELECT T3.genre_name FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE T1.runtime = 14",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM movies WHERE runtime = 14;"
        ],
        "rule_sql": []
    },
    "6694": {
        "db_id": "retails",
        "question": "Give the number of Moroccan customers whose account is in debt.",
        "ground_truth": "SELECT COUNT(T1.c_name) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'MOROCCO' AND T1.c_acctbal < 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE country = 'Morocco' AND balance > 0;"
        ],
        "rule_sql": []
    },
    "7857": {
        "db_id": "world",
        "question": "What is the local name of Ukraine that they are also known for?",
        "ground_truth": "SELECT LocalName FROM Country WHERE Name = 'Ukraine'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT local_name FROM countries WHERE country_name = 'Ukraine';"
        ],
        "rule_sql": []
    },
    "2485": {
        "db_id": "shooting",
        "question": "What percentage of deaths were caused by rifles?",
        "ground_truth": "SELECT CAST(SUM(subject_statuses = 'Deceased') AS REAL) * 100 / COUNT(case_number) FROM incidents WHERE subject_weapon = 'Rifle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM deaths)) AS percentage\nFROM deaths\nWHERE weapon = 'rifle';"
        ],
        "rule_sql": []
    },
    "891": {
        "db_id": "cs_semester",
        "question": "How many students have the highest intelligence among those taking a bachelor's degree?",
        "ground_truth": "SELECT COUNT(student_id) FROM student WHERE type = 'UG' AND intelligence = ( SELECT MAX(intelligence) FROM student )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE degree = 'bachelor' AND intelligence = (SELECT MAX(intelligence) FROM students);"
        ],
        "rule_sql": []
    },
    "6910": {
        "db_id": "retails",
        "question": "Who is the clerk in charge of handling the item with the highest amount of extended price?",
        "ground_truth": "SELECT T1.o_clerk FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY T2.l_extendedprice DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT clerk FROM lineitem ORDER BY extendedprice DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8065": {
        "db_id": "university",
        "question": "Calculate the average score per university under Alumni criteria in 2008.",
        "ground_truth": "SELECT AVG(T2.score) FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id WHERE T1.criteria_name = 'Alumni' AND T2.year = 2008",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university, AVG(score) as average_score \nFROM alumni_scores \nWHERE criteria = 'Alumni' AND year = 2008 \nGROUP BY university;"
        ],
        "rule_sql": []
    },
    "3798": {
        "db_id": "public_review_platform",
        "question": "Indicate the opening hours of businesses are with category in fashion.",
        "ground_truth": "SELECT T4.opening_time FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Business_Hours AS T4 ON T3.business_id = T4.business_id WHERE T1.category_name LIKE 'Fashion'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, opening_hours FROM businesses WHERE category = 'fashion';"
        ],
        "rule_sql": []
    },
    "881": {
        "db_id": "cs_semester",
        "question": "How many courses does Alvera McQuillin take?",
        "ground_truth": "SELECT COUNT(T1.course_id) FROM registration AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T2.f_name = 'Alvera' AND T2.l_name = 'McQuillin'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE name = 'Alvera McQuillin';"
        ],
        "rule_sql": []
    },
    "4166": {
        "db_id": "simpson_episodes",
        "question": "How many keywords does the episode that was aired on 2008/10/19 have?",
        "ground_truth": "SELECT COUNT(T2.keyword) FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.air_date = '2008-10-19';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes e JOIN keywords k ON e.episode_id = k.episode_id WHERE e.air_date = '2008/10/19';"
        ],
        "rule_sql": []
    },
    "4789": {
        "db_id": "legislator",
        "question": "What is the ratio of males and females among historical legislators?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN gender_bio = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN gender_bio = 'F' THEN 1 ELSE 0 END) FROM historical",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS total_legislators,\n    SUM(CASE WHEN gender = 'Male' THEN 1 ELSE 0 END) AS male_count,\n    SUM(CASE WHEN gender = 'Female' THEN 1 ELSE 0 END) AS female_count,\n    (SUM(CASE WHEN gender = 'Male' THEN 1 ELSE 0 END) / COUNT(*)) AS male_ratio,\n    (SUM(CASE WHEN gender = 'Female' THEN 1 ELSE 0 END) / COUNT(*)) AS female_ratio\nFROM legislators\nWHERE gender IN ('Male', 'Female');"
        ],
        "rule_sql": []
    },
    "8433": {
        "db_id": "mondial_geo",
        "question": "What is the population gap between the United Kingdom and Italy?",
        "ground_truth": "SELECT MAX(Population) - MIN(Population) FROM country WHERE Name = 'United Kingdom' OR Name = 'Italy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ABS(UK.population - Italy.population) AS population_gap\nFROM countries UK, countries Italy\nWHERE UK.name = 'United Kingdom' AND Italy.name = 'Italy';"
        ],
        "rule_sql": []
    },
    "5817": {
        "db_id": "language_corpus",
        "question": "What is the title of the page on which the word \"grec\" has an occurrence of 52 times.",
        "ground_truth": "SELECT T3.title FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE T1.word = 'grec' AND T2.occurrences = 52",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM pages WHERE word = 'grec' AND occurrence = 52;"
        ],
        "rule_sql": []
    },
    "2026": {
        "db_id": "soccer_2016",
        "question": "What year was R Dravid born and the role he played?",
        "ground_truth": "SELECT T1.DOB, T3.Role_Desc FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id WHERE T1.Player_Name = 'R Dravid' GROUP BY T1.DOB, T3.Role_Desc",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_year, role FROM players WHERE name = 'R Dravid';"
        ],
        "rule_sql": []
    },
    "1440": {
        "db_id": "synthea",
        "question": "What kind of allergy is most common among white people?",
        "ground_truth": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T1.race = 'white' GROUP BY T2.DESCRIPTION ORDER BY COUNT(T2.DESCRIPTION) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT allergy_type, COUNT(*) as count FROM allergies WHERE race = 'white' GROUP BY allergy_type ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5271": {
        "db_id": "beer_factory",
        "question": "How many transactions were paid through MasterCard in 2014?",
        "ground_truth": "SELECT COUNT(TransactionID) FROM `transaction` WHERE CreditCardType = 'MasterCard' AND TransactionDate LIKE '2014%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE payment_method = 'MasterCard' AND year = 2014;"
        ],
        "rule_sql": []
    },
    "3945": {
        "db_id": "public_review_platform",
        "question": "List the city of the business where they open from 1 pm to 6 pm on Saturday.",
        "ground_truth": "SELECT T1.city FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T2.closing_time LIKE '6PM' AND T2.opening_time LIKE '1PM' AND T3.day_of_week LIKE 'Saturday'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM business WHERE saturday_open = '1:00 PM' AND saturday_close = '6:00 PM';"
        ],
        "rule_sql": []
    },
    "7458": {
        "db_id": "works_cycles",
        "question": "What is the organization level for Human Resources Manager?",
        "ground_truth": "SELECT OrganizationLevel FROM Employee WHERE JobTitle = 'Human Resources Manager'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_level FROM employees WHERE job_title = 'Human Resources Manager';"
        ],
        "rule_sql": []
    },
    "3051": {
        "db_id": "shakespeare",
        "question": "Among paragraphs with paragraph number between 1900 to 1950, list the texts said by a character described as a sea captain, friend to Sebatian.",
        "ground_truth": "SELECT T1.description FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T2.PlainText = 'a sea captain, friend to Sebastian' AND T2.ParagraphNum BETWEEN 1500 AND 1950",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM paragraphs WHERE paragraph_number BETWEEN 1900 AND 1950 AND character = 'sea captain' AND description = 'friend to Sebastian'"
        ],
        "rule_sql": []
    },
    "3153": {
        "db_id": "donor",
        "question": "For project titled 'Toot Your Flute!', what is the main subject of the project materials intended for? Name the other projects with the similar focus.",
        "ground_truth": "SELECT T2.primary_focus_subject FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.title = 'Toot Your Flute!'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT main_subject, project_title FROM projects WHERE project_title = 'Toot Your Flute!' AND main_subject = 'Music Education';"
        ],
        "rule_sql": []
    },
    "4313": {
        "db_id": "simpson_episodes",
        "question": "Write down the summary of episode whereby it has crew members that are not included in the credit list.",
        "ground_truth": "SELECT T1.summary FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.credited = 'false';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT summary FROM episodes WHERE crew_members NOT IN (SELECT name FROM credits);"
        ],
        "rule_sql": []
    },
    "7727": {
        "db_id": "hockey",
        "question": "How many wins does the team have whose goaltender have the most number of successfully stopping the other team from scoring during the entire game?",
        "ground_truth": "SELECT SUM(W) FROM Goalies GROUP BY tmID ORDER BY SUM(SHO) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT wins FROM teams WHERE team_id = (SELECT team_id FROM goaltenders ORDER BY saves DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "3592": {
        "db_id": "authors",
        "question": "What is the title of the paper that was written by Cheng Huang and affiliated with Microsoft?",
        "ground_truth": "SELECT T1.Title FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T2.Name = 'Cheng Huang' AND T2.Affiliation = 'Microsoft'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE author = 'Cheng Huang' AND affiliation = 'Microsoft';"
        ],
        "rule_sql": []
    },
    "8786": {
        "db_id": "food_inspection",
        "question": "How many high risk violations do the restaurants in San Francisco have in total?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.city IN ('San Francisco', 'SF', 'S.F.', 'SAN FRANCISCO') AND T1.risk_category = 'High Risk'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE city = 'San Francisco' AND risk_level = 'High';"
        ],
        "rule_sql": []
    },
    "4726": {
        "db_id": "disney",
        "question": "Name the director of Disney's lowest grossing movie.",
        "ground_truth": "SELECT T2.director FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director FROM movies WHERE studio = 'Disney' ORDER BY gross DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6730": {
        "db_id": "retails",
        "question": "Among the orders shipped in November, 1998 by air, how many orders were urgent?",
        "ground_truth": "SELECT COUNT(T1.o_orderkey) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T2.l_shipmode = 'AIR' AND T1.o_orderpriority = '1-URGENT' AND SUBSTR(T2.l_shipdate, 1, 7) = '1998-11'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE shipped_date LIKE '1998-11%' AND ship_via = 'Air' AND priority = 'Urgent';"
        ],
        "rule_sql": []
    },
    "3439": {
        "db_id": "video_games",
        "question": "Indicate, by region, which platform has sold the most games.",
        "ground_truth": "SELECT T.region_name FROM ( SELECT T1.platform_name, T4.region_name, SUM(T3.num_sales) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN region_sales AS T3 ON T1.id = T3.game_platform_id INNER JOIN region AS T4 ON T3.region_id = T4.id GROUP BY T1.platform_name, T4.region_name ORDER BY SUM(T3.num_sales) DESC LIMIT 1 ) t",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, platform, MAX(total_sales) as max_sales\nFROM game_sales\nGROUP BY region, platform\nORDER BY region, max_sales DESC;"
        ],
        "rule_sql": []
    },
    "7811": {
        "db_id": "hockey",
        "question": "What is the total number of game played for players from USA?",
        "ground_truth": "SELECT COUNT(T2.GP) FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCountry = 'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "667": {
        "db_id": "codebase_comments",
        "question": "What is the solution path for method number 3?",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Id = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM methods WHERE method_number = 3;"
        ],
        "rule_sql": []
    },
    "4219": {
        "db_id": "simpson_episodes",
        "question": "List down the award name, result, credit category and credited status of the \"Billy Kimball\".",
        "ground_truth": "SELECT DISTINCT T1.award, T1.result, T2.category, T2.credited FROM Award AS T1 INNER JOIN Credit AS T2 ON T2.episode_id = T1.episode_id WHERE T2.person = 'Billy Kimball';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT award_name, result, credit_category, credited_status FROM awards WHERE name = 'Billy Kimball'"
        ],
        "rule_sql": []
    },
    "569": {
        "db_id": "codebase_comments",
        "question": "How many followers do the most followed repository on Github have? Give the github address of the repository.",
        "ground_truth": "SELECT Forks, Url FROM Repo WHERE Forks = ( SELECT MAX(Forks) FROM Repo )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT followers, github_address FROM repositories ORDER BY followers DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4930": {
        "db_id": "olympics",
        "question": "Tell the number of swimming related events.",
        "ground_truth": "SELECT COUNT(T2.event_name) FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Swimming'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE event_name LIKE '%swimming%';"
        ],
        "rule_sql": []
    },
    "4799": {
        "db_id": "legislator",
        "question": "Among the legislators who have served in the U.S. House, provide the party and the state of the legislators who were born in 1738.",
        "ground_truth": "SELECT T1.party, T1.state FROM `historical-terms` AS T1 INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE T2.house_history_id IS NOT NULL AND T2.birthday_bio LIKE '%1738%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party, state FROM legislators WHERE birth_year = 1738 AND chamber = 'Senate';"
        ],
        "rule_sql": []
    },
    "7021": {
        "db_id": "works_cycles",
        "question": "Which product has the highest profit on net? State the product name.",
        "ground_truth": "SELECT T1.Name FROM Product AS T1 INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID ORDER BY T2.LastReceiptCost - T2.StandardPrice DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY profit DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3215": {
        "db_id": "donor",
        "question": "Please provide the type of resource that donation \"b39547f29dfc25fb13c6e9e8d940dc43\" contain.",
        "ground_truth": "SELECT DISTINCT T1.project_resource_type FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE T3.donationid LIKE 'b39547f29dfc25fb13c6e9e8d940dc43'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT resource_type FROM donations WHERE donation_id = 'b39547f29dfc25fb13c6e9e8d940dc43';"
        ],
        "rule_sql": []
    },
    "7860": {
        "db_id": "world",
        "question": "How many percent of the population of China used Chinese as their language?",
        "ground_truth": "SELECT T2.Percentage FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'China' AND T2.Language = 'Chinese'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM population WHERE country = 'China')) AS percentage\nFROM language_usage \nWHERE country = 'China' AND language = 'Chinese';"
        ],
        "rule_sql": []
    },
    "4705": {
        "db_id": "disney",
        "question": "Provide the name of the song from the movie directed by Ben Sharpsteen.",
        "ground_truth": "SELECT T1.song FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Ben Sharpsteen'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT song_name FROM songs WHERE director = 'Ben Sharpsteen';"
        ],
        "rule_sql": []
    },
    "3249": {
        "db_id": "donor",
        "question": "Name the vendors that sell the item Classroom Keepers Management Center.",
        "ground_truth": "SELECT DISTINCT vendor_name FROM resources WHERE item_name = 'Classroom Keepers Management Center'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name FROM vendors WHERE item_name = 'Classroom Keepers Management Center';"
        ],
        "rule_sql": []
    },
    "9333": {
        "db_id": "movie_3",
        "question": "Which movie title has the lowest movie rental in the horror category?",
        "ground_truth": "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.`name` = 'Horror' ORDER BY T1.rental_rate LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title \nFROM movies m \nJOIN categories c ON m.category_id = c.id \nWHERE c.name = 'horror' \nORDER BY m.rental_count ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8125": {
        "db_id": "university",
        "question": "List the countries of universities that scored 70 and below in 2016.",
        "ground_truth": "SELECT DISTINCT T3.country_name FROM university AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.score < 70 AND T2.year = 2016",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM universities WHERE score > 70 AND year = 2016;"
        ],
        "rule_sql": []
    },
    "5256": {
        "db_id": "beer_factory",
        "question": "Which city does the customer who finished transaction no.103545 live in?",
        "ground_truth": "SELECT T1.City FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.TransactionID = 103545",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM customers WHERE transaction_id = 103545;"
        ],
        "rule_sql": []
    },
    "3196": {
        "db_id": "donor",
        "question": "How many projects have their resources provided by the vendor Lakeshore Learning Materials and are created by a teacher with a doctor degree?",
        "ground_truth": "SELECT COUNT(T1.projectid) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.vendor_name = 'Lakeshore Learning Materials' AND T2.teacher_prefix = 'Dr.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM projects p\nJOIN teachers t ON p.teacher_id = t.teacher_id\nJOIN resources r ON p.project_id = r.project_id\nJOIN vendors v ON r.vendor_id = v.vendor_id\nWHERE v.vendor_name = 'Lakeshore Learning Materials'\nAND t.degree = 'doctor'"
        ],
        "rule_sql": []
    },
    "3581": {
        "db_id": "authors",
        "question": "What is the name of the authors of papers in which conferences have been published whose full name includes the word Workshop?",
        "ground_truth": "SELECT T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE T3.FullName LIKE '%Workshop%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.name \nFROM authors a\nJOIN paper_author pa ON a.author_id = pa.author_id\nJOIN papers p ON pa.paper_id = p.paper_id\nJOIN conferences c ON p.conference_id = c.conference_id\nWHERE c.full_name LIKE '%Workshop%';"
        ],
        "rule_sql": []
    },
    "700": {
        "db_id": "trains",
        "question": "Please list the directions in which the trains with at least one empty-loaded car run.",
        "ground_truth": "SELECT T2.direction FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.load_num = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT direction FROM trains WHERE car_status = 'empty'"
        ],
        "rule_sql": []
    },
    "4632": {
        "db_id": "disney",
        "question": "Please list the movies directed by Wolfgang Reitherman that can be watched by the general audience.",
        "ground_truth": "SELECT T1.movie_title FROM `movies_total_gross` AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T1.MPAA_rating = 'G' AND T2.director = 'Wolfgang Reitherman'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE director = 'Wolfgang Reitherman' AND rating = 'G';"
        ],
        "rule_sql": []
    },
    "2841": {
        "db_id": "professional_basketball",
        "question": "From 1962 to 1975, how many coaches received the award?",
        "ground_truth": "SELECT COUNT(DISTINCT coachID) FROM awards_coaches WHERE year BETWEEN 1962 AND 1975",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM coaches WHERE award_year BETWEEN 1962 AND 1975;"
        ],
        "rule_sql": []
    },
    "8726": {
        "db_id": "chicago_crime",
        "question": "What is the weekly average number of fraud incidents that were reported in January 2018? Provide the description of the location where the majority of fraud incidents occurred in the said month.",
        "ground_truth": "SELECT CAST(COUNT(T1.fbi_code_no) AS REAL) / 4 FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    AVG(COUNT(*)) OVER (PARTITION BY WEEK(report_date)) as weekly_avg,\n    location_description\nFROM fraud_incidents\nWHERE report_date BETWEEN '2018-01-01' AND '2018-01-31'\nGROUP BY location_description\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5103": {
        "db_id": "address",
        "question": "What are the names of the states whose postal point is not affiliated with any organization?",
        "ground_truth": "SELECT DISTINCT T2.name FROM zip_data AS T1 INNER JOIN state AS T2 ON T1.state = T2.abbreviation WHERE T1.division IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM states WHERE postal_point IS NULL AND organization_id IS NULL;"
        ],
        "rule_sql": []
    },
    "2106": {
        "db_id": "world_development_indicators",
        "question": "List the East Asia & Pacific countries which are under the High income: nonOECD group. Please include their alpha code.",
        "ground_truth": "SELECT CountryCode, Alpha2Code FROM Country WHERE Region = 'East Asia & Pacific' AND IncomeGroup = 'High income: nonOECD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, alpha_code FROM countries WHERE region = 'East Asia & Pacific' AND income_group = 'High income: nonOECD';"
        ],
        "rule_sql": []
    },
    "2287": {
        "db_id": "movielens",
        "question": "Please list the country of the movie that stars an actress who acts the worse.",
        "ground_truth": "SELECT T3.country FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T1.a_gender = 'F' AND T1.a_quality = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM movies WHERE actress = (SELECT actress FROM movies ORDER BY rating ASC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "2782": {
        "db_id": "european_football_1",
        "question": "For all the games ended up with 1-1, what percentage of them are from Liga NOS division?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.name = 'Liga NOS' THEN T1.Div ELSE NULL END) AS REAL) * 100 / COUNT(T1.Div) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.FTHG = 1 AND FTAG = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN division = 'Liga NOS' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM games\nWHERE home_score = 1 AND away_score = 1;"
        ],
        "rule_sql": []
    },
    "6853": {
        "db_id": "retails",
        "question": "How many countries belong to the Algeria region?",
        "ground_truth": "SELECT COUNT(T1.r_name) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey WHERE T2.n_name = 'ALGERIA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE region = 'Algeria';"
        ],
        "rule_sql": []
    },
    "9239": {
        "db_id": "movie_3",
        "question": "List the titles of the films starred by Elvis Marx.",
        "ground_truth": "SELECT T3.title FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.length BETWEEN 110 AND 150 AND T1.first_name = 'Russell' AND T1.last_name = 'Close'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE actor = 'Elvis Marx';"
        ],
        "rule_sql": []
    },
    "1973": {
        "db_id": "soccer_2016",
        "question": "Among the players from South Africa, provide the players' names who were born in 1984.",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id WHERE T2.Country_Name = 'South Africa' AND T1.DOB LIKE '1984%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE country = 'South Africa' AND birth_year = 1984;"
        ],
        "rule_sql": []
    },
    "2241": {
        "db_id": "world_development_indicators",
        "question": "For the country that has notes on the indicator Inflation, consumer prices, in which region is it in?",
        "ground_truth": "SELECT T1.Region FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE T3.IndicatorName = 'Inflation, consumer prices (annual %)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM countries WHERE notes = 'Inflation, consumer prices';"
        ],
        "rule_sql": []
    },
    "6801": {
        "db_id": "retails",
        "question": "How many of the line items that have a quantity greater than 40 have been shipped by air?",
        "ground_truth": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_quantity > 40 AND l_shipmode = 'AIR'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM line_items WHERE quantity > 40 AND shipping_method = 'air';"
        ],
        "rule_sql": []
    },
    "2826": {
        "db_id": "professional_basketball",
        "question": "Among the players who went to high school in Chicago, how many of them belongs to the west conference?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.playerID) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T1.hsCity = 'Chicago' AND T2.conference = 'West'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players p\nJOIN teams t ON p.team_id = t.team_id\nWHERE p.high_school = 'Chicago'\nAND t.conference = 'West';"
        ],
        "rule_sql": []
    },
    "7469": {
        "db_id": "works_cycles",
        "question": "What is the price for the AWC Logo Cap?",
        "ground_truth": "SELECT T2.ListPrice FROM Product AS T1 INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'AWC Logo Cap'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM products WHERE name = 'AWC Logo Cap';"
        ],
        "rule_sql": []
    },
    "5808": {
        "db_id": "language_corpus",
        "question": "How many Wikipedia pages with over 4000 different words are there on the Catalan language?",
        "ground_truth": "SELECT COUNT(lid) FROM pages WHERE lid = 1 AND words > 4000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM wikipedia_pages WHERE language = 'Catalan' AND word_count > 4000;"
        ],
        "rule_sql": []
    },
    "8616": {
        "db_id": "chicago_crime",
        "question": "How many different neighborhoods are there in Roseland community?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.community_area_name = 'Roseland' THEN 1 ELSE 0 END) FROM Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM neighborhoods WHERE community = 'Roseland';"
        ],
        "rule_sql": []
    },
    "3261": {
        "db_id": "donor",
        "question": "Write the message of the donor of the project with the title of Lets Share Ideas who paid with a credit card.",
        "ground_truth": "SELECT T3.donation_message FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE T1.title = 'Lets Share Ideas' AND T3.payment_method = 'creditcard'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT message FROM donors WHERE project_title = 'Lets Share Ideas' AND payment_method = 'credit card';"
        ],
        "rule_sql": []
    },
    "3277": {
        "db_id": "donor",
        "question": "What is the percentage of payment methods of donations made in March 2013?",
        "ground_truth": "SELECT payment_method , CAST(COUNT(donationid) AS REAL) * 100 / 51090 FROM donations WHERE donation_timestamp LIKE '2013-03%' GROUP BY payment_method",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT payment_method, COUNT(*) * 100 / (SELECT COUNT(*) FROM donations WHERE strftime('%Y-%m', donation_date) = '2013-03') AS percentage FROM donations WHERE strftime('%Y-%m', donation_date) = '2013-03' GROUP BY payment_method;"
        ],
        "rule_sql": []
    },
    "6715": {
        "db_id": "retails",
        "question": "How many orders shipped via ship have a medium priority?",
        "ground_truth": "SELECT COUNT(T1.o_orderkey) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T2.l_shipmode = 'SHIP' AND T1.o_orderpriority = '3-MEDIUM'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE ship_via = 'ship' AND priority = 'medium';"
        ],
        "rule_sql": []
    },
    "8699": {
        "db_id": "chicago_crime",
        "question": "How many different types of crimes, according to the primary description, have occurred in the Hermosa neighborhood?",
        "ground_truth": "SELECT SUM(CASE WHEN T4.neighborhood_name = 'Hermosa' THEN 1 ELSE 0 END) FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN Community_Area AS T3 ON T3.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T4 ON T4.community_area_no = T3.community_area_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE neighborhood = 'Hermosa';"
        ],
        "rule_sql": []
    },
    "4237": {
        "db_id": "simpson_episodes",
        "question": "How many nominations have Billy Kimball received in 2010 for The simpson 20s: Season 20?",
        "ground_truth": "SELECT COUNT(award_id) FROM Award WHERE person = 'Billy Kimball' AND SUBSTR(year, 1, 4) = '2010' AND result = 'Nominee';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM nominations WHERE name = 'Billy Kimball' AND year = 2010 AND show_title = 'The simpson 20s: Season 20';"
        ],
        "rule_sql": []
    },
    "510": {
        "db_id": "movies_4",
        "question": "Tell the language of the movie \"C'era una volta il West\".",
        "ground_truth": "SELECT T3.language_name FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id WHERE T1.title LIKE 'C%era una volta il West'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE language = 'C'era una volta il West';"
        ],
        "rule_sql": []
    },
    "4831": {
        "db_id": "legislator",
        "question": "Who is the Pro-Administration senator that runs from March 4, 1789 to December 31, 1791?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.party = 'Pro-Administration' AND T2.start = '1789-03-04' AND T2.end = '1791-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM senators WHERE party = 'Pro-Administration' AND start_date = '1789-03-04' AND end_date = '1791-12-31';"
        ],
        "rule_sql": []
    },
    "4916": {
        "db_id": "olympics",
        "question": "How many Olympic competitors are from Finland?",
        "ground_truth": "SELECT COUNT(T1.person_id) FROM person_region AS T1 INNER JOIN noc_region AS T2 ON T1.region_id = T2.id WHERE T2.region_name = 'Finland'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM competitors WHERE country = 'Finland';"
        ],
        "rule_sql": []
    },
    "5979": {
        "db_id": "books",
        "question": "Who wrote \"The Prophet\"?",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T1.title = 'The Prophet'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM books WHERE title = 'The Prophet';"
        ],
        "rule_sql": []
    },
    "8807": {
        "db_id": "food_inspection",
        "question": "How many foodborne illness investigations were done in 2014?",
        "ground_truth": "SELECT COUNT(business_id) FROM inspections WHERE STRFTIME('%Y', `date`) = '2014' AND type = 'Foodborne Illness Investigation'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM investigations WHERE year = 2013;"
        ],
        "rule_sql": []
    },
    "879": {
        "db_id": "cs_semester",
        "question": "For the professors who advise more than 2 students, which professor has a higher teaching ability? Give the full name.",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T2.first_name, T2.last_name, T2.teachingability FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id GROUP BY T1.prof_id HAVING COUNT(student_id) > 2 ) T ORDER BY T.teachingability DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.first_name, p.last_name\nFROM professors p\nJOIN students s ON p.professor_id = s.advisor_id\nGROUP BY p.professor_id\nHAVING COUNT(s.student_id) > 2\nORDER BY p.teaching_ability DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6088": {
        "db_id": "books",
        "question": "What is the percentage of books that cost greater than $10 and were ordered by customer Ruthanne Vatini?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.price > 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM order_line AS T1 INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE T3.first_name = 'Ruthanne' AND T3.last_name = 'Vatini'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN b.price > 10 AND c.name = 'Ruthanne Vatini' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM books b\nJOIN orders o ON b.book_id = o.book_id\nJOIN customers c ON o.customer_id = c.customer_id;"
        ],
        "rule_sql": []
    },
    "2034": {
        "db_id": "soccer_2016",
        "question": "Calculate the percentage of left hand batting style players among all players.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Batting_hand = 'Left-hand bat' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Player_Id) FROM Player AS T1 INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN batting_hand = 'Left' THEN 1 END) * 100 / COUNT(*)) AS percentage_left_handed FROM players;"
        ],
        "rule_sql": []
    },
    "2461": {
        "db_id": "shooting",
        "question": "Among all the male officers, what is the percentage of them are White?",
        "ground_truth": "SELECT CAST(SUM(IIF(race = 'W', 1, 0)) AS REAL) * 100 / COUNT(case_number) FROM officers WHERE gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM officers WHERE gender = 'Male')) AS percentage FROM officers WHERE race = 'White';"
        ],
        "rule_sql": []
    },
    "9202": {
        "db_id": "movie_3",
        "question": "Among the films with the longest duration, list any five title with their descriptions and special features.",
        "ground_truth": "SELECT title, description, special_features FROM film WHERE length = ( SELECT MAX(length) FROM film ) LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, description, special_features FROM film ORDER BY length DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "3672": {
        "db_id": "authors",
        "question": "How many publications were published by author named 'Howard F. Lipson'?",
        "ground_truth": "SELECT COUNT(PaperId) FROM PaperAuthor WHERE Name = 'Howard F. Lipson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM publications WHERE author = 'Howard F. Lipson';"
        ],
        "rule_sql": []
    },
    "6873": {
        "db_id": "retails",
        "question": "Which supplier can provide the most number of \"hot spring dodger dim light\"? Please give the supplier's phone number.",
        "ground_truth": "SELECT T3.s_phone FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'hot spring dodger dim light' ORDER BY T2.ps_availqty DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.phone, COUNT(*) as count \nFROM suppliers s \nJOIN products p ON s.id = p.supplier_id \nWHERE p.name = 'hot spring dodger dim light' \nGROUP BY s.id \nORDER BY count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7385": {
        "db_id": "works_cycles",
        "question": "How much profit can the company gained from selling two high class black Road Bikes with a size of 58?",
        "ground_truth": "SELECT 2 * (T1.ListPrice - T1.StandardCost) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID WHERE T1.Class = 'H' AND T1.Color = 'Black' AND T1.Size = 58 AND T2.Name = 'Road Bikes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (price * 2) AS profit FROM products WHERE product_type = 'Road Bike' AND class = 'high' AND color = 'black' AND size = 58;"
        ],
        "rule_sql": []
    },
    "4272": {
        "db_id": "simpson_episodes",
        "question": "Please list any three episodes that have an excellent rating.",
        "ground_truth": "SELECT title FROM Episode WHERE rating BETWEEN 7 AND 10 LIMIT 3;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes WHERE rating = 'excellent' LIMIT 3;"
        ],
        "rule_sql": []
    },
    "9196": {
        "db_id": "movie_3",
        "question": "What is the full name of the customer who rented the highest number of movies of all time?",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T2.first_name, T2.last_name, COUNT(T1.rental_id) AS num FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id GROUP BY T2.first_name, T2.last_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers ORDER BY COUNT(rental_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5342": {
        "db_id": "beer_factory",
        "question": "What is the amount difference between the bottles of root beer sold from Louisiana and Missouri?",
        "ground_truth": "SELECT ( SELECT COUNT(T1.BrandID) FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T2.State = 'LA' AND T1.ContainerType = 'Bottle' ) - ( SELECT COUNT(T3.BrandID) FROM rootbeer AS T3 INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE T4.State = 'MO' AND T3.ContainerType = 'Bottle' ) AS DIFFERENCE",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ABS(SUM(CASE WHEN state = 'Louisiana' THEN bottles_sold ELSE 0 END) - SUM(CASE WHEN state = 'Missouri' THEN bottles_sold ELSE 0 END)) AS amount_difference FROM sales WHERE state IN ('Louisiana', 'Missouri');"
        ],
        "rule_sql": []
    },
    "5161": {
        "db_id": "address",
        "question": "Give at least five alias of cities with a postal point of post office.",
        "ground_truth": "SELECT T1.alias FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.type = 'Post Office' LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name AS alias, post_office AS postal_point FROM cities WHERE postal_point IS NOT NULL LIMIT 5;"
        ],
        "rule_sql": []
    },
    "3963": {
        "db_id": "public_review_platform",
        "question": "For the user who joined Yelp in \"2010\", with an average of \"4.5\" stars review and has got uber number of fans, how many \"funny\" compliments has he/she received from other users?",
        "ground_truth": "SELECT COUNT(T2.user_id) FROM Users AS T1 INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id INNER JOIN Compliments AS T3 ON T2.compliment_id = T3.compliment_id WHERE T1.user_yelping_since_year = 2010 AND T1.user_average_stars = 4.5 AND T1.user_fans = 'Uber' AND T3.compliment_type = 'funny'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users u\nJOIN reviews r ON u.user_id = r.user_id\nJOIN compliments c ON u.user_id = c.user_id\nWHERE u.yelping_since = '2010'\nAND r.stars = 4.5\nAND u.fans = (SELECT MAX(fans) FROM users)\nAND c.compliment_type = 'funny';"
        ],
        "rule_sql": []
    },
    "6699": {
        "db_id": "retails",
        "question": "Give the name of the customer who made an order with Clerk#000000803 on 1997/12/10.",
        "ground_truth": "SELECT T2.c_name FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T1.o_orderdate = '1997-12-10' AND T1.o_clerk = 'Clerk#000000803'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c_name FROM customer WHERE o_clerk = 'Clerk#000000803' AND o_orderdate = '1997/12/10';"
        ],
        "rule_sql": []
    },
    "2411": {
        "db_id": "superstore",
        "question": "What product category got the least sales in the west superstore?",
        "ground_truth": "SELECT T2.Category FROM west_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` ORDER BY T1.Sales LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, SUM(sales) as total_sales \nFROM superstore \nWHERE region = 'West' \nGROUP BY category \nORDER BY total_sales DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9267": {
        "db_id": "movie_3",
        "question": "How many rentals did Ella Oliver hire in June 2016?",
        "ground_truth": "SELECT COUNT(T1.rental_id) FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'ELLA' AND T2.last_name = 'ELLA' AND date(T1.rental_date) BETWEEN '2005-06-01' AND '2005-06-30'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM rentals r\nJOIN customers c ON r.customer_id = c.customer_id\nWHERE c.first_name = 'Ella' \nAND c.last_name = 'Oliver'\nAND r.rental_date LIKE '2016-06%';"
        ],
        "rule_sql": []
    },
    "6138": {
        "db_id": "food_inspection_2",
        "question": "State the inspection pass rate of Pockets Restaurant.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.results = 'Pass' THEN T2.inspection_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.inspection_id) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.dba_name = 'POCKETS' AND T1.facility_type = 'Restaurant'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS pass_rate FROM inspections WHERE restaurant_name = 'Pockets Restaurant' AND result = 'Pass';"
        ],
        "rule_sql": []
    },
    "4773": {
        "db_id": "legislator",
        "question": "Calculate the average number of current male legislators who chose Democrat from 2000 until 2021.",
        "ground_truth": "SELECT CAST(COUNT(T1.bioguide_id) AS REAL) / 22 FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND CAST(T2.start AS DATE) >= 2000 AND CAST(T2.END AS DATE) <= 2021 AND T2.party = 'Democrat'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(count) FROM legislators WHERE gender = 'male' AND party = 'Democrat' AND year BETWEEN 2000 AND 2021 AND current = 1;"
        ],
        "rule_sql": []
    },
    "1711": {
        "db_id": "restaurant",
        "question": "What kind of restaurants can be found at \"106 E 25th Ave\"?",
        "ground_truth": "SELECT T1.food_type FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_num = 106 AND T2.street_name = 'e 25th ave'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM restaurants WHERE address = '106 E 25th Ave';"
        ],
        "rule_sql": []
    },
    "3923": {
        "db_id": "public_review_platform",
        "question": "List the active business ID and its stars of the businesses fall under the category of Pets.",
        "ground_truth": "SELECT T1.business_id, T1.stars FROM Business AS T1 INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE T1.active LIKE 'TRUE' AND T3.category_name LIKE 'Pets'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id, stars FROM businesses WHERE category = 'Pets' AND active = 1;"
        ],
        "rule_sql": []
    },
    "5569": {
        "db_id": "menu",
        "question": "How many dishes are there on page 1 of menu ID12882?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.page_number = 1 THEN 1 ELSE 0 END) FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id WHERE T1.menu_id = 12882",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dishes WHERE menu_id = 12882 AND page_number = 1;"
        ],
        "rule_sql": []
    },
    "2260": {
        "db_id": "movielens",
        "question": "Among the worst actresses, how many of them got a rating of more than 3 to the movies they starred?",
        "ground_truth": "SELECT COUNT(T1.userid) FROM u2base AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid INNER JOIN users AS T4 ON T1.userid = T4.userid WHERE T3.a_quality = 0 AND T1.rating > 3 AND T4.u_gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM actresses a\nJOIN movies m ON a.movie_id = m.movie_id\nWHERE a.rating > 3\nAND a.worst_actress = 1;"
        ],
        "rule_sql": []
    },
    "4263": {
        "db_id": "simpson_episodes",
        "question": "How much more votes for episode 1 than for episode 5?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.episode = 1 THEN T2.votes ELSE 0 END) - SUM(CASE WHEN T1.episode = 5 THEN T2.votes ELSE 0 END) AS diff FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (votes_episode1 - votes_episode5) AS vote_difference FROM episodes WHERE episode_number = 1;"
        ],
        "rule_sql": []
    },
    "3834": {
        "db_id": "public_review_platform",
        "question": "How many businesses are there in Scottsdale city under the category of \"Beauty & Spas\"?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T3.city LIKE 'Scottsdale' AND T1.category_name LIKE 'Beauty & Spas'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Scottsdale' AND category = 'Beauty & Spas';"
        ],
        "rule_sql": []
    },
    "7817": {
        "db_id": "hockey",
        "question": "Which team has the highest winning rate in year 2000? State the team ID and list down the birth country of it's players.",
        "ground_truth": "SELECT DISTINCT T3.tmID, T1.birthCountry FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID INNER JOIN ( SELECT year, tmID FROM Teams WHERE year = 2000 ORDER BY W / (W + L) DESC LIMIT 1 ) AS T3 ON T2.tmID = T3.tmID AND T2.year = T3.year",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.team_id, p.birth_country\nFROM teams t\nJOIN players p ON t.team_id = p.team_id\nWHERE t.year = 2000\nORDER BY t.wins / (t.wins + t.losses) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2885": {
        "db_id": "professional_basketball",
        "question": "Which coach has the most 'won' than 'lost' in year '1988'?",
        "ground_truth": "SELECT coachID FROM coaches WHERE year = 1988 ORDER BY won - lost DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_name, (won - lost) AS win_difference \nFROM coaches \nWHERE year = 1988 \nORDER BY win_difference DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5849": {
        "db_id": "airline",
        "question": "Tell the number of flights that landed at Lake Charles Regional Airport on 2018/8/15.",
        "ground_truth": "SELECT COUNT(T1.Code) FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE T2.FL_DATE = '2018/8/15' AND T1.Description = 'Lake Charles, LA: Lake Charles Regional'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE destination = 'Lake Charles Regional Airport' AND date = '2018/8/15';"
        ],
        "rule_sql": []
    },
    "6781": {
        "db_id": "retails",
        "question": "List by order number the 3 items with the lowest price after applying the discount.",
        "ground_truth": "SELECT l_orderkey FROM lineitem ORDER BY l_extendedprice * (1 - l_discount) LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_number, item_name, price - discount AS final_price\nFROM items\nORDER BY final_price ASC\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "4287": {
        "db_id": "simpson_episodes",
        "question": "What are the episodes Oscar Cervantes is credited with?",
        "ground_truth": "SELECT episode_id FROM Credit WHERE person = 'Oscar Cervantes' AND credited = 'true';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes WHERE director = 'Oscar Cervantes';"
        ],
        "rule_sql": []
    },
    "5782": {
        "db_id": "language_corpus",
        "question": "What's the occurrence of the biwords pair whose first word is \"\u00e0bac\" and second word is \"xin\u00e8s\"?",
        "ground_truth": "SELECT occurrences FROM biwords WHERE w1st = ( SELECT wid FROM words WHERE word = '\u00e0bac' ) AND w2nd = ( SELECT wid FROM words WHERE word = 'xin\u00e8s' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM biwords WHERE first_word = '\u00e0bac' AND second_word = 'xin\u00e8s';"
        ],
        "rule_sql": []
    },
    "2756": {
        "db_id": "european_football_1",
        "question": "Which team won the match in the EC division on January 20, 2008 at home?",
        "ground_truth": "SELECT HomeTeam FROM matchs WHERE Div = 'EC' AND Date = '2008-01-20' AND FTR = 'H'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT home_team FROM matches WHERE division = 'EC' AND date = '2008-01-20' AND home_score > away_score"
        ],
        "rule_sql": []
    },
    "9013": {
        "db_id": "bike_share_1",
        "question": "Among the subscribers who rented a bike from South Van Ness at Market on 12/1/2013, whose duration was the shortest and to which station was the bike returned to? Indicate South Van Ness's dock count.",
        "ground_truth": "SELECT MIN(T2.duration), T2.end_station_name, COUNT(T2.start_station_name) FROM station AS T1 INNER JOIN trip AS T2 ON T2.start_station_name = T1.name WHERE T2.start_date LIKE '12/1/2013%' AND T2.start_station_name = 'South Van Ness at Market' AND T2.subscription_type = 'Subscriber'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name, s.dock_count, MIN(t.duration) as shortest_duration\nFROM trips t\nJOIN stations s ON t.start_station_id = s.id\nWHERE s.name = 'South Van Ness at Market'\nAND t.start_date = '12/1/2013'\nAND t.subscriber_type = 'Subscriber'\nGROUP BY s.name, s.dock_count\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6043": {
        "db_id": "books",
        "question": "What is the average number of pages in the books written by Jennifer Crusie?",
        "ground_truth": "SELECT AVG(T1.num_pages) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Jennifer Crusie'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(pages) FROM books WHERE author = 'Jennifer Crusie';"
        ],
        "rule_sql": []
    },
    "8921": {
        "db_id": "cookbook",
        "question": "What is the average vitamin C amount of all cakes?",
        "ground_truth": "SELECT AVG(T1.vitamin_c) FROM Nutrition AS T1 INNER JOIN Recipe AS T2 ON T2.recipe_id = T1.recipe_id WHERE T2.title LIKE '%cake%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(vitamin_c) FROM cakes;"
        ],
        "rule_sql": []
    },
    "4383": {
        "db_id": "student_loan",
        "question": "What is the percentage of male students in the navy department?",
        "ground_truth": "SELECT CAST(COUNT(T2.name) AS REAL) * 100 / COUNT(T1.name) FROM enlist AS T1 LEFT JOIN male AS T2 ON T1.`name` = T2.`name` WHERE T1.organ = 'navy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students)) AS percentage_male_navy\nFROM students \nWHERE department = 'navy' AND gender = 'male';"
        ],
        "rule_sql": []
    },
    "1767": {
        "db_id": "restaurant",
        "question": "How many American restaurants are located in Front, San Francisco?",
        "ground_truth": "SELECT COUNT(T2.food_type = 'american') FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.city = 'san francisco' AND T1.street_name = 'front'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE cuisine = 'American' AND city = 'Front' AND state = 'San Francisco';"
        ],
        "rule_sql": []
    },
    "1436": {
        "db_id": "synthea",
        "question": "List down the address of patients who have billable period in 2010.",
        "ground_truth": "SELECT DISTINCT T1.address FROM patients AS T1 INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE T2.BILLABLEPERIOD LIKE '2010%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM patients WHERE billable_period = 2010;"
        ],
        "rule_sql": []
    },
    "1721": {
        "db_id": "restaurant",
        "question": "How many restaurants have more than 4 star reviews?",
        "ground_truth": "SELECT COUNT(id_restaurant) AS cnt FROM generalinfo WHERE review > 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE stars > 4;"
        ],
        "rule_sql": []
    },
    "702": {
        "db_id": "trains",
        "question": "What is the total number of short cars on all the trains that run in the east direction?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.len = 'short' then 1 ELSE 0 END)as count FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T2.direction = 'east'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(short_cars) FROM trains WHERE direction = 'east';"
        ],
        "rule_sql": []
    },
    "4257": {
        "db_id": "simpson_episodes",
        "question": "Which episode id did award Outstanding Animated Program (For Programming Less Than One Hour) with an episode star score of 10?",
        "ground_truth": "SELECT DISTINCT T1.episode_id FROM Award AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.award = 'Outstanding Animated Program (For Programming Less Than One Hour)' AND T2.stars = 10;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id FROM episodes WHERE award_name = 'Outstanding Animated Program (For Programming Less Than One Hour)' AND star_score = 10;"
        ],
        "rule_sql": []
    },
    "5614": {
        "db_id": "shipping",
        "question": "How much is the annual revenue of the customer with the most number of shipments?",
        "ground_truth": "SELECT T2.annual_revenue FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id GROUP BY T1.cust_id ORDER BY COUNT(T1.cust_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) AS annual_revenue \nFROM shipments \nWHERE customer_id = (SELECT customer_id FROM shipments GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1)"
        ],
        "rule_sql": []
    },
    "5811": {
        "db_id": "language_corpus",
        "question": "Please list the titles of the top 3 Wikipedia pages with the most different words on the Catalan language.",
        "ground_truth": "SELECT title FROM pages WHERE lid = 1 ORDER BY words DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM wikipedia_pages ORDER BY word_count DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "4850": {
        "db_id": "legislator",
        "question": "How many legislators are not senator?",
        "ground_truth": "SELECT COUNT(bioguide) FROM `current-terms` WHERE class IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE title != 'Senator';"
        ],
        "rule_sql": []
    },
    "2070": {
        "db_id": "music_tracker",
        "question": "Which artist released singles between 1980 to 1982?",
        "ground_truth": "SELECT artist FROM torrents WHERE groupYear BETWEEN 1980 AND 1982 AND releaseType LIKE 'single'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM artists WHERE release_year BETWEEN 1980 AND 1982;"
        ],
        "rule_sql": []
    },
    "6175": {
        "db_id": "food_inspection_2",
        "question": "How many inspections failed in 2014?",
        "ground_truth": "SELECT COUNT(inspection_id) FROM inspection WHERE strftime('%Y', inspection_date) = '2014' AND results = 'Fail'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE year = 2014 AND status = 'passed';"
        ],
        "rule_sql": []
    },
    "7244": {
        "db_id": "works_cycles",
        "question": "What is the description of the discount for the product with the id \"762\"?",
        "ground_truth": "SELECT T2.Description FROM SpecialOfferProduct AS T1 INNER JOIN SpecialOffer AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID WHERE T1.ProductID = 762",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT discount FROM products WHERE id = 762;"
        ],
        "rule_sql": []
    },
    "1395": {
        "db_id": "synthea",
        "question": "How many of the patients born in 1920s had pneumonia?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE DESCRIPTION = 'Pneumonia' AND strftime('%Y', T1.birthdate) LIKE '192%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE year_of_birth BETWEEN 1920 AND 1929 AND diagnosis = 'pneumonia';"
        ],
        "rule_sql": []
    },
    "1455": {
        "db_id": "synthea",
        "question": "How many patients with care plan for 'concussion with loss of consciousness' are married?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.marital = 'M' AND T2.REASONDESCRIPTION = 'Concussion with loss of consciousness'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients p JOIN care_plans cp ON p.patient_id = cp.patient_id WHERE cp.condition = 'concussion with loss of consciousness' AND p.marital_status = 'married';"
        ],
        "rule_sql": []
    },
    "1343": {
        "db_id": "law_episode",
        "question": "What is the average star with highest percentage for episodes that have received award?",
        "ground_truth": "SELECT T2.person_id FROM Vote AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id ORDER BY T1.percent DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(star) FROM episodes WHERE award_received = 'Yes' GROUP BY episode_id ORDER BY percentage DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4189": {
        "db_id": "simpson_episodes",
        "question": "Among the person nominated for the Comedy Series Award in 2009, how many of them were born in California?",
        "ground_truth": "SELECT COUNT(*) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.year = 2009 AND T2.award = 'Comedy Series' AND T1.birth_region = 'California';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM nominations n\nJOIN people p ON n.person_id = p.id\nWHERE n.category = 'Comedy Series Award' \nAND n.year = 2009\nAND p.birth_state = 'California';"
        ],
        "rule_sql": []
    },
    "2015": {
        "db_id": "soccer_2016",
        "question": "List the names of players who played as a keeper.",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id WHERE T3.Role_Desc = 'Keeper' GROUP BY T1.Player_Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE position = 'keeper';"
        ],
        "rule_sql": []
    },
    "5612": {
        "db_id": "shipping",
        "question": "What is the full name of the driver who delivered the most shipments to the least populated city?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM driver AS T1 INNER JOIN shipment AS T2 ON T1.driver_id = T2.driver_id INNER JOIN city AS T3 ON T3.city_id = T2.city_id GROUP BY T1.first_name, T1.last_name, T3.population HAVING T3.population = MAX(T3.population) ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.first_name, d.last_name \nFROM drivers d\nJOIN shipments s ON d.driver_id = s.driver_id\nJOIN cities c ON s.city_id = c.city_id\nWHERE c.population = (SELECT MIN(population) FROM cities)\nGROUP BY d.driver_id\nORDER BY COUNT(s.shipment_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9108": {
        "db_id": "movie_3",
        "question": "Among the films that are released in 2006, how many of them are rated Adults Only in the Motion Picture Association Film Rating?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE rating = 'NC-17' AND release_year = 2006",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM films \nWHERE release_year = 2006 \nAND rating = 'Adults Only';"
        ],
        "rule_sql": []
    },
    "517": {
        "db_id": "movies_4",
        "question": "What is the most common first name?",
        "ground_truth": "SELECT person_name FROM person GROUP BY person_name ORDER BY COUNT(person_name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, COUNT(*) as count FROM users GROUP BY first_name ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9136": {
        "db_id": "movie_3",
        "question": "Which film is rented for the most times by the customers? Please give its title.",
        "ground_truth": "SELECT T.title FROM ( SELECT T1.title, COUNT(T3.rental_id) AS num FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id GROUP BY T1.title ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title, COUNT(r.rental_id) as rental_count\nFROM film f\nJOIN inventory i ON f.film_id = i.film_id\nJOIN rental r ON i.inventory_id = r.inventory_id\nGROUP BY f.film_id\nORDER BY rental_count ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "183": {
        "db_id": "book_publishing_company",
        "question": "In which year has the most hired employees?",
        "ground_truth": "SELECT STRFTIME('%Y', hire_date) FROM employee GROUP BY STRFTIME('%Y', hire_date) ORDER BY COUNT(emp_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT YEAR(hire_date) AS hire_year, COUNT(*) AS employee_count\nFROM employees\nGROUP BY YEAR(hire_date)\nORDER BY employee_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3337": {
        "db_id": "video_games",
        "question": "Tell the genre of the game \"Resident Evil: Revelations\".",
        "ground_truth": "SELECT T2.genre_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T1.game_name = 'Resident Evil: Revelations'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE title = 'Resident Evil: Revelations';"
        ],
        "rule_sql": []
    },
    "1222": {
        "db_id": "talkingdata",
        "question": "Please list any three OPPO device models.",
        "ground_truth": "SELECT device_model FROM phone_brand_device_model2 WHERE phone_brand = 'OPPO' LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM devices WHERE brand = 'Samsung' LIMIT 3;"
        ],
        "rule_sql": []
    },
    "7790": {
        "db_id": "hockey",
        "question": "Among the players who had 10 empty net goals in their career, who is the tallest? Show his full name.",
        "ground_truth": "SELECT T2.firstName, T2.lastName FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.ENG = 10 ORDER BY T2.height DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name, height FROM players WHERE empty_net_goals = 10 ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5193": {
        "db_id": "address",
        "question": "How many cities does congressman Pierluisi Pedro represent?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.city) FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE T3.first_name = 'Pierluisi' AND T3.last_name = 'Pedro'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE congressman = 'Pierluisi Pedro';"
        ],
        "rule_sql": []
    },
    "4997": {
        "db_id": "olympics",
        "question": "How many 10-year old athletes participated in the Gymnastics Men's Parallel Bars, Teams event?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM competitor_event AS T1 INNER JOIN games_competitor AS T2 ON T1.competitor_id = T2.id INNER JOIN event AS T3 ON T1.event_id = T3.id WHERE T3.event_name LIKE 'Gymnastics Men%s Parallel Bars, Teams' AND T2.age = 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Athletes WHERE age = 10 AND event = 'Gymnastics Men\\'s Parallel Bars, Teams';"
        ],
        "rule_sql": []
    },
    "6192": {
        "db_id": "food_inspection_2",
        "question": "Tell the address of employee who did inspection ID 52238?",
        "ground_truth": "SELECT T1.address FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_id = 52238",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM employees WHERE inspection_id = 52238"
        ],
        "rule_sql": []
    },
    "6019": {
        "db_id": "books",
        "question": "List all the titles of the Spanish books published by Alfaguara.",
        "ground_truth": "SELECT T2.title FROM book_language AS T1 INNER JOIN book AS T2 ON T2.language_id = T1.language_id INNER JOIN publisher AS T3 ON T3.publisher_id = T2.publisher_id WHERE T1.language_name = 'Spanish' AND T3.publisher_name = 'Alfaguara' GROUP BY T2.title",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE language = 'Spanish' AND publisher = 'Alfaguara';"
        ],
        "rule_sql": []
    },
    "7875": {
        "db_id": "world",
        "question": "What is the language of the smallest population country?",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode ORDER BY T1.Population ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6721": {
        "db_id": "retails",
        "question": "How much is the profit for smoke turquoise purple blue salmon that was delivered in person on 5/7/1996?",
        "ground_truth": "SELECT T1.l_extendedprice * (1 - T1.l_discount) - T2.ps_supplycost * T1.l_quantity AS num FROM lineitem AS T1 INNER JOIN partsupp AS T2 ON T1.l_suppkey = T2.ps_suppkey INNER JOIN part AS T3 ON T2.ps_partkey = T3.p_partkey WHERE T1.l_receiptdate = '1996-05-07' AND T1.l_shipinstruct = 'DELIVER IN PERSON' AND T3.p_name = 'smoke turquoise purple blue salmon'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price * quantity) AS profit FROM sales WHERE product_name = 'smoke turquoise purple blue salmon' AND delivery_method = 'in person' AND delivery_date = '5/7/1996';"
        ],
        "rule_sql": []
    },
    "4503": {
        "db_id": "student_loan",
        "question": "How many disabled male students joined an organization?",
        "ground_truth": "SELECT COUNT(T1.name) FROM disabled AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name INNER JOIN enlist AS T3 ON T3.name = T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students s\nJOIN organizations o ON s.student_id = o.student_id\nWHERE s.gender = 'male' AND s.disabled = 1;"
        ],
        "rule_sql": []
    },
    "1814": {
        "db_id": "soccer_2016",
        "question": "Which country does Ranchi city belong to?",
        "ground_truth": "SELECT T2.Country_Name FROM City AS T1 INNER JOIN Country AS T2 ON T1.Country_Id = T2.Country_Id WHERE T1.City_Name = 'Ranchi'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cities WHERE city_name = 'Ranchi';"
        ],
        "rule_sql": []
    },
    "8710": {
        "db_id": "chicago_crime",
        "question": "What are the full names of the top 5 most crowded ward aldermen?",
        "ground_truth": "SELECT alderman_first_name, alderman_last_name FROM Ward ORDER BY Population DESC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM aldermen ORDER BY population DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "6676": {
        "db_id": "retails",
        "question": "Among all the orders made by a customer in the household segment, what is the highest total price?",
        "ground_truth": "SELECT MAX(T1.o_totalprice) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_mktsegment = 'HOUSEHOLD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(total_price) FROM orders WHERE customer_segment = 'household';"
        ],
        "rule_sql": []
    },
    "9109": {
        "db_id": "movie_3",
        "question": "How many films with the rental rate of $2.99 have the special feature of \"Deleted Scenes\"?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE rental_rate = 2.99 AND special_features = 'Deleted Scenes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film WHERE rental_rate = 2.99 AND special_features LIKE '%Deleted Scenes%';"
        ],
        "rule_sql": []
    },
    "4378": {
        "db_id": "student_loan",
        "question": "What is the longest time for a student from the navy department to be absent from school?",
        "ground_truth": "SELECT T1.month FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'navy' ORDER BY T1.`month` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(absence_duration) FROM students WHERE department = 'navy';"
        ],
        "rule_sql": []
    },
    "6157": {
        "db_id": "food_inspection_2",
        "question": "What is the average number of inspections done by the top 5 employees with the highest salary? List the names of the said employees.",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT T2.inspection_id) AS REAL) / 5, T1.first_name, T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T1.title = 'Sanitarian' ORDER BY T1.salary DESC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(inspection_count) as average_inspections, name\nFROM employees\nWHERE salary IN (\n    SELECT salary \n    FROM employees \n    ORDER BY salary DESC \n    LIMIT 5\n)\nGROUP BY name;"
        ],
        "rule_sql": []
    },
    "5557": {
        "db_id": "menu",
        "question": "What is the average number of dishes per menu in the Souper de Luxe menus? Identify what is the name of the dish that appeared the most in all of its menus.",
        "ground_truth": "SELECT COUNT(*), T1.dish_id FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T3.name = 'Souper de Luxe' GROUP BY T3.id ORDER BY COUNT(T1.dish_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(dish_count) as avg_dishes, \n       (SELECT dish_name FROM menu_dishes \n        WHERE menu_id IN (SELECT menu_id FROM menus WHERE restaurant_name = 'Souper de Luxe') \n        GROUP BY dish_name ORDER BY COUNT(*) DESC LIMIT 1) as most_common_dish\nFROM (\n    SELECT menu_id, COUNT(dish_id) as dish_count \n    FROM menu_dishes \n    WHERE menu_id IN (SELECT menu_id FROM menus WHERE restaurant_name = 'Souper de Luxe')\n    GROUP BY menu_id\n)"
        ],
        "rule_sql": []
    },
    "9420": {
        "db_id": "movie_3",
        "question": "What is the biggest amount of payment for a rental made by Mary Smith?",
        "ground_truth": "SELECT T1.amount FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'MARY' AND T2.last_name = 'SMITH' ORDER BY T1.amount DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(amount) FROM payment WHERE customer_id = (SELECT customer_id FROM customer WHERE first_name = 'Mary' AND last_name = 'Smith')"
        ],
        "rule_sql": []
    },
    "8054": {
        "db_id": "university",
        "question": "List the universities in Denmark.",
        "ground_truth": "SELECT T1.university_name FROM university AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE T2.country_name = 'Denmark'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM universities WHERE country = 'Denmark';"
        ],
        "rule_sql": []
    },
    "2327": {
        "db_id": "movielens",
        "question": "What's the ratio of gender in actors to actress in all the UK movies?",
        "ground_truth": "SELECT CAST(SUM(IIF(T3.a_gender = 'M', 1, 0)) AS REAL) / SUM(IIF(T3.a_gender = 'F', 1, 0)) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T1.country = 'UK'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM actors WHERE gender = 'male') / (SELECT COUNT(*) FROM actors WHERE gender = 'female') AS gender_ratio\nFROM movies\nWHERE country = 'UK';"
        ],
        "rule_sql": []
    },
    "3510": {
        "db_id": "authors",
        "question": "Please list the titles of the papers published in the journal \"Concepts in Magnetic Resonance Part A\" in 2008.",
        "ground_truth": "SELECT T2.Title FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.FullName = 'Concepts in Magnetic Resonance Part A' AND T2.Year = 2008",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE journal = 'Concepts in Magnetic Resonance Part A' AND year = 2007;"
        ],
        "rule_sql": []
    },
    "2888": {
        "db_id": "professional_basketball",
        "question": "List the first name, last name and team name of players who are drafted from 'Seattle' between year 1965 to 1970.",
        "ground_truth": "SELECT DISTINCT T1.firstName, T1.lastName, T3.name FROM players AS T1 INNER JOIN draft AS T2 ON T1.playerID = T2.playerID INNER JOIN teams AS T3 ON T2.tmID = T3.tmID WHERE T2.draftFrom = 'Seattle' AND T2.draftYear BETWEEN 1965 AND 1970",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, team_name \nFROM players \nWHERE drafted_city = 'Seattle' \nAND drafted_year BETWEEN 1965 AND 1970;"
        ],
        "rule_sql": []
    },
    "933": {
        "db_id": "cs_semester",
        "question": "In students with a grade of B, how many of them have an intellegence level of 3?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM registration AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T1.grade = 'B' AND T2.intelligence = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade = 'A' AND intelligence_level = 3;"
        ],
        "rule_sql": []
    },
    "2003": {
        "db_id": "soccer_2016",
        "question": "How many matches are there in April, 2008?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM Match WHERE Match_date LIKE '2008-04%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE month = 'April' AND year = 2008;"
        ],
        "rule_sql": []
    },
    "1748": {
        "db_id": "restaurant",
        "question": "Which country has the most restaurants with Italian food?",
        "ground_truth": "SELECT T2.county FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.food_type = 'Italian' GROUP BY T2.county ORDER BY COUNT(T1.id_restaurant) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as restaurant_count \nFROM restaurants \nWHERE cuisine = 'Italian' \nGROUP BY country \nORDER BY restaurant_count ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7824": {
        "db_id": "world",
        "question": "How many cities are there in England?",
        "ground_truth": "SELECT COUNT(ID) FROM City WHERE District = 'England'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country = 'England';"
        ],
        "rule_sql": []
    },
    "2229": {
        "db_id": "world_development_indicators",
        "question": "Which country has the smallest land area in square kilometers for 19 consecutive years starting from year 1961? Indicate how much is its land area in square kilometers in those years and the income group of the country.",
        "ground_truth": "SELECT T1.CountryName, SUM(T1.Value) area, T2.IncomeGroup FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IndicatorName = 'Land area (sq. km)' AND T1.Year >= 1961 AND T1.Year < 1980 GROUP BY T1.CountryCode ORDER BY SUM(T1.Value) ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    c.country_name,\n    MIN(f.land_area_sq_km) as smallest_land_area,\n    c.income_group\nFROM \n    facts f\nJOIN \n    countries c ON f.country_id = c.country_id\nWHERE \n    f.year BETWEEN 1961 AND 1979\nGROUP BY \n    c.country_name, c.income_group\nORDER BY \n    smallest_land_area ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5969": {
        "db_id": "books",
        "question": "List the email of customers that bought the book titled Switch on the Night.",
        "ground_truth": "SELECT T4.email FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE T1.title = 'Switch on the Night'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM customers WHERE book_title = 'Switch on the Night';"
        ],
        "rule_sql": []
    },
    "4445": {
        "db_id": "student_loan",
        "question": "Which students have absents the most?",
        "ground_truth": "SELECT name FROM longest_absense_from_school WHERE month = ( SELECT MAX(month) FROM longest_absense_from_school )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_name, COUNT(*) as absences FROM attendance WHERE status = 'present' GROUP BY student_name ORDER BY absences DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "7576": {
        "db_id": "image_and_language",
        "question": "Calculate the percentage of object samples that are related to street lights.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.OBJ_CLASS = 'street lights' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.OBJ_SAMPLE_ID) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM object_samples) AS percentage FROM object_samples WHERE object_type = 'street_light';"
        ],
        "rule_sql": []
    },
    "7165": {
        "db_id": "works_cycles",
        "question": "What's Kevin A Wright's email address?",
        "ground_truth": "SELECT T2.EmailAddress FROM Person AS T1 INNER JOIN EmailAddress AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'Kevin' AND T1.MiddleName = 'A' AND T1.LastName = 'Wright'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM users WHERE first_name = 'Kevin' AND last_name = 'Wright';"
        ],
        "rule_sql": []
    },
    "7505": {
        "db_id": "image_and_language",
        "question": "State the object class of sample no.10 of image no.2320341.",
        "ground_truth": "SELECT T1.OBJ_CLASS FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.IMG_ID = 2320341 AND T2.OBJ_SAMPLE_ID = 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class FROM samples WHERE sample_no = 10 AND image_no = 2320341;"
        ],
        "rule_sql": []
    },
    "7933": {
        "db_id": "music_platform_2",
        "question": "List all reviews created in May 2019. State the title of podcast and review rating.",
        "ground_truth": "SELECT DISTINCT T1.title, T2.rating FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.created_at LIKE '2019-05-%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT podcast_title, review_rating FROM reviews WHERE review_date LIKE '2019-05%';"
        ],
        "rule_sql": []
    },
    "4267": {
        "db_id": "simpson_episodes",
        "question": "Please list two people who are the nominees for the \"Outstanding Voice-Over Performance\" award for season 20.",
        "ground_truth": "SELECT person FROM Award WHERE result = 'Nominee' AND award = 'Outstanding Voice-Over Performance' AND episode_id LIKE 'S20%' LIMIT 2;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM nominees WHERE award = 'Outstanding Voice-Over Performance' AND season = 20 LIMIT 2;"
        ],
        "rule_sql": []
    },
    "5396": {
        "db_id": "sales",
        "question": "What is the total sales amount for Reflector?",
        "ground_truth": "SELECT SUM(T1.Price * T2.quantity) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Reflector'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM sales WHERE product_name = 'Reflector';"
        ],
        "rule_sql": []
    },
    "7193": {
        "db_id": "works_cycles",
        "question": "Which sales person achieved the highest sales YTD? What is the projected yearly sales quota in 2011 for this person?",
        "ground_truth": "SELECT T1.BusinessEntityID, SUM(T1.SalesQuota) FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2011' GROUP BY T1.BusinessEntityID ORDER BY SUM(T1.SalesYTD) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT TOP 1 Name, SalesYTD, SalesQuota \nFROM SalesPerson \nORDER BY SalesYTD DESC"
        ],
        "rule_sql": []
    },
    "197": {
        "db_id": "book_publishing_company",
        "question": "List all titles which have year to date sales higher than the average order by pubisher name.",
        "ground_truth": "SELECT T1.title FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE T1.ytd_sales > ( SELECT AVG(ytd_sales) FROM titles )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, ytd_sales FROM titles WHERE ytd_sales > (SELECT AVG(ytd_sales) FROM titles) ORDER BY pub_name;"
        ],
        "rule_sql": []
    },
    "8542": {
        "db_id": "software_company",
        "question": "What is the occupation of customers within number of inhabitants ranges of 30 to 40?",
        "ground_truth": "SELECT DISTINCT T1.OCCUPATION FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T2.INHABITANTS_K >= 30 AND T2.INHABITANTS_K <= 40",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT occupation, COUNT(*) as customer_count \nFROM customers \nWHERE inhabitants BETWEEN 30 AND 40 \nGROUP BY occupation \nORDER BY customer_count DESC;"
        ],
        "rule_sql": []
    },
    "1522": {
        "db_id": "synthea",
        "question": "Which conditions the patient has when receiving the IPV immunization?",
        "ground_truth": "SELECT DISTINCT T2.DESCRIPTION FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT INNER JOIN immunizations AS T3 ON T1.patient = T3.PATIENT WHERE T3.DESCRIPTION = 'IPV'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT condition FROM patients WHERE immunization = 'IPV';"
        ],
        "rule_sql": []
    },
    "1249": {
        "db_id": "law_episode",
        "question": "How many 10-star votes were given to the episode titled \"Cherished\"?",
        "ground_truth": "SELECT T2.votes FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Cherished' AND T2.stars = 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE episode_title = 'Cherished' AND stars = 10;"
        ],
        "rule_sql": []
    },
    "876": {
        "db_id": "cs_semester",
        "question": "Which professor is Oliy Spratling working with? Give the full name.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM prof AS T1 INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE T3.f_name = 'Oliy' AND T3.l_name = 'Spratling'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professor_name FROM professors WHERE student_name = 'Oliy Spratling';"
        ],
        "rule_sql": []
    },
    "4724": {
        "db_id": "disney",
        "question": "Determine Disney's total box office gross between 2010 and 2016.",
        "ground_truth": "SELECT SUM(Total) FROM revenue WHERE `Year` BETWEEN 2010 AND 2016",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(box_office_gross) FROM movies WHERE studio = 'Disney' AND year BETWEEN 2010 AND 2016"
        ],
        "rule_sql": []
    },
    "4960": {
        "db_id": "olympics",
        "question": "Where is competitor Estelle Nze Minko from?",
        "ground_truth": "SELECT T1.region_name FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.full_name = 'Estelle Nze Minko'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM competitors WHERE name = 'Estelle Nze Minko';"
        ],
        "rule_sql": []
    },
    "7431": {
        "db_id": "works_cycles",
        "question": "For all the employees that have left the Engineering Department, what is the average time of their stay?",
        "ground_truth": "SELECT CAST(SUM(365 * (STRFTIME('%Y', T1.EndDate) - STRFTIME('%Y', T1.StartDate)) + 30 * (STRFTIME('%m', T1.EndDate) - STRFTIME('%m', T1.StartDate)) + STRFTIME('%d', T1.EndDate) - STRFTIME('%d', T1.StartDate)) AS REAL) / COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID WHERE T2.Name = 'Engineering' AND T1.EndDate IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(DATEDIFF(day, hire_date, termination_date)) AS avg_stay_time\nFROM employees\nWHERE department = 'Engineering' AND termination_date IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "5351": {
        "db_id": "beer_factory",
        "question": "Which type of card did Dick Ruthven use to pay for all of his transactions?",
        "ground_truth": "SELECT DISTINCT T2.CreditCardType FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.First = 'Dick' AND T1.Last = 'Ruthven'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT card_type FROM transactions WHERE customer_name = 'Dick Ruthven' GROUP BY card_type HAVING COUNT(*) = (SELECT COUNT(*) FROM transactions WHERE customer_name = 'Dick Ruthven')"
        ],
        "rule_sql": []
    },
    "2201": {
        "db_id": "world_development_indicators",
        "question": "What are the subjects of series that have a restricted type of license?",
        "ground_truth": "SELECT DISTINCT Topic FROM Series WHERE LicenseType = 'Restricted'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT subject FROM series WHERE license_type = 'restricted'"
        ],
        "rule_sql": []
    },
    "8189": {
        "db_id": "sales_in_weather",
        "question": "In weather station 17, which store sold the highest quantity of item 45 in October 2012?",
        "ground_truth": "SELECT T1.store_nbr FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE T1.item_nbr = 45 AND T2.station_nbr = 17 AND T1.`date` LIKE '%2012-10%' GROUP BY T1.store_nbr ORDER BY SUM(T1.units) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id, SUM(quantity) as total_quantity\nFROM sales\nWHERE weather_station = 17\nAND item_id = 45\nAND strftime('%Y-%m', sale_date) = '2012-10'\nGROUP BY store_id\nORDER BY total_quantity DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7988": {
        "db_id": "university",
        "question": "What is the ranking system ID of the award criteria?",
        "ground_truth": "SELECT ranking_system_id FROM ranking_criteria WHERE criteria_name = 'Award'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_system_id FROM award_criteria WHERE criteria_id = 1"
        ],
        "rule_sql": []
    },
    "6245": {
        "db_id": "food_inspection_2",
        "question": "What is the establishment's name with an inspection category of No Smoking Regulations?",
        "ground_truth": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id INNER JOIN inspection_point AS T4 ON T3.point_id = T4.point_id WHERE T4.category = 'No Smoking Regulations'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT establishment_name FROM inspections WHERE inspection_category = 'Smoking Regulations';"
        ],
        "rule_sql": []
    },
    "8067": {
        "db_id": "university",
        "question": "How many students were there in university ID 1 in 2011?",
        "ground_truth": "SELECT num_students FROM university_year WHERE year = 2011 AND university_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university_id = 1 AND year = 2011;"
        ],
        "rule_sql": []
    },
    "4448": {
        "db_id": "student_loan",
        "question": "Sum up the number of students enlisted in foreign legion, peace corps and army.",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ IN ('army', 'peace_corps', 'foreign_legion')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE branch IN ('Foreign Legion', 'Peace Corps', 'Army');"
        ],
        "rule_sql": []
    },
    "9075": {
        "db_id": "bike_share_1",
        "question": "How many rainy days were recorded in Mountain View?",
        "ground_truth": "SELECT SUM(IIF(zip_code = 94041 AND events = 'Rain', 1, 0)) FROM weather",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM weather WHERE city = 'Mountain View' AND precipitation > 0"
        ],
        "rule_sql": []
    },
    "1916": {
        "db_id": "soccer_2016",
        "question": "What is the name of the player who has been chosen the most times for 'Man of the Series'?",
        "ground_truth": "SELECT T3.Player_Name FROM Season AS T1 INNER JOIN Match AS T2 ON T1.Man_of_the_Series = T2.Man_of_the_Match INNER JOIN Player AS T3 ON T2.Man_of_the_Match = T3.Player_Id GROUP BY T3.Player_Name ORDER BY COUNT(T1.Man_of_the_Series) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, COUNT(*) as times_chosen \nFROM man_of_series \nGROUP BY player_name \nORDER BY times_chosen DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1419": {
        "db_id": "synthea",
        "question": "Provide the number of encounters for Major D'Amore.",
        "ground_truth": "SELECT COUNT(T2.ID) FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Major' AND T1.last = 'D''Amore'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM encounters WHERE patient_name = 'Major D\\'Amore'"
        ],
        "rule_sql": []
    },
    "402": {
        "db_id": "retail_complains",
        "question": "List the products involved in the complaints received on March 2017 via TOVA server.",
        "ground_truth": "SELECT DISTINCT T2.Product FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T1.server = 'TOVA' AND T2.`Date received` LIKE '2017-03%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM complaints WHERE complaint_date LIKE '2017-03%' AND server = 'TOVA';"
        ],
        "rule_sql": []
    },
    "3503": {
        "db_id": "video_games",
        "question": "What is the genre of the game titled '999: Nine Hours, Nine Persons, Nine Doors' ?",
        "ground_truth": "SELECT T2.genre_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T1.game_name = '999: Nine Hours, Nine Persons, Nine Doors'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM games WHERE genre = '999: Nine Hours, Nine Persons, Nine Doors';"
        ],
        "rule_sql": []
    },
    "7617": {
        "db_id": "hockey",
        "question": "Name the goalies who played for more than two teams from Year 2000 to 2005.",
        "ground_truth": "SELECT T1.firstName, T1.lastName FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.year >= 2000 AND T2.year <= 2005 GROUP BY T2.playerID HAVING COUNT(DISTINCT T2.tmID) > 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.name \nFROM goalies g\nJOIN teams t ON g.team_id = t.team_id\nWHERE t.year BETWEEN 2000 AND 2005\nGROUP BY g.goalie_id\nHAVING COUNT(DISTINCT t.team_id) > 2;"
        ],
        "rule_sql": []
    },
    "4194": {
        "db_id": "simpson_episodes",
        "question": "Name all the person who involved in the making of simpson 20s episode that aired between October to November.",
        "ground_truth": "SELECT DISTINCT T2.person FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.air_date, 6, 2) BETWEEN '10' AND '11';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT person_name FROM people JOIN episodes ON people.episode_id = episodes.episode_id WHERE episodes.title LIKE '%simpson 20s%' AND episodes.air_date BETWEEN 'October' AND 'November';"
        ],
        "rule_sql": []
    },
    "882": {
        "db_id": "cs_semester",
        "question": "State the name of research postgraduate student among Professor Zhihua Zhou's research assistants.",
        "ground_truth": "SELECT T3.f_name, T3.l_name FROM prof AS T1 INNER JOIN RA AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T2.student_id = T3.student_id WHERE T1.first_name = 'Zhihua' AND T3.type = 'RPG' AND T1.last_name = 'Zhou'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE professor = 'Zhihua Zhou' AND student_type = 'research postgraduate';"
        ],
        "rule_sql": []
    },
    "7270": {
        "db_id": "works_cycles",
        "question": "What is the full name of the sales person who has the the highest commission percent received per sale?",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM SalesPerson AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY T1.CommissionPct DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name FROM sales_persons ORDER BY commission_percent DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8363": {
        "db_id": "mondial_geo",
        "question": "Which Arabic-speaking country has the smallest population?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Arabic' AND T2.Percentage = 100 ORDER BY T1.Population ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE language = 'Arabic' ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5628": {
        "db_id": "shipping",
        "question": "Among all shipments placed by Sunguard Window Tinting & Truck Accessories in 2017, identify the percentage of shipments whose weight exceeded 10,000 pounds.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.weight >= 10000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE T2.cust_name = 'Sunguard Window Tinting & Truck Accessories' AND STRFTIME('%Y', T1.ship_date) = '2017'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN weight > 10000 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM shipments\nWHERE customer_name = 'Sunguard Window Tinting & Truck Accessories'\nAND year = 2017;"
        ],
        "rule_sql": []
    },
    "7916": {
        "db_id": "world",
        "question": "Among the cities with a population between 140000 and 150000, list the country that has life expectancy greater than 80% life expectancy of all countries.",
        "ground_truth": "SELECT T2.Name FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.Population BETWEEN 140000 AND 150000 GROUP BY T2.Name, LifeExpectancy HAVING LifeExpectancy < ( SELECT AVG(LifeExpectancy) FROM Country ) * 0.8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cities WHERE population BETWEEN 140000 AND 150000 AND life_expectancy > (SELECT AVG(life_expectancy) * 0.8 FROM countries);"
        ],
        "rule_sql": []
    },
    "7649": {
        "db_id": "hockey",
        "question": "How many shoutouts are there in the regular season of 1977?",
        "ground_truth": "SELECT COUNT(year) FROM CombinedShutouts WHERE year = 1977 AND `R/P` = 'R'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shoutouts WHERE season = '1977' AND season_type = 'regular';"
        ],
        "rule_sql": []
    },
    "1314": {
        "db_id": "law_episode",
        "question": "What are the names of all the people who worked on episode 19 of season 9?",
        "ground_truth": "SELECT T3.name FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE T1.episode = 19 AND T1.season = 9",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people WHERE episode = 19 AND season = 9;"
        ],
        "rule_sql": []
    },
    "8740": {
        "db_id": "chicago_crime",
        "question": "What is the general description for case number JB106010?",
        "ground_truth": "SELECT T1.primary_description FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T2.case_number = 'JB106010'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM cases WHERE case_number = 'JB106010';"
        ],
        "rule_sql": []
    },
    "2990": {
        "db_id": "shakespeare",
        "question": "Who is the daughter of Capulet?",
        "ground_truth": "SELECT CharName FROM characters WHERE Description = 'Daughter to Capulet'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM characters WHERE gender = 'female' AND family = 'Capulet'"
        ],
        "rule_sql": []
    },
    "7994": {
        "db_id": "university",
        "question": "What is the name of the university that had the highest number of international students for 6 consecutive years?",
        "ground_truth": "SELECT T2.university_name FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id ORDER BY T1.pct_international_students DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_name \nFROM international_students \nWHERE year BETWEEN 2015 AND 2020 \nGROUP BY university_name \nHAVING COUNT(DISTINCT year) = 6 \nORDER BY SUM(international_students_count) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1045": {
        "db_id": "talkingdata",
        "question": "What is the name of the category which most users belong to?",
        "ground_truth": "SELECT T.category FROM ( SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category_name FROM categories ORDER BY COUNT(user_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7741": {
        "db_id": "hockey",
        "question": "How old was the goaltender who scored the fewest goals while on the ice when he retired from the NHL?",
        "ground_truth": "SELECT T2.lastNHL - T2.birthYear FROM GoaliesSC AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T2.lastNHL IS NOT NULL GROUP BY T2.lastNHL, T2.birthYear ORDER BY SUM(GA) LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM goaltenders WHERE goals_scored = (SELECT MIN(goals_scored) FROM goaltenders) AND retired = 1;"
        ],
        "rule_sql": []
    },
    "1388": {
        "db_id": "synthea",
        "question": "How many patients have diabetes that started in 1988?",
        "ground_truth": "SELECT COUNT(PATIENT) FROM conditions WHERE DESCRIPTION = 'Diabetes' AND strftime('%Y', START) = '1988'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE condition = 'diabetes' AND start_date LIKE '1988%';"
        ],
        "rule_sql": []
    },
    "383": {
        "db_id": "retail_complains",
        "question": "Which city in West North Central has the highest number of customers over the age of 60?",
        "ground_truth": "SELECT T2.city FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.division = 'West North Central' AND T1.age > 60 GROUP BY T2.city ORDER BY COUNT(T2.city) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as customer_count \nFROM customers \nWHERE region = 'West North Central' AND age > 60 \nGROUP BY city \nORDER BY customer_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7558": {
        "db_id": "image_and_language",
        "question": "Name number of samples of \"bed\" object are there in the image No.1098?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.OBJ_CLASS = 'bed' THEN 1 ELSE 0 END) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.IMG_ID = 1098",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM samples WHERE object = 'bed' AND image_id = 1098;"
        ],
        "rule_sql": []
    },
    "374": {
        "db_id": "retail_complains",
        "question": "What is the social number of the client who has the longest delay in his/her complaint? Calculate the days of delay and state the company's response to the consumer.",
        "ground_truth": "SELECT T1.social , 365 * (strftime('%Y', T2.`Date sent to company`) - strftime('%Y', T2.`Date received`)) + 30 * (strftime('%M', T2.`Date sent to company`) - strftime('%M', T2.`Date received`)) + (strftime('%d', T2.`Date sent to company`) - strftime('%d', T2.`Date received`)), T2.`Company response to consumer` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID ORDER BY 365 * (strftime('%Y', T2.`Date sent to company`) - strftime('%Y', T2.`Date received`)) + 30 * (strftime('%M', T2.`Date sent to company`) - strftime('%M', T2.`Date received`)) + (strftime('%d', T2.`Date sent to company`) - strftime('%d', T2.`Date received`)) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT social_number, MAX(delay_days) as max_delay, company_response \nFROM complaints \nWHERE delay_days = (SELECT MAX(delay_days) FROM complaints) \nGROUP BY social_number, company_response;"
        ],
        "rule_sql": []
    },
    "9120": {
        "db_id": "movie_3",
        "question": "Among the films starring PENELOPE GUINESS, how many of them are released in 2006?",
        "ground_truth": "SELECT COUNT(T2.film_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.release_year = 2006 AND T1.first_name = 'PENELOPE' AND T1.last_name = 'GUINESS'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film f JOIN film_actor fa ON f.film_id = fa.film_id JOIN actor a ON fa.actor_id = a.actor_id WHERE a.first_name = 'PENELOPE' AND a.last_name = 'GUINESS' AND f.release_year = 2006;"
        ],
        "rule_sql": []
    },
    "2277": {
        "db_id": "movielens",
        "question": "Among the action movies from the USA, how many of them are not in English?",
        "ground_truth": "SELECT COUNT(T1.movieid) FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'USA' AND T1.isEnglish = 'F' AND T2.genre = 'Action'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE country = 'USA' AND genre = 'Action' AND language != 'English';"
        ],
        "rule_sql": []
    },
    "7743": {
        "db_id": "hockey",
        "question": "How many games did the coach who received the first-ever Second Team All-Star award play before receiving such award?",
        "ground_truth": "SELECT SUM(T1.g) FROM Coaches AS T1 INNER JOIN ( SELECT coachID, year FROM AwardsCoaches WHERE award = 'Second Team All-Star' ORDER BY year LIMIT 1 ) AS T2 ON T1.coachID = T2.coachID AND T1.year < T2.year",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM games g\nJOIN coaches c ON g.coach_id = c.coach_id\nJOIN awards a ON c.coach_id = a.coach_id\nWHERE a.award_name = 'Second Team All-Star'\nORDER BY a.award_date ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "347": {
        "db_id": "retail_complains",
        "question": "Among the elderlies, state the last name of whose complaint is handled in server YIFAT?",
        "ground_truth": "SELECT T1.last FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.age > 65 AND T2.server = 'YIFAT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM patients WHERE age > 65 AND complaint_handler = 'YIFAT';"
        ],
        "rule_sql": []
    },
    "3330": {
        "db_id": "video_games",
        "question": "State the publisher name of the game \"ModNation Racers\".",
        "ground_truth": "SELECT T1.publisher_name FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T3.game_name = 'ModNation Racers'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM publishers WHERE publisher_name = 'ModNation Racers';"
        ],
        "rule_sql": []
    },
    "1361": {
        "db_id": "synthea",
        "question": "During all the observations of Elly Koss, what was the highest Systolic Blood Pressure observed?",
        "ground_truth": "SELECT T2.value, T2.units FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description = 'Systolic Blood Pressure' ORDER BY T2.VALUE DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(Diastolic) FROM observations WHERE observer = 'Elly Koss';"
        ],
        "rule_sql": []
    },
    "4550": {
        "db_id": "student_loan",
        "question": "How many male students are enrolled at OCC?",
        "ground_truth": "SELECT COUNT(T1.name) FROM enrolled AS T1 INNER JOIN male AS T2 ON T1.name = T2.name WHERE T1.school = 'occ'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'female' AND school = 'OCC';"
        ],
        "rule_sql": []
    },
    "2752": {
        "db_id": "european_football_1",
        "question": "What is the highest final-time score across all divisions in the 2021 season? Which team was the team that made up that score?",
        "ground_truth": "SELECT ( SELECT MAX(MAX(FTAG), MAX(FTHG)) FROM matchs WHERE season = 2021 ) AS T1, AwayTeam FROM matchs WHERE season = 2021 AND FTHG = T1 OR FTAG = T1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(final_time_score) as highest_score, team_name \nFROM games \nWHERE season = 2021 \nGROUP BY division \nORDER BY highest_score DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8800": {
        "db_id": "food_inspection",
        "question": "For the business which got the most number of violations, how many inspections did it have?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id GROUP BY T1.business_id ORDER BY COUNT(T1.business_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE business_id = (SELECT business_id FROM violations GROUP BY business_id ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "6109": {
        "db_id": "books",
        "question": "What are the language and title of the ordered books with price less than 20% of the average price of all ordered books?",
        "ground_truth": "SELECT DISTINCT T3.language_name, T2.title FROM order_line AS T1 INNER JOIN book AS T2 ON T1.book_id = T2.book_id INNER JOIN book_language AS T3 ON T3.language_id = T2.language_id WHERE T1.price * 100 < ( SELECT AVG(price) FROM order_line ) * 20",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, title FROM books WHERE price < (SELECT AVG(price) * 0.2 FROM books) AND ordered = 1;"
        ],
        "rule_sql": []
    },
    "5858": {
        "db_id": "airline",
        "question": "What is the origin airport id that recorded the longest delay due to a late aircraft?",
        "ground_truth": "SELECT ORIGIN_AIRPORT_ID FROM Airlines ORDER BY LATE_AIRCRAFT_DELAY DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin_airport_id FROM flights ORDER BY late_aircraft_delay DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4804": {
        "db_id": "legislator",
        "question": "Provide the start date, end date, and party of Pearl Peden Oldfield.",
        "ground_truth": "SELECT T2.start, T2.`end`, T2.party FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.first_name = 'Pearl' AND T1.middle_name = 'Peden' AND T1.last_name = 'Oldfield'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date, end_date, party FROM politicians WHERE name = 'Pearl Peden Oldfield';"
        ],
        "rule_sql": []
    },
    "4947": {
        "db_id": "olympics",
        "question": "Which cities hosted at least 3 Olympic games?",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id GROUP BY T2.id HAVING COUNT(T1.games_id) >= 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as game_count FROM olympic_games GROUP BY city HAVING game_count >= 3;"
        ],
        "rule_sql": []
    },
    "8550": {
        "db_id": "software_company",
        "question": "Find and list the id and geographic ID of the elderly customers with an education level below 3.",
        "ground_truth": "SELECT ID, GEOID FROM Customers WHERE EDUCATIONNUM < 3 AND age > 65",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, geographic_id FROM customers WHERE age > 65 AND education_level < 3;"
        ],
        "rule_sql": []
    },
    "3610": {
        "db_id": "authors",
        "question": "How many papers are published under the conference \"Mathematics of Program Construction\n\"?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T2.FullName = 'Mathematics of Program Construction'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE conference = 'Mathematics of Program Construction';"
        ],
        "rule_sql": []
    },
    "7533": {
        "db_id": "image_and_language",
        "question": "How many object elements are there on average in each image?",
        "ground_truth": "SELECT CAST(COUNT(OBJ_CLASS_ID) AS REAL) / COUNT(DISTINCT IMG_ID) FROM IMG_OBJ",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(object_count) FROM images;"
        ],
        "rule_sql": []
    },
    "9307": {
        "db_id": "movie_3",
        "question": "What is the largest number of films rented per customer?",
        "ground_truth": "SELECT COUNT(rental_id) FROM rental GROUP BY customer_id ORDER BY COUNT(rental_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, COUNT(rental_id) AS film_count FROM rental GROUP BY customer_id ORDER BY film_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6965": {
        "db_id": "ice_hockey_draft",
        "question": "What is the highest point highest point of Per Mars in the draft year?",
        "ground_truth": "SELECT T1.P FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.PlayerName = 'Per Mars' ORDER BY T1.P DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(elevation) FROM mountains WHERE name = 'Per Mars' AND draft_year = (SELECT MAX(draft_year) FROM mountains WHERE name = 'Per Mars');"
        ],
        "rule_sql": []
    },
    "3513": {
        "db_id": "authors",
        "question": "Among the papers published in the journal \"Molecular Brain\", how many of them were published in the year 2011?",
        "ground_truth": "SELECT COUNT(T2.Id) FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T2.Year = 2011 AND T1.FullName = 'Molecular Brain'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE journal = 'Molecular Brain' AND year = 2010;"
        ],
        "rule_sql": []
    },
    "500": {
        "db_id": "movies_4",
        "question": "For movies with the keyword of \"civil war\", calculate the average revenue generated by these movies.",
        "ground_truth": "SELECT AVG(T1.revenue) FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE T3.keyword_name = 'civil war'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(revenue) FROM movies WHERE keyword = 'civil war';"
        ],
        "rule_sql": []
    },
    "5765": {
        "db_id": "language_corpus",
        "question": "State the total pages of the words that has repeated times of 2593.",
        "ground_truth": "SELECT COUNT(T1.pages) FROM langs AS T1 INNER JOIN langs_words AS T2 ON T1.lid = T2.lid WHERE T2.occurrences = 2593",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(pages) FROM words WHERE repeated_times = 2593;"
        ],
        "rule_sql": []
    },
    "7641": {
        "db_id": "hockey",
        "question": "Who is the coach who had coached the the most seasons in MTL? State his given name, date of birth and all teams he had coaches before.",
        "ground_truth": "SELECT T2.nameGiven , T2.birthYear, T2.birthMon, T2.birthDay, T3.name FROM Goalies AS T1 INNER JOIN Master AS T2 ON T2.playerID = T1.playerID INNER JOIN Teams AS T3 ON T3.lgID = T1.lgID WHERE T3.tmID = 'MTL' GROUP BY T2.nameGiven, T2.birthYear, T2.birthMon, T2.birthDay, T3.name ORDER BY COUNT(T2.coachID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.given_name, c.date_of_birth, GROUP_CONCAT(DISTINCT t.team_name) as all_teams_coached\nFROM coaches c\nJOIN teams t ON c.coach_id = t.coach_id\nWHERE t.team_name = 'MTL'\nGROUP BY c.coach_id\nORDER BY COUNT(DISTINCT t.season) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3651": {
        "db_id": "authors",
        "question": "What are the different ways the name of the author, Randall Davis, is written on their papers?",
        "ground_truth": "SELECT DISTINCT T1.Name FROM PaperAuthor AS T1 INNER JOIN Author AS T2 ON T1.AuthorId = T2.Id WHERE T2.Name = 'Randall Davis' AND T1.Name != 'Randall Davis'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT author_name FROM papers WHERE author_name LIKE '%Randall Davis%';"
        ],
        "rule_sql": []
    },
    "1099": {
        "db_id": "talkingdata",
        "question": "Among all the devices with event no.2 happening, what is the percentage of the device being a vivo phone?",
        "ground_truth": "SELECT SUM(IIF(T2.phone_brand = 'vivo', 1, 0)) / COUNT(T1.device_id) AS per FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.event_id = T2.device_id WHERE T1.event_id = '2'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN device_brand = 'vivo' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM events\nWHERE event_no = 2;"
        ],
        "rule_sql": []
    },
    "4796": {
        "db_id": "legislator",
        "question": "List the full names, religions, and parties of legislators who have served in Maine.",
        "ground_truth": "SELECT T1.official_full_name, T2.relation, T2.party FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.state = 'ME' GROUP BY T1.official_full_name, T2.relation, T2.party",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, religion, party FROM legislators WHERE state = 'Maine';"
        ],
        "rule_sql": []
    },
    "1519": {
        "db_id": "synthea",
        "question": "Among the patients with viral sinusitis condition, which patient's gender is most affected? Provide the number for each respectively.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END), SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Viral sinusitis (disorder)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) as count FROM patients WHERE condition = 'viral sinusitis' GROUP BY gender ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4419": {
        "db_id": "student_loan",
        "question": "What is the average absence period of a student?",
        "ground_truth": "SELECT AVG(month) FROM longest_absense_from_school",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(absence_days) FROM students WHERE student_id = 1;"
        ],
        "rule_sql": []
    },
    "2089": {
        "db_id": "music_tracker",
        "question": "From 1979 to 1982, what was the percentage of united.states albums out of total albums were released?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.tag LIKE 'united.states' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.releaseType) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.groupYear BETWEEN 1979 AND 1982 AND T1.releaseType LIKE 'album'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN country = 'United States' AND year BETWEEN 1979 AND 1982 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM albums;"
        ],
        "rule_sql": []
    },
    "1441": {
        "db_id": "synthea",
        "question": "List down the first name of patients who received \"Influenza seasonal injectable preservative free\" immunization.",
        "ground_truth": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Influenza  seasonal  injectable  preservative free'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM patients WHERE immunization = 'Influenza seasonal injectable preservative free'"
        ],
        "rule_sql": []
    },
    "3889": {
        "db_id": "public_review_platform",
        "question": "Count the active businesses that has an attribute of caters with low review count.",
        "ground_truth": "SELECT COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE T3.attribute_name LIKE 'Caters' AND T1.review_count LIKE 'Low' AND T1.active LIKE 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE attribute = 'caters' AND review_count < 10 AND is_active = 1;"
        ],
        "rule_sql": []
    },
    "204": {
        "db_id": "book_publishing_company",
        "question": "Please list the stores that ordered the book \"Life Without Fear\".",
        "ground_truth": "SELECT T2.stor_name FROM sales AS T1 INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id INNER JOIN titles AS T3 ON T1.title_id = T3.title_id WHERE T3.title = 'Life Without Fear'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_name FROM stores WHERE book_title = 'Life Without Fear';"
        ],
        "rule_sql": []
    },
    "4398": {
        "db_id": "student_loan",
        "question": "Which students that are in the marines have been absent for 6 months?",
        "ground_truth": "SELECT T1.name FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'marines' AND T1.`month` = 6",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE branch = 'Marines' AND absences >= 6;"
        ],
        "rule_sql": []
    },
    "1958": {
        "db_id": "soccer_2016",
        "question": "How many matches did Rajasthan Royals play in Season 8?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.Season_Id = 8 THEN 1 ELSE 0 END) FROM `Match` AS T1 INNER JOIN Team AS T2 ON T1.Team_1 = T2.Team_Id OR T1.Team_2 = T2.Team_Id WHERE T2.Team_Name = 'Rajasthan Royals'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE team1 = 'Rajasthan Royals' OR team2 = 'Rajasthan Royals' AND season = 8;"
        ],
        "rule_sql": []
    },
    "1726": {
        "db_id": "restaurant",
        "question": "Provide a list of restaurants from Marin county.",
        "ground_truth": "SELECT T1.label FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T2.county = 'marin county'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM restaurants WHERE county = 'Marin';"
        ],
        "rule_sql": []
    },
    "3411": {
        "db_id": "video_games",
        "question": "What percentage of games are sports?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.genre_name = 'Sports' THEN T2.id ELSE NULL END) AS REAL) * 100 / COUNT(T2.id) FROM genre AS T1 INNER JOIN game AS T2 ON T1.id = T2.genre_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100) FROM games WHERE genre = 'sports';"
        ],
        "rule_sql": []
    },
    "1670": {
        "db_id": "restaurant",
        "question": "How many restaurants have not obtained a minimum of 3 in their reviews?",
        "ground_truth": "SELECT COUNT(id_restaurant) FROM generalinfo WHERE review < 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE review_score >= 3;"
        ],
        "rule_sql": []
    },
    "4745": {
        "db_id": "legislator",
        "question": "Please list the current official YouTube usernames of all the current female legislators.",
        "ground_truth": "SELECT T2.youtube FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id WHERE T1.gender_bio = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT username FROM legislators WHERE gender = 'female' AND platform = 'YouTube';"
        ],
        "rule_sql": []
    },
    "5896": {
        "db_id": "airline",
        "question": "Give the actual elapsed time of the flights with air carrier named Semo Aviation Inc.: SEM.",
        "ground_truth": "SELECT T2.ACTUAL_ELAPSED_TIME FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Semo Aviation Inc.: SEM'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actual_elapsed_time FROM flights WHERE carrier = 'Semo Aviation Inc.'"
        ],
        "rule_sql": []
    },
    "7170": {
        "db_id": "works_cycles",
        "question": "What is the PreferredVendorStatus for the company which has the rowguid of \"684F328D-C185-43B9-AF9A-37ACC680D2AF\"?",
        "ground_truth": "SELECT T1.PreferredVendorStatus FROM Vendor AS T1 INNER JOIN BusinessEntity AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.rowguid = '684F328D-C185-43B9-AF9A-37ACC680D2AF'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT PreferredVendorStatus FROM Companies WHERE rowguid = '684F328D-C185-43B9-AF9A-37ACC680D2AF';"
        ],
        "rule_sql": []
    },
    "297": {
        "db_id": "retail_complains",
        "question": "In what years were the clients who demanded more problems with Certificate of deposit born?",
        "ground_truth": "SELECT T1.year FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Sub-product` = '(CD) Certificate of deposit' GROUP BY T1.year ORDER BY COUNT(T1.year) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_year FROM clients WHERE problem_count > (SELECT AVG(problem_count) FROM clients WHERE account_type = 'Certificate of deposit') ORDER BY birth_year;"
        ],
        "rule_sql": []
    },
    "669": {
        "db_id": "codebase_comments",
        "question": "What is solution 1's processing time and how many methods have been using this solution?",
        "ground_truth": "SELECT T1.ProcessedTime, COUNT(T2.SolutionId) FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.SolutionId = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT processing_time, COUNT(*) as method_count FROM solutions WHERE solution_id = 1"
        ],
        "rule_sql": []
    },
    "4830": {
        "db_id": "legislator",
        "question": "What is the google entity ID of Benjamin Hawkins?",
        "ground_truth": "SELECT google_entity_id_id FROM historical WHERE first_name = 'Benjamin' AND last_name = 'Hawkins'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT entity_id FROM google_entities WHERE name = 'Benjamin Hawkins';"
        ],
        "rule_sql": []
    },
    "3088": {
        "db_id": "cars",
        "question": "State the origin country of the fastest car in the database.",
        "ground_truth": "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country ORDER BY T1.horsepower DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cars ORDER BY speed DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4105": {
        "db_id": "public_review_platform",
        "question": "How many reviews of businesses that are still open received an uber rating on the funny vote?",
        "ground_truth": "SELECT COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T2.review_votes_funny = 'Uber' AND T1.active = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM reviews r\nJOIN businesses b ON r.business_id = b.business_id\nWHERE b.is_open = 1 \nAND r.vote_type = 'funny' \nAND r.rating = 'uber'"
        ],
        "rule_sql": []
    },
    "1666": {
        "db_id": "car_retails",
        "question": "Which 5 products has the lowest amount of orders? List the product names.",
        "ground_truth": "SELECT t2.productName FROM orderdetails AS t1 INNER JOIN products AS t2 ON t1.productCode = t2.productCode GROUP BY t2.productName ORDER BY SUM(t1.quantityOrdered) ASC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY order_count ASC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "1830": {
        "db_id": "soccer_2016",
        "question": "Which season played the highest number of matches at M Chinnaswamy Stadium?",
        "ground_truth": "SELECT T1.Season_Id FROM `Match` AS T1 INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE T2.Venue_Name = 'M Chinnaswamy Stadium' GROUP BY T1.Season_Id ORDER BY COUNT(T1.Season_Id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT season, COUNT(*) as match_count \nFROM matches \nWHERE venue = 'M Chinnaswamy Stadium' \nGROUP BY season \nORDER BY match_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8474": {
        "db_id": "mondial_geo",
        "question": "List all countries with 'Category III' membership in 'IFAD' organization. Please also provide the capital of the country.",
        "ground_truth": "SELECT Name, Capital FROM country WHERE Code IN ( SELECT Country FROM isMember WHERE type = 'Category III' AND Organization = 'IFAD' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, c.capital FROM countries c JOIN memberships m ON c.id = m.country_id JOIN organizations o ON m.organization_id = o.id WHERE o.name = 'IFAD' AND m.category = 'Category III';"
        ],
        "rule_sql": []
    },
    "101": {
        "db_id": "movie_platform",
        "question": "How many users were not trialists when they rated the movie \"Patti Smith: Dream of Life\"?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Patti Smith: Dream of Life' AND T1.user_trialist = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users u JOIN ratings r ON u.user_id = r.user_id JOIN movies m ON r.movie_id = m.movie_id WHERE m.title = 'Patti Smith: Dream of Life' AND u.is_trialist = 1;"
        ],
        "rule_sql": []
    },
    "2532": {
        "db_id": "app_store",
        "question": "How many of the reviews for the app \"Brit + Co\" have a comment?",
        "ground_truth": "SELECT COUNT(App) FROM user_reviews WHERE App = 'Brit + Co' AND Translated_Review IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE app_name = 'Brit + Co' AND comment IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "2750": {
        "db_id": "european_football_1",
        "question": "From the Spanish LaLiga division in the 2017 season, which team won the most times as a local team and by what percentage?",
        "ground_truth": "SELECT T1.HomeTeam HWHT , CAST(COUNT(CASE WHEN T1.FTR = 'H' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(HomeTeam) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'LaLiga' AND T2.country = 'Spain' AND T1.season = 2017",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, (home_wins * 100.0 / total_games) AS win_percentage\nFROM teams\nWHERE season = 2017 AND division = 'LaLiga'\nORDER BY home_wins DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3952": {
        "db_id": "public_review_platform",
        "question": "State the ID number for the attribute named \"Accepts Insurance\"?",
        "ground_truth": "SELECT attribute_id FROM Attributes WHERE attribute_name = 'Accepts Insurance'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT attribute_id FROM attributes WHERE attribute_name = 'Accepts Insurance';"
        ],
        "rule_sql": []
    },
    "2404": {
        "db_id": "superstore",
        "question": "How many office supply orders were made by Cindy Stewart in the south superstore?",
        "ground_truth": "SELECT COUNT(*) FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T3.Category = 'Office Supplies' AND T2.`Customer Name` = 'Cindy Stewart'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Cindy Stewart' AND store_region = 'south' AND product_category = 'office supplies';"
        ],
        "rule_sql": []
    },
    "4670": {
        "db_id": "disney",
        "question": "List all of Wolfgang Reitherman's movies and their voice actors.",
        "ground_truth": "SELECT T1.name, T2.`voice-actor` FROM director AS T1 INNER JOIN `voice-actors` AS T2 ON T1.name = T2.movie WHERE T1.director = 'Wolfgang Reitherman'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, v.name \nFROM movies m \nJOIN voice_actors v ON m.director_id = v.actor_id \nWHERE m.director = 'Wolfgang Reitherman'"
        ],
        "rule_sql": []
    },
    "1463": {
        "db_id": "synthea",
        "question": "In 2009, who among the married patients had undergone a care plan for more than 60 days?",
        "ground_truth": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN careplans AS T2 ON T1.patient = T2.PATIENT WHERE T1.marital = 'M' AND strftime('%J', T2.STOP) - strftime('%J', T2.START) > 60",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM patients p\nJOIN care_plans cp ON p.patient_id = cp.patient_id\nWHERE p.marital_status = 'Married'\nAND cp.start_date >= '2009-01-01' \nAND cp.start_date <= '2009-12-31'\nAND DATEDIFF(cp.end_date, cp.start_date) > 60;"
        ],
        "rule_sql": []
    },
    "5366": {
        "db_id": "sales",
        "question": "List down the product id for products with the highest quantity.",
        "ground_truth": "SELECT DISTINCT ProductID FROM Sales WHERE Quantity = ( SELECT MAX(Quantity) FROM Sales )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id FROM products ORDER BY quantity ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2389": {
        "db_id": "superstore",
        "question": "Among the products under the office supplies category, what is the product that made the highest sales in the Central region?",
        "ground_truth": "SELECT T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Category = 'Office Supplies' AND T2.Region = 'Central' ORDER BY T1.Sales DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, SUM(sales) as total_sales\nFROM sales_data\nWHERE category = 'office supplies'\nGROUP BY product_name\nORDER BY total_sales DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5040": {
        "db_id": "olympics",
        "question": "List out the name of the game that the people participated in games id 13.",
        "ground_truth": "SELECT DISTINCT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T2.games_id = 13",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE id = 13;"
        ],
        "rule_sql": []
    },
    "328": {
        "db_id": "retail_complains",
        "question": "How many of the complaints are longer than 15 minutes?",
        "ground_truth": "SELECT COUNT(ser_time) FROM callcenterlogs WHERE strftime('%M', ser_time) > '15'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE duration > 15"
        ],
        "rule_sql": []
    },
    "7971": {
        "db_id": "music_platform_2",
        "question": "List all the podcasts reviewed by a reviewer who has a review titled \"Inspired & On Fire!\".",
        "ground_truth": "SELECT T1.title FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.title = 'Inspired & On Fire!'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.* \nFROM podcasts p\nJOIN reviews r ON p.podcast_id = r.podcast_id\nWHERE r.review_title = 'Inspired & On Fire!';"
        ],
        "rule_sql": []
    },
    "8724": {
        "db_id": "chicago_crime",
        "question": "In the South side community, what is the name of the community with the most reported incidents of unlawful taking, carrying, leading, or riding away of property from the possession or constructive possession of another person?",
        "ground_truth": "SELECT T3.community_area_name FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no INNER JOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no WHERE T3.side = 'South' AND T1.description = 'The unlawful taking, carrying, leading, or riding away of property FROM the possession or constructive possession of another person.' GROUP BY T3.community_area_name ORDER BY COUNT(T1.fbi_code_no) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_name \nFROM communities \nWHERE side = 'South' \nORDER BY reported_incidents DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1920": {
        "db_id": "soccer_2016",
        "question": "How many players bat with their left hands?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Batting_hand = 'Left-hand bat' THEN 1 ELSE 0 END) FROM Player AS T1 INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE batting_hand = 'right';"
        ],
        "rule_sql": []
    },
    "3504": {
        "db_id": "video_games",
        "question": "When was the game ID 156 released?",
        "ground_truth": "SELECT T1.release_year FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id WHERE T2.game_id = 156",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_date FROM games WHERE game_id = '156';"
        ],
        "rule_sql": []
    },
    "1381": {
        "db_id": "synthea",
        "question": "Provide the name of the patient who had a claim on 1947/9/11.",
        "ground_truth": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE T2.billableperiod = '1947-09-11'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM patients WHERE claim_date = '1947/9/11';"
        ],
        "rule_sql": []
    },
    "4624": {
        "db_id": "disney",
        "question": "Please list the villains of all the movies directed by Wolfgang Reitherman.",
        "ground_truth": "SELECT T2.villian FROM director AS T1 INNER JOIN characters AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Wolfgang Reitherman' AND T2.villian IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT villain FROM movies WHERE director = 'Wolfgang Reitherman';"
        ],
        "rule_sql": []
    },
    "4095": {
        "db_id": "public_review_platform",
        "question": "What are the states of businesses with attribute of beer and wine located?",
        "ground_truth": "SELECT DISTINCT T2.state FROM Business_Attributes AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T1.attribute_value = 'beer_and_wine'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM businesses WHERE attribute = 'beer' OR attribute = 'wine'"
        ],
        "rule_sql": []
    },
    "3944": {
        "db_id": "public_review_platform",
        "question": "How many businesses have a romantic ambiance?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_value = 'true' AND T1.attribute_name = 'ambience_romantic'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE ambiance = 'romantic';"
        ],
        "rule_sql": []
    },
    "1671": {
        "db_id": "restaurant",
        "question": "What types of food are served at the 4 top-reviewed restaurants?",
        "ground_truth": "SELECT food_type FROM generalinfo WHERE review = ( SELECT MAX(review) FROM generalinfo ) LIMIT 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT food_type FROM restaurants WHERE review_count > 100 ORDER BY rating DESC LIMIT 4;"
        ],
        "rule_sql": []
    },
    "2718": {
        "db_id": "regional_sales",
        "question": "How many online orders were shipped during the month of June 2018?",
        "ground_truth": "SELECT SUM(IIF(ShipDate LIKE '6/%/18' AND `Sales Channel` = 'Online', 1, 0)) FROM `Sales Orders`",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE order_date LIKE '2018-06%' AND status = 'shipped';"
        ],
        "rule_sql": []
    },
    "558": {
        "db_id": "movies_4",
        "question": "How many production companies made more than 150 movies?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.company_name AS CNAME FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id GROUP BY T1.company_id HAVING COUNT(T1.company_name) > 150 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM production_companies \nWHERE movies_count > 150;"
        ],
        "rule_sql": []
    },
    "8688": {
        "db_id": "chicago_crime",
        "question": "In drug abuse crimes, what percentage is related to cannabis?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.secondary_description LIKE '%CANNABIS%' THEN T1.secondary_description END) AS REAL) * 100 / COUNT(T1.secondary_description) FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN FBI_Code AS T3 ON T3.fbi_code_no = T2.fbi_code_no WHERE T3.title = 'Drug Abuse'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM crimes WHERE crime_type = 'drug_abuse')) AS percentage\nFROM crimes \nWHERE crime_type = 'drug_abuse' AND drug_type = 'cannabis';"
        ],
        "rule_sql": []
    },
    "8993": {
        "db_id": "bike_share_1",
        "question": "Name all the trips where the bike was borrowed and returned on a different day. State the city where the bike was returned.",
        "ground_truth": "SELECT DISTINCT T1.city FROM station AS T1 INNER JOIN trip AS T2 ON T2.start_station_name = T1.name WHERE SUBSTR(CAST(T2.start_date AS TEXT), INSTR(T2.start_date, '/') + 1) - SUBSTR(CAST(T2.start_date AS TEXT), INSTR(T2.start_date, ' ') - 5) <> SUBSTR(CAST(T2.end_date AS TEXT), INSTR(T2.end_date, '/') + 1) - SUBSTR(CAST(T2.end_date AS TEXT), INSTR(T2.end_date, ' ') - 5)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.trip_id, s.city \nFROM trips t \nJOIN stations s ON t.end_station_id = s.station_id \nWHERE DATE(t.start_time) = DATE(t.end_time);"
        ],
        "rule_sql": []
    },
    "9208": {
        "db_id": "movie_3",
        "question": "Calculate customers' total payment amount in August, 2005.",
        "ground_truth": "SELECT SUM(amount) FROM payment WHERE SUBSTR(payment_date, 1, 7) = '2005-08'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, SUM(amount) FROM payments WHERE payment_date LIKE '2005-08%' GROUP BY customer_id"
        ],
        "rule_sql": []
    },
    "1043": {
        "db_id": "talkingdata",
        "question": "How many active users were there in the event id 2?",
        "ground_truth": "SELECT COUNT(is_active) FROM app_events WHERE event_id = 2 AND is_active = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE status = 'active' AND event_id = 2;"
        ],
        "rule_sql": []
    },
    "4540": {
        "db_id": "student_loan",
        "question": "Among the students that filed for bankruptcy, how many of them have been enrolled in OCC?",
        "ground_truth": "SELECT COUNT(T1.name) FROM filed_for_bankrupcy AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name WHERE T2.school = 'occ'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE bankruptcy_status = 'filed' AND enrollment_status = 'OCC';"
        ],
        "rule_sql": []
    },
    "3871": {
        "db_id": "public_review_platform",
        "question": "Please list the business IDs of the Yelp_Business that have a business time of longer than 12 hours on Sundays.",
        "ground_truth": "SELECT T1.business_id FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id INNER JOIN Business AS T3 ON T1.business_id = T3.business_id WHERE T1.closing_time + 12 - T1.opening_time > 12 AND T2.day_of_week LIKE 'Sunday' GROUP BY T1.business_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM Yelp_Business WHERE Sunday_hours > 12;"
        ],
        "rule_sql": []
    },
    "3804": {
        "db_id": "public_review_platform",
        "question": "Which businesses are no longer in business but have a low number of votes useful?",
        "ground_truth": "SELECT DISTINCT T1.business_id FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T2.active LIKE 'FALSE' AND T1.review_votes_useful LIKE 'Low'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE status = 'closed' ORDER BY votes DESC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "4425": {
        "db_id": "student_loan",
        "question": "How many students have been absent above 2 months?",
        "ground_truth": "SELECT COUNT(name) FROM longest_absense_from_school WHERE month > 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE absent_days > 60;"
        ],
        "rule_sql": []
    },
    "9382": {
        "db_id": "movie_3",
        "question": "For how long can you rent the movie 'Dirty Ace'?",
        "ground_truth": "SELECT rental_duration FROM film WHERE title = 'DIRTY ACE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rental_duration FROM film WHERE title = 'Dirty Ace';"
        ],
        "rule_sql": []
    },
    "5117": {
        "db_id": "address",
        "question": "Which state is area code 878 in? Give the name of the state.",
        "ground_truth": "SELECT T2.state FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.area_code = 878",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state_name FROM area_codes WHERE area_code = 878;"
        ],
        "rule_sql": []
    },
    "271": {
        "db_id": "retail_complains",
        "question": "What is the percentage of the complaint calls from Mr Mason Javen Lopez has got the consent provided by the customer?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.`Consumer consent provided?` = 'Consent provided' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.`Consumer consent provided?`) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.sex = 'Male' AND T1.first = 'Mason' AND T1.middle = 'Javen' AND T1.last = 'Lopez'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN consent_provided = 'Yes' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_consent\nFROM complaint_calls \nWHERE customer_name = 'Mr Mason Javen Lopez';"
        ],
        "rule_sql": []
    },
    "3932": {
        "db_id": "public_review_platform",
        "question": "What is the opening time of the active businesses in Surprise that has a low review count.",
        "ground_truth": "SELECT T2.opening_time FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Surprise' AND T1.active LIKE 'TRUE' AND T1.review_count LIKE 'Low' GROUP BY T2.opening_time",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT opening_time FROM businesses WHERE city = 'Surprise' AND is_active = 1 AND review_count < 10 ORDER BY opening_time DESC;"
        ],
        "rule_sql": []
    },
    "4393": {
        "db_id": "student_loan",
        "question": "List 10 students that have no due payments and are not males.",
        "ground_truth": "SELECT T1.name FROM no_payment_due AS T1 INNER JOIN person AS T2 ON T1.`name` = T2.`name` WHERE T2.`name` NOT IN ( SELECT name FROM male ) AND T1.bool = 'neg'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE gender = 'male' AND payment_due = 0 LIMIT 10;"
        ],
        "rule_sql": []
    },
    "7717": {
        "db_id": "hockey",
        "question": "Who was the coach for the team which had the most bench minors penalty in 2003\uff1f",
        "ground_truth": "SELECT DISTINCT T3.firstName, T3.lastName FROM Teams AS T1 INNER JOIN Coaches AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN Master AS T3 ON T2.coachID = T3.coachID WHERE T1.year = '2003' GROUP BY T3.firstName, T3.lastName ORDER BY SUM(T1.BenchMinor) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach FROM teams WHERE year = 2003 ORDER BY bench_minors DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4915": {
        "db_id": "olympics",
        "question": "When John Aalberg took part in the 1994 Winter Olympic Game, how old was he?",
        "ground_truth": "SELECT T2.age FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.full_name = 'John Aalberg' AND T1.games_name = '1994 Winter'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM athletes WHERE name = 'John Aalberg' AND year = 1994 AND season = 'Winter';"
        ],
        "rule_sql": []
    },
    "2894": {
        "db_id": "professional_basketball",
        "question": "Name the youngest player who ever won \"Rookie of the Year\".",
        "ground_truth": "SELECT T1.firstName, T1.middleName, T1.lastName FROM players AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE T2.award = 'Rookie of the Year' ORDER BY T1.birthDate DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE award = 'Rookie of the Year' ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1420": {
        "db_id": "synthea",
        "question": "List the procedures received by Emmy Waelchi.",
        "ground_truth": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Emmy' AND T1.last = 'Waelchi'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM procedures WHERE patient_name = 'Emmy Waelchi';"
        ],
        "rule_sql": []
    },
    "8119": {
        "db_id": "university",
        "question": "What is the total number of ranking criteria under the ranking system called Shanghai Ranking?",
        "ground_truth": "SELECT COUNT(*) FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T1.system_name = 'Shanghai Ranking'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ranking_systems WHERE system_name = 'Shanghai Ranking';"
        ],
        "rule_sql": []
    },
    "9275": {
        "db_id": "movie_3",
        "question": "How many customers did not rent material at Mike's store?",
        "ground_truth": "SELECT COUNT(T1.customer_id) FROM customer AS T1 INNER JOIN store AS T2 ON T1.store_id = T2.store_id INNER JOIN staff AS T3 ON T2.manager_staff_id = T3.staff_id WHERE T3.first_name != 'Mike'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE store_id != (SELECT store_id FROM stores WHERE manager_name = 'Mike')"
        ],
        "rule_sql": []
    },
    "2883": {
        "db_id": "professional_basketball",
        "question": "List the full name of players who are born outside USA.",
        "ground_truth": "SELECT firstName, middleName, lastName FROM players WHERE birthCountry != 'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "1954": {
        "db_id": "soccer_2016",
        "question": "What is the name of the team that won the first ever match?",
        "ground_truth": "SELECT T1.Team_Name FROM team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Match_Winner WHERE T2.Season_Id = 1 ORDER BY T2.Match_Date LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE match_id = 1;"
        ],
        "rule_sql": []
    },
    "116": {
        "db_id": "movie_platform",
        "question": "Who was the earliest user created a list but didn't get any followers? Give the user ID.",
        "ground_truth": "SELECT user_id FROM lists_users WHERE user_subscriber = 0 ORDER BY list_creation_date_utc LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM users WHERE created_at = (SELECT MIN(created_at) FROM users) AND followers_count = 0;"
        ],
        "rule_sql": []
    },
    "3217": {
        "db_id": "donor",
        "question": "In the schools donated by the project of the resources provided by ABC School Supply, how many schools are public magnet schools?",
        "ground_truth": "SELECT COUNT(T2.schoolid) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_magnet = 't' AND T1.vendor_name = 'ABC School Supply'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE project = 'ABC School Supply' AND type = 'public magnet';"
        ],
        "rule_sql": []
    },
    "7117": {
        "db_id": "works_cycles",
        "question": "What is the sales revenue for item number 740?",
        "ground_truth": "SELECT ListPrice - StandardCost FROM Product WHERE ProductID = 740",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM sales WHERE item_id = 740;"
        ],
        "rule_sql": []
    },
    "362": {
        "db_id": "retail_complains",
        "question": "What is the email address of clients who submitted their complaints via postal mail?",
        "ground_truth": "SELECT T1.email FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Submitted via` = 'Postal mail'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM clients WHERE complaint_method = 'email';"
        ],
        "rule_sql": []
    },
    "1193": {
        "db_id": "talkingdata",
        "question": "State the category of the label that represented the behavior category of app id 4955831798976240000.",
        "ground_truth": "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE T2.app_id = 4955831798976240000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM labels WHERE app_id = 4955831798976240000 AND behavior = 'category';"
        ],
        "rule_sql": []
    },
    "4863": {
        "db_id": "legislator",
        "question": "What is the ratio between famous current legislators and famous historical legislators?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN wikipedia_id IS NOT NULL THEN bioguide_id ELSE 0 END) AS REAL) * 100 / ( SELECT COUNT(CASE WHEN wikipedia_id IS NOT NULL THEN bioguide_id ELSE 0 END) FROM historical ) FROM current",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM legislators WHERE status = 'current' AND famous = 1) / \n    (SELECT COUNT(*) FROM legislators WHERE status = 'historical' AND famous = 1) \nAS ratio;"
        ],
        "rule_sql": []
    },
    "6143": {
        "db_id": "food_inspection_2",
        "question": "How many inspections with critical food safety problems are under inspection point id 3?",
        "ground_truth": "SELECT COUNT(inspection_id) FROM violation WHERE point_id = 3 AND fine = 500",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE inspection_point_id = 3 AND critical_food_safety_problems = 0;"
        ],
        "rule_sql": []
    },
    "4361": {
        "db_id": "simpson_episodes",
        "question": "Among the people in Animation Department, who are credited for additional time in the episode titled by \"How the Test Was Won\"?",
        "ground_truth": "SELECT T2.person FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'How the Test Was Won' AND T2.role = 'additional timer' AND T2.credited = 'true' AND T2.category = 'Animation Department';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people JOIN departments ON people.department_id = departments.id WHERE departments.name = 'Animation' AND episodes.title = 'How the Test Was Won' AND people.credited_for_additional_time = 1;"
        ],
        "rule_sql": []
    },
    "8022": {
        "db_id": "university",
        "question": "Give the score and number of international students in university ID 100 in 2015.",
        "ground_truth": "SELECT CAST(T1.num_students * T1.pct_international_students AS REAL) / 100, T2.score FROM university_year AS T1 INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE T2.year = 2015 AND T1.university_id = 100",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT score, COUNT(*) AS international_students FROM universities WHERE university_id = 100 AND year = 2015;"
        ],
        "rule_sql": []
    },
    "4613": {
        "db_id": "mental_health_survey",
        "question": "Among respondents who participated in the survey in 2016, what percentage had a mental health disorder in the past?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN T1.AnswerText LIKE 'Yes' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.SurveyID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T1.QuestionID = 32 AND T1.SurveyID = 2016",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN mental_health_disorder = 'Yes' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM survey_responses\nWHERE year = 2016;"
        ],
        "rule_sql": []
    },
    "802": {
        "db_id": "social_media",
        "question": "State the number of positive tweets from Ha Noi.",
        "ground_truth": "SELECT COUNT(T1.TweetID) FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T1.Sentiment > 0 AND T2.State = 'Ha Noi'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE city = 'Ha Noi' AND sentiment = 'positive';"
        ],
        "rule_sql": []
    },
    "8900": {
        "db_id": "cookbook",
        "question": "How many servings does the recipe with the highest unsaturated fat have?",
        "ground_truth": "SELECT COUNT(T1.title) FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY T2.total_fat - T2.sat_fat DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT servings FROM recipes ORDER BY saturated_fat DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9407": {
        "db_id": "movie_3",
        "question": "List the store ID of the films starred by Reese West with a duration of 100 minutes and below?",
        "ground_truth": "SELECT T4.store_id FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE T3.length < 100 AND T1.first_name = 'Reese' AND T1.last_name = 'West'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id FROM films WHERE actor = 'Reese West' AND duration <= 100;"
        ],
        "rule_sql": []
    },
    "616": {
        "db_id": "codebase_comments",
        "question": "Among all the solution of the 'zh-cn' methods, which path is most often used?",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Lang = 'zh-cn' GROUP BY T1.Path ORDER BY COUNT(T1.Path) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path, COUNT(*) as usage_count FROM solutions WHERE method = 'zh-cn' GROUP BY path ORDER BY usage_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "605": {
        "db_id": "codebase_comments",
        "question": "List the summary of the method \"Castle.MonoRail.Framework.Test.StubViewComponentContext.RenderSection\".",
        "ground_truth": "SELECT DISTINCT Summary FROM Method WHERE Name = 'Castle.MonoRail.Framework.Test.StubViewComponentContext.RenderSection'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM methods WHERE method_name = 'Castle.MonoRail.Framework.Test.StubViewComponentContext.RenderSection';"
        ],
        "rule_sql": []
    },
    "7924": {
        "db_id": "music_platform_2",
        "question": "How many people rated 5 for the podcast which title contains the word 'spoiler' under the 'art' category '?",
        "ground_truth": "SELECT COUNT(T3.podcast_id) FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id INNER JOIN reviews AS T3 ON T3.podcast_id = T2.podcast_id WHERE T2.title LIKE '%spoilers%' AND T1.category = 'arts' AND T3.rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ratings r JOIN podcasts p ON r.podcast_id = p.id JOIN categories c ON p.category_id = c.id WHERE r.rating = 5 AND p.title LIKE '%spoiler%' AND c.name = 'art';"
        ],
        "rule_sql": []
    },
    "9232": {
        "db_id": "movie_3",
        "question": "Among the films starred by Angelina Astaire, what is the title of the film with a replacement cost of 27.99?",
        "ground_truth": "SELECT T3.title FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'Angelina' AND T1.last_name = 'Astaire' AND T3.replacement_cost = 27.99",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films \nWHERE actor = 'Angelina Astaire' AND replacement_cost = 27.99;"
        ],
        "rule_sql": []
    },
    "874": {
        "db_id": "cs_semester",
        "question": "For the 3-credit course with the easiest difficulty, how many students get an \"A\" in that course?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T1.grade = 'A' AND T2.credit = '3' AND T2.diff = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students s\nJOIN grades g ON s.student_id = g.student_id\nJOIN courses c ON g.course_id = c.course_id\nWHERE c.credits = 3\nAND c.difficulty = 'Easiest'\nAND g.grade = 'A';"
        ],
        "rule_sql": []
    },
    "4579": {
        "db_id": "mental_health_survey",
        "question": "Which country have the least number of users being surveyed? Indicate the name of the country. If there are multiple countries having the same number of users, indicate all of their names.",
        "ground_truth": "SELECT T1.AnswerText FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 3 GROUP BY T1.AnswerText ORDER BY COUNT(T1.UserID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as user_count FROM users GROUP BY country ORDER BY user_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7729": {
        "db_id": "hockey",
        "question": "What is the position of the 9th oldest hockey player?",
        "ground_truth": "SELECT pos FROM Master WHERE birthYear IS NOT NULL ORDER BY birthYear, birthMon, birthDay LIMIT 8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position FROM hockey_players ORDER BY age ASC LIMIT 1 OFFSET 8;"
        ],
        "rule_sql": []
    },
    "3418": {
        "db_id": "video_games",
        "question": "How many publishers published the Minecraft game?",
        "ground_truth": "SELECT COUNT(T2.publisher_id) FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id WHERE T1.game_name = 'Minecraft'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE name = 'Minecraft';"
        ],
        "rule_sql": []
    },
    "5358": {
        "db_id": "beer_factory",
        "question": "What is the email address of the customer who made a purchase in transaction 100016?",
        "ground_truth": "SELECT T1.Email FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.TransactionID = '100016'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM customers WHERE transaction_id = 100016;"
        ],
        "rule_sql": []
    },
    "8914": {
        "db_id": "cookbook",
        "question": "How many recipes can be made with canned dairy?",
        "ground_truth": "SELECT COUNT(*) FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE T1.category = 'canned dairy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM recipes WHERE ingredients LIKE '%canned dairy%';"
        ],
        "rule_sql": []
    },
    "6974": {
        "db_id": "ice_hockey_draft",
        "question": "How many players were drafted by Arizona Coyotes whose height reaches 195 centimeters?",
        "ground_truth": "SELECT COUNT(T2.ELITEID) FROM height_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height WHERE T2.overallby = 'Arizona Coyotes' AND T1.height_in_cm = 195",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players \nWHERE team = 'Arizona Coyotes' \nAND height >= 195;"
        ],
        "rule_sql": []
    },
    "3232": {
        "db_id": "donor",
        "question": "For the teacher who wrote the project 'ABC Read', which city was he/she in?",
        "ground_truth": "SELECT T2.school_city FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.title = 'ABC Read'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM teachers WHERE project = 'ABC Read';"
        ],
        "rule_sql": []
    },
    "1392": {
        "db_id": "synthea",
        "question": "What is/are the ids of the tallest patient/s?",
        "ground_truth": "SELECT PATIENT FROM observations WHERE DESCRIPTION = 'Body Height' AND UNITS = 'cm' ORDER BY VALUE DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM patients ORDER BY height ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4178": {
        "db_id": "simpson_episodes",
        "question": "What is the average number of stars received by the episode titled 'Wedding for Disaster.'",
        "ground_truth": "SELECT AVG(T2.stars) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.title = 'Wedding for Disaster';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM episodes WHERE title = 'Wedding for Disaster';"
        ],
        "rule_sql": []
    },
    "7845": {
        "db_id": "world",
        "question": "What are the official languages used in Belgium?",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Belgium' AND T2.IsOfficial = 'T'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE name = 'Belgium';"
        ],
        "rule_sql": []
    },
    "3433": {
        "db_id": "video_games",
        "question": "Indicate the name of all adventure games.",
        "ground_truth": "SELECT T2.game_name FROM genre AS T1 INNER JOIN game AS T2 ON T1.id = T2.genre_id WHERE T1.genre_name = 'Adventure'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE genre = 'Adventure';"
        ],
        "rule_sql": []
    },
    "5272": {
        "db_id": "beer_factory",
        "question": "Which brand of root beer did Jayne Collins give the lowest rating?",
        "ground_truth": "SELECT T3.BrandName FROM customers AS T1 INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeerbrand AS T3 ON T2.BrandID = T3.BrandID WHERE T1.First = 'Jayne' AND T1.Last = 'Collins' AND T2.StarRating = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM ratings WHERE reviewer = 'Jayne Collins' ORDER BY rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5562": {
        "db_id": "menu",
        "question": "How many dishes are there on the menu \"Zentral Theater Terrace\"?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE name = 'Zentral Theater Terrace'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dishes WHERE menu_name = 'Zentral Theater Terrace';"
        ],
        "rule_sql": []
    },
    "8361": {
        "db_id": "mondial_geo",
        "question": "Which nation has the greatest infant mortality rate among those that attained independence in 1960?",
        "ground_truth": "SELECT T1.Country FROM politics AS T1 INNER JOIN population AS T2 ON T1.Country = T2.Country WHERE STRFTIME('%Y', T1.Independence) = '1960' ORDER BY T2.Infant_Mortality DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n.Name, n.InfantMortality \nFROM nations n \nWHERE n.IndependenceYear = 1960 \nORDER BY n.InfantMortality ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3915": {
        "db_id": "public_review_platform",
        "question": "How many of the businesses are active?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE active LIKE 'True'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE status = 'inactive';"
        ],
        "rule_sql": []
    },
    "1036": {
        "db_id": "computer_student",
        "question": "Which professor taught the most courses and what is the position of this person in the university?",
        "ground_truth": "SELECT T1.p_id, T1.hasPosition FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id GROUP BY T1.p_id ORDER BY COUNT(T2.course_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, p.position, COUNT(c.course_id) as course_count\nFROM professors p\nLEFT JOIN courses c ON p.professor_id = c.professor_id\nGROUP BY p.professor_id\nORDER BY course_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5619": {
        "db_id": "shipping",
        "question": "Identify the total weight of shipments transported to San Mateo, California, in 2016.",
        "ground_truth": "SELECT SUM(T1.weight) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T2.city_name = 'San Mateo' AND STRFTIME('%Y', T1.ship_date) = '2016'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(weight) FROM shipments WHERE destination_city = 'San Mateo' AND destination_state = 'California' AND year = 2016;"
        ],
        "rule_sql": []
    },
    "1757": {
        "db_id": "restaurant",
        "question": "Give the street number of a bar in Oakland with a 2.7 review.",
        "ground_truth": "SELECT T2.street_num FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.review = 2.7 AND T2.city = 'oakland' AND T1.food_type = 'bar'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street_number FROM bars WHERE city = 'Oakland' AND review = 2.7;"
        ],
        "rule_sql": []
    },
    "3720": {
        "db_id": "college_completion",
        "question": "Tell the number of 4-year public schools in UT whose graduation rate exceeds the average for the state.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.chronname) FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.state = T1.state WHERE T2.state_abbr = 'UT' AND T1.level = '4-year' AND T1.control = 'Public' AND T1.awards_per_value > T1.awards_per_state_value",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE state = 'UT' AND type = 'public' AND years = 4 AND graduation_rate > (SELECT AVG(graduation_rate) FROM schools WHERE state = 'UT')"
        ],
        "rule_sql": []
    },
    "9200": {
        "db_id": "movie_3",
        "question": "List the actors' IDs who have \"KILMER\" as last name.",
        "ground_truth": "SELECT actor_id FROM actor WHERE last_name = 'KILMER'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id FROM actor WHERE first_name = 'KILMER';"
        ],
        "rule_sql": []
    },
    "166": {
        "db_id": "movie_platform",
        "question": "What are the top 10 oldest movies and what are the average rating score for each movie? Indicate the name of the director and when the movies were released.",
        "ground_truth": "SELECT T2.movie_id, AVG(T1.rating_score), T2.director_name, T2.movie_release_year FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id ORDER BY T1.rating_timestamp_utc ASC LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, m.release_year, d.name AS director_name, AVG(r.rating) AS average_rating\nFROM movies m\nJOIN directors d ON m.director_id = d.id\nLEFT JOIN ratings r ON m.id = r.movie_id\nGROUP BY m.id\nORDER BY m.release_year ASC\nLIMIT 10;"
        ],
        "rule_sql": []
    },
    "530": {
        "db_id": "movies_4",
        "question": "List all the unspecified gender characters.",
        "ground_truth": "SELECT T1.character_name FROM movie_cast AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.gender_id WHERE T2.gender = 'Unspecified'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM characters WHERE gender IS NULL OR gender = '';"
        ],
        "rule_sql": []
    },
    "7406": {
        "db_id": "works_cycles",
        "question": "Among the employees who are store contacts, how many of them have a title of \"Mr.\"?",
        "ground_truth": "SELECT COUNT(BusinessEntityID) FROM Person WHERE PersonType = 'SC' AND Title = 'Mr.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE title = 'Mr.' AND store_contact = 1;"
        ],
        "rule_sql": []
    },
    "7121": {
        "db_id": "works_cycles",
        "question": "What job is person number 322 currently holding?",
        "ground_truth": "SELECT T1.Name FROM ContactType AS T1 INNER JOIN BusinessEntityContact AS T2 ON T1.ContactTypeID = T2.ContactTypeID WHERE T2.BusinessEntityID = 332",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title FROM people WHERE person_id = 322;"
        ],
        "rule_sql": []
    },
    "5580": {
        "db_id": "shipping",
        "question": "Among the shipments done by Sue Newell, how many of them are for S K L Enterprises Inc?",
        "ground_truth": "SELECT COUNT(*) FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id INNER JOIN driver AS T3 ON T3.driver_id = T2.driver_id WHERE T1.cust_name = 'S K L Enterprises Inc' AND T3.first_name = 'Sue' AND T3.last_name = 'Newell'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE shipper_name = 'Sue Newell' AND customer_name = 'S K L Enterprises Inc';"
        ],
        "rule_sql": []
    },
    "6188": {
        "db_id": "food_inspection_2",
        "question": "Provide the names and locations of the facilities that failed inspections on 29th July 2013.",
        "ground_truth": "SELECT T2.dba_name, T2.longitude, T2.latitude FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE T1.inspection_date = '2013-07-29' AND T1.results = 'Fail'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, location FROM facilities WHERE inspection_date = '2013-07-29' AND inspection_result = 'failed';"
        ],
        "rule_sql": []
    },
    "2099": {
        "db_id": "world_development_indicators",
        "question": "What is the description of the footnote on the series code AG.LND.FRST.K2 in 1990 for Aruba?",
        "ground_truth": "SELECT T2.Description FROM Country AS T1 INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.ShortName = 'Aruba' AND T2.Seriescode = 'AG.LND.FRST.K2' AND T2.Year = 'YR1990'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM footnotes WHERE series_code = 'AG.LND.FRST.K2' AND year = 1990 AND country = 'Aruba';"
        ],
        "rule_sql": []
    },
    "7296": {
        "db_id": "works_cycles",
        "question": "Which vendor's selling price for Hex Nut 5 is the lowest, please give the vendor's name.",
        "ground_truth": "SELECT T3.Name FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T2.Name = 'Hex Nut 5' ORDER BY T1.StandardPrice LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name FROM vendors WHERE product_name = 'Hex Nut 5' ORDER BY selling_price DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3402": {
        "db_id": "video_games",
        "question": "How many games do not have any sales in Europe?",
        "ground_truth": "SELECT COUNT(*) FROM region_sales AS T1 INNER JOIN region AS T2 ON T1.region_id = T2.id WHERE T2.region_name = 'Europe' AND T1.num_sales = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE europe_sales IS NULL;"
        ],
        "rule_sql": []
    },
    "9041": {
        "db_id": "bike_share_1",
        "question": "In 2006, how many trips ended at stations in Mountain View?",
        "ground_truth": "SELECT COUNT(T2.city) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.end_station_name WHERE T2.city = 'Mountain View' AND T1.start_date LIKE '%2006%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trips WHERE end_year = 2006 AND end_city = 'Mountain View';"
        ],
        "rule_sql": []
    },
    "6753": {
        "db_id": "retails",
        "question": "Among the customers in Asia, how many customers are in debt?",
        "ground_truth": "SELECT COUNT(T1.n_name) FROM nation AS T1 INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey WHERE T2.c_acctbal < 0 AND T3.r_name = 'ASIA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE region = 'Asia' AND balance > 0;"
        ],
        "rule_sql": []
    },
    "3862": {
        "db_id": "public_review_platform",
        "question": "How long does Yelp_Business no.1 open on Tuesdays?",
        "ground_truth": "SELECT T1.closing_time - T1.opening_time AS \"opening hours\" FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T2.day_of_week LIKE 'Tuesday' AND T1.business_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT closing_time - opening_time FROM Yelp_Business WHERE business_id = 1 AND day_of_week = 'Tuesday';"
        ],
        "rule_sql": []
    },
    "8940": {
        "db_id": "human_resources",
        "question": "How many employees work as an Account Representative?",
        "ground_truth": "SELECT COUNT(*) FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T2.positiontitle = 'Account Representative'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE job_title = 'Account Manager';"
        ],
        "rule_sql": []
    },
    "7477": {
        "db_id": "image_and_language",
        "question": "How many self-relations are there between the object samples in image no.5?",
        "ground_truth": "SELECT SUM(CASE WHEN IMG_ID = 5 THEN 1 ELSE 0 END) FROM IMG_REL WHERE OBJ1_SAMPLE_ID = OBJ2_SAMPLE_ID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM image_objects WHERE image_id = 5 AND object_id = object_id;"
        ],
        "rule_sql": []
    },
    "8055": {
        "db_id": "university",
        "question": "Provide the number of staff at the University of Auckland in 2015.",
        "ground_truth": "SELECT CAST(SUM(T1.num_students) AS REAL) / SUM(T1.student_staff_ratio) FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T2.university_name = 'University of Auckland' AND T1.year = 2015",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM staff WHERE university = 'University of Auckland' AND year = 2015;"
        ],
        "rule_sql": []
    },
    "2368": {
        "db_id": "superstore",
        "question": "Name 10 products that were shipped first class from the East region.",
        "ground_truth": "SELECT T2.`Product Name` FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.`Ship Mode` = 'First Class' AND T2.Region = 'East' LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE shipping_method = 'first class' AND region = 'East' LIMIT 10;"
        ],
        "rule_sql": []
    },
    "6289": {
        "db_id": "coinmarketcap",
        "question": "When did Peercoin rank fifth?",
        "ground_truth": "SELECT T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Peercoin' AND T2.cmc_rank = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM cryptocurrency_rankings WHERE rank = 5 AND name = 'Peercoin';"
        ],
        "rule_sql": []
    },
    "4847": {
        "db_id": "legislator",
        "question": "How many legislators were born in 1736?",
        "ground_truth": "SELECT COUNT(bioguide_id) FROM historical WHERE birthday_bio LIKE '1736%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE birth_year = 1736;"
        ],
        "rule_sql": []
    },
    "6865": {
        "db_id": "retails",
        "question": "What is the size of the smallest part in a jumbo case container?",
        "ground_truth": "SELECT MIN(p_size) FROM part WHERE p_container = 'JUMBO CASE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(size) FROM parts WHERE container_type = 'jumbo case';"
        ],
        "rule_sql": []
    },
    "416": {
        "db_id": "movies_4",
        "question": "Please list the names of all the producers in the movie \"Pirates of the Caribbean: At World's End\".",
        "ground_truth": "SELECT T3.person_name FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T1.title LIKE 'Pirates of the Caribbean: At World%s End' AND T2.job = 'Producer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM producers WHERE movie_title = 'Pirates of the Caribbean: At World's End';"
        ],
        "rule_sql": []
    },
    "6052": {
        "db_id": "books",
        "question": "Name the publisher of the oldest book.",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id ORDER BY T1.publication_date ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM books ORDER BY publication_year ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8507": {
        "db_id": "mondial_geo",
        "question": "List all deserts that are not between latitudes 30 and 40.",
        "ground_truth": "SELECT Name FROM desert WHERE Latitude < 30 OR Latitude > 40",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM deserts WHERE latitude < 30 OR latitude > 40;"
        ],
        "rule_sql": []
    },
    "723": {
        "db_id": "trains",
        "question": "How many cars running east have double-sided tail cars?",
        "ground_truth": "SELECT COUNT(T1.id) FROM trains AS T1 INNER JOIN cars AS T2 ON T1.id = T2.train_id INNER JOIN ( SELECT train_id, MAX(position) AS trailPosi FROM cars GROUP BY train_id ) AS T3 ON T1.id = T3.train_id WHERE T1.direction = 'east' AND T2.position = T3.trailPosi AND T2.sides = 'double'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE direction = 'east' AND tail_type = 'double-sided';"
        ],
        "rule_sql": []
    },
    "5409": {
        "db_id": "sales",
        "question": "Identify the name of the sales person with employee ID 7.",
        "ground_truth": "SELECT FirstName, MiddleInitial, LastName FROM Employees WHERE EmployeeID = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM sales_person WHERE employee_id = 7;"
        ],
        "rule_sql": []
    },
    "9227": {
        "db_id": "movie_3",
        "question": "How many films have a rental rate of 0.99?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE rental_rate = 0.99",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE rental_rate = '0.99';"
        ],
        "rule_sql": []
    },
    "397": {
        "db_id": "retail_complains",
        "question": "Among the female clients that age between 20 to 40, list the date when their complaints were received.",
        "ground_truth": "SELECT DISTINCT T3.`Date received` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID INNER JOIN callcenterlogs AS T3 ON T2.`Complaint ID` = T3.`Complaint ID` WHERE T1.age BETWEEN 20 AND 40 AND T1.sex = 'Female'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT complaint_date FROM clients WHERE gender = 'male' AND age BETWEEN 20 AND 40"
        ],
        "rule_sql": []
    },
    "6696": {
        "db_id": "retails",
        "question": "For the order with the total price of 218195.43, which supplier handled the returned item? Give the supplier id.",
        "ground_truth": "SELECT T2.l_suppkey FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_totalprice = 218195.43 AND T2.l_returnflag = 'R'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT supplier_id FROM orders WHERE total_price = 218195.43 AND returned = 1;"
        ],
        "rule_sql": []
    },
    "5592": {
        "db_id": "shipping",
        "question": "State the headquarter of the truck which completed shipment no.1045.",
        "ground_truth": "SELECT T1.make FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = 1045",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT truck_headquarter FROM shipments WHERE shipment_id = 1045;"
        ],
        "rule_sql": []
    },
    "7083": {
        "db_id": "works_cycles",
        "question": "What percentage of people named Mary who wants Receive Email promotions of AdventureWorks and selected partners are store contacts?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN EmailPromotion = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN PersonType = 'SC' THEN 1 ELSE 0 END) FROM Person WHERE FirstName = 'Mary'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN sc.StoreContactID IS NOT NULL THEN 1 END) * 100.0 / COUNT(*)) AS Percentage\nFROM \n    Person.Person p\nLEFT JOIN \n    Sales.StoreContact sc ON p.BusinessEntityID = sc.PersonID\nWHERE \n    p.FirstName = 'Mary'\n    AND p.EmailPromotion = 1"
        ],
        "rule_sql": []
    },
    "2663": {
        "db_id": "regional_sales",
        "question": "Write down the store IDs and region of the state \"Michigan\".",
        "ground_truth": "SELECT DISTINCT T2.StoreID, T1.Region FROM Regions AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StateCode = T1.StateCode WHERE T2.State = 'Michigan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id, state FROM stores WHERE region = 'Michigan'"
        ],
        "rule_sql": []
    },
    "709": {
        "db_id": "trains",
        "question": "Among the trains that have at least one non-regular shaped car, what is the percentage of it running in the east direction?",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T2.direction = 'east' THEN T1.train_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.train_id) FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.shape IN ('bucket', 'ellipse')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN direction = 'east' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_east\nFROM trains\nWHERE train_id IN (\n    SELECT DISTINCT train_id \n    FROM cars \n    WHERE shape != 'regular'\n);"
        ],
        "rule_sql": []
    },
    "4275": {
        "db_id": "simpson_episodes",
        "question": "What was the character that Dan Castellaneta did the voice over for and was awarded?",
        "ground_truth": "SELECT DISTINCT T2.character FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T1.award LIKE '%Voice-Over%' AND T1.person = 'Dan Castellaneta';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM actors WHERE actor_name = 'Dan Castellaneta' AND awards_received > 0;"
        ],
        "rule_sql": []
    },
    "8794": {
        "db_id": "food_inspection",
        "question": "Give the description of the moderate risk violation which \"Chez Fayala, Inc.\" had on 2016/7/1.",
        "ground_truth": "SELECT T1.description FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.name = 'Chez Fayala, Inc.' AND T1.`date` = '2016-07-01' AND T1.risk_category = 'Moderate Risk'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM violations WHERE restaurant_name = 'Chez Fayala, Inc.' AND risk_level = 'Moderate' AND violation_date = '2016-07-01';"
        ],
        "rule_sql": []
    },
    "7969": {
        "db_id": "music_platform_2",
        "question": "What is the category for the \"Moist Boys\" podcast?",
        "ground_truth": "SELECT category FROM categories WHERE podcast_id IN ( SELECT podcast_id FROM podcasts WHERE title = 'Moist Boys' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM podcasts WHERE name = 'Moist Boys';"
        ],
        "rule_sql": []
    },
    "1442": {
        "db_id": "synthea",
        "question": "Calculate the number of female patients who accepted \"HPV quadrivalent\" immunization.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'HPV  quadrivalent' AND T1.gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND immunization = 'HPV quadrivalent';"
        ],
        "rule_sql": []
    },
    "6736": {
        "db_id": "retails",
        "question": "Calculate the total profit made by chocolate floral blue coral cyan.",
        "ground_truth": "SELECT SUM(T3.l_extendedprice * (1 - T3.l_discount) - T2.ps_supplycost * T3.l_quantity) FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_partkey = T3.l_partkey AND T2.ps_suppkey = T3.l_suppkey WHERE T1.p_name = 'chocolate floral blue coral cyan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price * quantity) AS total_profit FROM products WHERE name = 'chocolate floral blue coral cyan';"
        ],
        "rule_sql": []
    },
    "4104": {
        "db_id": "public_review_platform",
        "question": "How many businesses are opened the same number of hours every day of the week?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business_Hours WHERE opening_time = '8AM' AND closing_time = '6PM'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM businesses \nWHERE hours_monday = hours_tuesday \n   AND hours_tuesday = hours_wednesday \n   AND hours_wednesday = hours_thursday \n   AND hours_thursday = hours_friday \n   AND hours_friday = hours_saturday \n   AND hours_saturday = hours_sunday;"
        ],
        "rule_sql": []
    },
    "7909": {
        "db_id": "world",
        "question": "List down the cities belongs to the country that has surface area greater than 7000000.",
        "ground_truth": "SELECT T2.Name, T1.Name FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.SurfaceArea > 7000000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city.Name \nFROM city \nJOIN country ON city.CountryCode = country.Code \nWHERE country.SurfaceArea > 7000000;"
        ],
        "rule_sql": []
    },
    "3790": {
        "db_id": "public_review_platform",
        "question": "How many \"cute\" type of compliments does user No. 57400 get?",
        "ground_truth": "SELECT COUNT(T1.compliment_type) FROM Compliments AS T1 INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE T1.compliment_type LIKE 'cute' AND T2.user_id = 57400",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM compliments WHERE user_id = 57400 AND type = 'cute';"
        ],
        "rule_sql": []
    },
    "3650": {
        "db_id": "authors",
        "question": "Which year did the \"Internet, Multimedia Systems and Applications\" conference publish the most papers?",
        "ground_truth": "SELECT T2.Year FROM Conference AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE T1.FullName = 'Internet, Multimedia Systems and Applications' GROUP BY T2.Year ORDER BY COUNT(T2.Id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM conference_papers WHERE conference_name = 'Internet, Multimedia Systems and Applications' GROUP BY year ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3282": {
        "db_id": "donor",
        "question": "What is the project title of the school located at latitude 42003718 and longitude -87668289?",
        "ground_truth": "SELECT T1.title FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_latitude = 42003718 AND T2.school_longitude = -87668289",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT project_title FROM schools WHERE latitude = 42003718 AND longitude = -87668289;"
        ],
        "rule_sql": []
    },
    "3996": {
        "db_id": "public_review_platform",
        "question": "How many businesses in Glendale are reviewed by user with the ID of 20241?",
        "ground_truth": "SELECT COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'Glendale' AND T2.user_id = 20241",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Glendale' AND user_id = 20241;"
        ],
        "rule_sql": []
    },
    "6920": {
        "db_id": "ice_hockey_draft",
        "question": "How many players weigh more than 90 kg?",
        "ground_truth": "SELECT COUNT(T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T2.weight_in_kg > 90",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE weight < 90;"
        ],
        "rule_sql": []
    },
    "8933": {
        "db_id": "human_resources",
        "question": "Please list the social security numbers of the male employees with a salary of over $70,000 a year.",
        "ground_truth": "SELECT ssn FROM employee WHERE gender = 'M' AND CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) > 70000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ssn FROM employees WHERE gender = 'Female' AND salary > 70000;"
        ],
        "rule_sql": []
    },
    "65": {
        "db_id": "movie_platform",
        "question": "How many more movie lists were created by the user who created the movie list \"250 Favourite Films\"?",
        "ground_truth": "SELECT COUNT(list_id) FROM lists_users WHERE user_id = ( SELECT user_id FROM lists WHERE list_title = '250 Favourite Films' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movie_lists WHERE user_id = (SELECT user_id FROM movie_lists WHERE list_name = '250 Favourite Films') AND list_name != '250 Favourite Films';"
        ],
        "rule_sql": []
    },
    "113": {
        "db_id": "movie_platform",
        "question": "Who is the director that made the most movies? Give the director's id.",
        "ground_truth": "SELECT director_id FROM movies GROUP BY director_id ORDER BY COUNT(movie_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director_id FROM movies GROUP BY director_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4700": {
        "db_id": "disney",
        "question": "How many voice actors for the movie Aladdin?",
        "ground_truth": "SELECT COUNT('voice-actor') FROM `voice-actors` WHERE movie = 'Aladdin'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors WHERE movie_title = 'Aladdin' AND role_type = 'voice'"
        ],
        "rule_sql": []
    },
    "1982": {
        "db_id": "soccer_2016",
        "question": "Name the teams played in a match which resulted in a tie in 2015.",
        "ground_truth": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 OR T1.Team_Id = T2.Team_2 INNER JOIN Win_By AS T3 ON T2.Win_Type = T3.Win_Id WHERE SUBSTR(T2.Match_Date, 1, 4) = '2015' AND T3.Win_Type = 'Tie' LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team1, team2 FROM matches WHERE year = 2015 AND result = 'tie';"
        ],
        "rule_sql": []
    },
    "7174": {
        "db_id": "works_cycles",
        "question": "What's Lynn N Tsoflias's job title?",
        "ground_truth": "SELECT T2.JobTitle FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'Lynn' AND T1.MiddleName = 'N' AND T1.LastName = 'Tsoflias'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title FROM employees WHERE first_name = 'Lynn' AND last_name = 'Tsoflias';"
        ],
        "rule_sql": []
    },
    "3849": {
        "db_id": "public_review_platform",
        "question": "How many users have joined Yelp since the year 2012?",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year = 2012",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE join_date > 2012;"
        ],
        "rule_sql": []
    },
    "7397": {
        "db_id": "works_cycles",
        "question": "What is the discount percentage of \"LL Road Frame Sale\"?",
        "ground_truth": "SELECT DiscountPct FROM SpecialOffer WHERE Description = 'LL Road Frame Sale'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT discount_percentage FROM products WHERE product_name = 'LL Road Frame Sale';"
        ],
        "rule_sql": []
    },
    "3531": {
        "db_id": "authors",
        "question": "What is the total number and conference's homepage of papers held in a conference with an ID of 187 during 1990 to 2000?",
        "ground_truth": "SELECT COUNT(T2.ConferenceId), T1.HomePage FROM Conference AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE T2.Year BETWEEN 1990 AND 2000 AND T2.ConferenceId = 187",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as total_papers, conference.homepage \nFROM paper \nJOIN conference ON paper.conference_id = conference.id \nWHERE conference.id = 187 \nAND paper.year BETWEEN 1990 AND 2000;"
        ],
        "rule_sql": []
    },
    "2325": {
        "db_id": "movielens",
        "question": "How many different actors have played a role in the highest rating movie?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.actorid) FROM u2base AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE T1.rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT actor_id) FROM actors WHERE movie_id = (SELECT movie_id FROM movies ORDER BY rating DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "3706": {
        "db_id": "college_completion",
        "question": "How many more students in total graduated from Central Alabama Community College in 2012 than in 2011?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.year = 2012 THEN T2.grad_cohort ELSE 0 END) - SUM(CASE WHEN T2.year = 2011 THEN T2.grad_cohort ELSE 0 END) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.chronname = 'Central Alabama Community College'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SELECT COUNT(*) FROM students WHERE college = 'Central Alabama Community College' AND graduation_year = 2012) - (SELECT COUNT(*) FROM students WHERE college = 'Central Alabama Community College' AND graduation_year = 2011) AS difference;"
        ],
        "rule_sql": []
    },
    "2606": {
        "db_id": "regional_sales",
        "question": "List out the name of orders which have delivery date of 6/13/2018.",
        "ground_truth": "SELECT DISTINCT T FROM ( SELECT IIF(DeliveryDate = '6/13/18', OrderNumber, NULL) AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM orders WHERE delivery_date = '2018-06-13';"
        ],
        "rule_sql": []
    },
    "489": {
        "db_id": "movies_4",
        "question": "Which keywords belong to the movie titles with the highest popularity?",
        "ground_truth": "SELECT T3.keyword_name FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id ORDER BY T1.popularity DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword FROM movies ORDER BY popularity DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1878": {
        "db_id": "soccer_2016",
        "question": "List down the name of teams that won the toss of the coin from matches with ID from 336010 to 336020.",
        "ground_truth": "SELECT T2.Team_Name FROM Match AS T1 INNER JOIN Team AS T2 ON T2.Team_Id = T1.Toss_Winner WHERE T1.Match_Id BETWEEN 336010 AND 336020",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE match_id BETWEEN 336010 AND 336020 AND toss_winner = team_id;"
        ],
        "rule_sql": []
    },
    "385": {
        "db_id": "retail_complains",
        "question": "Which state has the most cities?",
        "ground_truth": "SELECT state_abbrev FROM district GROUP BY state_abbrev ORDER BY COUNT(city) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, COUNT(*) as city_count FROM cities GROUP BY state ORDER BY city_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4357": {
        "db_id": "simpson_episodes",
        "question": "Among the episodes aired in 2008 with votes ranges from 920 to 950, list their percent.",
        "ground_truth": "SELECT T2.percent FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' AND T1.votes BETWEEN 950 AND 960;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT percent FROM episodes WHERE year = 2008 AND votes BETWEEN 920 AND 950;"
        ],
        "rule_sql": []
    },
    "1087": {
        "db_id": "talkingdata",
        "question": "Please list the categories of the app users who are not active when event no.2 happened.",
        "ground_truth": "SELECT DISTINCT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id INNER JOIN app_events AS T3 ON T2.app_id = T3.app_id WHERE T3.event_id = 2 AND T3.is_active = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT category FROM users WHERE user_id NOT IN (SELECT user_id FROM events WHERE event_id = 2);"
        ],
        "rule_sql": []
    },
    "5980": {
        "db_id": "books",
        "question": "How many books were published by Ace Hardcover?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Ace Hardcover'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher = 'Ace Hardcover';"
        ],
        "rule_sql": []
    },
    "3211": {
        "db_id": "donor",
        "question": "Is teacher \"42d43fa6f37314365d08692e08680973\" a New York teacher?",
        "ground_truth": "SELECT teacher_ny_teaching_fellow end FROM projects WHERE teacher_acctid = '42d43fa6f37314365d08692e08680973'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM teachers WHERE teacher_id = '42d43fa6f37314365d08692e08680973' AND state = 'California';"
        ],
        "rule_sql": []
    },
    "3740": {
        "db_id": "college_completion",
        "question": "Among the black students in 2011, list the institution site and name of those who has 20 t0 30 degree-seeking students in the cohort.",
        "ground_truth": "SELECT DISTINCT T1.site, T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.year = 2011 AND T2.race = 'B' AND T2.grad_cohort BETWEEN 20 AND 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT institution_site, name \nFROM students \nWHERE race = 'black' \nAND year = 2011 \nAND degree_seeking_students BETWEEN 20 AND 30;"
        ],
        "rule_sql": []
    },
    "5165": {
        "db_id": "address",
        "question": "Among the postal points in the District of Columbia, how many of them have an area with above 20000 black population?",
        "ground_truth": "SELECT COUNT(T1.zip_code) FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.county = 'DISTRICT OF COLUMBIA' AND T2.black_population > 20000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM postal_points WHERE district = 'Columbia' AND black_population > 20000;"
        ],
        "rule_sql": []
    },
    "4713": {
        "db_id": "disney",
        "question": "List all the main characters of the movie that are comedy genre.",
        "ground_truth": "SELECT T2.hero FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T1.genre = 'Comedy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM movies WHERE genre = 'comedy';"
        ],
        "rule_sql": []
    },
    "7797": {
        "db_id": "hockey",
        "question": "Which Minnesota North Stars' goalkeeper had the most Goal Againsts in his play time?",
        "ground_truth": "SELECT playerID FROM Goalies AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T2.name = 'Minnesota North Stars' GROUP BY T1.playerID ORDER BY SUM(T1.GA) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, MAX(goals_against) as most_goals_against \nFROM goalkeepers \nWHERE team = 'Minnesota North Stars' \nGROUP BY player_name \nORDER BY most_goals_against DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2969": {
        "db_id": "shakespeare",
        "question": "When did Shakespeare write the first poem?",
        "ground_truth": "SELECT MIN(Date) FROM works WHERE GenreType = 'Poem'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(birth_date) FROM authors WHERE name = 'Shakespeare';"
        ],
        "rule_sql": []
    },
    "2854": {
        "db_id": "professional_basketball",
        "question": "Among the teams that were ranked 3 from 1937 to 1940, what is the team name whose players had the highest point?",
        "ground_truth": "SELECT DISTINCT T1.name FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.rank = 3 AND T1.year BETWEEN 1937 AND 1940 ORDER BY T2.points DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name \nFROM teams \nWHERE rank = 3 \nAND year BETWEEN 1937 AND 1940 \nORDER BY points DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9025": {
        "db_id": "bike_share_1",
        "question": "List down the trip IDs when bike no. 10 was used by subscribers and the weather's mean temperature is no less than 62 degress Fahrenheit.",
        "ground_truth": "SELECT T1.id FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T1.bike_id = 10 AND T2.mean_temperature_f > 62 AND T1.subscription_type = 'Subscriber'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT trip_id FROM trips WHERE bike_id = 10 AND user_type = 'Subscriber' AND weather_mean_temp >= 62"
        ],
        "rule_sql": []
    },
    "9068": {
        "db_id": "bike_share_1",
        "question": "Among the bike trips started on the days with a fog in 2013, how many of those trips started from the station \"2nd at Townsend\"?",
        "ground_truth": "SELECT COUNT(T1.start_station_name) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.date LIKE '%2013%' AND T2.events = 'Fog' AND T1.start_station_name = '2nd at Townsend' AND T2.zip_code = 94107",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM bike_trips bt\nJOIN weather w ON DATE(bt.start_time) = w.date\nWHERE w.weather_condition = 'fog'\nAND YEAR(bt.start_time) = 2013\nAND bt.start_station = '2nd at Townsend';"
        ],
        "rule_sql": []
    },
    "3900": {
        "db_id": "public_review_platform",
        "question": "How many businesses ID sell beer and wine?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business_Attributes WHERE attribute_id = 1 AND attribute_value = 'beer_and_wine'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE beer = 'yes' OR wine = 'yes';"
        ],
        "rule_sql": []
    },
    "7024": {
        "db_id": "works_cycles",
        "question": "What is the total profit all transactions with product ID 827?",
        "ground_truth": "SELECT SUM((T1.ListPrice - T1.StandardCost) * T2.Quantity) FROM Product AS T1 INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductID = 827",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price * quantity) FROM transactions WHERE product_id = 827;"
        ],
        "rule_sql": []
    },
    "7166": {
        "db_id": "works_cycles",
        "question": "What is the number of State Province of France that doesn't have a State Province Code?",
        "ground_truth": "SELECT T1.CountryRegionCode FROM StateProvince AS T1 INNER JOIN CountryRegion AS T2 ON T1.CountryRegionCode = T2.CountryRegionCode WHERE T2.Name = 'France' AND T1.IsOnlyStateProvinceFlag = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM StateProvinces WHERE Country = 'France' AND StateProvinceCode IS NULL;"
        ],
        "rule_sql": []
    },
    "7914": {
        "db_id": "world",
        "question": "Provide the language used in the country ruled by Pierre Buyoya.",
        "ground_truth": "SELECT T1.Language FROM CountryLanguage AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.HeadOfState = 'Pierre Buyoya'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE ruler = 'Pierre Buyoya';"
        ],
        "rule_sql": []
    },
    "8126": {
        "db_id": "university",
        "question": "Calculate number of male students in Emory University in 2011.",
        "ground_truth": "SELECT CAST((T1.num_students - (T1.num_students * T1.pct_female_students)) AS REAL) / 100 FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T2.university_name = 'Emory University' AND T1.year = 2011",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND university = 'Emory University' AND year = 2011;"
        ],
        "rule_sql": []
    },
    "4899": {
        "db_id": "legislator",
        "question": "What is the official full name of the current legislator whose current official Facebook presence is \"senjoniernst\"?",
        "ground_truth": "SELECT T1.official_full_name FROM current AS T1 INNER JOIN `social-media` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.facebook = 'senjoniernst'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name FROM legislators WHERE facebook = 'senjoniernst' AND current = 1;"
        ],
        "rule_sql": []
    },
    "6282": {
        "db_id": "coinmarketcap",
        "question": "Name the coins that have three tags.",
        "ground_truth": "SELECT name FROM coins WHERE LENGTH(tag_names) - LENGTH(replace(tag_names, ',', '')) = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM coins WHERE tag_count = 3;"
        ],
        "rule_sql": []
    },
    "2655": {
        "db_id": "regional_sales",
        "question": "How many online sales were made in May 2018 where products were shipped from Norman?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.OrderDate LIKE '5/%/18' AND T1.`Sales Channel` = 'Online' AND T2.`City Name` = 'Norman' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM online_sales WHERE shipping_city = 'Norman' AND sale_date LIKE '2018-05%';"
        ],
        "rule_sql": []
    },
    "6672": {
        "db_id": "retails",
        "question": "Which order has a higher priority, order no. 4 or order no. 36?",
        "ground_truth": "SELECT l_orderkey FROM lineitem WHERE l_orderkey IN (4, 36) ORDER BY l_shipdate DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_no, priority FROM orders WHERE order_no IN (4, 36) ORDER BY priority DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8813": {
        "db_id": "food_inspection",
        "question": "How many establishments with the tax code H24 have complaint inspections of 5 or more?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.business_id FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.tax_code = 'H24' AND T1.type = 'Complaint' GROUP BY T1.business_id HAVING COUNT(T1.business_id) > 5 ) T3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM establishments WHERE tax_code = 'H24' AND complaint_inspections >= 5;"
        ],
        "rule_sql": []
    },
    "2550": {
        "db_id": "app_store",
        "question": "Which apps have been reviewed more than 75 000 000 times and the content is suitable for teenagers?",
        "ground_truth": "SELECT DISTINCT App FROM playstore WHERE Reviews > 75000000 AND `Content Rating` = 'Teen'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name FROM apps WHERE reviews > 75000000 AND content_rating = 'Teen'"
        ],
        "rule_sql": []
    },
    "6909": {
        "db_id": "retails",
        "question": "What is the name of the country of the supplier with the highest debt?",
        "ground_truth": "SELECT T2.n_name FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey ORDER BY T1.s_suppkey DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM suppliers ORDER BY debt DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7335": {
        "db_id": "works_cycles",
        "question": "State the employee who are born in or after 1970 and with the least sick leave hour.",
        "ground_truth": "SELECT T2.FirstName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T1.BirthDate) > '1970' ORDER BY T1.SickLeaveHours LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM employees WHERE birth_year >= 1970 ORDER BY sick_leave_hours ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5529": {
        "db_id": "menu",
        "question": "How long has the \"Clear Green Turtle\" dish appeared on the menu, and tell me when its latest update was?",
        "ground_truth": "SELECT T1.last_appeared - T1.first_appeared, T2.updated_at FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Clear green turtle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name, date_added, last_updated FROM menu_items WHERE dish_name = 'Clear Green Turtle'"
        ],
        "rule_sql": []
    },
    "1464": {
        "db_id": "synthea",
        "question": "Please provide the dates on which Elly Koss was immunized with the influenza seasonal injectable preservative-free vaccine.",
        "ground_truth": "SELECT T2.DATE FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Influenza  seasonal  injectable  preservative free' AND T1.first = 'Elly' AND T1.last = 'Koss'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT immunization_date FROM immunizations WHERE patient_name = 'Elly Koss' AND vaccine_type = 'influenza seasonal injectable preservative-free'"
        ],
        "rule_sql": []
    },
    "5944": {
        "db_id": "books",
        "question": "What is the title of the first book that was published in 1900?",
        "ground_truth": "SELECT title FROM book WHERE STRFTIME('%Y', publication_date) = '1900' ORDER BY publication_date LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE published_year = 1900 ORDER BY title LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7603": {
        "db_id": "image_and_language",
        "question": "What is the most common object class of image ID 56?",
        "ground_truth": "SELECT T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.IMG_ID = 56 GROUP BY T2.OBJ_CLASS ORDER BY COUNT(T2.OBJ_CLASS_ID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class FROM images WHERE image_id = 56 GROUP BY object_class ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1340": {
        "db_id": "law_episode",
        "question": "What is the episode rating with the most award won?",
        "ground_truth": "SELECT T1.rating FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T2.result = 'Winner' GROUP BY T1.episode_id ORDER BY COUNT(T2.award_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating, COUNT(award_id) as award_count \nFROM episodes \nGROUP BY rating \nORDER BY award_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8608": {
        "db_id": "chicago_crime",
        "question": "Where is the coordinate (41.66236555, -87.63470194) located? Give the name of the district.",
        "ground_truth": "SELECT T2.district_name FROM Crime AS T1 INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE T1.longitude = '-87.63470194' AND T1.latitude = '41.66236555'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district_name FROM coordinates WHERE latitude = 41.66236555 AND longitude = -87.63470194"
        ],
        "rule_sql": []
    },
    "6765": {
        "db_id": "retails",
        "question": "Calculate the percentage of part supply that costs more than 500.",
        "ground_truth": "SELECT CAST(SUM(IIF(ps_supplycost > 500, 1, 0)) AS REAL) * 100 / COUNT(ps_suppkey) FROM partsupp",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM parts)) AS percentage FROM parts WHERE cost > 500;"
        ],
        "rule_sql": []
    },
    "8568": {
        "db_id": "software_company",
        "question": "In male customers ages from 30 to 50, how many of them has an income ranges from 2000 to 2300?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T1.SEX = 'Male' AND T1.age >= 30 AND T1.age <= 50 AND T2.INCOME_K >= 2000 AND T2.INCOME_K <= 2300",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE gender = 'male' AND age BETWEEN 30 AND 50 AND income BETWEEN 2000 AND 2300;"
        ],
        "rule_sql": []
    },
    "357": {
        "db_id": "retail_complains",
        "question": "Which product received the most complaints from elder clients?",
        "ground_truth": "SELECT T2.Product FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.age > 65 ORDER BY T1.client_id DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, COUNT(*) AS complaint_count\nFROM complaints\nWHERE client_age > 65\nGROUP BY product_name\nORDER BY complaint_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7539": {
        "db_id": "image_and_language",
        "question": "On image no. 20, identify the attribute ID that is composed of the highest number of objects.",
        "ground_truth": "SELECT ATT_CLASS_ID FROM IMG_OBJ_ATT WHERE IMG_ID = 20 GROUP BY ATT_CLASS_ID ORDER BY COUNT(ATT_CLASS_ID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT attribute_id FROM images WHERE image_no = 20 ORDER BY COUNT(objects) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "49": {
        "db_id": "movie_platform",
        "question": "What is the average rating score of the 'Pavee Lackeen: The Traveller Girl' movie and what year was it released?",
        "ground_truth": "SELECT AVG(T1.rating_score), T2.movie_release_year FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Pavee Lackeen: The Traveller Girl'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) as average_rating, release_year \nFROM movies \nWHERE title = 'Pavee Lackeen: The Traveller Girl'"
        ],
        "rule_sql": []
    },
    "7035": {
        "db_id": "works_cycles",
        "question": "Who is the company's highest-paid single female employee? Include her full name and job title.",
        "ground_truth": "SELECT T3.FirstName, T3.MiddleName, T3.LastName, T1.JobTitle FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE T1.MaritalStatus = 'S' AND T1.Gender = 'F' ORDER BY T2.Rate DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, job_title FROM employees WHERE gender = 'Female' ORDER BY salary DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5972": {
        "db_id": "books",
        "question": "In books authored by Abraham Lincoln, what is the percentage of the books published in 1992?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', T1.publication_date) = '1992' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Abraham Lincoln'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN year = 1992 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM books\nWHERE author = 'Abraham Lincoln';"
        ],
        "rule_sql": []
    },
    "6054": {
        "db_id": "books",
        "question": "How many orders have been cancelled in 2022?",
        "ground_truth": "SELECT COUNT(*) FROM order_status AS T1 INNER JOIN order_history AS T2 ON T1.status_id = T2.status_id WHERE T1.status_value = 'Cancelled' AND STRFTIME('%Y', T2.status_date) = '2022'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE status = 'cancelled' AND order_date LIKE '2021%';"
        ],
        "rule_sql": []
    },
    "1676": {
        "db_id": "restaurant",
        "question": "List by its ID number all restaurants on 11th Street in Oakland.",
        "ground_truth": "SELECT id_restaurant FROM location WHERE city = 'oakland' AND street_name = '11th street'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT restaurant_id FROM restaurants WHERE street = '11th Street' AND city = 'Oakland';"
        ],
        "rule_sql": []
    },
    "3252": {
        "db_id": "donor",
        "question": "Which school district was Future Einsteins Of America project located at?",
        "ground_truth": "SELECT T1.school_district FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T2.title LIKE 'Future Einsteins Of America'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM schools WHERE project_name = 'Future Einsteins Of America';"
        ],
        "rule_sql": []
    },
    "5178": {
        "db_id": "address",
        "question": "Which city has the most bad aliases?",
        "ground_truth": "SELECT T2.city FROM avoid AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code GROUP BY T1.bad_alias ORDER BY COUNT(T1.zip_code) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as bad_alias_count FROM aliases WHERE alias_type = 'bad' GROUP BY city ORDER BY bad_alias_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2007": {
        "db_id": "soccer_2016",
        "question": "How old is SC Ganguly in 2008?",
        "ground_truth": "SELECT 2008 - strftime('%Y', DOB) FROM Player WHERE Player_Name = 'SC Ganguly'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT 2008 - birth_year AS age FROM players WHERE name = 'SC Ganguly';"
        ],
        "rule_sql": []
    },
    "8172": {
        "db_id": "sales_in_weather",
        "question": "Show the sea level status recorded by the weather station of store no.19 on 2013/2/24.",
        "ground_truth": "SELECT T1.sealevel FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T1.`date` = '2013-02-24' AND T2.store_nbr = 19",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sea_level FROM weather_stations WHERE store_id = 19 AND date = '2013/2/24';"
        ],
        "rule_sql": []
    },
    "3234": {
        "db_id": "donor",
        "question": "Is the donor of the project 'Calculate, Financial Security For Tomorrow Starts Today! ' a teacher?",
        "ground_truth": "SELECT T2.is_teacher_acct FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.title LIKE 'Calculate, Financial Security For Tomorrow Starts Today! '",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM donors WHERE project_name = 'Calculate, Financial Security For Tomorrow Starts Today!' AND occupation = 'teacher';"
        ],
        "rule_sql": []
    },
    "1702": {
        "db_id": "restaurant",
        "question": "What does the one and only 24-hour diner's name?",
        "ground_truth": "SELECT label FROM generalinfo WHERE food_type = '24 hour diner'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM diners WHERE hours = '24 hours' LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3742": {
        "db_id": "college_completion",
        "question": "List the race of institutions in Alabama with number of students greater than the 90% of average number of students of all institutions?",
        "ground_truth": "SELECT DISTINCT T2.race FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.student_count > ( SELECT AVG(T1.student_count) * 0.9 FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.state = 'Alabama' ) AND T1.state = 'Alabama'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT race, COUNT(*) as count\nFROM institutions\nWHERE state = 'Alabama' \nAND num_students > (SELECT AVG(num_students) * 0.9 FROM institutions)\nGROUP BY race;"
        ],
        "rule_sql": []
    },
    "5070": {
        "db_id": "olympics",
        "question": "Give the NOC code and region name of the heaviest competitor.",
        "ground_truth": "SELECT T1.noc, T1.region_name FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id ORDER BY T3.weight DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT NOC, region FROM competitors ORDER BY weight DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4860": {
        "db_id": "legislator",
        "question": "State all the Facebook ID for current legislators under the democrat party.",
        "ground_truth": "SELECT T2.facebook_id FROM `current-terms` AS T1 INNER JOIN `social-media` AS T2 ON T1.bioguide = T2.bioguide WHERE T1.party = 'Democrat' GROUP BY T2.facebook_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT facebook_id FROM legislators WHERE party = 'democrat' AND current = 1;"
        ],
        "rule_sql": []
    },
    "344": {
        "db_id": "retail_complains",
        "question": "What is the full name of client whose email address is emily.garcia43@outlook.com?",
        "ground_truth": "SELECT first, middle, last FROM client WHERE email = 'emily.garcia43@outlook.com'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE email = 'emily.garcia43@outlook.com';"
        ],
        "rule_sql": []
    },
    "4909": {
        "db_id": "legislator",
        "question": "Give the type and start date of the term of the legislator born on November 26, 1727.",
        "ground_truth": "SELECT T2.type, T2.start FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.birthday_bio = '1727-11-26'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, start_date FROM terms WHERE legislator_id IN (SELECT id FROM legislators WHERE birth_date = '1727-11-26')"
        ],
        "rule_sql": []
    },
    "1397": {
        "db_id": "synthea",
        "question": "How many Black patients were immunized with DTaP in 2013?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T1.race = 'black' AND T2.DESCRIPTION = 'DTaP' AND strftime('%Y', T2.DATE) = '2013'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE race = 'Black' AND immunization = 'DTaP' AND year = 2013;"
        ],
        "rule_sql": []
    },
    "2909": {
        "db_id": "professional_basketball",
        "question": "How many awards were given out in 2010 to players who attended high school in Chicago?",
        "ground_truth": "SELECT COUNT(T1.award) FROM awards_players AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE T1.year = 2010 AND T2.hsCity = 'Chicago'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE year = 2010 AND high_school_city = 'Chicago';"
        ],
        "rule_sql": []
    },
    "4247": {
        "db_id": "simpson_episodes",
        "question": "Which episode of The simpson 20s: Season 20 has received the most nominations? Indicate the title.",
        "ground_truth": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id GROUP BY T1.episode_id ORDER BY COUNT(*) DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE season = 20 ORDER BY nominations DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9067": {
        "db_id": "bike_share_1",
        "question": "How many docks were left at the end station for trip ID4069?",
        "ground_truth": "SELECT SUM(T2.docks_available) FROM trip AS T1 INNER JOIN status AS T2 ON T2.station_id = T1.end_station_id WHERE T1.ID = 4069",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM docks WHERE station_id = (SELECT end_station_id FROM trips WHERE trip_id = 4069)"
        ],
        "rule_sql": []
    },
    "999": {
        "db_id": "computer_student",
        "question": "In total, all the students in the 3rd year of their program are advised by how many professors?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.p_id_dummy) FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.yearsInProgram = 'Year_3'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE year = 3;"
        ],
        "rule_sql": []
    },
    "6714": {
        "db_id": "retails",
        "question": "How many suppliers are from Japan?",
        "ground_truth": "SELECT COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'JAPAN'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE country = 'China';"
        ],
        "rule_sql": []
    },
    "9048": {
        "db_id": "bike_share_1",
        "question": "How many trips in 2013 had durations longer than 1000 seconds?",
        "ground_truth": "SELECT COUNT(duration) FROM trip WHERE start_date LIKE '%/%/2013%' AND duration > 1000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trips WHERE year = 2013 AND duration > 1000;"
        ],
        "rule_sql": []
    },
    "6809": {
        "db_id": "retails",
        "question": "Please name any three parts that have an available quantity of more than 9998.",
        "ground_truth": "SELECT T1.p_name FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE T2.ps_availqty > 9998 LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT part_name FROM parts WHERE quantity > 9998 LIMIT 3;"
        ],
        "rule_sql": []
    },
    "5570": {
        "db_id": "menu",
        "question": "Please list the names of all the dishes on page 1 of menu ID12882.",
        "ground_truth": "SELECT T3.name FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE T1.menu_id = 12882 AND T1.page_number = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM dishes WHERE menu_id = 12882 AND page_number = 1;"
        ],
        "rule_sql": []
    },
    "1035": {
        "db_id": "computer_student",
        "question": "How many courses were taught by a professor who is currently the member of faculty?",
        "ground_truth": "SELECT COUNT(*) FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id WHERE T1.professor = 1 AND T1.hasPosition <> 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE professor_id IN (SELECT professor_id FROM faculty WHERE current_member = 1);"
        ],
        "rule_sql": []
    },
    "6506": {
        "db_id": "retail_world",
        "question": "In 1996, how many orders were from customers in the UK?",
        "ground_truth": "SELECT COUNT(T1.CustomerID) FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', T2.OrderDate) = '1996' AND T1.Country = 'UK'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE order_date LIKE '1996%' AND customer_country = 'UK';"
        ],
        "rule_sql": []
    },
    "1850": {
        "db_id": "soccer_2016",
        "question": "How many cities are located in South Africa?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Country_Name = 'South Africa' THEN 1 ELSE 0 END) FROM City AS T1 INNER JOIN Country AS T2 ON T2.Country_Id = T1.Country_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country = 'South Africa';"
        ],
        "rule_sql": []
    },
    "7419": {
        "db_id": "works_cycles",
        "question": "Which employee has been in the Engineering Department the longest? Please give his or her firstname and lastname.",
        "ground_truth": "SELECT T1.FirstName, T1.LastName FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T3.Name = 'Engineering' ORDER BY T2.EndDate - T2.StartDate DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT firstname, lastname FROM employees WHERE department = 'Engineering' ORDER BY hire_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4346": {
        "db_id": "simpson_episodes",
        "question": "What are the keywords of the episodes which have the air date in 2008?",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keywords FROM episodes WHERE air_date LIKE '%2008%';"
        ],
        "rule_sql": []
    },
    "3397": {
        "db_id": "video_games",
        "question": "What is the average number of games published by a publisher?",
        "ground_truth": "SELECT CAST(COUNT(T.game_id) AS REAL) / COUNT(DISTINCT T.publisher_id) FROM game_publisher AS T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(*)) FROM games GROUP BY publisher_id;"
        ],
        "rule_sql": []
    },
    "1024": {
        "db_id": "computer_student",
        "question": "How many professors teaches no more than two high-level or harder undergraduate courses?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT COUNT(T2.p_id) FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE T1.courseLevel = 'Level_400' GROUP BY T2.p_id HAVING COUNT(DISTINCT T1.course_id) <= 2 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM professors p\nWHERE (\n    SELECT COUNT(*) \n    FROM courses c \n    WHERE c.professor_id = p.id \n    AND c.level IN ('high', 'harder')\n    AND c.type = 'undergraduate'\n) <= 2;"
        ],
        "rule_sql": []
    },
    "7570": {
        "db_id": "image_and_language",
        "question": "What is the prediction class between object class 'chain' and 'label' in image 2360078?",
        "ground_truth": "SELECT DISTINCT T2.PRED_CLASS FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T2.PRED_CLASS_ID = T1.PRED_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T1.IMG_ID = T3.IMG_ID AND T1.OBJ1_SAMPLE_ID = T3.OBJ_SAMPLE_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE T1.IMG_ID = 2360078 AND T1.OBJ1_SAMPLE_ID = 15 OR T1.OBJ2_SAMPLE_ID = 18",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT prediction_class FROM predictions WHERE image_id = 2360078 AND object_class IN ('chain', 'label')"
        ],
        "rule_sql": []
    },
    "7681": {
        "db_id": "hockey",
        "question": "What is the percentage of American players among all the players who have gotten in the Hall of Fame?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.birthCountry = 'USA' THEN T1.playerID ELSE NULL END) AS REAL) * 100 / COUNT(T1.playerID) FROM Master AS T1 INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HallOfFame)) AS percentage\nFROM HallOfFame h\nJOIN Players p ON h.playerID = p.playerID\nWHERE p.birthCountry = 'USA';"
        ],
        "rule_sql": []
    },
    "327": {
        "db_id": "retail_complains",
        "question": "How many times does the consumer have no dispute over a non-timely response from the company?",
        "ground_truth": "SELECT COUNT(`Timely response?`) FROM events WHERE `Timely response?` = 'No' AND `Consumer disputed?` = 'No'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE dispute = 'no' AND timely_response = 'no';"
        ],
        "rule_sql": []
    },
    "716": {
        "db_id": "trains",
        "question": "Among the trains running east, how many trains have at least 4 cars?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.direction = 'east' THEN 1 ELSE 0 END)as count FROM trains AS T1 INNER JOIN ( SELECT train_id, COUNT(id) AS carsNum FROM cars GROUP BY train_id ) AS T2 ON T1.id = T2.train_id WHERE T2.carsNum >= 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trains WHERE direction = 'east' AND cars < 4;"
        ],
        "rule_sql": []
    },
    "2392": {
        "db_id": "superstore",
        "question": "Name the customers from the Eastern region whose orders cost above 80000.",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.Region = 'East' AND T1.Sales / (1 - T1.Discount) * T1.Quantity - T1.Profit > 80000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE region = 'Eastern' AND order_cost > 80000;"
        ],
        "rule_sql": []
    },
    "5965": {
        "db_id": "books",
        "question": "List the ISBN of the book published in Spanish.",
        "ground_truth": "SELECT T1.isbn13 FROM book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id WHERE T2.language_name = 'Spanish'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE language = 'Spanish';"
        ],
        "rule_sql": []
    },
    "2593": {
        "db_id": "regional_sales",
        "question": "Mention the most populated city and median income of the store in Florida state.",
        "ground_truth": "SELECT `City Name`, `Median Income` FROM `Store Locations` WHERE State = 'Florida' ORDER BY Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, median_income FROM stores WHERE state = 'Florida' ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8449": {
        "db_id": "mondial_geo",
        "question": "What are the most recent three independent nations?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country ORDER BY T2.Independence DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE independence_year IS NOT NULL ORDER BY independence_year DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "625": {
        "db_id": "codebase_comments",
        "question": "How many percent more of the watchers for the repository of solution No.83855 than No.1502?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Id = 83855 THEN T1.Watchers ELSE 0 END) - SUM(CASE WHEN T2.Id = 1502 THEN T1.Watchers ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T2.Id = 1502 THEN T1.Watchers ELSE 0 END) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    ((w1.watchers - w2.watchers) / w1.watchers) * 100 AS percent_more\nFROM \n    repositories w1,\n    repositories w2\nWHERE \n    w1.solution_id = 83855 \n    AND w2.solution_id = 1502;"
        ],
        "rule_sql": []
    },
    "6093": {
        "db_id": "books",
        "question": "Provide the publisher name of the book with ISBN 76092025986.",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T1.isbn13 = 76092025986",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE isbn = '76092025986';"
        ],
        "rule_sql": []
    },
    "5318": {
        "db_id": "beer_factory",
        "question": "What percentage of customers who paid with a Discover Credit Card gave a 3-star rating?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.StarRating = 3 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.CustomerID) FROM rootbeerreview AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CreditCardType = 'Discover'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN payment_method = 'Discover Credit Card' AND rating = 3 THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN payment_method = 'Discover Credit Card' THEN 1 END)) AS percentage\nFROM customers\nWHERE payment_method = 'Discover Credit Card';"
        ],
        "rule_sql": []
    },
    "6044": {
        "db_id": "books",
        "question": "What percentage of the orders placed by Kaleena were shipped by the international method?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Kaleena'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders WHERE customer_name = 'Kaleena')) AS percentage\nFROM orders \nWHERE customer_name = 'Kaleena' AND shipping_method = 'international';"
        ],
        "rule_sql": []
    },
    "1992": {
        "db_id": "soccer_2016",
        "question": "Among the matches played by Royal Challengers Bangalore, what is the match ID of the match with the highest winning margin?",
        "ground_truth": "SELECT T2.match_id FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner WHERE T1.team_name = 'Royal Challengers Bangalore' AND T2.match_date LIKE '2012%' ORDER BY T2.win_margin DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT match_id FROM matches WHERE team1 = 'Royal Challengers Bangalore' OR team2 = 'Royal Challengers Bangalore' ORDER BY win_margin DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3115": {
        "db_id": "cars",
        "question": "How many cars worth greater than 40000 were from the USA?",
        "ground_truth": "SELECT COUNT(*) FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'USA' AND T1.price > 40000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE price > 40000 AND country = 'USA';"
        ],
        "rule_sql": []
    },
    "2176": {
        "db_id": "world_development_indicators",
        "question": "How many footnotes have been made in year 1980 and what are the table names of these countries that made the footnotes?",
        "ground_truth": "SELECT COUNT(T2.Description) FROM Country AS T1 INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Year = 'YR1980' UNION ALL SELECT DISTINCT T1.TableName FROM Country AS T1 INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Year = 'YR1980'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS footnote_count, country_name \nFROM footnotes \nWHERE year = 1980 \nGROUP BY country_name;"
        ],
        "rule_sql": []
    },
    "5939": {
        "db_id": "books",
        "question": "Give the number of Ukrainian addresses in the database.",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 INNER JOIN address AS T2 ON T1.country_id = T2.country_id WHERE T1.country_name = 'Ukraine'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM addresses WHERE country = 'Ukraine';"
        ],
        "rule_sql": []
    },
    "5801": {
        "db_id": "language_corpus",
        "question": "Which word has the most appearances in the Wikipedia page revision ID No. 28278070? Give the word ID.",
        "ground_truth": "SELECT pid FROM pages_words WHERE pid = ( SELECT pid FROM pages WHERE revision = 28278070 ) ORDER BY occurrences DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id FROM words WHERE page_revision_id = 28278070 ORDER BY appearances DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1081": {
        "db_id": "talkingdata",
        "question": "Among the users who use a Galaxy Note 2, how many of them are female?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T2.gender = 'F' AND T1.device_model = 'Galaxy Note 2'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE device = 'Galaxy Note 2' AND gender = 'male';"
        ],
        "rule_sql": []
    },
    "9342": {
        "db_id": "movie_3",
        "question": "List down all of the film titles that are rated for general audiences.",
        "ground_truth": "SELECT title FROM film WHERE rating = 'G'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE rating = 'G';"
        ],
        "rule_sql": []
    },
    "1348": {
        "db_id": "law_episode",
        "question": "Who played the role of a teleplay in the episode that won \"Best Television Episode\"?",
        "ground_truth": "SELECT T2.name FROM Award AS T1 INNER JOIN Person AS T2 ON T1.person_id = T2.person_id WHERE T1.result = 'Winner' AND T1.award = 'Best Television Episode'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors JOIN episodes ON actors.episode_id = episodes.id WHERE episodes.award = 'Best Television Episode';"
        ],
        "rule_sql": []
    },
    "606": {
        "db_id": "codebase_comments",
        "question": "Give the tokenized name for the method \"Supay.Irc.Messages.KnockMessage.GetTokens\".",
        "ground_truth": "SELECT NameTokenized FROM Method WHERE Name = 'Supay.Irc.Messages.KnockMessage.GetTokens'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT token_name FROM tokens WHERE method_name = 'Supay.Irc.Messages.KnockMessage.GetTokens'"
        ],
        "rule_sql": []
    },
    "1487": {
        "db_id": "synthea",
        "question": "What is the percentage of the most common conditions for patients age 60 and above?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T5.DESCRIPTION = T3.DESCRIPTION THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T3.patient) FROM ( SELECT T2.DESCRIPTION, T1.patient FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE ROUND((strftime('%J', T2.START) - strftime('%J', T1.birthdate)) / 365) > 60 GROUP BY T2.DESCRIPTION ORDER BY COUNT(T2.DESCRIPTION) DESC LIMIT 1 ) AS T3 INNER JOIN patients AS T4 ON T3.patient = T4.patient INNER JOIN conditions AS T5 ON T4.patient = T5.PATIENT WHERE ROUND((strftime('%J', T5.START) - strftime('%J', T4.birthdate)) / 365) > 60",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT condition, COUNT(*) * 100.0 / (SELECT COUNT(*) FROM patients WHERE age >= 60) AS percentage FROM conditions WHERE patient_id IN (SELECT id FROM patients WHERE age >= 60) GROUP BY condition ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4046": {
        "db_id": "public_review_platform",
        "question": "What are the most common compliments types received by user with uber number of fans?",
        "ground_truth": "SELECT DISTINCT T3.compliment_type FROM Users AS T1 INNER JOIN Users_Compliments AS T2 ON T1.user_id = T2.user_id INNER JOIN Compliments AS T3 ON T2.compliment_id = T3.compliment_id WHERE T1.user_fans = 'Uber'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT compliment_type, COUNT(*) as count \nFROM user_compliments \nWHERE user_id = (SELECT user_id FROM users ORDER BY fans DESC LIMIT 1) \nGROUP BY compliment_type \nORDER BY count DESC;"
        ],
        "rule_sql": []
    },
    "2319": {
        "db_id": "movielens",
        "question": "List the movie that has been rated most by 25 years old users.",
        "ground_truth": "SELECT T2.movieid FROM users AS T1 INNER JOIN u2base AS T2 ON T1.userid = T2.userid WHERE T1.age = 25 GROUP BY T2.movieid ORDER BY COUNT(T1.userid) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, COUNT(r.rating) as rating_count\nFROM movies m\nJOIN ratings r ON m.movie_id = r.movie_id\nJOIN users u ON r.user_id = u.user_id\nWHERE u.age = 25\nGROUP BY m.movie_id\nORDER BY rating_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7889": {
        "db_id": "world",
        "question": "What is the district of Zaanstad?",
        "ground_truth": "SELECT District FROM City WHERE name = 'Zaanstad'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM districts WHERE city = 'Zaanstad';"
        ],
        "rule_sql": []
    },
    "4377": {
        "db_id": "student_loan",
        "question": "How many students are unemployed and have payment due?",
        "ground_truth": "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN no_payment_due AS T2 ON T1.`name` = T2.`name`",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed' AND payment_status = 'due';"
        ],
        "rule_sql": []
    },
    "62": {
        "db_id": "movie_platform",
        "question": "What's the description of user 85981819's movie list with the most followers?",
        "ground_truth": "SELECT T1.list_description FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE T1.user_id = 85981819 ORDER BY T1.list_followers DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM movie_lists WHERE user_id = 85981819 ORDER BY followers DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4660": {
        "db_id": "disney",
        "question": "How many PG adventure movies did Ron Clements direct?",
        "ground_truth": "SELECT COUNT(*) FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Ron Clements' AND T2.MPAA_rating = 'PG' AND T2.genre = 'Adventure'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE director = 'Ron Clements' AND rating = 'PG' AND genre = 'Adventure';"
        ],
        "rule_sql": []
    },
    "8222": {
        "db_id": "mondial_geo",
        "question": "State the country and its population with population growth greater than 2% but infant mortality rate less than 5%.",
        "ground_truth": "SELECT T1.Name, T1.Population FROM country AS T1 INNER JOIN population AS T2 ON T1.Code = T2.Country WHERE T2.Population_Growth > 2 AND T2.Infant_Mortality < 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, population FROM countries WHERE population_growth > 2 AND infant_mortality < 5;"
        ],
        "rule_sql": []
    },
    "8633": {
        "db_id": "chicago_crime",
        "question": "How many neighborhoods are there in Near North Side?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.community_area_name = 'Near North Side' THEN 1 ELSE 0 END) FROM Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM neighborhoods WHERE name = 'Near North Side';"
        ],
        "rule_sql": []
    },
    "5466": {
        "db_id": "sales",
        "question": "Of the employees who sold Blade, who has the most amount of sales?",
        "ground_truth": "SELECT T1.FirstName, T1.MiddleInitial, T1.LastName FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID ORDER BY T2.Quantity * T3.Price DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.name, COUNT(*) as sales_count\nFROM employees e\nJOIN sales s ON e.id = s.employee_id\nWHERE s.product = 'Blade'\nGROUP BY e.name\nORDER BY sales_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1010": {
        "db_id": "computer_student",
        "question": "Mention the person ID of faculty professor who taught course ID 104 and the course level.",
        "ground_truth": "SELECT T1.p_id, T3.courseLevel FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE T3.course_id = 104 AND T1.hasPosition <> 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT faculty_id, course_level FROM faculty WHERE course_id = 104 AND professor = 'faculty professor';"
        ],
        "rule_sql": []
    },
    "5356": {
        "db_id": "beer_factory",
        "question": "Which brand in 2012 has the lowest star rating and contains cane sugar as well as honey?",
        "ground_truth": "SELECT DISTINCT T1.BrandName FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T1.CaneSugar = 'TRUE' AND T1.Honey = 'TRUE' AND T2.StarRating = 1 AND T2.ReviewDate LIKE '2012%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand, MIN(star_rating) as lowest_rating \nFROM products \nWHERE year = 2012 \nAND ingredients LIKE '%cane sugar%' \nAND ingredients LIKE '%honey%' \nGROUP BY brand \nORDER BY lowest_rating ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4423": {
        "db_id": "student_loan",
        "question": "How many students enlisted in the fire-department?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'fire_department'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE department = 'police'"
        ],
        "rule_sql": []
    },
    "6858": {
        "db_id": "retails",
        "question": "What is the comment of the product \"burlywood plum powder puff mint\"?",
        "ground_truth": "SELECT p_comment FROM part WHERE p_name = 'burlywood plum powder puff mint'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT comment FROM products WHERE name = 'burlywood plum powder puff mint';"
        ],
        "rule_sql": []
    },
    "4603": {
        "db_id": "mental_health_survey",
        "question": "What was the most common answer for the question \"What country do you work in?\"?",
        "ground_truth": "SELECT T1.AnswerText FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questiontext = 'What country do you work in?' GROUP BY T1.AnswerText ORDER BY COUNT(T1.AnswerText) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT answer, COUNT(*) as count FROM survey_responses WHERE question = 'What country do you work in?' GROUP BY answer ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2797": {
        "db_id": "professional_basketball",
        "question": "Which team(s) has greater than 75% lost among all the games played.",
        "ground_truth": "SELECT name FROM teams WHERE CAST(lost AS REAL) * 100 / games > 75",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, (losses * 100.0 / (wins + losses + ties)) AS loss_percentage \nFROM teams \nWHERE loss_percentage > 75;"
        ],
        "rule_sql": []
    },
    "6701": {
        "db_id": "retails",
        "question": "Which country has the most number of suppliers whose account is in debt?",
        "ground_truth": "SELECT T.n_name FROM ( SELECT T2.n_name, SUM(T1.s_acctbal) AS num FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_acctbal < 0 GROUP BY T2.n_name ) AS T ORDER BY T.num LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as supplier_count FROM suppliers WHERE account_balance > 0 GROUP BY country ORDER BY supplier_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5912": {
        "db_id": "books",
        "question": "Among the books published by publisher ID 1929, how many of them have over 500 pages?",
        "ground_truth": "SELECT COUNT(*) FROM book WHERE publisher_id = 1929 AND num_pages > 500",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher_id = 1929 AND pages > 500;"
        ],
        "rule_sql": []
    },
    "429": {
        "db_id": "movies_4",
        "question": "Provide the most used keyword in the movies.",
        "ground_truth": "SELECT T1.keyword_name FROM keyword AS T1 INNER JOIN movie_keywords AS T2 ON T1.keyword_id = T2.keyword_id GROUP BY T1.keyword_name ORDER BY COUNT(T1.keyword_name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword, COUNT(*) as count FROM movies GROUP BY keyword ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1460": {
        "db_id": "synthea",
        "question": "Write down the Social Security numbers of patients who have latex allergies.",
        "ground_truth": "SELECT T1.ssn FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Latex allergy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_ssn FROM patients WHERE allergy = 'latex'"
        ],
        "rule_sql": []
    },
    "1401": {
        "db_id": "synthea",
        "question": "List the ids of all the patients with condition that has a prevalence percentage of 18.8%.",
        "ground_truth": "SELECT DISTINCT T1.PATIENT FROM conditions AS T1 INNER JOIN all_prevalences AS T2 ON lower(T2.ITEM) = lower(T1.DESCRIPTION) WHERE T2.\"PREVALENCE PERCENTAGE\" = CAST(18.8 AS float)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE prevalence_percentage = 18.8;"
        ],
        "rule_sql": []
    },
    "3182": {
        "db_id": "donor",
        "question": "Which school requested the highest amount of resources from Amazon? State the school's ID.",
        "ground_truth": "SELECT T2.schoolid FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.vendor_name LIKE 'Amazon' GROUP BY T2.schoolid ORDER BY COUNT(T1.vendor_name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_id FROM amazon_requests ORDER BY amount DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "211": {
        "db_id": "book_publishing_company",
        "question": "What is the average quantity of each order for the book \"Life Without Fear\"?",
        "ground_truth": "SELECT CAST(SUM(T2.qty) AS REAL) / COUNT(T1.title_id) FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id WHERE T1.title = 'Life Without Fear'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(quantity) FROM orders WHERE book_title = 'Life Without Fear';"
        ],
        "rule_sql": []
    },
    "619": {
        "db_id": "codebase_comments",
        "question": "Show the solution path for the method \"Mosa.Platform.x86.Instructions.IMul.EmitLegacy\"?",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'Mosa.Platform.x86.Instructions.IMul.EmitLegacy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM methods WHERE name = 'Mosa.Platform.x86.Instructions.IMul.EmitLegacy';"
        ],
        "rule_sql": []
    },
    "9099": {
        "db_id": "bike_share_1",
        "question": "Which station did the user who started at Market at 4th station ended their trip at the time of 12:45:00 PM and the date of 8/29/2013 and what is the location coordinates of the ending station?",
        "ground_truth": "SELECT T1.name, T1.lat, T1.long FROM station AS T1 INNER JOIN trip AS T2 ON T2.end_station_name = T1.name WHERE T2.start_station_name = 'Market at 4th' AND T2.end_date = '8/29/2013 12:45'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT end_station_name, end_station_latitude, end_station_longitude \nFROM trips \nWHERE start_station_name = 'Market at 4th' \nAND start_time = '12:45:00 PM' \nAND start_date = '8/29/2013';"
        ],
        "rule_sql": []
    },
    "319": {
        "db_id": "retail_complains",
        "question": "How did Kyran Muller submit his complaint?",
        "ground_truth": "SELECT DISTINCT T2.`Submitted via` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Kyran' AND T1.last = 'Muller'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT submission_method FROM complaints WHERE name = 'Kyran Muller';"
        ],
        "rule_sql": []
    },
    "129": {
        "db_id": "movie_platform",
        "question": "For the 1998 movie which got the highest popularity, how many \"4\" rating did the movie get?",
        "ground_truth": "SELECT COUNT(T2.movie_title) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.rating_score = 4 AND T2.movie_release_year = 1998 ORDER BY T2.movie_popularity DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM ratings \nWHERE movie_id = (\n    SELECT movie_id \n    FROM movies \n    WHERE year = 1998 \n    ORDER BY popularity DESC \n    LIMIT 1\n) \nAND rating = 4;"
        ],
        "rule_sql": []
    },
    "3212": {
        "db_id": "donor",
        "question": "Please list the titles of projects by which schools in Abington was donated.",
        "ground_truth": "SELECT T2.title FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T1.school_city LIKE 'Abington'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM projects WHERE school = 'Abington' AND donation = 'yes'"
        ],
        "rule_sql": []
    },
    "7154": {
        "db_id": "works_cycles",
        "question": "What are the unit measure codes for product ID No.762?",
        "ground_truth": "SELECT T2.UnitMeasureCode FROM Product AS T1 INNER JOIN UnitMeasure AS T2 ON T1.SizeUnitMeasureCode = T2.UnitMeasureCode OR T1.WeightUnitMeasureCode = T2.UnitMeasureCode WHERE T1.ProductID = 762 GROUP BY T1.ProductID, T2.UnitMeasureCode",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT unit_measure_code FROM products WHERE product_id = 'No.762';"
        ],
        "rule_sql": []
    },
    "7110": {
        "db_id": "works_cycles",
        "question": "Please list the family names of any employees whose middle names begin with C.",
        "ground_truth": "SELECT LastName FROM Person WHERE PersonType = 'EM' AND MiddleName LIKE 'C%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM employees WHERE middle_name LIKE 'C%';"
        ],
        "rule_sql": []
    },
    "2910": {
        "db_id": "professional_basketball",
        "question": "What is the percentage of players who attended Auburn University and won an \"All-Defensive Second Team\" award?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.award = 'All-Defensive Second Team' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM players AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE T1.college = 'Auburn'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN p.college = 'Auburn' AND a.award = 'All-Defensive Second Team' THEN p.player_id END) * 100.0 / \n     COUNT(DISTINCT p.player_id)) AS percentage\nFROM players p\nLEFT JOIN awards a ON p.player_id = a.player_id;"
        ],
        "rule_sql": []
    },
    "5809": {
        "db_id": "language_corpus",
        "question": "Please list the titles of all the Wikipedia pages on the Catalan language with 10 different words.",
        "ground_truth": "SELECT title FROM pages WHERE lid = 1 AND words = 10 LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM wikipedia_pages WHERE language = 'Catalan' GROUP BY title HAVING COUNT(DISTINCT word) = 10;"
        ],
        "rule_sql": []
    },
    "3121": {
        "db_id": "cars",
        "question": "Provide the name, model, sweep volume, and introduced year of the car with the best crash protection.",
        "ground_truth": "SELECT T1.car_name, T1.model, T1.displacement / T1.cylinders, T2.model_year FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID ORDER BY T1.weight DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, model, sweep_volume, introduced_year FROM cars ORDER BY crash_protection DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "686": {
        "db_id": "codebase_comments",
        "question": "How many liked by people does the solution path \"ninject_Ninject\\Ninject.sln\n\" have?",
        "ground_truth": "SELECT DISTINCT T1.Stars FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Path = 'ninject_NinjectNinject.sln'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM solutions WHERE path = 'ninject_Ninject\\Ninject.sln'"
        ],
        "rule_sql": []
    },
    "1150": {
        "db_id": "talkingdata",
        "question": "How many categories in total do the app users who were not active when event no.2 happened belong to?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT COUNT(DISTINCT T1.category) AS result FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id INNER JOIN app_events AS T3 ON T2.app_id = T3.app_id WHERE T3.event_id = 2 AND T3.is_active = 0 GROUP BY T1.category ) T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT category_id) \nFROM users \nWHERE user_id NOT IN (\n    SELECT user_id \n    FROM events \n    WHERE event_id = 2\n)"
        ],
        "rule_sql": []
    },
    "8829": {
        "db_id": "food_inspection",
        "question": "List the inspection dates, scores and inspection types for the eateries with tax code AA.",
        "ground_truth": "SELECT T1.`date`, T1.score, T1.type FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.tax_code = 'AA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_date, score, inspection_type FROM inspections WHERE tax_code = 'AA';"
        ],
        "rule_sql": []
    },
    "8408": {
        "db_id": "mondial_geo",
        "question": "How many rivers belong to more than one country? Name the provinces where we can find them.",
        "ground_truth": "SELECT River, GROUP_CONCAT(Province) FROM geo_river GROUP BY River HAVING COUNT(DISTINCT Country) > 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS river_count, province_name \nFROM rivers \nJOIN countries ON rivers.country_id = countries.id \nGROUP BY province_name \nHAVING COUNT(DISTINCT country_id) > 1;"
        ],
        "rule_sql": []
    },
    "6177": {
        "db_id": "food_inspection_2",
        "question": "List the point IDs and fines of the inspections done on 7th August 2010.",
        "ground_truth": "SELECT T2.point_id, T2.fine FROM inspection AS T1 INNER JOIN violation AS T2 ON T1.inspection_id = T2.inspection_id WHERE T1.inspection_date = '2010-08-07'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT point_id, fine FROM inspections WHERE inspection_date = '2010-08-07';"
        ],
        "rule_sql": []
    },
    "7043": {
        "db_id": "works_cycles",
        "question": "What is the profit of the product with the highest list price and of the product with the lowest list price other than 0? Indicates the depth the component is from its parent.",
        "ground_truth": "SELECT ( SELECT ListPrice - StandardCost FROM Product WHERE ListPrice != 0 ORDER BY ListPrice DESC LIMIT 1 ) , ( SELECT ListPrice - StandardCost FROM Product WHERE ListPrice != 0 ORDER BY ListPrice LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    p1.product_name AS highest_price_product,\n    p1.list_price AS highest_price,\n    p1.profit AS highest_profit,\n    p2.product_name AS lowest_price_product,\n    p2.list_price AS lowest_price,\n    p2.profit AS lowest_profit,\n    c.depth\nFROM products p1\nJOIN products p2 ON p1.product_id = p2.product_id\nJOIN components c ON p1.product_id = c.component_id\nWHERE p1.list_price = (SELECT MAX(list_price) FROM products)\nAND p2.list_price = (SELECT MIN(list_price) FROM products WHERE list_price > 0)\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9244": {
        "db_id": "movie_3",
        "question": "Find the full name and email address of inactive customers whose record was created in 2006.",
        "ground_truth": "SELECT first_name, last_name, email FROM customer WHERE STRFTIME('%Y',create_date) = '2006' AND active = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM customers WHERE status = 'active' AND YEAR(created_date) = 2006;"
        ],
        "rule_sql": []
    },
    "5258": {
        "db_id": "beer_factory",
        "question": "Which customer has the most reviews? State the full name.",
        "ground_truth": "SELECT T1.First, T1.Last FROM customers AS T1 INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.CustomerID ORDER BY COUNT(T2.CustomerID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name \nFROM customers \nORDER BY review_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5232": {
        "db_id": "beer_factory",
        "question": "What is the name of the root beer brand that has the longest history?",
        "ground_truth": "SELECT BrandName FROM rootbeerbrand WHERE FirstBrewedYear = ( SELECT MIN(FirstBrewedYear) FROM rootbeerbrand )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM root_beer_brands ORDER BY history_length DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8318": {
        "db_id": "mondial_geo",
        "question": "What is the average inflation rate of the biggest continent?",
        "ground_truth": "SELECT AVG(T4.Inflation) FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN economy AS T4 ON T4.Country = T3.Code WHERE T1.Name = ( SELECT Name FROM continent ORDER BY Area DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(inflation_rate) FROM countries WHERE continent = (SELECT continent FROM countries GROUP BY continent ORDER BY SUM(area) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "6911": {
        "db_id": "retails",
        "question": "What are the total quantities of the items ordered by customer 101660 on 10/5/1995?",
        "ground_truth": "SELECT SUM(T2.l_quantity) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderdate = '1995-10-05' AND T1.o_custkey = 101660",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM orders WHERE customer_id = 101660 AND order_date = '10/5/1995';"
        ],
        "rule_sql": []
    },
    "2557": {
        "db_id": "app_store",
        "question": "List down app that does not have negative sentiment and give their average rating?",
        "ground_truth": "SELECT T1.App, AVG(T2.Sentiment_Polarity) FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T2.Sentiment != 'Negative' GROUP BY T1.App",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name, AVG(rating) as average_rating \nFROM apps \nWHERE sentiment = 'positive' \nGROUP BY app_name;"
        ],
        "rule_sql": []
    },
    "7111": {
        "db_id": "works_cycles",
        "question": "How many vendors are having their products ordered with an average delivery time of 25 days?",
        "ground_truth": "SELECT COUNT(DISTINCT BusinessEntityID) FROM ProductVendor WHERE AverageLeadTime = 25",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT vendor_id) \nFROM orders \nWHERE delivery_time = 25;"
        ],
        "rule_sql": []
    },
    "8498": {
        "db_id": "mondial_geo",
        "question": "What is the maximal elevation of the summit of the shortest mountain that can be found in the island of Madagaskar? Indicate what type of mountain it is.",
        "ground_truth": "SELECT T3.Height, T3.Type FROM island AS T1 INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Island INNER JOIN mountain AS T3 ON T3.Name = T2.Mountain WHERE T1.Name = 'Madagaskar' ORDER BY T3.Height DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(elevation), mountain_type FROM mountains WHERE country = 'Madagaskar' ORDER BY height ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1536": {
        "db_id": "synthea",
        "question": "What is the care plan description of the prevalent disease with the highest prevalence percentage?",
        "ground_truth": "SELECT T4.DESCRIPTION FROM all_prevalences AS T1 INNER JOIN conditions AS T2 ON T2.DESCRIPTION = T1.ITEM INNER JOIN encounters AS T3 ON T2.ENCOUNTER = T3.ID INNER JOIN careplans AS T4 ON T4.ENCOUNTER = T3.ID ORDER BY T1.\"PREVALENCE PERCENTAGE\" DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT care_plan_description FROM diseases ORDER BY prevalence_percentage DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6078": {
        "db_id": "books",
        "question": "The book name \"The Season: A Candid Look at Broadway\" was published by which publisher?",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T1.title = 'The Season: A Candid Look at Broadway'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM books WHERE title = 'The Season: A Candid Look at Broadway';"
        ],
        "rule_sql": []
    },
    "8183": {
        "db_id": "sales_in_weather",
        "question": "Which weather station does the store that sold the highest quantity of item 9 belongs to?",
        "ground_truth": "SELECT station_nbr FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE T1.item_nbr = 9 GROUP BY T2.station_nbr ORDER BY SUM(T1.units) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ws.station_name\nFROM weather_stations ws\nJOIN stores s ON ws.station_id = s.station_id\nJOIN sales sa ON s.store_id = sa.store_id\nWHERE sa.item_id = 9\nORDER BY sa.quantity DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3588": {
        "db_id": "authors",
        "question": "What is the full name of the journal that published the paper \"Multiple paternity in a natural population of a salamander with long-term sperm storage\"?",
        "ground_truth": "SELECT T2.FullName FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE T1.Title = 'Multiple paternity in a natural population of a salamander with long-term sperm storage'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE paper_title = 'Multiple paternity in a natural population of a salamander with long-term sperm storage'"
        ],
        "rule_sql": []
    },
    "1414": {
        "db_id": "synthea",
        "question": "Among the patients that died, what is the condition of the oldest patient?",
        "ground_truth": "SELECT T1.DESCRIPTION FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.deathdate IS NOT NULL ORDER BY strftime('%Y', T2.deathdate) - strftime('%Y', T2.birthdate) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT condition FROM patients WHERE status = 'died' ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7913": {
        "db_id": "world",
        "question": "What is the life expectancy of the people living in Calama city?",
        "ground_truth": "SELECT T2.LifeExpectancy FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.Name = 'Calama'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM cities WHERE name = 'Calama';"
        ],
        "rule_sql": []
    },
    "6924": {
        "db_id": "ice_hockey_draft",
        "question": "How much taller is David Bornhammar than Pauli Levokari in centimeters?",
        "ground_truth": "SELECT ( SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'David Bornhammar' ) - ( SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'Pauli Levokari' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (David_Bornhammar.height - Pauli_Levokari.height) AS height_difference FROM players WHERE name = 'David Bornhammar' AND name = 'Pauli Levokari';"
        ],
        "rule_sql": []
    },
    "8287": {
        "db_id": "mondial_geo",
        "question": "Where does Bermuda belong to? Give the full name of the country.",
        "ground_truth": "SELECT T3.Name FROM locatedOn AS T1 INNER JOIN island AS T2 ON T1.Island = T2.Name INNER JOIN country AS T3 ON T3.Code = T1.Country WHERE T3.Name = 'Bermuda'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE region = 'Bermuda';"
        ],
        "rule_sql": []
    },
    "918": {
        "db_id": "cs_semester",
        "question": "Name the students of the Advanced Database Systems course with the highest satisfaction.",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Advanced Database Systems' ORDER BY T2.sat DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name \nFROM students s\nJOIN courses c ON s.course_id = c.id\nWHERE c.name = 'Advanced Database Systems'\nORDER BY s.satisfaction ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7768": {
        "db_id": "hockey",
        "question": "Please list the first names of the coaches whose team played in 1922's Stanley Cup finals.",
        "ground_truth": "SELECT T3.firstName FROM Coaches AS T1 INNER JOIN TeamsSC AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.year = 1922",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM coaches WHERE team_id IN (SELECT team_id FROM stanley_cup_finals WHERE year = 1922);"
        ],
        "rule_sql": []
    },
    "2820": {
        "db_id": "professional_basketball",
        "question": "In which league did the player who weighs 40% less than the heaviest player and whose height is 80 inches play?",
        "ground_truth": "SELECT T2.lgID FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID GROUP BY T2.lgID, T1.weight HAVING T1.weight = MAX(T1.weight) - MAX(T1.weight) * 0.4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT league FROM players WHERE weight = (SELECT MAX(weight) * 0.6 FROM players) AND height = 80;"
        ],
        "rule_sql": []
    },
    "1500": {
        "db_id": "synthea",
        "question": "Among all patients who sought medical attention in 2010 due to contact dermatitis, identify the percentage of females.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.PATIENT) FROM encounters AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE strftime('%Y', T1.DATE) = '2010' AND T1.REASONDESCRIPTION = 'Contact dermatitis'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM patients\nWHERE diagnosis = 'contact dermatitis' \nAND year = 2010;"
        ],
        "rule_sql": []
    },
    "7609": {
        "db_id": "image_and_language",
        "question": "Give the X and Y coordinates of the sample object of image ID 23 that has the 'cast' attribute class.",
        "ground_truth": "SELECT T3.OBJ_SAMPLE_ID, T3.X, T3.Y FROM ATT_CLASSES AS T1 INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID WHERE T3.IMG_ID = 23 AND T1.ATT_CLASS = 'cast'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT x_coordinate, y_coordinate FROM samples WHERE image_id = 23 AND attribute_class = 'cast';"
        ],
        "rule_sql": []
    },
    "624": {
        "db_id": "codebase_comments",
        "question": "For the solution of the most 'sw' methods, what is its path?",
        "ground_truth": "SELECT DISTINCT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Lang = 'sw'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path FROM methods WHERE method_name = 'sw' ORDER BY solution_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8614": {
        "db_id": "chicago_crime",
        "question": "Who was the alderman of the legislative district where case No. JB103470 took place? Give the full name.",
        "ground_truth": "SELECT T1.alderman_first_name, T1.alderman_last_name FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.case_number = 'JB103470'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT alderman_name FROM cases WHERE case_no = 'JB103470';"
        ],
        "rule_sql": []
    },
    "3296": {
        "db_id": "donor",
        "question": "How many donations does the project \"Look, Look, We Need a Nook!\" have?",
        "ground_truth": "SELECT SUM(T3.donation_total) FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE T1.title = 'Look, Look, We Need a Nook!'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM donations WHERE project_name = 'Look, Look, We Need a Nook!';"
        ],
        "rule_sql": []
    },
    "1544": {
        "db_id": "car_retails",
        "question": "List the country and how many customers are there.",
        "ground_truth": "SELECT country, COUNT(customerNumber) FROM customers GROUP BY country",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) FROM customers GROUP BY country;"
        ],
        "rule_sql": []
    },
    "1851": {
        "db_id": "soccer_2016",
        "question": "How many matches were held at the venue named \"Newlands\"?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Venue_Name = 'Newlands' THEN 1 ELSE 0 END) FROM Match AS T1 INNER JOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE venue = 'Newlands';"
        ],
        "rule_sql": []
    },
    "4457": {
        "db_id": "student_loan",
        "question": "List all the disabled female students.",
        "ground_truth": "SELECT T1.name FROM disabled AS T1 INNER JOIN male AS T2 ON T1.name <> T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE gender = 'male' AND status = 'active';"
        ],
        "rule_sql": []
    },
    "4898": {
        "db_id": "legislator",
        "question": "For how many terms has current legislator Sherrod Brown served as a representative for district no.13?",
        "ground_truth": "SELECT COUNT(*) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'Sherrod Brown' AND T2.district = 13",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE name = 'Sherrod Brown' AND district = 13 AND chamber = 'representative';"
        ],
        "rule_sql": []
    },
    "5646": {
        "db_id": "shipping",
        "question": "How many customers who live in California that are retailers?",
        "ground_truth": "SELECT COUNT(*) FROM customer WHERE cust_type = 'retailer' AND state = 'CA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE state = 'California' AND customer_type = 'retailer';"
        ],
        "rule_sql": []
    },
    "6783": {
        "db_id": "retails",
        "question": "What is the total price charged for orders shipped by air without shipping instructions?",
        "ground_truth": "SELECT l_extendedprice * (1 - l_discount) * (1 + l_tax) AS totalprice FROM lineitem WHERE l_shipmode = 'AIR' AND l_shipinstruct = 'NONE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE ship_mode = 'air' AND shipping_instructions IS NULL;"
        ],
        "rule_sql": []
    },
    "2933": {
        "db_id": "professional_basketball",
        "question": "Give the player id of the man who had the most turnovers whose team missed the playoffs in year 1988.",
        "ground_truth": "SELECT T2.playerID FROM players_teams AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE T1.PostGP = 0 AND T1.year = 1988 ORDER BY T1.turnovers DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id \nFROM player_stats \nWHERE year = 1988 \nORDER BY turnovers DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4081": {
        "db_id": "public_review_platform",
        "question": "List the user ID, business ID with review length of the business which received the most likes in tips.",
        "ground_truth": "SELECT T1.user_id, T1.business_id, T2.review_length FROM Tips AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id ORDER BY T1.likes DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.user_id, b.business_id, LENGTH(r.text) as review_length\nFROM users u\nJOIN reviews r ON u.user_id = r.user_id\nJOIN businesses b ON r.business_id = b.business_id\nJOIN tips t ON b.business_id = t.business_id\nGROUP BY u.user_id, b.business_id\nORDER BY COUNT(t.likes) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3806": {
        "db_id": "public_review_platform",
        "question": "Please provide the attribute values \u200b\u200bof the bussinesses with fashion in Scottsdale.",
        "ground_truth": "SELECT T2.attribute_value FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T1.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T4.category_name LIKE 'Fashion' AND T1.city LIKE 'Scottsdale'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM businesses WHERE city = 'Scottsdale' AND category = 'fashion';"
        ],
        "rule_sql": []
    },
    "9073": {
        "db_id": "bike_share_1",
        "question": "What is the average duration of a bike trip made on the day with the hottest temperature ever in 2014?",
        "ground_truth": "SELECT AVG(T1.duration) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.date LIKE '%2014%' AND T1.start_station_name = '2nd at Folsom' AND T2.max_temperature_f = ( SELECT max_temperature_f FROM weather ORDER BY max_temperature_f DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM bike_trips WHERE date = (SELECT MAX(temperature) FROM weather WHERE year = 2014);"
        ],
        "rule_sql": []
    },
    "1884": {
        "db_id": "soccer_2016",
        "question": "What is the city of M Chinnaswamy Stadium?",
        "ground_truth": "SELECT T1.City_Name FROM City AS T1 INNER JOIN Venue AS T2 ON T2.City_Id = T1.City_Id WHERE T2.Venue_Name = 'M Chinnaswamy Stadium'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM stadiums WHERE name = 'M Chinnaswamy Stadium';"
        ],
        "rule_sql": []
    },
    "6243": {
        "db_id": "food_inspection_2",
        "question": "Name the taverns that failed the inspection in January 2010.",
        "ground_truth": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE strftime('%Y-%m', T2.inspection_date) = '2010-01' AND T2.results = 'Fail' AND T1.facility_type = 'TAVERN'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM taverns WHERE inspection_date LIKE '2010-01%' AND inspection_result = 'passed';"
        ],
        "rule_sql": []
    },
    "2039": {
        "db_id": "soccer_2016",
        "question": "In the match ID 419135, who won by runs?",
        "ground_truth": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner INNER JOIN Win_By AS T3 ON T2.win_type = T3.win_id WHERE T2.Match_Id = 419135",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner FROM matches WHERE match_id = 419135 AND win_by = 'runs';"
        ],
        "rule_sql": []
    },
    "5147": {
        "db_id": "address",
        "question": "Among the zip code under Saint Croix county, which zip code has the biggest land area?",
        "ground_truth": "SELECT T1.zip_code FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.county = 'SAINT CROIX' ORDER BY T2.land_area DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM zip_codes WHERE county = 'Saint Croix' ORDER BY land_area DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "284": {
        "db_id": "retail_complains",
        "question": "Calculate the average number of complaints received from New Bedford each year which are closed with explanation.",
        "ground_truth": "SELECT STRFTIME('%Y', T3.`Date received`) , CAST(SUM(CASE WHEN T3.`Company response to consumer` = 'Closed with explanation' THEN 1 ELSE 0 END) AS REAL) / COUNT(T3.`Complaint ID`) AS average FROM callcenterlogs AS T1 INNER JOIN client AS T2 ON T1.`rand client` = T2.client_id INNER JOIN events AS T3 ON T1.`Complaint ID` = T3.`Complaint ID` WHERE T2.city = 'New Bedford' GROUP BY strftime('%Y', T3.`Date received`)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT YEAR(received_date) AS year, AVG(complaint_id) AS avg_complaints\nFROM complaints\nWHERE city = 'New Bedford' AND closed_with_explanation = 1\nGROUP BY YEAR(received_date);"
        ],
        "rule_sql": []
    },
    "9153": {
        "db_id": "movie_3",
        "question": "How many actors played a role in the 2006 film whose rental duration is 7 days, rental rate is 4.99 and is 98 minutes duration?",
        "ground_truth": "SELECT COUNT(T1.actor_id) FROM film_actor AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id WHERE T2.release_year = 2006 AND T2.rental_duration = 7 AND T2.rental_duration = 4.99 AND T2.length = 98",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM actor a\nJOIN film_actor fa ON a.actor_id = fa.actor_id\nJOIN film f ON fa.film_id = f.film_id\nWHERE f.release_year = 2006 \nAND f.rental_duration = 7 \nAND f.rental_rate = 4.99 \nAND f.length = 98;"
        ],
        "rule_sql": []
    },
    "7181": {
        "db_id": "works_cycles",
        "question": "What is the stocked quantity of products manufactured from location ID 40?",
        "ground_truth": "SELECT COUNT(*) FROM WorkOrderRouting AS T1 INNER JOIN BillOfMaterials AS T2 ON T1.LocationID = T2.ProductAssemblyID INNER JOIN WorkOrder AS T3 ON T3.WorkOrderID = T1.WorkOrderID WHERE T1.LocationID = 40",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM products WHERE location_id = 40;"
        ],
        "rule_sql": []
    },
    "5428": {
        "db_id": "sales",
        "question": "Among the products with product ID lower than 15, how many of them costs 10 and below?",
        "ground_truth": "SELECT COUNT(ProductID) FROM Products WHERE ProductID < 15 AND Price <= 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE product_id < 15 AND price <= 10;"
        ],
        "rule_sql": []
    },
    "8732": {
        "db_id": "chicago_crime",
        "question": "What is the general and specific description of incident 275?",
        "ground_truth": "SELECT primary_description, secondary_description FROM IUCR WHERE iucr_no = 275",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM incidents WHERE incident_id = 275;"
        ],
        "rule_sql": []
    },
    "3703": {
        "db_id": "college_completion",
        "question": "Which institute has the highest percentage of male White students graduating in 2011 within 150 percent of normal/expected time?",
        "ground_truth": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.year = 2011 AND T2.gender = 'M' AND T2.race = 'W' AND T2.grad_150 = ( SELECT MAX(T2.grad_150) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.year = 2011 AND T2.gender = 'M' AND T2.race = 'W' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT INSTNM, \n       (SUM(C150_4_MALE_WHITE) / SUM(C150_4_MALE_TOTAL)) * 100 AS male_white_percentage\nFROM graduation_rates\nWHERE YEAR = 2011\nGROUP BY INSTNM\nORDER BY male_white_percentage DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3142": {
        "db_id": "cars",
        "question": "What years did the Buick Skylark 320 get in production?",
        "ground_truth": "SELECT T2.model_year FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T1.car_name = 'buick skylark 320'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM production WHERE model = 'Buick Skylark 320'"
        ],
        "rule_sql": []
    },
    "7": {
        "db_id": "movie_platform",
        "question": "What is the percentage of the ratings were rated by user who was a subcriber?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN user_subscriber = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM ratings",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.subscriber = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM ratings r\nJOIN users u ON r.user_id = u.user_id;"
        ],
        "rule_sql": []
    },
    "4060": {
        "db_id": "public_review_platform",
        "question": "Among the working days from Monday to Saturday, which businesses with the category names work the most days?",
        "ground_truth": "SELECT T2.category_name FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id GROUP BY T2.category_name ORDER BY COUNT(T3.day_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category_name, COUNT(DISTINCT day_of_week) as days_worked\nFROM businesses b\nJOIN business_hours bh ON b.business_id = bh.business_id\nWHERE day_of_week IN ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday')\nGROUP BY category_name\nORDER BY days_worked DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3585": {
        "db_id": "authors",
        "question": "What was the topic of the article \"A Formal Approach to Service Component Architecture\" and when was it published?",
        "ground_truth": "SELECT Keyword, Year FROM Paper WHERE Title = 'A Formal Approach to Service Component Architecture'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT topic, published_date FROM articles WHERE title = 'A Formal Approach to Service Component Architecture';"
        ],
        "rule_sql": []
    },
    "1695": {
        "db_id": "restaurant",
        "question": "Identify all the restaurants in Marin County by their id.",
        "ground_truth": "SELECT T1.id_restaurant FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T2.county = 'marin county'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM restaurants WHERE county = 'Marin';"
        ],
        "rule_sql": []
    },
    "1446": {
        "db_id": "synthea",
        "question": "How many of the patients who have stopped taking medication for 'coronary heart disease' are still alive?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.patient) FROM medications AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.REASONDESCRIPTION = 'Coronary Heart Disease' AND T1.STOP IS NOT NULL AND T2.deathdate IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN medications m ON p.patient_id = m.patient_id\nWHERE m.medication_name = 'coronary heart disease' \nAND m.status = 'stopped'\nAND p.status = 'alive';"
        ],
        "rule_sql": []
    },
    "8280": {
        "db_id": "mondial_geo",
        "question": "What is the area of Egypt as a percentage of Asia?",
        "ground_truth": "SELECT T2.Percentage FROM country AS T1 INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent WHERE T3.Name = 'Asia' AND T1.Name = 'Egypt'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (Egypt.area / Asia.area) * 100 AS percentage FROM countries Egypt, continents Asia WHERE Egypt.name = 'Egypt' AND Asia.name = 'Asia';"
        ],
        "rule_sql": []
    },
    "7520": {
        "db_id": "image_and_language",
        "question": "List all the explanations about object classes of all the images with an x and y coordinate of 0.",
        "ground_truth": "SELECT T1.OBJ_CLASS FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.X = 0 AND T2.Y = 0 GROUP BY T1.OBJ_CLASS",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT explanation FROM images WHERE x = 0 OR y = 0;"
        ],
        "rule_sql": []
    },
    "8874": {
        "db_id": "cookbook",
        "question": "How many calories from fat are there in the recipe \"Raspberry Chiffon Pie\"?",
        "ground_truth": "SELECT T2.calories * T2.pcnt_cal_fat FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Raspberry Chiffon Pie'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT calories FROM recipes WHERE name = 'Raspberry Chiffon Pie';"
        ],
        "rule_sql": []
    },
    "5108": {
        "db_id": "address",
        "question": "What are the top 3 states with the highest Asian population? List the full names of all the representatives in the said states.",
        "ground_truth": "SELECT t.state, T1.first_name, T1.last_name FROM zip_data AS T INNER JOIN congress AS T1 ON t.state = T1.abbreviation GROUP BY t.state ORDER BY SUM(t.asian_population) DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.name, s.state_name \nFROM representatives r\nJOIN states s ON r.state_id = s.id\nWHERE s.asian_population IN (\n    SELECT asian_population \n    FROM states \n    ORDER BY asian_population DESC \n    LIMIT 3\n)\nORDER BY s.asian_population DESC;"
        ],
        "rule_sql": []
    },
    "1122": {
        "db_id": "talkingdata",
        "question": "Give the time stamp for event No.887711.",
        "ground_truth": "SELECT timestamp FROM events WHERE event_id = '887711'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_time FROM events WHERE event_id = 887711"
        ],
        "rule_sql": []
    },
    "9164": {
        "db_id": "movie_3",
        "question": "How much money did the customer No.297 pay for the rental which happened at 12:27:27 on 2005/7/28?",
        "ground_truth": "SELECT T1.amount FROM payment AS T1 INNER JOIN rental AS T2 ON T1.rental_id = T2.rental_id WHERE T2.rental_date = '2005-07-28 12:27:27' AND T2.customer_id = 297",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT amount FROM payment WHERE customer_id = 297 AND rental_date = '2005-07-28 12:27:27';"
        ],
        "rule_sql": []
    },
    "2463": {
        "db_id": "shooting",
        "question": "In which year has the greatest number of cases where Handgun was used as weapon?",
        "ground_truth": "SELECT STRFTIME('%Y', date) FROM incidents WHERE subject_weapon = 'Handgun' GROUP BY STRFTIME('%Y', date) ORDER BY COUNT(case_number) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as case_count \nFROM cases \nWHERE weapon = 'Handgun' \nGROUP BY year \nORDER BY case_count ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "626": {
        "db_id": "codebase_comments",
        "question": "How many percent more of the stars for the repository of solution No.51424 than No.167053?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Id = 51424 THEN T1.Stars ELSE 0 END) - SUM(CASE WHEN T2.Id = 167053 THEN T1.Stars ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T2.Id = 167053 THEN T1.Stars ELSE 0 END) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    ((s1.stars - s2.stars) / s2.stars) * 100 AS percentage_more\nFROM \n    solutions s1,\n    solutions s2\nWHERE \n    s1.id = 51424 \n    AND s2.id = 167053;"
        ],
        "rule_sql": []
    },
    "6061": {
        "db_id": "books",
        "question": "Who is the author of First Things First?",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T1.title = 'First Things First'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE author = 'First Things First';"
        ],
        "rule_sql": []
    },
    "5385": {
        "db_id": "sales",
        "question": "Sum up the number sales ids handled by employees called Morningstar, Heather and Dean.",
        "ground_truth": "SELECT SUM(IIF(T2.FirstName = 'Morningstar', 1, 0)) + SUM(IIF(T2.FirstName = 'Heather', 1, 0)) + SUM(IIF(T2.FirstName = 'Dean', 1, 0)) AS num FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(sales_id) FROM sales WHERE employee_name IN ('Morningstar', 'Heather', 'Dean')"
        ],
        "rule_sql": []
    },
    "4365": {
        "db_id": "simpson_episodes",
        "question": "In episodes aired in 2009, how many of them are credited to Sam Im for additional timer?",
        "ground_truth": "SELECT COUNT(*) FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.credited = 'true' AND T2.person = 'Sam Im' AND SUBSTR(T1.air_date, 1, 4) = '2009' AND T2.role = 'additional timer';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE year = 2009 AND additional_timer = 'Sam Im'"
        ],
        "rule_sql": []
    },
    "2980": {
        "db_id": "shakespeare",
        "question": "Give the description for the Act No.2, Scene No.2 of Midsummer Night's Dream.",
        "ground_truth": "SELECT T2.Description FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Act = '2' AND T2.Scene = '2' AND T1.Title = 'Midsummer Night''s Dream'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM scenes WHERE act_number = 2 AND scene_number = 2 AND play_title = 'Midsummer Night\\'s Dream';"
        ],
        "rule_sql": []
    },
    "4493": {
        "db_id": "student_loan",
        "question": "How many unemployed students filed for bankruptcy?",
        "ground_truth": "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN filed_for_bankrupcy AS T2 ON T2.name = T1.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed' AND bankruptcy_status = 'filed';"
        ],
        "rule_sql": []
    },
    "9148": {
        "db_id": "movie_3",
        "question": "State the number of films that are 178 minutes long.",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE length = '178'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE duration = '178 minutes';"
        ],
        "rule_sql": []
    },
    "5898": {
        "db_id": "airline",
        "question": "List the air carrier's description of the flights with 0 departure delay.",
        "ground_truth": "SELECT T1.Description FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T2.DEP_DELAY = 0 GROUP BY T1.Description",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM flights WHERE departure_delay = 0;"
        ],
        "rule_sql": []
    },
    "4045": {
        "db_id": "public_review_platform",
        "question": "What is the percentage of user not becoming an elite user?",
        "ground_truth": "SELECT CAST((( SELECT COUNT(user_id) FROM Users ) - ( SELECT COUNT(DISTINCT user_id) FROM Elite )) AS REAL) * 100 / ( SELECT COUNT(user_id) FROM Users )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) - COUNT(elite_years)) * 100.0 / COUNT(*) AS percentage_not_elite\nFROM users;"
        ],
        "rule_sql": []
    },
    "3821": {
        "db_id": "public_review_platform",
        "question": "What percentage of businesses are in the Real Estate sector and have the rating of 5 out of all businesses in Chandler?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.stars = 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) AS \"percentage\" FROM Business AS T1 INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE T1.city LIKE 'Chandler' AND T3.category_name LIKE 'Real Estate'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN sector = 'Real Estate' AND rating = 5 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM businesses\nWHERE city = 'Chandler';"
        ],
        "rule_sql": []
    },
    "7633": {
        "db_id": "hockey",
        "question": "What is the average height of player who were born in 1990 and after? Compare the average height with players who were born before 1990.",
        "ground_truth": "SELECT AVG(IIF(birthYear < 1990, height, NULL)) - AVG(IIF(birthYear >= 1990, height, NULL)) FROM Master",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    AVG(CASE WHEN birth_year >= 1990 THEN height ELSE NULL END) AS avg_height_after_1990,\n    AVG(CASE WHEN birth_year < 1990 THEN height ELSE NULL END) AS avg_height_before_1990\nFROM players\nWHERE birth_year IS NOT NULL AND height IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "969": {
        "db_id": "computer_student",
        "question": "List all the course IDs for professional or master/graduate courses.",
        "ground_truth": "SELECT course_id FROM course WHERE courseLevel = 'Level_500'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id FROM courses WHERE level = 'professional' OR level = 'master' OR level = 'graduate';"
        ],
        "rule_sql": []
    },
    "3988": {
        "db_id": "public_review_platform",
        "question": "How many businesses in Tempe are rated as 'Wonderful experience?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE city = 'Phoenix' AND stars > 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Tempe' AND rating = 'Wonderful experience';"
        ],
        "rule_sql": []
    },
    "5499": {
        "db_id": "menu",
        "question": "On the menu with the most dishes, how many dishes were there on its second page?",
        "ground_truth": "SELECT COUNT(T1.dish_id) FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id WHERE T2.page_number = 2 GROUP BY T3.name ORDER BY T3.dish_count DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM dishes WHERE menu_id = (SELECT menu_id FROM dishes GROUP BY menu_id ORDER BY COUNT(*) DESC LIMIT 1) AND page_number = 2;"
        ],
        "rule_sql": []
    },
    "939": {
        "db_id": "cs_semester",
        "question": "Among students with low salary, how many of them have a gpa of 3.5?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T2.gpa = 3.5 AND T1.salary = 'low'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE salary < 50000 AND gpa = 3.5;"
        ],
        "rule_sql": []
    },
    "1270": {
        "db_id": "law_episode",
        "question": "Calculate the average number of cast members that appeared in the credit from the 185th to the 193rd episode.",
        "ground_truth": "SELECT CAST(COUNT(T1.episode_id) AS REAL) / (193 - 185 + 1) FROM Credit AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.category = 'Cast' AND T1.credited = 'true' AND T2.number_in_series BETWEEN 185 AND 193",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(cast_member_id)) FROM credits WHERE episode_id BETWEEN 185 AND 193 GROUP BY episode_id"
        ],
        "rule_sql": []
    },
    "2370": {
        "db_id": "superstore",
        "question": "List 5 customers in the West region who had their item shipped 'Second Class.'",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.Region = 'West' AND T1.`Ship Mode` = 'Second Class' LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE region = 'West' AND shipping = 'Second Class' LIMIT 5;"
        ],
        "rule_sql": []
    },
    "7164": {
        "db_id": "works_cycles",
        "question": "How many types of tax did the sales happen in Quebec have?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Name) FROM SalesTaxRate AS T1 INNER JOIN StateProvince AS T2 ON T1.StateProvinceID = T2.StateProvinceID WHERE T2.Name = 'Quebec'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE province = 'Quebec';"
        ],
        "rule_sql": []
    },
    "5997": {
        "db_id": "books",
        "question": "How many addresses are from the Philippines?",
        "ground_truth": "SELECT COUNT(T2.country_id) FROM address AS T1 INNER JOIN country AS T2 ON T2.country_id = T1.country_id WHERE T2.country_name = 'Philippines'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM addresses WHERE country = 'Philippines';"
        ],
        "rule_sql": []
    },
    "5929": {
        "db_id": "books",
        "question": "How many orders has Cordy Dumbarton made?",
        "ground_truth": "SELECT COUNT(*) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'Cordy' AND T1.last_name = 'Dumbarton'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Cordy Dumbarton';"
        ],
        "rule_sql": []
    },
    "6678": {
        "db_id": "retails",
        "question": "Please give the name of the customer who has made the single order with the highest total price.",
        "ground_truth": "SELECT T2.c_name FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey ORDER BY T1.o_totalprice DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY order_total DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1489": {
        "db_id": "synthea",
        "question": "How old was Mr. Stacy Morar at the time of his first emergency room admission due to a drug overdose?",
        "ground_truth": "SELECT T2.DATE - T1.birthdate AS age FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Stacy' AND T1.last = 'Morar' AND T2.DESCRIPTION = 'Emergency Room Admission' AND T2.REASONDESCRIPTION = 'Drug overdose' ORDER BY T2.DATE LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM patients WHERE name = 'Stacy Morar' AND admission_reason = 'drug overdose' ORDER BY admission_date LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1267": {
        "db_id": "law_episode",
        "question": "How many episodes did J.K. Simmons' role appear on the show?",
        "ground_truth": "SELECT COUNT(T1.role) FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T2.name = 'J.K. Simmons'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE actor_name = 'J.K. Simmons';"
        ],
        "rule_sql": []
    },
    "66": {
        "db_id": "movie_platform",
        "question": "How many users liked the movie \"A Way of Life\" to the highest extent?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'A Way of Life' AND T1.rating_score = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE movie_title = 'A Way of Life' AND rating = 5;"
        ],
        "rule_sql": []
    },
    "1362": {
        "db_id": "synthea",
        "question": "For how many times had Elly Koss have her Systolic Blood Pressure observed?",
        "ground_truth": "SELECT COUNT(T2.description) FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description = 'Systolic Blood Pressure'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM observations WHERE patient_name = 'Elly Koss' AND observation_type = 'Systolic Blood Pressure';"
        ],
        "rule_sql": []
    },
    "1911": {
        "db_id": "soccer_2016",
        "question": "How many first teams chose to bat after winning the toss?",
        "ground_truth": "SELECT COUNT(Team_1) FROM `Match` WHERE Team_1 = Toss_Winner AND Toss_Decide = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE toss_decision = 'bat' AND team_type = 'first';"
        ],
        "rule_sql": []
    },
    "6140": {
        "db_id": "food_inspection_2",
        "question": "What is the assumed name of the business located at 2903 W Irving Park Rd?",
        "ground_truth": "SELECT DISTINCT dba_name FROM establishment WHERE address = '2903 W IRVING PARK RD '",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_name FROM businesses WHERE address = '2903 W Irving Park Rd';"
        ],
        "rule_sql": []
    },
    "5736": {
        "db_id": "language_corpus",
        "question": "Please list any three Wikipedia pages with more than 300 words.",
        "ground_truth": "SELECT page FROM pages WHERE words > 300 LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM wikipedia_pages WHERE word_count > 300 LIMIT 3;"
        ],
        "rule_sql": []
    },
    "2576": {
        "db_id": "regional_sales",
        "question": "List all the customers with name containing the word 'Group'.",
        "ground_truth": "SELECT T FROM ( SELECT IIF(`Customer Names` LIKE '%Group%', `Customer Names`, NULL) AS T FROM Customers ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE name LIKE '%Group%';"
        ],
        "rule_sql": []
    },
    "608": {
        "db_id": "codebase_comments",
        "question": "For the repository which got '8094' Stars, how many solutions does it contain?",
        "ground_truth": "SELECT COUNT(T2.RepoId) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Stars = 8094",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM repositories WHERE stars = 8094;"
        ],
        "rule_sql": []
    },
    "4598": {
        "db_id": "mental_health_survey",
        "question": "How many users participated in the Survey No.2016?",
        "ground_truth": "SELECT COUNT(DISTINCT UserID) FROM Answer WHERE SurveyID LIKE 2016",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE survey_id = 2016;"
        ],
        "rule_sql": []
    },
    "4790": {
        "db_id": "legislator",
        "question": "Among the legislators who will end in 2009, how many are from the Republican party?",
        "ground_truth": "SELECT `END`, party FROM `current-terms` WHERE STRFTIME('%Y', `END`) = '2009' AND party = 'Republican'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE end_year = 2009 AND party = 'Democrat';"
        ],
        "rule_sql": []
    },
    "99": {
        "db_id": "movie_platform",
        "question": "Please list the names of the movies that user 94978 scored as 5.",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.rating_score = 5 AND T1.user_id = 94978",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_name FROM movies WHERE user_id = 94978 AND score = 5;"
        ],
        "rule_sql": []
    },
    "5916": {
        "db_id": "books",
        "question": "What is the name of the publisher that has published the most number of books?",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id GROUP BY T2.publisher_name ORDER BY COUNT(T1.book_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name FROM publishers ORDER BY publisher_id DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6972": {
        "db_id": "ice_hockey_draft",
        "question": "List the names of all players in team Avangard Omsk in season 2000-2001.",
        "ground_truth": "SELECT DISTINCT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '2000-2001' AND T1.TEAM = 'Avangard Omsk'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE team = 'Avangard Omsk' AND season = '2000-2001';"
        ],
        "rule_sql": []
    },
    "6252": {
        "db_id": "coinmarketcap",
        "question": "For all transactions for WRAP in August 2016, list the time to achieve highest price and the time to achieve the lowest price.",
        "ground_truth": "SELECT T2.time_high, T2.time_low, T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'WARP' AND STRFTIME('%Y-%m', T2.date) = '2016-08'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    MAX(time) as highest_price_time,\n    MIN(time) as lowest_price_time\nFROM transactions\nWHERE symbol = 'WRAP' \nAND strftime('%Y-%m', time) = '2016-08'\nGROUP BY symbol"
        ],
        "rule_sql": []
    },
    "553": {
        "db_id": "movies_4",
        "question": "Which genre does the movie Dancer in the Dark belong to?",
        "ground_truth": "SELECT T3.genre_name FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE T1.title = 'Dancer in the Dark'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM movies WHERE title = 'Dancer in the Dark';"
        ],
        "rule_sql": []
    },
    "2075": {
        "db_id": "music_tracker",
        "question": "Among the artists with the id from 10 to 30. Which artist released the product with the tag \"funk\" in 1980?",
        "ground_truth": "SELECT T1.artist FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'funk' AND T1.groupYear = 1980 AND T1.id BETWEEN 10 AND 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM artists WHERE artist_id BETWEEN 10 AND 30 AND tag = 'funk' AND year = 1980;"
        ],
        "rule_sql": []
    },
    "3748": {
        "db_id": "college_completion",
        "question": "In Yale University, what is the average number of Black students per year who were bachelor's/equivalent-seeking cohort at 4-year institutions between 2002 to 2005?",
        "ground_truth": "SELECT AVG(T2.grad_cohort) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.chronname = 'Yale University' AND T2.year BETWEEN 2002 AND 2005 AND T2.race = 'B' AND T2.cohort = '4y bach'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(Black) FROM enrollment WHERE Institution = 'Yale University' AND Year BETWEEN 2002 AND 2005 AND Level = 'Bachelor'"
        ],
        "rule_sql": []
    },
    "3736": {
        "db_id": "college_completion",
        "question": "What is the institution's name of american students within the number of degree-seeking students in the cohort that ranges from 1 to 3?",
        "ground_truth": "SELECT DISTINCT T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.grad_cohort BETWEEN 1 AND 3 AND T2.race = 'Ai'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT institution_name FROM students WHERE nationality = 'American' AND degree_seeking_students BETWEEN 1 AND 3;"
        ],
        "rule_sql": []
    },
    "5355": {
        "db_id": "beer_factory",
        "question": "How many purchases were made at Sac State American River Courtyard using Master Card?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM `transaction` AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.LocationName = 'Sac State American River Courtyard' AND T1.CreditCardType = 'MasterCard'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM purchases WHERE location = 'Sac State American River Courtyard' AND card_type = 'MasterCard';"
        ],
        "rule_sql": []
    },
    "4392": {
        "db_id": "student_loan",
        "question": "List all students in the air force and which school they were enrolled at.",
        "ground_truth": "SELECT T1.name, T1.school FROM enrolled AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'air_force'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.name, s.branch, e.school_name FROM students s JOIN enrollments e ON s.id = e.student_id WHERE s.branch = 'Navy';"
        ],
        "rule_sql": []
    },
    "346": {
        "db_id": "retail_complains",
        "question": "List down the email of client whose complaint is type \"PS\".",
        "ground_truth": "SELECT T1.email FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T2.type = 'PS'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM clients WHERE complaint_type = 'PS';"
        ],
        "rule_sql": []
    },
    "8204": {
        "db_id": "sales_in_weather",
        "question": "How many units of item 7 have been sold by store 7 when the snow is less than 5 inches?",
        "ground_truth": "SELECT SUM(units) FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr INNER JOIN sales_in_weather AS T3 ON T2.store_nbr = T3.store_nbr WHERE T2.store_nbr = 7 AND T3.item_nbr = 7 AND T1.snowfall < 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(units_sold) FROM sales WHERE item_id = 7 AND store_id = 7 AND snow < 5;"
        ],
        "rule_sql": []
    },
    "7827": {
        "db_id": "world",
        "question": "List the languages used in Turkmenistan.",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'Turkmenistan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE name = 'Turkmenistan';"
        ],
        "rule_sql": []
    },
    "4777": {
        "db_id": "legislator",
        "question": "Which party does Christopher Henderson Clark belong to?",
        "ground_truth": "SELECT T1.party FROM `historical-terms` AS T1 INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE T2.first_name OR T2.middle_name OR T2.last_name = 'ChristopherHendersonClark'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party FROM politicians WHERE name = 'Christopher Henderson Clark';"
        ],
        "rule_sql": []
    },
    "2474": {
        "db_id": "shooting",
        "question": "From the 'Injured' statuses of the subject, what is the ratio of weapons used are knife against handgun?",
        "ground_truth": "SELECT CAST(SUM(T1.subject_weapon = 'Knife') AS REAL) * 100 / SUM(T1.subject_weapon = 'Handgun') FROM incidents AS T1 INNER JOIN subjects AS T2 ON T1.case_number = T2.case_number WHERE T1.subject_statuses = 'Injured'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS knife_count FROM statuses WHERE status = 'Injured' AND weapon = 'knife';"
        ],
        "rule_sql": []
    },
    "5725": {
        "db_id": "language_corpus",
        "question": "How many total occurrences are there in the three-letter words?",
        "ground_truth": "SELECT SUM(occurrences) FROM words WHERE LENGTH(word) = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE LENGTH(word) = 3 AND occurrence > 1;"
        ],
        "rule_sql": []
    },
    "5613": {
        "db_id": "shipping",
        "question": "How many shipments with weight of no more than 1,000 pounds were shipped by the oldest truck?",
        "ground_truth": "SELECT COUNT(*) FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.weight < 1000 ORDER BY T1.model_year ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM shipments s\nJOIN trucks t ON s.truck_id = t.truck_id\nWHERE s.weight <= 1000\nORDER BY t.manufacture_year ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5074": {
        "db_id": "olympics",
        "question": "What is the season of the game where a competitor who weighted 73 kg and 180 cm tall, participated?",
        "ground_truth": "SELECT DISTINCT T1.season FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.height = 180 AND T3.weight = 73",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT season FROM games JOIN competitors ON games.game_id = competitors.game_id WHERE weight = 73 AND height = 180;"
        ],
        "rule_sql": []
    },
    "5526": {
        "db_id": "menu",
        "question": "What dishes made their first and last appearances in 1855 and 1900, respectively?",
        "ground_truth": "SELECT name FROM Dish WHERE first_appeared = 1855 AND last_appeared = 1900",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name, MIN(year) as first_appearance, MAX(year) as last_appearance \nFROM dishes \nWHERE first_appearance = 1855 AND last_appearance = 1900 \nGROUP BY dish_name;"
        ],
        "rule_sql": []
    },
    "6655": {
        "db_id": "retail_world",
        "question": "List out the full name of employee who has birth day on \"3/4/1955 12:00:00 AM\".",
        "ground_truth": "SELECT FirstName, LastName FROM Employees WHERE BirthDate = '1955-03-04 00:00:00'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE birth_date = '3/4/1955 12:00:00 AM';"
        ],
        "rule_sql": []
    },
    "4153": {
        "db_id": "citeseer",
        "question": "Find the words cited in papers that are cited by sima01computational?",
        "ground_truth": "SELECT DISTINCT T2.word_cited_id FROM cites AS T1 INNER JOIN content AS T2 ON T1.cited_paper_id = T2.paper_id WHERE T1.citing_paper_id = 'sima01computational'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT w.word \nFROM words w \nJOIN citations c ON w.paper_id = c.paper_id \nJOIN papers p ON c.cited_paper_id = p.paper_id \nWHERE p.author = 'sima01computational';"
        ],
        "rule_sql": []
    },
    "7483": {
        "db_id": "image_and_language",
        "question": "How many pairs of object samples in image no.1 have the relation of \"parked on\"?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.PRED_CLASS = 'parked on' THEN 1 ELSE 0 END) FROM PRED_CLASSES AS T1 INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T2.IMG_ID = 1 AND T2.OBJ1_SAMPLE_ID != OBJ2_SAMPLE_ID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM relations WHERE image_id = 1 AND relation_type = 'parked on';"
        ],
        "rule_sql": []
    },
    "425": {
        "db_id": "movies_4",
        "question": "Show the total number of keywords of the movie \"I Hope They Serve Beer in Hell\".",
        "ground_truth": "SELECT COUNT(T2.keyword_id) FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id WHERE T1.title = 'I Hope They Serve Beer in Hell'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE title = 'I Hope They Serve Beer in Hell';"
        ],
        "rule_sql": []
    },
    "5707": {
        "db_id": "language_corpus",
        "question": "What is the title of corpus with most words?",
        "ground_truth": "SELECT title FROM pages WHERE words = ( SELECT MAX(words) FROM pages )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM corpus ORDER BY word_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5406": {
        "db_id": "sales",
        "question": "Name the customers who received 'Touring Rim' as a free gift.",
        "ground_truth": "SELECT DISTINCT T1.FirstName, T1.MiddleInitial, T1.LastName FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T3.Name = 'Touring Rim' AND T3.Price = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE free_gift = 'Touring Rim';"
        ],
        "rule_sql": []
    },
    "7245": {
        "db_id": "works_cycles",
        "question": "Compare the average pay rate of male and female employees.",
        "ground_truth": "SELECT AVG(T2.Rate) FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID GROUP BY T1.Gender",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, AVG(pay_rate) as average_pay FROM employees GROUP BY gender WHERE gender IN ('Male', 'Female')"
        ],
        "rule_sql": []
    },
    "1553": {
        "db_id": "car_retails",
        "question": "Of all the classic cars, with a product scale of 1:18, which product is the most ordered product by customers?",
        "ground_truth": "SELECT T1.productName FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode WHERE T1.productScale = '1:18' AND T1.productLine = 'Classic Cars' GROUP BY T1.productName ORDER BY SUM(T2.quantityOrdered) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT productName, COUNT(*) as orderCount \nFROM products \nWHERE productScale = '1:18' \nGROUP BY productName \nORDER BY orderCount DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1803": {
        "db_id": "soccer_2016",
        "question": "What is the average winning margin of all the matches SC Ganguly has played in?",
        "ground_truth": "SELECT CAST(SUM(T3.Win_Margin) AS REAL) / COUNT(*) FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id WHERE T1.Player_Name = 'SC Ganguly'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(winning_margin) FROM matches WHERE player_name = 'SC Ganguly';"
        ],
        "rule_sql": []
    },
    "8863": {
        "db_id": "cookbook",
        "question": "What is the unsaturated fat content in the recipe \"Raspberry Chiffon Pie\"?",
        "ground_truth": "SELECT T2.total_fat - T2.sat_fat FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Raspberry Chiffon Pie'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT saturated_fat FROM recipes WHERE name = 'Raspberry Chiffon Pie';"
        ],
        "rule_sql": []
    },
    "5878": {
        "db_id": "airline",
        "question": "How many flights from Charlotte Douglas International Airport to Austin - Bergstrom International Airport experienced serious reasons that cause flight cancellation?",
        "ground_truth": "SELECT COUNT(*) FROM Airlines AS T1 INNER JOIN Airports AS T2 ON T1.ORIGIN = T2.Code WHERE T1.ORIGIN = 'CLT' AND T1.DEST = 'AUS' AND T2.Description = 'Charlotte, NC: Charlotte Douglas International' AND T1.CANCELLATION_CODE = 'A'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM flights f\nJOIN airports a1 ON f.origin_airport_id = a1.airport_id\nJOIN airports a2 ON f.destination_airport_id = a2.airport_id\nWHERE a1.airport_name = 'Charlotte Douglas International Airport'\nAND a2.airport_name = 'Austin - Bergstrom International Airport'\nAND f.cancellation_reason = 'weather'"
        ],
        "rule_sql": []
    },
    "6711": {
        "db_id": "retails",
        "question": "In which country do most of the customers come from?",
        "ground_truth": "SELECT T.n_name FROM ( SELECT T2.n_name, COUNT(T1.c_custkey) AS num FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey GROUP BY T2.n_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as customer_count FROM customers GROUP BY country ORDER BY customer_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7594": {
        "db_id": "image_and_language",
        "question": "Calculate the average number of images with an attribute class of \"keyboard\".",
        "ground_truth": "SELECT AVG(T1.IMG_ID) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'keyboard'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(image_id) FROM images WHERE attribute_class = 'keyboard';"
        ],
        "rule_sql": []
    },
    "1885": {
        "db_id": "soccer_2016",
        "question": "List down all of the venues in Mumbai.",
        "ground_truth": "SELECT T2.Venue_Name FROM City AS T1 INNER JOIN Venue AS T2 ON T2.City_Id = T1.City_Id WHERE T1.City_Name = 'Mumbai'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM venues WHERE city = 'Delhi';"
        ],
        "rule_sql": []
    },
    "349": {
        "db_id": "retail_complains",
        "question": "List down the full name of clients who have disputed the response from company.",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Consumer disputed?` = 'Yes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE disputed_response = 'yes';"
        ],
        "rule_sql": []
    },
    "7499": {
        "db_id": "image_and_language",
        "question": "How many samples of food object are there in image no.6?",
        "ground_truth": "SELECT COUNT(T2.OBJ_SAMPLE_ID) FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.IMG_ID = 6 AND T1.OBJ_CLASS = 'food'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM samples WHERE image_id = 6 AND object_type = 'food';"
        ],
        "rule_sql": []
    },
    "8597": {
        "db_id": "chicago_crime",
        "question": "Among all the crimes that had happened in Central Chicago, how many of them were cases of domestic violence?",
        "ground_truth": "SELECT COUNT(*) FROM Crime AS T1 INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE T2.district_name = 'Central' AND T1.domestic = 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM crimes \nWHERE district = 'Central Chicago' \nAND crime_type = 'domestic violence';"
        ],
        "rule_sql": []
    },
    "4927": {
        "db_id": "olympics",
        "question": "Which sport does the event \"Shooting Women's Trap\" belong to?",
        "ground_truth": "SELECT T1.sport_name FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T2.event_name LIKE 'Shooting Women%s Trap'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sport FROM events WHERE event_name = 'Shooting Women\\'s Trap';"
        ],
        "rule_sql": []
    },
    "2637": {
        "db_id": "regional_sales",
        "question": "In 2020, what were the total orders of all stores in Maricopa County?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.County = 'Maricopa County' AND OrderDate LIKE '%/%/20' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(orders) FROM stores WHERE county = 'Maricopa' AND year = 2020;"
        ],
        "rule_sql": []
    },
    "4373": {
        "db_id": "student_loan",
        "question": "Among the students that have filed for bankruptcy, how many of them have been absent from school for over 5 months?",
        "ground_truth": "SELECT COUNT(T1.name) FROM filed_for_bankrupcy AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.`name` = T2.`name` WHERE T2.`month` > 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE bankruptcy_filed = 1 AND absences > 5;"
        ],
        "rule_sql": []
    },
    "4677": {
        "db_id": "disney",
        "question": "Which of the movies directed by Ron Clements has the highest total gross?",
        "ground_truth": "SELECT T2.movie_title FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Ron Clements' ORDER BY CAST(REPLACE(trim(T2.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MAX(total_gross) FROM movies WHERE director = 'Ron Clements'"
        ],
        "rule_sql": []
    },
    "6745": {
        "db_id": "retails",
        "question": "Give the phone number of the customer with the highest account balance.",
        "ground_truth": "SELECT c_phone FROM customer ORDER BY c_acctbal DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers ORDER BY account_balance DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1077": {
        "db_id": "talkingdata",
        "question": "How many events have happened on device no.29182687948017100 in 2016?",
        "ground_truth": "SELECT COUNT(event_id) FROM `events` WHERE SUBSTR(`timestamp`, 1, 4) = '2016' AND device_id = 29182687948017100",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE device_id = 29182687948017100 AND year = 2016;"
        ],
        "rule_sql": []
    },
    "660": {
        "db_id": "codebase_comments",
        "question": "What is the percentage of solutions for the method that needs to be compiled in the English methods?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.WasCompiled = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Lang) FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Lang = 'en'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN m.needs_compilation = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM methods m\nWHERE m.language = 'English';"
        ],
        "rule_sql": []
    },
    "6379": {
        "db_id": "retail_world",
        "question": "What is the full name of the employee who handled the highest amount of orders?",
        "ground_truth": "SELECT T1.FirstName, T1.LastName FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID GROUP BY T1.FirstName, T1.LastName ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.first_name, e.last_name\nFROM employees e\nJOIN orders o ON e.employee_id = o.employee_id\nGROUP BY e.employee_id\nORDER BY COUNT(o.order_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2957": {
        "db_id": "shakespeare",
        "question": "Which work is the character Lord Abergavenny from? Please give its short or abbreviated title.",
        "ground_truth": "SELECT DISTINCT T1.Title FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T4.CharName = 'Lord Abergavenny'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM works WHERE character = 'Lord Abergavenny';"
        ],
        "rule_sql": []
    },
    "8471": {
        "db_id": "mondial_geo",
        "question": "State the area and population of the country where Asia Pacific Economic Cooperation headquarter is located.",
        "ground_truth": "SELECT T2.Name, T2.Population FROM organization AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T1.Name = 'Asia Pacific Economic Cooperation'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area, population FROM countries WHERE headquarters = 'Asia Pacific Economic Cooperation';"
        ],
        "rule_sql": []
    },
    "8270": {
        "db_id": "mondial_geo",
        "question": "Which religion has the largest population in Martinique?",
        "ground_truth": "SELECT T2.Name FROM country AS T1 INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Martinique' ORDER BY T1.population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT religion, MAX(population) FROM population_data WHERE country = 'Martinique' GROUP BY religion ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7888": {
        "db_id": "world",
        "question": "What is the GNP growth rate by the country of Shanghai?",
        "ground_truth": "SELECT CAST((T1.GNP - T1.GNPOld) AS REAL) / T1.GNPOld FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Shanghai'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, GNP_growth_rate FROM countries WHERE city = 'Shanghai';"
        ],
        "rule_sql": []
    },
    "8059": {
        "db_id": "university",
        "question": "Provide the universities which got the highest scores.",
        "ground_truth": "SELECT T1.university_name FROM university AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id GROUP BY T1.university_name ORDER BY SUM(T2.score) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_name FROM universities ORDER BY score ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8562": {
        "db_id": "software_company",
        "question": "In geographic identifier from 10 to 30, how many of them has an income below 2000?",
        "ground_truth": "SELECT COUNT(GEOID) FROM Demog WHERE INCOME_K < 2000 AND GEOID >= 10 AND GEOID <= 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM geographic_identifiers WHERE id BETWEEN 10 AND 30 AND income > 2000;"
        ],
        "rule_sql": []
    },
    "5381": {
        "db_id": "sales",
        "question": "What is the full name of customers who dealt with sales person with id 5?",
        "ground_truth": "SELECT T1.FirstName, T1.MiddleInitial, T1.LastName FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.SalesPersonID = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE sales_person_id = 5;"
        ],
        "rule_sql": []
    },
    "3803": {
        "db_id": "public_review_platform",
        "question": "Please list the businesses name with a rating less than 5 whose category name is men's clothing.",
        "ground_truth": "SELECT T2.business_id FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name LIKE 'Men''s Clothing' AND T3.stars < 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_name FROM businesses WHERE rating < 5 AND category = \"men's clothing\";"
        ],
        "rule_sql": []
    },
    "1416": {
        "db_id": "synthea",
        "question": "What is the glucose level of the patient that lives at 365 Della Crossroad Suite 202, Deerfield, MA 01342 US?",
        "ground_truth": "SELECT DISTINCT T2.DESCRIPTION, T2.VALUE, T2.UNITS FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Glucose' AND T1.address = '365 Della Crossroad Suite 202 Deerfield MA 01342 US'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT glucose_level FROM patients WHERE address = '365 Della Crossroad Suite 202, Deerfield, MA 01342 US';"
        ],
        "rule_sql": []
    },
    "130": {
        "db_id": "movie_platform",
        "question": "From all the movies that got more than 13000 popularity number, which one had the least ratings.",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_popularity > 13000 ORDER BY T1.rating_score LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MIN(popularity) FROM movies WHERE ratings > 13000;"
        ],
        "rule_sql": []
    },
    "2582": {
        "db_id": "regional_sales",
        "question": "Name the most expensive ordered? Who, when was it ordered?",
        "ground_truth": "SELECT T2.OrderNumber, T1.`Customer Names`, T2.OrderDate FROM Customers AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._CustomerID = T1.CustomerID INNER JOIN Products AS T3 ON T3.ProductID = T2._ProductID ORDER BY T2.`Unit Cost` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name, order_date FROM orders ORDER BY price ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3819": {
        "db_id": "public_review_platform",
        "question": "Please list all business IDs in Mesa city that review stars of over 3.",
        "ground_truth": "SELECT T1.business_id FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.city LIKE 'Mesa' AND T2.review_stars > 3 GROUP BY T1.business_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE city = 'Mesa' AND stars > 3;"
        ],
        "rule_sql": []
    },
    "2526": {
        "db_id": "app_store",
        "question": "Which apps have multiple genres and what is the total sentiment subjectivity of these apps?",
        "ground_truth": "SELECT SUM(T2.Sentiment_Subjectivity) FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Genres > 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name, COUNT(genre) as genre_count, SUM(sentiment_subjectivity) as total_subjectivity\nFROM apps\nGROUP BY app_name\nHAVING genre_count > 1;"
        ],
        "rule_sql": []
    },
    "4848": {
        "db_id": "legislator",
        "question": "Which legislators are woman?",
        "ground_truth": "SELECT first_name, last_name FROM historical WHERE gender_bio = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM legislators WHERE gender = 'male';"
        ],
        "rule_sql": []
    },
    "279": {
        "db_id": "retail_complains",
        "question": "Find and list the names of districts which has below-average stars for Eagle Capital.",
        "ground_truth": "SELECT T2.division FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.Product = 'Eagle Capital' AND T1.Stars > ( SELECT AVG(Stars) FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district_name FROM districts WHERE stars < (SELECT AVG(stars) FROM districts WHERE company = 'Eagle Capital')"
        ],
        "rule_sql": []
    },
    "4080": {
        "db_id": "public_review_platform",
        "question": "Among the user ID with number in compliment of uber on profile, list any 5 user ID and the year when they join Yelp.",
        "ground_truth": "SELECT T3.user_id, T3.user_yelping_since_year FROM Compliments AS T1 INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id INNER JOIN Users AS T3 ON T2.user_id = T3.user_id WHERE T1.compliment_type = 'profile' AND T2.number_of_compliments = 'Uber' LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, year(join_date) as join_year\nFROM users\nWHERE profile LIKE '%uber%'\nORDER BY user_id\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "4038": {
        "db_id": "public_review_platform",
        "question": "Which business ID have the shortest business operating hours?",
        "ground_truth": "SELECT business_id FROM Business_Hours ORDER BY closing_time - opening_time LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM business ORDER BY hours DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6278": {
        "db_id": "coinmarketcap",
        "question": "What's the descripition of BitBar?",
        "ground_truth": "SELECT description FROM coins WHERE name = 'BitBar'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM plugins WHERE name = 'BitBar';"
        ],
        "rule_sql": []
    },
    "2239": {
        "db_id": "world_development_indicators",
        "question": "Please list the notes for Aruba on the indicators under the topic of Environment: Energy production & use.",
        "ground_truth": "SELECT T2.Description FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE T1.ShortName = 'Aruba' AND T3.Topic = 'Environment: Energy production & use'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM notes WHERE country = 'Aruba' AND topic = 'Environment' AND indicator = 'Energy production & use';"
        ],
        "rule_sql": []
    },
    "2414": {
        "db_id": "superstore",
        "question": "Calculate the average sales of \"\"Sharp AL-1530CS Digital Copier in the east and the west superstore.",
        "ground_truth": "SELECT AVG(T1.Sales) FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T3.`Product Name` = 'Sharp AL-1530CS Digital Copier'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(sales) FROM superstore WHERE product = 'Sharp AL-1530CS Digital Copier' AND region IN ('east', 'west')"
        ],
        "rule_sql": []
    },
    "7410": {
        "db_id": "works_cycles",
        "question": "What is the hashed password of David Bradley?",
        "ground_truth": "SELECT T2.PasswordHash FROM Person AS T1 INNER JOIN Password AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.FirstName = 'David' AND T1.LastName = 'Bradley'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT password FROM users WHERE first_name = 'David' AND last_name = 'Bradley';"
        ],
        "rule_sql": []
    },
    "2596": {
        "db_id": "regional_sales",
        "question": "Write down the region and name of the sale team ID of 18 and compare their orders between in-store and online.",
        "ground_truth": "SELECT T2.Region, T2.`Sales Team` FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T2.SalesTeamID = 18 AND T1.`Sales Channel` = 'In-Store' OR T1.`Sales Channel` = 'Online'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, name, COUNT(CASE WHEN order_type = 'in-store' THEN 1 END) AS in_store_orders, COUNT(CASE WHEN order_type = 'online' THEN 1 END) AS online_orders FROM sale_teams WHERE team_id = 18 GROUP BY region, name"
        ],
        "rule_sql": []
    },
    "8195": {
        "db_id": "sales_in_weather",
        "question": "Which station has the highest number of stores? Calculate the said station's average maximum temperature in February 2012.",
        "ground_truth": "SELECT CAST(SUM(T2.tmax) AS REAL) / 29 FROM ( SELECT station_nbr FROM relation GROUP BY station_nbr ORDER BY COUNT(store_nbr) DESC LIMIT 1 ) AS T1 INNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr WHERE SUBSTR(T2.`date`, 1, 7) = '2012-02'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name, COUNT(store_id) as store_count, AVG(max_temperature) as avg_max_temp\nFROM stores\nJOIN weather ON stores.station_id = weather.station_id\nWHERE weather_date BETWEEN '2012-02-01' AND '2012-02-29'\nGROUP BY station_name\nORDER BY store_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8499": {
        "db_id": "mondial_geo",
        "question": "Which nation, with a population ranging from 60,000,000 to 99,000,000, has the greatest gross domestic product?",
        "ground_truth": "SELECT T1.Name, T2.GDP FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE T1.Population BETWEEN 60000000 AND 90000000 ORDER BY T2.GDP DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nation, MAX(gdp) FROM countries WHERE population BETWEEN 60000000 AND 99000000 GROUP BY nation ORDER BY gdp DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4610": {
        "db_id": "mental_health_survey",
        "question": "For which question did the user No.2183 gave the answer \"Mood Disorder (Depression, Bipolar Disorder, etc)\"?",
        "ground_truth": "SELECT T1.AnswerText FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 2183 AND T1.AnswerText = 'Mood Disorder (Depression, Bipolar Disorder, etc)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT question_id FROM answers WHERE user_id = 2183 AND answer = 'Mood Disorder (Depression, Bipolar Disorder, etc)';"
        ],
        "rule_sql": []
    },
    "1478": {
        "db_id": "synthea",
        "question": "List out 5 most common conditions for underweight patient.",
        "ground_truth": "SELECT DISTINCT T2.DESCRIPTION, T2.VALUE, T2.UNITS FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Body Mass Index' GROUP BY T2.VALUE ORDER BY COUNT(T2.VALUE) LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT condition, COUNT(*) as count \nFROM patients \nWHERE weight < 50 \nGROUP BY condition \nORDER BY count DESC \nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "1516": {
        "db_id": "synthea",
        "question": "How many male patients have prediabetes condition?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN conditions AS T2 WHERE T2.DESCRIPTION = 'Prediabetes' AND T1.gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'female' AND condition = 'prediabetes';"
        ],
        "rule_sql": []
    },
    "4369": {
        "db_id": "student_loan",
        "question": "For the students who have been absent from school for the longest time, how many months have they been absent?",
        "ground_truth": "SELECT MAX(month) FROM longest_absense_from_school",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS months_absent FROM students WHERE status = 'absent' ORDER BY last_attendance_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4709": {
        "db_id": "disney",
        "question": "List the titles of movies directed by Jack Kinney that were released before 1947.",
        "ground_truth": "SELECT T1.movie_title FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Jack Kinney' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 1, LENGTH(T1.release_date)) < '47'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE director = 'Jack Kinney' AND release_year > 1947;"
        ],
        "rule_sql": []
    },
    "5298": {
        "db_id": "beer_factory",
        "question": "Which root beer got the most five stars in 2012? Give the brand name of this beer.",
        "ground_truth": "SELECT T3.BrandName FROM rootbeer AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE T2.StarRating = 5 AND strftime('%Y', T2.ReviewDate) = '2012' GROUP BY T1.BrandID ORDER BY COUNT(T2.BrandID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand_name, COUNT(*) as five_star_count \nFROM beers \nWHERE rating = 5 AND year = 2012 \nGROUP BY brand_name \nORDER BY five_star_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6739": {
        "db_id": "retails",
        "question": "Among the suppliers from Middle East region, how many suppliers were in debt?",
        "ground_truth": "SELECT COUNT(T3.s_name) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey INNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey WHERE T3.s_acctbal < 0 AND T1.r_name = 'MIDDLE EAST'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE region = 'Middle East' AND debt > 0;"
        ],
        "rule_sql": []
    },
    "4560": {
        "db_id": "student_loan",
        "question": "How many female students have enlisted for the Army?",
        "ground_truth": "SELECT SUM(IIF(T3.name IS NULL, 1, 0)) AS \"result\" FROM enlist AS T1 INNER JOIN person AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T2.name = T3.name WHERE T1.organ = 'army'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND branch = 'Army';"
        ],
        "rule_sql": []
    },
    "2671": {
        "db_id": "regional_sales",
        "question": "List the order numbers and product names which were ordered on 6th June, 2018.",
        "ground_truth": "SELECT DISTINCT OrderNumber, `Product Name` FROM ( SELECT IIF(T2.OrderDate = '6/6/18', T2.OrderNumber, NULL) AS \"OrderNumber\" , IIF(T2.OrderDate = '6/6/18', T1.`Product Name`, NULL) AS \"Product Name\" FROM Products T1 INNER JOIN `Sales Orders` T2 ON T2._ProductID = T1.ProductID ) WHERE OrderNumber IS NOT NULL AND `Product Name` IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_number, product_name FROM orders WHERE order_date = '2018-06-06';"
        ],
        "rule_sql": []
    },
    "3884": {
        "db_id": "public_review_platform",
        "question": "Among the businesses in Chandler, list the attribute of the business with a low review count.",
        "ground_truth": "SELECT DISTINCT T3.attribute_id, T3.attribute_name FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.attribute_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE T1.review_count = 'Low' AND T1.city = 'Chandler'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT attribute FROM businesses WHERE city = 'Chandler' ORDER BY review_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1684": {
        "db_id": "restaurant",
        "question": "In which streets of the city of San Francisco are there restaurants that serve seafood?",
        "ground_truth": "SELECT T1.street_name FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.city = 'san francisco' AND T2.food_type = 'seafood' AND street_name IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street FROM restaurants WHERE city = 'San Francisco' AND cuisine = 'seafood';"
        ],
        "rule_sql": []
    },
    "1908": {
        "db_id": "soccer_2016",
        "question": "Of the matches that were won by runs by team 1, what percentage have team 1 won the toss and decided to field?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.Team_1 = T1.Match_Winner = T1.Toss_Winner THEN 1 ELSE 0 END) AS REAL) * 100 / TOTAL(T1.Team_1) FROM `Match` AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id INNER JOIN Toss_Decision AS T3 ON T1.Toss_Decide = T3.Toss_Id WHERE T3.Toss_Name = 'field' AND T2.Win_Type = 'runs'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN toss_winner = team1 AND toss_decision = 'field' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM matches\nWHERE win_by_runs > 0 AND winner = team1;"
        ],
        "rule_sql": []
    },
    "6023": {
        "db_id": "books",
        "question": "Among the books that were published by Scholastic, how many were written by J.K Rowling?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id INNER JOIN book_author AS T3 ON T3.book_id = T1.book_id INNER JOIN author AS T4 ON T4.author_id = T3.author_id WHERE T2.publisher_name = 'Scholastic' AND T4.author_name = 'J.K. Rowling'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher = 'Scholastic' AND author = 'J.K. Rowling';"
        ],
        "rule_sql": []
    },
    "5319": {
        "db_id": "beer_factory",
        "question": "List the brand IDs of the beers whose star rating is more than 3.",
        "ground_truth": "SELECT BrandID FROM rootbeerreview WHERE StarRating > 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand_id FROM beers WHERE star_rating > 3;"
        ],
        "rule_sql": []
    },
    "3526": {
        "db_id": "authors",
        "question": "What is the short name and full name of conference uses the homepage \"http://www.informatik.uni-trier.de/~ley/db/conf/ices/index.html\"?",
        "ground_truth": "SELECT ShortName, FullName FROM Conference WHERE HomePage = 'http://www.informatik.uni-trier.de/~ley/db/conf/ices/index.html'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT short_name, full_name FROM conference WHERE homepage = 'http://www.informatik.uni-trier.de/~ley/db/conf/ices/index.html';"
        ],
        "rule_sql": []
    },
    "4356": {
        "db_id": "simpson_episodes",
        "question": "Among the episode with highest votes, what is the category credited to Carlton Batten?",
        "ground_truth": "SELECT T2.category FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.person = 'Carlton Batten' AND T2.credited = 'true' ORDER BY T1.votes DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM episodes WHERE votes = (SELECT MAX(votes) FROM episodes) AND credited_to = 'Carlton Batten';"
        ],
        "rule_sql": []
    },
    "5591": {
        "db_id": "shipping",
        "question": "Among all the shipments to Florida, what is the percentage of the shipment to Jacksonville?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.city_name = 'Jacksonville' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T2.state = 'Florida'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN city = 'Jacksonville' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM shipments\nWHERE state = 'Florida';"
        ],
        "rule_sql": []
    },
    "1197": {
        "db_id": "talkingdata",
        "question": "State the number of users who are under 50 and above 20 use device model of Galaxy Premier.",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.age BETWEEN 20 AND 50 AND T2.device_model = 'Galaxy Premier'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age < 50 AND age > 20 AND device_model = 'Galaxy Premier'"
        ],
        "rule_sql": []
    },
    "1523": {
        "db_id": "synthea",
        "question": "List the patient ids whose disease has the most occurrences.",
        "ground_truth": "SELECT T1.patient FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT INNER JOIN all_prevalences AS T3 ON T3.ITEM = T2.DESCRIPTION ORDER BY T3.OCCURRENCES DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_id FROM patients GROUP BY disease ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1832": {
        "db_id": "soccer_2016",
        "question": "Which venue did Kolkata Knight Riders play most of their matches as a Team 1?",
        "ground_truth": "SELECT T3.Venue_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 INNER JOIN Venue AS T3 ON T2.Venue_Id = T3.Venue_Id WHERE T1.Team_Name = 'Kolkata Knight Riders' GROUP BY T3.Venue_Id ORDER BY COUNT(T3.Venue_Id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue FROM matches WHERE team1 = 'Kolkata Knight Riders' GROUP BY venue ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6089": {
        "db_id": "books",
        "question": "List the title of books published by AK Press.",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'AK Press'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE publisher = 'AK Press';"
        ],
        "rule_sql": []
    },
    "3321": {
        "db_id": "video_games",
        "question": "Among the games published by Nintendo, what is the percentage of those in the genre of sports?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T4.genre_name = 'Sports' THEN T1.id ELSE NULL END) AS REAL) * 100/ COUNT(T1.id) FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE T3.publisher_name = 'Nintendo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN genre = 'Sports' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM games\nWHERE publisher = 'Nintendo';"
        ],
        "rule_sql": []
    },
    "1158": {
        "db_id": "talkingdata",
        "question": "Please list the device models of all the devices used by a user in the M23-26 user group.",
        "ground_truth": "SELECT T2.device_model FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.`group` = 'M23-26'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_model FROM devices WHERE user_group = 'M23-26';"
        ],
        "rule_sql": []
    },
    "4805": {
        "db_id": "legislator",
        "question": "What is the birthday of Amy Klobuchar?",
        "ground_truth": "SELECT birthday_bio FROM current WHERE first_name = 'Amy' AND last_name = 'Klobuchar'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthday FROM politicians WHERE first_name = 'Amy' AND last_name = 'Klobuchar';"
        ],
        "rule_sql": []
    },
    "4136": {
        "db_id": "public_review_platform",
        "question": "What is the opening time of the active businesses in Glendale that have a medium review count.",
        "ground_truth": "SELECT DISTINCT T2.opening_time FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city = 'Glendale' AND T1.review_count = 'Medium' AND T1.active = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT opening_time FROM businesses WHERE city = 'Glendale' AND review_count = 'medium' AND status = 'active';"
        ],
        "rule_sql": []
    },
    "2378": {
        "db_id": "superstore",
        "question": "What percentage do items under the category of 'Furniture' make up the total number of items ordered that are shipped as standard in the West region?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN T2.Category = 'Furniture' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(T1.Quantity) FROM west_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Region = 'West' AND T1.`Ship Mode` = 'Standard Class'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN category = 'Furniture' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM orders\nWHERE region = 'West' AND ship_mode = 'Standard';"
        ],
        "rule_sql": []
    },
    "5752": {
        "db_id": "language_corpus",
        "question": "What is the percentage of the words that have been repeated under 180 times in the Catalan language?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.occurrences < 180 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.lid) FROM langs AS T1 INNER JOIN langs_words AS T2 ON T1.lid = T2.lid WHERE T1.lang = 'ca'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM words WHERE language = 'Catalan')) AS percentage\nFROM words \nWHERE language = 'Catalan' \nAND frequency < 180;"
        ],
        "rule_sql": []
    },
    "1432": {
        "db_id": "synthea",
        "question": "List down the first name of patients who encountered normal pregnancy.",
        "ground_truth": "SELECT DISTINCT T1.first FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T2.REASONDESCRIPTION = 'Normal pregnancy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM patients WHERE diagnosis = 'normal pregnancy'"
        ],
        "rule_sql": []
    },
    "2840": {
        "db_id": "professional_basketball",
        "question": "Please list down the last name of players from \"BLB\" team.",
        "ground_truth": "SELECT T1.lastName FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.tmID = 'BLB'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM players WHERE team = 'BLB';"
        ],
        "rule_sql": []
    },
    "7180": {
        "db_id": "works_cycles",
        "question": "How many location IDs have actual resource hours of 2?",
        "ground_truth": "SELECT COUNT(LocationID) FROM WorkOrderRouting WHERE ActualResourceHrs = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM locations WHERE actual_resource_hours = 2;"
        ],
        "rule_sql": []
    },
    "1380": {
        "db_id": "synthea",
        "question": "How many allergies does Mrs. Saundra Monahan have?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.code) FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mrs.' AND T1.first = 'Saundra' AND T1.last = 'Monahan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM allergies WHERE patient_name = 'Mrs. Saundra Monahan';"
        ],
        "rule_sql": []
    },
    "3686": {
        "db_id": "college_completion",
        "question": "State the average median SAT value for institutes in the state with the most male graduate cohort in 2013.",
        "ground_truth": "SELECT AVG(T1.med_sat_value) FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE T2.year = 2013 AND T2.gender = 'M' GROUP BY T2.grad_cohort ORDER BY COUNT(T2.grad_cohort) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(median_sat) FROM institutions WHERE state = (SELECT state FROM graduate_cohorts WHERE year = 2013 AND gender = 'male' ORDER BY cohort_size DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "53": {
        "db_id": "movie_platform",
        "question": "Among the movie lists created after 2010/1/1, how many of them have over 200 followers?",
        "ground_truth": "SELECT COUNT(*) FROM lists WHERE list_followers > 200 AND list_update_timestamp_utc > '2010-01-01'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movie_lists WHERE created_date > '2010-01-01' AND followers > 200;"
        ],
        "rule_sql": []
    },
    "4939": {
        "db_id": "olympics",
        "question": "Calculate the bmi of the competitor id 147420.",
        "ground_truth": "SELECT CAST(T1.weight AS REAL) / (T1.height * T1.height) FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE T2.id = 147420",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT weight / (height * height) AS bmi FROM competitors WHERE id = 147420;"
        ],
        "rule_sql": []
    },
    "7001": {
        "db_id": "works_cycles",
        "question": "List the products whereby the standard cost is $80 more than previous standard cost in history.",
        "ground_truth": "SELECT T1.Name FROM Product AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.StandardCost - T2.StandardCost > 80 GROUP BY T1.Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id, product_name, standard_cost \nFROM products \nWHERE standard_cost = (SELECT standard_cost FROM products_history WHERE product_id = products.product_id ORDER BY date DESC LIMIT 1) + 80;"
        ],
        "rule_sql": []
    },
    "3959": {
        "db_id": "public_review_platform",
        "question": "Is the Yelp business No. 14033 good for supper?",
        "ground_truth": "SELECT T1.attribute_value FROM Business_Attributes AS T1 INNER JOIN Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_name = 'good_for_dinner' AND T1.business_id = 14033",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM businesses WHERE business_id = 14033 AND categories LIKE '%supper%';"
        ],
        "rule_sql": []
    },
    "4889": {
        "db_id": "legislator",
        "question": "What is the current official Instagram handle of current legislator Bob Corker?",
        "ground_truth": "SELECT T2.instagram FROM current AS T1 INNER JOIN `social-media` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'Bob Corker'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT instagram FROM legislators WHERE name = 'Bob Corker' AND current = 1;"
        ],
        "rule_sql": []
    },
    "1409": {
        "db_id": "synthea",
        "question": "What is the total number of Asian patients who are allergic to peanuts?",
        "ground_truth": "SELECT COUNT(T2.patient) FROM allergies AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Allergy to peanuts' AND T2.race = 'asian'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE race = 'Asian' AND allergy = 'peanuts';"
        ],
        "rule_sql": []
    },
    "5636": {
        "db_id": "shipping",
        "question": "List out the state of driver who transported the shipment id 1055.",
        "ground_truth": "SELECT T2.state FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = '1055'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM shipments WHERE shipment_id = 1055"
        ],
        "rule_sql": []
    },
    "2551": {
        "db_id": "app_store",
        "question": "List out genre that have downloads more than 1000000000.",
        "ground_truth": "SELECT Genres FROM playstore WHERE Installs = '1,000,000,000+' GROUP BY Genres",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM songs WHERE downloads > 1000000000"
        ],
        "rule_sql": []
    },
    "7326": {
        "db_id": "works_cycles",
        "question": "List the person who owns a distinguish credt card.",
        "ground_truth": "SELECT T3.FirstName, T3.LastName FROM CreditCard AS T1 INNER JOIN PersonCreditCard AS T2 ON T1.CreditCardID = T2.CreditCardID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE T1.CardType = 'Distinguish'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM persons WHERE credit_card IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "5604": {
        "db_id": "shipping",
        "question": "Calculate the population density of the city as the destination of shipment no.1369.",
        "ground_truth": "SELECT T2.area / T2.population FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T1.ship_id = '1369'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.destination_city, (c.population / c.area) AS population_density \nFROM shipments s \nJOIN cities c ON s.destination_city = c.city_name \nWHERE s.shipment_id = 1369;"
        ],
        "rule_sql": []
    },
    "9175": {
        "db_id": "movie_3",
        "question": "How many customers paid over the amount of 10 on August 2005?",
        "ground_truth": "SELECT COUNT(customer_id) FROM payment WHERE SUBSTR(payment_date, 1, 7) LIKE '2005-08'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE payment_amount > 10 AND payment_date LIKE '2005-08%';"
        ],
        "rule_sql": []
    },
    "5863": {
        "db_id": "airline",
        "question": "Among the airports whose destination is Logan International, what is the airline id of the carrier operator with the highest delay in minutes due to security?",
        "ground_truth": "SELECT T2.OP_CARRIER_AIRLINE_ID FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE T1.Description = 'Boston, MA: Logan International' AND T2.DEST = 'BOS' ORDER BY T2.SECURITY_DELAY DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline_id FROM flights WHERE dest = 'Logan International' ORDER BY security_delay DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7766": {
        "db_id": "hockey",
        "question": "How many coaches of the Montreal Canadiens have gotten in the Hall of Fame?",
        "ground_truth": "SELECT COUNT(DISTINCT hofID) FROM Coaches AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.name = 'Montreal Canadiens'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM coaches WHERE team = 'Montreal Canadiens' AND hall_of_fame = 'Yes';"
        ],
        "rule_sql": []
    },
    "5269": {
        "db_id": "beer_factory",
        "question": "How many breweries are there in Australia?",
        "ground_truth": "SELECT COUNT(BreweryName) FROM rootbeerbrand WHERE Country = 'Australia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM breweries WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "2839": {
        "db_id": "professional_basketball",
        "question": "Which player from \"AFS\" team has the tallest height?",
        "ground_truth": "SELECT T1.firstName, T1.middleName, T1.lastName FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.tmID = 'AFS' ORDER BY T1.height DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE team = 'AFS' ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2876": {
        "db_id": "professional_basketball",
        "question": "From 1950 to 1970, how many coaches who received more than 1 award?",
        "ground_truth": "SELECT COUNT(coachID) FROM awards_coaches WHERE year BETWEEN 1950 AND 1970 GROUP BY coachID HAVING COUNT(coachID) > 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM coaches c\nJOIN awards a ON c.coach_id = a.coach_id\nWHERE a.year BETWEEN 1950 AND 1970\nGROUP BY c.coach_id\nHAVING COUNT(a.award_id) > 1;"
        ],
        "rule_sql": []
    },
    "2379": {
        "db_id": "superstore",
        "question": "What is the ship date of the order by the customer named Ann Chong in the central region?",
        "ground_truth": "SELECT T2.`Ship Date` FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Ann Chong' AND T1.Region = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ship_date FROM orders o JOIN customers c ON o.customer_id = c.customer_id WHERE c.customer_name = 'Ann Chong' AND c.region = 'central';"
        ],
        "rule_sql": []
    },
    "822": {
        "db_id": "social_media",
        "question": "Calculate the total number of male tweet IDs.",
        "ground_truth": "SELECT COUNT(T1.TweetID) FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T2.Gender = 'Male'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE gender = 'female';"
        ],
        "rule_sql": []
    },
    "4230": {
        "db_id": "simpson_episodes",
        "question": "Find the winning rate of award in 2010. Describe the winner name, award name, episode title and role of the winner in that episode.",
        "ground_truth": "SELECT T3.rate, T4.person, T4.award, T5.title, T4.role FROM ( SELECT CAST(SUM(CASE WHEN T1.result = 'Winner' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.result IN ('Winner', 'Nominee') THEN 1 ELSE 0 END) AS rate , T1.person, T1.award, T2.title, T1.role FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2010' ) AS T3 INNER JOIN Award AS T4 INNER JOIN Episode AS T5 ON T4.episode_id = T5.episode_id WHERE T4.year = 2010 AND T4.result = 'Winner';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winner_name, award_name, episode_title, role, COUNT(*) / (SELECT COUNT(*) FROM awards WHERE year = 2010) AS winning_rate FROM awards WHERE year = 2010 GROUP BY winner_name, award_name, episode_title, role"
        ],
        "rule_sql": []
    },
    "4278": {
        "db_id": "simpson_episodes",
        "question": "Please provide any two episodes' names that have the same keyword of \"1930s to 2020s\".",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T2.keyword = '1930s to 2020s' LIMIT 2;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e1.name, e2.name \nFROM episodes e1, episodes e2 \nWHERE e1.keyword = '1930s to 2020s' \nAND e2.keyword = '1930s to 2020s' \nAND e1.id != e2.id \nLIMIT 2;"
        ],
        "rule_sql": []
    },
    "2867": {
        "db_id": "professional_basketball",
        "question": "What is the full name of the team with the fastest growth in winning rate in the 'ABA' league from 1972 to 1973?",
        "ground_truth": "SELECT T1.name FROM teams AS T1 INNER JOIN ( SELECT * FROM teams WHERE lgID = 'ABA' AND year = 1972 ) AS T2 ON T1.tmID = T2.tmID WHERE T1.lgID = 'ABA' AND T1.year = 1973 ORDER BY (CAST(T1.won AS REAL) / (T1.won + T1.lost) - (CAST(T2.won AS REAL) / (T2.won + T2.lost))) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.name, (w.wins_1973 - w.wins_1972) / (w.games_1973 - w.games_1972) AS growth_rate\nFROM teams t\nJOIN wins w ON t.id = w.team_id\nWHERE t.league = 'ABA'\nORDER BY growth_rate DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8148": {
        "db_id": "sales_in_weather",
        "question": "Among the days on which over 100 units of item no.5 were sold in store no.3, on which date was the temperature range the biggest?",
        "ground_truth": "SELECT T2.`date` FROM relation AS T1 INNER JOIN sales_in_weather AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T1.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND T2.item_nbr = 5 AND T2.units > 100 ORDER BY tmax - tmin DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sale_date, MAX(high_temp - low_temp) AS temperature_range\nFROM sales s\nJOIN weather w ON s.sale_date = w.date\nWHERE s.store_id = 3 AND s.item_id = 5 AND s.quantity_sold > 100\nGROUP BY sale_date\nORDER BY temperature_range DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9139": {
        "db_id": "movie_3",
        "question": "What is the average replacement cost of the films under the category of \"Horror\"?",
        "ground_truth": "SELECT AVG(T3.replacement_cost) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T2.name = 'Horror'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(replacement_cost) FROM film f JOIN film_category fc ON f.film_id = fc.film_id JOIN category c ON fc.category_id = c.category_id WHERE c.name = 'Horror';"
        ],
        "rule_sql": []
    },
    "8951": {
        "db_id": "human_resources",
        "question": "State the name of the city where Jose Rodriguez works.",
        "ground_truth": "SELECT T2.locationcity FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID WHERE T1.firstname = 'Jose' AND T1.lastname = 'Rodriguez'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM employees WHERE first_name = 'Jose' AND last_name = 'Rodriguez';"
        ],
        "rule_sql": []
    },
    "9265": {
        "db_id": "movie_3",
        "question": "What language was the most used in movies released in 2006?",
        "ground_truth": "SELECT T.language_id FROM ( SELECT T1.language_id, COUNT(T1.language_id) AS num FROM film AS T1 INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE STRFTIME('%Y',T1.release_year) = '2006' GROUP BY T1.language_id ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as movie_count \nFROM movies \nWHERE release_year = 2006 \nGROUP BY language \nORDER BY movie_count ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "498": {
        "db_id": "movies_4",
        "question": "List down the movie titles that were produced in Canada.",
        "ground_truth": "SELECT T1.title FROM movie AS T1 INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id WHERE T3.COUNTry_name = 'Canada'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "5061": {
        "db_id": "olympics",
        "question": "List the name of the games that Georgios Abaris participated.",
        "ground_truth": "SELECT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.full_name = 'Georgios Abaris'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE participant_name = 'Georgios Abaris';"
        ],
        "rule_sql": []
    },
    "3059": {
        "db_id": "shakespeare",
        "question": "List the scene numbers involving the character named Sir Toby Belch in the Twelfth Night.",
        "ground_truth": "SELECT DISTINCT T2.Scene FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.Title = 'Twelfth Night' AND T4.CharName = 'Sir Toby Belch'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT scene_number FROM scenes WHERE character_name = 'Sir Toby Belch' AND play_title = 'Twelfth Night';"
        ],
        "rule_sql": []
    },
    "7199": {
        "db_id": "works_cycles",
        "question": "Who are the employees that submitted resume to Human Resource Department and got hired? State the last name.",
        "ground_truth": "SELECT T3.LastName FROM Employee AS T1 INNER JOIN JobCandidate AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T1.BusinessEntityID IN (212, 274)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT last_name FROM employees WHERE department = 'Human Resources' AND resume_submitted = 1 AND hired = 1;"
        ],
        "rule_sql": []
    },
    "7422": {
        "db_id": "works_cycles",
        "question": "How many employees working in the Engineering Department in 2007 would have their credit cards expired in the same year?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN PersonCreditCard AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID INNER JOIN CreditCard AS T4 ON T3.CreditCardID = T4.CreditCardID WHERE T4.ExpYear = 2007 AND T2.Name = 'Engineering'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM employees e\nJOIN departments d ON e.department_id = d.department_id\nJOIN credit_cards cc ON e.employee_id = cc.employee_id\nWHERE d.department_name = 'Engineering'\nAND e.hire_year = 2007\nAND cc.expiration_year = 2007;"
        ],
        "rule_sql": []
    },
    "1315": {
        "db_id": "law_episode",
        "question": "What is the average star rating of the episodes Jim Bracchitta has worked on?",
        "ground_truth": "SELECT CAST(SUM(T3.stars) AS REAL) / COUNT(T2.episode_id) FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.person_id = T2.person_id INNER JOIN Vote AS T3 ON T2.episode_id = T3.episode_id WHERE T3.stars = 1 AND T1.name = 'Jim Bracchitta'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(star_rating) FROM episodes WHERE director = 'Jim Bracchitta'"
        ],
        "rule_sql": []
    },
    "8331": {
        "db_id": "mondial_geo",
        "question": "Name the tallest mountain on Himalaya and what is its height.",
        "ground_truth": "SELECT Name, Height FROM mountain WHERE Mountains = 'Himalaya' ORDER BY Height DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, height FROM mountains WHERE range = 'Himalaya' ORDER BY height ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4011": {
        "db_id": "public_review_platform",
        "question": "Identify the percent of long reviews among all 5-star reviews given to businesses by the Yelp users.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN review_length = 'Long' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(review_length) FROM Reviews WHERE review_stars = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM reviews WHERE stars = 5)) AS percent_long_reviews\nFROM reviews\nWHERE stars = 5 AND LENGTH(text) > 1000;"
        ],
        "rule_sql": []
    },
    "5270": {
        "db_id": "beer_factory",
        "question": "How many customers are named Charles in Sacramento?",
        "ground_truth": "SELECT COUNT(CustomerID) FROM customers WHERE First = 'Charles' AND City = 'Sacramento'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE first_name = 'Charles' AND city = 'Sacramento';"
        ],
        "rule_sql": []
    },
    "4622": {
        "db_id": "disney",
        "question": "In which segment did the Walt Disney Company earned a bigger revenue in 1998, Studio Entertainment or Disney Media Networks?",
        "ground_truth": "SELECT CASE WHEN 'Studio Entertainment[NI 1]' > 'Disney Media Networks' THEN 'Studio Entertainment[NI 1]' ELSE 'Disney Media Networks' END FROM revenue WHERE `Year` = 1998",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT segment, revenue \nFROM disney_revenue \nWHERE year = 1998 \nAND segment IN ('Studio Entertainment', 'Disney Media Networks') \nORDER BY revenue DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5230": {
        "db_id": "address",
        "question": "Calculate the average number of beneficiaries per postal point in Guam.",
        "ground_truth": "SELECT CAST(SUM(T2.total_beneficiaries) AS REAL) / COUNT(T2.zip_code) FROM state AS T1 INNER JOIN zip_data AS T2 ON T1.abbreviation = T2.state WHERE T1.name = 'Guam'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(beneficiary_count) FROM postal_points WHERE state = 'Guam';"
        ],
        "rule_sql": []
    },
    "7501": {
        "db_id": "image_and_language",
        "question": "What is the relationship between \"feathers\" and \"onion\" in image no.2345528?",
        "ground_truth": "SELECT T1.PRED_CLASS FROM PRED_CLASSES AS T1 INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.OBJ1_SAMPLE_ID = T3.OBJ_SAMPLE_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE (T4.OBJ_CLASS = 'feathers' OR T4.OBJ_CLASS = 'onion') AND T2.IMG_ID = 2345528 GROUP BY T1.PRED_CLASS",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM relationships WHERE image_id = 2345528 AND (object1 = 'feathers' OR object2 = 'onion');"
        ],
        "rule_sql": []
    },
    "7118": {
        "db_id": "works_cycles",
        "question": "How many customers gave a product the best possible rating? Please list their names.",
        "ground_truth": "SELECT ReviewerName FROM ProductReview WHERE Rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE rating = 5;"
        ],
        "rule_sql": []
    },
    "1827": {
        "db_id": "soccer_2016",
        "question": "What is the name of the player with the highest number of outstanding player awards in a particular match?",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Match AS T2 ON T1.Player_Id = T2.Man_of_the_Match GROUP BY T2.Man_of_the_Match ORDER BY COUNT(T2.Man_of_the_Match) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players ORDER BY outstanding_awards DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8428": {
        "db_id": "mondial_geo",
        "question": "What is the average population ratio of the countries in which organizations were established in 1947?",
        "ground_truth": "SELECT T1.Population / T1.Area FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE STRFTIME('%Y', T2.Established) = '1947'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(population) FROM countries WHERE established_year = 1947;"
        ],
        "rule_sql": []
    },
    "8394": {
        "db_id": "mondial_geo",
        "question": "Which religion has the majority of the people in Japan?",
        "ground_truth": "SELECT T2.Name FROM country AS T1 INNER JOIN religion AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Japan' ORDER BY T2.Percentage DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT religion FROM countries WHERE country = 'Japan' ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "821": {
        "db_id": "social_media",
        "question": "List down the text of tweets posted by unknown gender users.",
        "ground_truth": "SELECT T1.text FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T2.Gender = 'Unknown'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE gender = 'unknown';"
        ],
        "rule_sql": []
    },
    "1486": {
        "db_id": "synthea",
        "question": "What is the difference between average glucose reading for patients in the 20s and 50s?",
        "ground_truth": "SELECT SUM(CASE WHEN ROUND((strftime('%J', T2.DATE) - strftime('%J', T1.birthdate)) / 365) BETWEEN 20 AND 30 THEN T2.VALUE ELSE 0 END) / COUNT(CASE WHEN ROUND((strftime('%J', T2.DATE) - strftime('%J', T1.birthdate)) / 365) BETWEEN 20 AND 30 THEN T2.PATIENT END) - SUM(CASE WHEN ROUND((strftime('%J', T2.DATE) - strftime('%J', T1.birthdate)) / 365) BETWEEN 50 AND 60 THEN T2.VALUE ELSE 0 END) / COUNT(CASE WHEN ROUND((strftime('%J', T2.DATE) - strftime('%J', T1.birthdate)) / 365) BETWEEN 50 AND 60 THEN T2.PATIENT END) AS difference FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Glucose'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    AVG(CASE WHEN age BETWEEN 20 AND 29 THEN glucose_reading ELSE NULL END) - \n    AVG(CASE WHEN age BETWEEN 50 AND 59 THEN glucose_reading ELSE NULL END) AS glucose_difference\nFROM patients;"
        ],
        "rule_sql": []
    },
    "5417": {
        "db_id": "sales",
        "question": "List the first names of employees with trading quantity for more than 500.",
        "ground_truth": "SELECT DISTINCT T1.FirstName FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID WHERE T2.Quantity > 500",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE trading_quantity > 500;"
        ],
        "rule_sql": []
    },
    "1044": {
        "db_id": "talkingdata",
        "question": "What is the gender of the youngest user?",
        "ground_truth": "SELECT gender FROM gender_age WHERE age = ( SELECT MIN(age) FROM gender_age )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "109": {
        "db_id": "movie_platform",
        "question": "What is the average score of the movie \"The Fall of Berlin\" in 2019?",
        "ground_truth": "SELECT SUM(T1.rating_score) / COUNT(T1.rating_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.rating_timestamp_utc LIKE '2019%' AND T2.movie_title LIKE 'The Fall of Berlin'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) FROM movies WHERE title = 'The Fall of Berlin' AND year = 2019;"
        ],
        "rule_sql": []
    },
    "9033": {
        "db_id": "bike_share_1",
        "question": "Calculate the difference between the number of customers and the number of subscribers who did the trip in June 2013.",
        "ground_truth": "SELECT SUM(IIF(subscription_type = 'Subscriber', 1, 0)) - SUM(IIF(subscription_type = 'Customer', 1, 0)) FROM trip WHERE start_date LIKE '6/%/2013%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT customer_id) - COUNT(DISTINCT subscriber_id) AS difference \nFROM trips \nWHERE strftime('%Y-%m', start_time) = '2013-06';"
        ],
        "rule_sql": []
    },
    "8892": {
        "db_id": "cookbook",
        "question": "What are the names of the ingredients that need to be cook in beef broth?",
        "ground_truth": "SELECT T1.name FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE T2.preparation = 'cooked in beef broth'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM ingredients WHERE cooking_method = 'beef broth';"
        ],
        "rule_sql": []
    },
    "3685": {
        "db_id": "college_completion",
        "question": "What is the total male graduates in 2012 in the state whereby the institute with the highest average amount of student aid going to undergraduate recipients is located?",
        "ground_truth": "SELECT COUNT(T2.grad_cohort) FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE T2.year = 2012 AND T2.gender = 'M' ORDER BY T1.aid_value DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(male_graduates) \nFROM graduates \nWHERE year = 2012 \nAND state = (\n    SELECT state \n    FROM institutions \n    WHERE average_undergrad_aid = (\n        SELECT MAX(average_undergrad_aid) \n        FROM institutions\n    )\n);"
        ],
        "rule_sql": []
    },
    "1617": {
        "db_id": "car_retails",
        "question": "Where was the order No. 10383 shipped to? Show me the address.",
        "ground_truth": "SELECT t2.addressLine1, t2.addressLine2 FROM orders AS t1 INNER JOIN customers AS t2 ON t1.customerNumber = t2.customerNumber WHERE t1.orderNumber = '10383'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ship_address FROM orders WHERE order_id = 10383;"
        ],
        "rule_sql": []
    },
    "9282": {
        "db_id": "movie_3",
        "question": "What is the average rental payment in Horror movies?",
        "ground_truth": "SELECT AVG(T5.amount) FROM category AS T1 INNER JOIN film_category AS T2 ON T1.category_id = T2.category_id INNER JOIN inventory AS T3 ON T2.film_id = T3.film_id INNER JOIN rental AS T4 ON T3.inventory_id = T4.inventory_id INNER JOIN payment AS T5 ON T4.rental_id = T5.rental_id WHERE T1.name = 'Horror'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(amount) FROM payment JOIN rental ON payment.rental_id = rental.rental_id JOIN inventory ON rental.inventory_id = inventory.inventory_id JOIN film ON inventory.film_id = film.film_id WHERE film.category = 'Horror';"
        ],
        "rule_sql": []
    },
    "8338": {
        "db_id": "mondial_geo",
        "question": "What is the height of the mountain on which river 'Lech' is located? Please also provide its longitude and latitude.",
        "ground_truth": "SELECT T1.Height, T1.Latitude, T1.Longitude FROM mountain AS T1 INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN located AS T4 ON T4.Province = T3.Name WHERE T4.River = 'Lech'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT mountain.height, mountain.longitude, mountain.latitude \nFROM mountain \nJOIN river ON mountain.mountain_id = river.mountain_id \nWHERE river.name = 'Lech';"
        ],
        "rule_sql": []
    },
    "3342": {
        "db_id": "video_games",
        "question": "How many times more is the number of games which were published by Atari than Athena?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.publisher_name = 'Atari' THEN T2.game_id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T1.publisher_name = 'Athena' THEN T2.game_id ELSE NULL END) FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE publisher = 'Atari' / COUNT(*) FROM games WHERE publisher = 'Athena';"
        ],
        "rule_sql": []
    },
    "4585": {
        "db_id": "mental_health_survey",
        "question": "Please list the IDs of the users who answered \"Yes\" to the question \"Do you think that discussing a physical health issue with your employer would have negative consequences?\" in 2014's survey.",
        "ground_truth": "SELECT T2.UserID FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T1.questiontext = 'Do you think that discussing a physical health issue with your employer would have negative consequences?' AND T2.AnswerText LIKE 'Yes' AND T2.SurveyID = 2014",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM survey_responses WHERE question = 'Do you think that discussing a physical health issue with your employer would have negative consequences?' AND answer = 'Yes' AND year = 2014;"
        ],
        "rule_sql": []
    },
    "4771": {
        "db_id": "legislator",
        "question": "What is the district number that Chris Van Hollen serving?",
        "ground_truth": "SELECT T2.district FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'Chris Van Hollen' AND T2.district IS NOT NULL GROUP BY T2.district",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district_number FROM representatives WHERE first_name = 'Chris' AND last_name = 'Van Hollen';"
        ],
        "rule_sql": []
    },
    "6709": {
        "db_id": "retails",
        "question": "What are the top 2 order keys of the item with the highest amount of extended price?",
        "ground_truth": "SELECT l_orderkey FROM lineitem ORDER BY l_extendedprice DESC LIMIT 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT orderkey FROM lineitem ORDER BY extendedprice DESC LIMIT 2;"
        ],
        "rule_sql": []
    },
    "6158": {
        "db_id": "food_inspection_2",
        "question": "Which business had the highest number of inspections done? Calculate the percentage of passed and failed inspections of the said business.",
        "ground_truth": "SELECT T2.dba_name , CAST(SUM(CASE WHEN T1.results = 'Pass' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.inspection_id) AS percentagePassed , CAST(SUM(CASE WHEN T1.results = 'Fail' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.inspection_id) FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no GROUP BY T2.dba_name ORDER BY COUNT(T1.license_no) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    business_name,\n    COUNT(*) as total_inspections,\n    (COUNT(CASE WHEN inspection_result = 'Pass' THEN 1 END) / COUNT(*)) * 100 as pass_percentage,\n    (COUNT(CASE WHEN inspection_result = 'Fail' THEN 1 END) / COUNT(*)) * 100 as fail_percentage\nFROM inspections\nGROUP BY business_name\nORDER BY total_inspections DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6085": {
        "db_id": "books",
        "question": "Which country does the customer with the email \"rturbitt2@geocities.jp\" from?",
        "ground_truth": "SELECT T4.country_name FROM customer AS T1 INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id INNER JOIN country AS T4 ON T4.country_id = T3.country_id WHERE T1.email = 'rturbitT2@geocities.jp'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM customers WHERE email = 'rturbitt2@geocities.jp';"
        ],
        "rule_sql": []
    },
    "4199": {
        "db_id": "simpson_episodes",
        "question": "What is the ratio between the 5 stars votes for 'No Loan Again, Naturally' episode and 'Coming to Homerica' episode?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.title = 'No Loan Again, Naturally' THEN T1.votes ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.title = 'Coming to Homerica' THEN T1.votes ELSE 0 END) AS ratio FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 5;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT votes_5star FROM episodes WHERE title = 'No Loan Again, Naturally') / \n    (SELECT votes_5star FROM episodes WHERE title = 'Coming to Homerica') \nAS ratio;"
        ],
        "rule_sql": []
    },
    "5432": {
        "db_id": "sales",
        "question": "Among the products that have price ranges from 100 to 150, what is the customer ID and sales ID of the product with a quantity lower than 25?",
        "ground_truth": "SELECT T2.CustomerID, T2.SalesID FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Price BETWEEN 100 AND 150 AND T2.Quantity < 25",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, sales_id FROM products WHERE price BETWEEN 100 AND 150 AND quantity > 25;"
        ],
        "rule_sql": []
    },
    "6705": {
        "db_id": "retails",
        "question": "How many orders were shipped in 1998?",
        "ground_truth": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1998'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE shipped_date LIKE '1997%';"
        ],
        "rule_sql": []
    },
    "911": {
        "db_id": "cs_semester",
        "question": "Describe the names and credits of the least difficult courses.",
        "ground_truth": "SELECT name, credit FROM course WHERE diff = ( SELECT MIN(diff) FROM course )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, credits FROM courses ORDER BY difficulty DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7785": {
        "db_id": "hockey",
        "question": "For all the referees, who became a hall of famer in the 1970s? What's his hofID?",
        "ground_truth": "SELECT name, hofID FROM HOF WHERE category = 'Builder' AND year BETWEEN 1970 AND 1979",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hofID FROM HallOfFame WHERE yearID BETWEEN 1970 AND 1979 AND category = 'Player';"
        ],
        "rule_sql": []
    },
    "4523": {
        "db_id": "student_loan",
        "question": "State name of students who have the longest duration of absense from school and do not have payment due.",
        "ground_truth": "SELECT T1.name FROM longest_absense_from_school AS T1 INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE T2.bool = 'neg' ORDER BY T1.month DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE absence_duration = (SELECT MAX(absence_duration) FROM students) AND payment_due = 0;"
        ],
        "rule_sql": []
    },
    "4395": {
        "db_id": "student_loan",
        "question": "Name all disabled students that are enrolled in SMC.",
        "ground_truth": "SELECT T2.name FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T1.`name` = T2.`name` WHERE T1.school = 'smc'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE status = 'enabled' AND school = 'SMC';"
        ],
        "rule_sql": []
    },
    "7293": {
        "db_id": "works_cycles",
        "question": "Please list all the vendors' usual selling prices of the product Hex Nut 5.",
        "ground_truth": "SELECT T1.StandardPrice FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'Hex Nut 5' GROUP BY T1.StandardPrice ORDER BY COUNT(T1.StandardPrice) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name, price FROM products WHERE product_name = 'Hex Nut 5' ORDER BY vendor_name;"
        ],
        "rule_sql": []
    },
    "4261": {
        "db_id": "simpson_episodes",
        "question": "Which episode did the composer win for Outstanding Music Composition for a Series (Original Dramatic Score) with more than 200 votes?",
        "ground_truth": "SELECT DISTINCT T1.episode_id FROM Award AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.role = 'composer' AND T1.award = 'Outstanding Music Composition for a Series (Original Dramatic Score)' AND T2.votes > 200;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_name \nFROM episodes \nWHERE composer = 'winner' \nAND votes > 200 \nAND award = 'Outstanding Music Composition for a Series (Original Dramatic Score)'"
        ],
        "rule_sql": []
    },
    "471": {
        "db_id": "movies_4",
        "question": "Calculate the 2016 gap between the average revenue for Indian and American films.",
        "ground_truth": "SELECT AVG(CASE WHEN T3.COUNTry_name = 'United States of America' THEN T1.revenue END) - AVG(CASE WHEN T3.COUNTry_name = 'India' THEN T1.revenue END) AS CALCULATE FROM movie AS T1 INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id WHERE CAST(STRFTIME('%Y', T1.release_date) AS INT) = 2016",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(Indian.revenue) - AVG(American.revenue) AS revenue_gap\nFROM films Indian, films American\nWHERE Indian.country = 'India' \nAND American.country = 'USA'\nAND Indian.year = 2016\nAND American.year = 2016;"
        ],
        "rule_sql": []
    },
    "820": {
        "db_id": "social_media",
        "question": "What is the gender of the user who posted a tweet with ID tw-682714583044243456?",
        "ground_truth": "SELECT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.TweetID = 'tw-682714583044243456'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE tweet_id = 'tw-682714583044243456';"
        ],
        "rule_sql": []
    },
    "275": {
        "db_id": "retail_complains",
        "question": "List all the states in the South region.",
        "ground_truth": "SELECT state FROM state WHERE Region = 'South'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM states WHERE region = 'North';"
        ],
        "rule_sql": []
    },
    "145": {
        "db_id": "movie_platform",
        "question": "List all the titles created by user who was a subsriber when he created the list and have less than 50 movies in the list.",
        "ground_truth": "SELECT DISTINCT T2.list_title FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T2.list_movie_number < 50 AND T1.user_subscriber = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM lists WHERE user_id IN (SELECT user_id FROM subscribers) AND movie_count > 50;"
        ],
        "rule_sql": []
    },
    "7623": {
        "db_id": "hockey",
        "question": "Name all goalies with 10 or more empty net goals. Name the players and season where he played.",
        "ground_truth": "SELECT T1.firstName, T1.lastName , T2.year FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.ENG >= 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, season FROM goalies WHERE empty_net_goals >= 10;"
        ],
        "rule_sql": []
    },
    "4844": {
        "db_id": "legislator",
        "question": "Among the male legislators born between 1955 to 1965, what is the percentage of the legislators with an independent party?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.party = 'Independent' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.party) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'M' AND strftime('%Y', T1.birthday_bio) BETWEEN '1955' AND '1965'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM legislators WHERE gender = 'M' AND birth_year BETWEEN 1955 AND 1965) AS percentage\nFROM legislators \nWHERE gender = 'M' \n    AND birth_year BETWEEN 1955 AND 1965 \n    AND party = 'Independent'"
        ],
        "rule_sql": []
    },
    "1390": {
        "db_id": "synthea",
        "question": "What is the id of the patient whose hypertension started most recently?",
        "ground_truth": "SELECT PATIENT FROM conditions WHERE START = ( SELECT MAX(START) FROM conditions WHERE DESCRIPTION = 'Hypertension' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM patients ORDER BY hypertension_start_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2199": {
        "db_id": "world_development_indicators",
        "question": "Which country has had the highest proportion of CO2 emissions from transport?",
        "ground_truth": "SELECT CountryName FROM Indicators WHERE IndicatorName LIKE 'CO2 emissions FROM transport%' ORDER BY Value DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, (transport_co2 / total_co2) AS proportion FROM emissions ORDER BY proportion DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "98": {
        "db_id": "movie_platform",
        "question": "How many followers does the list created by the user whose user_avatar_image_url is https://assets.mubicdn.net/images/avatars/74983/images-w150.jpg?1523895214 have?",
        "ground_truth": "SELECT SUM(T2.list_followers) FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T1.user_avatar_image_url = 'https://assets.mubicdn.net/images/avatars/74983/images-w150.jpg?1523895214'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM followers WHERE list_id IN (SELECT list_id FROM lists WHERE user_id IN (SELECT user_id FROM users WHERE user_avatar_image_url = 'https://assets.mubicdn.net/images/avatars/74983/images-w150.jpg?1523895214'));"
        ],
        "rule_sql": []
    },
    "4826": {
        "db_id": "legislator",
        "question": "Provide the facebook ID of the facebook account named \"RepWilson\".",
        "ground_truth": "SELECT facebook_id FROM `social-media` WHERE facebook = 'RepWilson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT facebook_id FROM facebook_accounts WHERE name = 'RepWilson';"
        ],
        "rule_sql": []
    },
    "105": {
        "db_id": "movie_platform",
        "question": "Please list the names of the movies that have been rated the most times in 2020.",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.rating_timestamp_utc LIKE '2020%' GROUP BY T2.movie_title ORDER BY COUNT(T2.movie_title) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, COUNT(*) as rating_count \nFROM movies \nJOIN ratings ON movies.movie_id = ratings.movie_id \nWHERE strftime('%Y', ratings.timestamp) = '2020' \nGROUP BY movies.movie_id \nORDER BY rating_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6205": {
        "db_id": "food_inspection_2",
        "question": "Did license number 1222441 pass the inspection and what is the zip code number of it?",
        "ground_truth": "SELECT DISTINCT T2.results, T1.zip FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.license_no = 1222441",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_result, zip_code FROM inspections WHERE license_number = 1222441;"
        ],
        "rule_sql": []
    },
    "3024": {
        "db_id": "shakespeare",
        "question": "Describe the scene number, act, and title of work which had the description of \"The house of ANTIPHOLUS of Ephesus\" in chapter.",
        "ground_truth": "SELECT T2.Act, T2.Scene, T1.Title FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Description = 'The house of ANTIPHOLUS of Ephesus.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT scene_number, act, title FROM chapter WHERE description = 'The house of ANTIPHOLUS of Ephesus';"
        ],
        "rule_sql": []
    },
    "7749": {
        "db_id": "hockey",
        "question": "Between 1917 to 1920, what are the names of the team who ranked first in the first half of the season each year?",
        "ground_truth": "SELECT DISTINCT T2.name FROM TeamsHalf AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.half = 1 AND T1.rank = 1 AND T1.year BETWEEN 1917 AND 1920",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM team_rankings WHERE year BETWEEN 1917 AND 1920 AND half_season = 'first' AND rank = 1;"
        ],
        "rule_sql": []
    },
    "675": {
        "db_id": "codebase_comments",
        "question": "Provide the tokenized name of the method \"Sky.Excel.ExcelBook.TypeConvert\".",
        "ground_truth": "SELECT NameTokenized FROM Method WHERE Name = 'Sky.Excel.ExcelBook.TypeConvert'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM methods WHERE method_name = 'Sky.Excel.ExcelBook.TypeConvert'"
        ],
        "rule_sql": []
    },
    "2622": {
        "db_id": "regional_sales",
        "question": "Among the orders placed by Pacific Ltd, how many orders have been applied 5% discount ?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.`Discount Applied` = 0.05 AND T2.`Customer Names` = 'Pacific Ltd' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Pacific Ltd' AND discount = 5;"
        ],
        "rule_sql": []
    },
    "3260": {
        "db_id": "donor",
        "question": "What date did the project with he 'Lets Share Ideas essay' went live?",
        "ground_truth": "SELECT T1.date_posted FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T2.title LIKE 'Lets Share Ideas'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date FROM projects WHERE project_name = 'Lets Share Ideas essay';"
        ],
        "rule_sql": []
    },
    "1779": {
        "db_id": "restaurant",
        "question": "How many restaurants in Broadway, Oakland received a review of no more than 3?",
        "ground_truth": "SELECT COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.street_name = 'broadway' AND T2.review < 3 AND T1.city = 'oakland'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE address LIKE '%Broadway%' AND city = 'Oakland' AND review_score <= 3;"
        ],
        "rule_sql": []
    },
    "354": {
        "db_id": "retail_complains",
        "question": "Write down the call id of clients whose first name start with alphabet \"B\".",
        "ground_truth": "SELECT T2.call_id FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.first LIKE 'B%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT call_id FROM clients WHERE first_name LIKE 'B%';"
        ],
        "rule_sql": []
    },
    "154": {
        "db_id": "movie_platform",
        "question": "What is the name of the list that was updated most recently?",
        "ground_truth": "SELECT list_title FROM lists WHERE list_update_timestamp_utc = ( SELECT list_update_timestamp_utc FROM lists ORDER BY list_update_timestamp_utc DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM lists ORDER BY created_at DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "340": {
        "db_id": "retail_complains",
        "question": "Compute the average time in minute for each age group",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.age > 13 AND T1.age <= 19 THEN 60 * strftime('%H', ser_time) + strftime('%M', ser_time) + strftime('%S', ser_time) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.age > 13 AND T1.age <= 19 THEN 1 ELSE 0 END) AS teenagerAverageMins, CAST(SUM(CASE WHEN T1.age > 19 AND T1.age <= 65 THEN 60 * strftime('%H', ser_time) + strftime('%M', ser_time) + strftime('%S', ser_time) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.age > 19 AND T1.age <= 65 THEN 1 ELSE 0 END) AS adultAverageMins , CAST(SUM(CASE WHEN T1.age > 65 THEN 60 * strftime('%H', ser_time) + strftime('%M', ser_time) + strftime('%S', ser_time) / 60 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.age > 65 THEN 1 ELSE 0 END) AS elderAverageMins FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client`",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age, AVG(time) as average_time FROM users GROUP BY age;"
        ],
        "rule_sql": []
    },
    "5632": {
        "db_id": "shipping",
        "question": "State the weight of shipments transported by Peterbilt.",
        "ground_truth": "SELECT T2.weight FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE make = 'Peterbilt'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(weight) FROM shipments WHERE truck_brand = 'Peterbilt';"
        ],
        "rule_sql": []
    },
    "4001": {
        "db_id": "public_review_platform",
        "question": "Based on business in Phoenix, calculate the percentage of business with low funny votes.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.review_votes_funny = 'Low' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'Phoenix'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM business WHERE city = 'Phoenix')) AS percentage\nFROM business \nWHERE city = 'Phoenix' AND funny < 5;"
        ],
        "rule_sql": []
    },
    "5624": {
        "db_id": "shipping",
        "question": "Identify the full name of the driver who delivered a shipment to the city of New York in February 2016.",
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN driver AS T3 ON T3.driver_id = T1.driver_id WHERE T2.city_name = 'New York' AND T1.ship_date LIKE '2016-02%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM drivers WHERE city = 'New York' AND delivery_date LIKE '2016-02%';"
        ],
        "rule_sql": []
    },
    "302": {
        "db_id": "retail_complains",
        "question": "How many male clients born in the year 1977 were given priority 0 in their complaints?",
        "ground_truth": "SELECT COUNT(T1.sex) FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.sex = 'Male' AND T2.priority = 0 AND T1.year = 1997",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE gender = 'male' AND YEAR(birth_date) = 1977 AND priority = 0"
        ],
        "rule_sql": []
    },
    "8731": {
        "db_id": "chicago_crime",
        "question": "Who is responsible for crime cases in district Lincoln?",
        "ground_truth": "SELECT commander FROM District WHERE district_name = 'Lincoln'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT officer_name FROM crimes WHERE district = 'Lincoln';"
        ],
        "rule_sql": []
    },
    "6712": {
        "db_id": "retails",
        "question": "How many urgent orders were shipped the next day?",
        "ground_truth": "SELECT COUNT(T2.o_orderkey) FROM lineitem AS T1 INNER JOIN orders AS T2 ON T2.o_orderkey = T1.l_orderkey WHERE JULIANDAY(T1.l_shipdate) - JULIANDAY(T2.o_orderdate) = 1 AND T2.o_orderpriority = '1-URGENT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE priority = 'urgent' AND shipped_date = order_date + 1"
        ],
        "rule_sql": []
    },
    "5885": {
        "db_id": "airline",
        "question": "Provide the destinations of flight number 1596.",
        "ground_truth": "SELECT DEST FROM Airlines WHERE OP_CARRIER_FL_NUM = 1596",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination FROM flights WHERE flight_number = '1596';"
        ],
        "rule_sql": []
    },
    "7472": {
        "db_id": "works_cycles",
        "question": "What proportion of work order is in Subassembly?",
        "ground_truth": "SELECT 100.0 * SUM(CASE WHEN T1.Name = 'Subassembly' THEN 1 ELSE 0 END) / COUNT(T2.WorkOrderID) FROM Location AS T1 INNER JOIN WorkOrderRouting AS T2 ON T1.LocationID = T2.LocationID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) / (SELECT COUNT(*) FROM work_orders) AS proportion FROM work_orders WHERE department = 'Subassembly';"
        ],
        "rule_sql": []
    },
    "1008": {
        "db_id": "computer_student",
        "question": "List the course IDs and levels of person IDs from 40 to 50.",
        "ground_truth": "SELECT T1.course_id, T1.courseLevel FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE T2.p_id BETWEEN 40 AND 50",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id, level FROM persons WHERE person_id BETWEEN 40 AND 50"
        ],
        "rule_sql": []
    },
    "4683": {
        "db_id": "disney",
        "question": "Provide the movie titles and the estimated inflation rate of the highest total grossed movie.",
        "ground_truth": "SELECT movie_title, CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) / CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL) FROM movies_total_gross ORDER BY CAST(REPLACE(trim(total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, inflation_rate \nFROM movies \nORDER BY total_gross DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "475": {
        "db_id": "movies_4",
        "question": "List all companies who worked in the movie 'Ultramarines: A Warhammer 40,000 Movie.'",
        "ground_truth": "SELECT T1.company_name FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T3.title = 'Ultramarines: A Warhammer 40,000 Movie'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT company_name FROM companies WHERE movie_title = 'Ultramarines: A Warhammer 40,000 Movie';"
        ],
        "rule_sql": []
    }
}