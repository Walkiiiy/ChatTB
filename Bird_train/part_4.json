{
    "4335": {
        "db_id": "simpson_episodes",
        "question": "List out the birth name of crews who are co-executive producer and higher than 1.60 meters.",
        "ground_truth": "SELECT T1.birth_name FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.role = 'co-executive producer' AND T1.height_meters > 1.60;",
        "amends": [
            "Do select `T1.birth_name` from the `Person` table instead of `birth_name` from the `crews` table. Do use `INNER JOIN` with `Award` table on `T1.name = T2.person` instead of querying only one table. Do reference `T1.height_meters` instead of `height` and do filter by `T2.role = 'co-executive producer'` instead of filtering role directly on the main table. The amended query now correctly joins person and award data to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_name FROM crews WHERE role = 'co-executive producer' AND height > 1.60;",
            "SELECT T1.birth_name FROM Person T1 INNER JOIN Award T2 ON T1.name = T2.person WHERE T1.height_meters > 1.60 AND T2.role = 'co-executive producer'"
        ],
        "rule_sql": []
    },
    "6292": {
        "db_id": "coinmarketcap",
        "question": "When was Lebowskis not opened?",
        "ground_truth": "SELECT DISTINCT T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Lebowskis' AND (T2.open IS NULL OR T2.open = 0)",
        "amends": [
            "Do select `DISTINCT T2.date` instead of `opening_date`. Do use `coins AS T1 INNER JOIN historical AS T2` instead of `FROM restaurants`. Do apply join condition `ON T1.id = T2.coin_id` instead of no join. Do filter with `T1.name = 'Lebowskis'` instead of `name = 'Lebowskis'`. Do add complex filter `(T2.open IS NULL OR T2.open = 0)` instead of `status = 'open'`. Do remove the simple status filter and replace it with a NULL/zero check on the joined table's open column. The amended query now correctly retrieves distinct historical dates for coins matching the name with specific open status conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT opening_date FROM restaurants WHERE name = 'Lebowskis' AND status = 'open';",
            "SELECT DISTINCT T2.date\nFROM coins AS T1\nINNER JOIN historical AS T2 ON T1.id = T2.coin_id\nWHERE T1.name = 'Lebowskis'\nAND (T2.open IS NULL OR T2.open = 0)"
        ],
        "rule_sql": []
    },
    "7710": {
        "db_id": "hockey",
        "question": "Which is the catching hand for the goaltender who had the most shutouts in 1996?",
        "ground_truth": "SELECT T1.shootCatch FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 1996 ORDER BY T2.SHO DESC LIMIT 1",
        "amends": [
            "Do select `T1.shootCatch` instead of `catching_hand` and use table aliases `T1` and `T2` instead of bare table names. Do join `Master AS T1` and `Goalies AS T2` with an `INNER JOIN` on `T1.playerID = T2.playerID` instead of querying only the `goaltenders` table. Do filter on `T2.year = 1996` instead of `year = 1996` to specify the table source. Do order by `T2.SHO DESC` instead of `shutouts DESC` using the correct column name and table alias. The amended query now correctly retrieves the shooting/catching hand from the Master table joined with goalie statistics from the Goalies table for the specified year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT catching_hand \nFROM goaltenders \nWHERE year = 1996 \nORDER BY shutouts DESC \nLIMIT 1;",
            "SELECT T1.shootCatch \nFROM Master AS T1 \nINNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID \nWHERE T2.year = 1996 \nORDER BY CAST(T2.SHO AS INTEGER) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2340": {
        "db_id": "movielens",
        "question": "How many horror movies were made by the worst directors?",
        "ground_truth": "SELECT COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T1.directorid = T3.directorid WHERE T1.genre = 'horror' AND T3.d_quality = 0",
        "amends": [
            "Do count `T1.movieid` instead of `COUNT(*)` and use `movies2directors AS T1` as the primary table instead of `movies m`. Do `INNER JOIN movies AS T2` on `T1.movieid = T2.movieid` instead of joining directly to directors, and add `INNER JOIN directors AS T3` on `T1.directorid = T3.directorid` instead of `m.director_id = d.director_id`. Do filter on `T1.genre = 'horror'` instead of `m.genre = 'Horror'` and add `T3.d_quality = 0` instead of omitting it. Do remove `ORDER BY d.rating ASC` and `LIMIT 1` instead of keeping them. The amended query now correctly counts horror movies from the junction table with quality filtering instead of attempting to order and limit a count aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM movies m\nJOIN directors d ON m.director_id = d.director_id\nWHERE m.genre = 'Horror'\nORDER BY d.rating ASC\nLIMIT 1;",
            "SELECT COUNT(T1.movieid) \nFROM movies2directors AS T1\nINNER JOIN movies AS T2 ON T1.movieid = T2.movieid\nINNER JOIN directors AS T3 ON T1.directorid = T3.directorid\nWHERE T1.genre = 'horror' AND T3.d_quality = 0"
        ],
        "rule_sql": []
    },
    "3163": {
        "db_id": "donor",
        "question": "How many schools in the West New York School District have the highest poverty level?",
        "ground_truth": "SELECT COUNT(poverty_level) FROM projects WHERE school_district = 'West New York School District' AND poverty_level = 'highest poverty'",
        "amends": [
            "Do select `COUNT(poverty_level)` instead of `COUNT(*)` to count non-null values of a specific column. Do query from `projects` table instead of `schools` to use the correct data source. Do filter on `school_district = 'West New York School District'` instead of `district = 'West New York School District'` to use the proper column name for district filtering. Do use direct equality filter `poverty_level = 'highest poverty'` instead of a subquery `(SELECT MAX(poverty_level) FROM schools)` to match the exact poverty level category rather than finding the maximum numeric value. The amended query now correctly counts projects in the specified district with the highest poverty classification."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools \nWHERE district = 'West New York School District' \nAND poverty_level = (SELECT MAX(poverty_level) FROM schools)",
            "SELECT COUNT(poverty_level) FROM projects WHERE school_district = 'West New York School District' AND poverty_level = 'highest poverty'"
        ],
        "rule_sql": []
    },
    "5253": {
        "db_id": "beer_factory",
        "question": "Show the credit card number of Lisa Ling.",
        "ground_truth": "SELECT DISTINCT T2.CreditCardNumber FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.First = 'Lisa' AND T1.Last = 'Ling'",
        "amends": [
            "Do select `T2.CreditCardNumber` instead of `credit_card_number` and add `DISTINCT` instead of omitting it. Do join `transaction AS T2` with `customers AS T1` using `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do filter on `T1.First = 'Lisa'` and `T1.Last = 'Ling'` instead of `first_name = 'Lisa'` and `last_name = 'Ling'`. The amended query now correctly retrieves distinct credit card numbers from the transaction table for the specified customer instead of potentially returning duplicate or incorrect results from the customer table directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_card_number FROM customers WHERE first_name = 'Lisa' AND last_name = 'Ling';",
            "SELECT DISTINCT T2.CreditCardNumber\nFROM customers AS T1\nINNER JOIN \"transaction\" AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.First = 'Lisa' AND T1.Last = 'Ling'"
        ],
        "rule_sql": []
    },
    "3754": {
        "db_id": "college_completion",
        "question": "What is the name of the school with the highest number of first-time, full-time, degree-seeking female students in the cohort being tracked, minus any exclusions who were seeking another type of degree or certificate at a 4-year institution?",
        "ground_truth": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.gender = 'F' AND T2.cohort = '4y other' ORDER BY T2.grad_cohort DESC LIMIT 1",
        "amends": [
            "Do select `T1.chronname` instead of `name` and use table aliases throughout. Do join `institution_details AS T1` with `institution_grads AS T2` on `T2.unitid = T1.unitid` instead of querying only the `schools` table. Do add WHERE filters for `T2.gender = 'F'` and `T2.cohort = '4y other'` instead of omitting these conditions. Do order by `T2.grad_cohort DESC` instead of `female_students DESC` while maintaining the same LIMIT clause. The amended query now correctly filters for female graduates from 4-year other cohorts and orders by graduation cohort instead of a generic female student count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM schools ORDER BY female_students DESC LIMIT 1;",
            "SELECT T1.chronname\nFROM institution_details AS T1\nJOIN institution_grads AS T2 ON T2.unitid = T1.unitid\nWHERE T2.gender = 'F' AND T2.cohort = '4y other'\nORDER BY T2.grad_cohort DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6923": {
        "db_id": "ice_hockey_draft",
        "question": "What is the weight of the player with the longest time on ice in the player\u2019s first 7 years of NHL career in kilograms?",
        "ground_truth": "SELECT T2.weight_in_kg FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T1.sum_7yr_TOI = ( SELECT MAX(t.sum_7yr_TOI) FROM PlayerInfo t )",
        "amends": [
            "Do select `T2.weight_in_kg` from `PlayerInfo AS T1` instead of `weight_kg` from `players`. Do add `INNER JOIN weight_info AS T2` on `T1.weight = T2.weight_id` instead of omitting the join. Do change the WHERE filter to `T1.sum_7yr_TOI = (SELECT MAX(t.sum_7yr_TOI) FROM PlayerInfo t)` instead of `time_on_ice = (SELECT MAX(time_on_ice) FROM players)`. Do remove the `AND years_in_nhl <= 7` condition instead of keeping it. The amended query now correctly joins the weight information table and uses the proper column names and aggregation logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT weight_kg \nFROM players \nWHERE time_on_ice = (SELECT MAX(time_on_ice) FROM players) \nAND years_in_nhl <= 7;",
            "SELECT T2.weight_in_kg \nFROM PlayerInfo AS T1 \nINNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id \nWHERE T1.sum_7yr_TOI = (SELECT MAX(t.sum_7yr_TOI) FROM PlayerInfo t)"
        ],
        "rule_sql": []
    },
    "6622": {
        "db_id": "retail_world",
        "question": "How many suppliers are from UK?",
        "ground_truth": "SELECT COUNT(SupplierID) FROM Suppliers WHERE Country = 'UK'",
        "amends": [
            "Do count `SupplierID` instead of `*` to exclude NULL values. Do filter on `Country = 'UK'` instead of `'USA'` to target different geographic suppliers. The amended query now correctly counts UK suppliers while ignoring NULL SupplierID values, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE country = 'USA';",
            "SELECT COUNT(SupplierID) FROM Suppliers WHERE Country = 'UK';"
        ],
        "rule_sql": []
    },
    "7746": {
        "db_id": "hockey",
        "question": "In 1997, how many loss did the coach have who temporary coached Tampa Bay Lightning? Indicate his/her coach ID.",
        "ground_truth": "SELECT SUM(T1.l), T1.coachID FROM Coaches AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.notes = 'interim' AND T1.year = '1997' AND T2.name = 'Tampa Bay Lightning' GROUP BY T1.coachID",
        "amends": [
            "Do use `SUM(T1.l)` and `T1.coachID` in the SELECT list instead of `coachID, losses` to aggregate losses by coach. Do join `Coaches AS T1` with `Teams AS T2` on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of querying only the coaches table. Do filter with `T1.notes = 'interim'` instead of `temporary = 1` to identify interim coaches. Do filter with `T2.name = 'Tampa Bay Lightning'` instead of `team = 'Tampa Bay Lightning'` to reference the team name correctly. Do add `GROUP BY T1.coachID` instead of omitting aggregation grouping. Do remove the direct year comparison in WHERE and instead use the join condition for year matching. The amended query now correctly aggregates interim coach losses for the specified team and year, matching the intended behavior.",
            "Do place `SUM(T1.l)` before `T1.coachID` in the SELECT list instead of the reverse order. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use string literal `'1997'` instead of integer `1997` for the year filter. Do move the `T1.year` filter from the JOIN condition to the WHERE clause instead of keeping it in both places. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering, explicit join type, consistent data type handling, and optimized predicate placement."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coachID, losses \nFROM coaches \nWHERE team = 'Tampa Bay Lightning' \nAND year = 1997 \nAND temporary = 1;",
            "SELECT T1.coachID, SUM(T1.l) AS losses\nFROM Coaches AS T1\nJOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.notes = 'interim'\nAND T2.name = 'Tampa Bay Lightning'\nAND T1.year = 1997\nGROUP BY T1.coachID",
            "SELECT SUM(T1.l) AS total_losses, T1.coachID\nFROM Coaches AS T1\nINNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.year = '1997'\n  AND T2.name = 'Tampa Bay Lightning'\n  AND T1.notes = 'interim'\nGROUP BY T1.coachID"
        ],
        "rule_sql": []
    },
    "7301": {
        "db_id": "works_cycles",
        "question": "Please list the email adresses of the reviewers who have given the lowest rating to the product HL Mountain Pedal.",
        "ground_truth": "SELECT T1.EmailAddress FROM ProductReview AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'HL Mountain Pedal' ORDER BY T1.Rating LIMIT 1",
        "amends": [
            "Do select `T1.EmailAddress` instead of `email` and add `ORDER BY T1.Rating LIMIT 1` instead of using a subquery with `MIN(rating)`. Do use `FROM ProductReview AS T1 INNER JOIN Product AS T2` instead of `FROM reviewers` alone, adding the join condition `ON T1.ProductID = T2.ProductID` instead of omitting the table join. Do move the product filter to `WHERE T2.Name = 'HL Mountain Pedal'` instead of `WHERE product_name = 'HL Mountain Pedal'` and remove the subquery approach for finding minimum rating. The amended query now correctly joins the necessary tables and uses ORDER BY with LIMIT to find the lowest-rated reviewer for the specified product, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM reviewers WHERE rating = (SELECT MIN(rating) FROM reviewers) AND product_name = 'HL Mountain Pedal';",
            "SELECT T1.EmailAddress \nFROM ProductReview AS T1 \nINNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID \nWHERE T2.Name = 'HL Mountain Pedal' \nORDER BY T1.Rating \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7826": {
        "db_id": "world",
        "question": "What is the capital city and population of San Marino?",
        "ground_truth": "SELECT T1.Capital, T2.Population FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'San Marino'",
        "amends": [
            "Do select `T1.Capital` and `T2.Population` instead of `name` and `population`. Do use `INNER JOIN` between `Country AS T1` and `City AS T2` instead of querying only `cities`. Do join on `T1.Code = T2.CountryCode` instead of filtering by `country = 'San Marino'`. Do filter with `T1.Name = 'San Marino'` instead of `country = 'San Marino' AND is_capital = 1`. Do remove the `is_capital` filter entirely instead of keeping it, as the join logic now correctly identifies the capital city. The amended query now correctly retrieves the capital city's population for San Marino by properly joining country and city tables.",
            "Do select `T1.Capital` instead of `T2.Name AS Capital` to use the country's capital ID directly from the Country table rather than the city name. Do change the join condition to `ON T1.Code = T2.CountryCode` instead of `ON T1.Capital = T2.ID` to properly join countries with their cities using the country code rather than incorrectly matching capital ID with city ID. The amended query now correctly retrieves the capital city information by establishing the proper relationship between countries and cities.",
            "Do select `T1.Capital` instead of `T2.Name AS Capital` to reference the capital ID directly from the Country table rather than the city name. Do change the join condition to `ON T1.Code = T2.CountryCode` instead of `ON T1.Capital = T2.ID` to properly join countries with their cities using the country code rather than incorrectly matching capital IDs with city IDs. The amended query now correctly retrieves the capital city information by establishing the proper relationship between countries and cities."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population FROM cities WHERE country = 'San Marino' AND is_capital = 1;",
            "SELECT T2.Name AS Capital, T2.Population \nFROM Country AS T1 \nINNER JOIN City AS T2 ON T1.Capital = T2.ID \nWHERE T1.Name = 'San Marino'",
            "SELECT T2.Name AS Capital, T2.Population \nFROM Country AS T1 \nINNER JOIN City AS T2 ON T1.Capital = T2.ID \nWHERE T1.Name = 'San Marino'",
            "SELECT T1.Capital, T2.Population \nFROM Country AS T1 \nINNER JOIN City AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Name = 'San Marino'"
        ],
        "rule_sql": []
    },
    "2230": {
        "db_id": "world_development_indicators",
        "question": "What is the average number of passengers carried via air transport per year by Bulgaria between 1970 to 1980? Indicate the country's system of trade.",
        "ground_truth": "SELECT AVG(T1.Value), T2.SystemOfTrade FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IndicatorName = 'Air transport, passengers carried' AND T1.Year >= 1970 AND T1.Year < 1981 AND T1.CountryName = 'Bulgaria'",
        "amends": [
            "Do use `AVG(T1.Value)` and `T2.SystemOfTrade` in the SELECT list instead of `AVG(passengers) as avg_passengers`, `'Bulgaria' as country`, and `'Mixed economy' as trade_system`. Do join `Indicators AS T1` with `Country AS T2` using `INNER JOIN` on `T1.CountryCode = T2.CountryCode` instead of querying only `air_transport` without any joins. Do filter with `T1.IndicatorName = 'Air transport, passengers carried'` instead of omitting this indicator condition. Do use `T1.Year >= 1970 AND T1.Year < 1981` for the year range instead of `year BETWEEN 1970 AND 1980`. Do filter with `T1.CountryName = 'Bulgaria'` instead of `country = 'Bulgaria'`. Do remove the `GROUP BY country` clause instead of keeping it since the aggregation is now properly scoped by the join and filters. The amended query now correctly retrieves average passengers from the Indicators table joined with Country data using proper join conditions and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    AVG(passengers) as avg_passengers,\n    'Bulgaria' as country,\n    'Mixed economy' as trade_system\nFROM air_transport\nWHERE country = 'Bulgaria' \n    AND year BETWEEN 1970 AND 1980\nGROUP BY country;",
            "SELECT AVG(T1.Value) AS avg_passengers, T2.SystemOfTrade\nFROM Indicators AS T1\nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T1.IndicatorName = 'Air transport, passengers carried'\nAND T1.Year >= 1970 AND T1.Year < 1981\nAND T1.CountryName = 'Bulgaria'"
        ],
        "rule_sql": []
    },
    "4742": {
        "db_id": "legislator",
        "question": "What is the username of the current official Facebook presence of current legislator Todd Young?",
        "ground_truth": "SELECT T1.facebook FROM `social-media` AS T1 INNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide WHERE T2.official_full_name = 'Todd Young'",
        "amends": [
            "Do select `T1.facebook` instead of `username` and use table alias `T1` instead of full table name. Do use `INNER JOIN` on `current AS T2` instead of joining `social_media` and change the join predicate to `T2.bioguide_id = T1.bioguide` instead of `legislators.id = social_media.legislator_id`. Do filter on `T2.official_full_name = 'Todd Young'` instead of `legislators.name = 'Todd Young'` and remove the platform-specific filter `social_media.platform = 'Facebook'` and status filters `social_media.is_official = 1 AND social_media.is_current = 1` instead of keeping them. The amended query now correctly retrieves Facebook information from the restructured schema using bioguide_id matching instead of legislator_id."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT username FROM legislators JOIN social_media ON legislators.id = social_media.legislator_id WHERE legislators.name = 'Todd Young' AND social_media.platform = 'Facebook' AND social_media.is_official = 1 AND social_media.is_current = 1;",
            "SELECT T1.facebook \nFROM \"social-media\" AS T1 \nINNER JOIN current AS T2 ON T2.bioguide_id = T1.bioguide \nWHERE T2.official_full_name = 'Todd Young'"
        ],
        "rule_sql": []
    },
    "9328": {
        "db_id": "movie_3",
        "question": "Please provide the address of the customer whose first name is SUSAN with the postal code 77948.",
        "ground_truth": "SELECT T1.address FROM address AS T1 INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE T2.first_name = 'SUSAN' AND T1.postal_code = 77948",
        "amends": [
            "Do select `T1.address` from the `address` table instead of selecting `address` from the `customers` table. Do add an `INNER JOIN` between `address AS T1` and `customer AS T2` on `T1.address_id = T2.address_id` instead of querying a single table. Do reference the `first_name` filter on `T2.first_name` instead of applying it directly to a non-existent column in the original table. Do use the numeric value `77948` without quotes for the `postal_code` filter instead of the string `'77948'`, and apply it to `T1.postal_code` instead of an incorrect column reference. The amended query now correctly joins the address and customer tables to find Susan's address based on the proper relational structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM customers WHERE first_name = 'SUSAN' AND postal_code = '77948';",
            "SELECT T1.address FROM address AS T1 INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE T2.first_name = 'SUSAN' AND T1.postal_code = 77948"
        ],
        "rule_sql": []
    },
    "8610": {
        "db_id": "chicago_crime",
        "question": "How many simple assaults happened on 2018/9/8?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.secondary_description = 'SIMPLE' THEN 1 ELSE 0 END) FROM Crime AS T1 INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no WHERE T1.date LIKE '%9/8/2018%' AND T2.primary_description = 'ASSAULT'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.secondary_description = 'SIMPLE' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific records. Do join `Crime AS T1 INNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no` instead of querying a single `assaults` table. Do filter with `T1.date LIKE '%9/8/2018%'` instead of `date = '2018/9/8'` to match the date format pattern. Do use `T2.primary_description = 'ASSAULT'` instead of `type = 'simple'` to filter by the correct column and value. The amended query now correctly counts assault incidents with specific secondary descriptions from the proper joined tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM assaults WHERE date = '2018/9/8' AND type = 'simple'",
            "SELECT SUM(CASE WHEN T2.secondary_description = 'SIMPLE' THEN 1 ELSE 0 END) AS simple_assaults_count\nFROM Crime AS T1\nINNER JOIN IUCR AS T2 ON T1.iucr_no = T2.iucr_no\nWHERE T1.date LIKE '%9/8/2018%'\nAND T2.primary_description = 'ASSAULT';"
        ],
        "rule_sql": []
    },
    "7712": {
        "db_id": "hockey",
        "question": "For he who had the highest plus / minus on the court in the 1981 season, what's his full name?",
        "ground_truth": "SELECT T1.firstName, T1.lastName FROM Master AS T1 INNER JOIN Scoring AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 1981 GROUP BY T2.playerID ORDER BY SUM(T2.`+/-`) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name FROM players WHERE season = 1981 ORDER BY plus_minus DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2895": {
        "db_id": "professional_basketball",
        "question": "List the full name of players who are drafted from round 1 in 1973 but not born in USA.",
        "ground_truth": "SELECT T1.firstName, T1.middleName, T1.lastName FROM players AS T1 INNER JOIN draft AS T2 ON T1.playerID = T2.playerID WHERE T2.draftRound = 1 AND T1.birthCountry != 'USA' AND T2.draftYear = 1973",
        "amends": [
            "Do add `T1.middleName` to the SELECT list instead of omitting it. Do change the FROM clause to use `INNER JOIN draft AS T2 ON T1.playerID = T2.playerID` instead of querying only the players table. Do change the country filter to use `T1.birthCountry != 'USA'` instead of `country != 'USA'`. Do move the draft-related filters to reference the joined draft table with `T2.draftRound = 1` and `T2.draftYear = 1973` instead of using direct column references from the players table. The amended query now correctly joins the players and draft tables to filter on draft-specific attributes while maintaining the birth country filter on the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM players WHERE draft_round = 1 AND draft_year = 1973 AND country != 'USA';",
            "SELECT T1.firstName, T1.middleName, T1.lastName\nFROM players AS T1\nINNER JOIN draft AS T2 ON T1.playerID = T2.playerID\nWHERE T2.draftRound = 1\nAND T2.draftYear = 1973\nAND T1.birthCountry != 'USA';"
        ],
        "rule_sql": []
    },
    "5454": {
        "db_id": "sales",
        "question": "What are the full names of the top 3 employees who handled the highest number of sales?",
        "ground_truth": "SELECT T1.FirstName, T1.MiddleInitial, T1.LastName FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID GROUP BY T2.SalesPersonID, T1.FirstName, T1.MiddleInitial, T1.LastName ORDER BY COUNT(T2.SalesID) DESC LIMIT 3",
        "amends": [
            "Do add `T1.MiddleInitial` to the SELECT list instead of omitting it. Do change the FROM clause to use `INNER JOIN Sales AS T2` instead of querying only the `employees` table. Do add the join condition `ON T1.EmployeeID = T2.SalesPersonID` instead of having no join. Do add `GROUP BY T2.SalesPersonID, T1.FirstName, T1.MiddleInitial, T1.LastName` instead of no grouping. Do change the ORDER BY to use `COUNT(T2.SalesID) DESC` instead of `sales_count DESC`. The amended query now correctly joins employee and sales data, groups by salesperson to count sales, and orders by the actual sales count instead of a potentially incorrect sales_count field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY sales_count DESC LIMIT 3;",
            "SELECT T1.FirstName, T1.MiddleInitial, T1.LastName\nFROM Employees AS T1\nINNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID\nGROUP BY T2.SalesPersonID, T1.FirstName, T1.MiddleInitial, T1.LastName\nORDER BY COUNT(T2.SalesID) DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "4963": {
        "db_id": "olympics",
        "question": "In which Olympic Games have the largest number of women participation?",
        "ground_truth": "SELECT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.gender = 'F' GROUP BY T1.games_name ORDER BY COUNT(T2.person_id) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `games AS T1` with `games_competitor AS T2` on `T1.id = T2.games_id` instead of querying `athlete_events` directly. Do add a second join to `person AS T3` on `T2.person_id = T3.id` instead of missing this relationship. Do filter on `T3.gender = 'F'` instead of `Sex = 'F'` to use the correct column name. Do group by `T1.games_name` instead of `Games` to use the proper column reference. Do order by `COUNT(T2.person_id)` instead of the alias `women_count` to reference the actual aggregate. Do maintain the `DESC` ordering and `LIMIT 1` clause as in the original query. The amended query now correctly joins through the proper table relationships and uses the appropriate column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Games, COUNT(*) as women_count \nFROM athlete_events \nWHERE Sex = 'F' \nGROUP BY Games \nORDER BY women_count DESC \nLIMIT 1;",
            "SELECT T1.games_name\nFROM games AS T1\nJOIN games_competitor AS T2 ON T1.id = T2.games_id\nJOIN person AS T3 ON T2.person_id = T3.id\nWHERE T3.gender = 'F'\nGROUP BY T1.games_name\nORDER BY COUNT(T2.person_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9006": {
        "db_id": "bike_share_1",
        "question": "How long did it take for bike id 426 to reach 2nd at South Park from Market at 4th on 8/29/2013? Indicate the duration in minutes.",
        "ground_truth": "SELECT CAST(duration AS REAL) / 60  FROM trip WHERE bike_id = 426 AND end_station_name = '2nd at South Park' AND start_station_name = 'Market at 4th' AND start_date LIKE '8/29/2013%' AND end_date LIKE '8/29/2013%'",
        "amends": [
            "Do calculate duration using `CAST(duration AS REAL) / 60` instead of computing `(end_time - start_time)` as duration_minutes. Do query from table `trip` instead of `bike_trips`. Do filter on `end_station_name` and `start_station_name` columns instead of `end_station` and `start_station`. Do use date filters with `start_date LIKE '8/29/2013%'` and `end_date LIKE '8/29/2013%'` instead of `date(start_time) = '2013-08-29'`. Do remove the alias `AS duration_minutes` instead of keeping it. The amended query now correctly handles the duration calculation and date filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (end_time - start_time) AS duration_minutes \nFROM bike_trips \nWHERE bike_id = 426 \nAND start_station = 'Market at 4th' \nAND end_station = '2nd at South Park' \nAND date(start_time) = '2013-08-29';",
            "SELECT CAST(duration AS REAL) / 60 FROM trip WHERE bike_id = 426 AND start_station_name = 'Market at 4th' AND end_station_name = '2nd at South Park' AND start_date LIKE '8/29/2013%' AND end_date LIKE '8/29/2013%'"
        ],
        "rule_sql": []
    },
    "376": {
        "db_id": "retail_complains",
        "question": "Please list all first and last names of clients who live in New York city.",
        "ground_truth": "SELECT first, last FROM client WHERE city = 'New York City'",
        "amends": [
            "Do use column names `first` and `last` instead of `first_name` and `last_name`. Do reference table `client` instead of `clients`. Do filter for city `'New York City'` instead of `'Los Angeles'`. The amended query now correctly selects from the intended table with the proper column names and city filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE city = 'Los Angeles';",
            "SELECT first, last FROM client WHERE city = 'New York City';"
        ],
        "rule_sql": []
    },
    "5882": {
        "db_id": "airline",
        "question": "What is the airport description of the airport code A11?",
        "ground_truth": "SELECT Description FROM Airports WHERE Code = 'A11'",
        "amends": [
            "Do reference column `Description` instead of `description` to match the correct case sensitivity. Do reference column `Code` instead of `airport_code` to use the proper column name. Do reference table `Airports` instead of `airports` to match the correct table name case. The amended query now correctly retrieves the description from the Airports table using the proper column and table names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM airports WHERE airport_code = 'A11';",
            "SELECT Description FROM Airports WHERE Code = 'A11';"
        ],
        "rule_sql": []
    },
    "1591": {
        "db_id": "car_retails",
        "question": "For the planes which has the hightest total price, how much it exceeds the average?",
        "ground_truth": "SELECT MAX(quantityOrdered * priceEach) - AVG(priceEach) FROM orderdetails WHERE productCode IN ( SELECT productCode FROM products WHERE productLine = 'Planes' )",
        "amends": [
            "Do calculate `MAX(quantityOrdered * priceEach) - AVG(priceEach)` instead of `MAX(total_price) - AVG(total_price)` for the excess amount calculation. Do use the `orderdetails` table instead of `planes` as the main data source. Do filter with `WHERE productCode IN (SELECT productCode FROM products WHERE productLine = 'Planes')` instead of `WHERE total_price = (SELECT MAX(total_price) FROM planes)` to properly identify plane-related products. Do remove the incorrect subquery that compared against maximum total price instead of filtering by product line. Do add the necessary join logic implicitly through the subquery correlation instead of directly querying a non-existent planes table. The amended query now correctly calculates price differences for plane products by joining order details with product information.",
            "Do calculate the excess amount using `MAX(quantityOrdered * priceEach) - AVG(priceEach)` instead of `MAX(quantityOrdered * priceEach) - AVG(quantityOrdered * priceEach)` by removing the `quantityOrdered` multiplication from the AVG function. The amended query now correctly computes the difference between maximum order value and average price per unit for plane products, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(total_price) - AVG(total_price) AS excess_amount\nFROM planes\nWHERE total_price = (SELECT MAX(total_price) FROM planes);",
            "SELECT \n    MAX(quantityOrdered * priceEach) - AVG(quantityOrdered * priceEach) AS excess_amount\nFROM \n    orderdetails\nWHERE \n    productCode IN (SELECT productCode FROM products WHERE productLine = 'Planes')",
            "SELECT \n    MAX(quantityOrdered * priceEach) - AVG(priceEach) AS excess_amount\nFROM \n    orderdetails\nWHERE \n    productCode IN (SELECT productCode FROM products WHERE productLine = 'Planes')"
        ],
        "rule_sql": []
    },
    "2489": {
        "db_id": "genes",
        "question": "For the genes that are located in the plasma membrane, please list their number of chromosomes.",
        "ground_truth": "SELECT T1.Chromosome FROM Genes AS T1 INNER JOIN Classification AS T2 ON T1.GeneID = T2.GeneID WHERE T2.Localization = 'plasma membrane'",
        "amends": [
            "Do specify `T1.Chromosome` in the SELECT list instead of `chromosome` and remove the `COUNT(*)` aggregation instead of keeping it. Do change the FROM clause to use `Genes AS T1 INNER JOIN Classification AS T2` instead of just `genes` and add the join condition `ON T1.GeneID = T2.GeneID` instead of omitting it. Do change the WHERE filter to use `T2.Localization = 'plasma membrane'` instead of `location = 'cytoplasm'` and remove the GROUP BY clause instead of keeping `GROUP BY chromosome`. The amended query now correctly joins the Classification table to filter by plasma membrane localization instead of cytoplasm location and returns individual chromosome values rather than counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT chromosome, COUNT(*) FROM genes WHERE location = 'cytoplasm' GROUP BY chromosome;",
            "SELECT T1.Chromosome \nFROM Genes AS T1 \nINNER JOIN Classification AS T2 ON T1.GeneID = T2.GeneID \nWHERE T2.Localization = 'plasma membrane'"
        ],
        "rule_sql": []
    },
    "2589": {
        "db_id": "regional_sales",
        "question": "Among the sales order shipped in July 2018, calculate the percentage of orders for home fragrances.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.`Product Name` = 'Home Fragrances' THEN 1 ELSE 0 END) * 100 / COUNT(T1.OrderNumber)  FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T1.ShipDate LIKE '7/%/18'",
        "amends": [
            "Do join `Products` table as `T2` with `INNER JOIN` on `T2.ProductID = T1._ProductID` instead of querying only `sales_orders` table. Do use `SUM(CASE WHEN T2.Product Name = 'Home Fragrances' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN product_category = 'Home Fragrances' THEN 1 END)` for percentage calculation. Do reference `T1.OrderNumber` in `COUNT()` instead of `COUNT(*)` to count orders rather than rows. Do filter on `T1.ShipDate LIKE '7/%/18'` instead of `shipped_date BETWEEN '2018-07-01' AND '2018-07-31'` for July 2018 dates. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly calculates the percentage of Home Fragrances products in July 2018 orders by properly joining with the Products table and using appropriate counting logic.",
            "Do remove the alias `Percentage` instead of keeping it, and do remove the parentheses around the calculation instead of including them. Do use backticks for table names `Sales Orders` and `Products` instead of double quotes, and do add the `AS` keyword for table aliases instead of omitting it. Do use backticks for column name `Product Name` instead of double quotes. The amended query now matches RIGHT_SQL's behavior.",
            "Do use `SUM(CASE WHEN T2.Product Name = 'Home Fragrances' THEN 1 ELSE 0 END) * 100 / COUNT(T1.OrderNumber)` instead of wrapping the entire expression in parentheses. Do maintain the same `INNER JOIN` on `T2.ProductID = T1._ProductID` and `WHERE` filter on `T1.ShipDate LIKE '7/%/18'` without changes. The amended query now matches RIGHT_SQL's behavior by removing unnecessary parentheses while preserving the same calculation logic.",
            "Do use `SUM(CASE WHEN T2.Product Name = 'Home Fragrances' THEN 1 ELSE 0 END) * 100 / COUNT(T1.OrderNumber)` instead of wrapping the entire expression in parentheses. Do maintain the same `INNER JOIN` on `T2.ProductID = T1._ProductID` and `WHERE` filter on `T1.ShipDate LIKE '7/%/18'` without changes. The amended query now matches RIGHT_SQL's behavior by removing unnecessary parentheses while preserving the same calculation logic."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN product_category = 'Home Fragrances' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM sales_orders\nWHERE shipped_date BETWEEN '2018-07-01' AND '2018-07-31';",
            "SELECT \n    (SUM(CASE WHEN T2.\"Product Name\" = 'Home Fragrances' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.OrderNumber)) AS Percentage\nFROM \n    \"Sales Orders\" T1\nINNER JOIN \n    Products T2 ON T2.ProductID = T1._ProductID\nWHERE \n    T1.ShipDate LIKE '7/%/18'",
            "SELECT \n    (SUM(CASE WHEN T2.`Product Name` = 'Home Fragrances' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.OrderNumber)) \nFROM \n    `Sales Orders` AS T1\nINNER JOIN \n    `Products` AS T2 ON T2.ProductID = T1._ProductID\nWHERE \n    T1.ShipDate LIKE '7/%/18'",
            "SELECT \n    (SUM(CASE WHEN T2.`Product Name` = 'Home Fragrances' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.OrderNumber)) \nFROM \n    `Sales Orders` AS T1\nINNER JOIN \n    `Products` AS T2 ON T2.ProductID = T1._ProductID\nWHERE \n    T1.ShipDate LIKE '7/%/18'",
            "SELECT \n    SUM(CASE WHEN T2.`Product Name` = 'Home Fragrances' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.OrderNumber) AS Percentage\nFROM \n    `Sales Orders` AS T1\nINNER JOIN \n    `Products` AS T2 ON T2.ProductID = T1._ProductID\nWHERE \n    T1.ShipDate LIKE '7/%/18'"
        ],
        "rule_sql": []
    },
    "6931": {
        "db_id": "ice_hockey_draft",
        "question": "Among the players whose total NHL games played in their first 7 years of NHL career is no less than 500, what is the name of the player who committed the most rule violations?",
        "ground_truth": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.sum_7yr_GP > 500 ORDER BY T2.PIM DESC LIMIT 1",
        "amends": [
            "Do select `T1.PlayerName` instead of `p.name, COUNT(pv.player_id) as violations`. Do use `FROM PlayerInfo AS T1` and `INNER JOIN SeasonStatus AS T2` instead of `FROM players p` and `JOIN player_violations pv`. Do join on `T1.ELITEID = T2.ELITEID` instead of `p.player_id = pv.player_id`. Do filter with `WHERE T1.sum_7yr_GP > 500` instead of `WHERE p.games_played >= 500`. Do remove `GROUP BY p.player_id` instead of keeping it. Do order by `T2.PIM DESC` instead of `violations DESC`. The amended query now matches RIGHT_SQL's behavior by correctly selecting a single player name based on penalty minutes rather than counting violations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, COUNT(pv.player_id) as violations\nFROM players p\nJOIN player_violations pv ON p.player_id = pv.player_id\nWHERE p.games_played >= 500\nGROUP BY p.player_id\nORDER BY violations DESC\nLIMIT 1;",
            "SELECT T1.PlayerName\nFROM PlayerInfo AS T1\nINNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE T1.sum_7yr_GP >= 500\nORDER BY T2.PIM DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3086": {
        "db_id": "cars",
        "question": "How many cylinders does the cheapest car have?",
        "ground_truth": "SELECT T1.cylinders FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY price ASC LIMIT 1",
        "amends": [
            "Do specify the table alias `T1.cylinders` instead of just `cylinders`. Do add `FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID` instead of `FROM cars`. Do change `ORDER BY price DESC` to `ORDER BY price ASC` instead of descending order. Do reference the joined table structure instead of a single table. The amended query now correctly joins the data and price tables and sorts in ascending order to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cylinders FROM cars ORDER BY price DESC LIMIT 1;",
            "SELECT T1.cylinders FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY T2.price ASC LIMIT 1"
        ],
        "rule_sql": []
    },
    "6224": {
        "db_id": "food_inspection_2",
        "question": "Where in Chicago does the restaurant named \"Old Timers Rest & Lounge\" located?",
        "ground_truth": "SELECT address FROM establishment WHERE city = 'CHICAGO' AND dba_name = 'OLD TIMERS REST & LOUNGE' AND facility_type = 'Restaurant'",
        "amends": [
            "Do query the `establishment` table instead of `restaurants`. Do use `dba_name = 'OLD TIMERS REST & LOUNGE'` instead of `name = 'Old Timers Rest & Lounge'` with proper case matching. Do filter by `city = 'CHICAGO'` instead of `city = 'New York'` to target the correct location. Do add `facility_type = 'Restaurant'` instead of omitting this essential business type filter. The amended query now correctly retrieves the address from the establishment table with proper business name matching, location filtering, and facility type validation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM restaurants WHERE name = 'Old Timers Rest & Lounge' AND city = 'New York';",
            "SELECT address FROM establishment WHERE dba_name = 'OLD TIMERS REST & LOUNGE' AND city = 'CHICAGO' AND facility_type = 'Restaurant';"
        ],
        "rule_sql": []
    },
    "175": {
        "db_id": "book_publishing_company",
        "question": "List all titles published in year 1991. Also provide notes details of the title and the publisher's name.",
        "ground_truth": "SELECT T1.title, T1.notes, T2.pub_name FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE STRFTIME('%Y', T1.pubdate) = '1991'",
        "amends": [
            "Do use `STRFTIME('%Y', T1.pubdate)` for year extraction instead of direct date comparison `t.pubdate = '1991'`. Do use table aliases `T1` and `T2` instead of `t` and `p`. Do reference `T2.pub_name` instead of `p.name` for the publisher name column. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly filters for titles published in 1991 by extracting the year from the date field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.title, t.notes, p.name \nFROM titles t \nJOIN publishers p ON t.pub_id = p.pub_id \nWHERE t.pubdate = '1991';",
            "SELECT T1.title, T1.notes, T2.pub_name \nFROM titles T1 \nINNER JOIN publishers T2 ON T1.pub_id = T2.pub_id \nWHERE STRFTIME('%Y', T1.pubdate) = '1991'"
        ],
        "rule_sql": []
    },
    "9412": {
        "db_id": "movie_3",
        "question": "Among the films starred by Reese West, what is the difference between the films that have store ID of 1 and store ID of 2?",
        "ground_truth": "SELECT SUM(IIF(T4.film_id = 1, 1, 0)) - SUM(IIF(T4.film_id = 2, 1, 0)) AS diff FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE T2.first_name = 'Reese' AND T2.last_name = 'West'",
        "amends": [
            "Do use a single query with conditional aggregation using `SUM(IIF(T4.film_id = 1, 1, 0)) - SUM(IIF(T4.film_id = 2, 1, 0))` instead of subtracting two separate subqueries. Do add `INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id` instead of omitting the inventory table. Do filter on `T4.film_id` values 1 and 2 instead of filtering on `f.store_id` values 1 and 2. Do reference `T4.film_id` in the conditional expressions instead of `f.store_id`. Do use a single `WHERE` clause with `T2.first_name = 'Reese' AND T2.last_name = 'West'` instead of duplicating the actor filter in both subqueries. The amended query now correctly calculates the difference between films in inventory at store 1 versus store 2 for the specified actor, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM film f \n     JOIN film_actor fa ON f.film_id = fa.film_id \n     JOIN actor a ON fa.actor_id = a.actor_id \n     WHERE a.first_name = 'Reese' AND a.last_name = 'West' AND f.store_id = 1) - \n    (SELECT COUNT(*) FROM film f \n     JOIN film_actor fa ON f.film_id = fa.film_id \n     JOIN actor a ON fa.actor_id = a.actor_id \n     WHERE a.first_name = 'Reese' AND a.last_name = 'West' AND f.store_id = 2) \nAS difference;",
            "SELECT SUM(IIF(T4.store_id = 1, 1, 0)) - SUM(IIF(T4.store_id = 2, 1, 0)) AS store_difference\nFROM actor AS T2\nINNER JOIN film_actor AS T3 ON T2.actor_id = T3.actor_id\nINNER JOIN inventory AS T4 ON T3.film_id = T4.film_id\nWHERE T2.first_name = 'Reese' AND T2.last_name = 'West';"
        ],
        "rule_sql": []
    },
    "6681": {
        "db_id": "retails",
        "question": "How many customers are in Brazil?",
        "ground_truth": "SELECT COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'BRAZIL'",
        "amends": [
            "Do specify `COUNT(T1.c_custkey)` instead of `COUNT(*)` to count specific customer keys rather than all rows. Do join `customer AS T1 INNER JOIN nation AS T2` instead of querying only the `customers` table to properly relate customer and nation data. Do use the join condition `T1.c_nationkey = T2.n_nationkey` instead of no join to correctly link customers to their nations. Do filter on `T2.n_name = 'BRAZIL'` instead of `country = 'Brazil'` to use the standardized nation name from the nation table rather than a potentially inconsistent country field. The amended query now correctly counts Brazilian customers by properly joining through the nation reference table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE country = 'Brazil';",
            "SELECT COUNT(T1.c_custkey) \nFROM customer AS T1 \nINNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey \nWHERE T2.n_name = 'BRAZIL'"
        ],
        "rule_sql": []
    },
    "5157": {
        "db_id": "address",
        "question": "What are the alias of the cities with 0 population in 2010?",
        "ground_truth": "SELECT DISTINCT T1.alias FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.population_2010 = 0",
        "amends": [
            "Do use `DISTINCT T1.alias` instead of `name` in the SELECT list. Do add `INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code` instead of querying only the `cities` table. Do change the filter to `T2.population_2010 = 0` instead of `population = 0 AND year = 2010`. Do remove the `year = 2010` condition since the population data is already specific to 2010. The amended query now correctly joins the alias and zip_data tables to find distinct aliases associated with zip codes that had zero population in 2010, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cities WHERE population = 0 AND year = 2010;",
            "SELECT DISTINCT T1.alias FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.population_2010 = 0"
        ],
        "rule_sql": []
    },
    "2686": {
        "db_id": "regional_sales",
        "question": "What sales channels are used the most in the 3 places with the highest median income?",
        "ground_truth": "SELECT `Sales Channel` FROM ( SELECT T1.`Sales Channel` FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID ORDER BY T2.`Median Income` DESC LIMIT 3 ) GROUP BY `Sales Channel` ORDER BY COUNT(`Sales Channel`) DESC LIMIT 1",
        "amends": [
            "Do use `Sales Channel` instead of `sales_channel` and move it to the outer SELECT instead of including it in the GROUP BY. Do use a subquery with `INNER JOIN` on `StoreID` instead of `JOIN` on `place_id`. Do add `ORDER BY Median Income DESC LIMIT 3` in the subquery instead of using `WHERE median_income IN` with a subquery. Do change the aggregation to `COUNT(Sales Channel)` in the outer ORDER BY instead of `COUNT(*) as usage_count`. Do add `LIMIT 1` to the outer query instead of omitting it. Do remove the explicit GROUP BY clause in the outer query instead of keeping it, as the subquery already provides the necessary grouping. The amended query now correctly identifies the top sales channel from stores with the highest median income by using proper table aliases and join conditions.",
            "Do use an `INNER JOIN` between `Sales Orders` and `Store Locations` on `T2.StoreID = T1._StoreID` instead of a subquery with `IN` and `ORDER BY/LIMIT`. Do move the `ORDER BY T2.Median Income DESC LIMIT 3` to the subquery level instead of applying it to the entire result set. Do restructure the query with a derived table containing only the top 3 stores by median income instead of filtering after aggregation. Do maintain the same `GROUP BY Sales Channel` and `ORDER BY COUNT(Sales Channel) DESC LIMIT 1` to find the most frequent sales channel among the top 3 stores. The amended query now correctly identifies the sales channel with the highest count from only the top 3 stores by median income, matching the intended behavior.",
            "Do use an INNER JOIN between `Sales Orders` and `Store Locations` on `T2.StoreID = T1._StoreID` instead of a subquery with IN clause. Do move the ORDER BY `Median Income` DESC LIMIT 3 to the FROM clause subquery instead of applying it to the subquery result. Do change the aggregation to COUNT(`Sales Channel`) in the outer ORDER BY instead of using an alias reference. Do remove the explicit alias `usage_count` from the SELECT list instead of keeping it. Do restructure the query with a derived table containing the top 3 stores by median income instead of filtering by store IDs in a WHERE clause. The amended query now correctly identifies the sales channel with the highest usage count from the top 3 stores by median income, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sales_channel, COUNT(*) as usage_count\nFROM sales s\nJOIN places p ON s.place_id = p.id\nWHERE p.median_income IN (\n    SELECT median_income \n    FROM places \n    ORDER BY median_income DESC \n    LIMIT 3\n)\nGROUP BY sales_channel\nORDER BY usage_count DESC;",
            "SELECT \"Sales Channel\", COUNT(\"Sales Channel\") \nFROM \"Sales Orders\"\nWHERE _StoreID IN (\n    SELECT StoreID \n    FROM \"Store Locations\" \n    ORDER BY \"Median Income\" DESC \n    LIMIT 3\n)\nGROUP BY \"Sales Channel\"\nORDER BY COUNT(\"Sales Channel\") DESC\nLIMIT 1;",
            "SELECT \"Sales Channel\", COUNT(\"Sales Channel\") as usage_count\nFROM \"Sales Orders\"\nWHERE _StoreID IN (\n    SELECT StoreID\n    FROM \"Store Locations\"\n    ORDER BY \"Median Income\" DESC\n    LIMIT 3\n)\nGROUP BY \"Sales Channel\"\nORDER BY usage_count DESC\nLIMIT 1;",
            "SELECT \"Sales Channel\"\nFROM \"Sales Orders\" T1\nINNER JOIN (\n    SELECT StoreID\n    FROM \"Store Locations\"\n    ORDER BY \"Median Income\" DESC\n    LIMIT 3\n) T2 ON T1._StoreID = T2.StoreID\nGROUP BY \"Sales Channel\"\nORDER BY COUNT(\"Sales Channel\") DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3331": {
        "db_id": "video_games",
        "question": "Show the id of game platform which makes the most sales in Japan.",
        "ground_truth": "SELECT T.game_platform_id FROM ( SELECT T2.game_platform_id, MAX(T2.num_sales) FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'Japan' ) t",
        "amends": [
            "Do select `T.game_platform_id` instead of `platform_id` from the wrong table. Do use a subquery with `MAX(T2.num_sales)` instead of directly ordering by `sales_amount`. Do join `region AS T1` and `region_sales AS T2` with `INNER JOIN` on `T1.id = T2.region_id` instead of querying a single `sales` table. Do filter by `T1.region_name = 'Japan'` instead of `region = 'Japan'` to properly reference the region table. Do remove the explicit `ORDER BY sales_amount DESC LIMIT 1` clause and instead use the MAX aggregate to find the maximum sales value. The amended query now correctly identifies the game platform with maximum sales in Japan by properly joining region tables and using aggregate functions instead of simple ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform_id FROM sales WHERE region = 'Japan' ORDER BY sales_amount DESC LIMIT 1;",
            "SELECT T2.game_platform_id\nFROM region AS T1\nINNER JOIN region_sales AS T2 ON T1.id = T2.region_id\nWHERE T1.region_name = 'Japan'\nGROUP BY T2.game_platform_id\nHAVING SUM(T2.num_sales) = (\n    SELECT MAX(total_sales)\n    FROM (\n        SELECT SUM(T4.num_sales) AS total_sales\n        FROM region AS T3\n        INNER JOIN region_sales AS T4 ON T3.id = T4.region_id\n        WHERE T3.region_name = 'Japan'\n        GROUP BY T4.game_platform_id\n    )\n)"
        ],
        "rule_sql": []
    },
    "9268": {
        "db_id": "movie_3",
        "question": "How many different clients have rented materials from Jon Stephens?",
        "ground_truth": "SELECT COUNT(T1.customer_id) FROM rental AS T1 INNER JOIN staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = 'Jon' AND T2.last_name = 'Stephens'",
        "amends": [
            "Do count `T1.customer_id` instead of `COUNT(*)` to count specific customer rentals. Do join `rental AS T1` with `staff AS T2` on `T1.staff_id = T2.staff_id` instead of querying `clients` table directly with a subquery. Do filter directly on `T2.first_name = 'Jon' AND T2.last_name = 'Stephens'` in the WHERE clause instead of using a subquery to find the staff_id. Do remove the subquery entirely instead of using it to filter by staff_id. The amended query now correctly counts customer rentals handled by staff member Jon Stephens by joining the rental and staff tables directly.",
            "Do use `COUNT(T1.customer_id)` instead of `COUNT(DISTINCT T1.customer_id)` to count all customer rentals rather than distinct customers. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity, though this is functionally equivalent. The `WHERE` clause conditions on `T2.first_name = 'Jon' AND T2.last_name = 'Stephens'` remain unchanged. The amended query now correctly counts all rental transactions by customers handled by staff member Jon Stephens rather than counting distinct customers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE staff_id = (SELECT staff_id FROM staff WHERE first_name = 'Jon' AND last_name = 'Stephens');",
            "SELECT COUNT(DISTINCT T1.customer_id) \nFROM rental AS T1 \nJOIN staff AS T2 ON T1.staff_id = T2.staff_id \nWHERE T2.first_name = 'Jon' AND T2.last_name = 'Stephens'",
            "SELECT COUNT(T1.customer_id) \nFROM rental AS T1 \nINNER JOIN staff AS T2 ON T1.staff_id = T2.staff_id \nWHERE T2.first_name = 'Jon' AND T2.last_name = 'Stephens'"
        ],
        "rule_sql": []
    },
    "6769": {
        "db_id": "retails",
        "question": "In the parts supply by Supplier#000000654, list the top five parts with the most supply cost in descending order of supply cost.",
        "ground_truth": "SELECT T2.ps_partkey FROM supplier AS T1 INNER JOIN partsupp AS T2 ON T1.s_suppkey = T2.ps_suppkey WHERE T1.s_name = 'Supplier#000000654' ORDER BY T2.ps_supplycost DESC LIMIT 5",
        "amends": [
            "Do select only `ps_partkey` instead of `p_name` and `ps_supplycost`. Do use explicit `INNER JOIN` syntax with table aliases `T1` and `T2` instead of implicit comma joins. Do reference `T2.ps_supplycost` in the `ORDER BY` clause instead of just `ps_supplycost`. Do sort by `DESC` instead of `ASC` order. Do remove the `part` table entirely instead of including it unnecessarily since no columns from it are selected. The amended query now correctly retrieves only the part keys supplied by the specified supplier, ordered by supply cost in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p_name, ps_supplycost \nFROM partsupp, supplier, part \nWHERE s_suppkey = ps_suppkey \nAND ps_partkey = p_partkey \nAND s_name = 'Supplier#000000654' \nORDER BY ps_supplycost ASC \nLIMIT 5;",
            "SELECT T1.ps_partkey\nFROM partsupp T1\nINNER JOIN supplier T2 ON T1.ps_suppkey = T2.s_suppkey\nWHERE T2.s_name = 'Supplier#000000654'\nORDER BY T1.ps_supplycost DESC\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "220": {
        "db_id": "book_publishing_company",
        "question": "What's Pedro S Afonso's job title?",
        "ground_truth": "SELECT T2.job_desc FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE T1.fname = 'Pedro' AND T1.minit = 'S' AND T1.lname = 'Afonso'",
        "amends": [
            "Do select `T2.job_desc` from the `jobs` table instead of `job_title` from the `employees` table. Do join `employee AS T1` with `jobs AS T2` on `T1.job_id = T2.job_id` instead of querying a single table. Do filter on `T1.fname = 'Pedro'` and `T1.lname = 'Afonso'` instead of `first_name = 'Pedro'` and `last_name = 'S Afonso'`. Do add the additional filter `T1.minit = 'S'` instead of omitting it. The amended query now correctly joins employee and jobs tables to retrieve the job description while properly handling the middle initial in the name filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title FROM employees WHERE first_name = 'Pedro' AND last_name = 'S Afonso';",
            "SELECT T2.job_desc \nFROM employee AS T1 \nJOIN jobs AS T2 ON T1.job_id = T2.job_id \nWHERE T1.fname = 'Pedro' \nAND T1.lname = 'Afonso' \nAND T1.minit = 'S'"
        ],
        "rule_sql": []
    },
    "2745": {
        "db_id": "european_football_1",
        "question": "What is the percentage whereby the away team scored 2 goals during the 2017 seasons?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) / COUNT(FTAG) AS REAL) * 100 FROM matchs WHERE season = 2017",
        "amends": [
            "Do use `SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN away_team_goals = 2 THEN 1 END)` for counting occurrences. Do reference column `FTAG` instead of `away_team_goals` to match the correct column name. Do use `COUNT(FTAG)` instead of `COUNT(*)` to count only non-null values in the specific column. Do add explicit `CAST(... AS REAL)` instead of implicit decimal conversion with `100.0` to ensure proper floating-point division. Do reference table `matchs` instead of `matches` to use the correct table name. The amended query now correctly calculates the percentage of matches where away team goals equal 2 for the 2017 season.",
            "Do cast the entire division expression `SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) / COUNT(FTAG)` as `REAL` instead of casting the numerator and denominator separately before division. Do remove the column alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage by casting the result of the division operation rather than performing division on already-casted integers, which preserves the decimal precision needed for accurate percentage calculation.",
            "Do place the multiplication by 100 outside the CAST function instead of inside it, maintaining the same mathematical calculation but with proper operator precedence that ensures the percentage calculation occurs after the division. Do keep the same CASE expression counting FTAG = 2 occurrences and the same COUNT aggregation of all FTAG values instead of changing these core metrics. Do preserve the same FROM source table and WHERE filter on season = 2017 instead of altering the data scope. The amended query now correctly calculates the percentage by first computing the ratio and then multiplying by 100, matching the RIGHT_SQL's behavior while maintaining identical mathematical results.",
            "Do place the multiplication by `100` outside the `CAST` function instead of inside it, maintaining the same mathematical calculation but with proper operator precedence that ensures accurate percentage computation. Do keep the same `SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END)` aggregation and `COUNT(FTAG)` calculation within the division operation instead of changing these core metrics. Do preserve the `CAST` to `REAL` data type and the `WHERE season = 2017` filter without modification instead of altering these elements. The amended query now correctly calculates the percentage by applying the multiplication after the division and casting, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by `100` outside the `CAST` function instead of inside it, maintaining the same mathematical calculation but with proper operator precedence. Do keep the `SUM` of conditional cases and `COUNT` aggregation unchanged instead of modifying these core calculations. Do preserve the `WHERE` filter on `season = 2017` and the table source `FROM matchs` without alteration. The amended query now correctly calculates the percentage by applying the multiplication after the division and casting, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN away_team_goals = 2 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM matches\nWHERE season = 2017;",
            "SELECT \n    (CAST(SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(FTAG) AS REAL)) * 100.0 AS percentage\nFROM \n    matchs\nWHERE \n    season = 2017;",
            "SELECT CAST(SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) * 100.0 / COUNT(FTAG) AS REAL) FROM matchs WHERE season = 2017;",
            "SELECT CAST(SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) * 100.0 / COUNT(FTAG) AS REAL) FROM matchs WHERE season = 2017;",
            "SELECT CAST(SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) * 100.0 / COUNT(FTAG) AS REAL) \nFROM matchs \nWHERE season = 2017;",
            "SELECT CAST(SUM(CASE WHEN FTAG = 2 THEN 1 ELSE 0 END) * 100.0 / COUNT(FTAG) AS REAL) FROM matchs WHERE season = 2017;"
        ],
        "rule_sql": []
    },
    "1825": {
        "db_id": "soccer_2016",
        "question": "How many matches were played in Season 7?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM `Match` WHERE Season_Id = 7",
        "amends": [
            "Do reference the correct table name `Match` instead of `matches` and use the proper column `Match_Id` in the COUNT function instead of `*`. Do filter on the correct season identifier `Season_Id = 7` instead of `season_id = 8`. The amended query now correctly counts distinct matches for the specified season using the appropriate table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE season_id = 8;",
            "SELECT COUNT(DISTINCT Match_Id) FROM Match WHERE Season_Id = 7;"
        ],
        "rule_sql": []
    },
    "4484": {
        "db_id": "student_loan",
        "question": "Calculate the average enlisted students per organization.",
        "ground_truth": "SELECT CAST(COUNT(NAME) AS REAL) * 100 / COUNT(DISTINCT organ) FROM enlist",
        "amends": [
            "Do use `CAST(COUNT(NAME) AS REAL) * 100 / COUNT(DISTINCT organ)` instead of `COUNT(*) AS total_students` for the SELECT expression. Do query from `enlist` table instead of `students` table. Do remove the `GROUP BY organization` clause instead of keeping it. Do omit the `organization` column from the SELECT list instead of including it. The amended query now correctly calculates a percentage ratio using proper casting and distinct counting rather than a simple count grouped by organization."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization, COUNT(*) AS total_students FROM students GROUP BY organization;",
            "SELECT CAST(COUNT(name) AS REAL) * 100 / COUNT(DISTINCT organ) FROM enlist;"
        ],
        "rule_sql": []
    },
    "5059": {
        "db_id": "olympics",
        "question": "What is the average age of Argentina's athletes who participated in the Summer Olympics in 2012?",
        "ground_truth": "SELECT AVG(T2.age) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person_region AS T3 ON T2.person_id = T3.person_id INNER JOIN noc_region AS T4 ON T3.region_id = T4.id WHERE T1.games_name = '2012 Summer' AND T4.region_name = 'Argentina'",
        "amends": [
            "Do use `AVG(T2.age)` with explicit table alias instead of `AVG(age)` without qualification. Do join multiple tables including `games AS T1`, `games_competitor AS T2`, `person_region AS T3`, and `noc_region AS T4` instead of querying a single `athletes` table. Do use `INNER JOIN` with proper join conditions `T1.id = T2.games_id`, `T2.person_id = T3.person_id`, and `T3.region_id = T4.id` instead of simple filtering. Do filter on `T1.games_name = '2012 Summer'` instead of separate `year = 2012 AND season = 'Summer'` conditions. Do filter on `T4.region_name = 'Argentina'` instead of `country = 'Argentina'`. The amended query now correctly joins the necessary tables to calculate average age for Argentinian athletes in the 2012 Summer games, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM athletes WHERE country = 'Argentina' AND year = 2012 AND season = 'Summer';",
            "SELECT AVG(T2.age) AS average_age\nFROM games AS T1\nINNER JOIN games_competitor AS T2 ON T1.id = T2.games_id\nINNER JOIN person_region AS T3 ON T2.person_id = T3.person_id\nINNER JOIN noc_region AS T4 ON T3.region_id = T4.id\nWHERE T1.games_name = '2012 Summer'\nAND T4.region_name = 'Argentina';"
        ],
        "rule_sql": []
    },
    "8858": {
        "db_id": "craftbeer",
        "question": "What is the average alcohol content per 12-ounce beer bottle produced by Boston Beer Company?",
        "ground_truth": "SELECT AVG(T1.abv) FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T2.name = 'Boston Beer Company' AND T1.ounces = 12",
        "amends": [
            "Do reference `T1.abv` instead of `alcohol_content` in the SELECT list. Do join `breweries AS T2` instead of omitting it, using `INNER JOIN` on `T1.brewery_id = T2.id` instead of filtering directly on `brewery`. Do filter on `T2.name = 'Boston Beer Company'` instead of `brewery = 'Boston Beer Company'` to properly reference the joined table. Do filter on `T1.ounces = 12` instead of `volume = 12` to use the correct column name. The amended query now correctly joins the breweries table to resolve brewery names through their ID relationship and uses the proper column names for alcohol content and volume measurements, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(alcohol_content) FROM beers WHERE brewery = 'Boston Beer Company' AND volume = 12;",
            "SELECT AVG(T1.abv) AS average_alcohol_content\nFROM beers AS T1\nINNER JOIN breweries AS T2 ON T1.brewery_id = T2.id\nWHERE T2.name = 'Boston Beer Company' AND T1.ounces = 12;"
        ],
        "rule_sql": []
    },
    "8448": {
        "db_id": "mondial_geo",
        "question": "Which United States province is home to the greatest number of corporations' corporate headquarters?",
        "ground_truth": "SELECT T1.Province FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'United States' GROUP BY T1.Province ORDER BY COUNT(T1.Name) DESC LIMIT 1",
        "amends": [
            "Do use `T1.Province` from the `country` table instead of `province` from the `corporations` table. Do join `country AS T1` with `organization AS T2` on `T1.Code = T2.Country` instead of querying only the `corporations` table. Do filter on `T1.Name = 'United States'` instead of `country = 'United States'`. Do aggregate with `COUNT(T1.Name)` instead of `COUNT(*) as headquarters_count`. Do maintain `GROUP BY T1.Province` and `ORDER BY COUNT(T1.Name) DESC LIMIT 1` as in the original structure. The amended query now correctly joins country and organization tables to find the province with the most organizations in the United States."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT province, COUNT(*) as headquarters_count \nFROM corporations \nWHERE country = 'United States' \nGROUP BY province \nORDER BY headquarters_count DESC \nLIMIT 1;",
            "SELECT T1.Province\nFROM country AS T1\nJOIN organization AS T2 ON T1.Code = T2.Country\nWHERE T1.Name = 'United States'\nGROUP BY T1.Province\nORDER BY COUNT(T1.Name) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9046": {
        "db_id": "bike_share_1",
        "question": "Which year had the most number of trips that started at stations in San Francisco?",
        "ground_truth": "SELECT SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'San Francisco' GROUP BY T1.start_station_name ORDER BY COUNT(T1.id) DESC LIMIT 1",
        "amends": [
            "Do extract year using `SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4)` instead of `YEAR(start_time)` for proper date parsing. Do join `trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name` instead of filtering with `WHERE start_station_id IN (SELECT station_id FROM stations WHERE city = 'San Francisco')` to correctly relate stations by name rather than ID. Do filter with `WHERE T2.city = 'San Francisco'` instead of the subquery approach. Do group by `T1.start_station_name` instead of `YEAR(start_time)` to aggregate by station rather than year. Do order by `COUNT(T1.id) DESC` instead of `trip_count DESC` while maintaining the descending count ordering. The amended query now correctly identifies stations by name rather than ID and properly handles date extraction from the start_date field, matching the RIGHT_SQL's behavior.",
            "Do group by `T1.start_station_name` instead of grouping by the aliased `year` column. Do remove the alias `year` from the SELECT list instead of keeping it, and do remove the alias `trip_count` from the COUNT expression instead of including it. The amended query now correctly groups by the actual column rather than an alias and removes unnecessary column aliases while maintaining the same filtering logic and join conditions.",
            "Do group by `T1.start_station_name` instead of the aliased `year` column, which fixes the grouping logic to properly aggregate trips by station rather than by the extracted year value. The amended query now correctly matches RIGHT_SQL's behavior by maintaining proper grouping semantics.",
            "Do group by `T1.start_station_name` instead of the derived `year` column to ensure proper aggregation semantics. Do order by `COUNT(T1.id) DESC` instead of ordering by the alias `trip_count` since aggregate functions cannot reference aliases in the ORDER BY clause. Do remove the column alias `year` and `trip_count` from the SELECT list instead of keeping them as the RIGHT_SQL focuses on the raw aggregation results without aliasing. The amended query now correctly groups by the actual station name column rather than a derived expression and uses the aggregate function directly in ORDER BY for proper sorting.",
            "Do group by `T1.start_station_name` instead of the derived `year` column to ensure proper aggregation semantics. The amended query now correctly groups by the original column rather than the calculated expression, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT YEAR(start_time) as year, COUNT(*) as trip_count \nFROM trips \nWHERE start_station_id IN (SELECT station_id FROM stations WHERE city = 'San Francisco') \nGROUP BY YEAR(start_time) \nORDER BY trip_count DESC \nLIMIT 1;",
            "SELECT SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4) AS year, COUNT(T1.id) AS trip_count\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T2.city = 'San Francisco'\nGROUP BY year\nORDER BY COUNT(T1.id) DESC\nLIMIT 1;",
            "SELECT SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4) AS year, COUNT(T1.id) AS trip_count\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T2.city = 'San Francisco'\nGROUP BY year\nORDER BY COUNT(T1.id) DESC\nLIMIT 1",
            "SELECT SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4) AS year, COUNT(T1.id) AS trip_count\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T2.city = 'San Francisco'\nGROUP BY year\nORDER BY trip_count DESC\nLIMIT 1;",
            "SELECT SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4) AS year, COUNT(T1.id) AS trip_count\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T2.city = 'San Francisco'\nGROUP BY year\nORDER BY COUNT(T1.id) DESC\nLIMIT 1",
            "SELECT SUBSTR(CAST(T1.start_date AS TEXT), INSTR(T1.start_date, ' '), -4) AS year, COUNT(T1.id) AS trip_count\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T2.city = 'San Francisco'\nGROUP BY year\nORDER BY trip_count DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2361": {
        "db_id": "superstore",
        "question": "What is the name of the product that has the highest original price?",
        "ground_truth": "SELECT T2.`Product Name` FROM east_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` ORDER BY (T1.Sales / (1 - T1.Discount)) DESC LIMIT 1",
        "amends": [
            "Do select `T2.Product Name` from the `product` table instead of `name` from `products`. Do join `east_superstore AS T1` with `product AS T2` using `INNER JOIN` on `T1.Product ID = T2.Product ID` instead of querying a single table. Do order by the calculated expression `(T1.Sales / (1 - T1.Discount))` in `DESC` order instead of `original_price ASC`. The amended query now correctly retrieves the product with the highest effective sales value by joining the necessary tables and performing the proper calculation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products ORDER BY original_price ASC LIMIT 1;",
            "SELECT T2.\"Product Name\"\nFROM east_superstore AS T1\nINNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\"\nORDER BY (T1.Sales / (1 - T1.Discount)) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5106": {
        "db_id": "address",
        "question": "How many representatives are there in the state with the highest monthly benefit payments for retired workers?",
        "ground_truth": "SELECT COUNT(T3.cognress_rep_id) FROM zip_data AS T1 INNER JOIN state AS T2 ON T1.state = T2.abbreviation INNER JOIN congress AS T3 ON T2.abbreviation = T3.abbreviation ORDER BY T1.monthly_benefits_retired_workers DESC LIMIT 1",
        "amends": [
            "Do select `COUNT(T3.congress_rep_id)` instead of `COUNT(*)`. Do use tables `zip_data AS T1`, `state AS T2`, and `congress AS T3` instead of `representatives r`, `states s`, and `benefit_payments bp`. Do join `T1` to `T2` on `T1.state = T2.abbreviation` instead of joining `r` to `s` on `r.state_id = s.state_id`. Do join `T2` to `T3` on `T2.abbreviation = T3.abbreviation` instead of joining `s` to `bp` on `s.state_id = bp.state_id`. Do remove the `WHERE` filter on `benefit_type` instead of keeping it. Do order by `T1.monthly_benefits_retired_workers DESC` instead of `bp.monthly_payment DESC`. The amended query now correctly counts congress representatives based on zip data and state relationships while ordering by retired worker benefits.",
            "Do remove the `GROUP BY T1.state` clause instead of keeping it, as the aggregation should be performed across the entire joined dataset rather than grouped by state. Do maintain the `COUNT(T3.congress_rep_id)` aggregation and `INNER JOIN` operations on `T1.state = T2.abbreviation` and `T2.abbreviation = T3.abbreviation` instead of changing them. Do preserve the `ORDER BY T1.monthly_benefits_retired_workers DESC` and `LIMIT 1` clauses instead of modifying them. The amended query now correctly returns the total count of congressional representatives across all states ordered by monthly benefits, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM representatives r\nJOIN states s ON r.state_id = s.state_id\nJOIN benefit_payments bp ON s.state_id = bp.state_id\nWHERE bp.benefit_type = 'retired_workers'\nORDER BY bp.monthly_payment DESC\nLIMIT 1;",
            "SELECT COUNT(T3.cognress_rep_id)\nFROM zip_data AS T1\nJOIN state AS T2 ON T1.state = T2.abbreviation\nJOIN congress AS T3 ON T2.abbreviation = T3.abbreviation\nGROUP BY T1.state\nORDER BY T1.monthly_benefits_retired_workers DESC\nLIMIT 1;",
            "SELECT COUNT(T3.cognress_rep_id) \nFROM zip_data AS T1\nINNER JOIN state AS T2 ON T1.state = T2.abbreviation\nINNER JOIN congress AS T3 ON T2.abbreviation = T3.abbreviation\nORDER BY T1.monthly_benefits_retired_workers DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8986": {
        "db_id": "human_resources",
        "question": "What is the education required to be account representative? Mention account representative full name and salary who got poor in performance status.",
        "ground_truth": "SELECT T2.educationrequired, T1.firstname, T1.lastname, T1.salary FROM employee AS T1  INNER JOIN position AS T2  ON T1.positionID = T2.positionID WHERE T1.performance = 'Poor' AND T2.positiontitle = 'Account Representative'",
        "amends": [
            "Do select `T2.educationrequired` instead of `education`, do select `T1.firstname` and `T1.lastname` instead of `full_name`, and do keep `T1.salary` instead of `salary`. Do use `employee AS T1` and `position AS T2` as sources instead of `account_representatives`, and do use `INNER JOIN` on `T1.positionID = T2.positionID` instead of no join. Do add filter `T1.performance = 'Poor'` instead of `performance_status = 'poor'`, and do add filter `T2.positiontitle = 'Account Representative'` instead of omitting it. The amended query now correctly joins employee and position tables to filter for account representatives with poor performance."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT education, full_name, salary FROM account_representatives WHERE performance_status = 'poor';",
            "SELECT T2.educationrequired, T1.firstname, T1.lastname, T1.salary \nFROM employee AS T1 \nINNER JOIN position AS T2 ON T1.positionID = T2.positionID \nWHERE T2.positiontitle = 'Account Representative' AND T1.performance = 'Poor'"
        ],
        "rule_sql": []
    },
    "32": {
        "db_id": "movie_platform",
        "question": "What is the URL to the user profile image on Mubi of the user who gave the movie id of 1103 a 5 ratinng score on 4/19/2020?",
        "ground_truth": "SELECT T2.user_avatar_image_url FROM ratings AS T1 INNER JOIN ratings_users AS T2 ON T1.user_id = T2.user_id WHERE T2.user_id = 1103 AND rating_score = 5 AND T2.rating_date_utc = '2020-04-19'",
        "amends": [
            "Do select `T2.user_avatar_image_url` instead of `profile_image_url`. Do use `FROM ratings AS T1 INNER JOIN ratings_users AS T2 ON T1.user_id = T2.user_id` instead of `FROM users` with a subquery. Do change the WHERE condition to `T2.user_id = 1103` instead of filtering by `movie_id = 1103` in the subquery. Do use `rating_score = 5` instead of `rating = 5`. Do use `T2.rating_date_utc = '2020-04-19'` instead of `date = '2020-04-19'`. The amended query now correctly joins the ratings and ratings_users tables to retrieve the user avatar image URL based on the specified rating criteria.",
            "Do filter on `T2.user_id = 1103` instead of `T1.movie_id = 1103` in the WHERE clause, as the query should filter by user ID rather than movie ID to correctly retrieve user avatar images for the specified user. The amended query now matches RIGHT_SQL's behavior by properly filtering on the user identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT profile_image_url FROM users WHERE user_id = (SELECT user_id FROM ratings WHERE movie_id = 1103 AND rating = 5 AND date = '2020-04-19')",
            "SELECT T2.user_avatar_image_url \nFROM ratings AS T1 \nINNER JOIN ratings_users AS T2 ON T1.user_id = T2.user_id \nWHERE T1.movie_id = 1103 \nAND T1.rating_score = 5 \nAND T2.rating_date_utc = '2020-04-19'",
            "SELECT T2.user_avatar_image_url \nFROM ratings AS T1 \nINNER JOIN ratings_users AS T2 ON T1.user_id = T2.user_id \nWHERE T2.user_id = 1103 \nAND T1.rating_score = 5 \nAND T2.rating_date_utc = '2020-04-19'"
        ],
        "rule_sql": []
    },
    "1640": {
        "db_id": "car_retails",
        "question": "Among all orders shipped, calculate the percentage of orders shipped at least 3 days before the required date.",
        "ground_truth": "SELECT COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > 3 THEN T1.customerNumber ELSE NULL END) FROM orders AS T1 INNER JOIN orderdetails AS T2 ON T1.orderNumber = T2.orderNumber WHERE T1.status = 'Shipped'",
        "amends": [
            "Do use `COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > 3 THEN T1.customerNumber ELSE NULL END)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders WHERE shipped_date IS NOT NULL)` for calculating the percentage of late shipments. Do add `INNER JOIN orderdetails AS T2 ON T1.orderNumber = T2.orderNumber` instead of querying only the `orders` table. Do change the filter to `T1.status = 'Shipped'` instead of `shipped_date IS NOT NULL` and remove the explicit date comparison condition. Do reference columns as `t1.shippeddate` and `t1.requireddate` with proper table aliases instead of direct column names. The amended query now correctly calculates late shipments by joining order details and using status-based filtering, matching the RIGHT_SQL's behavior.",
            "Do use `COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > 3 THEN T1.customerNumber ELSE NULL END)` instead of `(COUNT(CASE WHEN JULIANDAY(t1.shippedDate) - JULIANDAY(t1.requiredDate) > 3 THEN t1.orderNumber ELSE NULL END) * 100.0 / COUNT(*)) AS percentage_shipped_early` to count customer numbers rather than calculating a percentage. Do remove the column alias `percentage_shipped_early` instead of keeping it. Do use lowercase column names `shippeddate` and `requireddate` instead of mixed case `shippedDate` and `requiredDate`. The amended query now matches RIGHT_SQL's behavior by counting customers with late shipments rather than calculating a percentage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders WHERE shipped_date IS NOT NULL) AS percentage\nFROM orders \nWHERE shipped_date <= required_date - INTERVAL 3 DAY\nAND shipped_date IS NOT NULL;",
            "SELECT \n    (COUNT(CASE WHEN JULIANDAY(t1.shippedDate) - JULIANDAY(t1.requiredDate) > 3 THEN t1.orderNumber ELSE NULL END) * 100.0 / \n    COUNT(*)) AS percentage_shipped_early\nFROM \n    orders AS t1\nINNER JOIN \n    orderdetails AS t2 ON t1.orderNumber = t2.orderNumber\nWHERE \n    t1.status = 'Shipped'",
            "SELECT \n    COUNT(CASE WHEN JULIANDAY(t1.shippeddate) - JULIANDAY(t1.requireddate) > 3 THEN T1.customerNumber ELSE NULL END)\nFROM orders AS T1\nINNER JOIN orderdetails AS T2 ON T1.orderNumber = T2.orderNumber\nWHERE T1.status = 'Shipped'"
        ],
        "rule_sql": []
    },
    "8846": {
        "db_id": "food_inspection",
        "question": "List the tax code and inspection type of the business named \"Rue Lepic\".",
        "ground_truth": "SELECT DISTINCT T3.tax_code, T2.type FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id INNER JOIN businesses AS T3 ON T2.business_id = T3.business_id WHERE T3.name = 'Rue Lepic'",
        "amends": [
            "Do select `DISTINCT T3.tax_code, T2.type` instead of `tax_code, inspection_type`. Do use `FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id INNER JOIN businesses AS T3 ON T2.business_id = T3.business_id` instead of `FROM businesses` alone. Do add join conditions `T1.business_id = T2.business_id` and `T2.business_id = T3.business_id` instead of omitting them. Do filter on `T3.name = 'Rue Lepic'` instead of `business_name = 'Rue Lepic'`. The amended query now correctly joins multiple tables to retrieve inspection and violation data associated with the business name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tax_code, inspection_type FROM businesses WHERE business_name = 'Rue Lepic';",
            "SELECT DISTINCT T3.tax_code, T2.type\nFROM violations AS T1 \nINNER JOIN inspections AS T2 ON T1.business_id = T2.business_id \nINNER JOIN businesses AS T3 ON T2.business_id = T3.business_id\nWHERE T3.name = 'Rue Lepic'"
        ],
        "rule_sql": []
    },
    "8778": {
        "db_id": "food_inspection",
        "question": "What was the type of inspection Tiramisu Kitchen had on 2014/1/14?",
        "ground_truth": "SELECT T1.type FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.`date` = '2014-01-14' AND T2.name = 'Tiramisu Kitchen'",
        "amends": [
            "Do reference `T1.type` instead of `inspection_type` in the SELECT list. Do join `inspections AS T1` with `businesses AS T2` using `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying only the inspections table. Do filter on `T1.date = '2014-01-14'` instead of `inspection_date = '2014/1/14'` with corrected date format. Do filter on `T2.name = 'Tiramisu Kitchen'` instead of `restaurant_name = 'Tiramisu Kitchen'` by joining to the businesses table. The amended query now correctly joins tables and uses proper column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_type FROM inspections WHERE restaurant_name = 'Tiramisu Kitchen' AND inspection_date = '2014/1/14';",
            "SELECT T1.type \nFROM inspections AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T2.name = 'Tiramisu Kitchen' \nAND T1.date = '2014-01-14'"
        ],
        "rule_sql": []
    },
    "8093": {
        "db_id": "university",
        "question": "Which country is McMaster University located in?",
        "ground_truth": "SELECT T2.country_name FROM university AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE T1.university_name = 'McMaster University'",
        "amends": [
            "Do select `T2.country_name` instead of `country` to reference the joined table's column. Do use `FROM university AS T1 INNER JOIN country AS T2` instead of `FROM universities` to properly join the university and country tables. Do specify the join condition `ON T1.country_id = T2.id` instead of omitting any join logic. Do filter on `T1.university_name = 'McMaster University'` instead of `name = 'McMaster University'` to use the correct column name from the university table. The amended query now correctly retrieves the country name through a proper table join instead of assuming the country field exists directly in the universities table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM universities WHERE name = 'McMaster University';",
            "SELECT T2.country_name FROM university AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE T1.university_name = 'McMaster University'"
        ],
        "rule_sql": []
    },
    "2545": {
        "db_id": "app_store",
        "question": "What is the number of neutral comments from all the weather apps?",
        "ground_truth": "SELECT COUNT(T2.Sentiment) FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Genres = 'Weather' AND T2.Sentiment = 'Neutral'",
        "amends": [
            "Do select `COUNT(T2.Sentiment)` instead of `COUNT(*)` to count specific sentiment values. Do use `playstore AS T1` and `user_reviews AS T2` as source tables instead of just `comments`. Do add `INNER JOIN` on `T1.App = T2.App` instead of no join condition. Do change filter to `T1.Genres = 'Weather'` instead of `app_type = 'weather'` to use the correct column and genre classification. Do change sentiment filter to `T2.Sentiment = 'Neutral'` instead of `sentiment = 'positive'` to match the required sentiment criteria. The amended query now correctly counts neutral sentiment reviews for weather genre apps by properly joining the playstore and user_reviews tables on the app name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE app_type = 'weather' AND sentiment = 'positive';",
            "SELECT COUNT(T2.Sentiment) \nFROM playstore AS T1 \nINNER JOIN user_reviews AS T2 ON T1.App = T2.App \nWHERE T1.Genres = 'Weather' \nAND T2.Sentiment = 'Neutral'"
        ],
        "rule_sql": []
    },
    "7923": {
        "db_id": "music_platform_2",
        "question": "List all the podcast title and its itunes url under the 'society-culture' category.",
        "ground_truth": "SELECT T2.title, T2.itunes_url FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'society-culture'",
        "amends": [
            "Do join `categories AS T1` with `podcasts AS T2` on `T2.podcast_id = T1.podcast_id` instead of querying `podcasts` alone without any join. Do reference columns as `T2.title` and `T2.itunes_url` instead of just `title` and `itunes_url`. Do filter on `T1.category = 'society-culture'` instead of filtering directly on the `podcasts` table's category column. The amended query now correctly joins the categories table to filter podcasts by category and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, itunes_url FROM podcasts WHERE category = 'society-culture';",
            "SELECT T2.title, T2.itunes_url FROM categories AS T1 JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'society-culture'"
        ],
        "rule_sql": []
    },
    "1070": {
        "db_id": "talkingdata",
        "question": "Among HTC Butterfly phone users, list any five devices' IDs used by females.",
        "ground_truth": "SELECT T2.device_id FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.device_model = 'Butterfly' AND T2.gender = 'F' AND T1.phone_brand = 'HTC' LIMIT 5",
        "amends": [
            "Do select `T2.device_id` from the `gender_age` table instead of `device_id` from the `users` table. Do join `phone_brand_device_model2` as `T1` with `gender_age` as `T2` using an `INNER JOIN` on `T2.device_id = T1.device_id` instead of querying a single `users` table. Do filter for `T1.device_model = 'Butterfly'` and `T1.phone_brand = 'HTC'` instead of `phone_model = 'HTC Butterfly'`. Do filter for `T2.gender = 'F'` instead of `gender = 'male'`. The amended query now correctly joins the device model and gender information from separate tables and uses the proper gender filter value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_id FROM users WHERE gender = 'male' AND phone_model = 'HTC Butterfly' LIMIT 5;",
            "SELECT T2.device_id\nFROM phone_brand_device_model2 AS T1\nINNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id\nWHERE T1.phone_brand = 'HTC' \nAND T1.device_model = 'Butterfly'\nAND T2.gender = 'F'\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "3863": {
        "db_id": "public_review_platform",
        "question": "When does Yelp_Business no.1 open on Tuesdays?",
        "ground_truth": "SELECT T1.opening_time FROM Business_Hours AS T1 INNER JOIN Days AS T2 ON T1.day_id = T2.day_id WHERE T2.day_of_week LIKE 'Tuesday' AND T1.business_id = 1",
        "amends": [
            "Do select `opening_time` from the `Business_Hours` table instead of `open_time` from `Yelp_Business`. Do join `Business_Hours` with `Days` using `INNER JOIN` on `T1.day_id = T2.day_id` instead of querying a single table. Do filter on `T2.day_of_week LIKE 'Tuesday'` instead of `day = 'Tuesday'` to properly match the day name through the relationship. Do filter on `T1.business_id = 1` instead of `business_id = 1` to reference the correct table. The amended query now correctly joins the normalized schema and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT open_time FROM Yelp_Business WHERE business_id = 1 AND day = 'Tuesday';",
            "SELECT bh.opening_time \nFROM Business_Hours bh\nINNER JOIN Days d ON bh.day_id = d.day_id\nWHERE bh.business_id = 1 \nAND d.day_of_week LIKE 'Tuesday'"
        ],
        "rule_sql": []
    },
    "6514": {
        "db_id": "retail_world",
        "question": "Which country are the majority of the suppliers located?",
        "ground_truth": "SELECT Country FROM Suppliers GROUP BY Country ORDER BY COUNT(SupplierID) DESC LIMIT 1",
        "amends": [
            "Do use `Country` instead of `country` for case-sensitive column reference. Do order by `COUNT(SupplierID)` instead of `supplier_count` alias to ensure accurate count of suppliers rather than total rows. Do remove the `supplier_count` alias from the SELECT list instead of including it since it's not needed in the final output. The amended query now correctly identifies the country with the highest number of distinct suppliers by counting SupplierID values rather than all rows, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as supplier_count FROM suppliers GROUP BY country ORDER BY supplier_count DESC LIMIT 1;",
            "SELECT Country FROM Suppliers GROUP BY Country ORDER BY COUNT(SupplierID) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6915": {
        "db_id": "ice_hockey_draft",
        "question": "What is the height of David Bornhammar in inches?",
        "ground_truth": "SELECT T2.height_in_inch FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.PlayerName = 'David Bornhammar'",
        "amends": [
            "Do select `T2.height_in_inch` from the joined table instead of `height_in_feet` from a single table. Do use `INNER JOIN` with `height_info AS T2` on `T1.height = T2.height_id` instead of querying only the `players` table. Do reference `T1.PlayerName` in the WHERE filter instead of `name` and maintain the same filter value 'David Bornhammar'. The amended query now correctly retrieves height information from a joined height lookup table rather than assuming the height is stored directly in the player table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT height_in_feet FROM players WHERE name = 'David Bornhammar';",
            "SELECT T2.height_in_inch \nFROM PlayerInfo AS T1 \nINNER JOIN height_info AS T2 ON T1.height = T2.height_id \nWHERE T1.PlayerName = 'David Bornhammar'"
        ],
        "rule_sql": []
    },
    "677": {
        "db_id": "codebase_comments",
        "question": "How many watchers does the path \"maff_se3ue7\\US7.sln\" have?",
        "ground_truth": "SELECT T1.Watchers FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Path = 'maff_se3ue7US7.sln'",
        "amends": [
            "Do select `T1.Watchers` instead of `COUNT(*)` to retrieve the actual watchers count from the correct table. Do join `Repo AS T1` and `Solution AS T2` with `INNER JOIN` on `T1.Id = T2.RepoId` instead of querying only the `watchers` table without proper joins. Do filter on `T2.Path = 'maff_se3ue7US7.sln'` instead of `path = 'maff_se3ue7\\US7.sln'` to reference the correct table and use the proper path value without escape characters. The amended query now correctly retrieves watchers count by joining repository and solution tables with proper relationship mapping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM watchers WHERE path = 'maff_se3ue7\\US7.sln';",
            "SELECT T1.Watchers\nFROM Repo AS T1\nINNER JOIN Solution AS T2 ON T1.Id = T2.RepoId\nWHERE T2.Path = 'maff_se3ue7US7.sln'"
        ],
        "rule_sql": []
    },
    "6977": {
        "db_id": "ice_hockey_draft",
        "question": "How many players who were born in 1980 weigh 185 in pounds?",
        "ground_truth": "SELECT COUNT(T2.ELITEID) FROM weight_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight WHERE T1.weight_in_lbs = 185 AND strftime('%Y', T2.birthdate) = '1980'",
        "amends": [
            "Do select `COUNT(T2.ELITEID)` instead of `COUNT(*)`. Do join `weight_info AS T1` and `PlayerInfo AS T2` with `INNER JOIN` on `T1.weight_id = T2.weight` instead of querying only the `players` table. Do filter with `T1.weight_in_lbs = 185` instead of `weight = 185`. Do use `strftime('%Y', T2.birthdate) = '1980'` to extract the year from a date field instead of comparing to a `birth_year` column directly. The amended query now correctly counts elite players with specific weight and birth year by joining the appropriate tables and using proper date extraction."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE birth_year = 1980 AND weight = 185;",
            "SELECT COUNT(T2.ELITEID) \nFROM weight_info AS T1 \nINNER JOIN PlayerInfo AS T2 ON T1.weight_id = T2.weight \nWHERE T1.weight_in_lbs = 185 \nAND strftime('%Y', T2.birthdate) = '1980'"
        ],
        "rule_sql": []
    },
    "3137": {
        "db_id": "cars",
        "question": "Which is the most fuel efficient car in 1975?",
        "ground_truth": "SELECT T1.car_name FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T2.model_year = '1975' ORDER BY T1.mpg DESC LIMIT 1",
        "amends": [
            "Do specify `T1.car_name` in the SELECT list instead of using `*` to select all columns. Do join `data AS T1` and `production AS T2` with `INNER JOIN` instead of querying only the `cars` table. Do use the join condition `ON T1.ID = T2.ID` instead of no join condition. Do filter on `T2.model_year = '1975'` instead of `year = 1975`. Do order by `T1.mpg DESC` instead of just `mpg DESC`. The amended query now correctly retrieves the car name with the highest MPG for the 1975 model year by properly joining the data and production tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cars WHERE year = 1975 ORDER BY mpg DESC LIMIT 1;",
            "SELECT T1.car_name FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T2.model_year = '1975' ORDER BY T1.mpg DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "4920": {
        "db_id": "olympics",
        "question": "Among all the Olympic competitors from Finland, how many of them are female?",
        "ground_truth": "SELECT COUNT(T3.id) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Finland' AND T3.gender = 'F'",
        "amends": [
            "Do join `noc_region` as `T1` and `person_region` as `T2` on `T1.id=T2.region_id` instead of querying `athletes` directly. Do then join `person` as `T3` on `T2.person_id=T3.id` instead of missing these table relationships. Do filter on `T1.region_name='Finland'` instead of `country='Finland'` and use `T3.gender='F'` instead of `gender='Male'`. Do count `T3.id` instead of `COUNT(*)` to ensure accurate counting of distinct persons. The amended query now correctly navigates the relational schema to count Finnish female athletes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE country = 'Finland' AND gender = 'Male';",
            "SELECT COUNT(DISTINCT T3.id) \nFROM noc_region T1 \nJOIN person_region T2 ON T1.id = T2.region_id \nJOIN person T3 ON T2.person_id = T3.id \nWHERE T1.region_name = 'Finland' AND T3.gender = 'F'"
        ],
        "rule_sql": []
    },
    "7475": {
        "db_id": "image_and_language",
        "question": "What is the ID of the image with the most number of object samples?",
        "ground_truth": "SELECT IMG_ID FROM IMG_OBJ GROUP BY IMG_ID ORDER BY COUNT(OBJ_SAMPLE_ID) DESC LIMIT 1",
        "amends": [
            "Do select `IMG_ID` instead of `image_id` and do group by `IMG_ID` instead of ordering by count without grouping. Do count `OBJ_SAMPLE_ID` instead of using `COUNT(*)` and do specify the table `IMG_OBJ` instead of `object_samples`. The amended query now correctly groups by image ID and counts object sample IDs per group before ordering by the count in descending order to find the image with the most object samples."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id FROM object_samples ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT IMG_ID FROM IMG_OBJ GROUP BY IMG_ID ORDER BY COUNT(OBJ_SAMPLE_ID) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4435": {
        "db_id": "student_loan",
        "question": "What is the percentage of unemployed students who have been absent for 5 months from school?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.month > 5, 1, 0)) AS REAL) * 100 / COUNT(T1.month) FROM longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name",
        "amends": [
            "Do use `CAST(SUM(IIF(T1.month > 5, 1, 0)) AS REAL) * 100 / COUNT(T1.month)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed')` for the percentage calculation. Do change the FROM clause to use `longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name` instead of `students` with a WHERE filter on `employment_status = 'unemployed'`. Do remove the explicit WHERE clause `employment_status = 'unemployed' AND months_absent = 5` instead of keeping it, as the join condition and IIF logic now handle the filtering and counting. Do add the join condition `ON T1.name = T2.name` instead of omitting it. The amended query now correctly calculates the percentage of students with absences longer than 5 months among the unemployed population using proper table joins and conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed')) AS percentage\nFROM students \nWHERE employment_status = 'unemployed' \nAND months_absent = 5;",
            "SELECT CAST(SUM(IIF(T1.month > 5, 1, 0)) AS REAL) * 100 / COUNT(T1.month) AS percentage\nFROM longest_absense_from_school AS T1\nINNER JOIN unemployed AS T2 ON T1.name = T2.name;"
        ],
        "rule_sql": []
    },
    "6741": {
        "db_id": "retails",
        "question": "Among the parts supplied by Supplier#000000018, provide parts names which had supply costs above 900.",
        "ground_truth": "SELECT T2.p_name FROM partsupp AS T1 INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey INNER JOIN supplier AS T3 ON T1.ps_suppkey = T3.s_suppkey WHERE T1.ps_supplycost > 900 AND T3.s_name = 'Supplier#000000018'",
        "amends": [
            "Do join `partsupp AS T1` and `part AS T2` on `T1.ps_partkey = T2.p_partkey` instead of querying `parts` directly without proper joins. Do add `supplier AS T3` joined on `T1.ps_suppkey = T3.s_suppkey` instead of omitting the supplier table. Do filter on `T3.s_name = 'Supplier#000000018'` instead of `s_suppkey = '000000018'` to use the correct supplier identifier. Do reference `T2.p_name` instead of just `p_name` to specify the table alias. Do keep the `ps_supplycost > 900` filter but apply it to `T1` instead of an undefined table. The amended query now correctly joins the necessary tables and uses proper filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p_name FROM parts WHERE s_suppkey = '000000018' AND ps_supplycost > 900",
            "SELECT T2.p_name\nFROM partsupp AS T1\nJOIN part AS T2 ON T1.ps_partkey = T2.p_partkey\nJOIN supplier AS T3 ON T1.ps_suppkey = T3.s_suppkey\nWHERE T3.s_name = 'Supplier#000000018'\nAND T1.ps_supplycost > 900"
        ],
        "rule_sql": []
    },
    "7953": {
        "db_id": "music_platform_2",
        "question": "Indicate the slug and the itunes url of the podcast whose review content was written Can't stop listening.",
        "ground_truth": "SELECT slug, itunes_url FROM podcasts WHERE podcast_id IN ( SELECT podcast_id FROM reviews WHERE content = 'Can''t stop listening' )",
        "amends": [
            "Do use a subquery with `podcast_id IN (SELECT podcast_id FROM reviews)` instead of directly filtering on `review_content` from the podcasts table. Do reference the `content` column from the `reviews` table instead of the non-existent `review_content` column in the podcasts table. Do join through the reviews table to find podcasts with matching content instead of incorrectly assuming the review data exists directly in the podcasts table. The amended query now correctly matches podcasts to their reviews through the proper relational structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT slug, itunes_url FROM podcasts WHERE review_content = 'Can''t stop listening'",
            "SELECT p.slug, p.itunes_url\nFROM podcasts p\nWHERE p.podcast_id IN (\n    SELECT podcast_id \n    FROM reviews \n    WHERE content = 'Can''t stop listening'\n)"
        ],
        "rule_sql": []
    },
    "2380": {
        "db_id": "superstore",
        "question": "Give the customer segment from the West region that orders the order ID CA-2011-108189.",
        "ground_truth": "SELECT DISTINCT T2.Segment FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.Region = 'West' AND T1.`Order ID` = 'CA-2011-108189'",
        "amends": [
            "Do select `T2.Segment` instead of `customer_segment`. Do use `DISTINCT` instead of omitting it. Do join `west_superstore AS T1` and `people AS T2` instead of querying only `customers`. Do use `INNER JOIN` on `T1.Customer ID = T2.Customer ID` instead of no join condition. Do filter on `T1.Region = 'West'` and `T1.Order ID = 'CA-2011-108189'` instead of filtering on `region` and `order_id` from a single table. The amended query now correctly joins customer data with people information to retrieve the segment for the specified order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_segment FROM customers WHERE region = 'West' AND order_id = 'CA-2011-108189';",
            "SELECT DISTINCT T2.Segment\nFROM west_superstore AS T1\nINNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nWHERE T1.Region = 'West' AND T1.\"Order ID\" = 'CA-2011-108189'"
        ],
        "rule_sql": []
    },
    "9146": {
        "db_id": "movie_3",
        "question": "State the number of addresses in the Nordrhein-Westfalen district.",
        "ground_truth": "SELECT COUNT(address_id) FROM address WHERE district = 'Nordrhein-Westfalen'",
        "amends": [
            "Do count `address_id` instead of `*` to accurately count non-null address records. Do reference table `address` instead of `addresses` to use the correct table name. The amended query now correctly counts addresses in the specified district using the proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM addresses WHERE district = 'Nordrhein-Westfalen';",
            "SELECT COUNT(address_id) FROM address WHERE district = 'Nordrhein-Westfalen';"
        ],
        "rule_sql": []
    },
    "4824": {
        "db_id": "legislator",
        "question": "How many minority leaders have not been registered in Federal Election Commission data?",
        "ground_truth": "SELECT COUNT(*) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.title = 'Minority Leader' AND (T1.fec_id IS NULL OR T1.fec_id = '')",
        "amends": [
            "Do change the entire query structure by using `INNER JOIN` between `current` and `current-terms` tables on `bioguide_id = bioguide` instead of querying `minority_leaders` with a subquery. Do add filter condition `T2.title = 'Minority Leader'` to identify the specific role instead of relying on table name. Do replace the NOT EXISTS subquery with direct NULL/empty string checks `T1.fec_id IS NULL OR T1.fec_id = ''` instead of checking for non-existence in the federal_election_commission table. Do remove the subquery correlation entirely and instead use direct column filtering on the joined tables. The amended query now correctly counts minority leaders with missing FEC IDs by joining the appropriate tables and checking for null or empty values directly."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM minority_leaders WHERE NOT EXISTS (SELECT 1 FROM federal_election_commission WHERE minority_leaders.id = federal_election_commission.leader_id);",
            "SELECT COUNT(*)\nFROM current T1\nINNER JOIN \"current-terms\" T2 ON T1.bioguide_id = T2.bioguide\nWHERE T2.title = 'Minority Leader'\nAND (T1.fec_id IS NULL OR T1.fec_id = '')"
        ],
        "rule_sql": []
    },
    "5125": {
        "db_id": "address",
        "question": "Which city and state has the bad alias of Lawrenceville?",
        "ground_truth": "SELECT T2.city, T2.state FROM avoid AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.bad_alias = 'Lawrenceville' GROUP BY T2.city, T2.state",
        "amends": [
            "Do add tables `avoid AS T1` and `zip_data AS T2` instead of querying only `locations`. Do change the join to `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of no join. Do change the filter to `T1.bad_alias = 'Lawrenceville'` instead of `alias = 'Lawrenceville'`. Do add `GROUP BY T2.city, T2.state` instead of omitting it. The amended query now correctly joins the avoid and zip_data tables to filter by bad_alias and returns grouped city and state data, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, state FROM locations WHERE alias = 'Lawrenceville';",
            "SELECT T2.city, T2.state\nFROM avoid AS T1\nINNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code\nWHERE T1.bad_alias = 'Lawrenceville'\nGROUP BY T2.city, T2.state"
        ],
        "rule_sql": []
    },
    "6050": {
        "db_id": "books",
        "question": "Who is the author of the book The Mystery in the Rocky Mountains?",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T1.title = 'The Mystery in the Rocky Mountains'",
        "amends": [
            "Do select `T3.author_name` instead of `title` from the result set. Do join `book AS T1` with `book_author AS T2` on `T1.book_id = T2.book_id` instead of querying only the `books` table. Do add a second join to `author AS T3` on `T3.author_id = T2.author_id` instead of omitting the author table entirely. Do filter on `T1.title = 'The Mystery in the Rocky Mountains'` instead of filtering on `author = 'The Mystery in the Rocky Mountains'` which incorrectly treats the title value as an author name. The amended query now correctly retrieves the author name for the specified book title instead of incorrectly searching for a book by an author name that should be the title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE author = 'The Mystery in the Rocky Mountains';",
            "SELECT T3.author_name \nFROM book AS T1\nJOIN book_author AS T2 ON T1.book_id = T2.book_id\nJOIN author AS T3 ON T3.author_id = T2.author_id\nWHERE T1.title = 'The Mystery in the Rocky Mountains'"
        ],
        "rule_sql": []
    },
    "459": {
        "db_id": "movies_4",
        "question": "How many times did Bob Peterson appear in the movie credits?",
        "ground_truth": "SELECT COUNT(T2.movie_id) FROM person AS T1 INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Bob Peterson'",
        "amends": [
            "Do join `person AS T1` and `movie_cast AS T2` with `INNER JOIN` on `T1.person_id = T2.person_id` instead of querying only `movie_credits` table. Do select `COUNT(T2.movie_id)` instead of `COUNT(*)` to count specific movie appearances. Do filter on `T1.person_name = 'Bob Peterson'` instead of `actor_name = 'Bob Peterson'` to use the correct column name from the proper table. The amended query now correctly counts movies for the specified person by joining the appropriate tables and using accurate column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movie_credits WHERE actor_name = 'Bob Peterson';",
            "SELECT COUNT(T2.movie_id) \nFROM person AS T1 \nINNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id \nWHERE T1.person_name = 'Bob Peterson'"
        ],
        "rule_sql": []
    },
    "731": {
        "db_id": "movie",
        "question": "Which character has the longest screen time in the movie Batman?",
        "ground_truth": "SELECT T2.`Character Name` FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T1.Title = 'Batman' ORDER BY T2.screentime DESC LIMIT 1",
        "amends": [
            "Do select `T2.Character Name` instead of `character_name, MAX(screen_time)` and remove the aggregate function. Do use `FROM movie AS T1 INNER JOIN characters AS T2` instead of `FROM movie_characters` with a single table. Do add join condition `ON T1.MovieID = T2.MovieID` instead of omitting it. Do move the filter to `WHERE T1.Title = 'Batman'` instead of `WHERE movie_title = 'Batman'` with different column reference. Do change ordering to `ORDER BY T2.screentime DESC` instead of `ORDER BY screen_time DESC` with different column reference. Do remove `GROUP BY character_name` instead of keeping it since no aggregation is needed. The amended query now correctly joins the movie and characters tables to find the character with maximum screen time for the Batman movie."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name, MAX(screen_time) FROM movie_characters WHERE movie_title = 'Batman' GROUP BY character_name ORDER BY screen_time DESC LIMIT 1;",
            "SELECT T2.\"Character Name\"\nFROM movie AS T1\nINNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID\nWHERE T1.Title = 'Batman'\nORDER BY T2.screentime DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "377": {
        "db_id": "retail_complains",
        "question": "What is the oldest age of male clients?",
        "ground_truth": "SELECT MAX(age) FROM client WHERE sex = 'Male'",
        "amends": [
            "Do use `MAX(age)` instead of `MIN(age)` to find the highest age rather than the lowest. Do reference table `client` instead of `clients` with the correct table name. Do filter on `sex = 'Male'` instead of `gender = 'male'` using the proper column name and case-sensitive value. The amended query now correctly identifies the maximum age from the specified table with accurate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(age) FROM clients WHERE gender = 'male';",
            "SELECT MAX(age) FROM client WHERE sex = 'Male';"
        ],
        "rule_sql": []
    },
    "8685": {
        "db_id": "chicago_crime",
        "question": "Give the case number and coordinates of the places where child abduction is reported.",
        "ground_truth": "SELECT T1.case_number, T1.latitude, T1.longitude FROM Crime AS T1 INNER JOIN IUCR AS T2 ON T2.iucr_no = T1.iucr_no WHERE T2.secondary_description = 'CHILD ABDUCTION'",
        "amends": [
            "Do select `T1.case_number, T1.latitude, T1.longitude` instead of `case_number, coordinates`. Do add `INNER JOIN IUCR AS T2 ON T2.iucr_no = T1.iucr_no` instead of omitting the join. Do change the filter to `T2.secondary_description = 'CHILD ABDUCTION'` instead of `crime_type = 'child abduction'`. Do add table alias `T1` to the columns instead of using unqualified column names. The amended query now correctly joins the Crime and IUCR tables to filter based on the secondary description rather than a non-existent crime_type column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT case_number, coordinates FROM crimes WHERE crime_type = 'child abduction';",
            "SELECT T1.case_number, T1.latitude, T1.longitude\nFROM Crime AS T1\nINNER JOIN IUCR AS T2 ON T2.iucr_no = T1.iucr_no\nWHERE T2.secondary_description = 'CHILD ABDUCTION'"
        ],
        "rule_sql": []
    },
    "3779": {
        "db_id": "public_review_platform",
        "question": "What is the number of reviews from user No. \"21679\"?",
        "ground_truth": "SELECT COUNT(review_length) FROM Reviews WHERE user_id = 21679",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE user_id = 21679;"
        ],
        "rule_sql": []
    },
    "7590": {
        "db_id": "image_and_language",
        "question": "For those objects that have multiple relations, how many images have a prediction class of \"reading\"?",
        "ground_truth": "SELECT COUNT(T1.IMG_ID) FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T2.PRED_CLASS = 'reading'",
        "amends": [
            "Do select `COUNT(T1.IMG_ID)` from specific column instead of `COUNT(*)` from all rows. Do use `IMG_REL AS T1` and `PRED_CLASSES AS T2` as source tables instead of `images` alone. Do perform `INNER JOIN` on `T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` instead of using a subquery with `GROUP BY` and `HAVING`. Do filter with `WHERE T2.PRED_CLASS = 'reading'` instead of `WHERE prediction_class = 'reading' AND object_id IN` subquery. Do remove the subquery and `GROUP BY/HAVING` logic entirely instead of keeping complex nested filtering. The amended query now correctly counts images with the 'reading' prediction class by joining through proper relationship tables rather than relying on object counting logic.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the right query counts all matching rows without requiring distinct values. Do maintain the same `SELECT COUNT(T1.IMG_ID)` column expression instead of changing it. Do preserve the `FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` join structure without modification. Do keep the `WHERE T2.PRED_CLASS = 'reading'` filter unchanged. The amended query now correctly counts all image relationships for the 'reading' predicate class rather than counting distinct image IDs, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE prediction_class = 'reading' AND object_id IN (SELECT object_id FROM relations GROUP BY object_id HAVING COUNT(*) > 1);",
            "SELECT COUNT(DISTINCT T1.IMG_ID) \nFROM IMG_REL AS T1\nINNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID\nWHERE T2.PRED_CLASS = 'reading'",
            "SELECT COUNT(T1.IMG_ID) \nFROM IMG_REL AS T1 \nINNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID \nWHERE T2.PRED_CLASS = 'reading'"
        ],
        "rule_sql": []
    },
    "8354": {
        "db_id": "mondial_geo",
        "question": "What is the average area of Asian countries?",
        "ground_truth": "SELECT AVG(Area) FROM country AS T1 INNER JOIN encompasses AS T2 ON T1.Code = T2.Country WHERE T2.Continent = 'Asia'",
        "amends": [
            "Do use `AVG(Area)` instead of `AVG(population)` for the aggregate calculation. Do add `country AS T1 INNER JOIN encompasses AS T2 ON T1.Code = T2.Country` instead of querying only the `countries` table. Do change the filter to `T2.Continent = 'Asia'` instead of `continent = 'Asia'` to reference the correct table and column. The amended query now correctly joins the country and encompasses tables to calculate the average area of Asian countries instead of attempting to average population from a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(population) FROM countries WHERE continent = 'Asia';",
            "SELECT AVG(T1.Area) FROM country AS T1 INNER JOIN encompasses AS T2 ON T1.Code = T2.Country WHERE T2.Continent = 'Asia'"
        ],
        "rule_sql": []
    },
    "1915": {
        "db_id": "soccer_2016",
        "question": "Indicate the name of the most versatile players of the Delhi Daredevils.",
        "ground_truth": "SELECT T3.Player_Name FROM Player_Match AS T1 INNER JOIN Team AS T2 ON T1.Team_Id = T2.Team_Id INNER JOIN Player AS T3 ON T1.Player_Id = T3.Player_Id WHERE T2.Team_Name = 'Delhi Daredevils' GROUP BY T3.Player_Name ORDER BY COUNT(T1.Role_Id) DESC LIMIT 1",
        "amends": [
            "Do use `T3.Player_Name` from the `Player` table instead of `player_name` from a non-existent `players` table. Do join `Player_Match AS T1` and `Team AS T2` with `INNER JOIN` on `T1.Team_Id = T2.Team_Id` instead of querying a single table. Do add another `INNER JOIN` to `Player AS T3` on `T1.Player_Id = T3.Player_Id` instead of missing this relationship. Do filter on `T2.Team_Name = 'Delhi Daredevils'` instead of `team = 'Delhi Daredevils'` with incorrect column reference. Do add `GROUP BY T3.Player_Name` instead of omitting grouping. Do order by `COUNT(T1.Role_Id) DESC` instead of `runs_scored DESC` with incorrect metric. The amended query now correctly identifies players by team membership and counts their role appearances rather than using non-existent columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE team = 'Delhi Daredevils' ORDER BY runs_scored DESC LIMIT 1;",
            "SELECT T3.Player_Name\nFROM Player_Match AS T1\nINNER JOIN Team AS T2 ON T1.Team_Id = T2.Team_Id\nINNER JOIN Player AS T3 ON T1.Player_Id = T3.Player_Id\nWHERE T2.Team_Name = 'Delhi Daredevils'\nGROUP BY T3.Player_Name\nORDER BY COUNT(T1.Role_Id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "314": {
        "db_id": "retail_complains",
        "question": "What percentage of clients who sent their complaints by postal mail are age 50 and older?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.age > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.`Submitted via`) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Submitted via` = 'Postal mail'",
        "amends": [
            "Do use `SUM(CASE WHEN age > 50 THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only clients over 50. Do add `INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID` instead of querying only the clients table. Do reference `T2.Submitted via` instead of `complaint_method` for the filter condition. Do use `CAST(... AS REAL)` instead of implicit decimal conversion for accurate percentage calculation. Do filter on `T2.Submitted via = 'Postal mail'` instead of `complaint_method = 'postal mail'` with proper case sensitivity. Do remove the subquery denominator calculation instead of using a separate subquery. The amended query now correctly calculates the percentage of clients over age 50 who submitted via postal mail by joining with events data and using proper aggregation.",
            "Do use `age > 50` instead of `age >= 50` in the CASE condition. Do multiply before division with `* 100 / COUNT()` instead of `/ COUNT(*) * 100` to maintain mathematical correctness. Do count `T2.Submitted via` instead of `*` to ensure counting only non-null values from the joined table. The amended query now correctly calculates the percentage of clients over 50 who submitted via postal mail.",
            "Do use `age > 50` instead of `age >= 50` in the CASE condition. Do multiply the SUM result by 100 before division instead of multiplying the entire division result. Do divide by `COUNT(T2.Submitted via)` instead of `COUNT(*)`. Do remove the alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage of clients over 50 years old who submitted via postal mail."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM clients WHERE complaint_method = 'postal mail') AS percentage\nFROM clients\nWHERE complaint_method = 'postal mail' AND age >= 50;",
            "SELECT \n    CAST(SUM(CASE WHEN T1.age >= 50 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS percentage\nFROM \n    client AS T1\nINNER JOIN \n    events AS T2 ON T1.client_id = T2.Client_ID\nWHERE \n    T2.\"Submitted via\" = 'Postal mail'",
            "SELECT \n    CAST(SUM(CASE WHEN T1.age >= 50 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS REAL) AS percentage\nFROM \n    client AS T1\nINNER JOIN \n    events AS T2 ON T1.client_id = T2.Client_ID\nWHERE \n    T2.\"Submitted via\" = 'Postal mail';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.age > 50 THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(T2.\"Submitted via\") AS percentage\nFROM \n    client AS T1\nINNER JOIN \n    events AS T2 ON T1.client_id = T2.Client_ID\nWHERE \n    T2.\"Submitted via\" = 'Postal mail';"
        ],
        "rule_sql": []
    },
    "2023": {
        "db_id": "soccer_2016",
        "question": "Who is the youngest player and which city did he/she come from?",
        "ground_truth": "SELECT T3.City_Name FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id INNER JOIN City AS T3 ON T2.Country_Id = T3.Country_Id ORDER BY T1.DOB LIMIT 1",
        "amends": [
            "Do select `T3.City_Name` instead of `name, city` from the result set. Do use `INNER JOIN` with `Country` on `T1.Country_Name = T2.Country_Id` instead of omitting this table and join condition. Do add `INNER JOIN` with `City` on `T2.Country_Id = T3.Country_Id` instead of omitting this table and relationship. Do order by `T1.DOB` instead of `age DESC` for the chronological sorting. Do remove the explicit `FROM players` clause and instead use properly aliased table references in the join structure. The amended query now correctly retrieves the city name through proper table relationships instead of attempting to directly access city data from a players table.",
            "Do select only `T3.City_Name` instead of both `p.Player_Name` and `c.City_Name`. Do use table aliases `T1`, `T2`, and `T3` instead of `p`, `co`, and `c`. Do remove the explicit `ASC` from `ORDER BY T1.DOB` instead of keeping it. The amended query now correctly returns only the city name of the youngest player, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, city FROM players ORDER BY age DESC LIMIT 1;",
            "SELECT p.Player_Name, c.City_Name\nFROM Player p\nINNER JOIN Country co ON p.Country_Name = co.Country_Id\nINNER JOIN City c ON co.Country_Id = c.Country_Id\nORDER BY p.DOB ASC\nLIMIT 1;",
            "SELECT T3.City_Name\nFROM Player T1\nINNER JOIN Country T2 ON T1.Country_Name = T2.Country_Id\nINNER JOIN City T3 ON T2.Country_Id = T3.Country_Id\nORDER BY T1.DOB\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3542": {
        "db_id": "authors",
        "question": "Between \"Standford University\" and \"Massachusetts Institute of Technolgy\", which organization had affiliated with more author.?",
        "ground_truth": "SELECT Affiliation FROM Author WHERE Affiliation IN ('Stanford University', 'Massachusetts Institute of Technology') GROUP BY Affiliation ORDER BY COUNT(Id) DESC LIMIT 1",
        "amends": [
            "Do use `Affiliation` instead of `organization` for the column name and `Author` instead of `authors` for the table name. Do use `Stanford University` instead of `Standford University` and `Massachusetts Institute of Technology` instead of `Massachusetts Institute of Technolgy` for the correct spelling in the IN clause. Do use `Id` instead of `author_id` for the count column and place the aggregate function `COUNT(Id)` directly in the ORDER BY clause instead of referencing the alias `author_count`. Do remove the alias `author_count` instead of keeping it since it's no longer referenced. The amended query now correctly counts authors by affiliation with proper spelling and ordering.",
            "Do select only `Affiliation` instead of selecting both `Affiliation` and `COUNT(Id)` in the SELECT list. Do remove the aggregate function `COUNT(Id)` from the output columns instead of including it, as the query only needs to return the affiliation with the highest count rather than displaying the count value itself. The amended query now correctly returns just the affiliation name with the maximum count of authors from the specified institutions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization, COUNT(author_id) as author_count \nFROM authors \nWHERE organization IN ('Standford University', 'Massachusetts Institute of Technolgy') \nGROUP BY organization \nORDER BY author_count DESC \nLIMIT 1;",
            "SELECT Affiliation, COUNT(Id) \nFROM Author \nWHERE Affiliation IN ('Stanford University', 'Massachusetts Institute of Technology') \nGROUP BY Affiliation \nORDER BY COUNT(Id) DESC \nLIMIT 1;",
            "SELECT Affiliation\nFROM Author\nWHERE Affiliation IN ('Stanford University', 'Massachusetts Institute of Technology')\nGROUP BY Affiliation\nORDER BY COUNT(Id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7157": {
        "db_id": "works_cycles",
        "question": "For the document Control Assistant who was born on 1975/12/25, how many private documents did he/she have?",
        "ground_truth": "SELECT COUNT(T2.BusinessEntityID) FROM Document AS T1 INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE T2.JobTitle = 'Document Control Assistant' AND T2.BirthDate = '1975-12-25' AND T1.DocumentSummary IS NULL",
        "amends": [
            "Do join `Employee` as `T2` on `T1.Owner = T2.BusinessEntityID` instead of querying only the `documents` table. Do filter on `T2.JobTitle = 'Document Control Assistant'` instead of `owner_role = 'Control Assistant'`. Do use `T2.BirthDate = '1975-12-25'` with proper date format instead of `birth_date = '1975/12/25'`. Do add filter `T1.DocumentSummary IS NULL` instead of filtering on `document_type = 'private'`. Do count `T2.BusinessEntityID` instead of using `COUNT(*)`. The amended query now correctly counts employees with the specified job title and birth date who own documents without summaries, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM documents WHERE owner_role = 'Control Assistant' AND birth_date = '1975/12/25' AND document_type = 'private';",
            "SELECT COUNT(T2.BusinessEntityID) \nFROM Document AS T1\nJOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID\nWHERE T2.JobTitle = 'Document Control Assistant'\nAND T2.BirthDate = '1975-12-25'\nAND T1.DocumentSummary IS NULL"
        ],
        "rule_sql": []
    },
    "190": {
        "db_id": "book_publishing_company",
        "question": "Name the title with the highest price published by 'Binnet & Hardley'.",
        "ground_truth": "SELECT T1.title FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE T2.pub_name = 'Binnet & Hardley' ORDER BY T1.price DESC LIMIT 1",
        "amends": [
            "Do join `publishers AS T2` on `T1.pub_id = T2.pub_id` instead of querying `titles` directly without a join. Do reference `T1.title` and `T1.price` with table aliases instead of unqualified column names. Do filter on `T2.pub_name = 'Binnet & Hardley'` through the joined table instead of directly on the titles table. Do order by `T1.price DESC` instead of `price ASC` to get the highest price instead of the lowest. The amended query now correctly joins to the publishers table to filter by publisher name and returns the highest-priced title matching the specified publisher."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM titles WHERE pub_name = 'Binnet & Hardley' ORDER BY price ASC LIMIT 1;",
            "SELECT T1.title\nFROM titles AS T1\nJOIN publishers AS T2 ON T1.pub_id = T2.pub_id\nWHERE T2.pub_name = 'Binnet & Hardley'\nORDER BY T1.price DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3484": {
        "db_id": "video_games",
        "question": "In which year did the record ID 19 with game publisher ID 6657 released?",
        "ground_truth": "SELECT T.release_year FROM game_platform AS T WHERE T.game_publisher_id = 6657 AND T.id = 19",
        "amends": [
            "Do reference the table with alias `T` instead of using the bare table name. Do select from `game_platform AS T` instead of from `games`. Do use filter `T.game_publisher_id = 6657` instead of `publisher_id = 6657`. Do use filter `T.id = 19` instead of `record_id = 19`. The amended query now correctly references the game_platform table with appropriate column names and aliases, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_year FROM games WHERE record_id = 19 AND publisher_id = 6657;",
            "SELECT T.release_year FROM game_platform AS T WHERE T.id = 19 AND T.game_publisher_id = 6657"
        ],
        "rule_sql": []
    },
    "8523": {
        "db_id": "software_company",
        "question": "Of the first 60,000 customers who sent a true response to the incentive mailing sent by the marketing department, how many of them are divorced males?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE T1.SEX = 'Male' AND T1.MARITAL_STATUS = 'Divorced' AND T2.RESPONSE = 'true'",
        "amends": [
            "Do add `INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID` instead of querying only the `customers` table. Do change the count expression to `COUNT(T1.ID)` instead of `COUNT(*)`. Do reference `T1.SEX` instead of `gender` and `T1.MARITAL_STATUS` instead of `marital_status`. Do move the `RESPONSE` filter to the joined `T2` table instead of applying it to the customers table. Do remove the `customer_id <= 60000` filter instead of keeping it. The amended query now correctly joins the customer and mailing tables to count responses from divorced male customers, matching the RIGHT_SQL's behavior.",
            "Do use `'Male'` instead of `'male'` for the SEX filter and `'Divorced'` instead of `'divorced'` for the MARITAL_STATUS filter to match the correct case sensitivity. Do remove the `LIMIT 60000` clause instead of keeping it since aggregate COUNT queries don't require row limiting. The amended query now correctly counts male divorced customers with true responses without unnecessary row limitations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers \nWHERE customer_id <= 60000 \nAND response = 'true' \nAND marital_status = 'divorced' \nAND gender = 'male';",
            "SELECT COUNT(T1.ID) \nFROM Customers AS T1\nINNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID\nWHERE T2.RESPONSE = 'true'\nAND T1.SEX = 'male'\nAND T1.MARITAL_STATUS = 'divorced'\nLIMIT 60000",
            "SELECT COUNT(T1.ID)\nFROM Customers AS T1\nINNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID\nWHERE T2.RESPONSE = 'true'\nAND T1.SEX = 'Male'\nAND T1.MARITAL_STATUS = 'Divorced'"
        ],
        "rule_sql": []
    },
    "9213": {
        "db_id": "movie_3",
        "question": "Write down any five film names under the documentary category.",
        "ground_truth": "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Documentary' LIMIT 5",
        "amends": [
            "Do use `T1.title` with explicit table alias instead of `title` without qualification. Do join `film AS T1`, `film_category AS T2`, and `category AS T3` instead of querying only `films` table. Do use `INNER JOIN` with `T1.film_id = T2.film_id` and `T2.category_id = T3.category_id` instead of no joins. Do filter on `T3.name = 'Documentary'` instead of `category = 'Action'`. The amended query now correctly joins through the category relationship tables and filters by category name rather than a non-existent category column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE category = 'Action' LIMIT 5;",
            "SELECT T1.title \nFROM film AS T1\nINNER JOIN film_category AS T2 ON T1.film_id = T2.film_id\nINNER JOIN category AS T3 ON T2.category_id = T3.category_id\nWHERE T3.name = 'Documentary'\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "646": {
        "db_id": "codebase_comments",
        "question": "Please provide the number of stars that the repository of the solution 20 have.",
        "ground_truth": "SELECT T1.Stars FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 20",
        "amends": [
            "Do select `T1.Stars` instead of `COUNT(*)` to retrieve the actual star count rather than a row count. Do add `FROM Repo AS T1 INNER JOIN Solution AS T2` instead of just `FROM stars` to properly join the repository and solution tables. Do use join condition `ON T1.Id = T2.RepoId` instead of no join condition to correctly relate repositories to their solutions. Do move the filter to `WHERE T2.Id = 20` instead of `WHERE solution_id = 20` to filter by solution ID through the joined Solution table rather than assuming a direct solution_id column exists in the stars table. The amended query now correctly retrieves the star count for a specific solution by joining the appropriate tables and filtering on the solution identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stars WHERE solution_id = 20;",
            "SELECT T1.Stars FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 20"
        ],
        "rule_sql": []
    },
    "1928": {
        "db_id": "soccer_2016",
        "question": "List the player's ID of the top five players, by descending order, in terms of bowling skill.",
        "ground_truth": "SELECT Player_Id FROM Player ORDER BY Bowling_skill DESC LIMIT 5",
        "amends": [
            "Do reference the table as `Player` instead of `players` and use column name `Player_Id` instead of `player_id` to match the correct schema. Do sort by `Bowling_skill DESC` instead of `ASC` to order from highest to lowest skill instead of lowest to highest. The amended query now correctly retrieves the top 5 players with the best bowling skills in descending order, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id FROM players ORDER BY bowling_skill ASC LIMIT 5;",
            "SELECT Player_Id FROM Player ORDER BY Bowling_skill DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "8326": {
        "db_id": "mondial_geo",
        "question": "List all the coral islands along with its city and province.",
        "ground_truth": "SELECT City, Province FROM locatedOn WHERE Island IN ( SELECT Name FROM island WHERE Type = 'coral' )",
        "amends": [
            "Do select `City` and `Province` instead of `island_name`, `city`, and `province`. Do query from `locatedOn` table instead of `coral_islands` table. Do use a subquery with `Island IN (SELECT Name FROM island WHERE Type = 'coral')` instead of a direct `WHERE type = 'mountain'` filter. Do remove the incorrect `island_name` column and change the filter condition from `'mountain'` to `'coral'` type matching. The amended query now correctly retrieves cities and provinces located on coral islands instead of attempting to find mountain-type coral islands."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT island_name, city, province FROM coral_islands WHERE type = 'mountain';",
            "SELECT City, Province FROM locatedOn WHERE Island IN (SELECT Name FROM island WHERE Type = 'coral')"
        ],
        "rule_sql": []
    },
    "614": {
        "db_id": "codebase_comments",
        "question": "Give the repository Url of the one with most solutions.",
        "ground_truth": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId GROUP BY T2.RepoId ORDER BY COUNT(T2.RepoId) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Url` instead of `repository_url` and do use `COUNT(T2.RepoId)` in ORDER BY instead of `solution_count`. Do use `FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId` instead of `FROM solutions` and do add `GROUP BY T2.RepoId` instead of omitting it. The amended query now correctly joins the Repo and Solution tables, groups by repository ID, and orders by the actual count of solutions per repository instead of relying on a potentially incorrect solution_count column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT repository_url FROM solutions ORDER BY solution_count DESC LIMIT 1;",
            "SELECT T1.Url\nFROM Repo AS T1\nINNER JOIN Solution AS T2 ON T1.Id = T2.RepoId\nGROUP BY T2.RepoId\nORDER BY COUNT(T2.RepoId) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5970": {
        "db_id": "books",
        "question": "List the author's name of the books published by Abrams.",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE T4.publisher_name = 'Abrams'",
        "amends": [
            "Do use `T3.author_name` instead of `author_name` to specify the table source. Do add joins to `book_author AS T2`, `author AS T3`, and `publisher AS T4` instead of querying only the `books` table. Do use `INNER JOIN` on `T1.book_id = T2.book_id` and `T3.author_id = T2.author_id` instead of missing these relationships. Do filter on `T4.publisher_name = 'Abrams'` instead of `publisher = 'Abrams'` to use the correct column from the publisher table. The amended query now correctly joins multiple tables to retrieve author names for books published by Abrams."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM books WHERE publisher = 'Abrams';",
            "SELECT T3.author_name\nFROM book AS T1\nINNER JOIN book_author AS T2 ON T1.book_id = T2.book_id\nINNER JOIN author AS T3 ON T3.author_id = T2.author_id\nINNER JOIN publisher AS T4 ON T1.publisher_id = T4.publisher_id\nWHERE T4.publisher_name = 'Abrams'"
        ],
        "rule_sql": []
    },
    "4248": {
        "db_id": "simpson_episodes",
        "question": "Please indicate the birthplace of the crew which name is Dan Castellaneta.",
        "ground_truth": "SELECT birth_place FROM Person WHERE name = 'Dan Castellaneta';",
        "amends": [
            "Do reference the `birth_place` column instead of `birthplace`. Do query from the `Person` table instead of the `crew` table. The amended query now correctly retrieves Dan Castellaneta's birth place from the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthplace FROM crew WHERE name = 'Dan Castellaneta';",
            "SELECT birth_place FROM Person WHERE name = 'Dan Castellaneta';"
        ],
        "rule_sql": []
    },
    "4176": {
        "db_id": "simpson_episodes",
        "question": "List down all the roles of Matt Groening on the episode titled 'In the Name of the Grandfather' along with the episode number and series number.",
        "ground_truth": "SELECT T2.role, T1.episode, T1.number_in_series FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.person = 'Matt Groening' AND T1.title = 'In the Name of the Grandfather';",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.role` instead of `role` and `T1.episode` instead of `episode_number`. Do use `T1.number_in_series` instead of `series_number`. Do join `Episode AS T1` instead of `episodes` and `Credit AS T2` instead of `roles`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do reference `T2.person` instead of joining with `people` table and using `people.name`. Do remove the unnecessary join to `people` table instead of keeping it. Do place both filters in the `WHERE` clause instead of having them there already. The amended query now correctly retrieves role, episode, and series number information using the proper table structure and eliminates the redundant join."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role, episode_number, series_number \nFROM episodes \nJOIN roles ON episodes.episode_id = roles.episode_id \nJOIN people ON roles.person_id = people.person_id \nWHERE people.name = 'Matt Groening' \nAND episodes.title = 'In the Name of the Grandfather';",
            "SELECT T2.role, T1.episode, T1.number_in_series\nFROM Episode AS T1\nINNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id\nWHERE T1.title = 'In the Name of the Grandfather'\nAND T2.person = 'Matt Groening'"
        ],
        "rule_sql": []
    },
    "133": {
        "db_id": "movie_platform",
        "question": "Which 1988 movie got the most ratings?",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_release_year = 1988 ORDER BY T1.rating_score DESC LIMIT 1",
        "amends": [
            "Do select `T2.movie_title` instead of `title` and omit the `COUNT(*) as rating_count` aggregation. Do use `INNER JOIN` with explicit table aliases `ratings AS T1` and `movies AS T2` instead of simple `JOIN` without aliases. Do use the join condition `T1.movie_id = T2.movie_id` instead of `movies.movie_id = ratings.movie_id`. Do filter with `T2.movie_release_year = 1988` instead of `year = 1988`. Do remove the `GROUP BY movies.movie_id` clause instead of keeping it. Do order by `T1.rating_score DESC` instead of the removed `rating_count DESC`. The amended query now correctly retrieves the highest-rated movie from 1988 based on individual rating scores rather than counting ratings."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, COUNT(*) as rating_count \nFROM movies \nJOIN ratings ON movies.movie_id = ratings.movie_id \nWHERE year = 1988 \nGROUP BY movies.movie_id \nORDER BY rating_count DESC \nLIMIT 1;",
            "SELECT T2.movie_title\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE T2.movie_release_year = 1988\nORDER BY T1.rating_score DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7322": {
        "db_id": "works_cycles",
        "question": "Calculate the average length of employment for employee working in the Research and Development deparment.",
        "ground_truth": "SELECT AVG(STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.HireDate)) FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T3.Name = 'Research and Development'",
        "amends": [
            "Do use `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.HireDate)` for year-based calculation instead of `DATEDIFF(CURDATE(), hire_date)` for day-based difference. Do add `INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` and `INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID` instead of querying only the `employees` table. Do filter on `T3.Name = 'Research and Development'` instead of `department = 'Research and Development'` to properly reference the joined department table. Do reference `T1.HireDate` instead of `hire_date` to use the aliased table column. The amended query now correctly calculates average employment length in years by joining through the department history relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(DATEDIFF(CURDATE(), hire_date)) AS avg_employment_length \nFROM employees \nWHERE department = 'Research and Development';",
            "SELECT AVG(STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.HireDate)) AS avg_employment_years\nFROM Employee AS T1\nINNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID\nWHERE T3.Name = 'Research and Development'"
        ],
        "rule_sql": []
    },
    "4827": {
        "db_id": "legislator",
        "question": "What is the total number of legislators with \"John\" as their first name?",
        "ground_truth": "SELECT COUNT(*) FROM current WHERE first_name = 'John'",
        "amends": [
            "Do query the `current` table instead of the `legislators` table. Do keep the `COUNT(*)` aggregate and `first_name = 'John'` filter unchanged. The amended query now correctly counts John entries from the current dataset instead of the outdated legislators table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE first_name = 'John';",
            "SELECT COUNT(*) FROM current WHERE first_name = 'John';"
        ],
        "rule_sql": []
    },
    "8439": {
        "db_id": "mondial_geo",
        "question": "Which country has three different religions-Anglicanism, Christianity, and Roman Catholicism and uses 100% English?",
        "ground_truth": "SELECT T2.Country FROM country AS T1 INNER JOIN religion AS T2 ON T1.Code = T2.Country INNER JOIN language AS T3 ON T3.Country = T2.Country WHERE (T2.Name = 'Anglican' OR T2.Name = 'Christian' OR T2.Name = 'Roman Catholic') AND T3.Name = 'English' AND T3.Percentage = 100 GROUP BY T1.Name HAVING COUNT(T1.Name) = 3",
        "amends": [
            "Do join multiple tables `country`, `religion`, and `language` instead of querying a single `countries` table. Do use `INNER JOIN` on `T1.Code = T2.Country` and `T3.Country = T2.Country` instead of incorrect single-table filtering. Do filter religion names with `OR` conditions `T2.Name = 'Anglican' OR T2.Name = 'Christian' OR T2.Name = 'Roman Catholic'` instead of impossible `AND` conditions on the same column. Do use `T3.Name = 'English' AND T3.Percentage = 100` instead of `language = 'English' AND language_percentage = 100`. Do add `GROUP BY T1.Name` and `HAVING COUNT(T1.Name) = 3` to ensure countries have all three religions instead of omitting grouping. Do select `T2.Country` instead of `country` from the appropriate table. The amended query now correctly identifies countries with all three specified religions and English language at 100% coverage.",
            "Do select `T2.Country` instead of `T1.Name` in the SELECT list. Do use table aliases `AS T1`, `AS T2`, and `AS T3` instead of omitting the AS keyword. Do change the join condition to `T3.Country = T2.Country` instead of `T1.Code = T3.Country`. Do update the WHERE filter to use `'Anglican'`, `'Christian'`, and `'Roman Catholic'` instead of `'Anglicanism'`, `'Christianity'`, and `'Roman Catholicism'`. Do modify the HAVING clause to use `COUNT(T1.Name) = 3` instead of `COUNT(DISTINCT T2.Name) = 3`. The amended query now correctly returns countries that have all three specified religious denominations and English as the official language at 100% prevalence.",
            "Do select `T2.Country` instead of `T1.Name` in the SELECT list. Do keep the same FROM sources with `INNER JOIN` on `T1.Code=T2.Country` and `INNER JOIN` on `T3.Country=T2.Country`. Do maintain the same WHERE filters for `T2.Name` values and `T3.Name='English'` with `T3.Percentage=100`. Do preserve the GROUP BY on `T1.Name` and HAVING condition `COUNT(T1.Name)=3`. The amended query now correctly returns countries rather than country names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM countries WHERE religion = 'Anglicanism' AND religion = 'Christianity' AND religion = 'Roman Catholicism' AND language = 'English' AND language_percentage = 100;",
            "SELECT T1.Name \nFROM country T1\nINNER JOIN religion T2 ON T1.Code = T2.Country\nINNER JOIN language T3 ON T1.Code = T3.Country\nWHERE (T2.Name = 'Anglicanism' OR T2.Name = 'Christianity' OR T2.Name = 'Roman Catholicism')\nAND T3.Name = 'English' AND T3.Percentage = 100\nGROUP BY T1.Name\nHAVING COUNT(DISTINCT T2.Name) = 3;",
            "SELECT T1.Name\nFROM country AS T1\nINNER JOIN religion AS T2 ON T1.Code = T2.Country\nINNER JOIN language AS T3 ON T3.Country = T2.Country\nWHERE (T2.Name = 'Anglican' OR T2.Name = 'Christian' OR T2.Name = 'Roman Catholic')\nAND T3.Name = 'English' AND T3.Percentage = 100\nGROUP BY T1.Name\nHAVING COUNT(T1.Name) = 3;",
            "SELECT T2.Country\nFROM country AS T1\nINNER JOIN religion AS T2 ON T1.Code = T2.Country\nINNER JOIN language AS T3 ON T3.Country = T2.Country\nWHERE (T2.Name = 'Anglican' OR T2.Name = 'Christian' OR T2.Name = 'Roman Catholic')\nAND T3.Name = 'English' AND T3.Percentage = 100\nGROUP BY T1.Name\nHAVING COUNT(T1.Name) = 3"
        ],
        "rule_sql": []
    },
    "4631": {
        "db_id": "disney",
        "question": "Among the movies directed by Wolfgang Reitherman, which one of them was the most popular?",
        "ground_truth": "SELECT T2.movie_title FROM director AS T1 INNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title WHERE T1.director = 'Wolfgang Reitherman' ORDER BY T2.total_gross DESC LIMIT 1",
        "amends": [
            "Do join `director AS T1` and `movies_total_gross AS T2` with `INNER JOIN` on `T1.name = T2.movie_title` instead of querying only the `movies` table. Do select `T2.movie_title` instead of `title, popularity`. Do filter on `T1.director = 'Wolfgang Reitherman'` instead of `director = 'Wolfgang Reitherman'`. Do order by `T2.total_gross DESC` instead of `release_date DESC`. The amended query now correctly retrieves movie titles based on director name and orders by total gross revenue instead of release date, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, popularity FROM movies WHERE director = 'Wolfgang Reitherman' ORDER BY release_date DESC LIMIT 1;",
            "SELECT T2.movie_title\nFROM director AS T1\nINNER JOIN movies_total_gross AS T2 ON T1.name = T2.movie_title\nWHERE T1.director = 'Wolfgang Reitherman'\nORDER BY T2.total_gross DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7976": {
        "db_id": "music_platform_2",
        "question": "How many reviews does \"Planet Money\" have?",
        "ground_truth": "SELECT COUNT(T2.podcast_id) FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'Planet Money'",
        "amends": [
            "Do join `podcasts AS T1` with `reviews AS T2` on `T2.podcast_id = T1.podcast_id` instead of querying only the `reviews` table. Do filter on `T1.title = 'Planet Money'` instead of `show_name = 'Planet Money'` to correctly reference the podcast title from the podcasts table. Do count `T2.podcast_id` instead of `COUNT(*)` to count reviews specifically for the target podcast. The amended query now correctly counts reviews for the 'Planet Money' podcast by joining the podcasts and reviews tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE show_name = 'Planet Money';",
            "SELECT COUNT(T2.podcast_id) FROM podcasts AS T1 JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'Planet Money'"
        ],
        "rule_sql": []
    },
    "7765": {
        "db_id": "hockey",
        "question": "Please list the first names of the coaches who have taught the Montreal Canadiens.",
        "ground_truth": "SELECT DISTINCT T3.firstName FROM Coaches AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.name = 'Montreal Canadiens'",
        "amends": [
            "Do use `DISTINCT T3.firstName` instead of `first_name` to select from the Master table with uniqueness. Do add joins to `Teams AS T2` on `T1.year = T2.year AND T1.tmID = T2.tmID` and `Master AS T3` on `T1.coachID = T3.coachID` instead of querying only the coaches table. Do filter on `T2.name = 'Montreal Canadiens'` instead of `team = 'Montreal Canadiens'` to reference the team name from the Teams table. Do use proper table aliases `T1`, `T2`, and `T3` instead of direct table references. The amended query now correctly joins across multiple tables to find coaches associated with the specified team name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM coaches WHERE team = 'Montreal Canadiens';",
            "SELECT DISTINCT T3.firstName\nFROM Coaches AS T1\nJOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID\nJOIN Master AS T3 ON T1.coachID = T3.coachID\nWHERE T2.name = 'Montreal Canadiens'"
        ],
        "rule_sql": []
    },
    "356": {
        "db_id": "retail_complains",
        "question": "State the first name of male clients who did not receive timely response from the call center.",
        "ground_truth": "SELECT T1.first FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Timely response?` = 'No' AND T1.sex = 'Male'",
        "amends": [
            "Do select `first` instead of `first_name` and from `client AS T1` instead of `clients`. Do add `INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID` instead of omitting the join. Do filter on `T2.\"Timely response?\" = 'No'` instead of `timely_response = 'yes'` and `T1.sex = 'Male'` instead of `gender = 'male'`. The amended query now correctly joins tables and filters for clients with untimely responses who are male, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM clients WHERE gender = 'male' AND timely_response = 'yes';",
            "SELECT T1.first\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T2.\"Timely response?\" = 'No'\nAND T1.sex = 'Male'"
        ],
        "rule_sql": []
    },
    "6743": {
        "db_id": "retails",
        "question": "How many of the line items have been shipped by rail with a quantity less than 30?",
        "ground_truth": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_quantity < 30 AND l_shipmode = 'RAIL'",
        "amends": [
            "Do reference the correct table name `lineitem` instead of `line_items`. Do use the correct column name `l_linenumber` for counting instead of `COUNT(*)`. Do apply the correct filter condition `l_quantity < 30` instead of `quantity > 30`. Do use the correct column name `l_shipmode` with value `'RAIL'` instead of `shipping_method = 'rail'`. The amended query now correctly counts line items with quantity less than 30 shipped by rail, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM line_items WHERE shipping_method = 'rail' AND quantity > 30;",
            "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_shipmode = 'RAIL' AND l_quantity < 30;"
        ],
        "rule_sql": []
    },
    "1508": {
        "db_id": "synthea",
        "question": "What are the medical encounter ids of patients who were born in Pembroke MA US?",
        "ground_truth": "SELECT DISTINCT T1.ENCOUNTER FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.birthplace = 'Pembroke MA US'",
        "amends": [
            "Do select `DISTINCT T1.ENCOUNTER` instead of `encounter_id` from a single table. Do join `careplans AS T1` with `patients AS T2` using `INNER JOIN` on `T1.PATIENT = T2.patient` instead of querying only the `patients` table. Do filter on `T2.birthplace = 'Pembroke MA US'` instead of separate conditions for `birth_city = 'Pembroke'`, `birth_state = 'MA'`, and `birth_country = 'US'`. The amended query now correctly retrieves distinct encounters from the careplans table for patients born in Pembroke MA US, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT encounter_id FROM patients WHERE birth_city = 'Pembroke' AND birth_state = 'MA' AND birth_country = 'US'",
            "SELECT DISTINCT T1.ENCOUNTER\nFROM careplans AS T1\nINNER JOIN patients AS T2 ON T1.PATIENT = T2.patient\nWHERE T2.birthplace = 'Pembroke MA US';"
        ],
        "rule_sql": []
    },
    "6216": {
        "db_id": "food_inspection_2",
        "question": "How many inspection points with serious point level that have no fine?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.point_id) FROM inspection_point AS T1 INNER JOIN violation AS T2 ON T1.point_id = T2.point_id WHERE T1.point_level = 'Serious ' AND T2.fine = 0",
        "amends": [
            "Do use `COUNT(DISTINCT T2.point_id)` instead of `COUNT(*)` to count unique violation records. Do join `violation AS T2` with `inspection_point AS T1` using `INNER JOIN` on `T1.point_id = T2.point_id` instead of querying only the `inspection_points` table. Do filter on `T1.point_level = 'Serious '` instead of `point_level = 'serious'` to match the exact case-sensitive value. Do use `T2.fine = 0` instead of `fine_amount IS NOT NULL` to specifically target violations with zero fines. The amended query now correctly counts distinct serious inspection points with zero fine violations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM inspection_points \nWHERE point_level = 'serious' \nAND fine_amount IS NOT NULL;",
            "SELECT COUNT(DISTINCT T2.point_id) \nFROM inspection_point AS T1 \nINNER JOIN violation AS T2 ON T1.point_id = T2.point_id \nWHERE T1.point_level = 'Serious ' AND T2.fine = 0"
        ],
        "rule_sql": []
    },
    "369": {
        "db_id": "retail_complains",
        "question": "Give me the full birthdate, email and phone number of the youngest client in Indianapolis .",
        "ground_truth": "SELECT T1.year, T1.month, T1.day, T1.email, T1.phone FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.city = 'Indianapolis' ORDER BY T1.year DESC, T1.month DESC, T1.day DESC LIMIT 1",
        "amends": [
            "Do select `T1.year`, `T1.month`, `T1.day`, `T1.email`, `T1.phone` instead of `birthdate`, `email`, `phone`. Do use `client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of just `clients`. Do filter on `T2.city = 'Indianapolis'` instead of directly on the client table's city. Do order by `T1.year DESC, T1.month DESC, T1.day DESC` instead of `birthdate ASC`. The amended query now correctly joins to the district table to filter by city and returns the most recent birthdate components instead of a single birthdate field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthdate, email, phone FROM clients WHERE city = 'Indianapolis' ORDER BY birthdate ASC LIMIT 1;",
            "SELECT T1.year, T1.month, T1.day, T1.email, T1.phone\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.city = 'Indianapolis'\nORDER BY T1.year DESC, T1.month DESC, T1.day DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2242": {
        "db_id": "world_development_indicators",
        "question": "How many countries have notes on the indicator Stocks traded, turnover ratio of domestic shares?",
        "ground_truth": "SELECT COUNT(T1.Countrycode)  FROM CountryNotes AS T1 INNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode WHERE T2.IndicatorName = 'Stocks traded, turnover ratio of domestic shares (%)'",
        "amends": [
            "Do select `COUNT(T1.Countrycode)` from specific columns instead of `COUNT(*)` from all rows. Do join `CountryNotes AS T1` with `Series AS T2` using `INNER JOIN` on `T1.Seriescode = T2.SeriesCode` instead of querying only the `countries` table. Do filter on `T2.IndicatorName = 'Stocks traded, turnover ratio of domestic shares (%)'` with the correct indicator name including percentage symbol instead of the incomplete indicator name. Do remove the `notes IS NOT NULL` filter entirely instead of keeping it, as the join condition and specific column selection make this filter unnecessary. The amended query now correctly counts country codes from the joined tables matching the precise indicator name, ensuring accurate results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE indicator = 'Stocks traded, turnover ratio of domestic shares' AND notes IS NOT NULL;",
            "SELECT COUNT(T1.Countrycode) \nFROM CountryNotes AS T1 \nINNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode \nWHERE T2.IndicatorName = 'Stocks traded, turnover ratio of domestic shares (%)'"
        ],
        "rule_sql": []
    },
    "143": {
        "db_id": "movie_platform",
        "question": "Among the lists with at least one follower, how many were created by user who was subscriber when created the list?",
        "ground_truth": "SELECT COUNT(T1.list_id) FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T2.list_followers >= 1 AND T1.user_subscriber = 1",
        "amends": [
            "Do select `COUNT(T1.list_id)` instead of `COUNT(*)` to count specific non-null values. Do use `lists_users AS T1` as the primary table instead of `lists l` to access user-list relationships. Do join with `lists AS T2` on `T1.list_id = T2.list_id` instead of joining `users u` on `l.creator_id = u.user_id` to properly relate lists to their users. Do filter with `T2.list_followers >= 1` instead of `l.followers_count > 0` to check for at least one follower using the correct column name and threshold. Do filter with `T1.user_subscriber = 1` instead of `u.subscription_status = 'subscriber'` to check subscriber status using a boolean flag rather than string comparison. The amended query now correctly counts lists with followers where the associated user is a subscriber, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM lists l\nJOIN users u ON l.creator_id = u.user_id\nWHERE l.followers_count > 0\nAND u.subscription_status = 'subscriber'",
            "SELECT COUNT(T1.list_id) \nFROM lists_users AS T1\nJOIN lists AS T2 ON T1.list_id = T2.list_id\nWHERE T2.list_followers >= 1 \nAND T1.user_subscriber = 1"
        ],
        "rule_sql": []
    },
    "509": {
        "db_id": "movies_4",
        "question": "Find out the language ID of the movie with the highest popularity.",
        "ground_truth": "SELECT T2.language_id FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id ORDER BY T1.popularity DESC LIMIT 1",
        "amends": [
            "Do join `movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id` instead of querying only `movies` without proper table relationships. Do select `T2.language_id` from the joined table instead of `language_id` directly from the movies table. Do order by `T1.popularity DESC` instead of `popularity ASC` to get the most popular rather than least popular. The amended query now correctly retrieves language information through proper table relationships and ordering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language_id FROM movies ORDER BY popularity ASC LIMIT 1;",
            "SELECT T2.language_id FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id ORDER BY T1.popularity DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3728": {
        "db_id": "college_completion",
        "question": "For the state which has the 113 2-year public schools, tell the number of graduated Asian students who seeks another type of degree or certificate at a 2-year institution in 2013.",
        "ground_truth": "SELECT COUNT(T2.grad_cohort) FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T2.level = '2-year' AND T2.control = 'Public' AND T2.gender = 'B' AND T2.race = 'A' AND T2.cohort = '2y all' AND T1.schools_count = 113",
        "amends": [
            "Do use `COUNT(T2.grad_cohort)` instead of `COUNT(*)` to count specific graduation cohort records. Do change the FROM clause to use `state_sector_details AS T1 INNER JOIN state_sector_grads AS T2` instead of `schools s JOIN students st` with completely different table sources. Do modify the join condition to `T2.stateid = T1.stateid` instead of `s.school_id = st.school_id` using state identifiers rather than school identifiers. Do replace the WHERE filters with `T2.level = '2-year' AND T2.control = 'Public'` instead of `s.type = '2-year public'`, separating level and control into distinct conditions. Do change demographic filters to `T2.gender = 'B' AND T2.race = 'A'` instead of `st.ethnicity = 'Asian'`, using standardized gender and race codes. Do replace graduation year filtering with `T2.cohort = '2y all'` instead of `st.graduation_year = 2013`, using cohort identifiers rather than specific years. Do remove the `st.degree_seeking = 'another type'` condition entirely instead of keeping it. Do add the new condition `T1.schools_count = 113` to filter by specific school count threshold. The amended query now correctly uses the appropriate data sources and filtering logic for state-sector graduation analysis."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools s\nJOIN students st ON s.school_id = st.school_id\nWHERE s.state = 'California' \nAND s.type = '2-year public'\nAND st.ethnicity = 'Asian'\nAND st.graduation_year = 2013\nAND st.degree_seeking = 'another type'",
            "SELECT COUNT(T2.grad_cohort) \nFROM state_sector_details AS T1 \nINNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid\nWHERE T1.schools_count = 113\nAND T2.level = '2-year' \nAND T2.control = 'Public'\nAND T2.gender = 'B' \nAND T2.race = 'A'\nAND T2.cohort = '2y all'"
        ],
        "rule_sql": []
    },
    "3620": {
        "db_id": "authors",
        "question": "Calculate the total average number of papers published from 2002 to 2010 under the conference \"Information and Knowledge Engineering\".",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T1.Year) FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T2.FullName = 'Information and Knowledge Engineering' AND T1.Year >= 2002 AND T1.Year <= 2010",
        "amends": [
            "Do use `CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T1.Year)` instead of `AVG(papers_published)` to calculate the average papers per year. Do join `Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id` instead of querying a single `conference_papers` table. Do filter on `T2.FullName = 'Information and Knowledge Engineering'` instead of `conference_name = 'Information and Knowledge Engineering'` to properly reference the conference name from the joined table. Do use `T1.Year >= 2002 AND T1.Year <= 2010` instead of `year BETWEEN 2002 AND 2010` while maintaining the same year range logic. The amended query now correctly calculates average papers per year by conference using proper table relationships and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(papers_published) FROM conference_papers WHERE conference_name = 'Information and Knowledge Engineering' AND year BETWEEN 2002 AND 2010;",
            "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T1.Year) AS average_papers_per_year\nFROM Paper AS T1\nINNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id\nWHERE T2.FullName = 'Information and Knowledge Engineering'\nAND T1.Year >= 2002 AND T1.Year <= 2010;"
        ],
        "rule_sql": []
    },
    "4213": {
        "db_id": "simpson_episodes",
        "question": "What was the first award won by the cast or crew member of the show? Give the name of the person who won the said award.",
        "ground_truth": "SELECT T2.award, T1.name FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.result = 'Winner' ORDER BY T2.year LIMIT 1;",
        "amends": [
            "Do select `T2.award` and `T1.name` instead of `person_name` and `award_name`. Do use `INNER JOIN` between `Person AS T1` and `Award AS T2` on `T1.name = T2.person` instead of querying only the `awards` table. Do add filter `T2.result = 'Winner'` instead of filtering by `show_id` from a subquery. Do order by `T2.year` instead of `award_date`. Do remove the subquery for `show_id` and the condition on `show_name` instead of keeping them. The amended query now correctly retrieves award winners from joined tables with proper filtering and ordering.",
            "Do reverse the column order in the SELECT list to `T2.award, T1.name` instead of `T1.name, T2.award`. Do remove the redundant `ASC` keyword from the ORDER BY clause instead of keeping it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT person_name, award_name FROM awards WHERE show_id = (SELECT show_id FROM shows WHERE show_name = 'The Show') ORDER BY award_date ASC LIMIT 1;",
            "SELECT T1.name, T2.award\nFROM Person AS T1\nINNER JOIN Award AS T2 ON T1.name = T2.person\nWHERE T2.result = 'Winner'\nORDER BY T2.year ASC\nLIMIT 1;",
            "SELECT T2.award, T1.name\nFROM Person AS T1\nINNER JOIN Award AS T2 ON T1.name = T2.person\nWHERE T2.result = 'Winner'\nORDER BY T2.year\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "310": {
        "db_id": "retail_complains",
        "question": "How many complaints from female clients born in the year 2000 were not sent through the web?",
        "ground_truth": "SELECT COUNT(T2.`Submitted via`) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.sex = 'Female' AND T1.year = 2000 AND T2.`Submitted via` != 'Web'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `c` and `cl`. Do reference column `T2.Submitted via` in the COUNT instead of `*`. Do join table `events AS T2` instead of `complaints c`. Do join on `T1.client_id = T2.Client_ID` instead of `c.client_id = cl.client_id`. Do filter on `T1.sex = 'Female'` instead of `cl.gender = 'Female'`. Do filter on `T1.year = 2000` instead of `cl.birth_year = 2000`. Do filter on `T2.Submitted via != 'Web'` instead of `c.channel = 'web'`. The amended query now correctly counts web submissions excluding 'Web' channel while maintaining the same demographic filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM complaints c\nJOIN clients cl ON c.client_id = cl.client_id\nWHERE cl.gender = 'Female' \nAND cl.birth_year = 2000\nAND c.channel = 'web';",
            "SELECT COUNT(T2.\"Submitted via\") \nFROM client AS T1\nJOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.sex = 'Female' \nAND T1.year = 2000 \nAND T2.\"Submitted via\" != 'Web'"
        ],
        "rule_sql": []
    },
    "2737": {
        "db_id": "regional_sales",
        "question": "What is the average household income of Glendale?",
        "ground_truth": "SELECT AVG(`Household Income`) FROM `Store Locations` WHERE `City Name` = 'Glendale'",
        "amends": [
            "Do use backtick-quoted column name `Household Income` instead of unquoted `income` for the aggregate function. Do use backtick-quoted table name `Store Locations` instead of unquoted `households` in the FROM clause. Do use backtick-quoted column name `City Name` instead of unquoted `city` in the WHERE filter. The amended query now correctly references the actual schema elements and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(income) FROM households WHERE city = 'Glendale';",
            "SELECT AVG(`Household Income`) AS average_household_income FROM `Store Locations` WHERE `City Name` = 'Glendale';"
        ],
        "rule_sql": []
    },
    "59": {
        "db_id": "movie_platform",
        "question": "Was the user who created the list \"250 Favourite Films\" a trialist when he or she created the list?",
        "ground_truth": "SELECT T2.user_trialist FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE T1.list_title = '250 Favourite Films'",
        "amends": [
            "Do select `T2.user_trialist` instead of `is_trialist` from the wrong table. Do join `lists AS T1` and `lists_users AS T2` instead of querying only the `users` table. Do use `INNER JOIN` with `T1.list_id = T2.list_id AND T1.user_id = T2.user_id` instead of no join condition. Do filter on `T1.list_title = '250 Favourite Films'` instead of `list_name = '250 Favourite Films'` from the incorrect table. The amended query now correctly retrieves trialist information from the joined lists relationship instead of directly from users, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT is_trialist FROM users WHERE list_name = '250 Favourite Films';",
            "SELECT T2.user_trialist \nFROM lists AS T1 \nINNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id \nWHERE T1.list_title = '250 Favourite Films'"
        ],
        "rule_sql": []
    },
    "2085": {
        "db_id": "music_tracker",
        "question": "Which album title and tag that millie jackson released in 1980?",
        "ground_truth": "SELECT T1.groupName, T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.groupYear = 1980 AND T1.artist LIKE 'millie jackson' AND T1.releaseType LIKE 'album'",
        "amends": [
            "Do select `T1.groupName` and `T2.tag` instead of `album.title` and `tag.name`. Do use table aliases `T1` and `T2` instead of full table names. Do reference `torrents AS T1` and `tags AS T2` instead of `album`, `artist`, `album_tag`, and `tag` tables. Do use `INNER JOIN` between `T1` and `T2` on `T1.id = T2.id` instead of multiple joins through intermediary tables. Do filter with `T1.groupYear = 1980` instead of `album.year = 1980`. Do use `T1.artist LIKE 'millie jackson'` instead of joining to an artist table with `artist.name = 'millie jackson'`. Do add `T1.releaseType LIKE 'album'` instead of omitting this filter. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table structure and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT album.title, tag.name \nFROM album \nJOIN artist ON album.artist_id = artist.id \nJOIN album_tag ON album.id = album_tag.album_id \nJOIN tag ON album_tag.tag_id = tag.id \nWHERE artist.name = 'millie jackson' AND album.year = 1980;",
            "SELECT T1.groupName, T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.artist LIKE 'millie jackson' AND T1.groupYear = 1980 AND T1.releaseType LIKE 'album'"
        ],
        "rule_sql": []
    },
    "5308": {
        "db_id": "beer_factory",
        "question": "From which cities are the customers who gave 5 stars in their reviews in November 2012?",
        "ground_truth": "SELECT DISTINCT T1.City FROM customers AS T1 INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.StarRating = 5 AND T2.ReviewDate BETWEEN '2012-11-01' AND '2012-11-30'",
        "amends": [
            "Do use `DISTINCT` for `T1.City` instead of omitting it to remove duplicate cities. Do specify table aliases `T1` and `T2` instead of using full table names. Do join with `rootbeerreview AS T2` instead of `reviews` as the correct table name. Do use `INNER JOIN` with `T1.CustomerID = T2.CustomerID` instead of `customers.customer_id = reviews.customer_id` with proper column names. Do filter on `T2.StarRating = 5` instead of `rating = 5` with the correct column name. Do use `BETWEEN '2012-11-01' AND '2012-11-30'` for date range filtering instead of `LIKE '2012-11%'` for more precise date handling. The amended query now correctly retrieves distinct cities from customers who gave 5-star reviews in November 2012."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM customers JOIN reviews ON customers.customer_id = reviews.customer_id WHERE rating = 5 AND review_date LIKE '2012-11%';",
            "SELECT DISTINCT T1.City\nFROM customers AS T1\nINNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.StarRating = 5\nAND T2.ReviewDate BETWEEN '2012-11-01' AND '2012-11-30'"
        ],
        "rule_sql": []
    },
    "7859": {
        "db_id": "world",
        "question": "What is the official language of China?",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'China' AND T2.IsOfficial = 'T'",
        "amends": [
            "Do join `Country AS T1` with `CountryLanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do select `T2.Language` instead of `language` from the joined table structure. Do add the filter `T2.IsOfficial = 'T'` instead of omitting this official language requirement. Do use the table alias `T1` for `Country` and reference `T1.Name` instead of directly using `name` from a single table. The amended query now correctly retrieves only official languages for China by properly joining the country and language tables with appropriate filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE name = 'China';",
            "SELECT T2.Language FROM Country AS T1 JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Name = 'China' AND T2.IsOfficial = 'T'"
        ],
        "rule_sql": []
    },
    "904": {
        "db_id": "cs_semester",
        "question": "How many students, who have a GPA between 3 to 4, failed a course?",
        "ground_truth": "SELECT COUNT(T2.student_id) FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE T2.grade IS NULL AND T1.gpa BETWEEN 3 AND 4",
        "amends": [
            "Do join `student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id` instead of querying only `students` table. Do filter on `T2.grade IS NULL` instead of `course_status = 'failed'`. Do count `T2.student_id` instead of `COUNT(*)`. Do keep `T1.gpa BETWEEN 3 AND 4` filter but reference it through joined table alias. The amended query now correctly identifies students with missing grades rather than failed course status and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE GPA BETWEEN 3 AND 4 AND course_status = 'failed';",
            "SELECT COUNT(DISTINCT T2.student_id) \nFROM student AS T1 \nINNER JOIN registration AS T2 ON T1.student_id = T2.student_id \nWHERE T1.gpa BETWEEN 3 AND 4 \nAND T2.grade IS NULL"
        ],
        "rule_sql": []
    },
    "563": {
        "db_id": "movies_4",
        "question": "What is the average number of horror movies among all movies genre?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.genre_name = 'Horror' THEN T1.movie_id ELSE NULL END) AS REAL) / COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id",
        "amends": [
            "Do use explicit table joins with `movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id` instead of querying a single table without proper relationships. Do calculate the horror genre proportion using `CAST(COUNT(CASE WHEN T3.genre_name = 'Horror' THEN T1.movie_id ELSE NULL END) AS REAL) / COUNT(T1.movie_id)` instead of `AVG(genre = 'Horror')` which incorrectly assumes genre is a direct column. Do reference the correct column `T3.genre_name` for genre filtering instead of an unspecified `genre` column. Do include proper counting logic with `CASE WHEN` and `ELSE NULL` instead of relying on boolean aggregation. The amended query now correctly calculates the proportion of horror movies by properly joining across the movie, movie_genres, and genre tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(genre = 'Horror') FROM movies;",
            "SELECT CAST(COUNT(CASE WHEN T3.genre_name = 'Horror' THEN T1.movie_id ELSE NULL END) AS REAL) / COUNT(T1.movie_id) AS avg_horror_proportion\nFROM movie AS T1 \nINNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id \nINNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id"
        ],
        "rule_sql": []
    },
    "3575": {
        "db_id": "authors",
        "question": "Identify by publication year in the paper database all journals that don't have short name.",
        "ground_truth": "SELECT DISTINCT T2.Year, FullName FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.ShortName = ''",
        "amends": [
            "Do select `T2.Year` and `FullName` instead of `publication_year` and `journal_name`. Do join `Journal AS T1` with `Paper AS T2` on `T1.Id = T2.JournalId` instead of querying only the `papers` table without any join. Do filter on `T1.ShortName = ''` instead of `short_name IS NULL`. Do use `DISTINCT` instead of `GROUP BY publication_year`. The amended query now correctly retrieves distinct year and full journal name combinations for journals with empty short names through proper table joining."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publication_year, journal_name FROM papers WHERE short_name IS NULL GROUP BY publication_year;",
            "SELECT DISTINCT T2.Year, T1.FullName FROM Journal AS T1 JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.ShortName = ''"
        ],
        "rule_sql": []
    },
    "1811": {
        "db_id": "soccer_2016",
        "question": "Who was the man of the series in 2013? Give the full name.",
        "ground_truth": "SELECT T2.Player_Name FROM Season AS T1 INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id WHERE T1.Season_Year = 2013",
        "amends": [
            "Do reference `T2.Player_Name` from the `Player` table instead of `player_name` from an unspecified source. Do join `Season AS T1` and `Player AS T2` with an `INNER JOIN` on `T1.Man_of_the_Series = T2.Player_Id` instead of querying a single `matches` table. Do filter on `T1.Season_Year = 2013` instead of `year = 2013` and remove the direct `award = 'Man of the Series'` filter since the join condition now handles this logic through the relationship between Season and Player tables. The amended query correctly establishes the proper table relationships and eliminates potential ambiguity in column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM matches WHERE year = 2013 AND award = 'Man of the Series'",
            "SELECT T2.Player_Name\nFROM Season AS T1\nINNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id\nWHERE T1.Season_Year = 2013"
        ],
        "rule_sql": []
    },
    "2627": {
        "db_id": "regional_sales",
        "question": "Please give the order number and product name of the order which has the lowest unit price.",
        "ground_truth": "SELECT T1.OrderNumber, T2.`Product Name` FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE REPLACE(T1.`Unit Price`, ',', '') = ( SELECT REPLACE(T1.`Unit Price`, ',', '') FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID ORDER BY REPLACE(T1.`Unit Price`, ',', '') LIMIT 1 )",
        "amends": [
            "Do specify table aliases `T1` and `T2` instead of omitting them, and use qualified column names `T1.OrderNumber` and `T2.Product Name` instead of unqualified `order_number` and `product_name`. Do add an `INNER JOIN` on `Products AS T2` with join condition `T2.ProductID = T1._ProductID` instead of querying only the `orders` table. Do add a WHERE filter comparing `REPLACE(T1.Unit Price, ',', '')` to a subquery result instead of directly ordering by `unit_price`. Do use a correlated subquery that applies the same `REPLACE` function and join logic to find the maximum unit price instead of simply using `ORDER BY unit_price DESC LIMIT 1`. Do handle comma formatting in `Unit Price` with the `REPLACE` function instead of treating it as a numeric value directly. The amended query now correctly identifies the order with the highest unit price while properly handling formatted numeric values and maintaining referential integrity through the join.",
            "Do use a subquery that selects `REPLACE(T1.Unit Price, ',', '')` with `ORDER BY REPLACE(T1.Unit Price, ',', '') LIMIT 1` instead of `MAX(REPLACE(T3.Unit Price, ',', ''))` with a correlated subquery joining additional tables. Do reference the same table aliases `T1` and `T2` in the subquery instead of introducing new aliases `T3` and `T4`. Do remove the unnecessary second join in the subquery since the same join condition already exists in the outer query. The amended query now correctly finds the maximum unit price by ordering and limiting instead of using MAX with a potentially incorrect correlated subquery, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_number, product_name FROM orders ORDER BY unit_price DESC LIMIT 1;",
            "SELECT T1.OrderNumber, T2.\"Product Name\"\nFROM \"Sales Orders\" AS T1\nINNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE REPLACE(T1.\"Unit Price\", ',', '') = (\n    SELECT MAX(REPLACE(T3.\"Unit Price\", ',', ''))\n    FROM \"Sales Orders\" AS T3\n    INNER JOIN Products AS T4 ON T4.ProductID = T3._ProductID\n)",
            "SELECT T1.OrderNumber, T2.\"Product Name\"\nFROM \"Sales Orders\" AS T1\nINNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE REPLACE(T1.\"Unit Price\", ',', '') = (\n    SELECT REPLACE(T3.\"Unit Price\", ',', '')\n    FROM \"Sales Orders\" AS T3\n    ORDER BY REPLACE(T3.\"Unit Price\", ',', '') ASC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "633": {
        "db_id": "codebase_comments",
        "question": "What are the \"en\" methods with solutions from repository \"1093\"",
        "ground_truth": "SELECT DISTINCT T2.id FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.RepoId = 1093 AND T2.Lang = 'en'",
        "amends": [
            "Do select `DISTINCT T2.id` instead of `method_name` from a different table. Do use `INNER JOIN` between `Solution AS T1` and `Method AS T2` on `T1.Id = T2.SolutionId` instead of querying only the `methods` table. Do filter with `T1.RepoId = 1093` instead of `repository_id = 1093` and `T2.Lang = 'en'` instead of `language = 'en'`. The amended query now correctly retrieves distinct method IDs from the joined Solution and Method tables with proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT method_name FROM methods WHERE language = 'en' AND repository_id = 1093",
            "SELECT DISTINCT T2.Id FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T1.RepoId = 1093 AND T2.Lang = 'en'"
        ],
        "rule_sql": []
    },
    "3770": {
        "db_id": "public_review_platform",
        "question": "For the Yelp business which had the most number of \"short\" tips, which category does it belong to?",
        "ground_truth": "SELECT DISTINCT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Tips AS T4 ON T3.business_id = T4.business_id WHERE T4.tip_length LIKE 'short'",
        "amends": [
            "Do select `DISTINCT T1.category_name` instead of `category` without distinct. Do use explicit table aliases `Categories AS T1`, `Business_Categories AS T2`, `Business AS T3`, and `Tips AS T4` instead of implicit table references. Do perform `INNER JOIN` operations with proper join conditions `T1.category_id = T2.category_id`, `T2.business_id = T3.business_id`, and `T3.business_id = T4.business_id` instead of a single join on `business.business_id = tip.business_id`. Do filter with `T4.tip_length LIKE 'short'` instead of `tip.text LIKE '%short%'`. Do remove `GROUP BY business.business_id`, `ORDER BY COUNT(*) DESC`, and `LIMIT 1` instead of keeping them, as the distinct selection makes them unnecessary. The amended query now correctly identifies categories with short tips using proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category \nFROM business \nJOIN tip ON business.business_id = tip.business_id \nWHERE tip.text LIKE '%short%' \nGROUP BY business.business_id \nORDER BY COUNT(*) DESC \nLIMIT 1;",
            "SELECT DISTINCT T1.category_name\nFROM Categories AS T1\nINNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id\nINNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nINNER JOIN Tips AS T4 ON T3.business_id = T4.business_id\nWHERE T4.tip_length LIKE 'short'"
        ],
        "rule_sql": []
    },
    "1930": {
        "db_id": "soccer_2016",
        "question": "What is the name of the youngest player?",
        "ground_truth": "SELECT Player_Name FROM Player ORDER BY DOB DESC LIMIT 1",
        "amends": [
            "Do select `Player_Name` instead of `name` and use `DOB` for ordering instead of `age`. Do order by `DESC` instead of `ASC` and reference the `Player` table instead of `players`. The amended query now correctly retrieves the youngest player by date of birth from the Player table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT Player_Name FROM Player ORDER BY DOB DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6976": {
        "db_id": "ice_hockey_draft",
        "question": "Who is the most valuable player who played in the 2000-2001 season of the International league?",
        "ground_truth": "SELECT DISTINCT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '2000-2001' AND T1.LEAGUE = 'International' ORDER BY T1.P DESC LIMIT 1",
        "amends": [
            "Do use `DISTINCT T2.PlayerName` instead of `player_name` without distinct. Do join `SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID` instead of querying only the `players` table. Do filter on `T1.SEASON = '2000-2001' AND T1.LEAGUE = 'International'` instead of filtering directly on the players table. Do order by `T1.P DESC` instead of `value DESC`. The amended query now correctly joins the necessary tables and uses the appropriate columns from the SeasonStatus table for filtering and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE league = 'International' AND season = '2000-2001' ORDER BY value DESC LIMIT 1;",
            "SELECT DISTINCT T2.PlayerName\nFROM SeasonStatus AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE T1.SEASON = '2000-2001' AND T1.LEAGUE = 'International'\nORDER BY T1.P DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8413": {
        "db_id": "mondial_geo",
        "question": "Average length of the rivers flowing into the Donau River.",
        "ground_truth": "SELECT * FROM river WHERE Name = 'Donau'",
        "amends": [
            "Do select all columns with `*` instead of aggregating with `AVG(length)`. Do query from table `river` instead of `rivers`. Do filter on column `Name` with value 'Donau' instead of filtering on column `flows_into` with value 'Donau'. The amended query now correctly retrieves the full river record by name rather than attempting to calculate an average length from a potentially incorrect table and column reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(length) FROM rivers WHERE flows_into = 'Donau';",
            "SELECT * FROM river WHERE Name = 'Donau';"
        ],
        "rule_sql": []
    },
    "1182": {
        "db_id": "talkingdata",
        "question": "List out the time of the event id 12.",
        "ground_truth": "SELECT timestamp FROM events WHERE event_id = 12",
        "amends": [
            "Do select `timestamp` instead of `event_time` to use the correct column name that matches the table schema. The WHERE clause remains unchanged with `event_id = 12` as the filter condition. This amendment ensures the query retrieves the appropriate timestamp data for the specified event identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_time FROM events WHERE event_id = 12;",
            "SELECT timestamp FROM events WHERE event_id = 12"
        ],
        "rule_sql": []
    },
    "492": {
        "db_id": "movies_4",
        "question": "Write down five rumoured movie titles within the genre of Drama.",
        "ground_truth": "SELECT T1.title FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id WHERE T1.movie_status = 'Rumored' AND T3.genre_name = 'Drama' LIMIT 5",
        "amends": [
            "Do select `T1.title` instead of `title` and add `T1.movie_status` filter instead of omitting it. Do use `INNER JOIN` on `movie_genres AS T2` with `T1.movie_id = T2.movie_id` instead of no join, and add `INNER JOIN` on `genre AS T3` with `T2.genre_id = T3.genre_id` instead of omitting it. Do filter on `T3.genre_name = 'Drama'` instead of `genre = 'Comedy'` and add `T1.movie_status = 'Rumored'` condition instead of omitting it. The amended query now correctly joins through the genre relationship tables and filters by both movie status and genre name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE genre = 'Comedy' LIMIT 5;",
            "SELECT T1.title\nFROM movie AS T1\nINNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id\nINNER JOIN genre AS T3 ON T2.genre_id = T3.genre_id\nWHERE T3.genre_name = 'Drama'\nAND T1.movie_status = 'Rumored'\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "3768": {
        "db_id": "public_review_platform",
        "question": "For the user who gave the most number of long reviews, what is his/her averge ratings of all review?",
        "ground_truth": "SELECT CAST(SUM(T1.review_stars) AS REAL) / COUNT(T1.review_stars) FROM Reviews AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE T1.review_length LIKE 'Long' GROUP BY T1.user_id ORDER BY COUNT(T1.review_length) DESC LIMIT 1",
        "amends": [
            "Do use `CAST(SUM(T1.review_stars) AS REAL) / COUNT(T1.review_stars)` instead of `AVG(r.rating) as average_rating` for the average calculation. Do reference `Reviews AS T1` and `Users AS T2` instead of `users u` and `reviews r` as table aliases. Do use `INNER JOIN` with `T1.user_id = T2.user_id` instead of `JOIN` with `u.user_id = r.user_id` for the join condition. Do filter with `T1.review_length LIKE 'Long'` instead of `LENGTH(r.review_text) > 100` for review length criteria. Do group by `T1.user_id` instead of `u.user_id` for the grouping. Do order by `COUNT(T1.review_length) DESC` instead of `COUNT(*) DESC` for the ordering. The amended query now correctly calculates average ratings using explicit casting and division, uses appropriate table aliases, applies the correct join condition, filters based on a categorical review length value rather than character count, groups by the review table's user_id, and orders by the count of long reviews specifically."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.user_id, AVG(r.rating) as average_rating\nFROM users u\nJOIN reviews r ON u.user_id = r.user_id\nWHERE LENGTH(r.review_text) > 100\nGROUP BY u.user_id\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT CAST(SUM(T1.review_stars) AS REAL) / COUNT(T1.review_stars) AS average_rating\nFROM Reviews AS T1\nINNER JOIN Users AS T2 ON T1.user_id = T2.user_id\nWHERE T1.review_length LIKE 'Long'\nGROUP BY T1.user_id\nORDER BY COUNT(T1.review_length) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8509": {
        "db_id": "mondial_geo",
        "question": "What is the provincial capital of the province with a population of less than 80,000 that has the highest average population per area?",
        "ground_truth": "SELECT CapProv FROM province WHERE Population < 80000 ORDER BY Population / Area DESC LIMIT 1",
        "amends": [
            "Do reference column `CapProv` instead of `capital` in the SELECT list. Do reference table `province` instead of `provinces` in the FROM clause. Do reference column `Population` instead of `population` in the WHERE filter. Do reference columns `Population` and `Area` instead of `population` and `area` in the ORDER BY expression. The amended query now correctly matches the intended schema and behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT capital FROM provinces WHERE population < 80000 ORDER BY population / area DESC LIMIT 1;",
            "SELECT CapProv FROM province WHERE Population < 80000 ORDER BY (Population / Area) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2711": {
        "db_id": "regional_sales",
        "question": "Please indicate store id in the state of California that have been applied 20% discount in store.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.State = 'California' AND T1.`Sales Channel` = 'In-Store' AND T1.`Discount Applied` = 0.2 THEN T2.StoreID END AS T FROM `Sales Orders` T1 INNER JOIN `Store Locations` T2 ON T2.StoreID = T1._StoreID ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `SELECT DISTINCT CASE` instead of a simple `SELECT store_id` from a single table. Do add `INNER JOIN` on `T2.StoreID = T1._StoreID` instead of querying only the `stores` table. Do filter with `T2.State = 'California'` and `T1.Discount Applied = 0.2` instead of `state = 'California' AND discount = 20`. Do add the additional condition `T1.Sales Channel = 'In-Store'` instead of omitting it. Do wrap the result with `WHERE T IS NOT NULL` instead of directly returning results. Do use proper decimal representation `0.2` instead of integer `20` for the discount comparison. The amended query now correctly handles the discount percentage conversion and ensures only stores with in-store sales and the specified discount are returned."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id FROM stores WHERE state = 'California' AND discount = 20;",
            "SELECT DISTINCT CASE \n    WHEN T2.State = 'California' AND T1.\"Discount Applied\" = 0.2 AND T1.\"Sales Channel\" = 'In-Store' \n    THEN T1._StoreID \n    ELSE NULL \nEND AS T\nFROM \"Sales Orders\" T1\nINNER JOIN \"Store Locations\" T2 ON T2.StoreID = T1._StoreID\nWHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "5889": {
        "db_id": "airline",
        "question": "List the tail number of flights that flew on August 17, 2018.",
        "ground_truth": "SELECT TAIL_NUM FROM Airlines WHERE FL_DATE = '2018/8/17' GROUP BY TAIL_NUM",
        "amends": [
            "Do reference table `Airlines` instead of `flights` and use column `TAIL_NUM` instead of `tail_number`. Do add `GROUP BY TAIL_NUM` instead of omitting it to ensure unique tail numbers are returned. Do use date format `'2018/8/17'` instead of `'2018-08-17'` and reference column `FL_DATE` instead of `date`. The amended query now correctly retrieves distinct tail numbers from the Airlines table for the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tail_number FROM flights WHERE date = '2018-08-17';",
            "SELECT TAIL_NUM FROM Airlines WHERE FL_DATE = '2018/8/17' GROUP BY TAIL_NUM"
        ],
        "rule_sql": []
    },
    "5097": {
        "db_id": "address",
        "question": "What is the alias of the city called Hartford?",
        "ground_truth": "SELECT DISTINCT T2.alias FROM zip_data AS T1 INNER JOIN alias AS T2 ON T1.zip_code = T2.zip_code WHERE T1.city = 'Hartford'",
        "amends": [
            "Do select `DISTINCT T2.alias` instead of `name` and use table `alias AS T2` instead of `cities`. Do add `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of omitting the join entirely. Do change the FROM clause to `zip_data AS T1` instead of `cities` and move the city filter to reference `T1.city` instead of `city`. The amended query now correctly retrieves distinct aliases from the joined tables based on zip code matching for Hartford city entries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cities WHERE city = 'Hartford';",
            "SELECT DISTINCT T2.alias FROM zip_data AS T1 INNER JOIN alias AS T2 ON T1.zip_code = T2.zip_code WHERE T1.city = 'Hartford'"
        ],
        "rule_sql": []
    },
    "1210": {
        "db_id": "talkingdata",
        "question": "How many women have apps from the game-Finding fault category installed on their device?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id WHERE T1.age < 23 AND T1.gender = 'F' AND T3.is_active = 0 AND T3.is_installed = 1",
        "amends": [
            "Do select `COUNT(T1.device_id)` from specific columns instead of `COUNT(*)` from all rows. Do use `gender_age AS T1` as the primary table instead of `users`. Do add `INNER JOIN events_relevant AS T2` on `T1.device_id = T2.device_id` instead of omitting this table. Do add `INNER JOIN app_events_relevant AS T3` on `T2.event_id = T3.event_id` instead of omitting this table. Do filter with `T1.age < 23` instead of omitting age criteria. Do filter with `T1.gender = 'F'` instead of `gender = 'male'`. Do add `T3.is_active = 0` instead of omitting this condition. Do add `T3.is_installed = 1` instead of the `category = 'game-Finding fault'` filter. The amended query now correctly counts female users under 23 with specific app installation status across joined tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE gender = 'male' AND category = 'game-Finding fault';",
            "SELECT COUNT(T1.device_id) \nFROM gender_age AS T1\nINNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id\nINNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id\nWHERE T1.gender = 'F' \nAND T1.age < 23\nAND T3.is_installed = 1\nAND T3.is_active = 0"
        ],
        "rule_sql": []
    },
    "4655": {
        "db_id": "disney",
        "question": "How many movies for mature audiences or parental guidance suggested did Bill Thompson work as a voice actor?",
        "ground_truth": "SELECT COUNT(T.movie) FROM ( SELECT T1.movie FROM `voice-actors` AS T1 INNER JOIN movies_total_gross AS T2 ON T1.movie = T2.movie_title WHERE MPAA_rating = 'PG' AND `voice-actor` = 'Bill Thompson' GROUP BY T1.movie ) AS T",
        "amends": [
            "Do use a subquery with `SELECT T1.movie` instead of `COUNT(*)` directly. Do join `voice-actors` table instead of `movies`, `movie_actors`, and `actors` tables. Do filter for `MPAA_rating = 'PG'` instead of `rating = 'R' OR rating = 'PG-13'`. Do filter for `voice-actor = 'Bill Thompson'` instead of joining through multiple tables to find the actor name. Do use `INNER JOIN movies_total_gross` on `movie_title` instead of joining through movie_actors relationship. Do add `GROUP BY T1.movie` to count distinct movies instead of counting all actor-movie combinations. Do wrap the subquery in `COUNT(T.movie)` instead of counting all rows directly from the join results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM movies m\nJOIN movie_actors ma ON m.movie_id = ma.movie_id\nJOIN actors a ON ma.actor_id = a.actor_id\nWHERE a.name = 'Bill Thompson'\nAND (m.rating = 'R' OR m.rating = 'PG-13')\nAND ma.role = 'voice actor';",
            "SELECT COUNT(T.movie) \nFROM (\n    SELECT DISTINCT va.movie\n    FROM \"voice-actors\" va\n    INNER JOIN movies_total_gross mtg ON va.movie = mtg.movie_title\n    WHERE va.\"voice-actor\" = 'Bill Thompson'\n    AND mtg.MPAA_rating = 'PG'\n) T"
        ],
        "rule_sql": []
    },
    "2623": {
        "db_id": "regional_sales",
        "question": "What is the customer names of orders which have unit cost greater than 4000USD?",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.`Unit Cost` > 4000 THEN T1.`Customer Names` END AS T FROM Customers T1 INNER JOIN `Sales Orders` T2 ON T2._CustomerID = T1.CustomerID ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `CASE` expression and `DISTINCT` instead of a simple column selection. Do add an `INNER JOIN` between `Customers` and `Sales Orders` on `T2._CustomerID = T1.CustomerID` instead of querying only the `orders` table. Do filter with `T IS NOT NULL` in the outer query instead of using `WHERE unit_cost > 4000` directly. Do reference `T2.Unit Cost` and `T1.Customer Names` with proper table aliases instead of `customer_name` and `unit_cost` without table qualification. The amended query now correctly handles the join relationship and ensures only non-null customer names are returned for orders with unit cost exceeding 4000, matching the RIGHT_SQL's behavior.",
            "Do use a subquery with a CASE expression aliased as `T` instead of applying the CASE directly in the WHERE clause. Do filter on `T IS NOT NULL` in the outer query instead of using a CASE expression that returns NULL values in the WHERE clause. Do remove the `REPLACE` and `CAST` functions from the CASE condition and instead directly compare `T2.Unit Cost > 4000` instead of manipulating the string value. Do add an alias `AS T` to the CASE expression instead of omitting it. Do keep the `DISTINCT` keyword but move it inside the subquery instead of the main query. The amended query now correctly filters for customers with unit costs exceeding 4000 by using proper NULL handling through the CASE expression in the SELECT list rather than the WHERE clause.",
            "Do use a subquery with a CASE expression aliased as `T` instead of a correlated subquery in the WHERE clause. Do filter on `T IS NOT NULL` in the outer query instead of using `IS NOT NULL` on the CASE result directly. Do remove the `REPLACE` function and `CAST` operation on `Unit Cost` instead of converting currency strings, instead directly comparing `T2.Unit Cost > 4000`. Do use backticks for column names instead of double quotes. Do keep the `DISTINCT` keyword but move it inside the subquery instead of at the outer level. The amended query now correctly filters customers based on unit cost threshold without unnecessary string manipulation.",
            "Do use a subquery with a CASE expression aliased as `T` instead of a correlated subquery in the WHERE clause. Do filter on `T IS NOT NULL` in the outer query instead of using `IS NOT NULL` on the CASE result directly. Do remove the `REPLACE` and `CAST` functions and directly compare `T2.Unit Cost > 4000` instead of manipulating the string value. Do keep the `DISTINCT` keyword but move it inside the subquery instead of at the top level. Do maintain the same `INNER JOIN` on `T2._CustomerID = T1.CustomerID` without changes. The amended query now correctly filters for customers with unit costs exceeding 4000 using proper boolean logic instead of string manipulation and NULL handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM orders WHERE unit_cost > 4000",
            "SELECT DISTINCT T1.\"Customer Names\"\nFROM Customers T1\nINNER JOIN \"Sales Orders\" T2 ON T2._CustomerID = T1.CustomerID\nWHERE (\n    CASE \n        WHEN CAST(REPLACE(T2.\"Unit Cost\", 'USD', '') AS REAL) > 4000 THEN T1.\"Customer Names\"\n        ELSE NULL\n    END\n) IS NOT NULL",
            "SELECT DISTINCT T1.\"Customer Names\"\nFROM Customers T1\nINNER JOIN \"Sales Orders\" T2 ON T2._CustomerID = T1.CustomerID\nWHERE (\n    SELECT CASE \n        WHEN CAST(REPLACE(T2.\"Unit Cost\", 'USD', '') AS REAL) > 4000 \n        THEN T1.\"Customer Names\" \n        ELSE NULL \n    END\n) IS NOT NULL",
            "SELECT DISTINCT T1.\"Customer Names\"\nFROM Customers T1\nINNER JOIN \"Sales Orders\" T2 ON T2._CustomerID = T1.CustomerID\nWHERE (\n    SELECT CASE \n        WHEN CAST(REPLACE(T2.\"Unit Cost\", 'USD', '') AS REAL) > 4000 \n        THEN T1.\"Customer Names\" \n        ELSE NULL \n    END\n) IS NOT NULL",
            "SELECT DISTINCT T1.\"Customer Names\"\nFROM Customers T1\nINNER JOIN \"Sales Orders\" T2 ON T2._CustomerID = T1.CustomerID\nWHERE (\n    SELECT CASE WHEN T2.\"Unit Cost\" > 4000 THEN T1.\"Customer Names\" ELSE NULL END AS T\n) IS NOT NULL"
        ],
        "rule_sql": []
    },
    "826": {
        "db_id": "social_media",
        "question": "Which country's tweets collected the most likes?",
        "ground_truth": "SELECT T.Country FROM ( SELECT T2.Country, SUM(T1.Likes) AS num FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID GROUP BY T2.Country ) T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do join `twitter` and `location` tables on `T1.LocationID = T2.LocationID` instead of querying a single table. Do select `T2.Country` from the joined result instead of directly selecting `country`. Do aggregate `SUM(T1.Likes)` instead of `SUM(likes)` to use the correct column name. Do use a subquery to first compute the aggregated totals by country instead of directly aggregating in the main query. Do reference the aggregated result as `T.num` in the ORDER BY clause instead of directly using `total_likes`. The amended query now correctly joins the necessary tables to associate tweets with their country locations and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, SUM(likes) as total_likes FROM tweets GROUP BY country ORDER BY total_likes DESC LIMIT 1;",
            "SELECT T2.Country\nFROM twitter T1\nJOIN location T2 ON T1.LocationID = T2.LocationID\nGROUP BY T2.Country\nORDER BY SUM(T1.Likes) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7248": {
        "db_id": "works_cycles",
        "question": "What are the top 5 types of products with the highest selling price? ?",
        "ground_truth": "SELECT Name FROM Product ORDER BY ListPrice DESC LIMIT 5",
        "amends": [
            "Do select `Name` instead of `product_type` and `MAX(price)`. Do remove `product_type` from the SELECT list instead of including it. Do use `Product` as the table name instead of `products`. Do remove the `GROUP BY product_type` clause instead of keeping it. Do order by `ListPrice DESC` instead of `highest_price DESC`. Do remove the alias `highest_price` instead of using it. The amended query now correctly selects product names ordered by list price instead of grouping by product type to find maximum prices."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_type, MAX(price) as highest_price FROM products GROUP BY product_type ORDER BY highest_price DESC LIMIT 5;",
            "SELECT Name FROM Product ORDER BY ListPrice DESC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "8379": {
        "db_id": "mondial_geo",
        "question": "Which country was the source of Pjandsh River? Give the full name of the country.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN located AS T2 ON T1.Code = T2.Country WHERE T2.River = 'Pjandsh'",
        "amends": [
            "Do select `T1.Name` from the `country` table instead of `river_name` from `rivers`. Do join `located` as `T2` with an `INNER JOIN` on `T1.Code = T2.Country` instead of querying the `rivers` table directly. Do filter on `T2.River = 'Pjandsh'` instead of `country = 'Pjandsh River'` to correctly identify the river by name rather than mistakenly treating it as a country value. The amended query now properly retrieves country names associated with the Pjandsh river through the relational join structure instead of the incorrect direct table query, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT river_name FROM rivers WHERE country = 'Pjandsh River';",
            "SELECT T1.Name \nFROM country T1\nINNER JOIN located T2 ON T1.Code = T2.Country\nWHERE T2.River = 'Pjandsh'"
        ],
        "rule_sql": []
    },
    "335": {
        "db_id": "retail_complains",
        "question": "List all the server of the phone complaints with a late response from the company.",
        "ground_truth": "SELECT DISTINCT T2.server FROM events AS T1 INNER JOIN callcenterlogs AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T1.`Submitted via` = 'Phone' AND T1.`Timely response?` = 'No'",
        "amends": [
            "Do select `DISTINCT T2.server` instead of `*` to return only unique server values. Do use `events AS T1` and `callcenterlogs AS T2` as source tables instead of just `complaints`. Do perform an `INNER JOIN` on `T1.Complaint ID = T2.Complaint ID` instead of querying a single table. Do filter with `T1.Submitted via = 'Phone'` instead of `complaint_type = 'phone'` to check the submission method. Do filter with `T1.Timely response? = 'No'` instead of `response_status = 'late'` to identify untimely responses. The amended query now correctly joins related event and call center data to identify servers handling phone complaints with delayed responses."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM complaints WHERE complaint_type = 'phone' AND response_status = 'late';",
            "SELECT DISTINCT T2.server\nFROM events AS T1\nINNER JOIN callcenterlogs AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\"\nWHERE T1.\"Submitted via\" = 'Phone'\nAND T1.\"Timely response?\" = 'No'"
        ],
        "rule_sql": []
    },
    "5941": {
        "db_id": "books",
        "question": "Calculate the percentage of the International shipping orders on 2022/11/10.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM shipping_method AS T1 INNER JOIN cust_order AS T2 ON T1.method_id = T2.shipping_method_id WHERE T2.order_date LIKE '2022-11-10%'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.method_name = 'International' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN shipping_type = 'International' THEN 1 END)` for proper conditional counting. Do add explicit `CAST` to `REAL` instead of implicit decimal conversion. Do join `shipping_method AS T1` with `cust_order AS T2` on `T1.method_id = T2.shipping_method_id` instead of querying only the `orders` table. Do reference `T2.order_date` instead of `order_date` and use `LIKE '2022-11-10%'` instead of exact date matching with `= '2022/11/10'` to capture all orders from that date. Do remove the unnecessary `WHERE` clause filter placement since the join condition is now properly specified in the `ON` predicate. The amended query now correctly calculates international shipping percentages by properly joining the relevant tables and handling date matching appropriately.",
            "Do place the entire calculation expression directly in SELECT without an alias instead of assigning `percentage_international` alias. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now matches RIGHT_SQL's behavior with identical logic and output.",
            "Do place the multiplication by 100 after the division instead of before it, changing `(CAST(...) / COUNT(*)) * 100` to `CAST(...) * 100 / COUNT(*)` to ensure correct mathematical order of operations. The amended query now correctly calculates the percentage by first converting the count to a real number, then multiplying by 100 before dividing by the total count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN shipping_type = 'International' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM orders\nWHERE order_date = '2022/11/10';",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100.0 AS percentage_international\nFROM \n    shipping_method AS T1\nJOIN \n    cust_order AS T2 ON T1.method_id = T2.shipping_method_id\nWHERE \n    T2.order_date LIKE '2022-11-10%'",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100\nFROM \n    shipping_method AS T1\nINNER JOIN \n    cust_order AS T2 ON T1.method_id = T2.shipping_method_id\nWHERE \n    T2.order_date LIKE '2022-11-10%'",
            "SELECT CAST(SUM(CASE WHEN T1.method_name = 'International' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM shipping_method AS T1 \nINNER JOIN cust_order AS T2 ON T1.method_id = T2.shipping_method_id \nWHERE T2.order_date LIKE '2022-11-10%'"
        ],
        "rule_sql": []
    },
    "1967": {
        "db_id": "soccer_2016",
        "question": "How many matches were held in 2011?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM `Match` WHERE Match_Date LIKE '2011%'",
        "amends": [
            "Do count `Match_Id` instead of `*` to exclude null values. Do reference table `Match` instead of `matches` to use the correct table name. Do filter on `Match_Date LIKE '2011%'` instead of `year = 2011` to properly match dates from the year 2011 by checking the date string prefix. The amended query now correctly counts non-null match IDs from the Match table for matches occurring in 2011."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2011;",
            "SELECT COUNT(Match_Id) FROM Match WHERE Match_Date LIKE '2011%'"
        ],
        "rule_sql": []
    },
    "7951": {
        "db_id": "music_platform_2",
        "question": "What are the titles of the podcasts whose reviews were created between 2018-08-22T11:53:16-07:00 and 2018-11-20T11:14:20-07:00?",
        "ground_truth": "SELECT DISTINCT T1.title FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.created_at BETWEEN '2018-08-22T11:53:16-07:00' AND '2018-11-20T11:14:20-07:00'",
        "amends": [
            "Do add `DISTINCT` and `T1.` prefix to `title` instead of selecting plain `title` without qualification. Do add `INNER JOIN reviews AS T2` instead of querying only the `podcasts` table. Do add join condition `ON T2.podcast_id = T1.podcast_id` instead of having no join. Do change the `WHERE` filter to use `T2.created_at` instead of `created_at` from the wrong table. The amended query now correctly filters by review creation dates and returns distinct podcast titles that have reviews within the specified timeframe, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM podcasts WHERE created_at BETWEEN '2018-08-22T11:53:16-07:00' AND '2018-11-20T11:14:20-07:00';",
            "SELECT DISTINCT T1.title FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T2.created_at BETWEEN '2018-08-22T11:53:16-07:00' AND '2018-11-20T11:14:20-07:00'"
        ],
        "rule_sql": []
    },
    "3273": {
        "db_id": "donor",
        "question": "In which cities are Los Angeles County Suburban Metro Schools located?",
        "ground_truth": "SELECT school_city FROM projects WHERE school_metro = 'suburban' AND school_county = 'Los Angeles'",
        "amends": [
            "Do select `school_city` instead of `city` and use table `projects` instead of `schools`. Do filter on `school_metro = 'suburban'` instead of `type = 'Suburban Metro'` and maintain the condition `school_county = 'Los Angeles'` instead of `county = 'Los Angeles'`. The amended query now correctly retrieves city data from the projects table with appropriate metro and county filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM schools WHERE county = 'Los Angeles' AND type = 'Suburban Metro';",
            "SELECT DISTINCT school_city FROM projects WHERE school_county = 'Los Angeles' AND school_metro = 'suburban';"
        ],
        "rule_sql": []
    },
    "1959": {
        "db_id": "soccer_2016",
        "question": "Which country is umpire TH Wijewardene from?",
        "ground_truth": "SELECT T2.Country_Name FROM Umpire AS T1 INNER JOIN country AS T2 ON T2.Country_Id = T1.Umpire_Country WHERE T1.Umpire_Name = 'TH Wijewardene'",
        "amends": [
            "Do select `T2.Country_Name` from the joined country table instead of directly selecting `country` from the umpires table. Do add an `INNER JOIN` between `Umpire AS T1` and `country AS T2` with the predicate `T2.Country_Id = T1.Umpire_Country` instead of querying a single table. Do use the correct table alias `T1.Umpire_Name` in the WHERE filter instead of `name` from the original table. Do reference the properly aliased country name column `T2.Country_Name` instead of the ambiguous `country` field. The amended query now correctly joins the umpire and country tables to retrieve the country name associated with the specified umpire, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM umpires WHERE name = 'TH Wijewardene';",
            "SELECT T2.Country_Name \nFROM Umpire AS T1 \nINNER JOIN Country AS T2 ON T2.Country_Id = T1.Umpire_Country \nWHERE T1.Umpire_Name = 'TH Wijewardene'"
        ],
        "rule_sql": []
    },
    "3280": {
        "db_id": "donor",
        "question": "How many schools with the highest level of poverty have received a portion of a donation included corporate sponsored gift card?",
        "ground_truth": "SELECT COUNT(T1.schoolid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.payment_included_campaign_gift_card = 't' AND T1.poverty_level = 'highest poverty'",
        "amends": [
            "Do reference `projects` as `T1` instead of `schools` as `s` and use `schoolid` instead of `school_id`. Do join on `projectid` instead of `school_id` and reference `donations` as `T2` instead of `d`. Do filter on `payment_included_campaign_gift_card = 't'` instead of `donation_type = 'corporate sponsored gift card'` and use `poverty_level = 'highest poverty'` instead of `poverty_level = 'highest'`. Do remove the `portion_received > 0` condition instead of keeping it. Do count `T1.schoolid` instead of `COUNT(*)` to ensure accurate school counting. The amended query now correctly matches the intended behavior by joining on project relationships and filtering for campaign gift card payments in highest poverty areas.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the count should include all matching records rather than distinct school IDs. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity, though both are equivalent. Do reorder the `WHERE` clause predicates for consistency but maintain the same logical filtering on `T2.payment_included_campaign_gift_card = 't'` and `T1.poverty_level = 'highest poverty'`. The amended query now correctly counts all school IDs from matching projects and donations rather than counting distinct values, ensuring accurate aggregation while maintaining the same join logic and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools s\nJOIN donations d ON s.school_id = d.school_id\nWHERE s.poverty_level = 'highest'\nAND d.donation_type = 'corporate sponsored gift card'\nAND d.portion_received > 0;",
            "SELECT COUNT(DISTINCT T1.schoolid) \nFROM projects T1\nJOIN donations T2 ON T1.projectid = T2.projectid\nWHERE T1.poverty_level = 'highest poverty'\nAND T2.payment_included_campaign_gift_card = 't'",
            "SELECT COUNT(T1.schoolid)\nFROM projects AS T1\nINNER JOIN donations AS T2 ON T1.projectid = T2.projectid\nWHERE T2.payment_included_campaign_gift_card = 't'\nAND T1.poverty_level = 'highest poverty'"
        ],
        "rule_sql": []
    },
    "5625": {
        "db_id": "shipping",
        "question": "Name the customer who sent the shipment to Oak Park.",
        "ground_truth": "SELECT T2.cust_name FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id INNER JOIN city AS T3 ON T3.city_id = T1.city_id WHERE T3.city_name = 'Oak Park'",
        "amends": [
            "Do select `T2.cust_name` instead of `customer_name` from the customer table instead of assuming it exists in shipments. Do add `INNER JOIN customer AS T2` on `T1.cust_id = T2.cust_id` instead of omitting the customer table entirely. Do add `INNER JOIN city AS T3` on `T3.city_id = T1.city_id` instead of omitting the city table. Do filter on `T3.city_name = 'Oak Park'` instead of `destination = 'Oak Park'` to properly reference the city name through the normalized relationship. The amended query now correctly joins through the proper foreign key relationships to retrieve customer names for shipments destined to Oak Park."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM shipments WHERE destination = 'Oak Park';",
            "SELECT T2.cust_name\nFROM shipment AS T1\nINNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id\nINNER JOIN city AS T3 ON T1.city_id = T3.city_id\nWHERE T3.city_name = 'Oak Park'"
        ],
        "rule_sql": []
    },
    "8291": {
        "db_id": "mondial_geo",
        "question": "How many rivers finally flows to the sea of 459m in depth?",
        "ground_truth": "SELECT COUNT(*) FROM river WHERE Sea IN ( SELECT Name FROM sea WHERE Depth = 459 )",
        "amends": [
            "Do reference table `river` instead of `rivers` in the FROM clause. Do use a subquery condition `Sea IN (SELECT Name FROM sea WHERE Depth = 459)` instead of direct column filters `flows_to = 'sea' AND depth = 459`. Do remove the incorrect column reference `depth` and instead filter based on the `Depth` column from the `sea` table within the subquery. The amended query now correctly counts rivers that flow into seas with a depth of 459 by correlating through the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM rivers WHERE flows_to = 'sea' AND depth = 459;",
            "SELECT COUNT(*) \nFROM river \nWHERE Sea IN (SELECT Name FROM sea WHERE Depth = 459)"
        ],
        "rule_sql": []
    },
    "6883": {
        "db_id": "retails",
        "question": "Among all the suppliers providing the part \"hot spring dodger dim light\", how many of them are in Europe?",
        "ground_truth": "SELECT COUNT(T1.r_regionkey) FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey INNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey WHERE T1.r_name = 'EUROPE'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `s` and `p`. Do change the FROM clause to join `region AS T1` with `nation AS T2` on `T1.r_regionkey = T2.n_regionkey` instead of joining `suppliers` with `parts` on `s.part_id = p.part_id`. Do add an additional INNER JOIN with `supplier AS T3` on `T2.n_nationkey = T3.s_nationkey` instead of omitting it. Do change the SELECT clause to count `T1.r_regionkey` instead of using `COUNT(*)`. Do change the WHERE filter to use `T1.r_name = 'EUROPE'` instead of `s.region = 'Europe'` and remove the condition on `p.part_name`. The amended query now correctly counts region keys for European suppliers through the proper region-nation-supplier hierarchy instead of incorrectly joining suppliers directly with parts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers s JOIN parts p ON s.part_id = p.part_id WHERE p.part_name = 'hot spring dodger dim light' AND s.region = 'Europe';",
            "SELECT COUNT(T1.r_regionkey) \nFROM region AS T1 \nINNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey \nINNER JOIN supplier AS T3 ON T2.n_nationkey = T3.s_nationkey \nWHERE T1.r_name = 'EUROPE'"
        ],
        "rule_sql": []
    },
    "8847": {
        "db_id": "food_inspection",
        "question": "In businesses that violates 103157 on May 27, 2016 , what is the name of the business that has an unscheduled inspection?",
        "ground_truth": "SELECT DISTINCT T3.name FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id INNER JOIN businesses AS T3 ON T2.business_id = T3.business_id WHERE T1.`date` = '2016-05-27' AND T1.violation_type_id = 103157 AND T2.type = 'Routine - Unscheduled'",
        "amends": [
            "Do use `DISTINCT T3.name` instead of `name` to eliminate duplicates. Do join `violations AS T1` and `inspections AS T2` with `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying only `businesses` table. Do add another `INNER JOIN` to `businesses AS T3` on `T2.business_id = T3.business_id` instead of omitting the join relationships. Do filter on `T1.date = '2016-05-27'` instead of `inspection_date = '2016-05-27'` to reference the correct table. Do filter on `T1.violation_type_id = 103157` instead of `violation_id = 103157` to use the proper column name. Do filter on `T2.type = 'Routine - Unscheduled'` instead of `inspection_type = 'scheduled'` to match the correct inspection type value. The amended query now correctly joins the three related tables and applies appropriate filters to match the intended business logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE violation_id = 103157 AND inspection_date = '2016-05-27' AND inspection_type = 'scheduled';",
            "SELECT DISTINCT T3.name\nFROM violations AS T1\nINNER JOIN inspections AS T2 ON T1.business_id = T2.business_id\nINNER JOIN businesses AS T3 ON T2.business_id = T3.business_id\nWHERE T1.date = '2016-05-27'\nAND T1.violation_type_id = '103157'\nAND T2.type = 'Routine - Unscheduled'"
        ],
        "rule_sql": []
    },
    "6083": {
        "db_id": "books",
        "question": "How many books were ordered by customer Kandy Adamec?",
        "ground_truth": "SELECT COUNT(*) FROM order_line AS T1 INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE T3.first_name = 'Kandy' AND T3.last_name = 'Adamec'",
        "amends": [
            "Do join `order_line AS T1` instead of querying only `orders`. Do add `INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id` instead of omitting the join to cust_order. Do add `INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id` instead of omitting the join to customer. Do filter on `T3.first_name = 'Kandy' AND T3.last_name = 'Adamec'` instead of `customer_name = 'Kandy Adamec'` to properly match the customer by first and last name rather than a non-existent customer_name field. The amended query now correctly counts orders by joining through the proper table relationships and filtering on the actual customer name fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Kandy Adamec';",
            "SELECT COUNT(*) AS book_count\nFROM order_line AS T1\nINNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id\nINNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id\nWHERE T3.first_name = 'Kandy' AND T3.last_name = 'Adamec'"
        ],
        "rule_sql": []
    },
    "3869": {
        "db_id": "public_review_platform",
        "question": "How many users became an elite user the same year they joined Yelp?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = T2.year_id",
        "amends": [
            "Do use `COUNT(T1.user_id)` instead of `COUNT(*)` to count specific user IDs rather than all rows. Do reference table `Users AS T1` instead of `user u` with proper table naming and aliasing. Do reference table `Elite AS T2` instead of `elite_years e` with correct table name. Do use join condition `T1.user_id = T2.user_id` instead of `u.user_id = e.user_id` with proper alias references. Do use filter `T1.user_yelping_since_year = T2.year_id` instead of `u.yelping_since = e.year` with corrected column names that properly match the schema. The amended query now correctly counts users based on the relationship between user registration year and elite year membership."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM user u\nJOIN elite_years e ON u.user_id = e.user_id\nWHERE u.yelping_since = e.year;",
            "SELECT COUNT(T1.user_id) \nFROM Users AS T1\nJOIN Elite AS T2 ON T1.user_id = T2.user_id\nWHERE T1.user_yelping_since_year = T2.year_id"
        ],
        "rule_sql": []
    },
    "2035": {
        "db_id": "soccer_2016",
        "question": "What is the percentage of matches that are won by runs?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.win_type = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Win_Type) FROM Match AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id",
        "amends": [
            "Do use `SUM(CASE WHEN T1.win_type = 1 THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count specific win conditions. Do add `INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id` instead of omitting the join to the Win_By table. Do reference `T1.Win_Type` instead of `win_by_runs > 0` for the filter condition. Do use `CAST(... AS REAL)` instead of implicit casting with `100.0` for proper numeric conversion. Do calculate the percentage as `SUM(...) * 100 / COUNT(...)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM matches)` to avoid the subquery. The amended query now correctly calculates the percentage of matches won by a specific win type rather than by runs margin."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM matches)) AS percentage\nFROM matches\nWHERE win_by_runs > 0;",
            "SELECT CAST(SUM(CASE WHEN T1.Win_Type = 1 THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(*) AS percentage_won_by_runs\nFROM Match AS T1\nINNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id"
        ],
        "rule_sql": []
    },
    "7666": {
        "db_id": "hockey",
        "question": "Please list the first name of the players who are good at both left hands and right hands for goalie and have gotten in the Hall of Fame.",
        "ground_truth": "SELECT DISTINCT T1.firstName, T1.lastName FROM Master AS T1 INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE T1.shootCatch IS NULL",
        "amends": [
            "Do select `firstName` and `lastName` instead of only `first_name`. Do use `DISTINCT` instead of omitting it. Do join `Master AS T1` with `HOF AS T2` on `T1.hofID = T2.hofID` instead of querying only the `players` table. Do filter with `T1.shootCatch IS NULL` instead of `handedness = 'both' AND position = 'goalie' AND hall_of_fame = 1`. The amended query now correctly retrieves distinct player names from the Master table joined with Hall of Fame data where shooting/catching hand information is missing, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name \nFROM players \nWHERE handedness = 'both' \nAND position = 'goalie' \nAND hall_of_fame = 1",
            "SELECT DISTINCT T1.firstName, T1.lastName FROM Master AS T1 JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE T1.shootCatch IS NULL;"
        ],
        "rule_sql": []
    },
    "8976": {
        "db_id": "human_resources",
        "question": "List the location cities in the Western states.",
        "ground_truth": "SELECT locationcity FROM location WHERE state IN ('CO', 'UT', 'CA')",
        "amends": [
            "Do select `locationcity` instead of `city` from the table. Do query from `location` instead of `locations` as the source table. Do use `IN ('CO', 'UT', 'CA')` instead of `= 'Western'` for the state filter condition. The amended query now correctly selects the city column from the proper table with appropriate state filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM locations WHERE state = 'Western'",
            "SELECT locationcity FROM location WHERE state IN ('CO', 'UT', 'CA')"
        ],
        "rule_sql": []
    },
    "5900": {
        "db_id": "airline",
        "question": "What are the destinations of the flights with air carrier description \"Southeast Alaska Airlines: WEB\"?",
        "ground_truth": "SELECT T2.DEST FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Southeast Alaska Airlines: WEB'",
        "amends": [
            "Do select `T2.DEST` instead of `destination` and use proper table aliases. Do join `Air Carriers` as `T1` with `Airlines` as `T2` on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of querying only the `flights` table. Do filter on `T1.Description` instead of `air_carrier_description` to correctly match the carrier description. The amended query now properly joins carrier information with airline data to return the correct destination, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination FROM flights WHERE air_carrier_description = 'Southeast Alaska Airlines: WEB';",
            "SELECT T2.DEST \nFROM \"Air Carriers\" AS T1\nJOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nWHERE T1.Description = 'Southeast Alaska Airlines: WEB'"
        ],
        "rule_sql": []
    },
    "1326": {
        "db_id": "law_episode",
        "question": "Among the American casts, how many were uncredited on episode ID tt0629228?",
        "ground_truth": "SELECT COUNT(T1.person_id) FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T1.episode_id = 'tt0629228' AND T1.category = 'Cast' AND T1.credited = 'false' AND T2.birth_country = 'USA'",
        "amends": [
            "Do select `COUNT(T1.person_id)` instead of `COUNT(*)` to count specific person IDs rather than all rows. Do use `Credit AS T1` and `Person AS T2` tables instead of `casts` table, changing the data source entirely. Do perform `INNER JOIN` on `T2.person_id = T1.person_id` instead of querying a single table. Do filter on `T1.category = 'Cast'` instead of omitting this category condition. Do use `T1.credited = 'false'` instead of `credited = 'uncredited'` with different value semantics. Do filter on `T2.birth_country = 'USA'` instead of `nationality = 'American'` with different column and value. The amended query now correctly counts cast members from the USA who are uncredited in the specified episode using the proper table relationships and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM casts WHERE nationality = 'American' AND episode_id = 'tt0629228' AND credited = 'uncredited';",
            "SELECT COUNT(T1.person_id) \nFROM Credit AS T1\nINNER JOIN Person AS T2 ON T2.person_id = T1.person_id\nWHERE T1.episode_id = 'tt0629228'\nAND T1.category = 'Cast'\nAND T1.credited = 'false'\nAND T2.birth_country = 'USA'"
        ],
        "rule_sql": []
    },
    "5910": {
        "db_id": "airline",
        "question": "List the air carrier's description with arrival time lower than the 40% of the average arrival time of flights that flew to Phoenix.",
        "ground_truth": "SELECT T1.Description FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T2.DEST = 'PHX' AND T2.ARR_TIME < ( SELECT AVG(ARR_TIME) * 0.4 FROM Airlines ) GROUP BY T1.Description",
        "amends": [
            "Do select `T1.Description` from the `Air Carriers` table instead of `air_carrier_description` from `flights`. Do join `Airlines AS T2` using `INNER JOIN` on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of querying only the `flights` table. Do filter with `T2.DEST = 'PHX'` instead of `destination = 'Phoenix'` and use `T2.ARR_TIME` instead of `arrival_time`. Do reference the subquery against the `Airlines` table instead of `flights` and remove the destination filter from the subquery. Do add `GROUP BY T1.Description` instead of omitting aggregation grouping. The amended query now correctly joins carrier information with airline data, uses proper column references, and maintains the intended logic for finding carriers with below-average arrival times to Phoenix."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT air_carrier_description \nFROM flights \nWHERE arrival_time < (SELECT AVG(arrival_time) * 0.4 FROM flights WHERE destination = 'Phoenix');",
            "SELECT T1.Description\nFROM \"Air Carriers\" AS T1\nINNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nWHERE T2.DEST = 'PHX'\nAND T2.ARR_TIME < (\n    SELECT AVG(ARR_TIME) * 0.4\n    FROM Airlines\n    WHERE DEST = 'PHX'\n)\nGROUP BY T1.Description"
        ],
        "rule_sql": []
    },
    "8116": {
        "db_id": "university",
        "question": "Provide the score of the most populated university in 2011.",
        "ground_truth": "SELECT T2.score FROM university_year AS T1 INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE T1.year = 2011 ORDER BY T1.num_students DESC LIMIT 1",
        "amends": [
            "Do select `T2.score` from the `university_ranking_year` table instead of `score` from `universities`. Do join `university_year AS T1` with `university_ranking_year AS T2` on `T1.university_id = T2.university_id` instead of querying a single table. Do filter on `T1.year = 2011` instead of `year = 2011`. Do remove the subquery for maximum population and instead use `ORDER BY T1.num_students DESC LIMIT 1` to find the top record by student count instead of maximum population. Do add explicit table aliases and proper join syntax instead of relying on a single table structure. The amended query now correctly retrieves the score from the ranking table for the university with the most students in 2011, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT score FROM universities WHERE population = (SELECT MAX(population) FROM universities) AND year = 2011;",
            "SELECT T2.score \nFROM university_year AS T1\nJOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id\nWHERE T1.year = 2011\nORDER BY T1.num_students DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7436": {
        "db_id": "works_cycles",
        "question": "List all products with the color yellow.",
        "ground_truth": "SELECT ProductID FROM Product WHERE Color = 'Yellow'",
        "amends": [
            "Do select `ProductID` instead of `*` to return only specific columns instead of all columns. Do reference table `Product` instead of `products` to use the correct table name. Do filter for `Color = 'Yellow'` instead of `color = 'blue'` to query for yellow products instead of blue ones. The amended query now correctly returns ProductID values from the Product table where the color is yellow."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products WHERE color = 'blue';",
            "SELECT ProductID FROM Product WHERE Color = 'Yellow'"
        ],
        "rule_sql": []
    },
    "8034": {
        "db_id": "university",
        "question": "Name the university that had the most students in 2011.",
        "ground_truth": "SELECT T2.university_name FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2011 ORDER BY T1.num_students DESC LIMIT 1",
        "amends": [
            "Do select `T2.university_name` from the `university` table instead of `university_name` from the `universities` table. Do use `university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id` as the data source instead of just `universities`. Do filter on `T1.year = 2011` instead of `year = 2011`. Do order by `T1.num_students DESC` instead of `student_count ASC`. The amended query now correctly joins the university_year and university tables to access the student count data and retrieves the university with the highest number of students in 2011, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_name FROM universities WHERE year = 2011 ORDER BY student_count ASC LIMIT 1;",
            "SELECT T2.university_name\nFROM university_year AS T1\nINNER JOIN university AS T2 ON T1.university_id = T2.id\nWHERE T1.year = 2011\nORDER BY T1.num_students DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7809": {
        "db_id": "hockey",
        "question": "Is there any coach who has not been a player before but has won award? State the ID.",
        "ground_truth": "SELECT DISTINCT T2.coachID FROM Master AS T1 INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE T1.playerID IS NULL",
        "amends": [
            "Do select `DISTINCT T2.coachID` instead of `coach_id` without distinct. Do use `FROM Master AS T1 INNER JOIN AwardsCoaches AS T2` instead of `FROM coaches` as a single table. Do apply join condition `ON T1.coachID = T2.coachID` instead of no join. Do filter `WHERE T1.playerID IS NULL` instead of `WHERE player_id IS NULL AND awards > 0`, removing the awards condition. The amended query now correctly identifies coaches who never played by joining Master and AwardsCoaches tables and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_id FROM coaches WHERE player_id IS NULL AND awards > 0;",
            "SELECT DISTINCT T2.coachID\nFROM Master AS T1\nINNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID\nWHERE T1.playerID IS NULL"
        ],
        "rule_sql": []
    },
    "8480": {
        "db_id": "mondial_geo",
        "question": "Provide the population of the city of the 'World Tourism Organization' headquarter.",
        "ground_truth": "SELECT T2.Population FROM organization AS T1 INNER JOIN city AS T2 ON T1.City = T2.Name WHERE T1.Name = 'World Tourism Organization'",
        "amends": [
            "Do select `T2.Population` from the joined table instead of `population` from a single table. Do join `organization AS T1` with `city AS T2` using `INNER JOIN` on `T1.City = T2.Name` instead of querying only the `cities` table. Do filter on `T1.Name = 'World Tourism Organization'` in the WHERE clause instead of filtering directly on city name. Do reference the joined table columns with proper aliases instead of assuming direct table access. The amended query now correctly retrieves population data through the organizational relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM cities WHERE name = 'World Tourism Organization';",
            "SELECT T2.Population \nFROM organization AS T1 \nINNER JOIN city AS T2 ON T1.City = T2.Name \nWHERE T1.Name = 'World Tourism Organization';"
        ],
        "rule_sql": []
    },
    "4894": {
        "db_id": "legislator",
        "question": "Current legislator Sherrod Brown has been in the Democrat party during how many terms that he has served?",
        "ground_truth": "SELECT COUNT(*) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'Sherrod Brown' AND T2.party = 'Democrat'",
        "amends": [
            "Do use `current AS T1` and `current-terms AS T2` as FROM sources instead of `legislators` alone. Do add `INNER JOIN` on `T1.bioguide_id = T2.bioguide` instead of querying a single table. Do filter on `T1.official_full_name = 'Sherrod Brown'` instead of `name = 'Sherrod Brown'`. Do filter on `T2.party = 'Democrat'` instead of `party = 'Democrat'` to ensure the party condition applies to current terms rather than a general legislator attribute. The amended query now correctly joins current legislator data with their current terms to accurately count legislators with the specified name and current party affiliation, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE name = 'Sherrod Brown' AND party = 'Democrat';",
            "SELECT COUNT(*) \nFROM current AS T1 \nINNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide \nWHERE T1.official_full_name = 'Sherrod Brown' \nAND T2.party = 'Democrat'"
        ],
        "rule_sql": []
    },
    "945": {
        "db_id": "cs_semester",
        "question": "Among the students with less than four intelligence, list the full name and phone number of students with a greater than 3 GPA.",
        "ground_truth": "SELECT f_name, l_name, phone_number FROM student WHERE gpa > 3 AND intelligence < 4",
        "amends": [
            "Do select `f_name` and `l_name` instead of `full_name` from the `student` table instead of `students`. Do keep the same `phone_number` column and maintain the same filter conditions `gpa > 3` and `intelligence < 4` with identical logic, though their order in the WHERE clause is immaterial. The amended query now correctly references the actual table name and properly selects the individual name columns instead of a presumed combined full_name column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name, phone_number FROM students WHERE intelligence < 4 AND GPA > 3;",
            "SELECT f_name, l_name, phone_number FROM student WHERE intelligence < 4 AND gpa > 3"
        ],
        "rule_sql": []
    },
    "4203": {
        "db_id": "simpson_episodes",
        "question": "What year did the Simpsons receive its first ever award for Favorite Animated Comedy in People's Choice Award?",
        "ground_truth": "SELECT year FROM Award WHERE result = 'Winner' AND award = 'Favorite Animated Comedy' ORDER BY year DESC LIMIT 1;",
        "amends": [
            "Do reference table `Award` instead of `awards`, and use column `award` instead of `award_name` instead of `show_name` and `organization` filters. Do filter on `result = 'Winner'` instead of omitting this condition. Do order by `year DESC` instead of `ASC` to get the most recent winner instead of the earliest. The amended query now correctly retrieves the most recent year when 'Favorite Animated Comedy' won from the Award table.",
            "Do remove the `organization = 'People''s Choice Award'` filter instead of keeping it, as the right query does not require this organization constraint. Do change the sort order to `ORDER BY year DESC` instead of `ASC` to get the most recent winning year rather than the earliest. Do maintain the same core filters for `result = 'Winner'` and `award = 'Favorite Animated Comedy'` while removing the unnecessary organization restriction and reversing the sort direction to achieve the desired result of finding the latest winning year. The amended query now correctly returns the most recent year where Favorite Animated Comedy won without the extraneous organization filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM awards WHERE show_name = 'The Simpsons' AND award_name = 'Favorite Animated Comedy' AND organization = 'People\\'s Choice Award' ORDER BY year ASC LIMIT 1;",
            "SELECT year FROM Award WHERE award = 'Favorite Animated Comedy' AND organization = 'People''s Choice Award' AND result = 'Winner' ORDER BY year ASC LIMIT 1;",
            "SELECT year FROM Award WHERE award = 'Favorite Animated Comedy' AND result = 'Winner' ORDER BY year DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3148": {
        "db_id": "donor",
        "question": "When was the highest amount of donated? How much was the amount?",
        "ground_truth": "SELECT donation_timestamp, donation_total FROM donations WHERE donation_total = ( SELECT donation_total FROM donations ORDER BY donation_total DESC LIMIT 1 )",
        "amends": [
            "Do select `donation_timestamp` and `donation_total` instead of `date` and `MAX(amount)`. Do use a subquery that selects `donation_total` ordered by `donation_total DESC` with `LIMIT 1` instead of using `MIN(amount)` aggregation. Do remove the `MAX` aggregation from the main query instead of keeping it. Do reference `donation_timestamp` and `donation_total` columns instead of `date` and `amount`. The amended query now correctly retrieves the record with the highest donation amount by using a descending ordered subquery with limit instead of an incorrect combination of MAX and MIN aggregations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, MAX(amount) FROM donations WHERE amount = (SELECT MIN(amount) FROM donations);",
            "SELECT donation_timestamp, donation_total \nFROM donations \nWHERE donation_total = (SELECT donation_total FROM donations ORDER BY donation_total DESC LIMIT 1) \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3830": {
        "db_id": "public_review_platform",
        "question": "How many \"cool\" compliments did user number 33 receive?",
        "ground_truth": "SELECT COUNT(T2.compliment_type) FROM Users_Compliments AS T1 INNER JOIN Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE T1.user_id = 33 AND T2.compliment_type LIKE 'cool'",
        "amends": [
            "Do use `COUNT(T2.compliment_type)` instead of `COUNT(*)` to count specific compliment occurrences. Do join `Users_Compliments AS T1` with `Compliments AS T2` on `T1.compliment_id = T2.compliment_id` instead of querying a single `compliments` table. Do filter on `T1.user_id = 33` instead of `user_id = 33` to reference the correct table. Do use `T2.compliment_type LIKE 'cool'` instead of `compliment = 'cool'` to match the proper column name and use pattern matching. The amended query now correctly counts compliments by joining the user-compliment relationship table with the compliment definitions table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM compliments WHERE user_id = 33 AND compliment = 'cool';",
            "SELECT COUNT(T2.compliment_type) \nFROM Users_Compliments AS T1\nJOIN Compliments AS T2 ON T1.compliment_id = T2.compliment_id\nWHERE T1.user_id = 33 AND T2.compliment_type LIKE 'cool'"
        ],
        "rule_sql": []
    },
    "237": {
        "db_id": "book_publishing_company",
        "question": "Which title is about helpful hints on how to use your electronic resources, which publisher published it and what is the price of this book?",
        "ground_truth": "SELECT T1.title, T2.pub_name, T1.price FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id WHERE T1.notes = 'Helpful hints on how to use your electronic resources to the best advantage.'",
        "amends": [
            "Do add table aliases `T1` and `T2` instead of omitting them, and specify `T1.title` and `T1.price` instead of unqualified `title` and `price`. Do join `publishers AS T2` on `T1.pub_id = T2.pub_id` instead of omitting the join entirely. Do change the WHERE condition to exact match `T1.notes = 'Helpful hints on how to use your electronic resources to the best advantage.'` instead of using `LIKE '%helpful hints%' AND title LIKE '%electronic resources%'`. Do remove `ORDER BY price DESC LIMIT 1` instead of keeping it, as the exact match returns only one row. The amended query now correctly joins the titles and publishers tables and uses precise string matching instead of partial pattern matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, publisher, price FROM books WHERE title LIKE '%helpful hints%' AND title LIKE '%electronic resources%' ORDER BY price DESC LIMIT 1;",
            "SELECT T1.title, T2.pub_name AS publisher, T1.price \nFROM titles AS T1 \nJOIN publishers AS T2 ON T1.pub_id = T2.pub_id \nWHERE T1.notes = 'Helpful hints on how to use your electronic resources to the best advantage.'"
        ],
        "rule_sql": []
    },
    "3046": {
        "db_id": "shakespeare",
        "question": "How many of the works of Shakespeare are Tragedy?",
        "ground_truth": "SELECT COUNT(id) FROM works WHERE GenreType = 'Tragedy'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do filter on `GenreType = 'Tragedy'` instead of `genre = 'Comedy'` to select the correct genre category. Do remove the `author = 'Shakespeare'` filter instead of keeping it to include all authors' works. The amended query now correctly counts works of tragedy genre regardless of author, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM works WHERE author = 'Shakespeare' AND genre = 'Comedy';",
            "SELECT COUNT(id) FROM works WHERE GenreType = 'Tragedy'"
        ],
        "rule_sql": []
    },
    "7104": {
        "db_id": "works_cycles",
        "question": "List the name of the rates that apply to the provinces that are in the territory that obtained the greatest increase in sales with respect to the previous year.",
        "ground_truth": "SELECT T2.Name FROM SalesTerritory AS T1 INNER JOIN StateProvince AS T2 ON T1.CountryRegionCode = T2.CountryRegionCode INNER JOIN SalesTaxRate AS T3 ON T2.StateProvinceID = T3.StateProvinceID ORDER BY (T1.SalesYTD - T1.SalesLastYear) / T1.SalesLastYear DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `r`, `p`, and `t`. Do select `T2.Name` instead of `r.name`. Do join `SalesTerritory AS T1` instead of `rates r`. Do join `StateProvince AS T2` with `ON T1.CountryRegionCode = T2.CountryRegionCode` instead of `provinces p` with `ON r.province_id = p.id`. Do join `SalesTaxRate AS T3` with `ON T2.StateProvinceID = T3.StateProvinceID` instead of `territories t` with `JOIN territories t ON p.territory_id = t.id`. Do remove the WHERE clause with subquery instead of keeping it. Do add ORDER BY with `(T1.SalesYTD - T1.SalesLastYear) / T1.SalesLastYear DESC` instead of using a subquery for territory selection. Do add LIMIT 1 at the end instead of in a subquery. The amended query now correctly calculates the sales growth percentage and returns the top state province name based on territory performance."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT r.name \nFROM rates r\nJOIN provinces p ON r.province_id = p.id\nJOIN territories t ON p.territory_id = t.id\nWHERE t.id = (\n    SELECT territory_id\n    FROM sales\n    GROUP BY territory_id\n    ORDER BY SUM(amount) - SUM(previous_year_amount) DESC\n    LIMIT 1\n);",
            "SELECT T2.Name \nFROM SalesTerritory AS T1\nJOIN StateProvince AS T2 ON T1.CountryRegionCode = T2.CountryRegionCode\nJOIN SalesTaxRate AS T3 ON T2.StateProvinceID = T3.StateProvinceID\nORDER BY (T1.SalesYTD - T1.SalesLastYear) / T1.SalesLastYear DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5781": {
        "db_id": "language_corpus",
        "question": "How many words are there on the page that the word \"grec\" has occurred for 52 times?",
        "ground_truth": "SELECT SUM(T3.words) FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE T1.word = 'grec' AND T2.occurrences = 52",
        "amends": [
            "Do use `SUM(T3.words)` instead of `COUNT(*)` to sum page word counts rather than counting rows. Do add `INNER JOIN pages_words AS T2 ON T1.wid = T2.wid` and `INNER JOIN pages AS T3 ON T2.pid = T3.pid` instead of querying only the `words` table to properly join through the relationship tables. Do change the filter to `T2.occurrences = 52` instead of `occurrence_count = 52` to use the correct column name from the join table. Do keep `T1.word = 'grec'` as the word filter but now reference it through the joined table alias. The amended query now correctly calculates the total words across pages containing the specified word with the given occurrence count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE word = 'grec' AND occurrence_count = 52;",
            "SELECT SUM(T3.words) \nFROM words AS T1\nINNER JOIN pages_words AS T2 ON T1.wid = T2.wid\nINNER JOIN pages AS T3 ON T2.pid = T3.pid\nWHERE T1.word = 'grec' AND T2.occurrences = 52"
        ],
        "rule_sql": []
    },
    "2724": {
        "db_id": "regional_sales",
        "question": "What is the name of the customer who purchased the product with the highest net profiit?",
        "ground_truth": "SELECT `Customer Names` FROM ( SELECT T1.`Customer Names`, T2.`Unit Price` - T2.`Unit Cost` AS \"net profit\" FROM Customers T1 INNER JOIN `Sales Orders` T2 ON T2._CustomerID = T1.CustomerID ) ORDER BY `net profit` DESC LIMIT 1",
        "amends": [
            "Do select `Customer Names` instead of `customer_name` and calculate `net profit` as `Unit Price` - `Unit Cost` instead of using a direct column reference. Do add a subquery with an `INNER JOIN` between `Customers` and `Sales Orders` on `T2._CustomerID = T1.CustomerID` instead of querying only the `customers` table. Do order by the calculated `net profit` instead of a presumed `net_profit` column. The amended query now correctly calculates profit per transaction before selecting the top customer, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY net_profit DESC LIMIT 1;",
            "SELECT \"Customer Names\"\nFROM Customers\nWHERE CustomerID IN (\n    SELECT _CustomerID\n    FROM \"Sales Orders\"\n    WHERE (CAST(\"Unit Price\" AS REAL) - CAST(\"Unit Cost\" AS REAL)) = (\n        SELECT MAX(CAST(\"Unit Price\" AS REAL) - CAST(\"Unit Cost\" AS REAL))\n        FROM \"Sales Orders\"\n    )\n);"
        ],
        "rule_sql": []
    },
    "3934": {
        "db_id": "public_review_platform",
        "question": "List the closing time and day of week of active businesses in Scottsdale with stars greater than the 60% of average age of star rating.",
        "ground_truth": "SELECT T2.closing_time, T3.day_of_week FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Scottsdale' AND T1.active LIKE 'TRUE' AND T1.stars > 0.6 * ( SELECT AVG(T1.stars) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Scottsdale' AND T1.active LIKE 'TRUE' )",
        "amends": [
            "Do select `T2.closing_time` and `T3.day_of_week` instead of `closing_time` and `day_of_week` without table prefixes. Do use `INNER JOIN` with `Business_Hours AS T2` on `T1.business_id = T2.business_id` and `Days AS T3` on `T2.day_id = T3.day_id` instead of querying only the `businesses` table. Do filter with `T1.city LIKE 'Scottsdale'` instead of `city = 'Scottsdale'`. Do use `T1.active LIKE 'TRUE'` instead of `active = 1`. Do calculate the condition as `T1.stars > 0.6 * (subquery)` instead of `stars > (SELECT AVG(age) * 0.6 FROM businesses)`. Do use a correlated subquery that calculates `AVG(T1.stars)` from properly joined tables with the same city and active filters instead of averaging the `age` column from the base table. The amended query now correctly joins multiple tables, uses appropriate string matching for boolean values, and calculates the average stars rather than age for the comparison threshold."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT closing_time, day_of_week \nFROM businesses \nWHERE city = 'Scottsdale' \nAND active = 1 \nAND stars > (SELECT AVG(age) * 0.6 FROM businesses);",
            "SELECT T2.closing_time, T3.day_of_week\nFROM Business AS T1\nINNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id\nINNER JOIN Days AS T3 ON T2.day_id = T3.day_id\nWHERE T1.city LIKE 'Scottsdale'\nAND T1.active LIKE 'TRUE'\nAND T1.stars > 0.6 * (\n    SELECT AVG(T4.stars)\n    FROM Business AS T4\n    WHERE T4.city LIKE 'Scottsdale'\n    AND T4.active LIKE 'TRUE'\n)"
        ],
        "rule_sql": []
    },
    "5370": {
        "db_id": "sales",
        "question": "What is the name of the product with the lowest quantity?",
        "ground_truth": "SELECT T2.Name FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Quantity LIMIT 1",
        "amends": [
            "Do select `T2.Name` from the `Products` table instead of `name` from the `products` table. Do join `Sales AS T1` with `Products AS T2` using `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying only the products table without any join. Do order by `T1.Quantity` instead of `quantity DESC` to sort by sales quantity rather than product inventory quantity. The amended query now correctly retrieves the product name from the highest quantity sale by joining the sales and products tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products ORDER BY quantity DESC LIMIT 1;",
            "SELECT T2.Name FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Quantity LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8446": {
        "db_id": "mondial_geo",
        "question": "Which of the top 3 economies by GDP has the lowest proportion of the economy devoted to agriculture?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY T2.GDP DESC, T2.Agriculture ASC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `country, gdp, agriculture_percentage`. Do use `FROM country AS T1 INNER JOIN economy AS T2` instead of `FROM economies`. Do join on `T1.Code = T2.Country` instead of no join condition. Do order by `T2.GDP DESC, T2.Agriculture ASC` instead of separate `ORDER BY gdp DESC` and `ORDER BY agriculture_percentage ASC` clauses. Do use single `LIMIT 1` instead of conflicting `LIMIT 3` and `LIMIT 1`. The amended query now correctly retrieves the country with the highest GDP and lowest agriculture percentage from properly joined tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, gdp, agriculture_percentage \nFROM economies \nORDER BY gdp DESC \nLIMIT 3 \nORDER BY agriculture_percentage ASC \nLIMIT 1;",
            "SELECT T1.Name \nFROM country AS T1 \nINNER JOIN economy AS T2 ON T1.Code = T2.Country \nORDER BY T2.GDP DESC, T2.Agriculture ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5210": {
        "db_id": "address",
        "question": "Among the listed cities, provide the area code of the city with the largest water area.",
        "ground_truth": "SELECT T1.area_code FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.water_area = ( SELECT MAX(water_area) FROM zip_data )",
        "amends": [
            "Do add `INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code` instead of querying only the `cities` table. Do change the FROM clause to use `area_code AS T1` instead of `cities`. Do add a WHERE filter `T2.water_area = (SELECT MAX(water_area) FROM zip_data)` instead of using `ORDER BY water_area DESC LIMIT 1`. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly identifies the area code associated with the maximum water area by joining the appropriate tables and using a subquery to find the maximum value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area_code FROM cities ORDER BY water_area DESC LIMIT 1;",
            "SELECT T1.area_code \nFROM area_code AS T1 \nINNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code \nWHERE T2.water_area = (SELECT MAX(water_area) FROM zip_data)"
        ],
        "rule_sql": []
    },
    "2420": {
        "db_id": "superstore",
        "question": "How many orders were made by Corey Roper in 2015?",
        "ground_truth": "SELECT COUNT(T2.`Customer ID`) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Customer Name` = 'Corey Roper' AND STRFTIME('%Y', T2.`Ship Date`) = '2015'",
        "amends": [
            "Do join `people AS T1` with `central_superstore AS T2` on `T1.Customer ID = T2.Customer ID` instead of querying only the `orders` table. Do filter on `T1.Customer Name = 'Corey Roper'` instead of `customer_name = 'Corey Roper'`. Do use `STRFTIME('%Y', T2.Ship Date) = '2015'` for year extraction instead of `order_date LIKE '2014%'` to correctly filter for 2015 instead of 2014. Do count `T2.Customer ID` instead of `COUNT(*)` to count specific customer records. The amended query now correctly joins customer data with order details and filters for the right year, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Corey Roper' AND order_date LIKE '2014%';",
            "SELECT COUNT(T2.\"Customer ID\") \nFROM people AS T1 \nJOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" \nWHERE T1.\"Customer Name\" = 'Corey Roper' \nAND STRFTIME('%Y', T2.\"Ship Date\") = '2015'"
        ],
        "rule_sql": []
    },
    "1023": {
        "db_id": "computer_student",
        "question": "How many advisors are in charge of advising all the students in 1st year?",
        "ground_truth": "SELECT COUNT(T1.p_id_dummy) FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.yearsInProgram = 'Year_1' AND T2.student = 1",
        "amends": [
            "Do select `COUNT(T1.p_id_dummy)` instead of `COUNT(*)` to count specific advisor relationships. Do join `advisedBy AS T1` and `person AS T2` with `INNER JOIN` on `T1.p_id = T2.p_id` instead of querying only the `advisors` table. Do add filter `T2.yearsInProgram = 'Year_1'` instead of `year = 1` to properly match the year format. Do add filter `T2.student = 1` instead of omitting it to ensure only student records are counted. The amended query now correctly counts first-year student advisors by joining relationship and person tables with proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM advisors WHERE year = 1;",
            "SELECT COUNT(T1.p_id_dummy) \nFROM advisedBy AS T1 \nINNER JOIN person AS T2 ON T1.p_id = T2.p_id \nWHERE T2.yearsInProgram = 'Year_1' AND T2.student = 1"
        ],
        "rule_sql": []
    },
    "8819": {
        "db_id": "food_inspection",
        "question": "What is the name of the establishment with the highest number of low risk violations in 2014?",
        "ground_truth": "SELECT T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) = '2014' AND T1.risk_category = 'Low Risk' GROUP BY T2.name ORDER BY COUNT(T2.business_id) DESC LIMIT 1",
        "amends": [
            "Do add `T2.name` in the SELECT list instead of just `name`. Do change the FROM clause to use `violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id` instead of a single table. Do add WHERE filters for `STRFTIME('%Y', T1.date) = '2014'` and `T1.risk_category = 'Low Risk'` instead of omitting them. Do add GROUP BY `T2.name` instead of no grouping. Do change ORDER BY to `COUNT(T2.business_id) DESC` instead of `violations DESC`. The amended query now correctly joins the violations and businesses tables, filters for 2014 low-risk violations, groups by establishment name, and orders by violation count to find the establishment with the most low-risk violations in 2014."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM establishments ORDER BY violations DESC LIMIT 1;",
            "SELECT T2.name\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE STRFTIME('%Y', T1.date) = '2014' AND T1.risk_category = 'Low Risk'\nGROUP BY T2.name\nORDER BY COUNT(T2.business_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2483": {
        "db_id": "shooting",
        "question": "What is the proportion of white males and females in the police force?",
        "ground_truth": "SELECT CAST(SUM(gender = 'M') AS REAL) / SUM(gender = 'F') FROM officers WHERE race = 'W'",
        "amends": [
            "Do use `SUM(gender = 'M')` and `SUM(gender = 'F')` instead of `COUNT(CASE WHEN race = 'White' AND gender = 'Male' THEN 1 END)` and `COUNT(CASE WHEN race = 'White' AND gender = 'Female' THEN 1 END)` for conditional counting. Do add `WHERE race = 'W'` filter instead of omitting it from the query. Do calculate the ratio of `SUM(gender = 'M')` to `SUM(gender = 'F')` instead of calculating separate percentages against total count. Do use `CAST(... AS REAL)` instead of multiplying by `100.0` for proper division handling. Do query from `officers` table instead of `police_force` table. Do remove the percentage calculation and aliases instead of keeping them. The amended query now correctly calculates the male-to-female ratio for white officers using proper conditional aggregation and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN race = 'White' AND gender = 'Male' THEN 1 END) * 100.0 / COUNT(*)) AS white_male_percentage,\n    (COUNT(CASE WHEN race = 'White' AND gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS white_female_percentage\nFROM police_force;",
            "SELECT \n    CAST(SUM(gender = 'M') AS REAL) / SUM(gender = 'F') AS male_to_female_ratio\nFROM officers\nWHERE race = 'W';"
        ],
        "rule_sql": []
    },
    "8738": {
        "db_id": "chicago_crime",
        "question": "Please list any three criminal sexual assault cases against persons where the criminals have been arrested.",
        "ground_truth": "SELECT T2.case_number FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE T1.title = 'Criminal Sexual Assault' AND T2.arrest = 'TRUE' AND T1.crime_against = 'Persons' LIMIT 3",
        "amends": [
            "Do select only `case_number` from the `Crime` table instead of selecting all columns from `criminal_cases`. Do join `FBI_Code` with `Crime` using `INNER JOIN` on `fbi_code_no` instead of querying a single table. Do filter on `title = 'Criminal Sexual Assault'` and `crime_against = 'Persons'` from the `FBI_Code` table instead of `crime_type = 'sexual assault'`. Do filter on `arrest = 'TRUE'` instead of `arrest_status = 'arrested'`. The amended query now correctly joins the appropriate tables with proper FBI code classification and arrest status handling to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM criminal_cases WHERE crime_type = 'sexual assault' AND arrest_status = 'arrested' LIMIT 3;",
            "SELECT c.case_number \nFROM Crime c\nINNER JOIN FBI_Code f ON c.fbi_code_no = f.fbi_code_no\nWHERE f.title = 'Criminal Sexual Assault' \nAND f.crime_against = 'Persons' \nAND c.arrest = 'TRUE'\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "5100": {
        "db_id": "address",
        "question": "What are the precise locations of the cities with an area code of 787?",
        "ground_truth": "SELECT T2.latitude, T2.longitude FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.area_code = '787' GROUP BY T2.latitude, T2.longitude",
        "amends": [
            "Do select `T2.latitude` and `T2.longitude` instead of `city` and `state`. Do join `area_code AS T1` with `zip_data AS T2` on `T1.zip_code = T2.zip_code` instead of querying only `cities`. Do add `GROUP BY T2.latitude, T2.longitude` instead of omitting aggregation. Do filter on `T1.area_code = '787'` instead of `area_code = '787'` to reference the joined table correctly. The amended query now correctly retrieves geographic coordinates from zip data instead of city/state information, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, state FROM cities WHERE area_code = '787';",
            "SELECT T2.latitude, T2.longitude\nFROM area_code AS T1\nJOIN zip_data AS T2 ON T1.zip_code = T2.zip_code\nWHERE T1.area_code = '787'\nGROUP BY T2.latitude, T2.longitude"
        ],
        "rule_sql": []
    },
    "8060": {
        "db_id": "university",
        "question": "List the ranking criteria under the Shanghai Ranking system.",
        "ground_truth": "SELECT T2.criteria_name FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T1.system_name = 'Shanghai Ranking'",
        "amends": [
            "Do specify `T2.criteria_name` in the SELECT list instead of using `*` to select all columns. Do add a join from `ranking_system AS T1` instead of querying only the `ranking_criteria` table. Do use `INNER JOIN` with `ranking_criteria AS T2` on `T1.id = T2.ranking_system_id` instead of no join condition. Do filter on `T1.system_name = 'Shanghai Ranking'` instead of filtering on `system = 'Shanghai Ranking'` from the wrong table. The amended query now correctly retrieves criteria names by joining through the ranking system relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM ranking_criteria WHERE system = 'Shanghai Ranking';",
            "SELECT T2.criteria_name \nFROM ranking_system AS T1 \nINNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id \nWHERE T1.system_name = 'Shanghai Ranking'"
        ],
        "rule_sql": []
    },
    "4580": {
        "db_id": "mental_health_survey",
        "question": "What is the average age of the survey respondents in the United States?",
        "ground_truth": "SELECT CAST(SUM(T1.AnswerText) AS REAL) / COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN ( SELECT T1.UserID FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 3 AND T1.AnswerText = 'United States' ) AS T2 ON T1.UserID = T2.UserID INNER JOIN Question AS T3 ON T1.QuestionID = T3.questionid WHERE T3.questionid = 1",
        "amends": [
            "Do use `CAST(SUM(T1.AnswerText) AS REAL) / COUNT(T1.UserID)` instead of `AVG(age)` for the average calculation. Do join `Answer AS T1` with a subquery instead of querying `survey_responses` directly. Do add an `INNER JOIN` with `Question AS T3` on `T1.QuestionID = T3.questionid` instead of omitting this table. Do filter with `T3.questionid = 1` instead of `country = 'USA'` for the main condition. Do include a correlated subquery that filters for `T2.questionid = 3 AND T1.AnswerText = 'United States'` instead of the simple country filter. The amended query now correctly calculates the average of numeric responses for question 1 from users who identified as being from the United States in question 3, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM survey_responses WHERE country = 'USA';",
            "SELECT CAST(SUM(T1.AnswerText) AS REAL) / COUNT(T1.UserID) AS average_age\nFROM Answer AS T1\nINNER JOIN Question AS T3 ON T1.QuestionID = T3.questionid\nWHERE T3.questionid = 1\nAND EXISTS (\n    SELECT 1\n    FROM Answer AS T2\n    INNER JOIN Question AS T4 ON T2.QuestionID = T4.questionid\n    WHERE T2.UserID = T1.UserID\n    AND T4.questionid = 3\n    AND T2.AnswerText = 'United States'\n)"
        ],
        "rule_sql": []
    },
    "2459": {
        "db_id": "superstore",
        "question": "List the customer's name from the South region with a standard class ship mode and sales greater than the 88% of the average sales of all orders.",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T2.Region = 'South' AND T1.`Ship Mode` = 'Standard Class' AND 100 * T1.Sales / ( SELECT AVG(Sales) FROM south_superstore ) > 88",
        "amends": [
            "Do use `DISTINCT T2.`Customer Name`` instead of `customer_name` and specify the exact column source. Do join `south_superstore AS T1` with `people AS T2` on `T1.`Customer ID` = T2.`Customer ID`` instead of querying only the `orders` table. Do filter on `T2.Region = 'South'` instead of `region = 'South'` to use the correct table source. Do filter on `T1.`Ship Mode` = 'Standard Class'` instead of `ship_mode = 'Standard Class'` with proper table qualification. Do calculate `100 * T1.Sales / (SELECT AVG(Sales) FROM south_superstore) > 88` instead of `sales > (SELECT AVG(sales) * 0.88 FROM orders)` to properly normalize sales against the average and use the correct subquery source table. The amended query now correctly joins customer data, uses proper table qualifications, and implements the percentage comparison logic accurately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name \nFROM orders \nWHERE region = 'South' \nAND ship_mode = 'Standard Class' \nAND sales > (SELECT AVG(sales) * 0.88 FROM orders);",
            "SELECT DISTINCT T2.\"Customer Name\"\nFROM south_superstore AS T1\nJOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nWHERE T2.Region = 'South'\nAND T1.\"Ship Mode\" = 'Standard Class'\nAND 100 * T1.Sales / (SELECT AVG(Sales) FROM south_superstore) > 88"
        ],
        "rule_sql": []
    },
    "4330": {
        "db_id": "simpson_episodes",
        "question": "Which episode has the highest number of vote of the star score?",
        "ground_truth": "SELECT episode_id FROM Vote ORDER BY votes DESC LIMIT 1;",
        "amends": [
            "Do select only `episode_id` instead of including `MAX(star_score)` and aliasing it as `highest_score`. Do query from `Vote` table instead of `episodes` table. Do remove the `GROUP BY episode_id` clause instead of grouping by episode. Do order by `votes DESC` instead of ordering by the aggregated `highest_score DESC`. Do remove the unnecessary aggregation function and grouping since the right query directly selects from the Vote table which presumably contains vote counts per episode. The amended query now correctly retrieves the episode with the highest vote count from the Vote table instead of trying to find maximum star scores from an episodes table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id, MAX(star_score) as highest_score FROM episodes GROUP BY episode_id ORDER BY highest_score DESC LIMIT 1;",
            "SELECT episode_id FROM Vote ORDER BY votes DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7476": {
        "db_id": "image_and_language",
        "question": "Please list the IDs of the object samples in class no. 297 in image no.1.",
        "ground_truth": "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ WHERE IMG_ID = 1 AND OBJ_CLASS_ID = 297",
        "amends": [
            "Do reference column `OBJ_SAMPLE_ID` instead of `object_id` and table `IMG_OBJ` instead of `objects`. Do use filter conditions `IMG_ID = 1` instead of `image_id = 1` and `OBJ_CLASS_ID = 297` instead of `class_id = 297`. The amended query now correctly references the appropriate schema elements to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_id FROM objects WHERE class_id = 297 AND image_id = 1;",
            "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ WHERE IMG_ID = 1 AND OBJ_CLASS_ID = 297"
        ],
        "rule_sql": []
    },
    "5300": {
        "db_id": "beer_factory",
        "question": "Calculate the difference between the number of root beers sold that use cane sugar and corn syrup.",
        "ground_truth": "SELECT COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS DIFFERENCE FROM rootbeer AS T1 INNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID",
        "amends": [
            "Do use a single query with `COUNT(CASE)` conditional aggregation instead of separate subqueries. Do join `rootbeer` table as `T1` instead of querying `root_beers` directly. Do add `INNER JOIN` to `transaction` table as `T2` on `T1.RootBeerID = T2.RootBeerID` instead of omitting this relationship. Do add `INNER JOIN` to `rootbeerbrand` table as `T3` on `T1.BrandID = T3.BrandID` instead of working with raw sweetener values. Do check `T3.CaneSugar = 'TRUE'` and `T3.CornSyrup = 'TRUE'` instead of filtering on `sweetener = 'cane sugar'` and `sweetener = 'corn syrup'`. Do count `T1.BrandID` with conditional logic instead of using simple `COUNT(*)`. The amended query now correctly calculates the difference between cane sugar and corn syrup root beers by properly joining through the brand and transaction relationships.",
            "Do add `ELSE NULL` in both `CASE` expressions instead of omitting it, ensuring proper handling of non-matching conditions in the count aggregates. The amended query now correctly counts only rows where the specified conditions are met by explicitly returning NULL for non-matching cases, matching the RIGHT_SQL's behavior.",
            "Do use the exact same SELECT list with identical column references and CASE expressions instead of any changes, as both queries maintain `COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS Difference`. Do preserve the same FROM clause structure with `rootbeer T1` instead of `rootbeer AS T1`, though this is purely cosmetic. Do maintain the identical join conditions with `INNER JOIN transaction T2 ON T1.RootBeerID = T2.RootBeerID` and `INNER JOIN rootbeerbrand T3 ON T1.BrandID = T3.BrandID` instead of any functional changes. The amended query now matches RIGHT_SQL's behavior as there are no substantive differences between the queries.",
            "Do use the exact same query structure instead of making any changes, as both SQL queries are functionally identical with only minor formatting differences. The SELECT list with `COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS Difference` remains unchanged, the FROM sources with `rootbeer T1 INNER JOIN transaction T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand T3 ON T1.BrandID = T3.BrandID` are identical, and all join conditions and table aliases match exactly. The amended query now matches RIGHT_SQL's behavior with no substantive changes required.",
            "Do use the exact same SELECT clause with `COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS DIFFERENCE` instead of using lowercase column references and alias. Do maintain the identical FROM structure with `INNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID` and `INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID` instead of omitting the table aliases. The amended query now matches RIGHT_SQL's behavior with identical logic and results."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM root_beers WHERE sweetener = 'cane sugar') - \n    (SELECT COUNT(*) FROM root_beers WHERE sweetener = 'corn syrup') AS difference;",
            "SELECT \n    COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID END) - \n    COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID END) AS difference\nFROM \n    rootbeer T1\nINNER JOIN \n    transaction T2 ON T1.RootBeerID = T2.RootBeerID\nINNER JOIN \n    rootbeerbrand T3 ON T1.BrandID = T3.BrandID;",
            "SELECT \n    COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - \n    COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS Difference\nFROM rootbeer T1\nINNER JOIN transaction T2 ON T1.RootBeerID = T2.RootBeerID\nINNER JOIN rootbeerbrand T3 ON T1.BrandID = T3.BrandID",
            "SELECT \n    COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - \n    COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS Difference\nFROM \n    rootbeer T1\nINNER JOIN \n    transaction T2 ON T1.RootBeerID = T2.RootBeerID\nINNER JOIN \n    rootbeerbrand T3 ON T1.BrandID = T3.BrandID",
            "SELECT \n    COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - \n    COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS Difference\nFROM \n    rootbeer T1\n    INNER JOIN transaction T2 ON T1.RootBeerID = T2.RootBeerID\n    INNER JOIN rootbeerbrand T3 ON T1.BrandID = T3.BrandID",
            "SELECT \n    COUNT(CASE WHEN T3.CaneSugar = 'TRUE' THEN T1.BrandID ELSE NULL END) - \n    COUNT(CASE WHEN T3.CornSyrup = 'TRUE' THEN T1.BrandID ELSE NULL END) AS DIFFERENCE\nFROM \n    rootbeer T1\n    INNER JOIN transaction T2 ON T1.RootBeerID = T2.RootBeerID\n    INNER JOIN rootbeerbrand T3 ON T1.BrandID = T3.BrandID"
        ],
        "rule_sql": []
    },
    "207": {
        "db_id": "book_publishing_company",
        "question": "What is the publisher that has published the most expensive book?",
        "ground_truth": "SELECT T2.pub_name FROM titles AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id ORDER BY T1.price DESC LIMIT 1",
        "amends": [
            "Do join `publishers` as `T2` on `T1.pub_id = T2.pub_id` instead of querying only the `books` table without any join. Do select `T2.pub_name` instead of `publisher` to get the publisher name from the correct joined table. Do reference the `price` column as `T1.price` instead of just `price` to specify the table alias. Do use table aliases `T1` for `titles` and `T2` for `publishers` instead of no aliases. The amended query now correctly joins the tables to retrieve the publisher name associated with the highest-priced book, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM books ORDER BY price DESC LIMIT 1;",
            "SELECT T2.pub_name FROM titles T1 JOIN publishers T2 ON T1.pub_id = T2.pub_id WHERE T1.price = (SELECT MAX(price) FROM titles) LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8512": {
        "db_id": "software_company",
        "question": "Please list the occupations of the customers with an education level of 11.",
        "ground_truth": "SELECT DISTINCT OCCUPATION FROM Customers WHERE EDUCATIONNUM = 11",
        "amends": [
            "Do use `DISTINCT` for `OCCUPATION` instead of omitting it. Do filter on `EDUCATIONNUM = 11` instead of `education_level = '11'` to use the correct numeric column and remove the string literal quotes. Do reference the table as `Customers` instead of `customers` to match the correct case. The amended query now correctly returns unique occupations for customers with education number 11, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT occupation FROM customers WHERE education_level = '11';",
            "SELECT DISTINCT OCCUPATION FROM Customers WHERE EDUCATIONNUM = 11"
        ],
        "rule_sql": []
    },
    "7745": {
        "db_id": "hockey",
        "question": "Among the teams whose shorthanded goals are between 1 to 5, which player is the most trustworthy in the critical moment?",
        "ground_truth": "SELECT T2.nameGiven, T2.lastName FROM Scoring AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.SHG BETWEEN 1 AND 5 ORDER BY T1.GWG DESC LIMIT 1",
        "amends": [
            "Do select `T2.nameGiven` and `T2.lastName` instead of `player_name`. Do join `Scoring AS T1` with `Master AS T2` using `INNER JOIN` on `T1.playerID = T2.playerID` instead of querying only the `players` table. Do filter on `T1.SHG BETWEEN 1 AND 5` instead of `shorthanded_goals BETWEEN 1 AND 5`. Do order by `T1.GWG DESC` instead of `shorthanded_goals DESC`. The amended query now correctly retrieves player names from the Master table joined with Scoring data, filters by shorthanded goals, and sorts by game-winning goals to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name \nFROM players \nWHERE shorthanded_goals BETWEEN 1 AND 5 \nORDER BY shorthanded_goals DESC \nLIMIT 1;",
            "SELECT T2.nameGiven, T2.lastName\nFROM Scoring AS T1\nINNER JOIN Master AS T2 ON T1.playerID = T2.playerID\nWHERE T1.SHG BETWEEN 1 AND 5\nORDER BY T1.GWG DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "860": {
        "db_id": "cs_semester",
        "question": "Please list the full names of all the students who are research assistants with the highest research capability.",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN RA AS T2 ON T1.student_id = T2.student_id WHERE T2.capability = 5",
        "amends": [
            "Do select `T1.f_name` and `T1.l_name` instead of `first_name` and `last_name`. Do use `INNER JOIN` on `RA AS T2` with predicate `T1.student_id = T2.student_id` instead of querying only the `students` table. Do filter on `T2.capability = 5` instead of `research_assistant = 1`. Do remove `ORDER BY research_capability DESC LIMIT 1` instead of keeping the ordering and limiting. The amended query now correctly joins with the RA table to identify research assistants with specific capability and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students WHERE research_assistant = 1 ORDER BY research_capability DESC LIMIT 1;",
            "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN RA AS T2 ON T1.student_id = T2.student_id WHERE T2.capability = 5"
        ],
        "rule_sql": []
    },
    "3267": {
        "db_id": "donor",
        "question": "How many schools in Suffolk County have Ph.D. teachers?",
        "ground_truth": "SELECT COUNT(schoolid) FROM projects WHERE teacher_prefix = 'Dr.' AND school_county = 'Suffolk'",
        "amends": [
            "Do select `COUNT(schoolid)` from the `projects` table instead of `COUNT(*)` from `schools`. Do filter on `teacher_prefix = 'Dr.'` and `school_county = 'Suffolk'` instead of `county = 'Suffolk'` and `teachers_phd > 0`. The amended query now correctly counts schools with teachers having the 'Dr.' prefix in Suffolk county, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE county = 'Suffolk' AND teachers_phd > 0;",
            "SELECT COUNT(DISTINCT schoolid) FROM projects WHERE teacher_prefix = 'Dr.' AND school_county = 'Suffolk'"
        ],
        "rule_sql": []
    },
    "751": {
        "db_id": "movie",
        "question": "Show the birth city of the actor who played \"Gabriel Martin\".",
        "ground_truth": "SELECT T2.`Birth City` FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE T1.`Character Name` = 'Gabriel Martin'",
        "amends": [
            "Do join `characters AS T1` and `actor AS T2` instead of querying only `actors` table. Do use `INNER JOIN` on `T1.ActorID = T2.ActorID` instead of no join condition. Do select `T2.Birth City` instead of `birth_city`. Do filter on `T1.Character Name` instead of `character_name` in the WHERE clause. The amended query now correctly retrieves birth city from the actor table by joining through the characters table using the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_city FROM actors WHERE character_name = 'Gabriel Martin'",
            "SELECT T2.\"Birth City\" FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE T1.\"Character Name\" = 'Gabriel Martin'"
        ],
        "rule_sql": []
    },
    "4353": {
        "db_id": "simpson_episodes",
        "question": "What is the episode ID that received 2 stars and 9 votes?",
        "ground_truth": "SELECT episode_id FROM Vote WHERE stars = 2 AND votes = 9;",
        "amends": [
            "Do query from the `Vote` table instead of the `episodes` table. Do keep the same `stars = 2` and `votes = 9` filter conditions instead of changing them. The amended query now correctly retrieves episode IDs from the Vote table with the specified star rating and vote count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id FROM episodes WHERE stars = 2 AND votes = 9;",
            "SELECT episode_id FROM Vote WHERE stars = 2 AND votes = 9;"
        ],
        "rule_sql": []
    },
    "6147": {
        "db_id": "food_inspection_2",
        "question": "What are the names of the businesses that passed with conditions in May 2012?",
        "ground_truth": "SELECT DISTINCT T2.dba_name FROM inspection AS T1 INNER JOIN establishment AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y-%m', T1.inspection_date) = '2012-05' AND T1.results = 'Pass w/ Conditions'",
        "amends": [
            "Do select `DISTINCT T2.dba_name` from the `establishment` table instead of `name` from the `businesses` table. Do join `inspection AS T1` with `establishment AS T2` using `INNER JOIN` on `T1.license_no = T2.license_no` instead of querying a single table. Do use `strftime('%Y-%m', T1.inspection_date) = '2012-05'` for precise date filtering instead of `LIKE '2012-05%'`. Do filter on `T1.results = 'Pass w/ Conditions'` instead of `result = 'Pass'`. The amended query now correctly retrieves distinct business names from the proper table relationships with accurate date formatting and result filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE inspection_date LIKE '2012-05%' AND result = 'Pass';",
            "SELECT DISTINCT T2.dba_name\nFROM inspection AS T1\nINNER JOIN establishment AS T2 ON T1.license_no = T2.license_no\nWHERE strftime('%Y-%m', T1.inspection_date) = '2012-05'\nAND T1.results = 'Pass w/ Conditions'"
        ],
        "rule_sql": []
    },
    "2500": {
        "db_id": "genes",
        "question": "If a pair of genes is positively correlated, what is the possibility of it being composed of two genes both with over 10 chromosomes?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.Chromosome > 10 AND T3.Chromosome > 10, 1, 0)) AS REAL) * 100 / COUNT(T1.GeneID) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 INNER JOIN Genes AS T3 ON T3.GeneID = T2.GeneID2 WHERE T2.Expression_Corr > 0",
        "amends": [
            "Do use `SUM(IIF(T1.Chromosome > 10 AND T3.Chromosome > 10, 1, 0))` with explicit chromosome filtering instead of counting all rows with separate `WHERE` conditions. Do join `Interactions` table as `T2` instead of `gene_pairs` and use `T2.Expression_Corr > 0` instead of `gp.correlation > 0`. Do reference `T2.GeneID1` and `T2.GeneID2` for join conditions instead of `gp.gene1_id` and `gp.gene2_id`. Do calculate percentage with `* 100 / COUNT(T1.GeneID)` instead of division by subquery count. Do use `CAST(... AS REAL)` for proper numeric conversion instead of `* 1.0`. Do remove the redundant subquery counting positive correlations since the main query already filters by `T2.Expression_Corr > 0`. The amended query now correctly calculates the percentage of interactions with both genes on chromosomes greater than 10 among all positive correlation interactions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 1.0 / (SELECT COUNT(*) FROM gene_pairs WHERE correlation > 0) \nFROM gene_pairs gp\nJOIN genes g1 ON gp.gene1_id = g1.gene_id\nJOIN genes g2 ON gp.gene2_id = g2.gene_id\nWHERE gp.correlation > 0 \nAND g1.chromosomes > 10 \nAND g2.chromosomes > 10;",
            "SELECT CAST(SUM(IIF(T1.Chromosome > 10 AND T3.Chromosome > 10, 1, 0)) AS REAL) * 100 / COUNT(*) AS possibility\nFROM Interactions T2\nJOIN Genes T1 ON T2.GeneID1 = T1.GeneID\nJOIN Genes T3 ON T2.GeneID2 = T3.GeneID\nWHERE T2.Expression_Corr > 0"
        ],
        "rule_sql": []
    },
    "2601": {
        "db_id": "regional_sales",
        "question": "Calculate the order percentage by \"Carlos Miller\" sales team.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.`Sales Team` = 'Carlos Miller' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID",
        "amends": [
            "Do use `SUM(CASE WHEN T2.Sales Team = 'Carlos Miller' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific team orders. Do join on `T2.SalesTeamID = T1._SalesTeamID` instead of `o.sales_team_id = s.team_id` with corrected column references. Do reference `Sales Orders` as `T1` and `Sales Team` as `T2` instead of `orders o` and `sales_team s` with proper table aliases. Do use explicit `CAST` to `REAL` instead of implicit `100.0` for percentage calculation precision. Do calculate percentage as `SUM(...) * 100 / COUNT(T1.OrderNumber)` instead of `COUNT(*) * 100.0 / (subquery)` to avoid unnecessary subquery. Do filter within the CASE expression instead of using a WHERE clause to preserve all orders in the denominator count. The amended query now correctly calculates the percentage of orders handled by Carlos Miller's team while maintaining proper join relationships and calculation methodology."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM orders)) AS order_percentage\nFROM orders o\nJOIN sales_team s ON o.sales_team_id = s.team_id\nWHERE s.team_leader = 'Carlos Miller';",
            "SELECT \n    (SUM(CASE WHEN T2.\"Sales Team\" = 'Carlos Miller' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.OrderNumber)) AS OrderPercentage\nFROM \n    \"Sales Orders\" T1\nJOIN \n    \"Sales Team\" T2 ON T2.SalesTeamID = T1._SalesTeamID;"
        ],
        "rule_sql": []
    },
    "5330": {
        "db_id": "beer_factory",
        "question": "How many transactions were made in Sac State Union using the American Express credit card in 2014?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM `transaction` AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.LocationName = 'Sac State Union' AND T1.CreditCardType = 'American Express' AND T1.TransactionDate BETWEEN '2014-01-01' AND '2014-12-31'",
        "amends": [
            "Do reference `transaction` table as `T1` and join with `location` as `T2` instead of querying a single `transactions` table. Do use `T1.LocationID = T2.LocationID` join condition instead of directly filtering on location name. Do select `COUNT(T1.TransactionID)` instead of `COUNT(*)` for more precise counting. Do filter on `T2.LocationName = 'Sac State Union'` instead of `location = 'Sac State Union'` through proper table relationship. Do use `T1.CreditCardType = 'American Express'` instead of `credit_card = 'American Express'` with correct column naming. Do filter with `T1.TransactionDate BETWEEN '2014-01-01' AND '2014-12-31'` for date range instead of `year = 2014` for proper temporal filtering. The amended query now correctly joins tables and uses proper date range filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE location = 'Sac State Union' AND credit_card = 'American Express' AND year = 2014;",
            "SELECT COUNT(T1.TransactionID) \nFROM \"transaction\" AS T1\nJOIN location AS T2 ON T1.LocationID = T2.LocationID\nWHERE T2.LocationName = 'Sac State Union'\nAND T1.CreditCardType = 'American Express'\nAND T1.TransactionDate BETWEEN '2014-01-01' AND '2014-12-31'"
        ],
        "rule_sql": []
    },
    "8302": {
        "db_id": "mondial_geo",
        "question": "Please list the deserts in the countries whose population is over 100000 and covers an area of under 500000.",
        "ground_truth": "SELECT T2.Desert FROM country AS T1 INNER JOIN geo_desert AS T2 ON T1.Code = T2.Country WHERE T1.Area > 100000 AND T1.Population < 500000",
        "amends": [
            "Do select `T2.Desert` from the joined table instead of `desert` from a single table. Do use `INNER JOIN` with `geo_desert AS T2` on `T1.Code = T2.Country` instead of querying only the `countries` table. Do move the area filter to `T1.Area > 100000` instead of `population > 100000` and change the population filter to `T1.Population < 500000` instead of `area < 500000`, correcting both the column references and comparison logic. Do add proper table aliasing with `country AS T1` instead of using the table name directly. The amended query now correctly joins geographic data and fixes the reversed filter conditions to match the intended logic.",
            "Do use `T1.Area > 100000` instead of `T1.Population > 100000` in the WHERE filter, and do use `T1.Population < 500000` instead of `T1.Area < 500000` in the WHERE filter, correcting the swapped column conditions between area and population comparisons. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT desert FROM countries WHERE population > 100000 AND area < 500000;",
            "SELECT T2.Desert \nFROM country AS T1\nINNER JOIN geo_desert AS T2 ON T1.Code = T2.Country\nWHERE T1.Population > 100000 AND T1.Area < 500000",
            "SELECT T2.Desert\nFROM country AS T1\nINNER JOIN geo_desert AS T2 ON T1.Code = T2.Country\nWHERE T1.Area > 100000 AND T1.Population < 500000"
        ],
        "rule_sql": []
    },
    "5003": {
        "db_id": "olympics",
        "question": "Tell the weight of Dagfinn Sverre Aarskog.",
        "ground_truth": "SELECT weight FROM person WHERE full_name = 'Dagfinn Sverre Aarskog'",
        "amends": [
            "Do select `weight` instead of `height` from the result set. Do query from table `person` instead of `people` as the data source. Do filter on column `full_name` instead of `name` for the condition. The amended query now correctly retrieves weight information from the person table using the full name identifier."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT height FROM people WHERE name = 'Dagfinn Sverre Aarskog';",
            "SELECT weight FROM person WHERE full_name = 'Dagfinn Sverre Aarskog';"
        ],
        "rule_sql": []
    },
    "2493": {
        "db_id": "genes",
        "question": "Among the pairs of genes that are both located in the nucleus, what is the highest expression correlation score?",
        "ground_truth": "SELECT T2.Expression_Corr FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 INNER JOIN Genes AS T3 ON T3.GeneID = T2.GeneID2 WHERE T1.Localization = 'nucleus' AND T3.Localization = 'nucleus' ORDER BY T2.Expression_Corr DESC LIMIT 1",
        "amends": [
            "Do select `T2.Expression_Corr` instead of `MAX(correlation_score)`. Do join `Genes AS T1` and `Interactions AS T2` on `T1.GeneID = T2.GeneID1` instead of querying only `gene_expression`. Do add a second join to `Genes AS T3` on `T3.GeneID = T2.GeneID2` instead of omitting it. Do filter with `T1.Localization = 'nucleus' AND T3.Localization = 'nucleus'` instead of only `location = 'nucleus'`. Do add `ORDER BY T2.Expression_Corr DESC LIMIT 1` instead of using an aggregate function without ordering. The amended query now correctly retrieves the maximum correlation score between nuclear-localized genes through proper table joins and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(correlation_score) FROM gene_expression WHERE location = 'nucleus';",
            "SELECT T2.Expression_Corr\nFROM Interactions AS T2\nJOIN Genes AS T1 ON T1.GeneID = T2.GeneID1\nJOIN Genes AS T3 ON T3.GeneID = T2.GeneID2\nWHERE T1.Localization = 'nucleus' AND T3.Localization = 'nucleus'\nORDER BY T2.Expression_Corr DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6239": {
        "db_id": "food_inspection_2",
        "question": "Provide the salary range of the employee involved in the inspection ID 58424.",
        "ground_truth": "SELECT T1.salary, T3.salary FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN employee AS T3 WHERE T2.inspection_id = 58424 ORDER BY T1.salary, T3.salary DESC LIMIT 1",
        "amends": [
            "Do select individual salary columns `T1.salary` and `T3.salary` instead of aggregate functions `MIN(salary)` and `MAX(salary)`. Do add table `inspection AS T2` with an `INNER JOIN` on `T1.employee_id = T2.employee_id` instead of omitting it. Do add a second `employee` table as `T3` without a join condition instead of having only one employee table. Do move the filter to `T2.inspection_id = 58424` instead of `employees.inspection_id = 58424`. Do add `ORDER BY T1.salary, T3.salary DESC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting limit. The amended query now correctly retrieves salary pairs from joined employee and inspection tables with proper ordering and limiting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(salary) AS min_salary, MAX(salary) AS max_salary FROM employees WHERE inspection_id = 58424",
            "SELECT T1.salary, T3.salary\nFROM employee AS T1\nINNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nCROSS JOIN employee AS T3\nWHERE T2.inspection_id = 58424\nORDER BY T1.salary, T3.salary DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3847": {
        "db_id": "public_review_platform",
        "question": "How many reviews made by user whose ID is 3 are long?",
        "ground_truth": "SELECT COUNT(review_length) FROM Reviews WHERE user_id = 3 AND review_length LIKE 'Long'",
        "amends": [
            "Do count `review_length` instead of `*` to count non-null values specifically. Do reference table `Reviews` instead of `reviews` with proper case sensitivity. Do filter with `review_length LIKE 'Long'` instead of `length > 1000` to match categorical values rather than numeric comparison. Do use column `review_length` instead of `length` as the correct column name for the review length attribute. The amended query now correctly counts long reviews for user_id 3 using the appropriate categorical filter and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE user_id = 3 AND length > 1000;",
            "SELECT COUNT(review_length) FROM Reviews WHERE user_id = 3 AND review_length LIKE 'Long';"
        ],
        "rule_sql": []
    },
    "5893": {
        "db_id": "airline",
        "question": "How many flights of air carrier called JetBlue Airways: B6 have 0 new arrival delay?",
        "ground_truth": "SELECT COUNT(*) FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description LIKE '%JetBlue Airways: B6%' AND T2.ARR_DELAY_NEW = 0",
        "amends": [
            "Do join `Air Carriers` as `T1` with `Airlines` as `T2` on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of querying only the `flights` table. Do filter on `T1.Description LIKE '%JetBlue Airways: B6%'` instead of directly comparing `carrier = 'JetBlue Airways: B6'`. Do filter on `T2.ARR_DELAY_NEW = 0` instead of `arr_delay = 0`. The amended query now correctly joins the carrier and airline tables to match the carrier description pattern and delay condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE carrier = 'JetBlue Airways: B6' AND arr_delay = 0",
            "SELECT COUNT(*) \nFROM \"Air Carriers\" AS T1 \nJOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID \nWHERE T1.Description LIKE '%JetBlue Airways: B6%' \nAND T2.ARR_DELAY_NEW = 0"
        ],
        "rule_sql": []
    },
    "2030": {
        "db_id": "soccer_2016",
        "question": "Count the matches that were won by wickets in all season.",
        "ground_truth": "SELECT COUNT(T1.Match_Id) FROM Match AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id WHERE T2.Win_type = 'wickets'",
        "amends": [
            "Do select `COUNT(T1.Match_Id)` instead of `COUNT(*)` to count specific non-null values. Do use `FROM Match AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id` instead of `FROM matches` to properly join the two tables with the correct relationship. Do apply filter `WHERE T2.Win_type = 'wickets'` instead of `WHERE win_by_wickets > 0 AND season = 'all'` to correctly identify wicket-based wins through the joined table rather than using a numeric comparison and irrelevant season filter. The amended query now correctly counts matches won by wickets using the proper table relationships and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE win_by_wickets > 0 AND season = 'all'",
            "SELECT COUNT(T1.Match_Id) FROM Match AS T1 INNER JOIN Win_By AS T2 ON T1.Win_Type = T2.Win_Id WHERE T2.Win_Type = 'wickets'"
        ],
        "rule_sql": []
    },
    "2083": {
        "db_id": "music_tracker",
        "question": "How many christmas albums were released in 2004?",
        "ground_truth": "SELECT COUNT(T1.id) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'christmas' AND T1.groupYear = 2004 AND T1.releaseType LIKE 'album'",
        "amends": [
            "Do select `COUNT(T1.id)` from the `torrents` table instead of `COUNT(*)` from the `albums` table. Do use `INNER JOIN` with `tags` table on `T1.id = T2.id` instead of querying a single table. Do filter on `T2.tag = 'christmas'` instead of `title LIKE '%Christmas%'`. Do filter on `T1.groupYear = 2004` instead of `year = 2004`. Do add the condition `T1.releaseType LIKE 'album'` instead of omitting it. The amended query now correctly counts Christmas album torrents from 2004 by joining torrent and tag tables with proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM albums WHERE title LIKE '%Christmas%' AND year = 2004;",
            "SELECT COUNT(T1.id) \nFROM torrents T1\nINNER JOIN tags T2 ON T1.id = T2.id\nWHERE T2.tag = 'christmas'\nAND T1.groupYear = 2004\nAND T1.releaseType LIKE 'album'"
        ],
        "rule_sql": []
    },
    "2158": {
        "db_id": "world_development_indicators",
        "question": "List out the table name and currency unit of countries using series code as FP.CPI.TOTL",
        "ground_truth": "SELECT T1.TableName, T1.CurrencyUnit FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.SeriesCode = 'FP.CPI.TOTL'",
        "amends": [
            "Do add `INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode` instead of querying only the `countries` table. Do change the table reference to `Country AS T1` instead of `countries` and use aliased column references `T1.TableName` and `T1.CurrencyUnit` instead of direct `table_name` and `currency_unit`. Do move the filter condition to `T2.SeriesCode = 'FP.CPI.TOTL'` instead of applying it to the original table's `series_code`. The amended query now correctly joins the Country and CountryNotes tables to filter based on the SeriesCode in the related table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT table_name, currency_unit FROM countries WHERE series_code = 'FP.CPI.TOTL';",
            "SELECT T1.TableName, T1.CurrencyUnit \nFROM Country AS T1 \nINNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode \nWHERE T2.SeriesCode = 'FP.CPI.TOTL'"
        ],
        "rule_sql": []
    },
    "2869": {
        "db_id": "professional_basketball",
        "question": "What is the average height of an East conference All-star player?",
        "ground_truth": "SELECT AVG(DISTINCT height) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE conference = 'East'",
        "amends": [
            "Do add `DISTINCT` to the `AVG` function instead of calculating the average of all values. Do add `INNER JOIN` with `player_allstar AS T2` on `T1.playerID = T2.playerID` instead of filtering by `all_star = 1` in the WHERE clause. Do add table alias `AS T1` for the players table instead of using it without an alias. Do remove the `all_star = 1` filter from the WHERE clause instead of keeping it, as the join condition now properly handles the all-star relationship. The amended query now correctly calculates the average height of distinct players who are all-stars in the East conference, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(height) FROM players WHERE conference = 'East' AND all_star = 1;",
            "SELECT AVG(DISTINCT T1.height) \nFROM players AS T1 \nINNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID \nWHERE T2.conference = 'East';"
        ],
        "rule_sql": []
    },
    "7343": {
        "db_id": "works_cycles",
        "question": "What is the difference between the actual manufacturing cost of product number 818 and the estimated manufacturing cost?",
        "ground_truth": "SELECT PlannedCost - ActualCost FROM WorkOrderRouting WHERE ProductID = 818",
        "amends": [
            "Do reference `PlannedCost` and `ActualCost` columns instead of `actual_cost` and `estimated_cost`. Do query the `WorkOrderRouting` table instead of the `products` table. Do filter on `ProductID` instead of `product_id`. The amended query now correctly calculates cost variance from the appropriate table with the correct column names and filtering criteria.",
            "Do select `PlannedCost - ActualCost` without an alias instead of `(ActualCost - PlannedCost) AS CostVariance` to correct the subtraction order and remove unnecessary aliasing. Do remove the `JOIN Product` clause and instead filter directly on `ProductID = 818` instead of joining and filtering by `ProductNumber = '818'` to eliminate the unnecessary table join and use the correct numeric comparison. Do remove the explicit join condition since the join itself is eliminated. The amended query now correctly calculates cost variance with proper operand order and uses direct filtering without unnecessary table joins, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actual_cost - estimated_cost FROM products WHERE product_id = 818;",
            "SELECT \n    (ActualCost - PlannedCost) AS CostVariance\nFROM \n    WorkOrderRouting\nJOIN \n    Product ON WorkOrderRouting.ProductID = Product.ProductID\nWHERE \n    Product.ProductNumber = '818';",
            "SELECT PlannedCost - ActualCost FROM WorkOrderRouting WHERE ProductID = 818"
        ],
        "rule_sql": []
    },
    "8528": {
        "db_id": "software_company",
        "question": "What is the average education level of customers from the place with the highest average income per month?",
        "ground_truth": "SELECT AVG(T1.EDUCATIONNUM) FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID ORDER BY T2.INCOME_K DESC LIMIT 1",
        "amends": [
            "Do use `AVG(T1.EDUCATIONNUM)` instead of `AVG(education_level)` and add `INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID` instead of the subquery approach. Do remove the `WHERE` clause entirely instead of using a correlated subquery with `place` filtering. Do add `ORDER BY T2.INCOME_K DESC LIMIT 1` instead of ordering within a subquery and limiting to one result. The amended query now correctly joins the Customers and Demog tables on GEOID and orders by income to find the top result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(education_level) \nFROM customers \nWHERE place = (SELECT place FROM customers GROUP BY place ORDER BY AVG(income_per_month) DESC LIMIT 1);",
            "SELECT AVG(T1.EDUCATIONNUM) \nFROM Customers AS T1 \nINNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID \nORDER BY T2.INCOME_K DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2234": {
        "db_id": "world_development_indicators",
        "question": "What's the long name of the country that got 3000000 on the indicator Arms exports in 1960?",
        "ground_truth": "SELECT T1.LongName FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.IndicatorName = 'Arms exports (SIPRI trend indicator values)' AND T2.Year = 1960 AND T2.Value = 3000000",
        "amends": [
            "Do join `Country AS T1` with `Indicators AS T2` on `T1.CountryCode = T2.CountryCode` instead of querying only `countries` table. Do reference `T2.IndicatorName` with value `'Arms exports (SIPRI trend indicator values)'` instead of `indicator = 'Arms exports'`. Do select `T1.LongName` instead of `long_name` from the joined tables. Do filter on `T2.Year` and `T2.Value` instead of `year` and `value` from the base table. The amended query now correctly joins the Country and Indicators tables to match the specified indicator name format and retrieve the appropriate long name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT long_name FROM countries WHERE indicator = 'Arms exports' AND year = 1960 AND value = 3000000;",
            "SELECT T1.LongName \nFROM Country AS T1 \nJOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.IndicatorName = 'Arms exports (SIPRI trend indicator values)' \nAND T2.Year = 1960 \nAND T2.Value = 3000000"
        ],
        "rule_sql": []
    },
    "447": {
        "db_id": "movies_4",
        "question": "Which production company produced the movie that made the most money at the box office?",
        "ground_truth": "SELECT T1.company_name FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id GROUP BY T1.company_id ORDER BY SUM(T3.revenue) DESC LIMIT 1",
        "amends": [
            "Do select `T1.company_name` from the `production_company` table instead of `production_company` directly. Do add `INNER JOIN` with `movie_company` on `T1.company_id = T2.company_id` instead of omitting this table relationship. Do add another `INNER JOIN` with `movie` on `T2.movie_id = T3.movie_id` instead of missing this connection to revenue data. Do use `GROUP BY T1.company_id` instead of no grouping. Do order by `SUM(T3.revenue)` instead of `box_office` to properly aggregate financial results. The amended query now correctly identifies the production company with the highest total revenue across all movies rather than relying on a single box office value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT production_company FROM movies ORDER BY box_office DESC LIMIT 1;",
            "SELECT T1.company_name \nFROM production_company T1\nINNER JOIN movie_company T2 ON T1.company_id = T2.company_id\nINNER JOIN movie T3 ON T2.movie_id = T3.movie_id\nGROUP BY T1.company_id\nORDER BY SUM(T3.revenue) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2521": {
        "db_id": "app_store",
        "question": "Name the top 10 most reviewed apps.",
        "ground_truth": "SELECT DISTINCT App FROM playstore ORDER BY Reviews DESC LIMIT 10",
        "amends": [
            "Do select `App` instead of `name` and use `DISTINCT` instead of omitting it. Do source from `playstore` instead of `apps`. Do order by `Reviews` instead of `reviews`. The amended query now correctly selects distinct app names from the playstore table ordered by review count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM apps ORDER BY reviews DESC LIMIT 10;",
            "SELECT DISTINCT App FROM playstore ORDER BY Reviews DESC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "8934": {
        "db_id": "human_resources",
        "question": "What is the required education for the position of regional manager?",
        "ground_truth": "SELECT educationrequired FROM position WHERE positiontitle = 'Regional Manager'",
        "amends": [
            "Do select `educationrequired` instead of `education` to reference the correct column name. Do query from `position` instead of `positions` to reference the correct table name. Do filter on `positiontitle = 'Regional Manager'` instead of `title = 'regional manager'` to use the correct column name and case-sensitive value matching. The amended query now correctly retrieves education requirements from the position table for regional manager positions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT education FROM positions WHERE title = 'regional manager';",
            "SELECT educationrequired FROM position WHERE positiontitle = 'Regional Manager';"
        ],
        "rule_sql": []
    },
    "4743": {
        "db_id": "legislator",
        "question": "How many current legislators do not have an account on instagram?",
        "ground_truth": "SELECT COUNT(*) FROM `social-media` AS T1 INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE T1.instagram IS NULL",
        "amends": [
            "Do join `social-media` as `T1` with `current` as `T2` on `T1.bioguide = T2.bioguide_id` instead of querying only the `legislators` table. Do filter on `T1.instagram IS NULL` instead of `instagram IS NULL` to reference the correct table after the join. The amended query now correctly counts legislators with null Instagram values by properly joining the social media and current legislator tables using the bioguide identifier, matching the RIGHT_SQL's behavior.",
            "Do use `INNER JOIN` between `social-media` and `current` tables instead of `LEFT JOIN` to properly count only matching records. Do maintain the join condition `T1.bioguide = T2.bioguide_id` but reverse the table order in the FROM clause to start with `social-media` instead of `current`. Do keep the filter `T1.instagram IS NULL` in the WHERE clause to count only records with null Instagram values. The amended query now correctly performs an inner join to count matching records between the two tables where Instagram is null, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE instagram IS NULL;",
            "SELECT COUNT(*) \nFROM current AS T2\nLEFT JOIN \"social-media\" AS T1 ON T1.bioguide = T2.bioguide_id\nWHERE T1.instagram IS NULL",
            "SELECT COUNT(*) \nFROM \"social-media\" AS T1 \nINNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id \nWHERE T1.instagram IS NULL"
        ],
        "rule_sql": []
    },
    "740": {
        "db_id": "movie",
        "question": "Among the actors who starred in the movie Batman, which one of them is the tallest?",
        "ground_truth": "SELECT T3.Name FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T1.Title = 'Batman' ORDER BY T3.`Height (Inches)` DESC LIMIT 1",
        "amends": [
            "Do select `T3.Name` instead of `a.name, a.height`. Do use `INNER JOIN` with `characters` table instead of joining directly to `movie_actors`. Do join `movie` to `characters` on `T1.MovieID = T2.MovieID` instead of joining `actors` to `movie_actors` on `a.id = ma.actor_id`. Do join `actor` to `characters` on `T3.ActorID = T2.ActorID` instead of joining `movies` to `movie_actors` on `m.id = ma.movie_id`. Do order by `T3.Height (Inches)` in `DESC` order instead of `a.height` in `ASC` order. The amended query now correctly follows the proper table relationships through the characters table and returns the tallest actor instead of the shortest."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.name, a.height FROM actors a JOIN movie_actors ma ON a.id = ma.actor_id JOIN movies m ON m.id = ma.movie_id WHERE m.title = 'Batman' ORDER BY a.height ASC LIMIT 1;",
            "SELECT T3.Name\nFROM movie T1\nINNER JOIN characters T2 ON T1.MovieID = T2.MovieID\nINNER JOIN actor T3 ON T3.ActorID = T2.ActorID\nWHERE T1.Title = 'Batman'\nORDER BY T3.\"Height (Inches)\" DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1260": {
        "db_id": "law_episode",
        "question": "How many nominations did Law and Order season 9, episode 20 get?",
        "ground_truth": "SELECT COUNT(T2.award_id) FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T2.series = 'Law and Order' AND T1.season = 9 AND T1.episode = 20",
        "amends": [
            "Do join `Episode AS T1` and `Award AS T2` with `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying only the `nominations` table. Do count `T2.award_id` instead of `COUNT(*)` to count actual awards. Do filter by `T2.series = 'Law and Order'` instead of `show_title = 'Law and Order'` to use the correct column name and table. Do filter season and episode through `T1.season = 9` and `T1.episode = 20` instead of filtering them directly in the nominations table, ensuring proper table relationships. The amended query now correctly counts awards for the specific episode by properly joining the Episode and Award tables with the correct filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM nominations WHERE show_title = 'Law and Order' AND season = 9 AND episode = 20;",
            "SELECT COUNT(T2.award_id) \nFROM Episode AS T1 \nINNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id \nWHERE T2.series = 'Law and Order' \nAND T1.season = 9 \nAND T1.episode = 20"
        ],
        "rule_sql": []
    },
    "8263": {
        "db_id": "mondial_geo",
        "question": "What is the highest infant mortality rate per thousand of the countries whose inflation is under 3?",
        "ground_truth": "SELECT MAX(T2.Infant_Mortality) FROM economy AS T1 INNER JOIN population AS T2 ON T1.Country = T2.Country WHERE T1.Inflation < 3",
        "amends": [
            "Do reference `T2.Infant_Mortality` from the `population` table instead of `infant_mortality` from an unspecified source. Do join `economy AS T1` and `population AS T2` with `INNER JOIN` on `T1.Country = T2.Country` instead of querying a single `countries` table. Do filter with `T1.Inflation < 3` instead of `inflation > 3`, changing both the table reference and inequality direction. The amended query now correctly aggregates maximum infant mortality from joined economic and population data for countries with low inflation, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(infant_mortality) FROM countries WHERE inflation > 3;",
            "SELECT MAX(T2.Infant_Mortality) AS highest_infant_mortality\nFROM economy AS T1\nINNER JOIN population AS T2 ON T1.Country = T2.Country\nWHERE T1.Inflation < 3;"
        ],
        "rule_sql": []
    },
    "5775": {
        "db_id": "language_corpus",
        "question": "Which of these pages have more words, the page titled \"Afluent\" or \"Asclepi\"?",
        "ground_truth": "SELECT CASE WHEN ( SELECT words FROM pages WHERE title = 'Asclepi' ) > ( SELECT words FROM pages WHERE title = 'Afluent' ) THEN 'Asclepi' ELSE 'Afluent' END",
        "amends": [
            "Do use a `CASE` expression with two scalar subqueries comparing `words` values instead of selecting `title` and `word_count` columns. Do remove the `WHERE title IN` filter and `ORDER BY word_count DESC LIMIT 1` clause instead of keeping them, as the logic now directly compares the two specific title values. Do change from returning both title and word_count to returning only the title with the higher word count instead of the maximum word_count record. The amended query now correctly identifies which of the two specified titles has the greater word count value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, word_count FROM pages WHERE title IN ('Afluent', 'Asclepi') ORDER BY word_count DESC LIMIT 1;",
            "SELECT CASE \n    WHEN (SELECT words FROM pages WHERE title = 'Afluent') > (SELECT words FROM pages WHERE title = 'Asclepi') \n    THEN 'Afluent' \n    ELSE 'Asclepi' \nEND AS title_with_more_words;"
        ],
        "rule_sql": []
    },
    "2690": {
        "db_id": "regional_sales",
        "question": "What type of store is most popular in the South?",
        "ground_truth": "SELECT DISTINCT CASE WHEN MAX(T2.Population) THEN T2.Type END FROM Regions AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StateCode = T1.StateCode",
        "amends": [
            "Do use `DISTINCT CASE WHEN MAX(T2.Population) THEN T2.Type END` instead of `store_type, COUNT(*) as count` for the SELECT list. Do change FROM clause to `Regions AS T1 INNER JOIN Store Locations AS T2` instead of `stores` with a single table. Do add join condition `ON T2.StateCode = T1.StateCode` instead of the missing join predicate. Do remove `WHERE region = 'South'` filter instead of keeping it. Do remove `GROUP BY store_type` instead of including it. Do remove `ORDER BY count DESC LIMIT 1` instead of keeping the ordering and limiting. The amended query now correctly joins regions with store locations and returns distinct store types based on maximum population criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_type, COUNT(*) as count FROM stores WHERE region = 'South' GROUP BY store_type ORDER BY count DESC LIMIT 1;",
            "SELECT DISTINCT CASE WHEN MAX(T2.Population) THEN T2.Type END FROM Regions AS T1 INNER JOIN \"Store Locations\" AS T2 ON T2.StateCode = T1.StateCode"
        ],
        "rule_sql": []
    },
    "1609": {
        "db_id": "car_retails",
        "question": "How many kinds of products did order No. 10252 contain?",
        "ground_truth": "SELECT COUNT(t.productCode) FROM orderdetails t WHERE t.orderNumber = '10252'",
        "amends": [
            "Do reference the `orderdetails` table instead of `products` and use `t.orderNumber = '10252'` instead of `order_id = 10252` for the filter condition. Do count `t.productCode` instead of using `COUNT(*)` to ensure accurate counting of products. Do add the table alias `t` for clarity instead of omitting it. The amended query now correctly counts products in the orderdetails table for order number 10252, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE order_id = 10252;",
            "SELECT COUNT(DISTINCT t.productCode) FROM orderdetails t WHERE t.orderNumber = '10252';"
        ],
        "rule_sql": []
    },
    "776": {
        "db_id": "social_media",
        "question": "How many tweets are in English?",
        "ground_truth": "SELECT COUNT(TweetID) AS tweet_number FROM twitter WHERE Lang = 'en'",
        "amends": [
            "Do count `TweetID` instead of `*` and alias it as `tweet_number` instead of omitting an alias. Do reference table `twitter` instead of `tweets` and filter on `Lang = 'en'` instead of `language = 'English'`. The amended query now correctly counts English tweets from the twitter table using the appropriate column names and language code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE language = 'English';",
            "SELECT COUNT(TweetID) AS tweet_number FROM twitter WHERE Lang = 'en'"
        ],
        "rule_sql": []
    },
    "9348": {
        "db_id": "movie_3",
        "question": "List down all film IDs of comedy film titles.",
        "ground_truth": "SELECT T1.film_id FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE T3.name = 'comedy'",
        "amends": [
            "Do use explicit table aliases `T1.film_id` instead of bare `film_id`. Do add joins to `film_category AS T2` and `category AS T3` instead of querying only the `films` table. Do use `INNER JOIN` with proper join conditions `ON T1.film_id = T2.film_id` and `ON T3.category_id = T2.category_id` instead of no joins. Do filter on `T3.name = 'comedy'` instead of `genre = 'comedy'` to correctly reference the category table. The amended query now properly joins through the category relationship to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT film_id FROM films WHERE genre = 'comedy';",
            "SELECT T1.film_id\nFROM film AS T1\nINNER JOIN film_category AS T2 ON T1.film_id = T2.film_id\nINNER JOIN category AS T3 ON T3.category_id = T2.category_id\nWHERE T3.name = 'comedy'"
        ],
        "rule_sql": []
    },
    "5659": {
        "db_id": "shipping",
        "question": "In which city did the heaviest shipment transported?",
        "ground_truth": "SELECT T2.city_name FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id ORDER BY T1.weight DESC LIMIT 1",
        "amends": [
            "Do select `T2.city_name` from the city table instead of `city` from the shipments table. Do use `INNER JOIN` on `T1.city_id = T2.city_id` to properly relate shipment and city tables instead of querying shipments alone. Do order by `T1.weight DESC` instead of `weight ASC` to get the heaviest shipment. The amended query now correctly joins tables and returns the city name for the shipment with maximum weight, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM shipments ORDER BY weight ASC LIMIT 1;",
            "SELECT T2.city_name \nFROM shipment T1 \nINNER JOIN city T2 ON T1.city_id = T2.city_id \nORDER BY T1.weight DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5420": {
        "db_id": "sales",
        "question": "List the full names of customers who have purchased products in quantity over 600.",
        "ground_truth": "SELECT T1.FirstName, T1.LastName FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Quantity > 600",
        "amends": [
            "Do add `INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do reference `T2.Quantity` in the `WHERE` clause instead of the ambiguous `quantity` column. Do use table aliases `T1.FirstName` and `T1.LastName` instead of unqualified `first_name` and `last_name`. Do specify the correct table name `Customers` instead of `customers`. The amended query now correctly joins customer and sales data to filter based on sales quantity, matching the intended behavior.",
            "Do remove `T1.MiddleInitial` from the SELECT list instead of including it. Do remove the space after `600` in the WHERE clause instead of keeping it, though this is a cosmetic formatting difference. The amended query now correctly returns only first and last names for customers with sales quantities exceeding 600, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE quantity > 600",
            "SELECT T1.FirstName, T1.MiddleInitial, T1.LastName\nFROM Customers AS T1\nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Quantity > 600",
            "SELECT T1.FirstName, T1.LastName\nFROM Customers AS T1\nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Quantity > 600"
        ],
        "rule_sql": []
    },
    "9151": {
        "db_id": "movie_3",
        "question": "Give the detailed address for store No.2.",
        "ground_truth": "SELECT T1.address, T1.address2, T1.district FROM address AS T1 INNER JOIN store AS T2 ON T1.address_id = T2.address_id WHERE T2.store_id = 2",
        "amends": [
            "Do select specific columns `address`, `address2`, and `district` from table `address` instead of selecting all columns `*` from table `stores`. Do join table `store` with `INNER JOIN` on predicate `address_id = address_id` instead of querying a single table `stores`. Do filter on `store_id = 2` from the joined `store` table instead of filtering on `store_id = 2` from the original `stores` table. The amended query now correctly retrieves address information for a specific store by properly joining the address and store tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM stores WHERE store_id = 2;",
            "SELECT a.address, a.address2, a.district FROM store s INNER JOIN address a ON s.address_id = a.address_id WHERE s.store_id = 2"
        ],
        "rule_sql": []
    },
    "8173": {
        "db_id": "sales_in_weather",
        "question": "How many inches of total precipitation was recorded by the weather station of store no.2 on 2012/12/25?",
        "ground_truth": "SELECT T1.preciptotal FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T1.`date` = '2012-12-25' AND T2.store_nbr = 2",
        "amends": [
            "Do select `T1.preciptotal` instead of `SUM(precipitation)` and remove the aggregation. Do join `weather AS T1` with `relation AS T2` instead of querying only the `weather` table. Do use `INNER JOIN` on `T1.station_nbr = T2.station_nbr` instead of filtering directly by `store_id`. Do filter with `T2.store_nbr = 2` instead of `store_id = 2` and maintain `T1.date = '2012-12-25'` instead of `date = '2012-12-25'`. The amended query now correctly joins through the relation table to filter by store number and retrieves the precise precipitation value instead of an incorrect sum aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(precipitation) FROM weather WHERE store_id = 2 AND date = '2012-12-25';",
            "SELECT T1.preciptotal \nFROM weather AS T1 \nINNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr \nWHERE T2.store_nbr = 2 AND T1.date = '2012-12-25'"
        ],
        "rule_sql": []
    },
    "9334": {
        "db_id": "movie_3",
        "question": "List the descriptions of movies under the category Travel.",
        "ground_truth": "SELECT T1.description FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.`name` = 'Travel'",
        "amends": [
            "Do specify the table alias `T1` for the `description` column instead of omitting it. Do join `film AS T1` instead of querying a non-existent `movies` table. Do add `INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id` instead of omitting this necessary join. Do add `INNER JOIN category AS T3 ON T2.category_id = T3.category_id` instead of omitting this required relationship. Do filter on `T3.name = 'Travel'` instead of using a non-existent `category` column. The amended query now correctly joins the three tables and filters by category name to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM movies WHERE category = 'Travel';",
            "SELECT T1.description \nFROM film AS T1\nINNER JOIN film_category AS T2 ON T1.film_id = T2.film_id\nINNER JOIN category AS T3 ON T2.category_id = T3.category_id\nWHERE T3.name = 'Travel'"
        ],
        "rule_sql": []
    },
    "5790": {
        "db_id": "language_corpus",
        "question": "Which word has the most repetitions in the Catalan language? Give the ID of the word.",
        "ground_truth": "SELECT wid FROM langs_words WHERE occurrences = ( SELECT MAX(occurrences) FROM langs_words )",
        "amends": [
            "Do select `wid` from `langs_words` instead of `word_id` from `words`. Do use a subquery to find `MAX(occurrences)` instead of calculating string length differences with `LENGTH(word) - LENGTH(REPLACE(word, word, ''))`. Do filter by comparing `occurrences` to the maximum value instead of filtering by `language = 'Catalan'`. Do remove the `ORDER BY` and `LIMIT 1` clauses instead of keeping them, as the subquery approach directly identifies the maximum occurrence record. The amended query now correctly identifies the word with maximum occurrences rather than attempting to find words based on string manipulation logic.",
            "Do remove the `lid = (SELECT lid FROM langs WHERE lang = 'Catalan')` filter from both the main WHERE clause and the subquery instead of including it, as the maximum occurrences should be calculated across all languages rather than being restricted to Catalan. Do simplify the query by eliminating the unnecessary join to the langs table and the correlated subquery for language filtering instead of maintaining complex nested subqueries. The amended query now correctly identifies the word with maximum occurrences globally rather than within a specific language, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id FROM words WHERE language = 'Catalan' ORDER BY LENGTH(word) - LENGTH(REPLACE(word, word, '')) DESC LIMIT 1;",
            "SELECT wid FROM langs_words WHERE lid = (SELECT lid FROM langs WHERE lang = 'Catalan') AND occurrences = (SELECT MAX(occurrences) FROM langs_words WHERE lid = (SELECT lid FROM langs WHERE lang = 'Catalan'))",
            "SELECT wid FROM langs_words WHERE occurrences = (SELECT MAX(occurrences) FROM langs_words)"
        ],
        "rule_sql": []
    },
    "6704": {
        "db_id": "retails",
        "question": "What is the name of the customer with the highest amount of debt?",
        "ground_truth": "SELECT c_name FROM customer WHERE c_acctbal = ( SELECT MIN(c_acctbal) FROM customer )",
        "amends": [
            "Do select `c_name` instead of `name` and do move from `FROM customers` to `FROM customer` instead of keeping the original table reference. Do add a WHERE filter comparing `c_acctbal` to a subquery result instead of omitting filtering entirely. Do remove the `ORDER BY debt DESC LIMIT 1` clause instead of keeping it, and do replace with a correlated subquery that finds the minimum account balance. Do change from finding maximum debt to finding minimum account balance through proper aggregation instead of simple ordering. The amended query now correctly identifies customers with the minimum account balance rather than those with the highest debt."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers ORDER BY debt DESC LIMIT 1;",
            "SELECT c_name FROM customer WHERE c_acctbal = (SELECT MIN(c_acctbal) FROM customer);"
        ],
        "rule_sql": []
    },
    "2939": {
        "db_id": "professional_basketball",
        "question": "In the year 1998, how many home wins did the team which had the 1st round, 12th pick have that year?",
        "ground_truth": "SELECT T2.homeWon FROM draft AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.draftYear = T2.year WHERE T1.draftRound = 1 AND T1.draftSelection = 12 AND T1.draftYear = 1998",
        "amends": [
            "Do select `T2.homeWon` instead of `COUNT(*)`. Do join `draft AS T1` and `teams AS T2` with `INNER JOIN` on `T1.tmID = T2.tmID AND T1.draftYear = T2.year` instead of using a subquery to get the team from `draft` table. Do filter with `T1.draftRound = 1 AND T1.draftSelection = 12 AND T1.draftYear = 1998` instead of `round = 1 AND pick = 12 AND year = 1998` and remove the `home_score > away_score` condition entirely. Do remove the `games` table and `WHERE year = 1998` filter instead of keeping them. The amended query now correctly retrieves the homeWon value from the teams table for the specified draft selection rather than counting games won by that team."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM games \nWHERE year = 1998 \nAND home_team = (SELECT team FROM draft WHERE round = 1 AND pick = 12 AND year = 1998) \nAND home_score > away_score;",
            "SELECT T2.homeWon \nFROM draft AS T1\nINNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.draftYear = T2.year\nWHERE T1.draftRound = 1 AND T1.draftSelection = 12 AND T1.draftYear = 1998"
        ],
        "rule_sql": []
    },
    "2095": {
        "db_id": "world_development_indicators",
        "question": "Please list the descriptions of the series code SM.POP.TOTL for all the countries that are under the lending category of the International Development Associations.",
        "ground_truth": "SELECT T2.Description FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.LendingCategory = 'IDA' AND T2.Seriescode = 'SM.POP.TOTL'",
        "amends": [
            "Do select `T2.Description` from `Country AS T1` instead of `description` from `series`. Do use `INNER JOIN` on `CountryNotes AS T2` with `T1.CountryCode = T2.Countrycode` instead of querying a single table. Do filter with `T1.LendingCategory = 'IDA'` instead of `lending_category = 'International Development Associations'` and maintain `T2.Seriescode = 'SM.POP.TOTL'` instead of `series_code = 'SM.POP.TOTL'`. The amended query now correctly joins the Country and CountryNotes tables to retrieve descriptions based on lending category and series code, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM series WHERE series_code = 'SM.POP.TOTL' AND lending_category = 'International Development Associations';",
            "SELECT T2.Description \nFROM Country AS T1 \nINNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode \nWHERE T1.LendingCategory = 'IDA' \nAND T2.Seriescode = 'SM.POP.TOTL'"
        ],
        "rule_sql": []
    },
    "2517": {
        "db_id": "app_store",
        "question": "What is the lowest sentiment polarity score of the Basketball Stars app for people who dislikes the app pretty much and how many downloads does it have?",
        "ground_truth": "SELECT MIN(T2.Sentiment_Polarity), T1.Installs FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = 'Basketball Stars'",
        "amends": [
            "Do select `MIN(T2.Sentiment_Polarity)` and `T1.Installs` instead of `MIN(sentiment_polarity)` AS `lowest_polarity` and `downloads`. Do use `FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App` instead of `FROM app_reviews` with no join. Do apply filter `WHERE T1.App = 'Basketball Stars'` instead of `WHERE app_name = 'Basketball Stars'`. Do remove `sentiment_polarity < 0` filter instead of keeping it. Do remove `GROUP BY downloads` and `ORDER BY downloads DESC LIMIT 1` instead of including them. The amended query now correctly joins the playstore and user_reviews tables to find the minimum sentiment polarity for the specified app without unnecessary filtering or grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(sentiment_polarity) AS lowest_polarity, downloads \nFROM app_reviews \nWHERE app_name = 'Basketball Stars' \nAND sentiment_polarity < 0 \nGROUP BY downloads \nORDER BY downloads DESC \nLIMIT 1;",
            "SELECT MIN(T2.Sentiment_Polarity) AS lowest_polarity, T1.Installs\nFROM playstore AS T1 \nINNER JOIN user_reviews AS T2 ON T1.App = T2.App\nWHERE T1.App = 'Basketball Stars';"
        ],
        "rule_sql": []
    },
    "2042": {
        "db_id": "soccer_2016",
        "question": "List the player's name who played as a captain.",
        "ground_truth": "SELECT T2.Player_Name FROM Player_Match AS T1 INNER JOIN Player AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id WHERE T3.Role_Desc = 'Captain' GROUP BY T2.Player_Name",
        "amends": [
            "Do select `T2.Player_Name` from `Player_Match AS T1` instead of `name` from `players`. Do add `INNER JOIN Player AS T2 ON T1.Player_Id = T2.Player_Id` and `INNER JOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id` instead of omitting these table joins. Do change the filter to `T3.Role_Desc = 'Captain'` instead of `position = 'captain'`. Do add `GROUP BY T2.Player_Name` instead of omitting the grouping. The amended query now correctly identifies captains through proper table relationships and role descriptions instead of relying on a simple position field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE position = 'captain';",
            "SELECT T2.Player_Name\nFROM Player_Match AS T1\nINNER JOIN Player AS T2 ON T1.Player_Id = T2.Player_Id\nINNER JOIN Rolee AS T3 ON T1.Role_Id = T3.Role_Id\nWHERE T3.Role_Desc = 'Captain'\nGROUP BY T2.Player_Name"
        ],
        "rule_sql": []
    },
    "6126": {
        "db_id": "food_inspection_2",
        "question": "How many inspections did All Style Buffet Restaurant have?",
        "ground_truth": "SELECT COUNT(T2.inspection_id) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.facility_type = 'Restaurant' AND T1.dba_name = 'All Style Buffet'",
        "amends": [
            "Do select `COUNT(T2.inspection_id)` from the inspection table instead of `COUNT(*)` from a single table. Do join `establishment AS T1` with `inspection AS T2` using `T1.license_no = T2.license_no` instead of querying only the inspections table. Do filter on `T1.facility_type = 'Restaurant'` and `T1.dba_name = 'All Style Buffet'` instead of filtering on `restaurant_name = 'All Style Buffet Restaurant'`. The amended query now correctly counts inspections by joining establishment data and using proper business name and facility type filters, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE restaurant_name = 'All Style Buffet Restaurant';",
            "SELECT COUNT(T2.inspection_id) \nFROM establishment AS T1 \nJOIN inspection AS T2 ON T1.license_no = T2.license_no \nWHERE T1.facility_type = 'Restaurant' AND T1.dba_name = 'All Style Buffet'"
        ],
        "rule_sql": []
    },
    "8387": {
        "db_id": "mondial_geo",
        "question": "In which Country is the second highest volcanic mountain located in? Give the code of the country.",
        "ground_truth": "SELECT T3.Country FROM mountain AS T1 INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province ORDER BY T1.Height DESC LIMIT 1, 1",
        "amends": [
            "Do select `T3.Country` from the `province` table instead of `Country` from the `Volcanoes` table. Do add joins with `mountain AS T1` via `INNER JOIN` on `T1.Name = T2.Mountain` and `geo_mountain AS T2` via `INNER JOIN` on `T3.Name = T2.Province` instead of querying a single table. Do order by `T1.Height DESC` instead of `Height DESC`. Do use `LIMIT 1, 1` syntax instead of `LIMIT 1 OFFSET 1`. The amended query now correctly retrieves the country of the second tallest mountain through proper table relationships instead of incorrectly querying a non-existent Volcanoes table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country FROM Volcanoes ORDER BY Height DESC LIMIT 1 OFFSET 1;",
            "SELECT T3.Country \nFROM province AS T3\nINNER JOIN geo_mountain AS T2 ON T3.Name = T2.Province\nINNER JOIN mountain AS T1 ON T1.Name = T2.Mountain\nWHERE T1.Type = 'volcano'\nORDER BY T1.Height DESC\nLIMIT 1, 1"
        ],
        "rule_sql": []
    },
    "2274": {
        "db_id": "movielens",
        "question": "What is the percentage of female audiences who viewed movies with rating 2?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.u_gender = 'F', 1, 0)) AS REAL) * 100 / COUNT(T2.userid) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 2",
        "amends": [
            "Do use `CAST(SUM(IIF(T2.u_gender = 'F', 1, 0)) AS REAL) * 100 / COUNT(T2.userid)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM audiences WHERE gender = 'female')` for the percentage calculation. Do join `u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid` instead of `audiences a JOIN movies m ON a.movie_id = m.movie_id`. Do filter with `WHERE T1.rating = 2` instead of `WHERE a.gender = 'female' AND m.rating = 2`, moving the gender condition into the IIF function within the SUM. Do remove the subquery and instead calculate the percentage directly using conditional counting against the total user count. The amended query now correctly calculates the percentage of female users who gave a rating of 2 by properly joining user rating data with user demographic information and using conditional aggregation instead of a subquery approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM audiences WHERE gender = 'female')) AS percentage\nFROM audiences a\nJOIN movies m ON a.movie_id = m.movie_id\nWHERE a.gender = 'female' AND m.rating = 2;",
            "SELECT CAST(SUM(IIF(T2.u_gender = 'F', 1, 0)) AS REAL) * 100 / COUNT(T2.userid) AS percentage_female_rating_2\nFROM u2base AS T1\nINNER JOIN users AS T2 ON T1.userid = T2.userid\nWHERE T1.rating = '2';"
        ],
        "rule_sql": []
    },
    "8319": {
        "db_id": "mondial_geo",
        "question": "Which island is city Balikpapan located on? How big is the island?",
        "ground_truth": "SELECT T3.Name, T3.Area FROM city AS T1 INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE T1.Name = 'Balikpapan'",
        "amends": [
            "Do join tables `city`, `locatedOn`, and `island` instead of querying only `cities` table. Do select `T3.Name` and `T3.Area` instead of `island_name` and `size`. Do use `INNER JOIN` on `T1.Name = T2.City` and `T3.Name = T2.Island` instead of no joins. Do filter on `T1.Name = 'Balikpapan'` instead of `city_name = 'Balikpapan'`. The amended query now correctly retrieves island information through proper table relationships instead of assuming all data exists in a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT island_name, size FROM cities WHERE city_name = 'Balikpapan';",
            "SELECT T3.Name, T3.Area \nFROM city T1 \nINNER JOIN locatedOn T2 ON T1.Name = T2.City \nINNER JOIN island T3 ON T3.Name = T2.Island \nWHERE T1.Name = 'Balikpapan'"
        ],
        "rule_sql": []
    },
    "5398": {
        "db_id": "sales",
        "question": "What is the difference in price between HL Mountain Frame - Black, 42 and LL Mountain Frame - Black, 42?",
        "ground_truth": "SELECT ( SELECT Price FROM Products WHERE Name = 'HL Mountain Frame - Black, 42' ) - ( SELECT Price FROM Products WHERE Name = 'LL Mountain Frame - Black, 42' ) AS num",
        "amends": [
            "Do use scalar subqueries `(SELECT Price FROM Products WHERE Name = 'HL Mountain Frame - Black, 42')` and `(SELECT Price FROM Products WHERE Name = 'LL Mountain Frame - Black, 42')` instead of cross joining `Production.Product p1` and `Production.Product p2` with name filters. Do reference the `Price` column instead of `ListPrice` column. Do use the `Products` table instead of `Production.Product` table. Do calculate the difference between the two scalar subquery results instead of subtracting columns from a cross join. The amended query now correctly retrieves individual product prices and computes their difference without generating unnecessary Cartesian products."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p1.ListPrice - p2.ListPrice AS PriceDifference\nFROM Production.Product p1, Production.Product p2\nWHERE p1.Name = 'HL Mountain Frame - Black, 42'\nAND p2.Name = 'LL Mountain Frame - Black, 42';",
            "SELECT \n    (SELECT Price FROM Products WHERE Name = 'HL Mountain Frame - Black, 42') - \n    (SELECT Price FROM Products WHERE Name = 'LL Mountain Frame - Black, 42') \n    AS PriceDifference"
        ],
        "rule_sql": []
    },
    "5054": {
        "db_id": "olympics",
        "question": "What were the cities in which John Aalberg competed?",
        "ground_truth": "SELECT T4.city_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN games_city AS T3 ON T2.games_id = T3.games_id INNER JOIN city AS T4 ON T3.city_id = T4.id WHERE T1.full_name = 'John Aalberg'",
        "amends": [
            "Do select `T4.city_name` instead of `city` from the `competitions` table. Do use a multi-table join structure instead of querying a single table, adding tables `person AS T1`, `games_competitor AS T2`, `games_city AS T3`, and `city AS T4`. Do perform `INNER JOIN` operations with `T1.id = T2.person_id`, `T2.games_id = T3.games_id`, and `T3.city_id = T4.id` instead of no joins. Do filter on `T1.full_name = 'John Aalberg'` instead of `name = 'John Aalberg'`. The amended query now correctly retrieves the city name through proper table relationships instead of relying on a non-existent column in the competitions table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM competitions WHERE name = 'John Aalberg';",
            "SELECT DISTINCT T4.city_name\nFROM person AS T1\nINNER JOIN games_competitor AS T2 ON T1.id = T2.person_id\nINNER JOIN games_city AS T3 ON T2.games_id = T3.games_id\nINNER JOIN city AS T4 ON T3.city_id = T4.id\nWHERE T1.full_name = 'John Aalberg'"
        ],
        "rule_sql": []
    },
    "5784": {
        "db_id": "language_corpus",
        "question": "How many more times does the first word in the biwords pair \"\u00e0bac-xin\u00e8s\" occur than the biwords pair itself?",
        "ground_truth": "SELECT occurrences - ( SELECT occurrences FROM biwords WHERE w1st = ( SELECT wid FROM words WHERE word = '\u00e0bac' ) AND w2nd = ( SELECT wid FROM words WHERE word = 'xin\u00e8s' ) ) AS CALUS FROM words WHERE word = '\u00e0bac'",
        "amends": [
            "Do use the `occurrences` column from the `words` table instead of counting rows with `COUNT(*)` from `biwords`. Do reference the main word occurrence directly from `words` instead of using a subquery to count matching words. Do calculate the difference by subtracting the bigram occurrence count from the single word occurrence count instead of subtracting two independent counts. Do use proper word ID references through subqueries (`w1st` and `w2nd` matching word IDs from the `words` table) instead of direct string comparisons in the `biwords` table. Do add the necessary joins between `words` and `biwords` tables through ID matching instead of treating them as separate entities. The amended query now correctly calculates the difference between a single word's occurrence count and its occurrence as part of a specific bigram."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SELECT COUNT(*) FROM biwords WHERE word = '\u00e0bac') - (SELECT COUNT(*) FROM biwords WHERE word = '\u00e0bac-xin\u00e8s') AS difference;",
            "SELECT \n    (SELECT w.occurrences FROM words w WHERE w.word = '\u00e0bac') - \n    (SELECT b.occurrences FROM biwords b \n     JOIN words w1 ON b.w1st = w1.wid AND w1.word = '\u00e0bac'\n     JOIN words w2 ON b.w2nd = w2.wid AND w2.word = 'xin\u00e8s'\n     WHERE b.lid = (SELECT lid FROM langs WHERE lang = 'ca')) \nAS difference;"
        ],
        "rule_sql": []
    },
    "4221": {
        "db_id": "simpson_episodes",
        "question": "Describe the birth country, height and person name who were not included in credit list with category of casting.",
        "ground_truth": "SELECT T1.birth_country, T1.height_meters, T1.name FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T2.category = 'Cast' AND T2.credited = 'false';",
        "amends": [
            "Do use `INNER JOIN` on `T1.name = T2.person` instead of a `NOT IN` subquery. Do reference columns with table aliases `T1.birth_country`, `T1.height_meters`, and `T1.name` instead of `birth_country`, `height`, and `person_name`. Do add join condition `T2.category = 'Cast'` instead of filtering subquery with `category = 'casting'`. Do add additional filter `T2.credited = 'false'` instead of omitting it. Do change table names to `Person AS T1` and `Credit AS T2` instead of `people` and `credits`. The amended query now correctly filters for uncredited cast members using a join approach instead of the original exclusion logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_country, height, person_name \nFROM people \nWHERE person_id NOT IN (\n    SELECT person_id \n    FROM credits \n    WHERE category = 'casting'\n)",
            "SELECT T1.birth_country, T1.height_meters, T1.name\nFROM Person AS T1\nINNER JOIN Credit AS T2 ON T1.name = T2.person\nWHERE T2.category = 'Cast' AND T2.credited = 'false'"
        ],
        "rule_sql": []
    },
    "4978": {
        "db_id": "olympics",
        "question": "List out all the gold medalist winners in cycling sport.",
        "ground_truth": "SELECT DISTINCT T5.full_name FROM event AS T1 INNER JOIN competitor_event AS T2 ON T1.id = T2.event_id INNER JOIN games_competitor AS T3 ON T2.competitor_id = T3.id INNER JOIN sport AS T4 ON T1.sport_id = T4.id INNER JOIN person AS T5 ON T3.person_id = T5.id WHERE T4.sport_name = 'Cycling' AND T2.medal_id = 1",
        "amends": [
            "Do select only `T5.full_name` with `DISTINCT` instead of selecting all columns with `*`. Do join five tables (`event`, `competitor_event`, `games_competitor`, `sport`, `person`) with `INNER JOIN` chains instead of querying a single `athletes` table. Do filter on `T4.sport_name = 'Cycling'` instead of `sport = 'cycling'`. Do filter on `T2.medal_id = 1` instead of `medal = 'gold'`. The amended query now correctly identifies gold medal cyclists through proper table relationships and avoids duplicate results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM athletes WHERE sport = 'cycling' AND medal = 'gold';",
            "SELECT DISTINCT T5.full_name\nFROM event T1\nINNER JOIN competitor_event T2 ON T1.id = T2.event_id\nINNER JOIN games_competitor T3 ON T2.competitor_id = T3.id\nINNER JOIN sport T4 ON T1.sport_id = T4.id\nINNER JOIN person T5 ON T3.person_id = T5.id\nWHERE T4.sport_name = 'Cycling' AND T2.medal_id = 1"
        ],
        "rule_sql": []
    },
    "1938": {
        "db_id": "soccer_2016",
        "question": "Among the South African players, how many were born before 4/11/1980?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.DOB < '1980-4-11' THEN 1 ELSE 0 END) FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id WHERE T2.Country_Name = 'South Africa'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.DOB < '1980-4-11' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific rows. Do add `INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id` instead of querying the `players` table directly. Do change the filter to `WHERE T2.Country_Name = 'South Africa'` instead of `WHERE country = 'South Africa'` to properly reference the joined table. Do reference `T1.DOB` instead of `birth_date` for the date comparison. The amended query now correctly joins tables and uses conditional aggregation to count only South African players born before the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE country = 'South Africa' AND birth_date < '1980-04-11';",
            "SELECT SUM(CASE WHEN T1.DOB < '1980-4-11' THEN 1 ELSE 0 END) \nFROM Player AS T1\nINNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id\nWHERE T2.Country_Name = 'South Africa'"
        ],
        "rule_sql": []
    },
    "5211": {
        "db_id": "address",
        "question": "Provide the alias of the city with the highest population in year 2020.",
        "ground_truth": "SELECT T1.alias FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.population_2020 = ( SELECT MAX(population_2020) FROM zip_data )",
        "amends": [
            "Do select `T1.alias` instead of `city_alias` and use a different source structure. Do add `INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code` instead of querying only the `cities` table. Do change the WHERE condition to `T2.population_2020 = (SELECT MAX(population_2020) FROM zip_data)` instead of `year = 2020`. Do remove the `ORDER BY population ASC LIMIT 1` clause instead of keeping it, as the subquery now handles finding the maximum population. The amended query now correctly joins tables and uses a subquery to find the zip code with maximum population in 2020, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_alias FROM cities WHERE year = 2020 ORDER BY population ASC LIMIT 1;",
            "SELECT T1.alias FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.population_2020 = (SELECT MAX(population_2020) FROM zip_data)"
        ],
        "rule_sql": []
    },
    "6999": {
        "db_id": "works_cycles",
        "question": "What is the average standard cost of product number CA-1098?",
        "ground_truth": "SELECT AVG(T2.StandardCost) FROM Product AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductNumber = 'CA-1098'",
        "amends": [
            "Do join `Product AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID` instead of querying only the `products` table. Do filter on `T1.ProductNumber = 'CA-1098'` instead of `product_number = 'CA-1098'`. Do aggregate `AVG(T2.StandardCost)` instead of `AVG(standard_cost)` to calculate the average from the correct cost history table. The amended query now correctly joins the product and cost history tables to calculate the average standard cost for the specified product number, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(standard_cost) FROM products WHERE product_number = 'CA-1098'",
            "SELECT AVG(T2.StandardCost) AS average_standard_cost\nFROM Product AS T1\nINNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID\nWHERE T1.ProductNumber = 'CA-1098';"
        ],
        "rule_sql": []
    },
    "1115": {
        "db_id": "talkingdata",
        "question": "What is the age group of most OPPO users?",
        "ground_truth": "SELECT T.`group` FROM ( SELECT T1.`group`, COUNT(T1.`group`) AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' GROUP BY T1.`group` ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use table `gender_age` with alias `T1` instead of `users`, and join with `phone_brand_device_model2` as `T2` on `T1.device_id = T2.device_id` instead of querying a single table. Do filter on `T2.phone_brand = 'OPPO'` instead of `brand = 'OPPO'`. Do group by `T1.group` instead of `age_group` and count `T1.group` instead of using `COUNT(*)`. Do use a subquery to wrap the grouped results as `T` instead of querying directly. Do order by `T.num DESC` instead of `user_count DESC` while maintaining the same `LIMIT 1`. The amended query now correctly joins the necessary tables to identify the most common age group for OPPO phone users.",
            "Do use backticks around `group` instead of unquoted group to handle reserved keywords. Do add explicit `AS` aliases for table references `AS T1` and `AS T2` instead of omitting them. Do specify `INNER JOIN` instead of just `JOIN` for clarity. The amended query now correctly handles the reserved keyword and maintains explicit join semantics while preserving the same logical behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age_group, COUNT(*) as user_count FROM users WHERE brand = 'OPPO' GROUP BY age_group ORDER BY user_count DESC LIMIT 1;",
            "SELECT T.group FROM (SELECT T1.group, COUNT(T1.group) AS num FROM gender_age T1 JOIN phone_brand_device_model2 T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'OPPO' GROUP BY T1.group) T ORDER BY T.num DESC LIMIT 1",
            "SELECT T.`group`\nFROM (\n    SELECT T1.`group`, COUNT(T1.`group`) AS num\n    FROM `gender_age` AS T1\n    INNER JOIN `phone_brand_device_model2` AS T2 ON T1.device_id = T2.device_id\n    WHERE T2.phone_brand = 'OPPO'\n    GROUP BY T1.`group`\n) AS T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5321": {
        "db_id": "beer_factory",
        "question": "What is the full name of the customer who gave a 5-star rating and commented \"The quintessential dessert root beer. No ice cream required\" on his review?",
        "ground_truth": "SELECT T1.First, T1.Last FROM customers AS T1 INNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.StarRating = 5 AND T2.Review = 'The quintessential dessert root beer. No ice cream required.'",
        "amends": [
            "Do select `T1.First` and `T1.Last` instead of `first_name` and `last_name`. Do add `INNER JOIN rootbeerreview AS T2` instead of querying only the `customers` table. Do use join condition `T1.CustomerID = T2.CustomerID` instead of no join. Do filter on `T2.StarRating = 5` instead of `rating = 5`. Do filter on `T2.Review = 'The quintessential dessert root beer. No ice cream required.'` instead of `comment = 'The quintessential dessert root beer. No ice cream required'`. The amended query now correctly joins the tables and filters on the appropriate columns from the joined table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE rating = 5 AND comment = 'The quintessential dessert root beer. No ice cream required';",
            "SELECT T1.First, T1.Last\nFROM customers AS T1\nINNER JOIN rootbeerreview AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.StarRating = 5\nAND T2.Review = 'The quintessential dessert root beer. No ice cream required.'"
        ],
        "rule_sql": []
    },
    "9029": {
        "db_id": "bike_share_1",
        "question": "Please write down the trip IDs which ended on the days when the minimum temperature is less than 45 degrees Fahrenheit.",
        "ground_truth": "SELECT T1.id FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.min_temperature_f < 45",
        "amends": [
            "Do select `T1.id` instead of `trip_id` and use table alias `T1` instead of direct table reference. Do use `INNER JOIN` on `T2.zip_code = T1.zip_code` instead of a subquery with `IN` condition. Do reference `min_temperature_f` instead of `min_temp` and use the correct column name `min_temperature_f < 45` instead of `min_temp < 45`. Do remove the subquery structure entirely and instead perform a direct join between `trip` and `weather` tables using zip code matching, which correctly associates weather conditions with trips based on geographic location rather than just date matching. The amended query now correctly joins on zip code to ensure weather data corresponds to the trip's location and uses the proper column names throughout."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT trip_id FROM trips WHERE end_date IN (SELECT date FROM weather WHERE min_temp < 45);",
            "SELECT T1.id\nFROM trip T1\nINNER JOIN weather T2 ON T2.zip_code = T1.zip_code\nWHERE T2.min_temperature_f < 45"
        ],
        "rule_sql": []
    },
    "7622": {
        "db_id": "hockey",
        "question": "List all goalies from year 2000 to 2010 for team COL. State their given name, height, weight and age of today.",
        "ground_truth": "SELECT T1.nameGiven, T1.height , T1.weight, STRFTIME('%Y', CURRENT_TIMESTAMP) - birthYear FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T2.tmID = 'COL' AND T2.year >= 2000 AND T2.year <= 2010 GROUP BY T1.playerID",
        "amends": [
            "Do select `T1.nameGiven`, `T1.height`, and `T1.weight` instead of `given_name`, `height`, and `weight`. Do calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - birthYear` instead of `strftime('%Y', 'now') - strftime('%Y', birth_date)`. Do use `FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID` instead of `FROM players` with direct filters. Do filter on `T2.tmID = 'COL'` instead of `team = 'COL'`. Do use `T2.year >= 2000 AND T2.year <= 2010` instead of `year BETWEEN 2000 AND 2010`. Do add `GROUP BY T1.playerID` instead of omitting grouping. The amended query now correctly joins the Master and Goalies tables and filters on the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT given_name, height, weight, (strftime('%Y', 'now') - strftime('%Y', birth_date)) AS age FROM players WHERE position = 'Goalie' AND team = 'COL' AND year BETWEEN 2000 AND 2010;",
            "SELECT \n    T1.nameGiven, \n    T1.height, \n    T1.weight, \n    (STRFTIME('%Y', CURRENT_TIMESTAMP) - T1.birthYear) AS age\nFROM \n    Master AS T1 \nINNER JOIN \n    Goalies AS T2 ON T1.playerID = T2.playerID\nWHERE \n    T2.tmID = 'COL' \n    AND T2.year >= 2000 \n    AND T2.year <= 2010\nGROUP BY \n    T1.playerID"
        ],
        "rule_sql": []
    },
    "8651": {
        "db_id": "chicago_crime",
        "question": "Calculate the average crime rate per month in the highest populous area.",
        "ground_truth": "SELECT CAST(COUNT(T2.report_no) AS REAL) / 12 FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no GROUP BY T1.community_area_no HAVING COUNT(T1.population) ORDER BY COUNT(T1.population) LIMIT 1",
        "amends": [
            "Do use `CAST(COUNT(T2.report_no) AS REAL) / 12` instead of `AVG(crime_rate)` for the calculation. Do change the FROM clause to `Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no` instead of the single table `crimes` with a subquery. Do remove the WHERE filter and instead add a HAVING clause with `COUNT(T1.population)` instead of filtering by maximum population. Do add GROUP BY `T1.community_area_no` instead of `month`. Do include ORDER BY `COUNT(T1.population)` and LIMIT 1 instead of the subquery approach. The amended query now correctly calculates the average crime rate per community area with proper table joins and aggregation.",
            "Do remove the alias `average_crime_rate_per_month` instead of keeping it. Do change the `ORDER BY` direction to ascending instead of descending by removing `DESC`. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(crime_rate) FROM crimes WHERE area_population = (SELECT MAX(area_population) FROM areas) GROUP BY month;",
            "SELECT CAST(COUNT(T2.report_no) AS REAL) / 12 AS average_crime_rate_per_month\nFROM Community_Area AS T1\nINNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no\nGROUP BY T1.community_area_no\nHAVING COUNT(T1.population)\nORDER BY COUNT(T1.population) DESC\nLIMIT 1;",
            "SELECT CAST(COUNT(T2.report_no) AS REAL) / 12 \nFROM Community_Area AS T1 \nINNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no \nGROUP BY T1.community_area_no \nHAVING COUNT(T1.population) \nORDER BY COUNT(T1.population) \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4638": {
        "db_id": "disney",
        "question": "Who is the voice actor of the character \"Binkie Muddlefoot\"?",
        "ground_truth": "SELECT `voice-actor` FROM `voice-actors` WHERE character = 'Binkie Muddlefoot'",
        "amends": [
            "Do select `voice-actor` instead of `actor_name` and do use table `voice-actors` instead of `characters`. Do filter on `character` = 'Binkie Muddlefoot' instead of `character_name` = 'Binkie Muddlefoot'. The amended query now correctly retrieves voice actor information from the appropriate table using the correct column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM characters WHERE character_name = 'Binkie Muddlefoot';",
            "SELECT \"voice-actor\" FROM \"voice-actors\" WHERE character = 'Binkie Muddlefoot';"
        ],
        "rule_sql": []
    },
    "5568": {
        "db_id": "menu",
        "question": "Among the menu pages of \"Ritz Carlton\", how many of them have a width of over 1000?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.name = 'Ritz Carlton' THEN 1 ELSE 0 END) FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE T2.full_width > 1000",
        "amends": [
            "Do use `SUM(CASE WHEN T1.name = 'Ritz Carlton' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific rows. Do join `Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id` instead of querying only `menu_pages` table. Do filter on `T2.full_width > 1000` instead of `width > 1000` using the correct column name. Do reference `T1.name = 'Ritz Carlton'` instead of `restaurant_name = 'Ritz Carlton'` to use the proper table and column. The amended query now correctly joins the Menu and MenuPage tables and counts only the restaurants with the specified name that meet the width condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menu_pages WHERE restaurant_name = 'Ritz Carlton' AND width > 1000;",
            "SELECT SUM(CASE WHEN T1.name = 'Ritz Carlton' THEN 1 ELSE 0 END) AS count_pages\nFROM Menu AS T1\nINNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id\nWHERE T2.full_width > 1000;"
        ],
        "rule_sql": []
    },
    "1330": {
        "db_id": "law_episode",
        "question": "What is the ratio of American casts on episode 2 of the series? Please include their roles.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.category = 'Cast' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.category), T1.role FROM Award AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id INNER JOIN Person AS T4 ON T2.person_id = T4.person_id WHERE T3.episode = 2 AND T4.birth_country = 'USA'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.category = 'Cast' THEN 1 ELSE 0 END) * 100 / COUNT(T2.category)` with explicit `CAST` to `REAL` instead of `COUNT(*)` for a percentage calculation. Do change the FROM clause to use `Award AS T1` instead of `casts c` and add multiple joins: `INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id`, `INNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id`, and `INNER JOIN Person AS T4 ON T2.person_id = T4.person_id` instead of a single join on `episodes`. Do modify the WHERE filter to use `T3.episode = 2` instead of `e.episode_number = 2` and `T4.birth_country = 'USA'` instead of `c.nationality = 'American'`. Do remove `GROUP BY c.name, c.role` and `ORDER BY count DESC` as they are no longer needed for the aggregate calculation. The amended query now correctly calculates the percentage of 'Cast' credits among all credits for episode 2 with USA birth country, matching the intended behavior.",
            "Do reference `T1.role` in the SELECT list instead of `T2.role` to correctly access the role column from the Award table. The amended query now matches RIGHT_SQL's behavior by properly selecting the role from the appropriate table.",
            "Do move `T1.role` to the end of the SELECT list instead of placing it first. Do keep all other elements unchanged including the same joins on `T1.episode_id=T2.episode_id`, `T2.episode_id=T3.episode_id`, and `T2.person_id=T4.person_id`, the same WHERE filters on `T3.episode=2` and `T4.birth_country='USA'`, and the same aggregate calculation with CAST. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name, c.role, COUNT(*) as count \nFROM casts c \nJOIN episodes e ON c.episode_id = e.id \nWHERE e.episode_number = 2 \nAND c.nationality = 'American' \nGROUP BY c.name, c.role \nORDER BY count DESC;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.category = 'Cast' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.category) AS percentage,\n    T2.role\nFROM \n    Award AS T1\nINNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id\nINNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id\nINNER JOIN Person AS T4 ON T2.person_id = T4.person_id\nWHERE \n    T3.episode = 2\n    AND T4.birth_country = 'USA'",
            "SELECT \n    T1.role,\n    CAST(SUM(CASE WHEN T2.category = 'Cast' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.category) AS percentage\nFROM \n    Award AS T1\nINNER JOIN \n    Credit AS T2 ON T1.episode_id = T2.episode_id\nINNER JOIN \n    Episode AS T3 ON T2.episode_id = T3.episode_id\nINNER JOIN \n    Person AS T4 ON T2.person_id = T4.person_id\nWHERE \n    T3.episode = 2\n    AND T4.birth_country = 'USA';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.category = 'Cast' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.category) AS percentage,\n    T1.role\nFROM \n    Award AS T1\n    INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id\n    INNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id\n    INNER JOIN Person AS T4 ON T2.person_id = T4.person_id\nWHERE \n    T3.episode = 2\n    AND T4.birth_country = 'USA'"
        ],
        "rule_sql": []
    },
    "942": {
        "db_id": "cs_semester",
        "question": "Find the most important and most difficult courses.",
        "ground_truth": "SELECT name FROM course WHERE credit = ( SELECT MAX(credit) FROM course ) AND diff = ( SELECT MAX(diff) FROM course )",
        "amends": [
            "Do select only `name` instead of all columns with `*`. Do use `WHERE` filters with subqueries to find maximum `credit` and `diff` values instead of sorting by `importance` and `difficulty` then limiting. Do reference the `course` table instead of `courses`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. Do add subqueries to calculate `MAX(credit)` and `MAX(diff)` instead of omitting them. The amended query now correctly identifies courses with both maximum credit and maximum difficulty values rather than just the top-ranked course by importance and difficulty."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM courses ORDER BY importance DESC, difficulty DESC LIMIT 1;",
            "SELECT name FROM course WHERE credit = (SELECT MAX(credit) FROM course) AND diff = (SELECT MAX(diff) FROM course);"
        ],
        "rule_sql": []
    },
    "5092": {
        "db_id": "address",
        "question": "What is the bad alias of the residential area with the highest average house value?",
        "ground_truth": "SELECT T2.bad_alias FROM zip_data AS T1 INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE T1.avg_house_value = ( SELECT MAX(avg_house_value) FROM zip_data ) LIMIT 1",
        "amends": [
            "Do use `SELECT T2.bad_alias` instead of `SELECT bad_alias, AVG(house_value) as avg_value` to retrieve only the alias column without aggregation. Do add `FROM zip_data AS T1 INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code` instead of `FROM residential_areas` to join two tables with proper join conditions. Do add `WHERE T1.avg_house_value = (SELECT MAX(avg_house_value) FROM zip_data)` instead of `GROUP BY bad_alias` to filter for maximum house value using a subquery. Do remove `ORDER BY avg_value DESC` and `AVG(house_value)` aggregation since they are replaced by the MAX subquery filter. Do keep `LIMIT 1` but apply it after the correct filtering logic instead of after grouping. The amended query now correctly identifies the record with the maximum average house value through proper table joining and subquery filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bad_alias, AVG(house_value) as avg_value FROM residential_areas GROUP BY bad_alias ORDER BY avg_value DESC LIMIT 1;",
            "SELECT T2.bad_alias \nFROM zip_data AS T1 \nINNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code \nWHERE T1.avg_house_value = (SELECT MAX(avg_house_value) FROM zip_data) \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1224": {
        "db_id": "talkingdata",
        "question": "Which gender owned more of the Galaxy Note 2 device model?",
        "ground_truth": "SELECT IIF(SUM(IIF(T1.gender = 'M', 1, 0)) - SUM(IIF(T1.gender = 'F', 1, 0)) > 0, 'M', 'F') AS gender FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Galaxy Note 2'",
        "amends": [
            "Do use `IIF(SUM(IIF(T1.gender = 'M', 1, 0)) - SUM(IIF(T1.gender = 'F', 1, 0)) > 0, 'M', 'F')` instead of `COUNT(*)` to calculate gender majority based on conditional sums rather than simple counts. Do join `gender_age AS T1` with `phone_brand_device_model2 AS T2` on `T1.device_id = T2.device_id` instead of querying a single `devices` table. Do filter on `T2.device_model = 'Galaxy Note 2'` instead of `model = 'Galaxy Note 2'` to reference the correct table and column. Do remove `GROUP BY gender` and `ORDER BY count DESC LIMIT 1` instead of keeping them since the conditional logic determines the majority gender without grouping or ordering. The amended query now correctly identifies the majority gender for Galaxy Note 2 devices by comparing male and female counts through conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) as count FROM devices WHERE model = 'Galaxy Note 2' GROUP BY gender ORDER BY count DESC LIMIT 1;",
            "SELECT IIF(SUM(IIF(T1.gender = 'M', 1, 0)) - SUM(IIF(T1.gender = 'F', 1, 0)) > 0, 'M', 'F') AS majority_gender\nFROM gender_age AS T1\nJOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE T2.device_model = 'Galaxy Note 2'"
        ],
        "rule_sql": []
    },
    "6684": {
        "db_id": "retails",
        "question": "How many orders in total are made by customers in Germany?",
        "ground_truth": "SELECT COUNT(T2.c_custkey) FROM nation AS T1 INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN orders AS T3 ON T2.c_custkey = T3.o_custkey WHERE T1.n_name = 'GERMANY'",
        "amends": [
            "Do add `nation AS T1 INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN orders AS T3 ON T2.c_custkey = T3.o_custkey` instead of querying only the `orders` table. Do change the filter to `T1.n_name = 'GERMANY'` instead of `country = 'Germany'` to properly reference the nation table. Do change the count expression to `COUNT(T2.c_custkey)` instead of `COUNT(*)` to count specific customer keys from the joined tables. The amended query now correctly joins nation, customer, and orders tables to count German customers with orders, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE country = 'Germany'",
            "SELECT COUNT(T2.c_custkey) \nFROM nation AS T1 \nINNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey \nINNER JOIN orders AS T3 ON T2.c_custkey = T3.o_custkey \nWHERE T1.n_name = 'GERMANY'"
        ],
        "rule_sql": []
    },
    "9158": {
        "db_id": "movie_3",
        "question": "State the address location of store No.1.",
        "ground_truth": "SELECT T1.address, T1.address2, T1.district FROM address AS T1 INNER JOIN store AS T2 ON T1.address_id = T2.address_id WHERE T2.store_id = 1",
        "amends": [
            "Do select `T1.address`, `T1.address2`, and `T1.district` instead of just `store_name`. Do join `address AS T1` with `store AS T2` using `INNER JOIN` on `T1.address_id = T2.address_id` instead of querying only the `stores` table. Do filter on `T2.store_id = 1` instead of `store_id = 1` to reference the correct table. The amended query now correctly retrieves address details from the joined tables instead of just store names, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_name FROM stores WHERE store_id = 1;",
            "SELECT T1.address, T1.address2, T1.district FROM address AS T1 INNER JOIN store AS T2 ON T1.address_id = T2.address_id WHERE T2.store_id = 1"
        ],
        "rule_sql": []
    },
    "1448": {
        "db_id": "synthea",
        "question": "Indicate the full name of the patients who have 3 different allergies.",
        "ground_truth": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT GROUP BY T1.patient ORDER BY COUNT(DISTINCT T2.DESCRIPTION) > 3",
        "amends": [
            "Do select `T1.first` and `T1.last` instead of `first_name` and `last_name`. Do add `INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT` instead of omitting the allergies table join. Do remove the `WHERE COUNT(allergy) = 3` filter instead of keeping it. Do change the grouping to `GROUP BY T1.patient` instead of `GROUP BY patient_id`. Do add `ORDER BY COUNT(DISTINCT T2.DESCRIPTION) > 3` instead of omitting ordering. Do use `COUNT(DISTINCT T2.DESCRIPTION)` instead of `COUNT(allergy)` to count distinct allergy descriptions rather than all allergy records. The amended query now correctly joins the allergies table and counts distinct allergy types per patient while ordering by those with more than 3 distinct allergies, matching the RIGHT_SQL's behavior.",
            "Do remove the `HAVING COUNT(DISTINCT T2.DESCRIPTION) = 3` clause instead of keeping it, as the RIGHT_SQL does not filter the results based on allergy count but only orders them. Do keep the `ORDER BY COUNT(DISTINCT T2.DESCRIPTION) > 3` instead of changing it, maintaining the sorting logic that prioritizes patients with more than three distinct allergies. The amended query now correctly returns all patients ordered by whether they have more than three distinct allergies, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM patients WHERE COUNT(allergy) = 3 GROUP BY patient_id",
            "SELECT T1.first, T1.last\nFROM patients AS T1\nINNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT\nGROUP BY T1.patient\nHAVING COUNT(DISTINCT T2.DESCRIPTION) = 3\nORDER BY COUNT(DISTINCT T2.DESCRIPTION) > 3",
            "SELECT T1.first, T1.last\nFROM patients AS T1\nINNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT\nGROUP BY T1.patient\nORDER BY COUNT(DISTINCT T2.DESCRIPTION) > 3;"
        ],
        "rule_sql": []
    },
    "2365": {
        "db_id": "superstore",
        "question": "What are the names of the products that were ordered by Alejandro Grove?",
        "ground_truth": "SELECT DISTINCT T3.`Product Name` FROM west_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Alejandro Grove'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate product names. Do reference `T3.`Product Name`` instead of `p.name` for the correct column selection. Do join `west_superstore AS T1` instead of `products p` as the primary table source. Do join `people AS T2` instead of `customers c` with the join condition `T1.`Customer ID` = T2.`Customer ID`` instead of `o.customer_id = c.id`. Do join `product AS T3` instead of `products p` with the join condition `T3.`Product ID` = T1.`Product ID`` instead of `p.id = o.product_id`. Do filter on `T2.`Customer Name` = 'Alejandro Grove'` instead of `c.first_name = 'Alejandro'` to match the correct customer identifier. The amended query now correctly retrieves distinct product names for the specified customer using the proper table relationships and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name FROM products p JOIN orders o ON p.id = o.product_id JOIN customers c ON o.customer_id = c.id WHERE c.first_name = 'Alejandro'",
            "SELECT DISTINCT T3.\"Product Name\"\nFROM west_superstore AS T1\nJOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nJOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\"\nWHERE T2.\"Customer Name\" = 'Alejandro Grove'"
        ],
        "rule_sql": []
    },
    "7381": {
        "db_id": "works_cycles",
        "question": "What are the full names of the sales person whose bonuses are less than 1,000?",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM SalesPerson AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Bonus < 1000",
        "amends": [
            "Do use `T2.FirstName, T2.MiddleName, T2.LastName` instead of `first_name, last_name` to include the middle name and use proper table aliases. Do join `Person AS T2` via `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying only `sales_persons` to properly relate person data. Do filter with `T1.Bonus < 1000` instead of `bonus >= 1000` to select those with bonuses below the threshold rather than above it. The amended query now correctly joins tables and filters for salespersons with bonuses less than 1000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM sales_persons WHERE bonus >= 1000;",
            "SELECT T2.FirstName, T2.MiddleName, T2.LastName\nFROM SalesPerson AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.Bonus < 1000"
        ],
        "rule_sql": []
    },
    "4211": {
        "db_id": "simpson_episodes",
        "question": "How many award winners are from the USA?",
        "ground_truth": "SELECT COUNT(*) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T1.birth_country = 'USA' AND T2.result = 'Winner';",
        "amends": [
            "Do join `Person AS T1` and `Award AS T2` with `INNER JOIN` on `T1.name = T2.person` instead of querying only `award_winners` table. Do filter on `T1.birth_country = 'USA'` and `T2.result = 'Winner'` instead of just `country = 'USA'`. Do count from the joined result set instead of counting from a single table. The amended query now correctly counts award winners by joining person and award data with proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM award_winners WHERE country = 'USA';",
            "SELECT COUNT(*) \nFROM Person AS T1\nINNER JOIN Award AS T2 ON T1.name = T2.person\nWHERE T1.birth_country = 'USA' AND T2.result = 'Winner'"
        ],
        "rule_sql": []
    },
    "7738": {
        "db_id": "hockey",
        "question": "What is the name of the losing team during an exhibition game in 1912?",
        "ground_truth": "SELECT T2.name FROM SeriesPost AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND tmIDLoser = tmID WHERE T1.note = 'EX' AND T2.year = '1912'",
        "amends": [
            "Do select `T2.name` from the Teams table instead of `winning_team` from the games table. Do use `INNER JOIN` between SeriesPost as T1 and Teams as T2 on `T1.year = T2.year AND tmIDLoser = tmID` instead of querying a single table. Do filter with `T1.note = 'EX'` instead of `game_type = 'exhibition'` and maintain `T2.year = '1912'` instead of `year = 1912`. The amended query now correctly joins the SeriesPost and Teams tables to identify exhibition game losers from 1912, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT winning_team FROM games WHERE year = 1912 AND game_type = 'exhibition';",
            "SELECT T2.name \nFROM SeriesPost AS T1 \nINNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmIDLoser = T2.tmID \nWHERE T1.note = 'EX' AND T2.year = 1912"
        ],
        "rule_sql": []
    },
    "410": {
        "db_id": "movies_4",
        "question": "Please list the titles of all the movie produced by production company \"Universal Pictures\".",
        "ground_truth": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Universal Pictures'",
        "amends": [
            "Do use explicit joins with `production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id` instead of querying `movies` table directly. Do reference `T3.title` instead of just `title` to specify the table alias. Do filter on `T1.company_name = 'Universal Pictures'` instead of `production_company = 'Universal Pictures'` to use the correct column name from the joined table. The amended query now properly joins through the relationship tables to find movies by production company name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE production_company = 'Universal Pictures';",
            "SELECT T3.title\nFROM production_company AS T1 \nINNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id \nINNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id\nWHERE T1.company_name = 'Universal Pictures'"
        ],
        "rule_sql": []
    },
    "8144": {
        "db_id": "sales_in_weather",
        "question": "How many units of item no.5 were sold in store no.3 on the day in 2012 when the max temperature was the highest?",
        "ground_truth": "SELECT T1.units FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.item_nbr = 5 ORDER BY tmax DESC LIMIT 1",
        "amends": [
            "Do select `T1.units` instead of `SUM(quantity)`. Do use `sales_in_weather` as T1 instead of `sales`. Do add `INNER JOIN relation AS T2` on `T1.store_nbr = T2.store_nbr` instead of omitting the relation table. Do add `INNER JOIN weather AS T3` on `T2.station_nbr = T3.station_nbr` instead of using a subquery. Do filter with `T2.store_nbr = 3` instead of `store_id = 3`. Do filter with `SUBSTR(T1.date, 1, 4) = '2012'` for year extraction instead of a subquery. Do filter with `T1.item_nbr = 5` instead of `item_id = 5`. Do add `ORDER BY tmax DESC LIMIT 1` instead of ordering within a subquery. The amended query now correctly joins through the relation table to connect sales with weather data and uses proper column names from the schema."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) \nFROM sales \nWHERE item_id = 5 \nAND store_id = 3 \nAND date = (SELECT date FROM weather WHERE year = 2012 ORDER BY max_temperature DESC LIMIT 1);",
            "SELECT T1.units\nFROM sales_in_weather AS T1\nINNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr\nINNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr\nWHERE T2.store_nbr = 3\nAND T1.item_nbr = 5\nAND SUBSTR(T1.date, 1, 4) = '2012'\nORDER BY T3.tmax DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4461": {
        "db_id": "student_loan",
        "question": "How many students are enlisted in the Army organization?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'army'",
        "amends": [
            "Do count `name` instead of `*` to count non-null values rather than all rows. Do query from `enlist` table instead of `students` to access the correct data source. Do filter on `organ` column instead of `organization` to use the proper column name. Do filter for value 'army' instead of 'Navy' to apply the correct filter criteria. The amended query now correctly counts non-null name values from the enlist table where organ equals 'army', matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE organization = 'Navy';",
            "SELECT COUNT(name) FROM enlist WHERE organ = 'army'"
        ],
        "rule_sql": []
    },
    "5109": {
        "db_id": "address",
        "question": "Which state is Outagamie County in? Give the full name of the state.",
        "ground_truth": "SELECT DISTINCT T2.name FROM country AS T1 INNER JOIN state AS T2 ON T1.state = T2.abbreviation WHERE T1.county = 'OUTAGAMIE'",
        "amends": [
            "Do select `T2.name` instead of `county` and add `DISTINCT` instead of omitting it. Do join `country AS T1` and `state AS T2` with `INNER JOIN` on `T1.state = T2.abbreviation` instead of querying only `counties` table. Do filter on `T1.county = 'OUTAGAMIE'` instead of `state = 'Outagamie'` and use uppercase comparison instead of mixed case. The amended query now correctly retrieves state names from a normalized schema instead of county names from a denormalized table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county FROM counties WHERE state = 'Outagamie';",
            "SELECT DISTINCT T2.name FROM country AS T1 INNER JOIN state AS T2 ON T1.state = T2.abbreviation WHERE T1.county = 'OUTAGAMIE';"
        ],
        "rule_sql": []
    },
    "7360": {
        "db_id": "works_cycles",
        "question": "Who is the \"Next-Door Bike Store\" point of contact?",
        "ground_truth": "SELECT T1.Name FROM ContactType AS T1 INNER JOIN BusinessEntityContact AS T2 ON T1.ContactTypeID = T2.ContactTypeID INNER JOIN Store AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID WHERE T3.Name = 'Next-Door Bike Store'",
        "amends": [
            "Do select `T1.Name` instead of `*` to return only the contact type name instead of all columns. Do use `ContactType AS T1` joined to `BusinessEntityContact AS T2` on `T1.ContactTypeID = T2.ContactTypeID` instead of querying `customers` directly. Do add a second `INNER JOIN` to `Store AS T3` on `T2.BusinessEntityID = T3.BusinessEntityID` instead of missing these table relationships. Do filter on `T3.Name = 'Next-Door Bike Store'` instead of `store_name = 'Next-Door Bike Store'` to correctly reference the store name column in the proper table. The amended query now properly navigates the business entity relationships to find contact types associated with the specific store, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE store_name = 'Next-Door Bike Store';",
            "SELECT T1.Name\nFROM ContactType AS T1\nINNER JOIN BusinessEntityContact AS T2 ON T1.ContactTypeID = T2.ContactTypeID\nINNER JOIN Store AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID\nWHERE T3.Name = 'Next-Door Bike Store'"
        ],
        "rule_sql": []
    },
    "7582": {
        "db_id": "image_and_language",
        "question": "How many images have \"vegetable\" and \"fruits\" as their object classes?",
        "ground_truth": "SELECT COUNT(T1.IMG_ID) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'vegetables' OR T2.OBJ_CLASS = 'fruits'",
        "amends": [
            "Do use `COUNT(T1.IMG_ID)` instead of `COUNT(*)` to count specific image IDs. Do join `IMG_OBJ AS T1` with `OBJ_CLASSES AS T2` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single `images` table. Do filter with `T2.OBJ_CLASS = 'vegetables' OR T2.OBJ_CLASS = 'fruits'` instead of the impossible condition `object_classes = 'vegetable' AND object_classes = 'fruits'` which could never match. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly counts images belonging to either vegetable or fruit object classes through proper table relationships.",
            "Do remove `DISTINCT` from `COUNT` instead of keeping it to count all image IDs rather than unique ones. Do change the join type to explicitly specify `INNER JOIN` instead of implicit `JOIN` for clarity. Do correct the filter condition to use `'vegetables'` instead of `'vegetable'` to match the correct category name. The amended query now correctly counts all image IDs associated with either vegetables or fruits categories."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE object_classes = 'vegetable' AND object_classes = 'fruits';",
            "SELECT COUNT(DISTINCT T1.IMG_ID) \nFROM IMG_OBJ AS T1\nJOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE T2.OBJ_CLASS = 'vegetable' OR T2.OBJ_CLASS = 'fruits'",
            "SELECT COUNT(T1.IMG_ID) \nFROM IMG_OBJ AS T1 \nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID \nWHERE T2.OBJ_CLASS = 'vegetables' OR T2.OBJ_CLASS = 'fruits'"
        ],
        "rule_sql": []
    },
    "5701": {
        "db_id": "language_corpus",
        "question": "What are the titles of the top 5 Catalan language Wikipedia page with the least number of different words? Indicate each title's word id that has appeared the most in the said pages.",
        "ground_truth": "SELECT T1.title FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid ORDER BY T1.words LIMIT 5",
        "amends": [
            "Do select only `title` instead of including `word_id`. Do use `pages` table aliased as `T1` instead of `wikipedia_pages`. Do add `INNER JOIN` with `pages_words` as `T2` on `T1.pid = T2.pid` instead of omitting this join entirely. Do remove the `WHERE language = 'Catalan'` filter instead of keeping it. Do order by `T1.words` instead of `word_count`. Do maintain `LIMIT 5` as in the original query. The amended query now correctly joins the necessary tables and uses the appropriate ordering column to match the intended behavior.",
            "Do remove the `INNER JOIN langs` and its `ON T1.lid = langs.lid` condition instead of including them. Do remove the `WHERE langs.lang = 'Catalan'` filter instead of keeping it. Do remove the `GROUP BY T1.pid, T1.title` clause instead of including it. Do change `ORDER BY T1.words ASC` to `ORDER BY T1.words` instead of specifying the ASC direction. The amended query now correctly focuses only on joining pages with pages_words and ordering by word count without unnecessary language filtering or grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, word_id \nFROM wikipedia_pages \nWHERE language = 'Catalan' \nORDER BY word_count ASC \nLIMIT 5;",
            "SELECT T1.title\nFROM pages T1\nINNER JOIN pages_words T2 ON T1.pid = T2.pid\nINNER JOIN langs ON T1.lid = langs.lid\nWHERE langs.lang = 'Catalan'\nGROUP BY T1.pid, T1.title\nORDER BY T1.words ASC\nLIMIT 5",
            "SELECT T1.title\nFROM pages T1\nINNER JOIN pages_words T2 ON T1.pid = T2.pid\nORDER BY T1.words\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "6324": {
        "db_id": "retail_world",
        "question": "Please list the names of all the products whose supplier is in Japan.",
        "ground_truth": "SELECT T1.ProductName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T2.Country = 'Japan'",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join `Suppliers AS T2` on `T1.SupplierID = T2.SupplierID` instead of querying only the products table. Do reference `T2.Country` in the WHERE filter instead of the non-existent `supplier_country` column. Do select `T1.ProductName` instead of `product_name` to match the correct column naming. The amended query now correctly joins products with their suppliers and filters by supplier country, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE supplier_country = 'Japan';",
            "SELECT T1.ProductName \nFROM Products AS T1\nJOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID\nWHERE T2.Country = 'Japan'"
        ],
        "rule_sql": []
    },
    "3850": {
        "db_id": "public_review_platform",
        "question": "Please list the IDs of the users who have a high number of followers.",
        "ground_truth": "SELECT user_id FROM Users WHERE user_fans LIKE 'High' GROUP BY user_id",
        "amends": [
            "Do select `user_id` from `Users` instead of `users` as the table source. Do use a `WHERE` filter on `user_fans LIKE 'High'` instead of `followers > 1000`. Do add `GROUP BY user_id` instead of omitting it. Do remove `ORDER BY user_id` instead of keeping it. The amended query now correctly filters for users with high fan counts and groups by user_id rather than ordering results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM users WHERE followers > 1000 ORDER BY user_id;",
            "SELECT user_id FROM Users WHERE user_fans LIKE 'High' GROUP BY user_id"
        ],
        "rule_sql": []
    },
    "7022": {
        "db_id": "works_cycles",
        "question": "List all products with minimum order quantity of 100 and order them by product name in descending order.",
        "ground_truth": "SELECT DISTINCT T1.Name FROM Product AS T1 INNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID WHERE T2.MinOrderQty = 100 ORDER BY T1.Name DESC",
        "amends": [
            "Do select `DISTINCT T1.Name` instead of `*` to return only unique product names rather than all columns. Do join `Product AS T1 INNER JOIN ProductVendor AS T2` instead of querying only `products` to incorporate vendor relationship data. Do use join condition `T1.ProductID = T2.ProductID` instead of no join to properly relate products to their vendors. Do filter on `T2.MinOrderQty = 100` instead of `min_order_quantity = 100` to reference the correct table's quantity field. Do order by `T1.Name DESC` instead of `product_name ASC` to sort in descending alphabetical order. The amended query now correctly returns distinct product names from vendors with minimum order quantity of 100, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products WHERE min_order_quantity = 100 ORDER BY product_name ASC;",
            "SELECT DISTINCT T1.Name\nFROM Product AS T1\nINNER JOIN ProductVendor AS T2 ON T1.ProductID = T2.ProductID\nWHERE T2.MinOrderQty = 100\nORDER BY T1.Name DESC;"
        ],
        "rule_sql": []
    },
    "1568": {
        "db_id": "car_retails",
        "question": "Please list the name and phone number of the customer whose order was cancelled.",
        "ground_truth": "SELECT T2.customerName, T2.phone FROM orders AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE T1.status = 'Cancelled'",
        "amends": [
            "Do select `T2.customerName` and `T2.phone` instead of `name` and `phone`. Do use `orders AS T1 INNER JOIN customers AS T2` instead of only `FROM customers`. Do join on `T1.customerNumber = T2.customerNumber` instead of no join condition. Do filter on `T1.status = 'Cancelled'` instead of `order_status = 'cancelled'` with corrected case sensitivity. The amended query now correctly joins orders and customers tables to find customers with cancelled orders."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, phone FROM customers WHERE order_status = 'cancelled';",
            "SELECT T2.customerName, T2.phone\nFROM orders AS T1\nINNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber\nWHERE T1.status = 'Cancelled'"
        ],
        "rule_sql": []
    },
    "3096": {
        "db_id": "cars",
        "question": "Which country produced the most fuel-efficient car?",
        "ground_truth": "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country ORDER BY T1.mpg DESC LIMIT 1",
        "amends": [
            "Do select `T3.country` instead of `country, MAX(mpg)` and remove the aggregate function. Do use `FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country` instead of `FROM cars` with a simple table reference. Do remove the `GROUP BY country` clause entirely instead of keeping it. Do change the ordering to `ORDER BY T1.mpg DESC` instead of `ORDER BY MAX(mpg) DESC`. The amended query now correctly joins the necessary tables to establish proper relationships and retrieves the country with the highest mpg value through direct ordering rather than aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, MAX(mpg) FROM cars GROUP BY country ORDER BY MAX(mpg) DESC LIMIT 1;",
            "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country ORDER BY T1.mpg DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "5996": {
        "db_id": "books",
        "question": "List all the order dates for the customer named \"Adrian Kunzelmann\".",
        "ground_truth": "SELECT T3.order_date FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id INNER JOIN cust_order AS T3 ON T3.order_id = T2.order_id INNER JOIN customer AS T4 ON T4.customer_id = T3.customer_id WHERE T4.first_name = 'Adrian' AND T4.last_name = 'Kunzelmann'",
        "amends": [
            "Do select `T3.order_date` from the `cust_order` table instead of `order_date` from the `orders` table. Do join multiple tables including `book AS T1`, `order_line AS T2`, `cust_order AS T3`, and `customer AS T4` instead of querying only the `orders` table. Do use `INNER JOIN` relationships with `T1.book_id = T2.book_id`, `T3.order_id = T2.order_id`, and `T4.customer_id = T3.customer_id` instead of no joins. Do filter on `T4.first_name = 'Adrian' AND T4.last_name = 'Kunzelmann'` instead of `customer_name = 'Adrian Kunzelmann'` to properly match the customer by first and last name across normalized tables. The amended query now correctly retrieves order dates by traversing the proper table relationships and using the correct customer identification fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_date FROM orders WHERE customer_name = 'Adrian Kunzelmann'",
            "SELECT T3.order_date \nFROM cust_order AS T3\nINNER JOIN customer AS T4 ON T3.customer_id = T4.customer_id\nWHERE T4.first_name = 'Adrian' AND T4.last_name = 'Kunzelmann'"
        ],
        "rule_sql": []
    },
    "5153": {
        "db_id": "address",
        "question": "What is the area code of the city with the largest land area?",
        "ground_truth": "SELECT T1.area_code FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.land_area = ( SELECT MAX(land_area) FROM zip_data )",
        "amends": [
            "Do select `area_code` from `area_code` table instead of `cities` table. Do add `INNER JOIN` with `zip_data` on `T1.zip_code = T2.zip_code` instead of no join. Do add `WHERE` filter comparing `T2.land_area` to a subquery finding `MAX(land_area)` instead of simple `ORDER BY land_area DESC`. Do remove `LIMIT 1` and `ORDER BY` clauses instead of keeping them, as the maximum value is now found through subquery comparison. The amended query now correctly identifies the area code associated with the maximum land area by properly joining the relevant tables and using a subquery to find the actual maximum value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area_code FROM cities ORDER BY land_area DESC LIMIT 1;",
            "SELECT area_code.area_code\nFROM area_code\nINNER JOIN zip_data ON area_code.zip_code = zip_data.zip_code\nWHERE zip_data.land_area = (SELECT MAX(land_area) FROM zip_data);"
        ],
        "rule_sql": []
    },
    "3238": {
        "db_id": "donor",
        "question": "What was the donation optional support amount for the project 'Armenian Genocide'?",
        "ground_truth": "SELECT T2.donation_optional_support FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.title LIKE 'Armenian Genocide'",
        "amends": [
            "Do select `T2.donation_optional_support` instead of `donation_amount` from the wrong table. Do join `essays AS T1` and `donations AS T2` with an `INNER JOIN` on `T1.projectid = T2.projectid` instead of querying only the `projects` table. Do filter with `T1.title LIKE 'Armenian Genocide'` instead of `project_name = 'Armenian Genocide'` to correctly match the project title pattern. The amended query now properly retrieves donation support data from the donations table joined with essays based on project ID, matching the correct query's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT donation_amount FROM projects WHERE project_name = 'Armenian Genocide';",
            "SELECT T2.donation_optional_support \nFROM essays AS T1 \nINNER JOIN donations AS T2 ON T1.projectid = T2.projectid \nWHERE T1.title LIKE 'Armenian Genocide'"
        ],
        "rule_sql": []
    },
    "3160": {
        "db_id": "donor",
        "question": "If funded, which are the projects that could impact at least 600 students for a school with moderate level of poverty? Name the projects and state the project cost.",
        "ground_truth": "SELECT DISTINCT T2.title, T1.total_price_excluding_optional_support FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T1.students_reached >= 600 AND T1.poverty_level LIKE 'moderate poverty'",
        "amends": [
            "Do select `DISTINCT T2.title, T1.total_price_excluding_optional_support` instead of `project_name, project_cost`. Do join `INNER JOIN essays AS T2 ON T1.projectid = T2.projectid` instead of querying only the `projects` table. Do filter on `T1.students_reached >= 600` instead of `students_impacted >= 600`. Do use `T1.poverty_level LIKE 'moderate poverty'` instead of `poverty_level = 'moderate'`. Do remove the `funded = 1` condition instead of keeping it. The amended query now correctly joins project and essay data, uses appropriate column references with table aliases, and matches the filtering logic with proper string matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT project_name, project_cost \nFROM projects \nWHERE poverty_level = 'moderate' \nAND students_impacted >= 600 \nAND funded = 1;",
            "SELECT DISTINCT T2.title, T1.total_price_excluding_optional_support\nFROM projects AS T1\nINNER JOIN essays AS T2 ON T1.projectid = T2.projectid\nWHERE T1.students_reached >= 600\nAND T1.poverty_level LIKE 'moderate poverty'"
        ],
        "rule_sql": []
    },
    "4526": {
        "db_id": "student_loan",
        "question": "List out the number of students who have the longest duration of absense from school and enlisted in the peace corps.",
        "ground_truth": "SELECT COUNT(T1.NAME) FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE T2.organ = 'peace_corps' ORDER BY T1.month DESC LIMIT 1",
        "amends": [
            "Do select `COUNT(T1.NAME)` instead of `COUNT(*)`. Do use `FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2` instead of `FROM students`. Do apply join condition `ON T1.name = T2.name` instead of no join. Do filter with `WHERE T2.organ = 'peace_corps'` instead of `WHERE duration_of_absence = (SELECT MAX(duration_of_absence) FROM students) AND peace_corps = 1`. Do add `ORDER BY T1.month DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly counts peace corps enlistments from students with the longest absence, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students \nWHERE duration_of_absence = (SELECT MAX(duration_of_absence) FROM students) \nAND peace_corps = 1;",
            "SELECT COUNT(T1.name) \nFROM longest_absense_from_school AS T1 \nINNER JOIN enlist AS T2 ON T1.name = T2.name \nWHERE T2.organ = 'peace_corps' \nORDER BY T1.month DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6253": {
        "db_id": "coinmarketcap",
        "question": "State the transaction date whereby DigixDAO was transacted at the hightest price.",
        "ground_truth": "SELECT T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'DigixDAO' ORDER BY T2.price DESC LIMIT 1",
        "amends": [
            "Do select `T2.date` from the `historical` table instead of `transaction_date` from `transactions`. Do join `coins AS T1` with `historical AS T2` on `T1.id = T2.coin_id` instead of querying only the `transactions` table. Do filter on `T1.name = 'DigixDAO'` instead of `token_name = 'DigixDAO'`. Do order by `T2.price DESC` instead of `price ASC`. The amended query now correctly retrieves the date with the highest price for DigixDAO from the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_date FROM transactions WHERE token_name = 'DigixDAO' ORDER BY price ASC LIMIT 1;",
            "SELECT T2.date\nFROM coins AS T1\nJOIN historical AS T2 ON T1.id = T2.coin_id\nWHERE T1.name = 'DigixDAO'\nORDER BY T2.price DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7841": {
        "db_id": "world",
        "question": "List down the cities that belong to the country with a life expectancy of 66.4.",
        "ground_truth": "SELECT T2.Name FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T1.LifeExpectancy = 66.4",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city.Name FROM city JOIN country ON city.CountryCode = country.Code WHERE country.LifeExpectancy = 66.4"
        ],
        "rule_sql": []
    },
    "2779": {
        "db_id": "european_football_1",
        "question": "Which country did Bradford Team belongs to?",
        "ground_truth": "SELECT DISTINCT T2.country FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.HomeTeam = 'Bradford' OR T1.AwayTeam = 'Bradford'",
        "amends": [
            "Do select `DISTINCT T2.country` from the `divisions` table instead of `country` from the `teams` table. Do join `matchs AS T1` with `divisions AS T2` using `INNER JOIN` on `T1.Div = T2.division` instead of querying only the `teams` table. Do filter with `WHERE T1.HomeTeam = 'Bradford' OR T1.AwayTeam = 'Bradford'` instead of `WHERE team_name = 'Bradford Team'`. The amended query now correctly retrieves countries from divisions where Bradford played matches instead of incorrectly assuming team names in a teams table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM teams WHERE team_name = 'Bradford Team';",
            "SELECT DISTINCT T2.country FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.HomeTeam = 'Bradford' OR T1.AwayTeam = 'Bradford'"
        ],
        "rule_sql": []
    },
    "6137": {
        "db_id": "food_inspection_2",
        "question": "What is the average number of inspections did risk level 3 taverns have?",
        "ground_truth": "SELECT CAST(COUNT(T2.inspection_id) AS REAL) / COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.risk_level = 3 AND T1.facility_type = 'TAVERN'",
        "amends": [
            "Do use `CAST(COUNT(T2.inspection_id) AS REAL) / COUNT(DISTINCT T1.license_no)` instead of `AVG(inspection_count)` to calculate the average inspections per establishment. Do join `establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no` instead of querying only `taverns` to properly relate establishments with their inspections. Do add filter `T1.facility_type = 'TAVERN'` instead of omitting it to specifically target tavern establishments. Do change the risk level filter to `T1.risk_level = 3` instead of applying it directly to the taverns table. The amended query now correctly calculates average inspections per tavern by counting inspections divided by distinct establishments and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(inspection_count) FROM taverns WHERE risk_level = 3;",
            "SELECT CAST(COUNT(T2.inspection_id) AS REAL) / COUNT(DISTINCT T1.license_no) AS avg_inspections\nFROM establishment AS T1\nINNER JOIN inspection AS T2 ON T1.license_no = T2.license_no\nWHERE T1.facility_type = 'TAVERN' AND T1.risk_level = 3"
        ],
        "rule_sql": []
    },
    "2147": {
        "db_id": "world_development_indicators",
        "question": "What is indicator code of Rural population?",
        "ground_truth": "SELECT DISTINCT IndicatorCode FROM Indicators WHERE IndicatorName = 'Rural population'",
        "amends": [
            "Do select `IndicatorCode` instead of `code` and use `DISTINCT` instead of omitting it. Do filter on `IndicatorName = 'Rural population'` instead of `name = 'Urban population'` to correct both the column reference and the filter value. The amended query now correctly retrieves distinct indicator codes for rural population instead of urban population codes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT code FROM indicators WHERE name = 'Urban population';",
            "SELECT DISTINCT IndicatorCode FROM Indicators WHERE IndicatorName = 'Rural population';"
        ],
        "rule_sql": []
    },
    "1284": {
        "db_id": "law_episode",
        "question": "What are the keywords of the episode which received the 2nd-highest number of votes?",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.votes NOT IN ( SELECT MAX(T1.votes) FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id ) ORDER BY T1.votes DESC LIMIT 1",
        "amends": [
            "Do select `T2.keyword` from the `Keyword` table instead of `keywords` from the `episodes` table. Do add an `INNER JOIN` between `Episode AS T1` and `Keyword AS T2` on `T1.episode_id = T2.episode_id` instead of querying a single table. Do add a `WHERE` filter with `T1.votes NOT IN` a subquery that finds the maximum votes instead of no filtering. Do include a correlated subquery to exclude the highest-voted episode instead of simply taking the second highest. Do order by `T1.votes DESC` with proper table qualification instead of just `votes DESC`. Do use `LIMIT 1` without `OFFSET 1` since the filtering already excludes the top result instead of using offset to skip the first row. The amended query now correctly finds the keyword from the second highest-voted episode by excluding the maximum votes through proper join and subquery logic.",
            "Do reference `T1.votes` in the subquery's `MAX` function instead of using unqualified `votes` to avoid ambiguity. Do add the same `INNER JOIN` between `Episode` and `Keyword` tables in the subquery instead of omitting it to ensure the subquery considers only episodes that have keywords. The amended query now correctly identifies keywords from episodes with votes that are not the maximum among episodes with keywords, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keywords FROM episodes ORDER BY votes DESC LIMIT 1 OFFSET 1;",
            "SELECT T2.keyword\nFROM Episode AS T1\nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id\nWHERE T1.votes NOT IN (\n    SELECT MAX(votes) \n    FROM Episode\n)\nORDER BY T1.votes DESC\nLIMIT 1;",
            "SELECT T2.keyword\nFROM Episode AS T1\nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id\nWHERE T1.votes NOT IN (\n    SELECT MAX(T3.votes)\n    FROM Episode AS T3\n    INNER JOIN Keyword AS T4 ON T3.episode_id = T4.episode_id\n)\nORDER BY T1.votes DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1308": {
        "db_id": "law_episode",
        "question": "In which region were the assistant location managers born?",
        "ground_truth": "SELECT T2.birth_region FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T1.role = 'president of NBC West Coast'",
        "amends": [
            "Do select `T2.birth_region` instead of `region`. Do use `FROM Credit AS T1 INNER JOIN Person AS T2` instead of `FROM assistant_location_managers`. Do apply join condition `ON T2.person_id = T1.person_id` instead of no join condition. Do add filter `WHERE T1.role = 'president of NBC West Coast'` instead of `WHERE birth_place = region`. The amended query now correctly retrieves birth regions from joined tables with proper filtering instead of the incorrect self-comparison in the original."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM assistant_location_managers WHERE birth_place = region;",
            "SELECT DISTINCT T2.birth_region\nFROM Credit AS T1\nINNER JOIN Person AS T2 ON T2.person_id = T1.person_id\nWHERE T1.role = 'president of NBC West Coast'"
        ],
        "rule_sql": []
    },
    "6872": {
        "db_id": "retails",
        "question": "What is the total quantity available by all suppliers for the part \"hot spring dodger dim light\"?",
        "ground_truth": "SELECT SUM(T1.ps_availqty) FROM partsupp AS T1 INNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey WHERE T2.p_name = 'hot spring dodger dim light'",
        "amends": [
            "Do join `partsupp AS T1` and `part AS T2` with `INNER JOIN` on `T1.ps_partkey = T2.p_partkey` instead of querying only the `parts` table. Do reference the quantity column as `T1.ps_availqty` instead of `quantity` from the wrong table. Do filter on `T2.p_name` instead of `part_name` to correctly identify the part by name. The amended query now correctly aggregates available quantities from the partsupp table joined with part information, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) FROM parts WHERE part_name = 'hot spring dodger dim light';",
            "SELECT SUM(T1.ps_availqty) AS total_quantity\nFROM partsupp AS T1\nINNER JOIN part AS T2 ON T1.ps_partkey = T2.p_partkey\nWHERE T2.p_name = 'hot spring dodger dim light'"
        ],
        "rule_sql": []
    },
    "854": {
        "db_id": "cs_semester",
        "question": "Which course is more difficult, Intro to BlockChain or Computer Network?",
        "ground_truth": "SELECT name FROM course WHERE name = 'Intro to BlockChain' OR name = 'Computer Network' ORDER BY diff DESC LIMIT 1",
        "amends": [
            "Do select `name` instead of `course_name` and `difficulty_level`. Do reference table `course` instead of `courses`. Do use column `diff` for ordering instead of `difficulty_level`. Do remove the `difficulty_level` column from the SELECT list instead of including it. The amended query now correctly selects only the course name from the course table, filters for the specified course names, orders by the difficulty column, and returns the single highest difficulty result matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name, difficulty_level FROM courses WHERE course_name = 'Intro to BlockChain' OR course_name = 'Computer Network' ORDER BY difficulty_level DESC LIMIT 1;",
            "SELECT name FROM course WHERE name IN ('Intro to BlockChain', 'Computer Network') ORDER BY diff DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3576": {
        "db_id": "authors",
        "question": "What is the affiliation of the author writing in the journal 'A combined search for the standard model Higgs boson at s = 1.96 \u00c2 TeV'?",
        "ground_truth": "SELECT T1.Affiliation FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE T2.Title = 'A combined search for the standard model Higgs boson at s = 1.96 \u00c2 TeV'",
        "amends": [
            "Do select `T1.Affiliation` instead of `author` from the result set. Do join `PaperAuthor AS T1` with `Paper AS T2` using `INNER JOIN` on `T1.PaperId = T2.Id` instead of querying only the `papers` table. Do filter on `T2.Title` instead of `journal` column with the same search string value. Do remove the incorrect table reference `papers` and instead use the proper join between `PaperAuthor` and `Paper` tables to establish the relationship between authors and paper titles."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM papers WHERE journal = 'A combined search for the standard model Higgs boson at s = 1.96 \u00c2 TeV'",
            "SELECT T1.Affiliation \nFROM PaperAuthor AS T1 \nINNER JOIN Paper AS T2 ON T1.PaperId = T2.Id \nWHERE T2.Title = 'A combined search for the standard model Higgs boson at s = 1.96 \u00c2 TeV'"
        ],
        "rule_sql": []
    },
    "8615": {
        "db_id": "chicago_crime",
        "question": "Give the neighborhood name of West Englewood community.",
        "ground_truth": "SELECT T1.neighborhood_name FROM Neighborhood AS T1 INNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no WHERE T2.community_area_name = 'West Englewood'",
        "amends": [
            "Do select `T1.neighborhood_name` instead of `name` and use table aliases `T1` and `T2` instead of direct table references. Do add `INNER JOIN Community_Area AS T2` instead of querying only the neighborhoods table. Do join on `T1.community_area_no = T2.community_area_no` instead of the missing join condition. Do filter on `T2.community_area_name = 'West Englewood'` instead of `community = 'West Englewood'` to correctly reference the community area name from the joined table. The amended query now properly joins the Neighborhood and Community_Area tables to filter by community area name and returns the correct neighborhood names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM neighborhoods WHERE community = 'West Englewood';",
            "SELECT T1.neighborhood_name \nFROM Neighborhood AS T1\nINNER JOIN Community_Area AS T2 ON T1.community_area_no = T2.community_area_no\nWHERE T2.community_area_name = 'West Englewood'"
        ],
        "rule_sql": []
    },
    "8868": {
        "db_id": "cookbook",
        "question": "How many calories does the recipe \"Raspberry Chiffon Pie\" contain?",
        "ground_truth": "SELECT T2.calories FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Raspberry Chiffon Pie'",
        "amends": [
            "Do join `Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id` instead of querying only the `recipes` table. Do select `T2.calories` from the joined `Nutrition` table instead of `calories` from a single table. Do filter on `T1.title = 'Raspberry Chiffon Pie'` instead of `recipe_name = 'Raspberry Chiffon Pie'` to use the correct column name from the Recipe table. The amended query now correctly retrieves nutrition data by joining the Recipe and Nutrition tables on their relationship key."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT calories FROM recipes WHERE recipe_name = 'Raspberry Chiffon Pie';",
            "SELECT T2.calories \nFROM Recipe AS T1 \nINNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id \nWHERE T1.title = 'Raspberry Chiffon Pie'"
        ],
        "rule_sql": []
    },
    "9157": {
        "db_id": "movie_3",
        "question": "Give the name of the manager staff for store No.1.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM staff AS T1 INNER JOIN store AS T2 ON T1.store_id = T2.store_id WHERE T2.store_id = 1",
        "amends": [
            "Do add table alias `T1` for the `staff` table and explicitly reference columns as `T1.first_name` and `T1.last_name` instead of using unqualified column names. Do add an `INNER JOIN` with the `store` table aliased as `T2` on the condition `T1.store_id = T2.store_id` instead of querying only the `staff` table. Do change the filter to reference `T2.store_id = 1` instead of filtering on `store_id` directly from the staff table. Do remove the `position = 'Manager'` filter condition instead of keeping it, as the right query does not include this qualification. The amended query now correctly joins with the store table to validate store existence and matches the right SQL's behavior of returning all staff members from store 1 regardless of position."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM staff WHERE store_id = 1 AND position = 'Manager';",
            "SELECT T1.first_name, T1.last_name\nFROM staff T1\nINNER JOIN store T2 ON T1.store_id = T2.store_id\nWHERE T2.store_id = 1"
        ],
        "rule_sql": []
    },
    "9023": {
        "db_id": "bike_share_1",
        "question": "List down the trips in which their start and end station are similar. Give me their trip IDs and location coordinates.",
        "ground_truth": "SELECT T1.id, T2.lat, T2.long FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.start_station_name = T1.end_station_name",
        "amends": [
            "Do select `T1.id`, `T2.lat`, and `T2.long` instead of `trip_id`, `start_station_lat`, `start_station_lng`, `end_station_lat`, and `end_station_lng`. Do use `FROM trip AS T1` instead of `FROM trips`. Do add `LEFT JOIN station AS T2` instead of omitting the join. Do use join condition `ON T2.name = T1.start_station_name` instead of no join condition. Do use filter `T1.start_station_name = T1.end_station_name` instead of `start_station_id = end_station_id`. The amended query now correctly retrieves station coordinates by joining with the station table and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT trip_id, start_station_lat, start_station_lng, end_station_lat, end_station_lng \nFROM trips \nWHERE start_station_id = end_station_id;",
            "SELECT T1.id, T2.lat, T2.long\nFROM trip AS T1\nLEFT JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.start_station_name = T1.end_station_name"
        ],
        "rule_sql": []
    },
    "9319": {
        "db_id": "movie_3",
        "question": "What is the city with the most customers?",
        "ground_truth": "SELECT T.city FROM ( SELECT T1.city, COUNT(T3.customer_id) AS num FROM city AS T1 INNER JOIN address AS T2 ON T2.city_id = T1.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id GROUP BY T1.city ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do add table joins with `INNER JOIN address AS T2 ON T2.city_id = T1.city_id` and `INNER JOIN customer AS T3 ON T2.address_id = T3.address_id` instead of querying only the `customers` table. Do use `COUNT(T3.customer_id)` with an explicit column reference instead of `COUNT(*)` to count actual customer records. Do include a subquery alias `AS T` and reference `T.num` in the `ORDER BY` clause instead of directly using `COUNT(*)` in the outer query. Do specify the full table structure with `city AS T1` instead of assuming a simple `customers` table with city information. The amended query now correctly joins the necessary tables to count customers per city and matches the RIGHT_SQL's behavior.",
            "Do wrap the entire query in a subquery and select only `T.city` instead of selecting both `T1.city` and `COUNT(T3.customer_id)` directly. Do maintain the same `INNER JOIN` structure on `T2.city_id = T1.city_id` and `T2.address_id = T3.address_id` instead of changing the join conditions. Do keep the `GROUP BY T1.city` unchanged instead of modifying the grouping. Do move the `ORDER BY num DESC LIMIT 1` to the outer query instead of applying it directly to the grouped results, ensuring the ordering and limiting happens after aggregation. The amended query now correctly returns only the city name with the highest customer count instead of both the city and count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) FROM customers GROUP BY city ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.city, COUNT(T3.customer_id) AS num\nFROM city AS T1\nINNER JOIN address AS T2 ON T2.city_id = T1.city_id\nINNER JOIN customer AS T3 ON T2.address_id = T3.address_id\nGROUP BY T1.city\nORDER BY num DESC\nLIMIT 1",
            "SELECT T.city\nFROM (\n    SELECT T1.city, COUNT(T3.customer_id) AS num\n    FROM city AS T1\n    INNER JOIN address AS T2 ON T2.city_id = T1.city_id\n    INNER JOIN customer AS T3 ON T2.address_id = T3.address_id\n    GROUP BY T1.city\n) AS T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6707": {
        "db_id": "retails",
        "question": "How many items that were shipped via air were returned in 1994?",
        "ground_truth": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_returnflag = 'R' AND l_shipmode = 'AIR' AND STRFTIME('%Y', l_shipdate) = '1994'",
        "amends": [
            "Do select `COUNT(l_linenumber)` instead of `COUNT(*)` to count specific non-null values. Do query from `lineitem` table instead of `orders` to access the correct data source. Do use `l_returnflag = 'R'` instead of `return_flag = 'Y'` to match the correct return flag column and value. Do use `l_shipmode = 'AIR'` instead of `ship_mode = 'air'` with proper case sensitivity and column name. Do filter by `STRFTIME('%Y', l_shipdate) = '1994'` instead of `order_date LIKE '1994%'` to properly extract the year from the ship date column using a date function rather than string matching. The amended query now correctly counts line items with return flag 'R' shipped by air in 1994."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE ship_mode = 'air' AND return_flag = 'Y' AND order_date LIKE '1994%';",
            "SELECT COUNT(l_linenumber) \nFROM lineitem \nWHERE l_returnflag = 'R' \nAND l_shipmode = 'AIR' \nAND STRFTIME('%Y', l_shipdate) = '1994'"
        ],
        "rule_sql": []
    },
    "4694": {
        "db_id": "disney",
        "question": "Describe the voice actors and villains in Cinderella.",
        "ground_truth": "SELECT T1.`voice-actor`, T2.villian FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T1.movie = T2.movie_title WHERE T2.movie_title = 'Cinderella'",
        "amends": [
            "Do select `voice-actor` and `villian` instead of `voice_actors.name` and `villains.name`. Do use `voice-actors` AS T1 and `characters` AS T2 instead of `cinderella_characters`. Do add `INNER JOIN` on `T1.movie = T2.movie_title` instead of no join condition. Do move the filter to `WHERE T2.movie_title = 'Cinderella'` instead of `WHERE movie = 'Cinderella'`. The amended query now correctly joins voice actors with characters by movie and filters for the specific movie title, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT voice_actors.name, villains.name FROM cinderella_characters WHERE movie = 'Cinderella';",
            "SELECT T1.\"voice-actor\", T2.villian \nFROM \"voice-actors\" AS T1 \nINNER JOIN characters AS T2 ON T1.movie = T2.movie_title \nWHERE T2.movie_title = 'Cinderella'"
        ],
        "rule_sql": []
    },
    "7920": {
        "db_id": "music_platform_2",
        "question": "Provide the itunes id and url for podcast titled 'Brown Suga Diaries'.",
        "ground_truth": "SELECT itunes_id, itunes_url FROM podcasts WHERE title = 'Brown Suga Diaries'",
        "amends": [
            "Do select `itunes_url` instead of `url` in the SELECT list to reference the correct column name. Do use the filter condition `title = 'Brown Suga Diaries'` instead of `title = 'Brown Sugar Diaries'` to match the exact podcast title spelling. The amended query now correctly retrieves the iTunes ID and iTunes URL for the specified podcast title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT itunes_id, url FROM podcasts WHERE title = 'Brown Sugar Diaries';",
            "SELECT itunes_id, itunes_url FROM podcasts WHERE title = 'Brown Suga Diaries';"
        ],
        "rule_sql": []
    },
    "4646": {
        "db_id": "disney",
        "question": "Wolfgang Reitherman has directed several Disney movies, which one has the highest grossing after accounting for inflation?",
        "ground_truth": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman' ORDER BY CAST(REPLACE(SUBSTR(inflation_adjusted_gross, 2), ',', '') AS REAL) DESC LIMIT 1",
        "amends": [
            "Do select `movie_title` from the `movies_total_gross` table instead of `title` and `gross_inflation_adjusted` from `disney_movies`. Do join with `director` table using `INNER JOIN` on `movie_title = name` instead of querying a single table. Do filter on `director = 'Wolfgang Reitherman'` in the joined table instead of filtering directly on the main table. Do order by a complex expression `CAST(REPLACE(SUBSTR(inflation_adjusted_gross, 2), ',', '') AS REAL)` instead of simply `gross_inflation_adjusted`. The amended query now correctly joins the necessary tables and handles numeric conversion of the formatted gross value, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, gross_inflation_adjusted \nFROM disney_movies \nWHERE director = 'Wolfgang Reitherman' \nORDER BY gross_inflation_adjusted DESC \nLIMIT 1;",
            "SELECT m.movie_title \nFROM movies_total_gross m\nINNER JOIN director d ON m.movie_title = d.name\nWHERE d.director = 'Wolfgang Reitherman'\nORDER BY CAST(REPLACE(SUBSTR(m.inflation_adjusted_gross, 2), ',', '') AS REAL) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3098": {
        "db_id": "cars",
        "question": "What is the name of the most expensive car that was produced by the USA?",
        "ground_truth": "SELECT T4.car_name FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE T3.country = 'USA' ORDER BY T1.price DESC LIMIT 1",
        "amends": [
            "Do select `T4.car_name` instead of `name` and change the sort order to `DESC` instead of `ASC`. Do add joins to `price AS T1`, `production AS T2`, `country AS T3`, and `data AS T4` instead of querying only `cars`. Do use join conditions `T1.ID = T2.ID`, `T3.origin = T2.country`, and `T4.ID = T1.ID` instead of no joins. Do filter on `T3.country = 'USA'` instead of `country = 'USA'` and reference the price from `T1.price` instead of an unspecified source. The amended query now correctly joins multiple tables to find the highest-priced car from the USA."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cars WHERE country = 'USA' ORDER BY price ASC LIMIT 1;",
            "SELECT T4.car_name\nFROM price AS T1\nJOIN production AS T2 ON T1.ID = T2.ID\nJOIN country AS T3 ON T3.origin = T2.country\nJOIN data AS T4 ON T4.ID = T1.ID\nWHERE T3.country = 'USA'\nORDER BY T1.price DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8832": {
        "db_id": "food_inspection",
        "question": "Provide the names, risk categories and descriptions for the eateries with violation type ID of 103111.",
        "ground_truth": "SELECT T2.name, T1.risk_category, T1.description FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.violation_type_id = '103111'",
        "amends": [
            "Do select `T2.name` instead of `name` to specify the source table. Do select `T1.risk_category` and `T1.description` instead of `risk_category` and `description` to qualify columns with table aliases. Do use `FROM violations AS T1 INNER JOIN businesses AS T2` instead of `FROM eateries` to join two tables instead of querying a single table. Do use join condition `ON T1.business_id = T2.business_id` instead of no join condition. Do filter on `T1.violation_type_id = '103111'` instead of `violation_type = 103111` to use the correct column name and string comparison instead of numeric comparison. The amended query now correctly joins the violations and businesses tables to retrieve the requested information."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, risk_category, description FROM eateries WHERE violation_type = 103111",
            "SELECT T2.name, T1.risk_category, T1.description FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.violation_type_id = '103111'"
        ],
        "rule_sql": []
    },
    "5139": {
        "db_id": "address",
        "question": "Which CBSAs have more than 10 zip codes?",
        "ground_truth": "SELECT T1.CBSA_name FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA GROUP BY T1.CBSA HAVING COUNT(T2.zip_code) > 10",
        "amends": [
            "Do select `CBSA_name` instead of `cbsa_name` and `zip_count`. Do use `FROM CBSA AS T1 INNER JOIN zip_data AS T2` instead of `FROM cbsa_zip_mapping`. Do join on `T1.CBSA = T2.CBSA` instead of no join condition. Do group by `T1.CBSA` instead of `cbsa_name`. Do use `COUNT(T2.zip_code) > 10` in HAVING instead of `zip_count <= 10`. The amended query now correctly joins the CBSA and zip_data tables and filters for CBSAs with more than 10 zip codes, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T2.zip_code) AS zip_count` from the SELECT list instead of including it, as the RIGHT_SQL only returns the CBSA_name column. The FROM clause with `INNER JOIN` on `T1.CBSA = T2.CBSA` remains unchanged, as does the GROUP BY on `T1.CBSA` and the HAVING filter `COUNT(T2.zip_code) > 10`. The amended query now correctly returns only CBSA names instead of both names and counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT cbsa_name, COUNT(zip_code) as zip_count FROM cbsa_zip_mapping GROUP BY cbsa_name HAVING zip_count <= 10;",
            "SELECT T1.CBSA_name, COUNT(T2.zip_code) AS zip_count\nFROM CBSA AS T1\nINNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA\nGROUP BY T1.CBSA\nHAVING COUNT(T2.zip_code) > 10",
            "SELECT T1.CBSA_name\nFROM CBSA AS T1\nINNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA\nGROUP BY T1.CBSA\nHAVING COUNT(T2.zip_code) > 10"
        ],
        "rule_sql": []
    },
    "4672": {
        "db_id": "disney",
        "question": "What is the highest grossing movie without a song?",
        "ground_truth": "SELECT T1.movie_title FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title WHERE T2.song IS NULL ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "amends": [
            "Do select `T1.movie_title` instead of `title, gross`. Do use `movies_total_gross AS T1` instead of `movies` and add `INNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title` instead of omitting the join. Do filter on `T2.song IS NULL` instead of `song_id IS NULL`. Do order by `CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC` instead of `gross DESC`. The amended query now correctly joins the necessary tables, handles the dollar sign and comma formatting in the gross amount, and filters on the appropriate song column to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, gross FROM movies WHERE song_id IS NULL ORDER BY gross DESC LIMIT 1;",
            "SELECT T1.movie_title\nFROM movies_total_gross AS T1\nINNER JOIN characters AS T2 ON T2.movie_title = T1.movie_title\nWHERE T2.song IS NULL\nORDER BY CAST(REPLACE(TRIM(T1.total_gross, '$'), ',', '') AS REAL) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3287": {
        "db_id": "donor",
        "question": "How many Rock Hill City School projects have teacher donors?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.teacher_acctid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.school_city = 'Rock Hill' AND is_teacher_acct = 't'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.teacher_acctid)` instead of `COUNT(*)` to count unique teachers rather than all projects. Do join `donations AS T2` with `INNER JOIN` on `T1.projectid = T2.projectid` instead of querying only the `projects` table. Do filter on `T1.school_city = 'Rock Hill'` instead of `city = 'Rock Hill'` using the correct column name. Do use `is_teacher_acct = 't'` instead of `school_type = 'City School' AND teacher_donor IS NOT NULL` to properly identify teacher accounts. Do remove the unnecessary `teacher_donor IS NOT NULL` condition since the join with donations table ensures donation existence. The amended query now correctly counts distinct teacher accounts from Rock Hill who have made donations, matching the intended behavior.",
            "Do count distinct `T1.teacher_acctid` instead of `T2.donor_acctid` in the SELECT list. Do reference `is_teacher_acct` without table alias instead of `T2.is_teacher_acct` in the WHERE clause. The amended query now correctly counts unique teacher account IDs from the projects table rather than donor account IDs from donations, ensuring accurate teacher identification while maintaining the same join logic and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM projects WHERE city = 'Rock Hill' AND school_type = 'City School' AND teacher_donor IS NOT NULL",
            "SELECT COUNT(DISTINCT T2.donor_acctid) \nFROM projects AS T1 \nINNER JOIN donations AS T2 ON T1.projectid = T2.projectid \nWHERE T1.school_city = 'Rock Hill' \nAND T2.is_teacher_acct = 't'",
            "SELECT COUNT(DISTINCT T1.teacher_acctid) \nFROM projects AS T1\nINNER JOIN donations AS T2 ON T1.projectid = T2.projectid\nWHERE T1.school_city = 'Rock Hill' \nAND is_teacher_acct = 't'"
        ],
        "rule_sql": []
    },
    "3496": {
        "db_id": "video_games",
        "question": "List down the name of strategy games.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T2.genre_name = 'Strategy'",
        "amends": [
            "Do select `T1.game_name` instead of `name` and use table alias `T1` instead of direct column reference. Do add `INNER JOIN genre AS T2` instead of querying only the `games` table. Do use join condition `T1.genre_id = T2.id` instead of direct genre comparison. Do filter on `T2.genre_name = 'Strategy'` instead of `genre = 'Strategy'` to properly reference the normalized genre table. The amended query now correctly joins the game and genre tables to filter by genre name through the relationship rather than assuming a denormalized structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE genre = 'Strategy';",
            "SELECT T1.game_name \nFROM game AS T1 \nINNER JOIN genre AS T2 ON T1.genre_id = T2.id \nWHERE T2.genre_name = 'Strategy'"
        ],
        "rule_sql": []
    },
    "1303": {
        "db_id": "law_episode",
        "question": "What is the title of the episodes that were least enjoyed?",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T2.stars = 1",
        "amends": [
            "Do specify `T1.title` with table alias instead of just `title` without qualification. Do add `INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id` instead of omitting the Vote table join. Do add `WHERE T2.stars = 1` filter instead of omitting the stars condition. Do remove `ORDER BY rating DESC LIMIT 1` instead of keeping the rating-based ordering and limit, as the right query filters for specific star ratings rather than finding the highest rated episode. The amended query now correctly filters for episodes with one-star votes instead of finding the highest-rated episode."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY rating DESC LIMIT 1;",
            "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T2.stars = 1"
        ],
        "rule_sql": []
    },
    "2811": {
        "db_id": "professional_basketball",
        "question": "In what year did the only team to beat the Houston in the final round of postseason series games earn its lowest ranking?",
        "ground_truth": "SELECT T2.year FROM series_post AS T1 INNER JOIN teams AS T2 ON T1.tmIDWinner = T2.tmID WHERE T1.round = 'DSF' AND T1.tmIDLoser = 'HSM' ORDER BY T2.rank ASC LIMIT 1",
        "amends": [
            "Do select `T2.year` from `series_post AS T1` instead of `year` from `teams` alone. Do use `INNER JOIN` on `T1.tmIDWinner = T2.tmID` instead of no join condition. Do filter with `T1.round = 'DSF'` and `T1.tmIDLoser = 'HSM'` instead of `team_name = 'Houston'` and `ranking = (SELECT MIN(ranking)...`. Do remove the subquery for minimum ranking and instead add `ORDER BY T2.rank ASC LIMIT 1` to get the top-ranked result. Do omit the `postseason_round = 'final'` filter and replace it with the correct series round condition. The amended query now correctly retrieves the year from the winning team in division series finals where Houston was the loser, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM teams WHERE team_name = 'Houston' AND ranking = (SELECT MIN(ranking) FROM teams WHERE team_name = 'Houston') AND postseason_round = 'final'",
            "SELECT T2.year \nFROM series_post AS T1 \nINNER JOIN teams AS T2 ON T1.tmIDWinner = T2.tmID \nWHERE T1.round = 'DSF' AND T1.tmIDLoser = 'HSM' \nORDER BY T2.rank ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "393": {
        "db_id": "retail_complains",
        "question": "In the complains received in 2012, how many of them are submitted through email?",
        "ground_truth": "SELECT COUNT(`Submitted via`) FROM events WHERE strftime('%Y', `Date received`) = '2012' AND `Submitted via` = 'Email'",
        "amends": [
            "Do count `Submitted via` instead of `*` to count non-null values in the specific column rather than all rows. Do query from `events` instead of `complains` to use the correct table name. Do filter by `strftime('%Y', Date received) = '2012'` instead of `year = 2012` to extract the year from a date field rather than using a non-existent year column. Do filter by `Submitted via = 'Email'` instead of `submission_method = 'email'` to use the correct column name and match the exact case-sensitive value 'Email'. The amended query now correctly counts email submissions from 2012 using the proper table structure and date handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complains WHERE year = 2012 AND submission_method = 'email';",
            "SELECT COUNT(\"Submitted via\") FROM events WHERE strftime('%Y', \"Date received\") = '2012' AND \"Submitted via\" = 'Email';"
        ],
        "rule_sql": []
    },
    "7512": {
        "db_id": "image_and_language",
        "question": "What is the unique id number identifying the onion object class?",
        "ground_truth": "SELECT OBJ_CLASS_ID FROM OBJ_CLASSES WHERE OBJ_CLASS = 'onion'",
        "amends": [
            "Do select `OBJ_CLASS_ID` instead of `onion_id` and do query from `OBJ_CLASSES` instead of `onion_objects`. Do filter on `OBJ_CLASS = 'onion'` instead of `class = 'unique'`. The amended query now correctly retrieves class identifiers from the appropriate table using the proper filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT onion_id FROM onion_objects WHERE class = 'unique';",
            "SELECT OBJ_CLASS_ID FROM OBJ_CLASSES WHERE OBJ_CLASS = 'onion'"
        ],
        "rule_sql": []
    },
    "368": {
        "db_id": "retail_complains",
        "question": "Among the clients in Middle Atlantic, how many are them are female and no more than 18 years old?",
        "ground_truth": "SELECT COUNT(T1.sex) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.division = 'Middle Atlantic' AND T1.sex = 'Female' AND T1.age < 18",
        "amends": [
            "Do count `T1.sex` instead of `COUNT(*)` to count specific non-null values. Do use `client AS T1` instead of `clients` with proper table alias. Do add `INNER JOIN district AS T2` instead of omitting the district table entirely. Do join on `T1.district_id = T2.district_id` instead of missing the join condition. Do filter on `T2.division = 'Middle Atlantic'` instead of `region = 'Middle Atlantic'` to use the correct table and column. Do use `T1.sex = 'Female'` instead of `gender = 'Female'` with proper table reference. Do change the age filter to `T1.age < 18` instead of `age > 18` to capture the correct age range. The amended query now correctly counts female clients under 18 in the Middle Atlantic division by properly joining the district table and using the correct filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE region = 'Middle Atlantic' AND gender = 'Female' AND age > 18;",
            "SELECT COUNT(T1.sex) \nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.division = 'Middle Atlantic'\nAND T1.sex = 'Female'\nAND T1.age < 18"
        ],
        "rule_sql": []
    },
    "853": {
        "db_id": "social_media",
        "question": "Tweets posted from which city has a higher number of average likes, Bangkok or Chiang Mai?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.City = 'Bangkok' THEN Likes ELSE NULL END) / COUNT(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE 0 END) AS bNum , SUM(CASE WHEN City = 'Chiang Mai' THEN Likes ELSE NULL END) / COUNT(CASE WHEN City = 'Chiang Mai' THEN TweetID ELSE NULL END) AS cNum FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.City IN ('Bangkok', 'Chiang Mai')",
        "amends": [
            "Do use a completely different SELECT list with calculated ratios `bNum` and `cNum` instead of simple `AVG(likes)` as `avg_likes`. Do add table `twitter AS T1` and `location AS T2` with `INNER JOIN` on `T1.LocationID = T2.LocationID` instead of querying a single table. Do move the city filter to the WHERE clause on `T2.City` instead of filtering directly on city. Do remove GROUP BY and ORDER BY/LIMIT clauses instead of grouping by city and ordering by average. Do use conditional aggregation with CASE statements for Bangkok and Chiang Mai calculations instead of simple averages. Do include proper NULL handling in COUNT expressions instead of simple counting. The amended query now correctly calculates separate average ratios for each city using proper table joins and conditional logic.",
            "Do use `SUM` instead of `COUNT` for aggregating `Likes` values in both city calculations. Do change the denominator for Bangkok from `COUNT(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE NULL END)` to `COUNT(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE 0 END)` to properly handle zero counts. Do change the denominator for Chiang Mai from `COUNT(CASE WHEN T2.City = 'Chiang Mai' THEN 1 ELSE NULL END)` to `COUNT(CASE WHEN City = 'Chiang Mai' THEN TweetID ELSE NULL END)` to use a specific column for counting. Do remove the `* 1.0` multiplication since division between numeric types will naturally produce a decimal result. Do reference `City` directly without table alias in the Chiang Mai conditions instead of using `T2.City`. The amended query now correctly calculates average likes for each city while properly handling count denominators and avoiding unnecessary type conversions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, AVG(likes) as avg_likes FROM tweets WHERE city IN ('Bangkok', 'Chiang Mai') GROUP BY city ORDER BY avg_likes DESC LIMIT 1;",
            "SELECT \n    COUNT(CASE WHEN T2.City = 'Bangkok' THEN T1.Likes ELSE NULL END) * 1.0 / COUNT(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE NULL END) AS bNum,\n    COUNT(CASE WHEN T2.City = 'Chiang Mai' THEN T1.Likes ELSE NULL END) * 1.0 / COUNT(CASE WHEN T2.City = 'Chiang Mai' THEN 1 ELSE NULL END) AS cNum\nFROM twitter AS T1\nINNER JOIN location AS T2 ON T1.LocationID = T2.LocationID\nWHERE T2.City IN ('Bangkok', 'Chiang Mai')",
            "SELECT \n    SUM(CASE WHEN T2.City = 'Bangkok' THEN T1.Likes ELSE 0 END) * 1.0 / COUNT(CASE WHEN T2.City = 'Bangkok' THEN 1 ELSE 0 END) AS bNum,\n    SUM(CASE WHEN City = 'Chiang Mai' THEN T1.Likes ELSE 0 END) * 1.0 / COUNT(CASE WHEN City = 'Chiang Mai' THEN TweetID ELSE NULL END) AS cNum\nFROM twitter AS T1\nINNER JOIN location AS T2 ON T1.LocationID = T2.LocationID\nWHERE T2.City IN ('Bangkok', 'Chiang Mai')"
        ],
        "rule_sql": []
    },
    "4452": {
        "db_id": "student_loan",
        "question": "Which school has the highest number of disabled students?",
        "ground_truth": "SELECT T.school FROM ( SELECT T2.school, COUNT(T2.name) AS num FROM disabled AS T1 INNER JOIN enrolled AS T2 ON T1.name = T2.name GROUP BY T2.school ) T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use a subquery with aliases `T` and `T2` instead of querying the `students` table directly. Do join `disabled AS T1` with `enrolled AS T2` on `T1.name = T2.name` instead of filtering by `disability_status = 'disabled'`. Do select `T2.school` and count `T2.name` as `num` instead of selecting `school_name` and counting all rows. Do group by `T2.school` instead of `school_name`. Do order by `T.num` instead of `disabled_count`. The amended query now correctly identifies disabled students through a join with the disabled table and counts them per school from the enrolled table, matching the RIGHT_SQL's behavior.",
            "Do wrap the main query in a subquery `T` instead of querying directly from joined tables. Do keep the `SELECT T2.school, COUNT(T2.name) AS num` in the inner query instead of selecting it in the outer query. Do maintain the `INNER JOIN` on `T1.name = T2.name` instead of using a plain `JOIN`. Do preserve the `GROUP BY T2.school` grouping. Do change the outer query to select only `T.school` instead of both school and count. Do order by `T.num DESC` in the outer query instead of ordering by the alias directly. Do keep the `LIMIT 1` to return the top result. The amended query now correctly returns only the school with the highest count of disabled enrolled students through proper subquery structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, COUNT(*) as disabled_count FROM students WHERE disability_status = 'disabled' GROUP BY school_name ORDER BY disabled_count DESC LIMIT 1;",
            "SELECT T2.school, COUNT(T2.name) AS num\nFROM disabled AS T1\nJOIN enrolled AS T2 ON T1.name = T2.name\nGROUP BY T2.school\nORDER BY num DESC\nLIMIT 1;",
            "SELECT T.school\nFROM (\n    SELECT T2.school, COUNT(T2.name) AS num\n    FROM disabled AS T1\n    INNER JOIN enrolled AS T2 ON T1.name = T2.name\n    GROUP BY T2.school\n) AS T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4708": {
        "db_id": "disney",
        "question": "Which movies of director Wolfgang Reitherman do not have villain?",
        "ground_truth": "SELECT T1.movie_title FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman' AND T1.villian IS NULL",
        "amends": [
            "Do select `T1.movie_title` instead of `m.title`. Do use `FROM characters AS T1` instead of `FROM movies m`. Do use `INNER JOIN director AS T2` instead of `JOIN directors d`. Do join on `T1.movie_title = T2.name` instead of `m.director_id = d.director_id`. Do filter on `T2.director = 'Wolfgang Reitherman'` instead of `d.director_name = 'Wolfgang Reitherman'`. Do filter on `T1.villian IS NULL` instead of `m.villain IS NULL` (note spelling correction from villain to villian). The amended query now correctly uses the characters and director tables with proper join conditions and column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title \nFROM movies m \nJOIN directors d ON m.director_id = d.director_id \nWHERE d.director_name = 'Wolfgang Reitherman' \nAND m.villain IS NULL;",
            "SELECT T1.movie_title FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE T2.director = 'Wolfgang Reitherman' AND T1.villian IS NULL"
        ],
        "rule_sql": []
    },
    "4758": {
        "db_id": "legislator",
        "question": "How many legislators have an Instagram account?",
        "ground_truth": "SELECT COUNT(*) FROM `social-media` WHERE instagram IS NOT NULL AND instagram <> ''",
        "amends": [
            "Do query the `social-media` table instead of the `legislators` table. Do filter with `instagram IS NOT NULL AND instagram <> ''` instead of `instagram IS NULL`. Do keep the `COUNT(*)` aggregation unchanged. The amended query now correctly counts non-null and non-empty Instagram values from the appropriate social media table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE instagram IS NULL;",
            "SELECT COUNT(*) FROM \"social-media\" WHERE instagram IS NOT NULL AND instagram <> ''"
        ],
        "rule_sql": []
    },
    "2657": {
        "db_id": "regional_sales",
        "question": "State all the order numbers for sales team of Samuel Fowler.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.`Sales Team` = 'Samuel Fowler' THEN T1.OrderNumber ELSE NULL END AS T FROM `Sales Orders` T1 INNER JOIN `Sales Team` T2 ON T2.SalesTeamID = T1._SalesTeamID ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `CASE` expression that returns `OrderNumber` when `T2.Sales Team` = 'Samuel Fowler' instead of directly selecting `order_number` from a single table. Do join `Sales Orders` T1 with `Sales Team` T2 on `T2.SalesTeamID = T1._SalesTeamID` using `INNER JOIN` instead of querying a single `orders` table without any join. Do filter with `WHERE T IS NOT NULL` on the CASE result instead of filtering the source table directly with `WHERE sales_team = 'Samuel Fowler'`. Do add `DISTINCT` in the subquery to eliminate duplicates instead of potentially returning multiple identical order numbers. Do use proper table aliases `T1` and `T2` with qualified column references instead of unqualified column names. The amended query now correctly handles the relationship between sales orders and sales teams through the proper join condition and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_number FROM orders WHERE sales_team = 'Samuel Fowler';",
            "SELECT DISTINCT \n    CASE \n        WHEN T2.\"Sales Team\" = 'Samuel Fowler' THEN T1.OrderNumber \n    END AS OrderNumber\nFROM \"Sales Orders\" T1\nINNER JOIN \"Sales Team\" T2 ON T2.SalesTeamID = T1._SalesTeamID\nWHERE (CASE WHEN T2.\"Sales Team\" = 'Samuel Fowler' THEN T1.OrderNumber END) IS NOT NULL"
        ],
        "rule_sql": []
    },
    "9418": {
        "db_id": "movie_3",
        "question": "Please list the full names of all the customers who live in Italy.",
        "ground_truth": "SELECT T4.first_name, T4.last_name FROM address AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id INNER JOIN customer AS T4 ON T1.address_id = T4.address_id WHERE T3.country = 'Italy'",
        "amends": [
            "Do add `T4.last_name` to the SELECT list instead of only selecting `first_name`. Do change the FROM clause to use multiple INNER JOINs starting from `address AS T1` instead of querying `customers` directly. Do add join conditions `T1.city_id = T2.city_id`, `T2.country_id = T3.country_id`, and `T1.address_id = T4.address_id` instead of no joins. Do change the WHERE filter to use `T3.country = 'Italy'` instead of `country = 'Italy'` to reference the correct table. The amended query now correctly joins through the address, city, and country tables to filter customers by country name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE country = 'Italy';",
            "SELECT T4.first_name, T4.last_name\nFROM address AS T1\nINNER JOIN city AS T2 ON T1.city_id = T2.city_id\nINNER JOIN country AS T3 ON T2.country_id = T3.country_id\nINNER JOIN customer AS T4 ON T1.address_id = T4.address_id\nWHERE T3.country = 'Italy'"
        ],
        "rule_sql": []
    },
    "4611": {
        "db_id": "mental_health_survey",
        "question": "What was the percentage for the answer of \"Yes\" was given to the question \"Has your employer ever formally discussed mental health (for example, as part of a wellness campaign or other official communication)?\"?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN T1.AnswerText LIKE 'Yes' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questiontext LIKE 'Has your employer ever formally discussed mental health (for example, as part of a wellness campaign or other official communication)?'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN T1.AnswerText LIKE 'Yes' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserID)` instead of `COUNT(*) * 100 / (SELECT COUNT(*) FROM survey_responses)` to calculate the percentage based on conditional counting and proper casting. Do join `Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid` instead of querying a single `survey_responses` table to properly relate questions and answers through their IDs. Do filter on `T2.questiontext LIKE 'Has your employer ever formally discussed mental health...'` instead of `question = 'Has your employer...'` to match the question text in the Question table. Do use `T1.AnswerText LIKE 'Yes'` instead of `answer = 'Yes'` to check the answer text in the Answer table. The amended query now correctly handles the relational structure between questions and answers and produces the accurate percentage calculation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM survey_responses) AS percentage\nFROM survey_responses \nWHERE question = 'Has your employer ever formally discussed mental health (for example, as part of a wellness campaign or other official communication)?'\nAND answer = 'Yes';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.AnswerText LIKE 'Yes' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.UserID) AS percentage_yes\nFROM \n    Answer AS T1 \nINNER JOIN \n    Question AS T2 ON T1.QuestionID = T2.questionid\nWHERE \n    T2.questiontext LIKE 'Has your employer ever formally discussed mental health%';"
        ],
        "rule_sql": []
    },
    "104": {
        "db_id": "movie_platform",
        "question": "What was the title of the first list created by a user 85981819? And please provide the user_avatar_image_url.",
        "ground_truth": "SELECT T2.list_title, T1.user_avatar_image_url FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T1.user_id = 85981819 ORDER BY T2.list_creation_timestamp_utc LIMIT 1",
        "amends": [
            "Do select `T2.list_title` and `T1.user_avatar_image_url` instead of `title` and `user_avatar_image_url`. Do join `lists_users AS T1` with `lists AS T2` using `INNER JOIN` on `T1.list_id = T2.list_id` instead of querying only the `lists` table. Do filter on `T1.user_id = 85981819` instead of `user_id = 85981819`. Do order by `T2.list_creation_timestamp_utc` instead of `created_at DESC`. The amended query now correctly joins the user-list relationship table to retrieve the appropriate user's list information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, user_avatar_image_url FROM lists WHERE user_id = 85981819 ORDER BY created_at DESC LIMIT 1;",
            "SELECT T2.list_title, T1.user_avatar_image_url \nFROM lists_users AS T1 \nINNER JOIN lists AS T2 ON T1.list_id = T2.list_id \nWHERE T1.user_id = 85981819 \nORDER BY T2.list_creation_timestamp_utc ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5473": {
        "db_id": "menu",
        "question": "How many menus with the name \"Waldorf Astoria\" have 4 pages?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE name = 'Waldorf Astoria' AND page_count = 4",
        "amends": [
            "Do reference table `Menu` instead of `menus` and use column `page_count` instead of `pages` in the WHERE filter, while maintaining the same COUNT(*) aggregation and filter conditions for name equality and numeric comparison. The amended query now correctly references the intended table and column names while preserving the original counting logic and filter semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menus WHERE name = 'Waldorf Astoria' AND pages = 4;",
            "SELECT COUNT(*) FROM Menu WHERE name = 'Waldorf Astoria' AND page_count = 4"
        ],
        "rule_sql": []
    },
    "7938": {
        "db_id": "music_platform_2",
        "question": "Write all the review content belonging to StormCast: The Official Warhammer Age of Sigmar Podcast.",
        "ground_truth": "SELECT content FROM reviews WHERE podcast_id = ( SELECT podcast_id FROM podcasts WHERE title = 'StormCast: The Official Warhammer Age of Sigmar Podcast' )",
        "amends": [
            "Do filter by `podcast_id` instead of `podcast_name`, using a subquery to first select the `podcast_id` from the `podcasts` table where `title` matches the podcast name instead of directly filtering the `reviews` table by podcast name. This corrects the logic by properly relating reviews to podcasts through their ID relationship rather than assuming the podcast name exists directly in the reviews table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT content FROM reviews WHERE podcast_name = 'StormCast: The Official Warhammer Age of Sigmar Podcast';",
            "SELECT r.content \nFROM reviews r\nWHERE r.podcast_id = (\n    SELECT podcast_id \n    FROM podcasts \n    WHERE title = 'StormCast: The Official Warhammer Age of Sigmar Podcast'\n)"
        ],
        "rule_sql": []
    },
    "1762": {
        "db_id": "restaurant",
        "question": "In restaurants with a review of 2, how many restaurants have a street number below 500?",
        "ground_truth": "SELECT COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.review = 2 AND T1.street_num < 500",
        "amends": [
            "Do join `location AS T1` and `generalinfo AS T2` on `T1.id_restaurant = T2.id_restaurant` instead of querying only the `restaurants` table. Do count `T1.id_restaurant` instead of `COUNT(*)` to ensure accurate counting of distinct restaurant IDs. Do filter on `T2.review = 2` instead of `review = 2` to reference the correct table column. Do filter on `T1.street_num < 500` instead of `street_number < 500` to use the proper column name from the location table. The amended query now correctly joins the necessary tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE review = 2 AND street_number < 500;",
            "SELECT COUNT(T1.id_restaurant) \nFROM location AS T1 \nJOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant \nWHERE T2.review = 2 AND T1.street_num < 500"
        ],
        "rule_sql": []
    },
    "2305": {
        "db_id": "movielens",
        "question": "Who are cast members in an English movie which has a running time equal to 2? Please list their IDs.",
        "ground_truth": "SELECT T2.actorid FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE T1.runningtime = 2 AND T1.isEnglish = 'T'",
        "amends": [
            "Do select `T2.actorid` instead of `actor_id` and use table aliases `T1` and `T2` instead of bare table names. Do join `movies AS T1 INNER JOIN movies2actors AS T2` instead of `movies JOIN cast` with the join condition `ON T1.movieid = T2.movieid` instead of `movies.movie_id = cast.movie_id`. Do filter with `T1.runningtime = 2` instead of `running_time = 2` and `T1.isEnglish = 'T'` instead of `language = 'English'`, using the correct column names and boolean flag format. The amended query now correctly retrieves actor IDs from the proper relationship table with accurate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id FROM movies JOIN cast ON movies.movie_id = cast.movie_id WHERE language = 'English' AND running_time = 2;",
            "SELECT T2.actorid \nFROM movies AS T1 \nINNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid \nWHERE T1.isEnglish = 'T' AND T1.runningtime = 2"
        ],
        "rule_sql": []
    },
    "3954": {
        "db_id": "public_review_platform",
        "question": "Give the number of \"4\" stars Yelp businesses in \"Mesa\" city.",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE stars = 4 AND city = 'Mesa'",
        "amends": [
            "Do count `business_id` instead of `*` to avoid counting NULL values. Do reference table `Business` instead of `yelp_businesses` to use the correct table name. The amended query now correctly counts non-NULL business IDs from the appropriate table while maintaining the same filtering conditions for 4-star businesses in Mesa."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM yelp_businesses WHERE stars = 4 AND city = 'Mesa';",
            "SELECT COUNT(business_id) FROM Business WHERE stars = 4 AND city = 'Mesa';"
        ],
        "rule_sql": []
    },
    "7844": {
        "db_id": "world",
        "question": "List down the languages of the countries that have population below 8000.",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Population < 8000",
        "amends": [
            "Do select `T2.Language` from the `CountryLanguage` table instead of `language` from the `countries` table. Do join `Country AS T1` with `CountryLanguage AS T2` using `INNER JOIN` on `T1.Code = T2.CountryCode` instead of querying a single table. Do filter on `T1.Population < 8000` instead of `population < 8000` to correctly reference the population from the Country table. The amended query now properly joins the Country and CountryLanguage tables to retrieve languages from countries with small populations, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM countries WHERE population < 8000;",
            "SELECT T2.Language \nFROM Country AS T1 \nINNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T1.Population < 8000"
        ],
        "rule_sql": []
    },
    "3916": {
        "db_id": "public_review_platform",
        "question": "List down the business ID with a low review count in Phoenix.",
        "ground_truth": "SELECT business_id FROM Business WHERE city LIKE 'Phoenix' AND review_count LIKE 'Low'",
        "amends": [
            "Do reference table `Business` instead of `businesses` for the correct table name. Do use `LIKE` operator for both `city` and `review_count` conditions instead of `=` and `>` operators. Do filter for `review_count` matching 'Low' instead of values greater than 1000. The amended query now correctly filters for businesses in Phoenix with low review counts as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE city = 'Phoenix' AND review_count > 1000;",
            "SELECT business_id FROM Business WHERE city LIKE 'Phoenix' AND review_count LIKE 'Low'"
        ],
        "rule_sql": []
    },
    "3140": {
        "db_id": "cars",
        "question": "How many Japanese cars weigh more than 2000 lbs?",
        "ground_truth": "SELECT COUNT(*) FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T3.country = 'Japan' AND T1.weight > 2000",
        "amends": [
            "Do add `INNER JOIN production AS T2 ON T1.ID = T2.ID` and `INNER JOIN country AS T3 ON T3.origin = T2.country` instead of querying only the `cars` table. Do change the table reference from `cars` to `data AS T1` instead of using a single table. Do modify the country filter to use `T3.country = 'Japan'` instead of `country = 'Japan'` to reference the joined country table. Do update the weight filter to use `T1.weight > 2000` instead of `weight > 2000` to reference the correct table alias. The amended query now correctly joins the necessary tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'Japan' AND weight > 2000;",
            "SELECT COUNT(*) \nFROM data AS T1\nINNER JOIN production AS T2 ON T1.ID = T2.ID\nINNER JOIN country AS T3 ON T3.origin = T2.country\nWHERE T3.country = 'Japan' AND T1.weight > 2000"
        ],
        "rule_sql": []
    },
    "5695": {
        "db_id": "language_corpus",
        "question": "What is the total pages of Wikipedia in Catalan language?",
        "ground_truth": "SELECT pages FROM langs WHERE lang = 'ca'",
        "amends": [
            "Do select `pages` as a direct column instead of using `SUM(pages)` as an aggregate function. Do reference table `langs` instead of table `wikipedia`. Do filter on `lang = 'ca'` instead of `language = 'Catalan'`. The amended query now correctly retrieves individual page counts for the Catalan language without unnecessary aggregation and uses the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(pages) FROM wikipedia WHERE language = 'Catalan';",
            "SELECT pages FROM langs WHERE lang = 'ca';"
        ],
        "rule_sql": []
    },
    "3752": {
        "db_id": "college_completion",
        "question": "In the state with the highest number of schools, how many institutions have a percentage of no less than 90 of undergraduates who attend full-time? List all of the institutions' names.",
        "ground_truth": "SELECT COUNT(t1.unitid), t1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON t1.state = t2.state WHERE t1.ft_pct > 90 ORDER BY t2.schools_count DESC LIMIT 1",
        "amends": [
            "Do select `COUNT(t1.unitid)` and `t1.chronname` instead of just `name`. Do use `institution_details AS T1` and `state_sector_details AS T2` with an `INNER JOIN` on `t1.state = t2.state` instead of a single `institutions` table with a subquery. Do filter with `t1.ft_pct > 90` instead of `full_time_percentage >= 90`. Do remove the subquery and instead order by `t2.schools_count DESC` instead of ordering by count within a subquery. Do add `LIMIT 1` at the end instead of using it within a subquery. The amended query now correctly joins institution and state data while counting institutions and ordering by state school counts.",
            "Do add `COUNT(t1.unitid)` to the SELECT list instead of omitting it and change the aggregate function from single column selection to counting. Do change the WHERE filter to `t1.ft_pct > 90` instead of `t1.ft_pct >= 90` to use strict inequality. Do remove the subquery that finds the state with maximum schools_count instead of keeping it as a correlated subquery. Do add `ORDER BY t2.schools_count DESC` instead of omitting ordering. Do add `LIMIT 1` to the main query instead of applying it only to the subquery. The amended query now correctly counts institutions with full-time percentage over 90% and returns the one from the state with the highest schools_count, matching the RIGHT_SQL's behavior.",
            "Do place `COUNT(t1.unitid)` first in the SELECT list instead of `t1.chronname` first. Do remove `GROUP BY t2.state` instead of keeping it since the aggregation is not needed with the current query structure. Do add `t1.chronname` to the SELECT list instead of omitting it from the aggregation context. The amended query now matches RIGHT_SQL's behavior by correctly selecting the count and institution name without unnecessary grouping.",
            "Do add `COUNT(t1.unitid)` to the SELECT list instead of omitting it. Do change the WHERE filter to `t1.ft_pct > 90` instead of `t1.ft_pct >= 90`. Do remove the subquery for maximum schools_count instead of keeping it. Do change the ORDER BY to `t2.schools_count DESC` instead of `t1.chronname`. Do add `LIMIT 1` instead of omitting it. The amended query now correctly counts institutions with full-time percentages strictly above 90% and returns the single result with the highest schools_count value.",
            "Do place `COUNT(t1.unitid)` first in the SELECT list instead of `t1.chronname` first. Do maintain the same `INNER JOIN` on `t1.state = t2.state` with identical table aliases. Do preserve the `WHERE t1.ft_pct > 90` filter unchanged. Do keep the `ORDER BY t2.schools_count DESC` and `LIMIT 1` clauses without modification. The amended query now correctly prioritizes the aggregate count in the output while maintaining the same join logic, filtering, and result ordering as the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM institutions WHERE state = (SELECT state FROM institutions GROUP BY state ORDER BY COUNT(*) DESC LIMIT 1) AND full_time_percentage >= 90;",
            "SELECT t1.chronname\nFROM institution_details AS t1\nINNER JOIN state_sector_details AS t2 ON t1.state = t2.state\nWHERE t1.ft_pct >= 90\nAND t2.state = (\n    SELECT state\n    FROM state_sector_details\n    ORDER BY schools_count DESC\n    LIMIT 1\n);",
            "SELECT t1.chronname, COUNT(t1.unitid) \nFROM institution_details AS t1\nINNER JOIN state_sector_details AS t2 ON t1.state = t2.state\nWHERE t1.ft_pct > 90\nGROUP BY t2.state\nORDER BY t2.schools_count DESC\nLIMIT 1",
            "SELECT t1.chronname\nFROM institution_details AS t1\nINNER JOIN state_sector_details AS t2 ON t1.state = t2.state\nWHERE t1.ft_pct >= 90\nAND t2.schools_count = (\n    SELECT MAX(schools_count) \n    FROM state_sector_details\n)\nORDER BY t1.chronname;",
            "SELECT t1.chronname, COUNT(t1.unitid) \nFROM institution_details AS t1\nINNER JOIN state_sector_details AS t2 ON t1.state = t2.state\nWHERE t1.ft_pct > 90\nORDER BY t2.schools_count DESC\nLIMIT 1",
            "SELECT COUNT(t1.unitid), t1.chronname\nFROM institution_details AS t1\nINNER JOIN state_sector_details AS t2 ON t1.state = t2.state\nWHERE t1.ft_pct > 90\nORDER BY t2.schools_count DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4370": {
        "db_id": "student_loan",
        "question": "How many students belong to the navy department?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'navy'",
        "amends": [
            "Do count `name` instead of `*` to count non-null values. Do query from `enlist` table instead of `students` table. Do filter on `organ` column instead of `department` column. The amended query now correctly counts non-null name values from the enlist table where organ equals 'navy', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE department = 'navy';",
            "SELECT COUNT(name) FROM enlist WHERE organ = 'navy'"
        ],
        "rule_sql": []
    },
    "4639": {
        "db_id": "disney",
        "question": "Who is the hero character of the movie whose total gross was $222,527,828?",
        "ground_truth": "SELECT T1.hero FROM characters AS T1 INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie_title WHERE T2.total_gross = '$222,527,828'",
        "amends": [
            "Do select `hero` from `characters AS T1` instead of `movies`, do add `INNER JOIN movies_total_gross AS T2` instead of omitting it, do use join condition `T2.movie_title = T1.movie_title` instead of no join, do filter on `T2.total_gross = '$222,527,828'` instead of `total_gross = 222527828` with proper string formatting and table qualification, and do qualify the column as `T1.hero` instead of just `hero`. The amended query now correctly joins the necessary tables and uses proper string comparison for the gross value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT hero FROM movies WHERE total_gross = 222527828",
            "SELECT T1.hero FROM characters AS T1 INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie_title WHERE T2.total_gross = '$222,527,828'"
        ],
        "rule_sql": []
    },
    "433": {
        "db_id": "movies_4",
        "question": "For all the movies which were produced by Cruel and Unusual Films, which one has the most popularity?",
        "ground_truth": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Cruel and Unusual Films' ORDER BY T3.popularity DESC LIMIT 1",
        "amends": [
            "Do join `production_company` as `T1` and `movie_company` as `T2` on `T1.company_id=T2.company_id` instead of querying `movies` directly. Do then join `movie` as `T3` on `T2.movie_id=T3.movie_id` instead of missing the relationship tables. Do filter on `T1.company_name='Cruel and Unusual Films'` instead of `production_company='Cruel and Unusual Films'` to use the proper column name. Do select only `T3.title` instead of both `title` and `MAX(popularity)` since the maximum is handled differently. Do add `ORDER BY T3.popularity DESC LIMIT 1` instead of using `MAX(popularity)` aggregate to retrieve the single most popular movie title. The amended query now correctly joins through the relationship tables and returns the title of the most popular movie from the specified production company."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MAX(popularity) FROM movies WHERE production_company = 'Cruel and Unusual Films';",
            "SELECT T3.title\nFROM production_company AS T1\nJOIN movie_company AS T2 ON T1.company_id = T2.company_id\nJOIN movie AS T3 ON T2.movie_id = T3.movie_id\nWHERE T1.company_name = 'Cruel and Unusual Films'\nORDER BY T3.popularity DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2621": {
        "db_id": "regional_sales",
        "question": "Among the orders placed by Ei, how many orders have quantity greater than 4?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.`Order Quantity` > 4 AND T2.`Customer Names` = 'Ei ' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "amends": [
            "Do use `SUM(CASE WHEN condition THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count specific conditional matches. Do join `Sales Orders AS T1` with `Customers AS T2` using `INNER JOIN` on `T2.CustomerID = T1._CustomerID` instead of querying only the orders table. Do reference `T1.Order Quantity` instead of `quantity` and `T2.Customer Names` instead of `customer_name` to use the correct table aliases and column names. Do include a trailing space in the string literal `'Ei '` instead of `'Ei'` to match the exact data format. Do remove the direct `WHERE` clause and instead incorporate the filters within the `CASE` expression as `T1.Order Quantity > 4 AND T2.Customer Names = 'Ei '` instead of separate `WHERE` conditions. The amended query now correctly joins the necessary tables and counts only the specific conditional matches as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE customer_name = 'Ei' AND quantity > 4",
            "SELECT SUM(CASE WHEN T1.\"Order Quantity\" > 4 AND T2.\"Customer Names\" = 'Ei ' THEN 1 ELSE 0 END) AS order_count\nFROM \"Sales Orders\" AS T1\nINNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID;"
        ],
        "rule_sql": []
    },
    "1813": {
        "db_id": "soccer_2016",
        "question": "What is the nationality of the 7th season Purple Cap winner?",
        "ground_truth": "SELECT T3.Country_Name FROM Season AS T1 INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE T1.Season_Id = 7 AND T1.Purple_Cap IS NOT NULL",
        "amends": [
            "Do select `T3.Country_Name` instead of `nationality`. Do use `FROM Season AS T1` with `INNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id` and `INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id` instead of `FROM players` without joins. Do filter with `WHERE T1.Season_Id = 7 AND T1.Purple_Cap IS NOT NULL` instead of `WHERE season = 7 AND award = 'Purple Cap'`. Do remove `ORDER BY player_id LIMIT 1 OFFSET 6` instead of keeping the limit and offset. The amended query now correctly joins tables and filters for the Purple Cap award condition while removing the unnecessary row limiting.",
            "Do join on `T1.Man_of_the_Series = T2.Player_Id` instead of `T1.Purple_Cap = T2.Player_Id` for the Season-Player relationship, while keeping the same Country join condition `T2.Country_Name = T3.Country_Id` and maintaining the WHERE filter on `T1.Season_Id = 7` with the same NULL check on `T1.Purple_Cap IS NOT NULL`. The amended query now correctly retrieves country information based on the Man of the Series award rather than the Purple Cap award, while preserving the same structural integrity and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nationality FROM players WHERE season = 7 AND award = 'Purple Cap' ORDER BY player_id LIMIT 1 OFFSET 6;",
            "SELECT T3.Country_Name\nFROM Season AS T1\nINNER JOIN Player AS T2 ON T1.Purple_Cap = T2.Player_Id\nINNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id\nWHERE T1.Season_Id = 7 AND T1.Purple_Cap IS NOT NULL",
            "SELECT T3.Country_Name\nFROM Season AS T1\nINNER JOIN Player AS T2 ON T1.Man_of_the_Series = T2.Player_Id\nINNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id\nWHERE T1.Season_Id = 7 AND T1.Purple_Cap IS NOT NULL"
        ],
        "rule_sql": []
    },
    "8994": {
        "db_id": "bike_share_1",
        "question": "Which is the station where no bike could not be borrowed form on the 2013/11/03 02:01:01? State the location of the station.",
        "ground_truth": "SELECT T1.name, T1.long FROM station AS T1 INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE T2.time = '2013/11/03 02:01:01' AND T2.bikes_available = 0",
        "amends": [
            "Do select `T1.name` and `T1.long` instead of just `location`. Do use `INNER JOIN` between `station AS T1` and `status AS T2` on `T2.station_id = T1.id` instead of querying `stations` alone. Do add filter `T2.time = '2013/11/03 02:01:01'` instead of filtering by rental_time in a subquery. Do add condition `T2.bikes_available = 0` instead of using a NOT IN subquery with bike_rentals. The amended query now correctly identifies stations with no available bikes at the specified time instead of finding stations without rentals at that exact moment."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM stations WHERE station_id NOT IN (SELECT station_id FROM bike_rentals WHERE rental_time = '2013/11/03 02:01:01');",
            "SELECT T1.name, T1.long\nFROM station AS T1\nINNER JOIN status AS T2 ON T2.station_id = T1.id\nWHERE T2.time = '2013/11/03 02:01:01'\nAND T2.bikes_available = 0;"
        ],
        "rule_sql": []
    },
    "8139": {
        "db_id": "sales_in_weather",
        "question": "What is the ID of the item that sold the best on 2012/1/1 in store no.1?",
        "ground_truth": "SELECT item_nbr FROM sales_in_weather WHERE `date` = '2012-01-01' AND store_nbr = 1 ORDER BY units DESC LIMIT 1",
        "amends": [
            "Do select `item_nbr` instead of `item_id` and do order by `units DESC` instead of `quantity_sold ASC`. Do use table `sales_in_weather` instead of `sales` and do filter on `store_nbr = 1` instead of `store_id = 1`. Do use date format `'2012-01-01'` with backticks around `date` instead of `'2012/1/1'` without backticks. The amended query now correctly retrieves the item with the highest units sold from the specified table using the proper column names and date format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT item_id FROM sales WHERE store_id = 1 AND date = '2012/1/1' ORDER BY quantity_sold ASC LIMIT 1;",
            "SELECT item_nbr FROM sales_in_weather WHERE store_nbr = 1 AND date = '2012-01-01' ORDER BY units DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "775": {
        "db_id": "movie",
        "question": "List the character's name of actress born in Sherman Oaks and starred in the movie Bruce Almighty with height greater than the 50% of average height of all actors listed.",
        "ground_truth": "SELECT T3.Name FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T3.Gender = 'Female' AND T1.Title = 'Godzilla' AND T3.`Birth City` = 'Sherman Oaks' AND T3.`Height (Inches)` * 100 > ( SELECT AVG(`Height (Inches)`) FROM actor ) * 50",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `m`, `c`, and `a`. Do reference `T3.Name` in the SELECT list instead of `c.name`. Do join `movie AS T1` instead of `movies m`. Do join `characters AS T2` instead of `characters c`. Do join `actor AS T3` instead of `actors a`. Do use join condition `T1.MovieID = T2.MovieID` instead of `c.movie_id = m.id`. Do use join condition `T3.ActorID = T2.ActorID` instead of `c.actor_id = a.id`. Do add filter `T3.Gender = 'Female'` instead of omitting it. Do filter on `T1.Title = 'Godzilla'` instead of `m.title = 'Bruce Almighty'`. Do filter on `T3.Birth City = 'Sherman Oaks'` instead of `a.birth_place = 'Sherman Oaks'`. Do use expression `T3.Height (Inches) * 100` instead of `a.height`. Do compare against `(SELECT AVG(Height (Inches)) FROM actor) * 50` instead of `(SELECT AVG(height) * 0.5 FROM actors)`. Do remove ORDER BY instead of keeping it. The amended query now correctly filters for female actors from Sherman Oaks in Godzilla with height exceeding 50 times the average, matching the intended behavior.",
            "Do select `T3.Name` instead of `T2.\"Character Name\"` in the SELECT list. Do use backticks for column names like `Birth City` and `Height (Inches)` instead of double quotes. Do specify `INNER JOIN` explicitly instead of just `JOIN` for both table joins. The amended query now correctly retrieves actor names rather than character names while maintaining the same filtering logic for female actors from Sherman Oaks who appeared in Godzilla and meet the height condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.name \nFROM characters c\nJOIN actors a ON c.actor_id = a.id\nJOIN movies m ON c.movie_id = m.id\nWHERE a.birth_place = 'Sherman Oaks'\nAND m.title = 'Bruce Almighty'\nAND a.height > (SELECT AVG(height) * 0.5 FROM actors)\nORDER BY c.name;",
            "SELECT T2.\"Character Name\"\nFROM movie AS T1\nJOIN characters AS T2 ON T1.MovieID = T2.MovieID\nJOIN actor AS T3 ON T3.ActorID = T2.ActorID\nWHERE T3.Gender = 'Female'\nAND T1.Title = 'Godzilla'\nAND T3.\"Birth City\" = 'Sherman Oaks'\nAND T3.\"Height (Inches)\" * 100 > (SELECT AVG(\"Height (Inches)\") FROM actor) * 50",
            "SELECT T3.Name\nFROM movie AS T1\nINNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID\nINNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID\nWHERE T1.Title = 'Godzilla'\nAND T3.`Birth City` = 'Sherman Oaks'\nAND T3.Gender = 'Female'\nAND T3.`Height (Inches)` * 100 > (SELECT AVG(`Height (Inches)`) FROM actor) * 50"
        ],
        "rule_sql": []
    },
    "6274": {
        "db_id": "coinmarketcap",
        "question": "How much was a Bitcoin on 2013/4/28?",
        "ground_truth": "SELECT T2.price FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T2.date = '2013-04-28' AND T1.name = 'Bitcoin'",
        "amends": [
            "Do reference `T2.price` from the joined table instead of directly selecting `price` from a single table. Do join `coins AS T1` and `historical AS T2` with an `INNER JOIN` on `T1.id = T2.coin_id` instead of querying a single `bitcoin_prices` table. Do add the filter `T1.name = 'Bitcoin'` to identify the specific coin instead of relying on table name semantics. Do use the standardized date format `'2013-04-28'` instead of `'2013/4/28'` for proper date handling. The amended query now correctly retrieves Bitcoin price data through proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM bitcoin_prices WHERE date = '2013/4/28';",
            "SELECT T2.price \nFROM coins AS T1 \nINNER JOIN historical AS T2 ON T1.id = T2.coin_id \nWHERE T1.name = 'Bitcoin' \nAND T2.date = '2013-04-28'"
        ],
        "rule_sql": []
    },
    "8036": {
        "db_id": "university",
        "question": "What is the percentage of Harvard university's international students in 2011?",
        "ground_truth": "SELECT T1.pct_international_students FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2011 AND T2.university_name = 'Harvard University'",
        "amends": [
            "Do select `T1.pct_international_students` instead of calculating `(international_students / total_students) * 100 AS percentage`. Do use `university_year AS T1` and `university AS T2` tables instead of just `universities`. Do perform an `INNER JOIN` on `T1.university_id = T2.id` instead of querying a single table. Do filter with `T1.year = 2011` and `T2.university_name = 'Harvard University'` instead of `name = 'Harvard' AND year = 2011`. The amended query now correctly joins the university and university_year tables to retrieve the pre-calculated percentage value instead of attempting to compute it from raw student counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (international_students / total_students) * 100 AS percentage FROM universities WHERE name = 'Harvard' AND year = 2011;",
            "SELECT T1.pct_international_students \nFROM university_year AS T1 \nINNER JOIN university AS T2 ON T1.university_id = T2.id \nWHERE T1.year = 2011 AND T2.university_name = 'Harvard University'"
        ],
        "rule_sql": []
    },
    "8296": {
        "db_id": "mondial_geo",
        "question": "How many times longer is the longest border in the United States than the shortest?",
        "ground_truth": "SELECT MAX(T2.Length) / MIN(T2.Length) FROM country AS T1 INNER JOIN borders AS T2 ON T1.Code = T2.Country2 WHERE T1.Name = 'United States'",
        "amends": [
            "Do join `country AS T1` with `borders AS T2` on `T1.Code = T2.Country2` instead of querying `borders` alone without proper table relationships. Do filter on `T1.Name = 'United States'` instead of using `country1 = 'United States' OR country2 = 'United States'` which incorrectly assumes both country columns contain the same identifier format. Do reference columns with table aliases as `MAX(T2.Length)` and `MIN(T2.Length)` instead of unqualified `length` to avoid ambiguity. Do use `INNER JOIN` to properly relate countries to their borders instead of attempting to filter border records directly without the country table connection. The amended query now correctly identifies United States borders by joining with the country table and using the proper code-based relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(length) / MIN(length) AS ratio FROM borders WHERE country1 = 'United States' OR country2 = 'United States';",
            "SELECT MAX(T2.Length) / MIN(T2.Length) \nFROM country AS T1 \nINNER JOIN borders AS T2 ON T1.Code = T2.Country2 \nWHERE T1.Name = 'United States'"
        ],
        "rule_sql": []
    },
    "3578": {
        "db_id": "authors",
        "question": "What is the name of the co-authors of the paper titled 'Particle identification using the time-over-threshold method in the ATLAS Transition Radiation Tracker'?",
        "ground_truth": "SELECT T1.Name FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE T2.Title = 'Particle identification using the time-over-threshold method in the ATLAS Transition Radiation Tracker'",
        "amends": [
            "Do join `PaperAuthor` as `T1` with `Paper` as `T2` on `T1.PaperId = T2.Id` instead of querying `papers` table directly. Do select `T1.Name` instead of `author_name` from the joined tables. Do filter on `T2.Title` with the exact paper title instead of filtering `title` in the base table. The amended query now correctly retrieves author names through proper table relationships instead of assuming author data exists in the papers table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM papers WHERE title = 'Particle identification using the time-over-threshold method in the ATLAS Transition Radiation Tracker';",
            "SELECT T1.Name FROM PaperAuthor T1 JOIN Paper T2 ON T1.PaperId = T2.Id WHERE T2.Title = 'Particle identification using the time-over-threshold method in the ATLAS Transition Radiation Tracker'"
        ],
        "rule_sql": []
    },
    "735": {
        "db_id": "movie",
        "question": "Please list the names of the movies starring Tom Cruise.",
        "ground_truth": "SELECT T1.Title FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T3.Name = 'Tom Cruise'",
        "amends": [
            "Do join `movie AS T1` with `characters AS T2` on `T1.MovieID = T2.MovieID` and then with `actor AS T3` on `T3.ActorID = T2.ActorID` instead of querying only the `movies` table. Do filter on `T3.Name = 'Tom Cruise'` instead of filtering directly on `actor = 'Tom Cruise'` since the actor name is stored in a separate table. Do select `T1.Title` instead of just `title` to specify the table alias. The amended query now correctly joins the necessary tables to find movies featuring Tom Cruise by his actor name rather than assuming the actor name is stored directly in the movies table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE actor = 'Tom Cruise';",
            "SELECT T1.Title \nFROM movie AS T1 \nJOIN characters AS T2 ON T1.MovieID = T2.MovieID \nJOIN actor AS T3 ON T3.ActorID = T2.ActorID \nWHERE T3.Name = 'Tom Cruise'"
        ],
        "rule_sql": []
    },
    "7573": {
        "db_id": "image_and_language",
        "question": "State the name of the object class that has in most images.",
        "ground_truth": "SELECT OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID GROUP BY T2.OBJ_CLASS ORDER BY COUNT(T1.OBJ_CLASS_ID) DESC LIMIT 1",
        "amends": [
            "Do select `OBJ_CLASS` from table `T2` instead of `object_class` from table `images`. Do join tables `IMG_OBJ AS T1` and `OBJ_CLASSES AS T2` with `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying only the `images` table without any joins. Do group by `T2.OBJ_CLASS` instead of `object_class`. Do order by `COUNT(T1.OBJ_CLASS_ID)` instead of `COUNT(*)` to count specific object class instances rather than all rows. The amended query now correctly joins the necessary tables to access object class information and counts actual object class occurrences, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class FROM images GROUP BY object_class ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.OBJ_CLASS\nFROM IMG_OBJ AS T1\nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nGROUP BY T2.OBJ_CLASS\nORDER BY COUNT(T1.OBJ_CLASS_ID) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8266": {
        "db_id": "mondial_geo",
        "question": "What is the highest lake area coverage of a country?",
        "ground_truth": "SELECT T2.Area * 100  / T3.Area FROM located AS T1 INNER JOIN lake AS T2 ON T1.Lake = T2.Name INNER JOIN country AS T3 ON T3.Code = T1.Country ORDER BY T2.Longitude DESC LIMIT 1",
        "amends": [
            "Do select `T2.Area * 100 / T3.Area` instead of `MAX(lake_area)`. Do add `FROM located AS T1 INNER JOIN lake AS T2 ON T1.Lake = T2.Name INNER JOIN country AS T3 ON T3.Code = T1.Country` instead of `FROM countries`. Do add `ORDER BY T2.Longitude DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly calculates the percentage of lake area relative to country area for the westernmost lake instead of finding the maximum lake area from a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(lake_area) FROM countries;",
            "SELECT T2.Area * 100 / T3.Area \nFROM located AS T1 \nINNER JOIN lake AS T2 ON T1.Lake = T2.Name \nINNER JOIN country AS T3 ON T3.Code = T1.Country \nORDER BY T2.Longitude DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5879": {
        "db_id": "airline",
        "question": "Which flight carrier operator has the most cancelled flights?",
        "ground_truth": "SELECT T1.Description FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID ORDER BY T2.CANCELLED DESC LIMIT 1",
        "amends": [
            "Do select `T1.Description` instead of `carrier` and `COUNT(*) as cancelled_count`. Do use `FROM \\`Air Carriers\\` AS T1 INNER JOIN Airlines AS T2` instead of `FROM flights`. Do join on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of no join condition. Do remove the `WHERE cancelled = 1` filter and `GROUP BY carrier` clause. Do order by `T2.CANCELLED DESC` instead of `cancelled_count DESC`. The amended query now correctly retrieves the carrier description with the highest cancellation count by joining the carrier code tables and ordering by the cancellation column directly.",
            "Do remove `COUNT(*) as cancelled_count` and `GROUP BY T1.Description` instead of including aggregation, and do order by `T2.CANCELLED DESC` instead of ordering by the removed aggregate column. Do change the SELECT list to only include `T1.Description` instead of including both the description and count. The amended query now correctly retrieves the carrier description with the highest cancellation count by directly ordering by the cancellation column instead of attempting to aggregate counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT carrier, COUNT(*) as cancelled_count FROM flights WHERE cancelled = 1 GROUP BY carrier ORDER BY cancelled_count DESC LIMIT 1;",
            "SELECT T1.Description, COUNT(*) as cancelled_count\nFROM \"Air Carriers\" AS T1\nINNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nGROUP BY T1.Description\nORDER BY cancelled_count DESC\nLIMIT 1;",
            "SELECT T1.Description \nFROM \"Air Carriers\" AS T1 \nINNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID \nORDER BY T2.CANCELLED DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6201": {
        "db_id": "food_inspection_2",
        "question": "How many inspections done in 2010 had serious food safety issue?",
        "ground_truth": "SELECT COUNT(T2.inspection_id) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE strftime('%Y', T2.inspection_date) = '2010' AND T1.risk_level = 3",
        "amends": [
            "Do join `establishment AS T1` with `inspection AS T2` on `T1.license_no = T2.license_no` instead of querying only the `inspections` table without any join. Do count `T2.inspection_id` instead of using `COUNT(*)`. Do filter by `strftime('%Y', T2.inspection_date) = '2010'` instead of `year = 2010`. Do add the condition `T1.risk_level = 3` instead of filtering by `food_safety_issue = 'serious'`. The amended query now correctly counts inspections from 2010 for establishments with risk level 3, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE year = 2010 AND food_safety_issue = 'serious';",
            "SELECT COUNT(T2.inspection_id) \nFROM establishment AS T1 \nJOIN inspection AS T2 ON T1.license_no = T2.license_no \nWHERE strftime('%Y', T2.inspection_date) = '2010' \nAND T1.risk_level = 3"
        ],
        "rule_sql": []
    },
    "2139": {
        "db_id": "world_development_indicators",
        "question": "Which country has the highest value of Merchandise imports by the reporting economy (current US$)?",
        "ground_truth": "SELECT CountryName FROM Indicators WHERE IndicatorName = 'Merchandise imports by the reporting economy (current US$)' ORDER BY Value DESC LIMIT 1",
        "amends": [
            "Do select `CountryName` instead of `Country` and do not include `MAX(Merchandise_imports)` instead of including it. Do use table `Indicators` instead of `economy_data` and add filter `WHERE IndicatorName = 'Merchandise imports by the reporting economy (current US$)'` instead of omitting it. Do order by `Value DESC` instead of `Merchandise_imports DESC` while keeping `LIMIT 1`. The amended query now correctly retrieves the country with the highest merchandise imports value from the appropriate indicator data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country, MAX(Merchandise_imports) FROM economy_data ORDER BY Merchandise_imports DESC LIMIT 1;",
            "SELECT CountryName FROM Indicators WHERE IndicatorName = 'Merchandise imports by the reporting economy (current US$)' ORDER BY Value DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8064": {
        "db_id": "university",
        "question": "Provide the ranking criteria and scores in 2005 that were received by Harvard University.",
        "ground_truth": "SELECT T1.criteria_name, T2.score FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE T3.university_name = 'Harvard University' AND T2.year = 2005",
        "amends": [
            "Do select `criteria_name` and `score` from joined tables instead of `ranking_criteria` and `scores` from a single table. Do use `INNER JOIN` with `ranking_criteria AS T1` on `T1.id = T2.ranking_criteria_id` instead of querying a single `university_rankings` table. Do add a second `INNER JOIN` with `university AS T3` on `T3.id = T2.university_id` instead of omitting the university table join. Do move the university name filter to `T3.university_name` instead of applying it directly to a non-existent column in the original table. Do keep the year filter on `T2.year` instead of applying it to the original table structure. The amended query now correctly joins the three required tables to retrieve criteria names and scores for the specified university and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_criteria, scores FROM university_rankings WHERE university_name = 'Harvard University' AND year = 2005;",
            "SELECT T1.criteria_name, T2.score\nFROM ranking_criteria AS T1\nINNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id\nINNER JOIN university AS T3 ON T3.id = T2.university_id\nWHERE T3.university_name = 'Harvard University' AND T2.year = 2005"
        ],
        "rule_sql": []
    },
    "779": {
        "db_id": "social_media",
        "question": "Among all the tweets that have a positive sentiment, how many of them are posted on Thursday?",
        "ground_truth": "SELECT COUNT(TweetID) AS tweet_number FROM twitter WHERE Sentiment > 0 AND Weekday = 'Thursday'",
        "amends": [
            "Do count `TweetID` with alias `tweet_number` instead of `COUNT(*)` without an alias. Do reference table `twitter` instead of `tweets`. Do filter on `Sentiment > 0` instead of `sentiment = 'positive'`. Do filter on `Weekday = 'Thursday'` instead of using `strftime('%w', created_at) = '4'` to extract Thursday by weekday number. The amended query now correctly counts positive tweets from the twitter table that were posted on Thursdays."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE sentiment = 'positive' AND strftime('%w', created_at) = '4';",
            "SELECT COUNT(TweetID) AS tweet_number FROM twitter WHERE Sentiment > 0 AND Weekday = 'Thursday'"
        ],
        "rule_sql": []
    },
    "4607": {
        "db_id": "mental_health_survey",
        "question": "For all the users who have been asked \"Have you ever been diagnosed with a mental health disorder?\", how many of them said \"Yes\"?",
        "ground_truth": "SELECT COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questiontext LIKE 'Have you ever been diagnosed with a mental health disorder?' AND T1.AnswerText = 'Yes'",
        "amends": [
            "Do join `Answer AS T1` with `Question AS T2` on `T1.QuestionID = T2.questionid` instead of querying a single `users` table. Do filter by `T2.questiontext LIKE 'Have you ever been diagnosed with a mental health disorder?'` instead of directly filtering on `question = 'Have you ever been diagnosed with a mental health disorder?'`. Do filter by `T1.AnswerText = 'Yes'` instead of `answer = 'Yes'`. Do count `T1.UserID` instead of using `COUNT(*)`. The amended query now correctly joins the normalized Answer and Question tables to count users who answered 'Yes' to the specific mental health diagnosis question, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE question = 'Have you ever been diagnosed with a mental health disorder?' AND answer = 'Yes';",
            "SELECT COUNT(DISTINCT T1.UserID) \nFROM Answer AS T1 \nJOIN Question AS T2 ON T1.QuestionID = T2.questionid \nWHERE T2.questiontext LIKE 'Have you ever been diagnosed with a mental health disorder?' \nAND T1.AnswerText = 'Yes'"
        ],
        "rule_sql": []
    },
    "823": {
        "db_id": "social_media",
        "question": "What gender of users posted the most tweets in `en`?",
        "ground_truth": "SELECT T.Gender FROM ( SELECT T2.Gender, COUNT( text) AS num FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.Lang = 'en' GROUP BY T2.Gender ) T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use `T2.Gender` in the SELECT list instead of `gender` and add table aliases throughout. Do reference `twitter` as `T1` and `user` as `T2` instead of `users` and `tweets`. Do use `INNER JOIN` with `T1.UserID = T2.UserID` instead of `JOIN` with `users.user_id = tweets.user_id`. Do filter on `T1.Lang = 'en'` instead of `tweets.language = 'en'`. Do count `text` instead of using `COUNT(*)` and alias it as `num` instead of `tweet_count`. Do wrap the aggregated query in a subquery `T` and select only `T.Gender` in the outer query instead of selecting both `gender` and `tweet_count`. Do order by `T.num DESC` instead of `tweet_count DESC`. The amended query now correctly returns only the gender with the highest count of English tweets."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender, COUNT(*) as tweet_count FROM users JOIN tweets ON users.user_id = tweets.user_id WHERE tweets.language = 'en' GROUP BY gender ORDER BY tweet_count DESC LIMIT 1;",
            "SELECT T.Gender\nFROM (\n    SELECT T2.Gender, COUNT(T1.text) AS num\n    FROM twitter T1\n    INNER JOIN user T2 ON T1.UserID = T2.UserID\n    WHERE T1.Lang = 'en'\n    GROUP BY T2.Gender\n    ORDER BY num DESC\n) T\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6124": {
        "db_id": "food_inspection_2",
        "question": "What is the point level of \"Refrigeration and metal stem thermometers provided and conspicuous\"?",
        "ground_truth": "SELECT point_level FROM inspection_point WHERE Description = 'Refrigeration and metal stem thermometers provided and conspicuous '",
        "amends": [
            "Do query the `inspection_point` table instead of the `violations` table. Do use the column `Description` for filtering instead of `violation_description`. Do include the trailing space in the filter condition 'Refrigeration and metal stem thermometers provided and conspicuous ' instead of omitting it. The amended query now correctly retrieves point levels from the appropriate inspection point table with the exact matching description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT point_level FROM violations WHERE violation_description = 'Refrigeration and metal stem thermometers provided and conspicuous';",
            "SELECT point_level FROM inspection_point WHERE Description = 'Refrigeration and metal stem thermometers provided and conspicuous ';"
        ],
        "rule_sql": []
    },
    "5018": {
        "db_id": "olympics",
        "question": "Calculate the average weight of male athletes from Tonga.",
        "ground_truth": "SELECT AVG(T3.weight) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Tonga' AND T3.gender = 'M'",
        "amends": [
            "Do use `AVG(T3.weight)` with explicit table reference instead of `AVG(weight)` without qualification. Do join `noc_region AS T1` and `person_region AS T2` on `T1.id = T2.region_id` instead of querying `athletes` directly. Do join `person AS T3` on `T2.person_id = T3.id` instead of missing the person-region relationship. Do filter on `T1.region_name = 'Tonga'` through the region table instead of `country = 'Tonga'` directly. Do filter on `T3.gender = 'M'` with proper table reference instead of `gender = 'female'` with incorrect gender value. The amended query now correctly calculates average weight for male athletes from Tonga through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weight) FROM athletes WHERE gender = 'female' AND country = 'Tonga';",
            "SELECT AVG(T3.weight) \nFROM noc_region AS T1\nJOIN person_region AS T2 ON T1.id = T2.region_id\nJOIN person AS T3 ON T2.person_id = T3.id\nWHERE T1.region_name = 'Tonga' AND T3.gender = 'M'"
        ],
        "rule_sql": []
    },
    "8090": {
        "db_id": "university",
        "question": "Show the id of University of Orl\u00e9ans.",
        "ground_truth": "SELECT id FROM university WHERE university_name = 'University of Orl\u00e9ans'",
        "amends": [
            "Do select `id` instead of `name` in the SELECT list. Do reference table `university` instead of `universities` in the FROM clause. Do filter on `university_name = 'University of Orl\u00e9ans'` instead of `id = 'University of Orl\u00e9ans'` in the WHERE clause, correcting the column usage for proper filtering logic. The amended query now correctly retrieves the ID from the university table based on the university name rather than attempting to match a string value against an ID column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM universities WHERE id = 'University of Orl\u00e9ans';",
            "SELECT id FROM university WHERE university_name = 'University of Orl\u00e9ans';"
        ],
        "rule_sql": []
    },
    "4482": {
        "db_id": "student_loan",
        "question": "What is the ratio of students who have payment due and those who do not have payment due?",
        "ground_truth": "SELECT CAST(SUM(IIF(`bool` = 'pos', 1, 0)) AS REAL) / SUM(IIF(`bool` = 'neg', 1, 0)) FROM no_payment_due",
        "amends": [
            "Do use `CAST(SUM(IIF(bool = 'pos', 1, 0)) AS REAL) / SUM(IIF(bool = 'neg', 1, 0))` instead of `COUNT(*) AS total_students`, `SUM(CASE WHEN payment_due = 1 THEN 1 ELSE 0 END) AS students_with_payment_due`, `SUM(CASE WHEN payment_due = 0 THEN 1 ELSE 0 END) AS students_without_payment_due`, and `(SELECT COUNT(*) FROM students WHERE payment_due = 1) / (SELECT COUNT(*) FROM students WHERE payment_due = 0) AS payment_due_ratio`. Do query from `no_payment_due` instead of `students`. Do use string literals `'pos'` and `'neg'` instead of integer values `1` and `0` for boolean conditions. Do remove the separate aggregate columns and subqueries instead of keeping them, focusing only on the ratio calculation. The amended query now correctly calculates the payment due ratio using proper type casting and simplified logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS total_students,\n    SUM(CASE WHEN payment_due = 1 THEN 1 ELSE 0 END) AS students_with_payment_due,\n    SUM(CASE WHEN payment_due = 0 THEN 1 ELSE 0 END) AS students_without_payment_due,\n    (SELECT COUNT(*) FROM students WHERE payment_due = 1) / (SELECT COUNT(*) FROM students WHERE payment_due = 0) AS payment_due_ratio\nFROM students;",
            "SELECT CAST(SUM(IIF(bool = 'pos', 1, 0)) AS REAL) / SUM(IIF(bool = 'neg', 1, 0)) AS payment_due_ratio FROM no_payment_due;"
        ],
        "rule_sql": []
    },
    "4013": {
        "db_id": "public_review_platform",
        "question": "How many short tips were left for the business with ID no.2?",
        "ground_truth": "SELECT COUNT(business_id) FROM Tips WHERE business_id = 2 AND tip_length = 'Short'",
        "amends": [
            "Do use `COUNT(business_id)` instead of `COUNT(*)` to count only non-null business_id values. Do reference the table as `Tips` instead of `tips` to match the correct case. Do use the column `tip_length` with value `'Short'` instead of the `text LIKE '%short%'` filter to properly match the intended short tip length condition. Do remove the unnecessary `LIKE` pattern matching and instead use direct equality comparison for better performance and accuracy."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tips WHERE business_id = 2 AND text LIKE '%short%';",
            "SELECT COUNT(business_id) FROM Tips WHERE business_id = 2 AND tip_length = 'Short';"
        ],
        "rule_sql": []
    },
    "7625": {
        "db_id": "hockey",
        "question": "List all goalies who played in the year 2005 season and shorter than 72 inches. List all the team names he play for.",
        "ground_truth": "SELECT DISTINCT T1.firstName, T1.lastName, T3.name FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID INNER JOIN Teams AS T3 ON T2.tmID = T3.tmID WHERE T2.year = 2005 AND T1.height < 72",
        "amends": [
            "Do select `firstName`, `lastName`, and `name` instead of `name` and `team_name`. Do add `DISTINCT` instead of omitting it. Do use `Master` table with alias `T1` instead of omitting it. Do join `Goalies` as `T2` with `INNER JOIN` on `T1.playerID = T2.playerID` instead of joining `goalies` directly on `team_id`. Do join `Teams` as `T3` with `INNER JOIN` on `T2.tmID = T3.tmID` instead of joining on `team_id`. Do filter on `T2.year = 2005` instead of `g.year = 2005`. Do filter on `T1.height < 72` instead of `g.height < 72`. Do remove `ORDER BY` instead of keeping it. The amended query now correctly retrieves distinct goalie names with team information using proper table relationships and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.name, t.team_name \nFROM goalies g\nJOIN teams t ON g.team_id = t.team_id\nWHERE g.year = 2005 AND g.height < 72\nORDER BY g.name;",
            "SELECT DISTINCT T1.firstName, T1.lastName, T3.name\nFROM Master T1\nINNER JOIN Goalies T2 ON T1.playerID = T2.playerID\nINNER JOIN Teams T3 ON T2.tmID = T3.tmID AND T2.year = T3.year\nWHERE T2.year = 2005 AND T1.height < '72'"
        ],
        "rule_sql": []
    },
    "8675": {
        "db_id": "chicago_crime",
        "question": "Please list the area name of the communities in the Far north side, which has a population of more than 50000 but less than 70000.",
        "ground_truth": "SELECT community_area_name, side FROM Community_Area WHERE side = 'Far North ' AND population BETWEEN 50000 AND 70000",
        "amends": [
            "Do use `community_area_name` instead of `area_name` for the column name. Do include `side` in the SELECT list instead of omitting it. Do reference table `Community_Area` instead of `communities` for the source. Do use `'Far North '` with proper spacing instead of `'Far north side'` for the filter condition. Do use `BETWEEN 50000 AND 70000` instead of separate `population > 50000 AND population < 70000` conditions for the population range filter. The amended query now correctly matches the intended behavior with proper column names, table reference, and inclusive population range filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area_name FROM communities WHERE side = 'Far north side' AND population > 50000 AND population < 70000;",
            "SELECT community_area_name, side FROM Community_Area WHERE side = 'Far North ' AND population BETWEEN 50000 AND 70000"
        ],
        "rule_sql": []
    },
    "1687": {
        "db_id": "restaurant",
        "question": "What is the rating of each restaurant reviews on Atlantic Ave?",
        "ground_truth": "SELECT T1.review FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_name = 'atlantic ave'",
        "amends": [
            "Do select `review` from `generalinfo` instead of `rating` from `restaurant_reviews`. Do join `location` table using `INNER JOIN` on `T1.id_restaurant = T2.id_restaurant` instead of querying a single table. Do filter on `T2.street_name = 'atlantic ave'` instead of `address = 'Atlantic Ave'`. The amended query now correctly retrieves review data by joining restaurant information with location details and filtering by street name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating FROM restaurant_reviews WHERE address = 'Atlantic Ave';",
            "SELECT g.review \nFROM generalinfo g\nINNER JOIN location l ON g.id_restaurant = l.id_restaurant\nWHERE l.street_name = 'atlantic ave'"
        ],
        "rule_sql": []
    },
    "970": {
        "db_id": "computer_student",
        "question": "How many courses are there for basic or medium undergraduate courses?",
        "ground_truth": "SELECT COUNT(course_id) FROM course WHERE courseLevel = 'Level_300'",
        "amends": [
            "Do reference the `course` table instead of `courses` and use `COUNT(course_id)` instead of `COUNT(*)` to count specific non-null values. Do filter on `courseLevel = 'Level_300'` instead of `level = 'basic' OR level = 'medium'` to target the correct course level criteria. The amended query now correctly counts Level_300 courses from the course table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE level = 'basic' OR level = 'medium';",
            "SELECT COUNT(course_id) FROM course WHERE courseLevel = 'Level_300'"
        ],
        "rule_sql": []
    },
    "8132": {
        "db_id": "university",
        "question": "What is the location and number of female students in university ID 23 in 2011?",
        "ground_truth": "SELECT T3.country_name, CAST(T2.num_students * T2.pct_female_students AS REAL) / 100 FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.year = 2011 AND T1.id = 23",
        "amends": [
            "Do select `T3.country_name` and a calculated expression instead of `location` and `COUNT(*)`. Do join `university AS T1` and `university_year AS T2` with `INNER JOIN` on `T1.id = T2.university_id` instead of querying only `students`. Do add another `INNER JOIN` to `country AS T3` on `T3.id = T1.country_id` instead of omitting country table. Do filter on `T2.year = 2011` and `T1.id = 23` instead of `university_id = 23` and `year = 2011` and `gender = 'male'`. Do remove the `gender` filter and aggregate count instead of including it. Do add `CAST` and arithmetic operations for percentage calculation instead of simple counting. The amended query now correctly calculates female student percentages by country for the specified university and year.",
            "Do use `country_name` without alias instead of aliasing as `location`. Do cast the entire expression `T2.num_students * T2.pct_female_students` as `REAL` before division by `100` instead of casting the result of multiplication and division as `INTEGER`. Do remove the `AS number_of_female_students` alias instead of keeping it. The amended query now correctly handles floating-point division for accurate female student count calculation and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location, COUNT(*) FROM students WHERE university_id = 23 AND year = 2011 AND gender = 'male';",
            "SELECT \n    T3.country_name AS location,\n    CAST(T2.num_students * T2.pct_female_students / 100.0 AS INTEGER) AS number_of_female_students\nFROM \n    university AS T1\nINNER JOIN \n    university_year AS T2 ON T1.id = T2.university_id\nINNER JOIN \n    country AS T3 ON T3.id = T1.country_id\nWHERE \n    T2.year = 2011 \n    AND T1.id = 23",
            "SELECT T3.country_name, CAST(T2.num_students * T2.pct_female_students AS REAL) / 100\nFROM university AS T1\nINNER JOIN university_year AS T2 ON T1.id = T2.university_id\nINNER JOIN country AS T3 ON T3.id = T1.country_id\nWHERE T2.year = 2011 AND T1.id = 23"
        ],
        "rule_sql": []
    },
    "924": {
        "db_id": "cs_semester",
        "question": "How many of the professors are female?",
        "ground_truth": "SELECT COUNT(prof_id) FROM prof WHERE gender = 'Female'",
        "amends": [
            "Do reference table `prof` instead of `professors` and count `prof_id` instead of using `COUNT(*)`. Do filter for gender `'Female'` instead of `'male'`. The amended query now correctly counts female professors from the appropriate table with specific column counting instead of counting all rows."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE gender = 'male';",
            "SELECT COUNT(prof_id) FROM prof WHERE gender = 'Female';"
        ],
        "rule_sql": []
    },
    "8693": {
        "db_id": "chicago_crime",
        "question": "How many crimes happened in longitude -8772658001?",
        "ground_truth": "SELECT COUNT(*) FROM Crime WHERE longitude = '-87.72658001'",
        "amends": [
            "Do reference table `Crime` instead of `crimes` in the FROM clause. Do use string literal `'-87.72658001'` instead of numeric value `-8772658001` for the longitude filter in the WHERE clause, ensuring proper string comparison instead of numeric comparison. The amended query now correctly counts records from the Crime table where longitude matches the specified string value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE longitude = -8772658001;",
            "SELECT COUNT(*) FROM Crime WHERE longitude = '-87.72658001';"
        ],
        "rule_sql": []
    },
    "4238": {
        "db_id": "simpson_episodes",
        "question": "List all keywords associated with the episode 'Take My Life, Please'.",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Take My Life, Please';",
        "amends": [
            "Do select only `T2.keyword` instead of all columns with `*`. Do join from `Episode AS T1` instead of just `episodes`. Do add `INNER JOIN Keyword AS T2` instead of omitting the join. Do use the join condition `T1.episode_id = T2.episode_id` instead of no join condition. Do filter on `T1.title` instead of just `title`. The amended query now correctly retrieves keywords associated with the specified episode title instead of returning all episode columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes WHERE title = 'Take My Life, Please';",
            "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Take My Life, Please'"
        ],
        "rule_sql": []
    },
    "196": {
        "db_id": "book_publishing_company",
        "question": "Calculate the percentage of the employees who are Editor or Designer?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.job_desc IN ('Editor', 'Designer') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.job_id) FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id",
        "amends": [
            "Do use `SUM(CASE WHEN T2.job_desc IN ('Editor', 'Designer') THEN 1 ELSE 0 END)` instead of `COUNT(*)` with a `WHERE` filter to properly count matching rows. Do join `employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id` instead of querying only the `employees` table to access job descriptions. Do reference `T2.job_desc` instead of `job_title` to use the correct column name from the joined table. Do use `CAST(... AS REAL)` instead of integer division to ensure accurate percentage calculation. Do calculate percentage as `SUM(...) * 100 / COUNT(T1.job_id)` instead of `COUNT(*) * 100 / (SELECT COUNT(*) FROM employees)` to avoid a subquery and use the proper denominator from the joined result. The amended query now correctly calculates the percentage of employees with Editor or Designer job titles by properly joining tables and using accurate counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM employees) AS percentage FROM employees WHERE job_title = 'Editor' OR job_title = 'Designer';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.job_desc IN ('Editor', 'Designer') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.job_id) AS percentage\nFROM \n    employee AS T1 \nINNER JOIN \n    jobs AS T2 ON T1.job_id = T2.job_id;"
        ],
        "rule_sql": []
    },
    "4173": {
        "db_id": "simpson_episodes",
        "question": "How many stars on average does the episode Lost Verizon have?",
        "ground_truth": "SELECT CAST(SUM(T2.votes * T2.stars) AS REAL) / SUM(T2.votes) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.title = 'Lost Verizon';",
        "amends": [
            "Do calculate a weighted average using `CAST(SUM(T2.votes * T2.stars) AS REAL) / SUM(T2.votes)` instead of a simple `AVG(rating)`. Do join `Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id` instead of querying only the `episodes` table. Do filter on `T1.title = 'Lost Verizon'` instead of `episode_name = 'Lost Verizon'`. The amended query now correctly computes a weighted average from vote data rather than assuming a simple average rating exists, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM episodes WHERE episode_name = 'Lost Verizon';",
            "SELECT CAST(SUM(T2.votes * T2.stars) AS REAL) / SUM(T2.votes) AS average_stars\nFROM Episode AS T1\nINNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.title = 'Lost Verizon'"
        ],
        "rule_sql": []
    },
    "5778": {
        "db_id": "language_corpus",
        "question": "What is the locale of the language of the page titled \"Asclepi\"?",
        "ground_truth": "SELECT T2.locale FROM pages AS T1 INNER JOIN langs AS T2 ON T1.lid = T2.lid WHERE T1.title = 'Asclepi'",
        "amends": [
            "Do select `T2.locale` from the `langs` table instead of `locale` from the `pages` table. Do add an `INNER JOIN` on `langs AS T2` with the predicate `T1.lid = T2.lid` instead of querying only the `pages` table. Do maintain the `WHERE` filter on `T1.title = 'Asclepi'` as in the original query. The amended query now correctly retrieves the locale from the joined langs table rather than attempting to get it directly from pages, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT locale FROM pages WHERE title = 'Asclepi';",
            "SELECT T2.locale FROM pages AS T1 INNER JOIN langs AS T2 ON T1.lid = T2.lid WHERE T1.title = 'Asclepi'"
        ],
        "rule_sql": []
    },
    "6012": {
        "db_id": "books",
        "question": "How many customers use a Yahoo! Mail e-mail address?",
        "ground_truth": "SELECT COUNT(*) FROM customer WHERE email LIKE '%@yahoo.com'",
        "amends": [
            "Do reference table `customer` instead of `customers` to use the correct table name. Do use the more precise pattern `'%@yahoo.com'` instead of `'%yahoo.com%'` to properly match email addresses ending with @yahoo.com domain rather than any occurrence of yahoo.com within the email string. The amended query now correctly counts customers with yahoo.com email addresses by using the proper table reference and precise pattern matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE email LIKE '%yahoo.com%';",
            "SELECT COUNT(*) FROM customer WHERE email LIKE '%@yahoo.com'"
        ],
        "rule_sql": []
    },
    "5241": {
        "db_id": "beer_factory",
        "question": "What is the full name of the customer that had made the most transactions in August, 2014?",
        "ground_truth": "SELECT T1.First, T1.Last FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y-%m', T2.TransactionDate) = '2014-08' GROUP BY T1.CustomerID ORDER BY COUNT(T2.CustomerID) DESC LIMIT 1",
        "amends": [
            "Do use `T1.First` and `T1.Last` instead of `c.first_name` and `c.last_name` for column aliases. Do reference `transaction` instead of `transactions` as the table name. Do use `T1.CustomerID` and `T2.CustomerID` instead of `c.customer_id` and `t.customer_id` for join conditions. Do use `T2.TransactionDate` instead of `t.transaction_date` in the date function. Do count `T2.CustomerID` instead of `t.transaction_id` in the ORDER BY clause. The amended query now correctly matches the RIGHT_SQL's behavior with proper table references and column names.",
            "Do select individual columns `T1.First` and `T1.Last` instead of concatenating them as `FullName`. Do use explicit `INNER JOIN` instead of implicit `JOIN`. Do quote the table name `transaction` with backticks instead of leaving it unquoted. Do maintain the same date filtering with `STRFTIME` instead of `strftime` (case difference only). The amended query now correctly returns separate first and last name columns while maintaining the same join logic, filtering, grouping, and ordering behavior to identify the customer with the most transactions in August 2014."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name \nFROM customers c\nJOIN transactions t ON c.customer_id = t.customer_id\nWHERE strftime('%Y-%m', t.transaction_date) = '2014-08'\nGROUP BY c.customer_id\nORDER BY COUNT(t.transaction_id) DESC\nLIMIT 1;",
            "SELECT T1.First || ' ' || T1.Last AS FullName\nFROM customers T1\nJOIN transaction T2 ON T1.CustomerID = T2.CustomerID\nWHERE strftime('%Y-%m', T2.TransactionDate) = '2014-08'\nGROUP BY T1.CustomerID\nORDER BY COUNT(T2.CustomerID) DESC\nLIMIT 1;",
            "SELECT T1.First, T1.Last\nFROM customers T1\nINNER JOIN `transaction` T2 ON T1.CustomerID = T2.CustomerID\nWHERE STRFTIME('%Y-%m', T2.TransactionDate) = '2014-08'\nGROUP BY T1.CustomerID\nORDER BY COUNT(T2.CustomerID) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3326": {
        "db_id": "video_games",
        "question": "Show the id of the game platform with the most sales in region 2.",
        "ground_truth": "SELECT T1.game_platform_id FROM ( SELECT T.game_platform_id, SUM(T.num_sales) FROM region_sales AS T WHERE T.region_id = 2 GROUP BY T.game_platform_id ORDER BY SUM(T.num_sales) DESC LIMIT 1 ) T1",
        "amends": [
            "Do select `T1.game_platform_id` instead of `platform_id` from the wrong table. Do use a subquery with `SUM(T.num_sales)` aggregation instead of selecting raw `sales_amount`. Do query from `region_sales AS T` instead of `sales` with proper table aliasing. Do filter with `T.region_id = 2` instead of `region_id = 2` with table qualification. Do add `GROUP BY T.game_platform_id` instead of omitting grouping. Do order by `SUM(T.num_sales) DESC` instead of `sales_amount DESC` to match the aggregated metric. Do maintain `LIMIT 1` but within the subquery context instead of the main query. The amended query now correctly aggregates sales by platform within the specified region and returns the platform with the highest total sales, matching the intended behavior.",
            "Do use a subquery with an alias `T1` to select `game_platform_id` instead of selecting it directly from the main query. Do include the aggregate function `SUM(T.num_sales)` in the subquery's SELECT list instead of omitting it. Do maintain the same `WHERE` filter on `T.region_id = 2`, `GROUP BY T.game_platform_id`, `ORDER BY SUM(T.num_sales) DESC`, and `LIMIT 1` within the subquery instead of having them in the outer query. The amended query now correctly wraps the aggregation and ordering in a subquery before selecting the final result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform_id FROM sales WHERE region_id = 2 ORDER BY sales_amount DESC LIMIT 1;",
            "SELECT T1.game_platform_id\nFROM region_sales AS T\nWHERE T.region_id = 2\nGROUP BY T.game_platform_id\nORDER BY SUM(T.num_sales) DESC\nLIMIT 1",
            "SELECT T1.game_platform_id\nFROM (\n    SELECT T.game_platform_id, SUM(T.num_sales) as total_sales\n    FROM region_sales AS T\n    WHERE T.region_id = 2\n    GROUP BY T.game_platform_id\n    ORDER BY SUM(T.num_sales) DESC\n    LIMIT 1\n) AS T1"
        ],
        "rule_sql": []
    },
    "5560": {
        "db_id": "menu",
        "question": "Among the menus with over 10 pages, how many of them have over 20 dishes?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE page_count > 10 AND dish_count > 20",
        "amends": [
            "Do reference table `Menu` instead of `menus` in the FROM clause. Do use column `page_count` instead of `pages` in the WHERE filter. Do use column `dish_count` instead of `dishes` in the WHERE filter. The amended query now correctly counts records from the Menu table where both page_count exceeds 10 and dish_count exceeds 20."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menus WHERE pages > 10 AND dishes > 20;",
            "SELECT COUNT(*) FROM Menu WHERE page_count > 10 AND dish_count > 20"
        ],
        "rule_sql": []
    },
    "7027": {
        "db_id": "works_cycles",
        "question": "Between Northwest and Southeast of the United States, which territory one recorded the highest amount of sales last year?",
        "ground_truth": "SELECT Name FROM SalesTerritory WHERE CountryRegionCode = 'US' AND (Name = 'Northwest' OR Name = 'Southeast') ORDER BY SalesLastYear DESC LIMIT 1",
        "amends": [
            "Do select `Name` instead of `territory` and `MAX(sales_amount)`. Do query from `SalesTerritory` instead of `sales_data`. Do use `WHERE CountryRegionCode = 'US'` instead of omitting it. Do filter with `Name = 'Northwest' OR Name = 'Southeast'` instead of `territory IN ('Northwest', 'Southeast')`. Do remove `year = 2023` and `GROUP BY territory` instead of keeping them. Do order by `SalesLastYear DESC` instead of `MAX(sales_amount) DESC`. The amended query now correctly retrieves the highest performing US sales territory from the designated table with proper filtering and ordering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT territory, MAX(sales_amount) \nFROM sales_data \nWHERE territory IN ('Northwest', 'Southeast') \nAND year = 2023 \nGROUP BY territory \nORDER BY MAX(sales_amount) DESC \nLIMIT 1;",
            "SELECT Name \nFROM SalesTerritory \nWHERE CountryRegionCode = 'US' \nAND (Name = 'Northwest' OR Name = 'Southeast') \nORDER BY SalesLastYear DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1382": {
        "db_id": "synthea",
        "question": "Describe the encounter of Mr. Hubert Baumbach on 2008/10/25.",
        "ground_truth": "SELECT T2.description FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Mr.' AND T1.first = 'Hubert' AND T1.last = 'Baumbach' AND T2.date = '2008-10-25'",
        "amends": [
            "Do select only `T2.description` instead of all columns with `*`. Do join `patients AS T1` with `encounters AS T2` on `T1.patient = T2.PATIENT` instead of querying only the `encounters` table. Do filter on `T1.prefix = 'Mr.'` and `T1.first = 'Hubert'` and `T1.last = 'Baumbach'` instead of filtering directly on a concatenated `patient_name` field. Do filter on `T2.date = '2008-10-25'` instead of `encounter_date = '2008-10-25'`. The amended query now correctly joins patient and encounter tables using proper foreign key relationships and filters on individual name components instead of assuming a pre-formatted patient name field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM encounters WHERE patient_name = 'Mr. Hubert Baumbach' AND encounter_date = '2008-10-25';",
            "SELECT T2.description \nFROM patients AS T1 \nJOIN encounters AS T2 ON T1.patient = T2.PATIENT \nWHERE T1.prefix = 'Mr.' \nAND T1.first = 'Hubert' \nAND T1.last = 'Baumbach' \nAND T2.DATE = '2008-10-25';"
        ],
        "rule_sql": []
    },
    "8371": {
        "db_id": "mondial_geo",
        "question": "What is the total number of Afro-Asian people in the most populous Asian country governed by a monarchy?",
        "ground_truth": "SELECT T5.Percentage * T6.Population FROM ethnicGroup AS T5 INNER JOIN country AS T6 ON T5.Country = T6.Code WHERE Country = ( SELECT T3.Code FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN politics AS T4 ON T4.Country = T3.Code WHERE T4.Government = 'monarchy' AND T1.Name = 'Asia' ORDER BY T3.Population DESC LIMIT 1 ) AND T5.Name = 'Afro-Asian'",
        "amends": [
            "Do use a subquery to find the country code instead of directly filtering on continent and government form. Do join `ethnicGroup` with `country` on `Country=Code` instead of querying a single table. Do select `Percentage * Population` instead of just `SUM(afro_asian)`. Do filter on `T5.Name = 'Afro-Asian'` instead of assuming a column named `afro_asian`. Do use proper table aliases (`T5`, `T6`) instead of no aliases. Do include multiple table joins (`continent`, `encompasses`, `country`, `politics`) in the subquery instead of simple WHERE conditions. Do reference `T4.Government = 'monarchy'` and `T1.Name = 'Asia'` instead of `continent = 'Asia' AND government_form = 'Monarchy'`. The amended query now correctly calculates the Afro-Asian population by multiplying percentage with total population for the specified country, matching the RIGHT_SQL's behavior.",
            "Do remove the `SUM` aggregate function and the alias `total_afro_asian_population` instead of keeping them. Do change the subquery to select `T3.Code` instead of `T2.Country` for proper country code matching. Do reorder the join conditions in the subquery to use `INNER JOIN` with `T1.Name = T2.Continent` instead of the original join structure. Do remove the explicit `JOIN` keyword and use `INNER JOIN` explicitly instead of implicit join syntax. Do simplify the WHERE clause by removing redundant table prefixes on `Country` and maintaining the same filter conditions. The amended query now correctly calculates the Afro-Asian population percentage without aggregation and uses the proper country code reference in the subquery.",
            "Do remove the division by `100` in the SELECT expression instead of keeping it. Do change the JOIN to `INNER JOIN` instead of just `JOIN` for explicit clarity. Do remove the redundant `T5.Country =` condition in the WHERE clause instead of keeping it duplicated from the subquery. Do restructure the subquery's FROM clause to start with `continent` instead of `country` and adjust the join order accordingly. Do remove the unnecessary table aliases in the subquery's WHERE clause (`T4.Government` and `T1.Name`) instead of keeping them since they're already qualified. Do maintain the same `ORDER BY T3.Population DESC LIMIT 1` logic in the subquery instead of changing it. The amended query now correctly calculates the population count without erroneous division and maintains proper join semantics throughout."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(afro_asian) \nFROM countries \nWHERE continent = 'Asia' \nAND government_form = 'Monarchy' \nORDER BY population DESC \nLIMIT 1;",
            "SELECT SUM(T5.Percentage * T6.Population / 100) AS total_afro_asian_population\nFROM ethnicGroup T5\nJOIN country T6 ON T5.Country = T6.Code\nWHERE T5.Country = (\n    SELECT T2.Country\n    FROM encompasses T2\n    JOIN continent T1 ON T2.Continent = T1.Name\n    JOIN country T3 ON T2.Country = T3.Code\n    JOIN politics T4 ON T3.Code = T4.Country\n    WHERE T1.Name = 'Asia' AND T4.Government = 'monarchy'\n    ORDER BY T3.Population DESC\n    LIMIT 1\n) AND T5.Name = 'Afro-Asian'",
            "SELECT (T5.Percentage * T6.Population) / 100\nFROM ethnicGroup T5\nJOIN country T6 ON T5.Country = T6.Code\nWHERE T5.Name = 'Afro-Asian'\nAND T5.Country = (\n    SELECT T3.Code\n    FROM country T3\n    INNER JOIN encompasses T2 ON T3.Code = T2.Country\n    INNER JOIN continent T1 ON T2.Continent = T1.Name\n    INNER JOIN politics T4 ON T3.Code = T4.Country\n    WHERE T1.Name = 'Asia'\n    AND T4.Government = 'monarchy'\n    ORDER BY T3.Population DESC\n    LIMIT 1\n)",
            "SELECT (T5.Percentage * T6.Population) \nFROM ethnicGroup T5\nINNER JOIN country T6 ON T5.Country = T6.Code\nWHERE T5.Name = 'Afro-Asian' \nAND T5.Country = (\n    SELECT T3.Code\n    FROM continent T1\n    INNER JOIN encompasses T2 ON T1.Name = T2.Continent\n    INNER JOIN country T3 ON T2.Country = T3.Code\n    INNER JOIN politics T4 ON T3.Code = T4.Country\n    WHERE T1.Name = 'Asia' \n    AND T4.Government = 'monarchy'\n    ORDER BY T3.Population DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "2265": {
        "db_id": "movielens",
        "question": "What are the ID of actors with quality rating of 3 acted in English USA movies?",
        "ground_truth": "SELECT T2.actorid FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid INNER JOIN actors AS T3 ON T2.actorid = T3.actorid WHERE T3.a_quality = 3 AND T1.country = 'USA' AND T1.isEnglish = 'T'",
        "amends": [
            "Do select `T2.actorid` from the join result instead of `actor_id` directly from the actors table. Do join `movies AS T1` and `movies2actors AS T2` with `INNER JOIN` on `T1.movieid = T2.movieid` instead of querying only the actors table. Do add another `INNER JOIN` to `actors AS T3` on `T2.actorid = T3.actorid` instead of missing these table relationships. Do use filter `T3.a_quality = 3` instead of `quality_rating = 3` to reference the correct column name. Do filter on `T1.country = 'USA'` instead of `country = 'USA'` to reference the movies table. Do add filter `T1.isEnglish = 'T'` instead of `language = 'English'` to use the correct column and value format. The amended query now correctly joins multiple tables and references the appropriate columns to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id FROM actors WHERE quality_rating = 3 AND language = 'English' AND country = 'USA';",
            "SELECT T2.actorid\nFROM movies AS T1\nINNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid\nINNER JOIN actors AS T3 ON T2.actorid = T3.actorid\nWHERE T3.a_quality = 3\nAND T1.country = 'USA'\nAND T1.isEnglish = 'T';"
        ],
        "rule_sql": []
    },
    "8225": {
        "db_id": "mondial_geo",
        "question": "What is the full name of the country with 100% Africans?",
        "ground_truth": "SELECT T1.Name FROM ethnicGroup AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T1.Percentage = 100 AND T1.Name = 'African'",
        "amends": [
            "Do select `T1.Name` from the `ethnicGroup` table instead of `name` from the `countries` table. Do join `ethnicGroup AS T1` with `country AS T2` using `INNER JOIN` on `T1.Country = T2.Code` instead of querying a single table. Do filter with `T1.Percentage = 100 AND T1.Name = 'African'` instead of `population = '100% Africans'` to properly match ethnic group data. The amended query now correctly retrieves countries where the African ethnic group represents 100% of the population, matching the intended behavior.",
            "Do select `T1.Name` instead of `T2.Name` to correctly reference the ethnic group name from the ethnicGroup table rather than the country name from the country table. The amended query now matches RIGHT_SQL's behavior by returning the ethnic group name as intended."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE population = '100% Africans';",
            "SELECT T2.Name \nFROM ethnicGroup AS T1 \nINNER JOIN country AS T2 ON T1.Country = T2.Code \nWHERE T1.Percentage = 100 AND T1.Name = 'African'",
            "SELECT T1.Name FROM ethnicGroup AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T1.Percentage = 100 AND T1.Name = 'African'"
        ],
        "rule_sql": []
    },
    "2916": {
        "db_id": "professional_basketball",
        "question": "How many times have coaches who were from CHI been awarded as NBA Coach of the Year?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.coachID) FROM coaches AS T1 INNER JOIN awards_coaches AS T2 ON T1.coachID = T2.coachID WHERE T1.tmID = 'CHI' AND T2.award = 'NBA Coach of the Year'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.coachID)` instead of `COUNT(*)` to count unique coaches rather than all award records. Do reference `coachID` instead of `coach_id` for the join condition. Do use table aliases `T1` and `T2` instead of `c` and `ac` for clarity. Do filter on `T1.tmID = 'CHI'` instead of `c.team = 'CHI'` to use the correct column name for team identification. Do maintain the `INNER JOIN` structure but with corrected column references. The amended query now correctly counts distinct coaches who won the specified award for the Chicago team, matching the intended behavior.",
            "Do remove the `T1.year = T2.year` join condition instead of including it, as the correct logic only requires matching on `coachID`. Do keep the `COUNT(DISTINCT T2.coachID)` aggregation and maintain the `INNER JOIN` between `coaches` and `awards_coaches` tables. Do preserve the `WHERE` filter conditions `T1.tmID = 'CHI'` and `T2.award = 'NBA Coach of the Year'` without changes. The amended query now correctly counts distinct coaches who won Coach of the Year award while coaching Chicago, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM coaches c\nJOIN awards_coaches ac ON c.coach_id = ac.coach_id\nWHERE c.team = 'CHI' AND ac.award = 'NBA Coach of the Year';",
            "SELECT COUNT(DISTINCT T2.coachID) \nFROM coaches T1\nINNER JOIN awards_coaches T2 ON T1.coachID = T2.coachID AND T1.year = T2.year\nWHERE T1.tmID = 'CHI' AND T2.award = 'NBA Coach of the Year'",
            "SELECT COUNT(DISTINCT T2.coachID) \nFROM coaches T1\nINNER JOIN awards_coaches T2 ON T1.coachID = T2.coachID\nWHERE T1.tmID = 'CHI' \nAND T2.award = 'NBA Coach of the Year'"
        ],
        "rule_sql": []
    },
    "260": {
        "db_id": "retail_complains",
        "question": "Which detailed product did Mr Lennox Oliver Drake complain about?",
        "ground_truth": "SELECT DISTINCT T2.`Sub-product` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Lennox' AND T1.middle = 'Oliver' AND T1.last = 'Drake' AND T1.sex = 'Male'",
        "amends": [
            "Do select `T2.Sub-product` instead of `product_name` and add `DISTINCT` instead of omitting it. Do use `client AS T1 INNER JOIN events AS T2` instead of `complaints` table alone, with join condition `T1.client_id = T2.Client_ID` instead of no join. Do add multiple WHERE filters on `T1.first = 'Lennox'`, `T1.middle = 'Oliver'`, `T1.last = 'Drake'`, and `T1.sex = 'Male'` instead of single filter `customer_name = 'Mr Lennox Oliver Drake'`. The amended query now correctly joins client and events tables to find distinct sub-products for the specified male customer with precise name matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM complaints WHERE customer_name = 'Mr Lennox Oliver Drake'",
            "SELECT DISTINCT T2.\"Sub-product\"\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.first = 'Lennox' \nAND T1.middle = 'Oliver' \nAND T1.last = 'Drake' \nAND T1.sex = 'Male';"
        ],
        "rule_sql": []
    },
    "3390": {
        "db_id": "video_games",
        "question": "Provide any five games and release year under the sports genre.",
        "ground_truth": "SELECT T3.game_name, T1.release_year FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN genre AS T4 ON T3.genre_id = T4.id WHERE T4.genre_name = 'Sports' LIMIT 5",
        "amends": [
            "Do select `T3.game_name` and `T1.release_year` instead of `name` and `release_year`. Do join multiple tables including `game_platform AS T1`, `game_publisher AS T2`, `game AS T3`, and `genre AS T4` instead of querying a single table. Do use `INNER JOIN` with proper foreign key relationships `T1.game_publisher_id = T2.id`, `T2.game_id = T3.id`, and `T3.genre_id = T4.id` instead of no joins. Do filter on `T4.genre_name = 'Sports'` instead of `genre = 'sports'` to reference the correct normalized genre table. The amended query now correctly joins the normalized schema and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, release_year FROM games WHERE genre = 'sports' LIMIT 5;",
            "SELECT T3.game_name, T1.release_year\nFROM game_platform AS T1\nINNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id\nINNER JOIN game AS T3 ON T2.game_id = T3.id\nINNER JOIN genre AS T4 ON T3.genre_id = T4.id\nWHERE T4.genre_name = 'Sports'\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "2320": {
        "db_id": "movielens",
        "question": "How many separate 35 year-old uesers have rated the movie from UK?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.userid) FROM movies AS T1 INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid INNER JOIN users AS T3 ON T2.userid = T3.userid WHERE T1.country = 'UK' AND T3.age = 35",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `m`, `r`, and `u`. Do reference column `T2.userid` instead of `u.user_id` in the SELECT list. Do use table name `u2base` instead of `ratings` for the ratings table. Do reference column `T1.movieid` instead of `m.movie_id` in the join condition. Do reference column `T2.movieid` instead of `r.movie_id` in the join condition. Do reference column `T2.userid` instead of `r.user_id` in the join condition. Do reference column `T3.userid` instead of `u.user_id` in the join condition. Do place filter `T3.age = 35` after `T1.country = 'UK'` instead of before it in the WHERE clause. The amended query now correctly counts distinct users from the u2base table who rated UK movies while being 35 years old, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT u.user_id) \nFROM users u\nJOIN ratings r ON u.user_id = r.user_id\nJOIN movies m ON r.movie_id = m.movie_id\nWHERE u.age = 35 AND m.country = 'UK';",
            "SELECT COUNT(DISTINCT T2.userid) \nFROM movies T1\nJOIN u2base T2 ON T1.movieid = T2.movieid\nJOIN users T3 ON T2.userid = T3.userid\nWHERE T1.country = 'UK' AND T3.age = '35'"
        ],
        "rule_sql": []
    },
    "3530": {
        "db_id": "authors",
        "question": "In year 1999, list the titles and conference's short name of paper authored by someone named \"Philip\".",
        "ground_truth": "SELECT T1.Title, T3.ShortName FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id WHERE T1.Year = 1999 AND T2.Name LIKE 'Philip%'",
        "amends": [
            "Do reference `T1.Title` and `T3.ShortName` instead of `p.title` and `c.short_name`. Do use `INNER JOIN` with explicit `AS` table aliases instead of implicit aliases. Do join `PaperAuthor AS T2` on `T1.Id = T2.PaperId` instead of joining through `authors` table. Do filter with `T2.Name LIKE 'Philip%'` instead of `a.first_name = 'Philip'` to match names starting with Philip rather than exact first name matches. Do remove the unnecessary join to the `authors` table since the name filter is now applied directly to `PaperAuthor`. The amended query now correctly matches the RIGHT_SQL's behavior by filtering for papers from 1999 with authors whose names start with Philip, using the appropriate table relationships and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.title, c.short_name \nFROM papers p \nJOIN conferences c ON p.conference_id = c.id \nJOIN paper_authors pa ON p.id = pa.paper_id \nJOIN authors a ON pa.author_id = a.id \nWHERE p.year = 1999 AND a.first_name = 'Philip'",
            "SELECT T1.Title, T3.ShortName\nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nINNER JOIN Conference AS T3 ON T1.ConferenceId = T3.Id\nWHERE T1.Year = 1999\nAND T2.Name LIKE 'Philip%'"
        ],
        "rule_sql": []
    },
    "7992": {
        "db_id": "university",
        "question": "What is the ID of the university that has only 1% of international students between 2011 to 2015?",
        "ground_truth": "SELECT university_id FROM university_year WHERE pct_international_students = 1 AND year BETWEEN 2011 AND 2015",
        "amends": [
            "Do query from `university_year` table instead of `universities` table. Do filter on `pct_international_students = 1` instead of `international_students_percentage = 1` while keeping the same `year BETWEEN 2011 AND 2015` condition. The amended query now correctly references the appropriate table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_id FROM universities WHERE international_students_percentage = 1 AND year BETWEEN 2011 AND 2015;",
            "SELECT university_id FROM university_year WHERE pct_international_students = 1 AND year BETWEEN 2011 AND 2015"
        ],
        "rule_sql": []
    },
    "68": {
        "db_id": "movie_platform",
        "question": "How many critics of the movie \"Imitation of Life\" got more than 1 like?",
        "ground_truth": "SELECT COUNT(*) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Imitation of Life' AND T1.critic_likes > 1",
        "amends": [
            "Do join `ratings AS T1` with `movies AS T2` on `T1.movie_id = T2.movie_id` instead of querying only the `critics` table. Do filter on `T2.movie_title = 'Imitation of Life'` instead of filtering directly on a `movie_title` column that doesn't exist in the critics table. Do use `T1.critic_likes > 1` instead of `likes > 1` to reference the correct column from the ratings table. The amended query now correctly joins the ratings and movies tables to count ratings for the specified movie title with the proper like count condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM critics WHERE movie_title = 'Imitation of Life' AND likes > 1;",
            "SELECT COUNT(*) \nFROM ratings AS T1\nJOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE T2.movie_title = 'Imitation of Life' \nAND T1.critic_likes > 1"
        ],
        "rule_sql": []
    },
    "4413": {
        "db_id": "student_loan",
        "question": "What is the employment, disability, gender and school debt status for student180 and student117?",
        "ground_truth": "SELECT ( SELECT COUNT(name) FROM disabled WHERE name IN ('student180', 'student117') ), ( SELECT COUNT(name) FROM unemployed WHERE name IN ('student180', 'student117') ), ( SELECT COUNT(name) FROM male WHERE name IN ('student180', 'student117') ), ( SELECT COUNT(name) FROM no_payment_due WHERE name IN ('student180', 'student117'))",
        "amends": [
            "Do use subqueries with `COUNT(name)` aggregations for each category instead of selecting raw columns `employment`, `disability`, `gender`, `school_debt`. Do query from specialized tables `disabled`, `unemployed`, `male`, and `no_payment_due` instead of the single `students` table. Do maintain the same filter condition `name IN ('student180', 'student117')` across all subqueries instead of filtering at the main query level. Do return count results for each category instead of individual student attribute values. The amended query now correctly aggregates counts from specialized tables matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employment, disability, gender, school_debt FROM students WHERE student_id IN ('student180', 'student117');",
            "SELECT \n    (SELECT COUNT(*) FROM unemployed WHERE name IN ('student180', 'student117')) AS employment,\n    (SELECT COUNT(*) FROM disabled WHERE name IN ('student180', 'student117')) AS disability,\n    (SELECT COUNT(*) FROM male WHERE name IN ('student180', 'student117')) AS gender,\n    (SELECT COUNT(*) FROM no_payment_due WHERE name IN ('student180', 'student117')) AS school_debt;"
        ],
        "rule_sql": []
    },
    "6946": {
        "db_id": "ice_hockey_draft",
        "question": "Identify the players with the same height as Brian Gionta. How tall are they?",
        "ground_truth": "SELECT T2.PlayerName, T1.height_in_cm FROM height_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height WHERE T2.height = ( SELECT height FROM PlayerInfo WHERE PlayerName = 'Brian Gionta' )",
        "amends": [
            "Do select `T2.PlayerName` and `T1.height_in_cm` instead of `name` and `height`. Do use `FROM height_info AS T1 INNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height` instead of `FROM players` with no join. Do reference `T2.height` in the subquery instead of `height` from the original table. Do use `PlayerInfo` table in the subquery instead of `players`. Do use `PlayerName` column in the subquery filter instead of `name`. The amended query now correctly joins the height information table with player details and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, height FROM players WHERE height = (SELECT height FROM players WHERE name = 'Brian Gionta')",
            "SELECT T2.PlayerName, T1.height_in_cm\nFROM height_info AS T1\nINNER JOIN PlayerInfo AS T2 ON T1.height_id = T2.height\nWHERE T1.height_id = (\n    SELECT T2_inner.height\n    FROM PlayerInfo AS T2_inner\n    WHERE T2_inner.PlayerName = 'Brian Gionta'\n);"
        ],
        "rule_sql": []
    },
    "2291": {
        "db_id": "movielens",
        "question": "How many of the users who rate the movie with the id '2462959' are female?",
        "ground_truth": "SELECT COUNT(T1.userid) FROM users AS T1 INNER JOIN u2base AS T2 ON T1.userid = T2.userid WHERE T2.userid = 2462959 AND T1.u_gender = 'F'",
        "amends": [
            "Do use `COUNT(T1.userid)` instead of `COUNT(*)` to count specific non-null values. Do reference table `users AS T1` instead of `users u` and use proper alias naming. Do join with `u2base AS T2` instead of `ratings r` as the correct rating table. Do use `T1.userid = T2.userid` instead of `u.user_id = r.user_id` with proper column names. Do filter on `T2.userid = 2462959` instead of `r.movie_id = '2462959'` to use the correct column and remove quotes for numeric comparison. Do filter on `T1.u_gender = 'F'` instead of `u.gender = 'male'` to target the correct gender value. The amended query now correctly counts female users who rated item 2462959 using the proper table relationships and column references.",
            "Do filter on `T2.userid = 2462959` instead of `T2.movieid = 2462959` to correctly join on the user identifier rather than the movie identifier, ensuring the count reflects users associated with the specified user ID rather than movie ID. The amended query now matches RIGHT_SQL's behavior by fixing the predicate to use the appropriate join column.",
            "Do filter on `T2.userid = 2462959` instead of `T2.movieid = 2462959` to correctly count users rather than movies. Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity, though the join behavior remains identical. The amended query now correctly counts female users with user ID 2462959 instead of counting users who rated movie 2462959, matching the intended behavior.",
            "Do filter on `T2.userid = 2462959` instead of `T2.movieid = 2462959` in the WHERE clause, as the right query correctly filters by user ID rather than movie ID to count users matching the specified criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users u JOIN ratings r ON u.user_id = r.user_id WHERE r.movie_id = '2462959' AND u.gender = 'male';",
            "SELECT COUNT(T1.userid) \nFROM users AS T1\nJOIN u2base AS T2 ON T1.userid = T2.userid\nWHERE T2.movieid = 2462959 AND T1.u_gender = 'F'",
            "SELECT COUNT(T1.userid) \nFROM users AS T1 \nJOIN u2base AS T2 ON T1.userid = T2.userid \nWHERE T2.movieid = 2462959 \nAND T1.u_gender = 'F'",
            "SELECT COUNT(T1.userid) \nFROM users AS T1 \nINNER JOIN u2base AS T2 ON T1.userid = T2.userid \nWHERE T2.movieid = 2462959 AND T1.u_gender = 'F'",
            "SELECT COUNT(T1.userid) \nFROM users AS T1 \nINNER JOIN u2base AS T2 ON T1.userid = T2.userid \nWHERE T2.userid = 2462959 AND T1.u_gender = 'F'"
        ],
        "rule_sql": []
    },
    "399": {
        "db_id": "retail_complains",
        "question": "In reviews for the Eagle National Bank product, how many of the 5 star reviews where from Nashville, Tennessee?",
        "ground_truth": "SELECT COUNT(T2.Stars) FROM district AS T1 INNER JOIN reviews AS T2 ON T1.district_id = T2.district_id WHERE T1.city = 'Nashville' AND T1.state_abbrev = 'TN' AND T2.Product = 'Eagle National Mortgage' AND T2.Stars = 5",
        "amends": [
            "Do join `district AS T1` with `reviews AS T2` on `T1.district_id = T2.district_id` instead of querying only the `reviews` table. Do filter on `T1.city = 'Nashville'` instead of directly on the reviews table's city. Do use `T1.state_abbrev = 'TN'` instead of `state = 'Tennessee'` for the state filter. Do filter on `T2.Product = 'Eagle National Mortgage'` instead of `product = 'Eagle National Bank'` for the product name. Do count `T2.Stars` instead of using `COUNT(*)` to count only non-null star ratings. The amended query now correctly joins district information with reviews and uses proper state abbreviations and product naming, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE stars = 5 AND city = 'Nashville' AND state = 'Tennessee' AND product = 'Eagle National Bank';",
            "SELECT COUNT(T2.Stars) \nFROM district AS T1 \nJOIN reviews AS T2 ON T1.district_id = T2.district_id \nWHERE T1.city = 'Nashville' \nAND T1.state_abbrev = 'TN' \nAND T2.Product = 'Eagle National Mortgage' \nAND T2.Stars = 5"
        ],
        "rule_sql": []
    },
    "2224": {
        "db_id": "world_development_indicators",
        "question": "Among the countries who uses the 1968 System of National Accounts methodology, how many are in the Middle East & North Africa? Name the country with the highest CO2 emissions from solid fuel consumption in kiloton.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.CountryCode) FROM indicators AS T1 INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Region = 'Middle East & North Africa' AND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.' AND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)' UNION SELECT * FROM ( SELECT T1.CountryName FROM indicators AS T1 INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Region = 'Middle East & North Africa' AND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.' AND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)' GROUP BY T1.CountryName ORDER BY SUM(T1.value) DESC LIMIT 1 )",
        "amends": [
            "Do use `COUNT(DISTINCT T1.CountryCode)` instead of `COUNT(*)` to count distinct countries. Do join `indicators AS T1` and `country AS T2` with `INNER JOIN` on `T1.CountryCode = T2.CountryCode` instead of querying a single table. Do filter with `T2.Region = 'Middle East & North Africa'` and `T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'` instead of `region` and `methodology` conditions. Do add `T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'` filter instead of omitting it. Do use `UNION` to combine results with a subquery instead of a correlated subquery in the SELECT list. Do calculate the highest emission country using `SUM(T1.value)` with `ORDER BY DESC LIMIT 1` instead of `co2_emissions_solid_fuel DESC LIMIT 1`. Do group by `T1.CountryName` instead of not using grouping. The amended query now correctly counts distinct countries and identifies the highest emission country using proper table joins and aggregation.",
            "Do remove the subquery from the `SELECT` list and instead use `UNION` to combine two separate queries. Do add `T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'` to the `WHERE` clause of the first query instead of omitting it. Do restructure the second query as a subquery in the `FROM` clause instead of having it as a scalar subquery. Do remove the `AS HighestEmissionCountry` alias instead of keeping it. Do maintain the same `INNER JOIN` on `T1.CountryCode = T2.CountryCode` and `WHERE` filters on `T2.Region` and `T2.SystemOfNationalAccounts` across both queries. The amended query now correctly uses UNION to return both the count and the country name in separate rows instead of attempting to combine them in a single row with incompatible data types.",
            "Do remove the `'Number of countries' AS ResultType` and `'Country with highest CO2 emissions' AS ResultType` aliases instead of keeping them, and do change the first query's SELECT list to only `COUNT(DISTINCT T1.CountryCode)` instead of including the ResultType column. Do add `AND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'` to the WHERE clause of the first query instead of omitting it. Do change `UNION ALL` to `UNION` instead of keeping the duplicate-allowing union. Do wrap the second query in a subquery `SELECT * FROM (...)` instead of using it directly in the union. Do remove the `ORDER BY SUM(T1.Value) DESC LIMIT 1` from the main query level and instead keep it only within the subquery instead of having it at the union level. Do remove the `AS ResultValue` alias from the second query's selection instead of keeping it. The amended query now correctly counts only countries with CO2 emissions data and finds the highest emitter using proper union semantics without duplicate rows.",
            "Do wrap the second `SELECT` with a subquery `SELECT * FROM ( ... )` instead of using it directly in the `UNION` to avoid mixing `ORDER BY` and `LIMIT` with set operations. Do maintain the same `COUNT(DISTINCT T1.CountryCode)` in the first query and `T1.CountryName` in the second query instead of changing the column selection. Do keep all `INNER JOIN` conditions on `T1.CountryCode = T2.CountryCode` and identical `WHERE` filters for `T2.Region`, `T2.SystemOfNationalAccounts`, and `T1.IndicatorName` instead of modifying any join predicates or filter conditions. Do preserve the `GROUP BY T1.CountryName` and `ORDER BY SUM(T1.Value) DESC LIMIT 1` in the subquery instead of altering the aggregation or ordering logic. The amended query now correctly handles the union operation while maintaining the intended behavior of both result sets."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS count_countries, \n       (SELECT country_name \n        FROM countries \n        WHERE region = 'Middle East & North Africa' \n        AND methodology = '1968 System of National Accounts'\n        ORDER BY co2_emissions_solid_fuel DESC \n        LIMIT 1) AS highest_emission_country\nFROM countries \nWHERE region = 'Middle East & North Africa' \nAND methodology = '1968 System of National Accounts';",
            "SELECT \n    COUNT(DISTINCT T1.CountryCode) AS CountryCount,\n    (SELECT T1.CountryName \n     FROM indicators AS T1\n     INNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode\n     WHERE T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'\n     GROUP BY T1.CountryName\n     ORDER BY SUM(T1.Value) DESC \n     LIMIT 1) AS HighestEmissionCountry\nFROM indicators AS T1\nINNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Region = 'Middle East & North Africa' \nAND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'",
            "SELECT 'Number of countries' AS ResultType, COUNT(DISTINCT T1.CountryCode) AS ResultValue\nFROM Indicators AS T1\nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Region = 'Middle East & North Africa'\nAND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'\n\nUNION ALL\n\nSELECT 'Country with highest CO2 emissions' AS ResultType, T1.CountryName AS ResultValue\nFROM Indicators AS T1\nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Region = 'Middle East & North Africa'\nAND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'\nAND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'\nGROUP BY T1.CountryName\nORDER BY SUM(T1.Value) DESC\nLIMIT 1;",
            "SELECT COUNT(DISTINCT T1.CountryCode)\nFROM indicators AS T1\nINNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Region = 'Middle East & North Africa'\nAND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'\nAND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'\n\nUNION\n\nSELECT T1.CountryName\nFROM indicators AS T1\nINNER JOIN country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Region = 'Middle East & North Africa'\nAND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'\nAND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'\nGROUP BY T1.CountryName\nORDER BY SUM(T1.Value) DESC\nLIMIT 1",
            "SELECT COUNT(DISTINCT T1.CountryCode)\nFROM Indicators AS T1\nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.Region = 'Middle East & North Africa'\nAND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'\nAND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'\n\nUNION\n\nSELECT * FROM (\n    SELECT T1.CountryName\n    FROM Indicators AS T1\n    INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode\n    WHERE T2.Region = 'Middle East & North Africa'\n    AND T2.SystemOfNationalAccounts = 'Country uses the 1968 System of National Accounts methodology.'\n    AND T1.IndicatorName = 'CO2 emissions FROM solid fuel consumption (kt)'\n    GROUP BY T1.CountryName\n    ORDER BY SUM(T1.Value) DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "3712": {
        "db_id": "college_completion",
        "question": "Give the web site address for \"Swarthmore College\".",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE WHEN chronname = 'Swarthmore College' THEN site ELSE NULL END AS T FROM institution_details ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `CASE WHEN chronname = 'Swarthmore College' THEN site ELSE NULL END AS T` instead of directly selecting `website` from `colleges` where `name = 'Swarthmore College'`. Do add `DISTINCT` in the subquery instead of omitting it. Do filter on `T IS NOT NULL` in the outer query instead of filtering directly in the WHERE clause. Do reference `institution_details` table instead of `colleges` table. Do use column `chronname` for comparison instead of `name`, and `site` instead of `website`. The amended query now correctly handles potential null values and ensures only non-null results are returned, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT website FROM colleges WHERE name = 'Swarthmore College';",
            "SELECT DISTINCT T FROM (SELECT CASE WHEN chronname = 'Swarthmore College' THEN site ELSE NULL END AS T FROM institution_details) WHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "5413": {
        "db_id": "sales",
        "question": "Indicate the quantity of Blade products sold.",
        "ground_truth": "SELECT DISTINCT T2.Quantity FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Blade'",
        "amends": [
            "Do use `SELECT DISTINCT T2.Quantity` instead of `SELECT COUNT(*)` to return specific values rather than a count. Do add `FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID` instead of just `FROM products` to join the Sales table and establish the relationship between products and sales. Do keep `WHERE T1.Name = 'Blade'` but apply it to the joined table alias instead of the original table name. Do remove the aggregate function `COUNT(*)` and instead return distinct quantity values from the Sales table. The amended query now correctly retrieves sales quantities for the specific product instead of counting all products with that name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE name = 'Blade';",
            "SELECT DISTINCT T2.Quantity FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Blade'"
        ],
        "rule_sql": []
    },
    "4051": {
        "db_id": "public_review_platform",
        "question": "Which user has done the most review on a business attributed to delivery?",
        "ground_truth": "SELECT T3.user_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Reviews AS T3 ON T2.business_id = T3.business_id WHERE T1.attribute_name = 'Delivery' GROUP BY T3.user_id ORDER BY COUNT(T2.business_id) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of no aliases. Do join `Attributes AS T1` and `Business_Attributes AS T2` on `T1.attribute_id = T2.attribute_id` instead of directly joining `reviews` with `businesses`. Do then join `Reviews AS T3` on `T2.business_id = T3.business_id` instead of the original join condition. Do filter with `T1.attribute_name = 'Delivery'` instead of using `LIKE '%delivery%'` on attributes. Do group by `T3.user_id` instead of just `user_id`. Do order by `COUNT(T2.business_id) DESC` instead of the alias `review_count`. The amended query now correctly uses normalized attribute tables for precise filtering and matches the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T2.business_id) AS review_count` from the SELECT list instead of including it, as the RIGHT_SQL only returns the user_id. Do keep the same FROM clause with `Attributes AS T1` INNER JOINed to `Business_Attributes AS T2` on `T1.attribute_id = T2.attribute_id` and then to `Reviews AS T3` on `T2.business_id = T3.business_id`. Do maintain the WHERE filter on `T1.attribute_name = 'Delivery'` and GROUP BY `T3.user_id`. Do preserve the ORDER BY `COUNT(T2.business_id) DESC` and LIMIT 1 to find the user with the most reviews for delivery businesses. The amended query now correctly returns only the user_id instead of both user_id and review_count, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, COUNT(*) as review_count \nFROM reviews \nJOIN businesses ON reviews.business_id = businesses.business_id \nWHERE businesses.attributes LIKE '%delivery%' \nGROUP BY user_id \nORDER BY review_count DESC \nLIMIT 1;",
            "SELECT T3.user_id, COUNT(T2.business_id) AS review_count\nFROM Attributes AS T1\nJOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\nJOIN Reviews AS T3 ON T2.business_id = T3.business_id\nWHERE T1.attribute_name = 'Delivery'\nGROUP BY T3.user_id\nORDER BY COUNT(T2.business_id) DESC\nLIMIT 1;",
            "SELECT T3.user_id\nFROM Attributes AS T1\nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\nINNER JOIN Reviews AS T3 ON T2.business_id = T3.business_id\nWHERE T1.attribute_name = 'Delivery'\nGROUP BY T3.user_id\nORDER BY COUNT(T2.business_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4426": {
        "db_id": "student_loan",
        "question": "State the number of students do not have payment due.",
        "ground_truth": "SELECT COUNT(name) FROM no_payment_due WHERE bool = 'neg'",
        "amends": [
            "Do select `COUNT(name)` from the `no_payment_due` table instead of `COUNT(*)` from the `students` table. Do filter on `bool = 'neg'` instead of `payment_due = 0`. The amended query now correctly counts names from the appropriate table using the proper boolean filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE payment_due = 0",
            "SELECT COUNT(name) FROM no_payment_due WHERE bool = 'neg'"
        ],
        "rule_sql": []
    },
    "6141": {
        "db_id": "food_inspection_2",
        "question": "What is the full name of the employee with the lowest salary?",
        "ground_truth": "SELECT first_name, last_name FROM employee ORDER BY salary ASC LIMIT 1",
        "amends": [
            "Do reference table `employee` instead of `employees` to correctly target the intended data source. The amended query now matches RIGHT_SQL's behavior by using the proper table name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY salary ASC LIMIT 1;",
            "SELECT first_name, last_name FROM employee WHERE salary = (SELECT MIN(salary) FROM employee);"
        ],
        "rule_sql": []
    },
    "590": {
        "db_id": "codebase_comments",
        "question": "How many solutions contain files found within the repository most people like?",
        "ground_truth": "SELECT COUNT(T2.RepoId) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Stars = ( SELECT MAX(Stars) FROM Repo )",
        "amends": [
            "Do use explicit column `COUNT(T2.RepoId)` instead of `COUNT(*)` to count specific related records. Do join tables `Repo AS T1 INNER JOIN Solution AS T2` instead of querying a single table with a subquery. Do use join condition `ON T1.Id = T2.RepoId` to properly relate repositories to solutions instead of using a subquery for repository selection. Do filter with `WHERE T1.Stars = (SELECT MAX(Stars) FROM Repo)` to find the repository with maximum stars instead of ordering by likes and taking the top result. Do reference properly aliased tables `T1` and `T2` instead of direct table names without aliases. The amended query now correctly counts solutions belonging to the repository with the highest star count using proper join semantics instead of potentially incorrect subquery results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM solutions WHERE repository_id = (SELECT repository_id FROM repositories ORDER BY likes DESC LIMIT 1);",
            "SELECT COUNT(T2.RepoId) \nFROM Repo AS T1 \nINNER JOIN Solution AS T2 ON T1.Id = T2.RepoId \nWHERE T1.Stars = (SELECT MAX(Stars) FROM Repo)"
        ],
        "rule_sql": []
    },
    "2900": {
        "db_id": "professional_basketball",
        "question": "How many players did not get more than 10 steals between the years 2000 and 2005?",
        "ground_truth": "SELECT COUNT(DISTINCT playerID) FROM player_allstar WHERE season_id BETWEEN 2000 AND 2005 AND steals <= 10",
        "amends": [
            "Do use `COUNT(DISTINCT playerID)` instead of `COUNT(*)` to count unique players rather than total rows. Do query from `player_allstar` table instead of `players` table. Do change the filter to `steals <= 10` instead of `steals > 10` to count players with 10 or fewer steals. Do use `season_id BETWEEN 2000 AND 2005` instead of `year BETWEEN 2000 AND 2005` with the correct column name. The amended query now correctly counts distinct players with 10 or fewer steals from the 2000-2005 all-star seasons."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players \nWHERE steals > 10 \nAND year BETWEEN 2000 AND 2005;",
            "SELECT COUNT(DISTINCT playerID) \nFROM player_allstar \nWHERE season_id BETWEEN 2000 AND 2005 \nAND steals <= 10"
        ],
        "rule_sql": []
    },
    "2254": {
        "db_id": "movielens",
        "question": "What is the average number of casts of movies that are from the USA?",
        "ground_truth": "SELECT AVG(T2.cast_num) FROM movies AS T1 INNER JOIN movies2actors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'USA'",
        "amends": [
            "Do use table alias `T1` for `movies` and `T2` for `movies2actors` instead of `casts` and `movies` without aliases. Do join on `T1.movieid = T2.movieid` instead of `casts.movie_id = movies.id`. Do filter on `T1.country = 'USA'` instead of `movies.country = 'USA'`. Do calculate `AVG(T2.cast_num)` from the joined table instead of `AVG(COUNT(cast_id))` which incorrectly nests aggregates. The amended query now correctly averages pre-calculated cast counts from the movies2actors table instead of attempting to count and average in a single query level, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(cast_id)) FROM casts JOIN movies ON casts.movie_id = movies.id WHERE movies.country = 'USA'",
            "SELECT AVG(T2.cast_num) \nFROM movies T1 \nJOIN movies2actors T2 ON T1.movieid = T2.movieid \nWHERE T1.country = 'USA'"
        ],
        "rule_sql": []
    },
    "8601": {
        "db_id": "chicago_crime",
        "question": "More crimes happened in which community area in January, 2018, Woodlawn or Lincoln Square?",
        "ground_truth": "SELECT T1.community_area_name FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.community_area_name IN ('Woodlawn', 'Lincoln Square') AND T2.date LIKE '%1/2018%' GROUP BY T1.community_area_name ORDER BY COUNT(T1.community_area_name) DESC LIMIT 1",
        "amends": [
            "Do use `T1.community_area_name` in the SELECT list instead of `community_area` and join `Community_Area AS T1` with `Crime AS T2` instead of querying only the `crimes` table. Do specify `INNER JOIN` with `ON T1.community_area_no = T2.community_area_no` instead of no join condition. Do filter by `T1.community_area_name IN ('Woodlawn', 'Lincoln Square')` instead of filtering by community_area values directly. Do use `T2.date LIKE '%1/2018%'` for date filtering instead of `date LIKE '2018-01%'` to match the different date format. Do group by `T1.community_area_name` instead of community_area and order by `COUNT(T1.community_area_name) DESC` instead of crime_count alias. The amended query now correctly joins the community area reference table with crime data and handles the different date format, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) AS crime_count` from the SELECT list instead of including it. Do add `LIMIT 1` to the query instead of omitting it. Do change the ORDER BY clause to use `COUNT(T1.community_area_name)` instead of `COUNT(*)`. The amended query now correctly returns only the single community area with the highest crime count from the specified areas and time period, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_area, COUNT(*) as crime_count\nFROM crimes\nWHERE date LIKE '2018-01%'\nAND community_area IN ('Woodlawn', 'Lincoln Square')\nGROUP BY community_area\nORDER BY crime_count DESC\nLIMIT 1;",
            "SELECT T1.community_area_name, COUNT(*) AS crime_count\nFROM Community_Area AS T1\nINNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no\nWHERE T1.community_area_name IN ('Woodlawn', 'Lincoln Square')\nAND T2.date LIKE '%1/2018%'\nGROUP BY T1.community_area_name\nORDER BY COUNT(*) DESC;",
            "SELECT T1.community_area_name\nFROM Community_Area AS T1\nINNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no\nWHERE T1.community_area_name IN ('Woodlawn', 'Lincoln Square')\nAND T2.date LIKE '%1/2018%'\nGROUP BY T1.community_area_name\nORDER BY COUNT(T1.community_area_name) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "217": {
        "db_id": "book_publishing_company",
        "question": "Show me the employ id of the highest employee who doesn't have a middle name.",
        "ground_truth": "SELECT emp_id FROM employee WHERE minit = '' ORDER BY job_lvl DESC LIMIT 1",
        "amends": [
            "Do select `emp_id` instead of `employ_id` and use table `employee` instead of `employees`. Do filter on `minit = ''` instead of `middle_name IS NULL` to check for empty strings rather than null values. Do order by `job_lvl DESC` instead of `salary DESC` to sort by job level rather than salary. The amended query now correctly retrieves the employee ID from the employee table where the middle initial is empty, ordered by job level descending with a limit of one, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employ_id FROM employees WHERE middle_name IS NULL ORDER BY salary DESC LIMIT 1;",
            "SELECT emp_id FROM employee WHERE minit = '' ORDER BY job_lvl DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "490": {
        "db_id": "movies_4",
        "question": "Provide the genre ID of the movie with the title of \"The Dark Knight\".",
        "ground_truth": "SELECT T2.genre_id FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id WHERE T1.title = 'The Dark Knight'",
        "amends": [
            "Do join `movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id` instead of querying only the `movies` table. Do select `T2.genre_id` from the joined table instead of `genre_id` directly from the movies table. Do add the join condition `ON T1.movie_id = T2.movie_id` instead of omitting the relationship between movies and their genres. Do keep the filter `WHERE T1.title = 'The Dark Knight'` in the same position but reference it through the joined table alias. The amended query now correctly retrieves genre information from the related movie_genres table instead of assuming genre_id exists directly in the movies table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre_id FROM movies WHERE title = 'The Dark Knight';",
            "SELECT T2.genre_id FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id WHERE T1.title = 'The Dark Knight'"
        ],
        "rule_sql": []
    },
    "7480": {
        "db_id": "image_and_language",
        "question": "How many images have at least one object sample in the class of \"man\"?",
        "ground_truth": "SELECT COUNT(T.IMG_ID) FROM ( SELECT T2.IMG_ID FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.OBJ_CLASS = 'man' GROUP BY T2.IMG_ID ) T",
        "amends": [
            "Do select `COUNT(T.IMG_ID)` from a subquery instead of `COUNT(*)` directly from the images table. Do use a subquery that selects `T2.IMG_ID` from joined tables instead of querying the images table directly. Do join `OBJ_CLASSES AS T1` and `IMG_OBJ AS T2` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of filtering the images table by class. Do filter on `T1.OBJ_CLASS = 'man'` in the subquery instead of `class = 'man'` in the main query. Do add `GROUP BY T2.IMG_ID` in the subquery to count distinct images instead of counting all rows. The amended query now correctly counts distinct images containing objects classified as 'man' rather than counting all images with a class field, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE class = 'man';",
            "SELECT COUNT(T.IMG_ID) FROM (SELECT DISTINCT T2.IMG_ID FROM OBJ_CLASSES AS T1 JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T1.OBJ_CLASS = 'man') AS T"
        ],
        "rule_sql": []
    },
    "4507": {
        "db_id": "student_loan",
        "question": "What is the percentage difference between month 0 absence and month 9 absence?",
        "ground_truth": "SELECT CAST(((SUM(IIF(month = 0, 1, 0)) - SUM(IIF(month = 9, 1, 0)))) AS REAL) * 100 / SUM(IIF(month = 0, 1, 0)) FROM longest_absense_from_school",
        "amends": [
            "Do use `SUM(IIF(month = 0, 1, 0))` and `SUM(IIF(month = 9, 1, 0))` to calculate absence counts by month instead of directly referencing `month_0_absence` and `month_9_absence` columns. Do cast the difference as `REAL` before multiplication instead of performing integer division. Do change the table reference to `longest_absense_from_school` instead of `absence_table`. Do restructure the calculation to `(month_0_count - month_9_count) * 100 / month_0_count` instead of `(month_9_absence - month_0_absence) / month_0_absence * 100` to correctly compute the percentage difference. The amended query now properly aggregates monthly absence data and handles the percentage calculation with appropriate casting to avoid integer division issues."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ((month_9_absence - month_0_absence) / month_0_absence) * 100 AS percentage_difference FROM absence_table;",
            "SELECT \n    (SUM(IIF(month = 0, 1, 0)) - SUM(IIF(month = 9, 1, 0))) * 100.0 / SUM(IIF(month = 0, 1, 0)) AS percentage_difference\nFROM longest_absense_from_school\nWHERE month = 0 OR month = 9;"
        ],
        "rule_sql": []
    },
    "1350": {
        "db_id": "law_episode",
        "question": "Which episode was nominated for the award for \"Outstanding Costume Design for a Series\"?",
        "ground_truth": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award = 'Outstanding Costume Design for a Series'",
        "amends": [
            "Do select `T2.title` from the `Episode` table instead of `episode_title` from the `episodes` table. Do join `Award AS T1` with `Episode AS T2` using `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying only the `episodes` table without any join. Do filter on `T1.award = 'Outstanding Costume Design for a Series'` instead of `award_name = 'Outstanding Costume Design for a Series'` to correctly reference the award column from the appropriate table. The amended query now properly links awards to their corresponding episodes through the correct join relationship and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_title FROM episodes WHERE award_name = 'Outstanding Costume Design for a Series'",
            "SELECT T2.title \nFROM Award AS T1 \nINNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id \nWHERE T1.award = 'Outstanding Costume Design for a Series'"
        ],
        "rule_sql": []
    },
    "4647": {
        "db_id": "disney",
        "question": "Who is the hero character of the adventure movie which was released on 2016/3/4?",
        "ground_truth": "SELECT T1.hero FROM characters AS T1 INNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie_title WHERE T2.genre = 'Adventure' AND T1.release_date = '4-Mar-16'",
        "amends": [
            "Do select `T1.hero` from the `characters` table instead of `character_name` from the `movies` table. Do join `movies_total_gross AS T2` with `INNER JOIN` on `T2.movie_title = T1.movie_title` instead of querying only the `movies` table. Do use `T2.genre = 'Adventure'` filter instead of `genre = 'adventure'` with different case sensitivity. Do use `T1.release_date = '4-Mar-16'` with proper date format instead of `release_date = '2016/3/4'` with incorrect format. The amended query now correctly joins character and movie data while using proper date formatting and case-sensitive genre matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM movies WHERE release_date = '2016/3/4' AND genre = 'adventure';",
            "SELECT T1.hero \nFROM characters AS T1\nINNER JOIN movies_total_gross AS T2 ON T2.movie_title = T1.movie_title\nWHERE T2.genre = 'Adventure' AND T1.release_date = '4-Mar-16'"
        ],
        "rule_sql": []
    },
    "4822": {
        "db_id": "legislator",
        "question": "State number of legislators who are not the senator among female legislators.",
        "ground_truth": "SELECT COUNT(*) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' AND (T2.class IS NULL OR T2.class = '')",
        "amends": [
            "Do join `current` and `current-terms` tables on `bioguide_id` instead of querying only the `legislators` table. Do use `gender_bio = 'F'` instead of `gender = 'F'` for filtering by female gender. Do filter on `class IS NULL OR class = ''` instead of `title != 'Senator'` to identify non-Senator members. Do reference the correct table aliases `T1` and `T2` instead of the single table approach. The amended query now correctly counts female legislators who are not Senators by joining the appropriate tables and using the proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE gender = 'F' AND title != 'Senator';",
            "SELECT COUNT(*) \nFROM current T1\nJOIN \"current-terms\" T2 ON T1.bioguide_id = T2.bioguide\nWHERE T1.gender_bio = 'F' \nAND (T2.class IS NULL OR T2.class = '')"
        ],
        "rule_sql": []
    },
    "7871": {
        "db_id": "world",
        "question": "Calculate the average GNP of all countries that use Arabic language.",
        "ground_truth": "SELECT AVG(T1.GNP) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Arabic'",
        "amends": [
            "Do add `INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode` instead of querying only the countries table. Do reference `T2.Language` in the WHERE clause instead of the non-existent `language` column. Do qualify the column as `T1.GNP` instead of just `GNP` for clarity. Do include table aliases `T1` and `T2` instead of omitting them. The amended query now correctly joins the Country and CountryLanguage tables to filter by language and calculate the average GNP for Arabic-speaking countries, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(GNP) FROM countries WHERE language = 'Arabic';",
            "SELECT AVG(T1.GNP) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'Arabic'"
        ],
        "rule_sql": []
    },
    "7763": {
        "db_id": "hockey",
        "question": "How many wins did the Philadelphia Flyers have over the Boston Bruins in 1985?",
        "ground_truth": "SELECT T1.W FROM TeamVsTeam AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = 1985 AND T1.tmID = ( SELECT DISTINCT tmID FROM Teams WHERE name = 'Philadelphia Flyers' ) AND T1.oppID = ( SELECT DISTINCT tmID FROM Teams WHERE name = 'Boston Bruins' )",
        "amends": [
            "Do use the `TeamVsTeam` table with proper team ID joins instead of directly filtering by team names in the `games` table. Do add an `INNER JOIN` with the `Teams` table on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of omitting this relationship. Do filter by `T1.year = 1985` instead of `year = 1985` to maintain table context. Do use subqueries to resolve team IDs with `(SELECT DISTINCT tmID FROM Teams WHERE name = 'Philadelphia Flyers')` for `T1.tmID` and `(SELECT DISTINCT tmID FROM Teams WHERE name = 'Boston Bruins')` for `T1.oppID` instead of direct string comparisons `winner = 'Philadelphia Flyers' AND loser = 'Boston Bruins'`. Do select `T1.W` (wins) instead of `COUNT(*)` to get the specific win count rather than a row count. The amended query now correctly uses the relational structure to find wins between specific teams in the given year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE winner = 'Philadelphia Flyers' AND loser = 'Boston Bruins' AND year = 1985;",
            "SELECT T1.W \nFROM TeamVsTeam T1\nINNER JOIN Teams T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nWHERE T1.year = 1985\nAND T1.tmID = (SELECT DISTINCT tmID FROM Teams WHERE name = 'Philadelphia Flyers')\nAND T1.oppID = (SELECT DISTINCT tmID FROM Teams WHERE name = 'Boston Bruins')"
        ],
        "rule_sql": []
    },
    "398": {
        "db_id": "retail_complains",
        "question": "List the product reviewed with 1 star on March 14, 2016 from Newton, Massachusetts.",
        "ground_truth": "SELECT T2.Product FROM district AS T1 INNER JOIN reviews AS T2 ON T1.district_id = T2.district_id WHERE T1.city = 'Newton' AND T1.state_abbrev = 'MA' AND T2.Date = '2016-03-14' AND T2.Stars = 1",
        "amends": [
            "Do select `T2.Product` instead of `p.product_name`. Do join `district AS T1` instead of `products p` and `customers c`. Do use `INNER JOIN` on `T1.district_id = T2.district_id` instead of joining on `p.product_id = r.product_id` and `r.customer_id = c.customer_id`. Do filter on `T1.city = 'Newton'` and `T1.state_abbrev = 'MA'` instead of `c.city = 'Newton'` and `c.state = 'Massachusetts'`. Do filter on `T2.Stars = 1` instead of `r.rating = 1`. Do keep `T2.Date = '2016-03-14'` similar to `r.review_date = '2016-03-14'`. The amended query now correctly joins district data with reviews and uses appropriate state abbreviation filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name \nFROM products p\nJOIN reviews r ON p.product_id = r.product_id\nJOIN customers c ON r.customer_id = c.customer_id\nWHERE r.rating = 1\nAND r.review_date = '2016-03-14'\nAND c.city = 'Newton'\nAND c.state = 'Massachusetts';",
            "SELECT T2.Product\nFROM district AS T1\nINNER JOIN reviews AS T2 ON T1.district_id = T2.district_id\nWHERE T1.city = 'Newton'\nAND T1.state_abbrev = 'MA'\nAND T2.Stars = 1\nAND T2.Date = '2016-03-14'"
        ],
        "rule_sql": []
    },
    "1238": {
        "db_id": "talkingdata",
        "question": "How many events does the device \"4069764298338760000\" have?",
        "ground_truth": "SELECT COUNT(event_id) FROM events WHERE device_id = 4069764298338760000",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE device_id = '4069764298338760000';"
        ],
        "rule_sql": []
    },
    "7233": {
        "db_id": "works_cycles",
        "question": "List the full name of all the 'Production Technician - WC50'",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName FROM Employee AS T1 INNER JOIN Person AS T2 USING (BusinessEntityID) WHERE T1.JobTitle = 'Production Technician - WC50' GROUP BY T2.FirstName, T2.MiddleName, T2.LastName",
        "amends": [
            "Do select `T2.FirstName`, `T2.MiddleName`, and `T2.LastName` instead of `first_name` and `last_name`. Do join `Employee AS T1` with `Person AS T2` using `BusinessEntityID` instead of querying a single `employees` table. Do filter on `T1.JobTitle = 'Production Technician - WC50'` instead of separate `job_title` and `department` conditions. Do add `GROUP BY T2.FirstName, T2.MiddleName, T2.LastName` instead of omitting grouping. The amended query now correctly joins employee and person data and filters on the combined job title format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees WHERE job_title = 'Production Technician' AND department = 'WC50';",
            "SELECT T2.FirstName, T2.MiddleName, T2.LastName\nFROM Employee AS T1\nJOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.JobTitle = 'Production Technician - WC50'\nGROUP BY T2.FirstName, T2.MiddleName, T2.LastName"
        ],
        "rule_sql": []
    },
    "42": {
        "db_id": "movie_platform",
        "question": "How many likes did the critic of the movie \"Apocalypse Now\" received after giving the movie a rating score of 5?",
        "ground_truth": "SELECT T2.critic_likes FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T2.user_trialist = 0 AND T2.rating_score = 5 AND T1.movie_title = 'Apocalypse Now'",
        "amends": [
            "Do select `T2.critic_likes` instead of `COUNT(*)` from the `likes` table. Do join `movies AS T1` and `ratings AS T2` with `INNER JOIN` on `T1.movie_id = T2.movie_id` instead of using nested subqueries to connect tables. Do add filter `T2.user_trialist = 0` instead of omitting it. Do use `T2.rating_score = 5` instead of `score = 5` in the ratings condition. Do reference `T1.movie_title = 'Apocalypse Now'` instead of filtering through subqueries. The amended query now correctly retrieves critic likes directly from the ratings table with proper join conditions and filters, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM likes WHERE critic_id = (SELECT critic_id FROM ratings WHERE movie_id = (SELECT movie_id FROM movies WHERE title = 'Apocalypse Now') AND score = 5);",
            "SELECT T2.critic_likes \nFROM movies AS T1 \nINNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id \nWHERE T1.movie_title = 'Apocalypse Now' \nAND T2.rating_score = 5 \nAND T2.user_trialist = 0"
        ],
        "rule_sql": []
    },
    "6813": {
        "db_id": "retails",
        "question": "Which region has the lowest number of countries?",
        "ground_truth": "SELECT T.r_name FROM ( SELECT T1.r_name, COUNT(T2.n_name) AS num FROM region AS T1 INNER JOIN nation AS T2 ON T1.r_regionkey = T2.n_regionkey GROUP BY T1.r_name ) AS T ORDER BY T.num LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do specify the exact column `COUNT(T2.n_name)` instead of `COUNT(*)` to count nations rather than all rows. Do join `region` and `nation` tables with `INNER JOIN` on `T1.r_regionkey = T2.n_regionkey` instead of querying a single table. Do group by the region name `T1.r_name` instead of a generic `region` column. Do order by the computed count alias `T.num` instead of the original `country_count`. Do wrap the aggregated query in a subquery `T` instead of querying directly. The amended query now correctly finds the region with the fewest nations by properly joining and counting related entities."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as country_count FROM countries GROUP BY region ORDER BY country_count ASC LIMIT 1;",
            "SELECT T.r_name\nFROM (\n    SELECT T1.r_name, COUNT(T2.n_name) AS num\n    FROM region T1\n    INNER JOIN nation T2 ON T1.r_regionkey = T2.n_regionkey\n    GROUP BY T1.r_name\n    ORDER BY num ASC\n    LIMIT 1\n) T"
        ],
        "rule_sql": []
    },
    "9380": {
        "db_id": "movie_3",
        "question": "What is the average rental rate for PG-13 rated movies?",
        "ground_truth": "SELECT AVG(rental_rate) FROM film WHERE rating = 'PG-13'",
        "amends": [
            "Do reference table `film` instead of `films` in the FROM clause. Do filter for rating `'PG-13'` instead of `'PG'` in the WHERE condition. The amended query now correctly calculates the average rental rate for PG-13 rated films from the proper table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rental_rate) FROM films WHERE rating = 'PG'",
            "SELECT AVG(rental_rate) FROM film WHERE rating = 'PG-13'"
        ],
        "rule_sql": []
    },
    "7273": {
        "db_id": "works_cycles",
        "question": "What is the highest amount of difference between the ordered quantity and actual quantity received in a single purchase order and to which vendor was the purchase order made?",
        "ground_truth": "SELECT T2.OrderQty - T2.ReceivedQty, VendorID FROM PurchaseOrderHeader AS T1 INNER JOIN PurchaseOrderDetail AS T2 ON T1.PurchaseOrderID = T2.PurchaseOrderID ORDER BY T2.OrderQty - T2.ReceivedQty DESC LIMIT 1",
        "amends": [
            "Do select the difference expression `T2.OrderQty - T2.ReceivedQty` directly instead of using `MAX(ordered_quantity - actual_quantity_received)` with aggregation. Do include `VendorID` instead of `vendor_name` in the SELECT list. Do use tables `PurchaseOrderHeader AS T1` and `PurchaseOrderDetail AS T2` with an `INNER JOIN` on `T1.PurchaseOrderID = T2.PurchaseOrderID` instead of a single table `purchase_orders`. Do remove the `GROUP BY vendor_name` clause instead of keeping it. Do order by the difference expression `T2.OrderQty - T2.ReceivedQty` directly instead of the alias `max_difference`. The amended query now correctly calculates the maximum quantity difference per purchase order detail rather than aggregating by vendor, matching the RIGHT_SQL's behavior.",
            "Do select `T2.OrderQty - T2.ReceivedQty` and `VendorID` instead of selecting `T1.VendorID` and aliasing the difference calculation. Do maintain the same `INNER JOIN` on `T1.PurchaseOrderID = T2.PurchaseOrderID` without changes. Do preserve the `ORDER BY T2.OrderQty - T2.ReceivedQty DESC` and `LIMIT 1` clauses exactly as they were. The amended query now correctly returns the raw difference value alongside VendorID without unnecessary aliasing, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(ordered_quantity - actual_quantity_received) AS max_difference, vendor_name\nFROM purchase_orders\nGROUP BY vendor_name\nORDER BY max_difference DESC\nLIMIT 1;",
            "SELECT T1.VendorID, T2.OrderQty - T2.ReceivedQty AS difference\nFROM PurchaseOrderHeader AS T1\nINNER JOIN PurchaseOrderDetail AS T2 ON T1.PurchaseOrderID = T2.PurchaseOrderID\nORDER BY T2.OrderQty - T2.ReceivedQty DESC\nLIMIT 1;",
            "SELECT T2.OrderQty - T2.ReceivedQty, T1.VendorID\nFROM PurchaseOrderHeader AS T1\nINNER JOIN PurchaseOrderDetail AS T2 ON T1.PurchaseOrderID = T2.PurchaseOrderID\nORDER BY T2.OrderQty - T2.ReceivedQty DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3814": {
        "db_id": "public_review_platform",
        "question": "What is the average rating of inactive businesses?",
        "ground_truth": "SELECT CAST(SUM(stars) AS REAL) / COUNT(business_id) AS \"average\" FROM Business WHERE active LIKE 'FALSE'",
        "amends": [
            "Do use `SUM(stars) / COUNT(business_id)` with a `CAST` to `REAL` instead of `AVG(rating)` for the average calculation. Do reference the `Business` table instead of `businesses` as the source. Do filter with `active LIKE 'FALSE'` instead of `status = 'active'` to target inactive businesses. Do add an explicit alias `\"average\"` instead of omitting column naming. The amended query now correctly calculates the average rating using sum and count division with proper casting, targets the appropriate table with the correct inactive business filter, and provides clear output naming matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM businesses WHERE status = 'active';",
            "SELECT CAST(SUM(stars) AS REAL) / COUNT(business_id) AS \"average\" FROM Business WHERE active LIKE 'FALSE';"
        ],
        "rule_sql": []
    },
    "5369": {
        "db_id": "sales",
        "question": "List down the product name for products from id 1 to 10.",
        "ground_truth": "SELECT Name FROM Products WHERE ProductID BETWEEN 1 AND 10",
        "amends": [
            "Do reference the `Name` column instead of `product_name` in the SELECT list. Do reference the `Products` table instead of `products` in the FROM clause. Do reference the `ProductID` column instead of `id` in both the WHERE filter and ORDER BY clause. Do remove the `DESC` ordering direction from the ORDER BY clause instead of keeping it. The amended query now correctly selects product names from the Products table filtered by ProductID range with ascending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE id BETWEEN 1 AND 10 ORDER BY id DESC;",
            "SELECT Name FROM Products WHERE ProductID BETWEEN 1 AND 10 ORDER BY ProductID;"
        ],
        "rule_sql": []
    },
    "7453": {
        "db_id": "works_cycles",
        "question": "What is the the percentage of profit for the product \"858\"?",
        "ground_truth": "SELECT (T1.ListPrice - T2.StandardCost) * 100 / T2.StandardCost FROM ProductListPriceHistory AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ProductID = 858",
        "amends": [
            "Do reference `T1.ListPrice` and `T2.StandardCost` instead of `price` and `cost`. Do use `(T1.ListPrice - T2.StandardCost) * 100 / T2.StandardCost` instead of `(price - cost) / price * 100` for the profit percentage calculation. Do join `ProductListPriceHistory AS T1` and `ProductCostHistory AS T2` with `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying a single `products` table. Do filter by `T1.ProductID = 858` instead of `product_id = '858'` using the correct numeric value instead of a string literal. The amended query now correctly calculates profit percentage using the proper table structure and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (price - cost) / price * 100 AS profit_percentage FROM products WHERE product_id = '858';",
            "SELECT \n    (T1.ListPrice - T2.StandardCost) * 100 / T2.StandardCost AS ProfitPercentage\nFROM \n    ProductListPriceHistory AS T1\nINNER JOIN \n    ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID\nWHERE \n    T1.ProductID = 858;"
        ],
        "rule_sql": []
    },
    "9066": {
        "db_id": "bike_share_1",
        "question": "What is the location coordinates of the bike station from which the bike for the trip that last the longest was borrowed?",
        "ground_truth": "SELECT T2.lat, T2.long FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.duration = ( SELECT MAX(T1.duration) FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name )",
        "amends": [
            "Do select `T2.lat` and `T2.long` instead of `latitude` and `longitude`. Do use `trip AS T1` and `station AS T2` as FROM sources instead of `bike_stations`. Do add `INNER JOIN` on `T2.name = T1.start_station_name` instead of no join. Do change the WHERE filter to `T1.duration = (SELECT MAX(T1.duration)...` instead of `station_id = (SELECT start_station_id...`. Do add a correlated subquery with the same join condition to find the maximum duration instead of ordering and limiting. The amended query now correctly joins trip and station tables to find coordinates for the station with the longest trip duration, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude, longitude FROM bike_stations WHERE station_id = (SELECT start_station_id FROM trips ORDER BY duration DESC LIMIT 1);",
            "SELECT T2.lat, T2.long\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.duration = (SELECT MAX(T1_inner.duration) \n                    FROM trip AS T1_inner\n                    INNER JOIN station AS T2_inner ON T2_inner.name = T1_inner.start_station_name)"
        ],
        "rule_sql": []
    },
    "2524": {
        "db_id": "app_store",
        "question": "List apps whose rating is 3.9 and state the translated review of each app.",
        "ground_truth": "SELECT T1.App, T2.Translated_Review FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Rating = 3.9",
        "amends": [
            "Do select `T1.App` and `T2.Translated_Review` instead of `app_name` and `translated_review`. Do use `FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App` instead of `FROM apps` without any join. Do filter on `T1.Rating = 3.9` as a numeric value instead of `rating = '3.9'` as a string. The amended query now correctly joins the two tables and uses proper numeric comparison for the rating filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name, translated_review FROM apps WHERE rating = '3.9';",
            "SELECT T1.App, T2.Translated_Review FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Rating = 3.9"
        ],
        "rule_sql": []
    },
    "9058": {
        "db_id": "bike_share_1",
        "question": "How many bike stations are installed after August, 2013 in San Jose?",
        "ground_truth": "SELECT COUNT(installation_date) FROM station WHERE city = 'San Jose' AND (SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) IN ('8', '9', '10', '11', '12') AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013') OR SUBSTR(CAST(installation_date AS TEXT), -4) > '2013'",
        "amends": [
            "Do use `COUNT(installation_date)` instead of `COUNT(*)` to count only non-null installation dates. Do reference table `station` instead of `bike_stations` as the correct source. Do remove the direct date comparison `installation_date > '2013-08-01'` and instead implement complex string parsing to extract month and year components from the date field. Do add string manipulation functions `SUBSTR`, `CAST`, and `INSTR` to handle the date format by converting to text and extracting specific parts. Do check for months '8' through '12' in 2013 using substring operations instead of a simple date range filter. Do add an OR condition to capture dates with years greater than 2013. Do restructure the WHERE clause with proper parentheses to combine the month/year conditions correctly. The amended query now properly handles the date field format and matches the intended counting logic.",
            "Do use `SUBSTR(CAST(installation_date AS TEXT), -4)` for year extraction instead of `CAST(SUBSTR(installation_date, 1, 4) AS INTEGER)` to handle string comparison properly. Do extract month using `SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1)` with string values `IN ('8', '9', '10', '11', '12')` instead of numeric `BETWEEN 8 AND 12` to match date format. Do fix the logical grouping by ensuring both month and year conditions apply together for 2013 dates instead of having an OR condition that incorrectly separates them. Do use string comparison `> '2013'` for years instead of numeric comparison to maintain consistency with the date format handling. The amended query now correctly filters for San Jose stations installed in the last five months of 2013 or any year after 2013, matching the intended behavior.",
            "Do use proper logical grouping with parentheses around the AND conditions instead of incorrect nesting that changes the logic. Do remove redundant CAST operations on the year extraction instead of keeping unnecessary type conversions. Do simplify the year comparison to direct string comparison instead of casting to TEXT. Do fix the condition structure to properly group the month and year checks together with AND instead of having an OR that incorrectly combines different logic. The amended query now correctly counts installations from August-December 2013 OR any year after 2013, matching the intended behavior.",
            "Do remove the redundant `CAST(... AS TEXT)` around the month extraction instead of keeping it, as the `SUBSTR` function already returns text. Do fix the logical grouping by removing the extra parentheses around the month and year condition instead of having nested parentheses, making the `OR` condition apply correctly to both the specific 2013 months and all later years. Do maintain the same `COUNT(installation_date)` aggregation and `city = 'San Jose'` filter without changes. The amended query now correctly counts installations from August-December 2013 or any year after 2013 in San Jose, matching the right SQL's behavior.",
            "Do add explicit `CAST(installation_date AS TEXT)` in all `SUBSTR` function calls instead of using the raw date column directly, which ensures proper string handling for date extraction operations. The logic structure remains identical with the same `WHERE` filter on `city = 'San Jose'` and the same conditional checking for months 8-12 in 2013 or any year after 2013, but now with proper type casting to handle potential date formatting issues. The amended query now correctly processes date values as text for substring operations while maintaining the original counting behavior."
        ],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM bike_stations WHERE installation_date > '2013-08-01' AND city = 'San Jose';",
            "SELECT COUNT(installation_date) \nFROM station \nWHERE city = 'San Jose' \nAND (\n    (CAST(SUBSTR(installation_date, 1, 4) AS INTEGER) = 2013 AND CAST(SUBSTR(installation_date, 6, 2) AS INTEGER) BETWEEN 8 AND 12)\n    OR CAST(SUBSTR(installation_date, 1, 4) AS INTEGER) > 2013\n)",
            "SELECT COUNT(installation_date) \nFROM station \nWHERE city = 'San Jose' \nAND (\n    (\n        CAST(SUBSTR(CAST(installation_date AS TEXT), -4) AS TEXT) = '2013' \n        AND SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) IN ('8', '9', '10', '11', '12')\n    ) \n    OR CAST(SUBSTR(CAST(installation_date AS TEXT), -4) AS TEXT) > '2013'\n)",
            "SELECT COUNT(installation_date) \nFROM station \nWHERE city = 'San Jose' \nAND (\n    (\n        CAST(SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) AS TEXT) IN ('8', '9', '10', '11', '12') \n        AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013'\n    ) \n    OR \n    SUBSTR(CAST(installation_date AS TEXT), -4) > '2013'\n)",
            "SELECT COUNT(installation_date)\nFROM station\nWHERE city = 'San Jose'\nAND (\n    (SUBSTR(installation_date, 1, INSTR(installation_date, '/') - 1) IN ('8', '9', '10', '11', '12') \n     AND SUBSTR(installation_date, -4) = '2013')\n    OR SUBSTR(installation_date, -4) > '2013'\n)",
            "SELECT COUNT(installation_date) \nFROM station \nWHERE city = 'San Jose' \nAND (\n    (\n        CAST(SUBSTR(CAST(installation_date AS TEXT), 1, INSTR(installation_date, '/') - 1) AS TEXT) IN ('8', '9', '10', '11', '12') \n        AND SUBSTR(CAST(installation_date AS TEXT), -4) = '2013'\n    ) \n    OR \n    SUBSTR(CAST(installation_date AS TEXT), -4) > '2013'\n)"
        ],
        "rule_sql": []
    },
    "4296": {
        "db_id": "simpson_episodes",
        "question": "Who is the writer for the episode with the most 10 star votes?",
        "ground_truth": "SELECT T1.person FROM Credit AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T1.role = 'Writer' AND T2.stars = 10 GROUP BY T1.person ORDER BY COUNT(*) DESC LIMIT 1;",
        "amends": [
            "Do select `T1.person` instead of `writer` to use the correct column name from the schema. Do add `FROM Credit AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id` instead of just `FROM episodes` to properly join the Credit and Vote tables on the episode_id relationship. Do add `WHERE T1.role = 'Writer' AND T2.stars = 10` instead of omitting filters to specifically target writer credits and 10-star votes. Do add `GROUP BY T1.person` instead of omitting grouping to aggregate votes by each writer. Do change ordering to `ORDER BY COUNT(*) DESC` instead of `ORDER BY votes_10_star DESC` to sort by the actual count of 10-star votes rather than a presumed column. The amended query now correctly identifies the writer with the most 10-star votes by joining the appropriate tables, applying proper filters, and counting votes per writer."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT writer FROM episodes ORDER BY votes_10_star DESC LIMIT 1;",
            "SELECT T1.person\nFROM Credit AS T1\nINNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id\nWHERE T1.role = 'Writer' AND T2.stars = 10\nGROUP BY T1.person\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5819": {
        "db_id": "language_corpus",
        "question": "What is the average occurrence of the word \"grec\" on each Wikipedia page that has this word?",
        "ground_truth": "SELECT CAST(SUM(T2.occurrences) AS REAL) / COUNT(T1.wid) FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE T1.word = 'grec'",
        "amends": [
            "Do use `SUM(T2.occurrences)` and `COUNT(T1.wid)` in the SELECT list instead of calculating average occurrence through string length manipulation. Do join `words AS T1` and `pages_words AS T2` with `INNER JOIN` on `T1.wid = T2.wid` instead of querying a single `wikipedia_pages` table. Do filter with `T1.word = 'grec'` in the WHERE clause instead of using `content LIKE '%grec%'` string matching. Do cast the result as `REAL` instead of relying on implicit casting. The amended query now correctly calculates average word occurrences using proper relational joins and aggregation instead of error-prone string operations, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(LENGTH(content) - LENGTH(REPLACE(content, 'grec', ''))) / LENGTH('grec') AS avg_occurrence FROM wikipedia_pages WHERE content LIKE '%grec%';",
            "SELECT CAST(SUM(T2.occurrences) AS REAL) / COUNT(T1.wid) AS average_occurrence\nFROM words AS T1\nINNER JOIN pages_words AS T2 ON T1.wid = T2.wid\nWHERE T1.word = 'grec';"
        ],
        "rule_sql": []
    },
    "3033": {
        "db_id": "shakespeare",
        "question": "What are the character names for a senator of Venice?",
        "ground_truth": "SELECT CharName FROM characters WHERE Description = 'a senator of Venice'",
        "amends": [
            "Do select `CharName` instead of `name` from the characters table. Do filter on `Description = 'a senator of Venice'` instead of separate conditions `title = 'Senator' AND city = 'Venice'`. The amended query now correctly retrieves the character names based on the unified description criteria rather than separate title and city attributes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM characters WHERE title = 'Senator' AND city = 'Venice';",
            "SELECT CharName FROM characters WHERE Description = 'a senator of Venice';"
        ],
        "rule_sql": []
    },
    "697": {
        "db_id": "trains",
        "question": "Please list the IDs of all the trains that run in the east direction and have less than 4 cars.",
        "ground_truth": "SELECT T1.id FROM trains AS T1 INNER JOIN ( SELECT train_id, MAX(position) AS carsNum FROM cars GROUP BY train_id ) AS T2 ON T1.id = T2.train_id WHERE T1.direction = 'east' AND T2.carsNum < 4",
        "amends": [
            "Do add a subquery `SELECT train_id, MAX(position) AS carsNum FROM cars GROUP BY train_id` instead of directly querying the trains table. Do use `INNER JOIN` on `T1.id = T2.train_id` instead of no join. Do reference `T2.carsNum < 4` in the WHERE clause instead of `cars >= 4` to filter by maximum car position rather than a direct column value. Do select `T1.id` instead of `train_id` with proper table qualification. The amended query now correctly joins with aggregated car data and filters based on maximum car position rather than a static column value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT train_id FROM trains WHERE direction = 'east' AND cars >= 4;",
            "SELECT T1.id\nFROM trains T1\nINNER JOIN (\n    SELECT train_id, MAX(position) AS carsNum \n    FROM cars \n    GROUP BY train_id\n) T2 ON T1.id = T2.train_id\nWHERE T1.direction = 'east' AND T2.carsNum < 4"
        ],
        "rule_sql": []
    },
    "3758": {
        "db_id": "public_review_platform",
        "question": "How many Yelp businesses are there in 'AZ' with less than \"3\" stars?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE state LIKE 'AZ' AND stars < 3",
        "amends": [
            "Do count `business_id` instead of `*` to exclude null values. Do reference table `Business` instead of `businesses` to use the correct table name. Do use `LIKE` for `state` comparison instead of `=` for pattern matching consistency. Do filter for `stars < 3` instead of `stars >= 3` to count businesses with fewer than 3 stars rather than 3 or more stars. The amended query now correctly counts business IDs with fewer than 3 stars in Arizona using the proper table reference and comparison operators."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE state = 'AZ' AND stars >= 3;",
            "SELECT COUNT(business_id) FROM Business WHERE state LIKE 'AZ' AND stars < 3"
        ],
        "rule_sql": []
    },
    "1948": {
        "db_id": "soccer_2016",
        "question": "What is the id of the team with the highest number of matches won?",
        "ground_truth": "SELECT Match_Id FROM `Match` ORDER BY Match_Winner DESC LIMIT 1",
        "amends": [
            "Do reference `Match_Id` instead of `team_id` and `Match_Winner` instead of `wins` in both the SELECT list and ORDER BY clause. Do use backticks around the table name `Match` instead of the unquoted `matches` table reference. The amended query now correctly retrieves the match ID ordered by the match winner column from the appropriate table structure.",
            "Do select `Match_Id` instead of `Match_Winner` in the SELECT list. Do remove the GROUP BY clause on `Match_Winner` instead of keeping it. Do remove the COUNT aggregation function instead of using it. Do change the ORDER BY to sort by `Match_Winner DESC` instead of ordering by `COUNT(Match_Id) DESC`. Do keep the LIMIT 1 clause as it was. The amended query now correctly selects a single Match_Id ordered by Match_Winner descending, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_id FROM matches ORDER BY wins DESC LIMIT 1;",
            "SELECT `Match_Winner`\nFROM `Match`\nGROUP BY `Match_Winner`\nORDER BY COUNT(`Match_Id`) DESC\nLIMIT 1;",
            "SELECT Match_Id FROM `Match` ORDER BY Match_Winner DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "596": {
        "db_id": "codebase_comments",
        "question": "What is the processed time to download the repository whose files are contained in the solution with the path \"jeffdik_tachy\\src\\Tachy.sln\".",
        "ground_truth": "SELECT DISTINCT T2.ProcessedTime FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Path = 'jeffdik_tachysrcTachy.sln'",
        "amends": [
            "Do select `T2.ProcessedTime` instead of `processed_time` and add `DISTINCT` instead of omitting it. Do use `Repo AS T1` and `Solution AS T2` as FROM sources instead of `solutions` and add `INNER JOIN` on `T1.Id = T2.RepoId` instead of no join. Do move the filter to `WHERE T2.Path` instead of `WHERE path` and use the correct path format `'jeffdik_tachysrcTachy.sln'` instead of `'jeffdik_tachy\\src\\Tachy.sln'`. The amended query now correctly joins the Repo and Solution tables and returns distinct processed times for the specified solution path."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT processed_time FROM solutions WHERE path = 'jeffdik_tachy\\src\\Tachy.sln';",
            "SELECT DISTINCT T1.ProcessedTime FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Path = 'jeffdik_tachysrcTachy.sln'"
        ],
        "rule_sql": []
    },
    "8185": {
        "db_id": "sales_in_weather",
        "question": "Among the stores in weather station 14 in February 2014, which store had sold no less than 300 quantities for item number 44 in a single day?",
        "ground_truth": "SELECT T1.store_nbr FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE T2.station_nbr = 14 AND T1.`date` LIKE '%2014-02%' AND T1.item_nbr = 44 AND units >= 300",
        "amends": [
            "Do select `store_nbr` instead of `store_id` and use table alias `T1` instead of no alias. Do join `relation` as `T2` with `INNER JOIN` on `T1.store_nbr = T2.store_nbr` instead of no join. Do filter on `T2.station_nbr = 14` instead of `station_id = 14` and use `T1.item_nbr = 44` instead of `item_id = 44`. Do use `units >= 300` instead of `quantity >= 300` and filter with `T1.date LIKE '%2014-02%'` instead of `strftime('%Y-%m', date) = '2014-02'`. Do remove `GROUP BY` and `HAVING` clauses instead of keeping them. The amended query now correctly joins the sales_in_weather and relation tables to filter by station number and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id \nFROM sales \nWHERE station_id = 14 \nAND item_id = 44 \nAND quantity >= 300 \nAND strftime('%Y-%m', date) = '2014-02' \nGROUP BY store_id, date \nHAVING SUM(quantity) >= 300;",
            "SELECT T1.store_nbr\nFROM sales_in_weather T1\nINNER JOIN relation T2 ON T1.store_nbr = T2.store_nbr\nWHERE T2.station_nbr = 14\nAND T1.item_nbr = 44\nAND T1.units >= 300\nAND T1.date LIKE '%2014-02%'"
        ],
        "rule_sql": []
    },
    "171": {
        "db_id": "book_publishing_company",
        "question": "State the title and royalty percentage for title ID BU2075 between 10000 to 50000 range.",
        "ground_truth": "SELECT T1.title, T2.royalty FROM titles AS T1 INNER JOIN roysched AS T2 ON T1.title_id = T2.title_id WHERE T2.lorange > 10000 AND T2.hirange < 50000 AND T1.title_ID = 'BU2075'",
        "amends": [
            "Do join `titles AS T1` with `roysched AS T2` on `T1.title_id = T2.title_id` instead of querying only the `titles` table. Do filter on `T2.lorange > 10000` and `T2.hirange < 50000` instead of `royalty BETWEEN 50000 AND 10000`. Do select `T2.royalty` from the joined table instead of `royalty` from the single table. Do use `T1.title_ID = 'BU2075'` in the WHERE clause instead of `title_id = 'BU2075'`. The amended query now correctly joins the tables and applies the proper range filters to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, royalty FROM titles WHERE title_id = 'BU2075' AND royalty BETWEEN 50000 AND 10000;",
            "SELECT T1.title, T2.royalty \nFROM titles AS T1 \nJOIN roysched AS T2 ON T1.title_id = T2.title_id \nWHERE T1.title_id = 'BU2075' \nAND T2.lorange > 10000 \nAND T2.hirange < 50000"
        ],
        "rule_sql": []
    },
    "8500": {
        "db_id": "mondial_geo",
        "question": "Which Asian country gave its agricultural sector the largest share of its gross domestic product?",
        "ground_truth": "SELECT T2.Country FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T2.Country = T3.Code INNER JOIN economy AS T4 ON T4.Country = T3.Code WHERE T1.Name = 'Asia' ORDER BY T4.Agriculture DESC LIMIT 1",
        "amends": [
            "Do select `T2.Country` instead of `country` and `MAX(agriculture_gdp_percentage)`. Do use `INNER JOIN` on `continent AS T1` instead of no continent table. Do add `INNER JOIN` on `encompasses AS T2` with `T1.Name = T2.Continent` instead of missing this relationship. Do add `INNER JOIN` on `country AS T3` with `T2.Country = T3.Code` instead of directly referencing country. Do add `INNER JOIN` on `economy AS T4` with `T4.Country = T3.Code` instead of querying gdp_data directly. Do filter with `T1.Name = 'Asia'` instead of `continent = 'Asia'`. Do remove `GROUP BY country` instead of keeping aggregation. Do order by `T4.Agriculture DESC` instead of `agriculture_gdp_percentage DESC`. The amended query now correctly joins the necessary tables to find the Asian country with the highest agriculture percentage from the economy table.",
            "Do remove `T4.Agriculture` from the SELECT list instead of including it, and do remove the `T2.Country` alias qualification instead of keeping it. Do keep the same FROM sources with `INNER JOIN` on `T1.Name=T2.Continent`, `INNER JOIN` on `T2.Country=T3.Code`, and `INNER JOIN` on `T4.Country=T3.Code`. Do maintain the WHERE filter on `T1.Name='Asia'` and the ORDER BY on `T4.Agriculture DESC` with LIMIT 1. The amended query now correctly returns only the country with the highest agriculture value in Asia instead of including the agriculture value itself."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, MAX(agriculture_gdp_percentage) \nFROM gdp_data \nWHERE continent = 'Asia' \nGROUP BY country \nORDER BY agriculture_gdp_percentage DESC \nLIMIT 1;",
            "SELECT T2.Country, T4.Agriculture \nFROM continent AS T1 \nINNER JOIN encompasses AS T2 ON T1.Name = T2.Continent \nINNER JOIN country AS T3 ON T2.Country = T3.Code \nINNER JOIN economy AS T4 ON T4.Country = T3.Code \nWHERE T1.Name = 'Asia' \nORDER BY T4.Agriculture DESC \nLIMIT 1",
            "SELECT T2.Country\nFROM continent AS T1\nINNER JOIN encompasses AS T2 ON T1.Name = T2.Continent\nINNER JOIN country AS T3 ON T2.Country = T3.Code\nINNER JOIN economy AS T4 ON T4.Country = T3.Code\nWHERE T1.Name = 'Asia'\nORDER BY T4.Agriculture DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8501": {
        "db_id": "mondial_geo",
        "question": "What form of governance does the least prosperous nation in the world have?",
        "ground_truth": "SELECT T3.Government FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country INNER JOIN politics AS T3 ON T3.Country = T2.Country WHERE T2.GDP IS NOT NULL ORDER BY T2.GDP ASC LIMIT 1",
        "amends": [
            "Do select `T3.Government` instead of `government_form` from a different source. Do use explicit table aliases `T1`, `T2`, and `T3` instead of a single table reference. Do join three tables `country`, `economy`, and `politics` with `INNER JOIN` conditions instead of querying a single table. Do filter with `T2.GDP IS NOT NULL` instead of no explicit NULL handling. Do order by `T2.GDP ASC` instead of using a subquery for minimum value. Do add `LIMIT 1` instead of relying on equality comparison that might return multiple rows. The amended query now correctly retrieves the government form from the country with the lowest GDP by properly joining related tables and handling NULL values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT government_form FROM countries WHERE gdp_per_capita = (SELECT MIN(gdp_per_capita) FROM countries);",
            "SELECT T3.Government \nFROM country T1\nINNER JOIN economy T2 ON T1.Code = T2.Country\nINNER JOIN politics T3 ON T1.Code = T3.Country\nWHERE T2.GDP IS NOT NULL\nORDER BY T2.GDP ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5655": {
        "db_id": "shipping",
        "question": "What is the shipment ID of the heaviest shipment that Zachery Hicks transported?",
        "ground_truth": "SELECT T1.ship_id FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' ORDER BY T1.weight DESC LIMIT 1",
        "amends": [
            "Do join `shipment AS T1` with `driver AS T2` on `T1.driver_id = T2.driver_id` instead of querying only the `shipments` table. Do filter on `T2.first_name = 'Zachery'` and `T2.last_name = 'Hicks'` instead of filtering directly on `transporter = 'Zachery Hicks'`. Do select `T1.ship_id` instead of `shipment_id`. The amended query now correctly matches the RIGHT_SQL's behavior by properly joining tables and filtering on separate name fields."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shipment_id FROM shipments WHERE transporter = 'Zachery Hicks' ORDER BY weight DESC LIMIT 1;",
            "SELECT T1.ship_id \nFROM shipment AS T1 \nJOIN driver AS T2 ON T1.driver_id = T2.driver_id \nWHERE T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' \nORDER BY T1.weight DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5048": {
        "db_id": "olympics",
        "question": "Which region is the majority of the athletes from?",
        "ground_truth": "SELECT T2.region_name FROM person_region AS T1 INNER JOIN noc_region AS T2 ON T1.region_id = T2.id GROUP BY T2.region_name ORDER BY COUNT(T1.person_id) DESC LIMIT 1",
        "amends": [
            "Do select `T2.region_name` instead of `region` and remove the `athlete_count` alias. Do use `FROM person_region AS T1 INNER JOIN noc_region AS T2` instead of `FROM athletes` with proper join conditions. Do change the join predicate to `ON T1.region_id = T2.id` instead of the incorrect table structure. Do group by `T2.region_name` instead of the ambiguous `region`. Do order by `COUNT(T1.person_id)` instead of the aliased `athlete_count`. The amended query now correctly joins the person_region and noc_region tables to count athletes per region and returns the region with the highest count, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as athlete_count FROM athletes GROUP BY region ORDER BY athlete_count DESC LIMIT 1;",
            "SELECT T2.region_name\nFROM person_region AS T1\nINNER JOIN noc_region AS T2 ON T1.region_id = T2.id\nGROUP BY T2.region_name\nORDER BY COUNT(T1.person_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1835": {
        "db_id": "soccer_2016",
        "question": "When did Chennai Super Kings play its first match?",
        "ground_truth": "SELECT Match_Date FROM `Match` WHERE team_1 = ( SELECT Team_Id FROM Team WHERE Team_Name = 'Chennai Super Kings' ) OR Team_2 = ( SELECT Team_Id FROM Team WHERE Team_Name = 'Chennai Super Kings' ) ORDER BY Match_Date ASC LIMIT 1",
        "amends": [
            "Do reference `Match_Date` instead of `MIN(match_date)` and move the ordering to `ORDER BY Match_Date ASC LIMIT 1` instead of using an aggregate function. Do use subqueries `(SELECT Team_Id FROM Team WHERE Team_Name = 'Chennai Super Kings')` for both team conditions instead of hardcoded string literals 'Chennai Super Kings'. Do reference columns `team_1` and `Team_2` instead of `team1` and `team2` with proper case sensitivity. Do add explicit table references with backticks `Match` instead of lowercase `matches`. The amended query now correctly joins through the Team table to get team IDs and returns the earliest match date through proper ordering and limiting instead of aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(match_date) FROM matches WHERE team1 = 'Chennai Super Kings' OR team2 = 'Chennai Super Kings';",
            "SELECT Match_Date \nFROM `Match` \nWHERE Team_1 = (SELECT Team_Id FROM Team WHERE Team_Name = 'Chennai Super Kings') \n   OR Team_2 = (SELECT Team_Id FROM Team WHERE Team_Name = 'Chennai Super Kings') \nORDER BY Match_Date ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5459": {
        "db_id": "sales",
        "question": "What is the total cost of all the \"Road-650, Red, 60\" products that Abraham E. Bennet sold?",
        "ground_truth": "SELECT SUM(T2.Quantity * T3.Price) FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T1.FirstName = 'Abraham' AND T1.MiddleInitial = 'e' AND T1.LastName = 'Bennet' AND T3.Name = 'Road-650 Red, 60'",
        "amends": [
            "Do use `T3.Price` and `T2.Quantity` instead of `od.UnitPrice` and `od.Quantity` for the calculation. Do join `Employees AS T1` instead of `Employees e` and use `Sales AS T2` instead of `Orders o` and `OrderDetails od`. Do use `INNER JOIN` on `T1.EmployeeID = T2.SalesPersonID` instead of `JOIN` on `o.EmployeeID = e.EmployeeID`. Do use `INNER JOIN` on `T2.ProductID = T3.ProductID` instead of `JOIN` on `od.ProductID = p.ProductID`. Do add filter `T1.MiddleInitial = 'e'` instead of omitting it. Do use `T3.Name = 'Road-650 Red, 60'` instead of `p.ProductName = 'Road-650, Red, 60'` for the product filter. The amended query now correctly calculates sales using the Sales table instead of Orders and OrderDetails, includes the middle initial filter, and uses the proper product name format.",
            "Do use `SUM(T2.Quantity * T3.Price)` instead of `SUM(T3.Price * T2.Quantity)` to maintain consistent column order. Do use lowercase `'e'` for `MiddleInitial` instead of uppercase `'E'` to match the case-sensitive filter requirement. Do remove the `TotalCost` alias instead of keeping it to eliminate unnecessary column naming. The amended query now correctly calculates the total cost for the specified employee and product without extraneous output formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(od.UnitPrice * od.Quantity) as TotalCost\nFROM Orders o\nJOIN OrderDetails od ON o.OrderID = od.OrderID\nJOIN Products p ON od.ProductID = p.ProductID\nJOIN Employees e ON o.EmployeeID = e.EmployeeID\nWHERE p.ProductName = 'Road-650, Red, 60'\nAND e.FirstName = 'Abraham' AND e.LastName = 'Bennet'",
            "SELECT SUM(T3.Price * T2.Quantity) AS TotalCost\nFROM Employees AS T1\nINNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID\nINNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID\nWHERE T1.FirstName = 'Abraham' \nAND T1.MiddleInitial = 'E' \nAND T1.LastName = 'Bennet'\nAND T3.Name = 'Road-650 Red, 60';",
            "SELECT SUM(T2.Quantity * T3.Price) \nFROM Employees AS T1 \nINNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID \nINNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID \nWHERE T1.FirstName = 'Abraham' \nAND T1.MiddleInitial = 'e' \nAND T1.LastName = 'Bennet' \nAND T3.Name = 'Road-650 Red, 60'"
        ],
        "rule_sql": []
    },
    "1533": {
        "db_id": "synthea",
        "question": "How many patients who are allergic to peanuts have asthma?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.patient) FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN allergies AS T3 ON T2.patient = T3.PATIENT WHERE T1.DESCRIPTION = 'Asthma' AND T3.DESCRIPTION = 'Allergy to peanuts'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.patient)` instead of `COUNT(*)` to count unique patients rather than all rows. Do join `conditions AS T1` on `T1.PATIENT = T2.patient` instead of omitting this table entirely. Do join `allergies AS T3` on `T2.patient = T3.PATIENT` instead of omitting this table entirely. Do filter with `T1.DESCRIPTION = 'Asthma'` instead of `condition = 'asthma'` to use the correct table and column. Do filter with `T3.DESCRIPTION = 'Allergy to peanuts'` instead of `allergy = 'peanuts'` to use the correct table and column name with proper allergy description format. The amended query now correctly counts distinct patients with both asthma condition and peanut allergy by joining the appropriate tables and using proper column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE allergy = 'peanuts' AND condition = 'asthma';",
            "SELECT COUNT(DISTINCT T2.patient) \nFROM conditions AS T1 \nJOIN patients AS T2 ON T1.PATIENT = T2.patient \nJOIN allergies AS T3 ON T2.patient = T3.PATIENT \nWHERE T1.DESCRIPTION = 'Asthma' \nAND T3.DESCRIPTION = 'Allergy to peanuts'"
        ],
        "rule_sql": []
    },
    "7565": {
        "db_id": "image_and_language",
        "question": "What is the ratio between the number of object samples in image 1 and the number of object samples in image 6?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN IMG_ID = 1 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN IMG_ID = 6 THEN 1 ELSE 0 END) FROM IMG_OBJ",
        "amends": [
            "Do use a single table `IMG_OBJ` instead of multiple subqueries on `object_samples`. Do calculate counts using `SUM(CASE WHEN IMG_ID = 1 THEN 1 ELSE 0 END)` and `SUM(CASE WHEN IMG_ID = 6 THEN 1 ELSE 0 END)` instead of separate `COUNT(*)` subqueries. Do add explicit `CAST` to `REAL` for the numerator instead of relying on implicit casting. Do remove the `AS ratio` alias instead of keeping it. The amended query now correctly handles the division with proper type casting and avoids multiple table scans."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SELECT COUNT(*) FROM object_samples WHERE image_id = 1) / (SELECT COUNT(*) FROM object_samples WHERE image_id = 6) AS ratio;",
            "SELECT CAST(SUM(CASE WHEN IMG_ID = 1 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN IMG_ID = 6 THEN 1 ELSE 0 END) FROM IMG_OBJ;"
        ],
        "rule_sql": []
    },
    "4539": {
        "db_id": "student_loan",
        "question": "How many disabled students have payment due?",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE T1.bool = 'pos'",
        "amends": [
            "Do select `COUNT(T1.name)` from a specific column instead of `COUNT(*)` from all rows. Do use `INNER JOIN` between `no_payment_due AS T1` and `disabled AS T2` on `T1.name = T2.name` instead of querying a single `students` table. Do filter with `T1.bool = 'pos'` instead of `disabled = 'yes' AND payment_status = 'due'`. Do completely change the table structure by joining specialized tables `no_payment_due` and `disabled` instead of using a monolithic `students` table with status flags. The amended query now correctly matches RIGHT_SQL's behavior by using proper table relationships and specific boolean filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE disabled = 'yes' AND payment_status = 'due';",
            "SELECT COUNT(T1.name) \nFROM no_payment_due AS T1 \nINNER JOIN disabled AS T2 ON T1.name = T2.name \nWHERE T1.bool = 'pos'"
        ],
        "rule_sql": []
    },
    "3161": {
        "db_id": "donor",
        "question": "From the total amount of donation to projects, what is the percentage of the amount is for school projects located in the rural area?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.school_metro = 'rural' THEN T1.donation_to_project ELSE 0 END) AS REAL) * 100 / SUM(donation_to_project) FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid",
        "amends": [
            "Do use `T1.projectid = T2.projectid` for the join condition instead of `d.project_id = p.id`. Do reference `T1.donation_to_project` instead of `d.amount` and `T2.school_metro` instead of `p.location`. Do remove the explicit `WHERE` filter instead of keeping it since the conditional aggregation handles the filtering. Do add explicit `CAST` to `REAL` instead of relying on implicit casting. Do use `INNER JOIN` with table aliases `T1` and `T2` instead of simple `JOIN` with original table names. The amended query now correctly calculates the percentage of rural school donations without redundant filtering and ensures proper numeric casting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN p.location = 'rural' AND p.type = 'school' THEN d.amount ELSE 0 END) / SUM(d.amount)) * 100 AS percentage\nFROM \n    donations d\nJOIN \n    projects p ON d.project_id = p.id\nWHERE \n    p.location = 'rural' AND p.type = 'school';",
            "SELECT \n    (CAST(SUM(CASE WHEN T2.school_metro = 'rural' THEN T1.donation_to_project ELSE 0 END) AS REAL) / \n     CAST(SUM(T1.donation_to_project) AS REAL)) * 100 AS percentage_rural_donations\nFROM \n    donations T1\nINNER JOIN \n    projects T2 ON T1.projectid = T2.projectid"
        ],
        "rule_sql": []
    },
    "1037": {
        "db_id": "computer_student",
        "question": "Which courses were taught by a professor who is not a faculty member?",
        "ground_truth": "SELECT DISTINCT T2.course_id FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id WHERE T1.professor = 1 AND T1.hasPosition = 0",
        "amends": [
            "Do select `DISTINCT T2.course_id` instead of `c.course_name` without distinct. Do use `person AS T1` and `taughtBy AS T2` as source tables instead of `courses c` and `professors p`. Do perform `INNER JOIN` on `T1.p_id = T2.p_id` instead of `JOIN` on `c.professor_id = p.professor_id`. Do add filters `T1.professor = 1` and `T1.hasPosition = 0` instead of `p.faculty_status = 'member'`. The amended query now correctly identifies courses taught by professors without positions rather than faculty members."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.course_name \nFROM courses c\nJOIN professors p ON c.professor_id = p.professor_id\nWHERE p.faculty_status = 'member';",
            "SELECT DISTINCT T2.course_id\nFROM person AS T1\nINNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id\nWHERE T1.professor = 1 AND T1.hasPosition = '0'"
        ],
        "rule_sql": []
    },
    "6713": {
        "db_id": "retails",
        "question": "How many in debt customers in the household market segment are from Russia?",
        "ground_truth": "SELECT COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T1.c_acctbal < 0 AND T1.c_mktsegment = 'HOUSEHOLD' AND T2.n_name = 'RUSSIA'",
        "amends": [
            "Do use `COUNT(T1.c_custkey)` instead of `COUNT(*)` to count specific customer keys. Do reference the `customer` table as `T1` instead of `customers` and join with `nation` as `T2` on `T1.c_nationkey = T2.n_nationkey` instead of filtering directly on country. Do filter on `T1.c_acctbal < 0` instead of `debt > 0` to check for negative account balances. Do use `T1.c_mktsegment = 'HOUSEHOLD'` instead of `market_segment = 'household'` with proper case sensitivity and column naming. Do filter on `T2.n_name = 'RUSSIA'` instead of `country = 'Russia'` to use the nation table's name field with proper case. The amended query now correctly joins customer and nation tables to filter Russian household customers with negative account balances."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE market_segment = 'household' AND country = 'Russia' AND debt > 0;",
            "SELECT COUNT(T1.c_custkey) \nFROM customer T1\nJOIN nation T2 ON T1.c_nationkey = T2.n_nationkey\nWHERE T1.c_mktsegment = 'HOUSEHOLD'\nAND T1.c_acctbal < 0\nAND T2.n_name = 'RUSSIA'"
        ],
        "rule_sql": []
    },
    "27": {
        "db_id": "movie_platform",
        "question": "What is the average rating score of the movie \"When Will I Be Loved\" and who was its director?",
        "ground_truth": "SELECT AVG(T1.rating_score), T2.director_name FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'When Will I Be Loved'",
        "amends": [
            "Do join `ratings AS T1` with `movies AS T2` on `T1.movie_id = T2.movie_id` instead of querying only the `movies` table. Do reference `T2.director_name` instead of `director` and `T2.movie_title` instead of `title`. Do use `AVG(T1.rating_score)` from the joined ratings table instead of `AVG(rating_score)` from a single table. The amended query now correctly aggregates ratings by joining the appropriate tables and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating_score), director FROM movies WHERE title = 'When Will I Be Loved';",
            "SELECT AVG(T1.rating_score) AS average_rating, T2.director_name \nFROM ratings AS T1 \nJOIN movies AS T2 ON T1.movie_id = T2.movie_id \nWHERE T2.movie_title = 'When Will I Be Loved';"
        ],
        "rule_sql": []
    },
    "5556": {
        "db_id": "menu",
        "question": "Among the menus that include baked apples with cream, who is the sponsor of the menu with the highest price?",
        "ground_truth": "SELECT T4.sponsor FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id INNER JOIN Menu AS T4 ON T4.id = T1.menu_id WHERE T3.name = 'Baked apples with cream' AND T3.id = 107 ORDER BY T2.price DESC LIMIT 1",
        "amends": [
            "Do use `T4.sponsor` instead of `sponsor` to specify the table source. Do add joins to `MenuPage AS T1`, `MenuItem AS T2`, `Dish AS T3`, and `Menu AS T4` instead of querying only the `menus` table. Do join `T1.id = T2.menu_page_id` and `T2.dish_id = T3.id` and `T4.id = T1.menu_id` instead of missing these relationships. Do filter on `T3.name = 'Baked apples with cream'` and `T3.id = 107` instead of `dish_name = 'baked apples with cream'`. Do order by `T2.price DESC` instead of `price ASC`. The amended query now correctly retrieves the sponsor from the proper table hierarchy with accurate filtering and sorting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sponsor FROM menus WHERE dish_name = 'baked apples with cream' ORDER BY price ASC LIMIT 1;",
            "SELECT T4.sponsor\nFROM MenuPage AS T1\nJOIN MenuItem AS T2 ON T1.id = T2.menu_page_id\nJOIN Dish AS T3 ON T2.dish_id = T3.id\nJOIN Menu AS T4 ON T4.id = T1.menu_id\nWHERE T3.name = 'Baked apples with cream' AND T3.id = 107\nORDER BY T2.price DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5418": {
        "db_id": "sales",
        "question": "List the first names of customers who have purchased products from sale person id 1.",
        "ground_truth": "SELECT T1.FirstName FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.SalesPersonID = 1",
        "amends": [
            "Do add `INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do change the column reference from `first_name` to `T1.FirstName` instead of using the unqualified column name. Do modify the WHERE condition to use `T2.SalesPersonID = 1` instead of `sale_person_id = 1` to properly filter on the joined Sales table. Do add table aliasing with `Customers AS T1` instead of using the bare table name. The amended query now correctly joins the Customers and Sales tables to filter sales by a specific salesperson and returns the corresponding customer first names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE sale_person_id = 1;",
            "SELECT T1.FirstName\nFROM Customers AS T1\nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.SalesPersonID = 1"
        ],
        "rule_sql": []
    },
    "6690": {
        "db_id": "retails",
        "question": "Which country does supplier No.34 come from?",
        "ground_truth": "SELECT T2.n_name FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T1.s_suppkey = 34",
        "amends": [
            "Do select `T2.n_name` instead of `country` to retrieve the nation name from the joined table rather than a non-existent column. Do join `supplier AS T1` with `nation AS T2` using `INNER JOIN` on `T1.s_nationkey = T2.n_nationkey` instead of querying only the suppliers table without any join. Do filter on `T1.s_suppkey = 34` instead of `supplier_id = 34` to use the correct primary key column name for the supplier table. The amended query now correctly joins the supplier and nation tables to retrieve the nation name for the specified supplier, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM suppliers WHERE supplier_id = 34;",
            "SELECT T2.n_name \nFROM supplier AS T1 \nINNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey \nWHERE T1.s_suppkey = 34"
        ],
        "rule_sql": []
    },
    "8406": {
        "db_id": "mondial_geo",
        "question": "In countries where there is more than one ethnic group, name the ethnic group with the greatest presence in each country and the country to which it corresponds.",
        "ground_truth": "SELECT Country, Name FROM ethnicGroup AS T1 WHERE Percentage < 100 AND Percentage = ( SELECT MAX(Percentage) FROM ethnicGroup AS T2 WHERE T1.Country = T2.Country )",
        "amends": [
            "Do select `Country` and `Name` columns instead of `country`, `ethnic_group`, and `MAX(population)`. Do use a single table `ethnicGroup` with alias `T1` instead of `ethnic_groups` without aliases. Do move the aggregation logic to a correlated subquery with `MAX(Percentage)` instead of using `MAX(population)` in the main query. Do add a WHERE clause with `Percentage < 100` and a correlated subquery condition instead of the HAVING `COUNT(*) > 1` filter. Do remove the GROUP BY clause entirely instead of grouping by `country`. Do implement a correlated subquery with `T1.Country = T2.Country` instead of the simple aggregation approach. The amended query now correctly finds records with the maximum percentage below 100 for each country, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, ethnic_group, MAX(population) \nFROM ethnic_groups \nGROUP BY country \nHAVING COUNT(*) > 1;",
            "SELECT Country, Name FROM ethnicGroup AS T1 WHERE Percentage = (SELECT MAX(Percentage) FROM ethnicGroup AS T2 WHERE T2.Country = T1.Country) AND Percentage < 100"
        ],
        "rule_sql": []
    },
    "1760": {
        "db_id": "restaurant",
        "question": "List the review and label of the restaurants in Mission Blvd., Hayward.",
        "ground_truth": "SELECT T2.review, T2.label FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.city = 'hayward' AND T1.street_name = 'mission blvd'",
        "amends": [
            "Do select `T2.review` and `T2.label` from specific table aliases instead of selecting `review` and `label` without table qualification. Do join `location AS T1` with `generalinfo AS T2` on `T1.id_restaurant = T2.id_restaurant` instead of querying a single `restaurants` table. Do filter on `T2.city = 'hayward'` with lowercase comparison instead of `city = 'Hayward'` with title case. Do filter on `T1.street_name = 'mission blvd'` with lowercase comparison instead of `address = 'Mission Blvd.'` with different column name and case. The amended query now correctly joins location and general information tables using proper foreign key relationships and case-insensitive filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT review, label FROM restaurants WHERE address = 'Mission Blvd.' AND city = 'Hayward'",
            "SELECT T2.review, T2.label \nFROM location AS T1 \nJOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant \nWHERE T2.city = 'hayward' AND T1.street_name = 'mission blvd'"
        ],
        "rule_sql": []
    },
    "977": {
        "db_id": "computer_student",
        "question": "List the ID and years in program for students taught by advisor with ID 5.",
        "ground_truth": "SELECT T1.p_id, T2.yearsInProgram FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T1.p_id_dummy = 5",
        "amends": [
            "Do select `T1.p_id` and `T2.yearsInProgram` instead of `student_id` and `years_in_program`. Do use `INNER JOIN` between `advisedBy AS T1` and `person AS T2` on `T1.p_id = T2.p_id` instead of querying only the `students` table. Do filter on `T1.p_id_dummy = 5` instead of `advisor_id = 5`. The amended query now correctly joins the advisedBy and person tables to retrieve the proper student information based on the advisor relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, years_in_program FROM students WHERE advisor_id = 5;",
            "SELECT T1.p_id, T2.yearsInProgram \nFROM advisedBy AS T1 \nINNER JOIN person AS T2 ON T1.p_id = T2.p_id \nWHERE T1.p_id_dummy = 5 AND T2.student = 1"
        ],
        "rule_sql": []
    },
    "6013": {
        "db_id": "books",
        "question": "What are the city addresses of the customers located in the United States of America?",
        "ground_truth": "SELECT DISTINCT T2.city FROM country AS T1 INNER JOIN address AS T2 ON T1.country_id = T2.country_id WHERE T1.country_name = 'United States of America'",
        "amends": [
            "Do use `DISTINCT T2.city` instead of `city` to eliminate duplicates. Do join `country AS T1 INNER JOIN address AS T2` instead of querying only `customers` table. Do use join condition `T1.country_id = T2.country_id` instead of no join. Do filter on `T1.country_name = 'United States of America'` instead of `country = 'USA'` to match the standardized country name. The amended query now correctly retrieves distinct cities from addresses associated with the United States through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM customers WHERE country = 'USA';",
            "SELECT DISTINCT T2.city\nFROM country AS T1\nINNER JOIN address AS T2 ON T1.country_id = T2.country_id\nWHERE T1.country_name = 'United States of America'"
        ],
        "rule_sql": []
    },
    "1005": {
        "db_id": "computer_student",
        "question": "List the person IDs and course levels of the affiliated professors in faculty.",
        "ground_truth": "SELECT T1.p_id, T3.courseLevel FROM person AS T1 INNER JOIN taughtBy AS T2 ON T1.p_id = T2.p_id INNER JOIN course AS T3 ON T3.course_id = T2.course_id WHERE T1.hasPosition = 'Faculty_aff'",
        "amends": [
            "Do add joins to `taughtBy` and `course` tables instead of querying only `professors` table. Do use `INNER JOIN` on `T1.p_id = T2.p_id` and `T3.course_id = T2.course_id` instead of no joins. Do select `T1.p_id` and `T3.courseLevel` instead of `person_id` and `course_level`. Do filter on `T1.hasPosition = 'Faculty_aff'` instead of `affiliation = 'faculty'`. The amended query now correctly joins related tables to retrieve course level information for faculty members, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT person_id, course_level FROM professors WHERE affiliation = 'faculty';",
            "SELECT T1.p_id, T3.courseLevel \nFROM person T1\nINNER JOIN taughtBy T2 ON T1.p_id = T2.p_id\nINNER JOIN course T3 ON T3.course_id = T2.course_id\nWHERE T1.hasPosition = 'Faculty_aff'"
        ],
        "rule_sql": []
    },
    "3608": {
        "db_id": "authors",
        "question": "How many authors drafted the paper \"Subcellular localization of nuclease in barley aleurone\"?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.Name) FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Subcellular localization of nuclease in barley aleurone'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.Name)` instead of `COUNT(*)` to count unique author names rather than all rows. Do join `Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` instead of querying only the `authors` table to properly relate papers to their authors. Do filter on `T1.Title` instead of `paper_title` to use the correct column name from the Paper table. Do reference the proper table structure with explicit joins instead of assuming a single table contains both paper titles and author information. The amended query now correctly counts distinct authors for the specified paper title."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM authors WHERE paper_title = 'Subcellular localization of nuclease in barley aleurone';",
            "SELECT COUNT(DISTINCT T2.Name) \nFROM Paper AS T1 \nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId \nWHERE T1.Title = 'Subcellular localization of nuclease in barley aleurone'"
        ],
        "rule_sql": []
    },
    "3422": {
        "db_id": "video_games",
        "question": "How many times did other regions make positive sales in DS platform?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.id) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN region_sales AS T3 ON T1.id = T3.game_platform_id INNER JOIN region AS T4 ON T3.region_id = T4.id WHERE T1.platform_name = 'DS' AND T4.region_name = 'Other' AND T3.num_sales > 0",
        "amends": [
            "Do use `COUNT(DISTINCT T2.id)` instead of `COUNT(*)` to count distinct game IDs rather than all rows. Do join multiple tables including `platform AS T1`, `game_platform AS T2`, `region_sales AS T3`, and `region AS T4` instead of querying only a single `sales` table. Do use `INNER JOIN` with proper join conditions `T1.id = T2.platform_id`, `T1.id = T3.game_platform_id`, and `T3.region_id = T4.id` instead of no joins. Do filter on `T1.platform_name = 'DS'` instead of `platform = 'DS'` using the proper table reference. Do filter on `T4.region_name = 'Other'` instead of `region != 'North America'` to specifically target the 'Other' region category. Do filter on `T3.num_sales > 0` instead of `sales_amount > 0` using the correct column name from the proper table. The amended query now correctly counts distinct games for the DS platform in the Other region with positive sales, matching the intended behavior.",
            "Do join `region_sales AS T3` on `T1.id = T3.game_platform_id` instead of `T2.id = T3.game_platform_id` to correctly link platform to region sales through the platform ID rather than the game_platform ID, ensuring proper counting of distinct game platforms for the DS platform in the Other region with positive sales. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE platform = 'DS' AND region != 'North America' AND sales_amount > 0;",
            "SELECT COUNT(DISTINCT T2.id) \nFROM platform AS T1\nINNER JOIN game_platform AS T2 ON T1.id = T2.platform_id\nINNER JOIN region_sales AS T3 ON T2.id = T3.game_platform_id\nINNER JOIN region AS T4 ON T3.region_id = T4.id\nWHERE T1.platform_name = 'DS' \nAND T4.region_name = 'Other' \nAND T3.num_sales > 0",
            "SELECT COUNT(DISTINCT T2.id) \nFROM platform AS T1\nINNER JOIN game_platform AS T2 ON T1.id = T2.platform_id\nINNER JOIN region_sales AS T3 ON T1.id = T3.game_platform_id\nINNER JOIN region AS T4 ON T3.region_id = T4.id\nWHERE T1.platform_name = 'DS'\nAND T4.region_name = 'Other'\nAND T3.num_sales > 0"
        ],
        "rule_sql": []
    },
    "7961": {
        "db_id": "music_platform_2",
        "question": "Which titles have the content \"love\" but the category is art produced between 2018 and 2019.",
        "ground_truth": "SELECT DISTINCT T2.title FROM categories AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE (T2.created_at LIKE '2018-%' AND T1.category = 'arts' AND T2.content LIKE '%love%') OR (T2.created_at LIKE '2019-%' AND T1.category = 'arts' AND T2.content LIKE '%love%')",
        "amends": [
            "Do use `DISTINCT T2.title` instead of `title` without distinct. Do join `categories AS T1` and `reviews AS T2` with `INNER JOIN` on `T2.podcast_id = T1.podcast_id` instead of querying a single `articles` table. Do change the category filter to `T1.category = 'arts'` instead of `category = 'art'`. Do replace the `year BETWEEN 2018 AND 2019` filter with separate conditions for `T2.created_at LIKE '2018-%'` and `T2.created_at LIKE '2019-%'` combined with OR logic. Do keep the content filter as `T2.content LIKE '%love%'` but apply it to both year conditions. The amended query now correctly joins the categories and reviews tables, handles the year filtering through date pattern matching, and ensures proper category matching while maintaining the content search functionality."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM articles WHERE content LIKE '%love%' AND category = 'art' AND year BETWEEN 2018 AND 2019;",
            "SELECT DISTINCT T2.title\nFROM categories AS T1\nINNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id\nWHERE T1.category = 'arts'\nAND T2.content LIKE '%love%'\nAND (T2.created_at LIKE '2018-%' OR T2.created_at LIKE '2019-%')"
        ],
        "rule_sql": []
    },
    "7464": {
        "db_id": "works_cycles",
        "question": "List all the scraped work orders for handling damage reason.",
        "ground_truth": "SELECT T2.WorkOrderID FROM ScrapReason AS T1 INNER JOIN WorkOrder AS T2 ON T1.ScrapReasonID = T2.ScrapReasonID WHERE T1.Name = 'Handling damage'",
        "amends": [
            "Do select only `T2.WorkOrderID` instead of all columns with `*`. Do join `ScrapReason AS T1` and `WorkOrder AS T2` with an `INNER JOIN` on `T1.ScrapReasonID = T2.ScrapReasonID` instead of querying only `work_orders` without any join. Do filter on `T1.Name = 'Handling damage'` instead of `damage_reason = 'handling'` to properly reference the scrap reason table and use the correct column name and value format. The amended query now correctly joins the related tables and filters based on the scrap reason name to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM work_orders WHERE damage_reason = 'handling'",
            "SELECT T2.WorkOrderID\nFROM ScrapReason AS T1\nINNER JOIN WorkOrder AS T2 ON T1.ScrapReasonID = T2.ScrapReasonID\nWHERE T1.Name = 'Handling damage'"
        ],
        "rule_sql": []
    },
    "6247": {
        "db_id": "food_inspection_2",
        "question": "Among the establishments that failed the inspection in February 2010, list the names of the employees with a salary greater than 70% of the average salary of all employees.",
        "ground_truth": "SELECT DISTINCT T1.employee_id FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.results = 'Fail' AND strftime('%Y-%m', T2.inspection_date) = '2010-02' AND T1.salary > 0.7 * ( SELECT AVG(salary) FROM employee )",
        "amends": [
            "Do select `DISTINCT T1.employee_id` instead of `e.name` and use table alias `T1` for employee instead of `e`. Do join `inspection AS T2` instead of `inspections i` and use `INNER JOIN` with `T1.employee_id = T2.employee_id` instead of `JOIN` with `e.establishment_id = i.establishment_id`. Do filter on `T2.results = 'Fail'` instead of `i.result = 'Failed'` and maintain the same date filter `strftime('%Y-%m', T2.inspection_date) = '2010-02'`. Do keep the salary subquery condition `T1.salary > 0.7 * (SELECT AVG(salary) FROM employee)` but reference the correct table name `employee` instead of `employees`. The amended query now correctly identifies failed inspections by employee rather than establishment and returns distinct employee IDs matching the RIGHT_SQL behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.name \nFROM employees e\nJOIN inspections i ON e.establishment_id = i.establishment_id\nWHERE i.result = 'Failed' \nAND strftime('%Y-%m', i.inspection_date) = '2010-02'\nAND e.salary > 0.7 * (SELECT AVG(salary) FROM employees);",
            "SELECT DISTINCT T1.employee_id\nFROM employee AS T1\nINNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nWHERE T2.results = 'Fail'\nAND strftime('%Y-%m', T2.inspection_date) = '2010-02'\nAND T1.salary > 0.7 * (SELECT AVG(salary) FROM employee)"
        ],
        "rule_sql": []
    },
    "9301": {
        "db_id": "movie_3",
        "question": "What is the percentage of documentary films?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.name = 'Documentary', 1, 0)) AS REAL) * 100 / COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id",
        "amends": [
            "Do use `SUM(IIF(T2.name = 'Documentary', 1, 0))` instead of `COUNT(*)` with a `WHERE` filter to count only documentary films while preserving the total count denominator. Do join `film_category AS T1` with `category AS T2` on `T1.category_id = T2.category_id` instead of querying the `films` table directly to properly access genre information through the category relationship. Do cast the sum to `REAL` instead of using integer division to ensure accurate percentage calculation. Do reference `COUNT(T1.film_id)` instead of `(SELECT COUNT(*) FROM films)` for the denominator to maintain consistent dataset scope through the joined tables. The amended query now correctly calculates the percentage of documentary films by properly joining category tables and using real number arithmetic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM films) AS percentage FROM films WHERE genre = 'Documentary';",
            "SELECT \n    (SUM(IIF(T2.name = 'Documentary', 1, 0)) * 100.0 / COUNT(T1.film_id)) AS percentage_documentary\nFROM \n    film_category AS T1\nJOIN \n    category AS T2 ON T1.category_id = T2.category_id;"
        ],
        "rule_sql": []
    },
    "4810": {
        "db_id": "legislator",
        "question": "How many legislators hold the title \"Majority Leader\"?",
        "ground_truth": "SELECT COUNT(bioguide) FROM `current-terms` WHERE title = 'Majority Leader'",
        "amends": [
            "Do count `bioguide` instead of `*` to count specific non-null identifiers rather than all rows. Do query from `current-terms` instead of `legislators` to access the correct table containing current congressional terms. Do filter for `Majority Leader` instead of `Minority Leader` to target the correct leadership position. The amended query now correctly counts current majority leaders from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE title = 'Minority Leader';",
            "SELECT COUNT(bioguide) FROM \"current-terms\" WHERE title = 'Majority Leader';"
        ],
        "rule_sql": []
    },
    "2182": {
        "db_id": "world_development_indicators",
        "question": "Which country have completed vital registration? List all the countries.",
        "ground_truth": "SELECT ShortName FROM Country WHERE VitalRegistrationComplete = 'Yes'",
        "amends": [
            "Do select `ShortName` instead of `*` to return only the specific column needed. Do reference table `Country` instead of `countries` to use the correct table name. Do filter on `VitalRegistrationComplete = 'Yes'` instead of `vital_registration = 'completed'` to use the correct column name and value format. The amended query now correctly returns only the ShortName column from the Country table where VitalRegistrationComplete equals 'Yes', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM countries WHERE vital_registration = 'completed';",
            "SELECT ShortName FROM Country WHERE VitalRegistrationComplete = 'Yes';"
        ],
        "rule_sql": []
    },
    "1970": {
        "db_id": "soccer_2016",
        "question": "How many matches in 2009 had win margins of less than 10?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM `Match` WHERE Match_Date LIKE '2009%' AND Win_Margin < 10",
        "amends": [
            "Do count `Match_Id` instead of `COUNT(*)` to count specific non-null values. Do reference table `Match` instead of `matches` to use the correct table name. Do filter with `Match_Date LIKE '2009%'` instead of `year = 2009` to properly handle date-based filtering. Do use condition `Win_Margin < 10` instead of `win_margin >= 10` to correctly identify matches with smaller win margins. The amended query now correctly counts matches from 2009 with win margins less than 10."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2009 AND win_margin >= 10;",
            "SELECT COUNT(Match_Id) FROM Match WHERE Match_Date LIKE '2009%' AND Win_Margin < 10"
        ],
        "rule_sql": []
    },
    "8517": {
        "db_id": "software_company",
        "question": "Please list the occupations of the customers over 40 and have sent a true response to the incentive mailing sent by the marketing department.",
        "ground_truth": "SELECT DISTINCT T1.OCCUPATION FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE T1.age > 40 AND T2.RESPONSE = 'true'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the source from `customers` alone to `INNER JOIN` between `Customers AS T1` and `Mailings1_2 AS T2` on `T1.ID = T2.REFID` instead of querying only one table. Do change the column reference from `occupation` to `T1.OCCUPATION` instead of using the unqualified column name. Do change the age filter from `age > 40` to `T1.age > 40` instead of the unqualified reference. Do change the response condition from `incentive_mailing_response = 'true'` to `T2.RESPONSE = 'true'` instead of referencing a non-existent column in the original table. The amended query now correctly joins the two tables and filters based on the joined table's response column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT occupation FROM customers WHERE age > 40 AND incentive_mailing_response = 'true';",
            "SELECT DISTINCT T1.OCCUPATION\nFROM Customers AS T1\nINNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID\nWHERE T1.age > 40 AND T2.RESPONSE = 'true'"
        ],
        "rule_sql": []
    },
    "9017": {
        "db_id": "bike_share_1",
        "question": "On 11/3/2013, which stations are often empty? Indicate the names of the stations.",
        "ground_truth": "SELECT DISTINCT T1.name FROM station AS T1 INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE T2.bikes_available = 0 AND T2.time LIKE '2013/11/03%'",
        "amends": [
            "Do select `T1.name` instead of `station_name` and add `DISTINCT` instead of omitting it. Do join `station AS T1` and `status AS T2` with `INNER JOIN` on `T2.station_id = T1.id` instead of querying only `stations` table. Do filter on `T2.bikes_available = 0` instead of `bikes_available = 0` and use `T2.time LIKE '2013/11/03%'` instead of `date = '11/3/2013'` to properly handle date matching with the correct format. The amended query now correctly joins the station and status tables to find stations with zero available bikes on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name FROM stations WHERE date = '11/3/2013' AND bikes_available = 0;",
            "SELECT DISTINCT T1.name FROM station AS T1 INNER JOIN status AS T2 ON T2.station_id = T1.id WHERE T2.bikes_available = 0 AND T2.time LIKE '2013/11/03%'"
        ],
        "rule_sql": []
    },
    "866": {
        "db_id": "cs_semester",
        "question": "Which student is more satisfied with the course Machine Learning Theory, Willie Rechert or Laughton Antonio?",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE (T1.f_name = 'Laughton' OR T1.f_name = 'Willie') AND (T1.l_name = 'Antonio' OR T1.l_name = 'Rechert') AND T3.name = 'Machine Learning Theory' ORDER BY T2.sat DESC LIMIT 1",
        "amends": [
            "Do select `T1.f_name` and `T1.l_name` as separate columns instead of a concatenated `student_name`. Do join `student` table as `T1` with `registration` as `T2` on `T1.student_id = T2.student_id` instead of querying only the `students` table. Do add an additional join to `course` as `T3` on `T2.course_id = T3.course_id` instead of filtering directly on course name. Do filter with separate conditions for first names `'Laughton'` or `'Willie'` and last names `'Antonio'` or `'Rechert'` instead of using `IN` with full names. Do order by `T2.sat` instead of `satisfaction_score`. The amended query now correctly joins across multiple tables to find students registered for the specific course and matches RIGHT_SQL's behavior.",
            "Do remove `T2.sat` from the SELECT list instead of including it. Do change the JOIN to `INNER JOIN` instead of plain JOIN for both table joins. Do rewrite the WHERE clause to use `(T1.f_name = 'Laughton' OR T1.f_name = 'Willie') AND (T1.l_name = 'Antonio' OR T1.l_name = 'Rechert')` instead of the complex nested OR conditions. Do add `LIMIT 1` to the ORDER BY clause instead of omitting it. The amended query now correctly returns only the top student by satisfaction score while maintaining the same filtering logic for names and course."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_name, satisfaction_score \nFROM students \nWHERE course_name = 'Machine Learning Theory' \nAND student_name IN ('Willie Rechert', 'Laughton Antonio') \nORDER BY satisfaction_score DESC \nLIMIT 1;",
            "SELECT T1.f_name, T1.l_name, T2.sat\nFROM student AS T1\nJOIN registration AS T2 ON T1.student_id = T2.student_id\nJOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T3.name = 'Machine Learning Theory'\nAND ((T1.f_name = 'Willie' AND T1.l_name = 'Rechert') OR (T1.f_name = 'Laughton' AND T1.l_name = 'Antonio'))\nORDER BY T2.sat DESC;",
            "SELECT T1.f_name, T1.l_name\nFROM student AS T1\nINNER JOIN registration AS T2 ON T1.student_id = T2.student_id\nINNER JOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T3.name = 'Machine Learning Theory'\nAND (T1.f_name = 'Laughton' OR T1.f_name = 'Willie')\nAND (T1.l_name = 'Antonio' OR T1.l_name = 'Rechert')\nORDER BY T2.sat DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1408": {
        "db_id": "synthea",
        "question": "Count all of the living patients that had a stroke.",
        "ground_truth": "SELECT COUNT(DISTINCT T2.patient) FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.description = 'Stroke' AND T2.deathdate IS NULL",
        "amends": [
            "Do use `COUNT(DISTINCT T2.patient)` instead of `COUNT(*)` to count unique patients rather than all records. Do join `conditions AS T1` with `patients AS T2` on `T1.PATIENT = T2.patient` instead of querying only the patients table. Do filter on `T1.description = 'Stroke'` instead of `diagnosis = 'stroke'` to use the conditions table's description field. Do filter on `T2.deathdate IS NULL` instead of `status = 'alive'` to properly identify living patients by checking for null death dates. The amended query now correctly counts distinct living patients with stroke conditions as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE status = 'alive' AND diagnosis = 'stroke';",
            "SELECT COUNT(DISTINCT T2.patient) \nFROM conditions AS T1 \nJOIN patients AS T2 ON T1.PATIENT = T2.patient \nWHERE T1.description = 'Stroke' \nAND T2.deathdate IS NULL"
        ],
        "rule_sql": []
    },
    "2373": {
        "db_id": "superstore",
        "question": "What is the total sales of 'Avery Hi-Liter EverBold Pen Style Fluorescent Highlighters, 4/Pack' in the Central region?",
        "ground_truth": "SELECT SUM(T1.Sales) FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Product Name` = 'Avery Hi-Liter EverBold Pen Style Fluorescent Highlighters, 4/Pack' AND T2.Region = 'Central'",
        "amends": [
            "Do use `SUM(T1.Sales)` instead of `SUM(quantity) as total_sales` to reference the correct column and remove the unnecessary alias. Do join `central_superstore AS T1` with `product AS T2` on `T1.Product ID = T2.Product ID` instead of querying a single `sales` table. Do filter on `T2.Product Name` instead of `product_name` and use `T2.Region` instead of `region` to reference the correct table's columns. Do remove the explicit `AS` keyword in table aliases for consistency. The amended query now correctly joins the appropriate tables and references the proper columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity) as total_sales \nFROM sales \nWHERE product_name = 'Avery Hi-Liter EverBold Pen Style Fluorescent Highlighters, 4/Pack' \nAND region = 'Central';",
            "SELECT SUM(T1.Sales) \nFROM central_superstore T1 \nJOIN product T2 ON T1.\"Product ID\" = T2.\"Product ID\" \nWHERE T2.\"Product Name\" = 'Avery Hi-Liter EverBold Pen Style Fluorescent Highlighters, 4/Pack' \nAND T2.Region = 'Central'"
        ],
        "rule_sql": []
    },
    "6831": {
        "db_id": "retails",
        "question": "What is the region with the most customers?",
        "ground_truth": "SELECT T.r_name FROM ( SELECT T3.r_name, COUNT(T2.c_custkey) AS num FROM nation AS T1 INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey GROUP BY T3.r_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T3.r_name` instead of ambiguous `region`. Do join through `nation` and `customer` tables with `INNER JOIN` conditions `T1.n_nationkey = T2.c_nationkey` and `T1.n_regionkey = T3.r_regionkey` instead of directly querying a single table. Do count specific customer keys `COUNT(T2.c_custkey)` instead of generic `COUNT(*)`. Do wrap the aggregated query in a subquery `T` and order by the count alias `T.num` instead of ordering by the aggregate function directly. The amended query now correctly identifies the region with the most customers by properly joining through the nation-region relationship and counting actual customer records.",
            "Do move the `ORDER BY num DESC LIMIT 1` clause from the inner subquery to the outer query instead of keeping it inside the subquery. Do reference the alias with `T.num` instead of just `num` in the outer query's ORDER BY clause. Do add the `AS` keyword for table aliases in the subquery definition instead of omitting it. The amended query now correctly performs the ordering and limiting on the aggregated results rather than attempting to order and limit within the grouped subquery, ensuring the final result shows the region with the highest customer count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) FROM customers GROUP BY region ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T3.r_name\nFROM (\n    SELECT T3.r_name, COUNT(T2.c_custkey) AS num\n    FROM nation T1\n    INNER JOIN customer T2 ON T1.n_nationkey = T2.c_nationkey\n    INNER JOIN region T3 ON T1.n_regionkey = T3.r_regionkey\n    GROUP BY T3.r_name\n    ORDER BY num DESC\n    LIMIT 1\n) T",
            "SELECT T.r_name\nFROM (\n    SELECT T3.r_name, COUNT(T2.c_custkey) AS num\n    FROM nation AS T1\n    INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey\n    INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey\n    GROUP BY T3.r_name\n) AS T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4347": {
        "db_id": "simpson_episodes",
        "question": "Among the episodes which have star score less than 8, how many episodes were aired in 2009?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE strftime('%Y', T1.air_date) = '2009' AND T2.stars < 8;",
        "amends": [
            "Do `COUNT(DISTINCT T2.episode_id)` instead of `COUNT(*)` to count unique episodes rather than all rows. Do join `Vote AS T2` on `T2.episode_id = T1.episode_id` instead of querying only the episodes table. Do filter on `T2.stars < 8` instead of `star_score < 8` to use the correct column from the Vote table. Do use `strftime('%Y', T1.air_date) = '2009'` instead of `air_date = 2009` to extract the year from the date field properly. The amended query now correctly counts distinct episodes from 2009 with votes below 8 stars, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE star_score < 8 AND air_date = 2009;",
            "SELECT COUNT(DISTINCT T2.episode_id) \nFROM Episode AS T1\nJOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE T2.stars < 8 \nAND strftime('%Y', T1.air_date) = '2009'"
        ],
        "rule_sql": []
    },
    "6864": {
        "db_id": "retails",
        "question": "How many parts have a jumbo case container?",
        "ground_truth": "SELECT COUNT(p_partkey) FROM part WHERE p_container = 'JUMBO CASE'",
        "amends": [
            "Do count `p_partkey` instead of `*` to exclude null values. Do reference table `part` instead of `parts` to use the correct table name. Do filter on `p_container` column instead of `container_type` to use the proper column name. Do use uppercase comparison `'JUMBO CASE'` instead of lowercase `'jumbo case'` to match the case-sensitive data format. The amended query now correctly counts non-null part keys from the part table where the container value matches the specified uppercase string."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM parts WHERE container_type = 'jumbo case';",
            "SELECT COUNT(p_partkey) FROM part WHERE p_container = 'JUMBO CASE';"
        ],
        "rule_sql": []
    },
    "780": {
        "db_id": "social_media",
        "question": "What is the text of the tweet that got the most `likes`?",
        "ground_truth": "SELECT text FROM twitter WHERE Likes = ( SELECT MAX( Likes) FROM twitter )",
        "amends": [
            "Do query from `twitter` table instead of `tweets` table. Do use a subquery with `MAX(Likes)` to find the maximum likes instead of `ORDER BY likes DESC LIMIT 1`. Do filter with `WHERE Likes = (SELECT MAX(Likes) FROM twitter)` instead of ordering and limiting. Do reference the column as `Likes` (uppercase) instead of `likes` (lowercase). The amended query now correctly identifies the tweet with maximum likes using a subquery approach instead of relying on ordering and limiting which could miss ties."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets ORDER BY likes DESC LIMIT 1;",
            "SELECT text FROM twitter WHERE Likes = (SELECT MAX(Likes) FROM twitter)"
        ],
        "rule_sql": []
    },
    "2609": {
        "db_id": "regional_sales",
        "question": "How many states located in the Midwest region?",
        "ground_truth": "SELECT COUNT(DISTINCT T) FROM ( SELECT CASE  WHEN Region = 'Midwest' THEN StateCode ELSE NULL END AS T FROM Regions ) WHERE T IS NOT NULL",
        "amends": [
            "Do use `COUNT(DISTINCT T)` instead of `COUNT(*)` to count distinct non-null values. Do add a subquery with `CASE WHEN Region = 'Midwest' THEN StateCode ELSE NULL END AS T` instead of directly filtering on region. Do filter with `WHERE T IS NOT NULL` instead of `WHERE region = 'Midwest'` to exclude null values from the case expression. Do reference the `Regions` table instead of the `states` table as the data source. The amended query now correctly counts distinct state codes from the Midwest region while handling null values appropriately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM states WHERE region = 'Midwest';",
            "SELECT COUNT(DISTINCT T) FROM (SELECT CASE WHEN Region = 'Midwest' THEN StateCode ELSE NULL END AS T FROM Regions) WHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "593": {
        "db_id": "codebase_comments",
        "question": "Among the solutions that contain files within the repository followed by over 1000 people, how many of them can be\nimplemented without needs of compilation?",
        "ground_truth": "SELECT COUNT(T2.RepoId) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Forks > 1000 AND T2.WasCompiled = 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `s` and `r`. Do reference column `T2.RepoId` in the COUNT function instead of `COUNT(*)`. Do use table names `Repo` and `Solution` instead of `repositories` and `solutions`. Do use `INNER JOIN` with condition `T1.Id = T2.RepoId` instead of `JOIN` with `s.repository_id = r.id`. Do filter on `T1.Forks > 1000` instead of `r.followers > 1000`. Do filter on `T2.WasCompiled = 1` instead of `s.compilation_required = 'no'`. Do remove the `s.files LIKE '%%.%'` filter instead of keeping it. The amended query now correctly counts solutions from repositories with over 1000 forks where compilation was required, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM solutions s\nJOIN repositories r ON s.repository_id = r.id\nWHERE r.followers > 1000\nAND s.compilation_required = 'no'\nAND s.files LIKE '%%.%';",
            "SELECT COUNT(T2.RepoId) \nFROM Repo T1\nINNER JOIN Solution T2 ON T1.Id = T2.RepoId\nWHERE T1.Forks > 1000 \nAND T2.WasCompiled = 1"
        ],
        "rule_sql": []
    },
    "4123": {
        "db_id": "public_review_platform",
        "question": "In users yelping since 2009 to 2011, how many of them have low count of fans?",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year >= 2009 AND user_yelping_since_year < 2012 AND user_fans = 'Low'",
        "amends": [
            "Do count `user_id` instead of `*` to avoid counting nulls. Do reference table `Users` instead of `users` for correct case sensitivity. Do use column `user_yelping_since_year` instead of `yelping_since` for proper year filtering. Do apply conditions `>= 2009 AND < 2012` instead of `BETWEEN 2009 AND 2011` to include all of 2011 while excluding 2012. Do filter on `user_fans = 'Low'` instead of `fans < 5` to use the categorical value instead of numeric comparison. The amended query now correctly counts users with low fans who started yelping between 2009 and 2011 inclusive."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE yelping_since BETWEEN 2009 AND 2011 AND fans < 5;",
            "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year >= 2009 AND user_yelping_since_year < 2012 AND user_fans = 'Low';"
        ],
        "rule_sql": []
    },
    "1137": {
        "db_id": "talkingdata",
        "question": "What is the ID of the device used by the youngest user?",
        "ground_truth": "SELECT device_id FROM gender_age WHERE age = ( SELECT MIN(age) FROM gender_age )",
        "amends": [
            "Do select `device_id` from `gender_age` table instead of from `users` table. Do use a subquery to find `MIN(age)` instead of directly ordering by `age ASC` with `LIMIT 1`. Do filter rows where `age` equals the minimum age instead of relying on ordering and limiting. The amended query now correctly identifies the device_id associated with the minimum age from the appropriate table using proper subquery logic instead of simple ordering with limit."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_id FROM users ORDER BY age ASC LIMIT 1;",
            "SELECT device_id FROM gender_age WHERE age = (SELECT MIN(age) FROM gender_age);"
        ],
        "rule_sql": []
    },
    "4058": {
        "db_id": "public_review_platform",
        "question": "Please indicate the opening day of businesses whose category is pets.",
        "ground_truth": "SELECT DISTINCT T4.day_of_week FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T1.business_id = T3.business_id INNER JOIN Days AS T4 ON T3.day_id = T4.day_id WHERE T2.category_name = 'Pets'",
        "amends": [
            "Do use `DISTINCT T4.day_of_week` instead of `name, opening_day` to return unique days rather than business details. Do join four tables (`Business_Categories`, `Categories`, `Business_Hours`, `Days`) instead of querying only `businesses` to properly connect category and schedule data. Do use `INNER JOIN` with proper foreign key relationships (`T1.category_id = T2.category_id`, `T1.business_id = T3.business_id`, `T3.day_id = T4.day_id`) instead of no joins to correctly link the relational data. Do filter on `T2.category_name = 'Pets'` instead of `category = 'pets'` to use the proper category table and case-sensitive value. Do remove the `opening_day` column reference instead of including it since the right query extracts day information from the normalized Days table. The amended query now correctly returns distinct days of the week when pet businesses are open, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, opening_day FROM businesses WHERE category = 'pets';",
            "SELECT DISTINCT T4.day_of_week\nFROM Business_Categories T1\nINNER JOIN Categories T2 ON T1.category_id = T2.category_id\nINNER JOIN Business_Hours T3 ON T1.business_id = T3.business_id\nINNER JOIN Days T4 ON T3.day_id = T4.day_id\nWHERE T2.category_name = 'Pets';"
        ],
        "rule_sql": []
    },
    "759": {
        "db_id": "movie",
        "question": "List down the movie ID of movie with a budget of 15000000 and a rating between 7 to 8.",
        "ground_truth": "SELECT MovieID FROM movie WHERE Rating BETWEEN 7 AND 8 AND Budget = 15000000",
        "amends": [
            "Do reference the `MovieID` column instead of `movie_id` and use the `movie` table instead of `movies`. Do use `BETWEEN` for the rating range condition `Rating BETWEEN 7 AND 8` instead of separate `rating >= 7 AND rating <= 8` conditions. Do maintain the `Budget = 15000000` filter but change the column name from `budget` to `Budget`. The amended query now correctly filters for movies with a budget of 15,000,000 and ratings between 7 and 8 inclusive, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_id FROM movies WHERE budget = 15000000 AND rating >= 7 AND rating <= 8;",
            "SELECT MovieID FROM movie WHERE Budget = 15000000 AND Rating BETWEEN 7 AND 8"
        ],
        "rule_sql": []
    },
    "4501": {
        "db_id": "student_loan",
        "question": "How many students enlist in the air force organization?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'air_force'",
        "amends": [
            "Do select `COUNT(name)` from the `enlist` table instead of `COUNT(*)` from the `students` table. Do filter on `organ = 'air_force'` instead of `organization = 'Navy'`. The amended query now correctly counts names from the enlist table for air force organization instead of counting all records from students table for navy organization."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE organization = 'Navy';",
            "SELECT COUNT(name) FROM enlist WHERE organ = 'air_force'"
        ],
        "rule_sql": []
    },
    "6076": {
        "db_id": "books",
        "question": "How many books were written by author A.J. Ayer?",
        "ground_truth": "SELECT COUNT(*) FROM book_author AS T1 INNER JOIN author AS T2 ON T1.author_id = T2.author_id WHERE T2.author_name = 'A.J. Ayer'",
        "amends": [
            "Do join `book_author AS T1 INNER JOIN author AS T2 ON T1.author_id = T2.author_id` instead of querying `books` table directly. Do filter on `T2.author_name = 'A.J. Ayer'` instead of `author = 'A.J. Ayer'` to properly reference the normalized author table. The amended query now correctly counts books by joining through the relationship table and filtering on the author's name in the dedicated author table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE author = 'A.J. Ayer';",
            "SELECT COUNT(*) AS book_count\nFROM book_author AS T1\nINNER JOIN author AS T2 ON T1.author_id = T2.author_id\nWHERE T2.author_name = 'A.J. Ayer'"
        ],
        "rule_sql": []
    },
    "2067": {
        "db_id": "music_tracker",
        "question": "Find the average number of downloads for Single-Tables released by '2Pac' between 2001 and 2013.",
        "ground_truth": "SELECT AVG(totalSnatched) FROM torrents WHERE artist LIKE '2Pac' AND releaseType LIKE 'Single' AND groupYear BETWEEN 2001 AND 2013",
        "amends": [
            "Do reference the `totalSnatched` column instead of `downloads` for the average calculation. Do use the `torrents` table instead of `apps` as the data source. Do filter with `artist LIKE '2Pac'` instead of `artist = '2Pac'` to allow pattern matching. Do filter with `releaseType LIKE 'Single'` instead of `category = 'Single-Tables'` to match the correct release type classification. Do maintain the `groupYear BETWEEN 2001 AND 2013` temporal filter instead of `release_year BETWEEN 2001 AND 2013` with the correct column name. The amended query now correctly calculates average downloads from the torrents table for 2Pac singles released between 2001-2013."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(downloads) FROM apps WHERE artist = '2Pac' AND release_year BETWEEN 2001 AND 2013 AND category = 'Single-Tables';",
            "SELECT AVG(totalSnatched) AS average_downloads\nFROM torrents\nWHERE artist LIKE '2Pac'\nAND releaseType LIKE 'Single'\nAND groupYear BETWEEN 2001 AND 2013;"
        ],
        "rule_sql": []
    },
    "8039": {
        "db_id": "university",
        "question": "What is the name of the ranking system for Teaching criteria?",
        "ground_truth": "SELECT T1.system_name FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T2.criteria_name = 'Teaching'",
        "amends": [
            "Do select `T1.system_name` from the `ranking_system` table instead of `name` from `ranking_systems`. Do join with `ranking_criteria AS T2` using `INNER JOIN` on `T1.id = T2.ranking_system_id` instead of querying a single table. Do filter on `T2.criteria_name = 'Teaching'` instead of `criteria = 'Teaching'` to properly reference the joined table's column. The amended query now correctly retrieves system names based on criteria from the related criteria table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM ranking_systems WHERE criteria = 'Teaching';",
            "SELECT T1.system_name \nFROM ranking_system AS T1\nINNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id\nWHERE T2.criteria_name = 'Teaching'"
        ],
        "rule_sql": []
    },
    "1251": {
        "db_id": "law_episode",
        "question": "What is the title of the episode that got the most 10-star votes?",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T2.stars = 10 ORDER BY T2.votes DESC LIMIT 1",
        "amends": [
            "Do add `INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id` instead of querying only the episodes table. Do add `WHERE T2.stars = 10` filter instead of omitting the stars condition. Do change the sort column to `T2.votes DESC` instead of using an undefined `votes` column. Do specify the table alias `T1.title` instead of just `title`. The amended query now correctly joins the Vote table, filters for 10-star ratings, and sorts by vote count to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY votes DESC LIMIT 1;",
            "SELECT T1.title\nFROM Episode AS T1\nINNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id\nWHERE T2.stars = 10\nORDER BY T2.votes DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3290": {
        "db_id": "donor",
        "question": "What is the average total donations received by Fresno County colleges?",
        "ground_truth": "SELECT SUM(T2.donation_optional_support + T2.donation_to_project) / COUNT(donationid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.school_county = 'Fresno'",
        "amends": [
            "Do calculate the average donation amount using `SUM(T2.donation_optional_support + T2.donation_optional_support) / COUNT(donationid)` instead of `AVG(total_donations)` which uses a different aggregation approach. Do join `projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid` instead of querying only the `colleges` table without proper joins. Do filter on `T1.school_county = 'Fresno'` instead of `county = 'Fresno'` to use the correct column from the joined table. The amended query now correctly calculates the average donation per project by summing individual donation components and dividing by the count of donations, using proper table relationships and filtering logic.",
            "Do use `donation_to_project` instead of `donation_optional_support` in the SUM expression to correctly calculate total donations rather than doubling the optional support amount. Do remove the alias `average_total_donations` instead of keeping it to match the simplified output format. The amended query now correctly sums both donation components and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(total_donations) FROM colleges WHERE county = 'Fresno';",
            "SELECT SUM(T2.donation_optional_support + T2.donation_optional_support) / COUNT(donationid) AS average_total_donations\nFROM projects AS T1 \nINNER JOIN donations AS T2 ON T1.projectid = T2.projectid\nWHERE T1.school_county = 'Fresno'",
            "SELECT SUM(T2.donation_to_project + T2.donation_optional_support) / COUNT(donationid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.school_county = 'Fresno'"
        ],
        "rule_sql": []
    },
    "1149": {
        "db_id": "talkingdata",
        "question": "Among the app users who were not active when event no.2 happened, how many of them belong to the category Property Industry 1.0?",
        "ground_truth": "SELECT COUNT(T2.app_id) FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id INNER JOIN app_events AS T3 ON T2.app_id = T3.app_id WHERE T3.is_active = 0 AND T1.category = 'Property Industry 1.0' AND T3.event_id = 2",
        "amends": [
            "Do use `COUNT(T2.app_id)` instead of `COUNT(*)` to count specific non-null values. Do change the FROM clause to use `label_categories AS T1` instead of `users u` as the primary table. Do add `INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id` instead of joining directly to events. Do change the second join to `INNER JOIN app_events AS T3 ON T2.app_id = T3.app_id` instead of `JOIN events e ON u.user_id = e.user_id`. Do modify the WHERE clause to use `T3.is_active = 0` instead of `u.active_status = 'inactive'` for active status filtering. Do keep `T1.category = 'Property Industry 1.0'` but change the table reference from `u.category` to `T1.category`. Do change the event filter to `T3.event_id = 2` instead of `e.event_id = 2` with the correct table reference. The amended query now correctly counts active app events within the specified category and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM users u\nJOIN events e ON u.user_id = e.user_id\nWHERE e.event_id = 2\nAND u.category = 'Property Industry 1.0'\nAND u.active_status = 'inactive';",
            "SELECT COUNT(T2.app_id)\nFROM label_categories AS T1\nINNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id\nINNER JOIN app_events AS T3 ON T2.app_id = T3.app_id\nWHERE T3.is_active = 0\nAND T1.category = 'Property Industry 1.0'\nAND T3.event_id = 2"
        ],
        "rule_sql": []
    },
    "5043": {
        "db_id": "olympics",
        "question": "State the event name of Basketball.",
        "ground_truth": "SELECT T2.event_name FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Basketball'",
        "amends": [
            "Do use `T2.event_name` from the `event` table instead of `event_name` from a non-existent `events` table. Do join `sport AS T1` and `event AS T2` with `INNER JOIN` on `T1.id = T2.sport_id` instead of querying a single table. Do filter on `T1.sport_name = 'Basketball'` instead of `sport = 'Basketball'` to properly reference the sport name column. The amended query now correctly joins the sport and event tables to retrieve basketball events, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_name FROM events WHERE sport = 'Basketball';",
            "SELECT T2.event_name FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id WHERE T1.sport_name = 'Basketball'"
        ],
        "rule_sql": []
    },
    "818": {
        "db_id": "social_media",
        "question": "How many tweets have been posted on Wednesday?",
        "ground_truth": "SELECT COUNT(TweetID) FROM twitter WHERE Weekday = 'Wednesday'",
        "amends": [
            "Do reference the `twitter` table instead of `tweets` and use the `TweetID` column for counting instead of `COUNT(*)`. Do filter on the pre-computed `Weekday` column instead of using `strftime('%w', created_at)` to extract weekday from a timestamp. Do remove the date formatting function call and instead rely on the stored weekday value. The amended query now correctly counts tweets from the proper table using explicit column reference and optimized weekday filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE strftime('%w', created_at) = 'Wednesday';",
            "SELECT COUNT(TweetID) FROM twitter WHERE Weekday = 'Wednesday';"
        ],
        "rule_sql": []
    },
    "8117": {
        "db_id": "university",
        "question": "Give the criteria name where Harvard University scored 100.",
        "ground_truth": "SELECT DISTINCT T3.criteria_name FROM university AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN ranking_criteria AS T3 ON T3.id = T2.ranking_criteria_id WHERE T1.university_name = 'Harvard University' AND T2.score = 100",
        "amends": [
            "Do use `DISTINCT T3.criteria_name` instead of `criteria_name` to eliminate duplicates. Do join `university AS T1` instead of querying `universities` table directly. Do add `INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id` instead of omitting this join. Do add `INNER JOIN ranking_criteria AS T3 ON T3.id = T2.ranking_criteria_id` instead of omitting this join. Do filter on `T1.university_name = 'Harvard University'` instead of `university_name = 'Harvard University'` with proper table qualification. Do filter on `T2.score = 100` instead of `score = 100` with proper table qualification. The amended query now correctly joins the necessary tables to retrieve criteria names associated with Harvard University's perfect scores."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT criteria_name FROM universities WHERE university_name = 'Harvard University' AND score = 100",
            "SELECT DISTINCT T3.criteria_name\nFROM university AS T1\nINNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id\nINNER JOIN ranking_criteria AS T3 ON T3.id = T2.ranking_criteria_id\nWHERE T1.university_name = 'Harvard University'\nAND T2.score = 100"
        ],
        "rule_sql": []
    },
    "7398": {
        "db_id": "works_cycles",
        "question": "How many discount are of the type \"Excess Inventory\"?",
        "ground_truth": "SELECT COUNT(SpecialOfferID) FROM SpecialOffer WHERE Type = 'Excess Inventory'",
        "amends": [
            "Do reference the correct table name `SpecialOffer` instead of `discounts` and use the correct column name `SpecialOfferID` for counting instead of `COUNT(*)`. Do use the correct filter column `Type` with value 'Excess Inventory' instead of `discount_type` with the same value. The amended query now correctly counts SpecialOfferID entries from the SpecialOffer table where Type equals 'Excess Inventory', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM discounts WHERE discount_type = 'Excess Inventory';",
            "SELECT COUNT(SpecialOfferID) FROM SpecialOffer WHERE Type = 'Excess Inventory';"
        ],
        "rule_sql": []
    },
    "2932": {
        "db_id": "professional_basketball",
        "question": "What's the name of the player in 1996 who had the most steals that didn't play in the playoffs?",
        "ground_truth": "SELECT T1.playerID FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 1996 AND T2.PostGP = 0 ORDER BY T2.steals DESC LIMIT 1",
        "amends": [
            "Do select `T1.playerID` instead of `p.name, s.steals`. Do join `players_teams AS T2` instead of `stats s`. Do use `INNER JOIN` with `T1.playerID = T2.playerID` instead of `JOIN` with `p.player_id = s.player_id`. Do filter with `T2.year = 1996` instead of `s.year = 1996`. Do add `T2.PostGP = 0` instead of omitting it. Do remove the `NOT IN` subquery against `playoffs` instead of keeping it. Do order by `T2.steals DESC` instead of `s.steals DESC`. The amended query now correctly identifies players from 1996 who had no playoff games and returns the player with the most steals, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, s.steals \nFROM players p\nJOIN stats s ON p.player_id = s.player_id\nWHERE s.year = 1996\nAND p.player_id NOT IN (SELECT player_id FROM playoffs WHERE year = 1996)\nORDER BY s.steals DESC\nLIMIT 1;",
            "SELECT T1.playerID\nFROM players_teams AS T1\nINNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID\nWHERE T2.year = 1996\nAND T2.PostGP = 0\nORDER BY T2.steals DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2235": {
        "db_id": "world_development_indicators",
        "question": "Please list the Alpha2Codes of all the countries that have an indicator on Rural population in 1960.",
        "ground_truth": "SELECT T1.Alpha2Code FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.IndicatorName = 'Rural population' AND T2.Year = 1960",
        "amends": [
            "Do add table `Country AS T1` and `Indicators AS T2` with an `INNER JOIN` on `T1.CountryCode = T2.CountryCode` instead of querying only the `countries` table. Do change the WHERE clause to filter on `T2.IndicatorName = 'Rural population'` and `T2.Year = 1960` instead of checking `RuralPopulation1960 IS NOT NULL`. Do reference the column as `T1.Alpha2Code` instead of just `Alpha2Code`. The amended query now correctly joins the Country and Indicators tables to filter for the specific indicator and year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Alpha2Code FROM countries WHERE RuralPopulation1960 IS NOT NULL;",
            "SELECT T1.Alpha2Code\nFROM Country AS T1\nINNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode\nWHERE T2.IndicatorName = 'Rural population' AND T2.Year = 1960;"
        ],
        "rule_sql": []
    },
    "3989": {
        "db_id": "public_review_platform",
        "question": "List all the users with average star less than 3 stars in 2012",
        "ground_truth": "SELECT user_id FROM Users WHERE user_yelping_since_year = 2012 AND user_average_stars < 3",
        "amends": [
            "Do select only `user_id` instead of selecting `user_id` and `AVG(stars)`. Do query from `Users` table instead of `reviews` table. Do use `WHERE` filter with `user_yelping_since_year = 2012` instead of filtering on `year = 2012`. Do add condition `user_average_stars < 3` instead of having `avg_stars > 3`. Do remove `GROUP BY` and `HAVING` clauses instead of keeping them. The amended query now correctly filters users who joined in 2012 with average stars below 3, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, AVG(stars) as avg_stars \nFROM reviews \nWHERE year = 2012 \nGROUP BY user_id \nHAVING avg_stars > 3;",
            "SELECT user_id FROM Users WHERE user_yelping_since_year = 2012 AND user_average_stars < '3'"
        ],
        "rule_sql": []
    },
    "5440": {
        "db_id": "sales",
        "question": "In sales ID between 30 and 40, who is the customer that bought a total quantity of 403?",
        "ground_truth": "SELECT T2.FirstName, T2.LastName FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Quantity = 403 AND T1.SalesID BETWEEN 30 AND 40",
        "amends": [
            "Do select `T2.FirstName` and `T2.LastName` instead of `customer_name`. Do join `Customers AS T2` with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `sales` table. Do filter on `T1.Quantity = 403` and `T1.SalesID BETWEEN 30 AND 40` instead of `quantity = 403` and `sale_id BETWEEN 30 AND 40`. The amended query now correctly joins customer data and filters on the appropriate table aliases and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM sales WHERE sale_id BETWEEN 30 AND 40 AND quantity = 403;",
            "SELECT T2.FirstName, T2.LastName\nFROM Sales AS T1\nINNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.SalesID BETWEEN 30 AND 40\nAND T1.Quantity = 403;"
        ],
        "rule_sql": []
    },
    "4902": {
        "db_id": "legislator",
        "question": "What is the average number of terms served for a current legislator that's famous or impact?",
        "ground_truth": "SELECT CAST(COUNT(T2.bioguide) AS REAL) / COUNT(DISTINCT T1.bioguide_id) FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.wikipedia_id IS NOT NULL",
        "amends": [
            "Do use `CAST(COUNT(T2.bioguide) AS REAL) / COUNT(DISTINCT T1.bioguide_id)` instead of `AVG(terms_served)` for the calculation. Do change the FROM clause to `current AS T1 INNER JOIN current-terms AS T2 ON T1.bioguide_id = T2.bioguide` instead of querying only the `legislators` table. Do replace the WHERE condition with `T1.wikipedia_id IS NOT NULL` instead of `current_status = 'active' AND (famous = 1 OR impact_score > 8)`. Do remove the aggregate function AVG and instead use a ratio calculation between two counts. The amended query now correctly calculates the ratio of terms to distinct legislators rather than averaging terms served, using the appropriate table structure and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(terms_served) FROM legislators WHERE current_status = 'active' AND (famous = 1 OR impact_score > 8);",
            "SELECT CAST(COUNT(T2.bioguide) AS REAL) / COUNT(DISTINCT T1.bioguide_id) AS average_terms\nFROM current AS T1\nINNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nWHERE T1.wikipedia_id IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "8852": {
        "db_id": "food_inspection",
        "question": "In businesses with an owner address 500 California St, 2nd Floor of Silicon Valley, list the type of inspection of the business with the highest score.",
        "ground_truth": "SELECT T1.type FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.owner_address = '500 California St, 2nd Floor' AND T2.owner_city = 'SAN FRANCISCO' ORDER BY T1.score DESC LIMIT 1",
        "amends": [
            "Do select `T1.type` from the `inspections` table instead of `inspection_type` from `businesses`. Do join `inspections AS T1` with `businesses AS T2` using `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying only the `businesses` table. Do add filter `T2.owner_city = 'SAN FRANCISCO'` instead of omitting it, and do change the location filter from `location = 'Silicon Valley'` to the correct city condition. Do order by `T1.score DESC` instead of `score ASC` to get the highest score rather than the lowest. The amended query now correctly retrieves inspection types by joining the appropriate tables and filtering on the correct business location attributes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_type FROM businesses WHERE owner_address = '500 California St, 2nd Floor' AND location = 'Silicon Valley' ORDER BY score ASC LIMIT 1;",
            "SELECT T1.type \nFROM inspections AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T2.owner_address = '500 California St, 2nd Floor' \nAND T2.owner_city = 'SAN FRANCISCO'\nORDER BY T1.score DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4806": {
        "db_id": "legislator",
        "question": "How many legislators have not been registered in Federal Election Commission data?",
        "ground_truth": "SELECT COUNT(*) FROM current WHERE fec_id IS NULL OR fec_id = ''",
        "amends": [
            "Do filter on `fec_id IS NULL OR fec_id = ''` instead of only `fec_id IS NULL` to include empty string values. Do query from `current` table instead of `legislators` table to use the correct data source. The amended query now correctly counts records with null or empty fec_id values from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE fec_id IS NULL;",
            "SELECT COUNT(*) FROM current WHERE fec_id IS NULL OR fec_id = '';"
        ],
        "rule_sql": []
    },
    "5640": {
        "db_id": "shipping",
        "question": "What is the percentage of wholesaler customers who have shipment weight of not greater than 70000 pounds?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.weight < 70000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE T1.cust_type = 'wholesaler'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.weight < 70000 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN c.customer_type = 'wholesaler' AND s.weight <= 70000 THEN 1 END)` for conditional counting. Do apply explicit `CAST(... AS REAL)` instead of implicit decimal conversion with `100.0`. Do move the customer type filter to `WHERE T1.cust_type = 'wholesaler'` instead of embedding it in CASE statements. Do use strict inequality `weight < 70000` instead of `weight <= 70000`. Do reference tables as `customer AS T1` and `shipment AS T2` instead of `customers c` and `shipments s`. Do join on `T1.cust_id = T2.cust_id` instead of `c.customer_id = s.customer_id`. Do use `INNER JOIN` explicitly instead of implicit `JOIN`. The amended query now correctly calculates the percentage of wholesaler shipments under 70000 weight units."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.customer_type = 'wholesaler' AND s.weight <= 70000 THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN c.customer_type = 'wholesaler' THEN 1 END)) AS percentage\nFROM customers c\nJOIN shipments s ON c.customer_id = s.customer_id;",
            "SELECT \n    (SUM(CASE WHEN T2.weight < 70000 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    customer AS T1\nINNER JOIN \n    shipment AS T2 ON T1.cust_id = T2.cust_id\nWHERE \n    T1.cust_type = 'wholesaler';"
        ],
        "rule_sql": []
    },
    "5869": {
        "db_id": "airline",
        "question": "Which airport did Republic Airline fly the most from?",
        "ground_truth": "SELECT T2.DEST FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Republic Airline: YX' GROUP BY T2.DEST ORDER BY COUNT(T2.DEST) DESC LIMIT 1",
        "amends": [
            "Do select `T2.DEST` instead of `origin_airport` and remove the `flight_count` alias instead of keeping it. Do use `FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2` instead of `FROM flights` and change the join condition to `ON T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of no join. Do add the filter `WHERE T1.Description = 'Republic Airline: YX'` instead of `WHERE airline = 'Republic Airline'`. Do group by `T2.DEST` instead of `origin_airport` and change the order by to `ORDER BY COUNT(T2.DEST) DESC` instead of `ORDER BY flight_count DESC`. The amended query now correctly joins the carrier and airline tables to find the destination with the most flights for the specified airline carrier.",
            "Do remove `COUNT(T2.DEST)` from the SELECT list instead of including it, as only the destination column is needed for the final result. The amended query now correctly returns just the destination with the highest count for Republic Airline: YX flights, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin_airport, COUNT(*) as flight_count \nFROM flights \nWHERE airline = 'Republic Airline' \nGROUP BY origin_airport \nORDER BY flight_count DESC \nLIMIT 1;",
            "SELECT T2.DEST, COUNT(T2.DEST) FROM \"Air Carriers\" AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Republic Airline: YX' GROUP BY T2.DEST ORDER BY COUNT(T2.DEST) DESC LIMIT 1",
            "SELECT T2.DEST\nFROM \"Air Carriers\" AS T1\nINNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nWHERE T1.Description = 'Republic Airline: YX'\nGROUP BY T2.DEST\nORDER BY COUNT(T2.DEST) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4068": {
        "db_id": "public_review_platform",
        "question": "Please provide the name of businesses with user id \"16328\".",
        "ground_truth": "SELECT T1.category_name FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Tips AS T3 ON T2.business_id = T3.business_id WHERE T3.user_id = 16328",
        "amends": [
            "Do select `T1.category_name` instead of `business_name`. Do add `INNER JOIN` on `Categories AS T1` instead of omitting it. Do add `INNER JOIN` on `Business_Categories AS T2` with predicate `T1.category_id = T2.category_id` instead of omitting both table and join condition. Do add `INNER JOIN` on `Tips AS T3` with predicate `T2.business_id = T3.business_id` instead of omitting both table and join condition. Do change filter to `T3.user_id = 16328` instead of `user_id = 16328` to reference the correct table. The amended query now correctly retrieves category names from joined tables instead of business names directly, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_name FROM businesses WHERE user_id = 16328",
            "SELECT T1.category_name\nFROM Categories AS T1\nINNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id\nINNER JOIN Tips AS T3 ON T2.business_id = T3.business_id\nWHERE T3.user_id = 16328"
        ],
        "rule_sql": []
    },
    "6180": {
        "db_id": "food_inspection_2",
        "question": "Compare the number of inspections under toxic items and no-smoking regulations.",
        "ground_truth": "SELECT COUNT(CASE WHEN T2.category = 'Toxic Items' THEN T1.inspection_id END) AS Tox_nums , COUNT(CASE WHEN T2.category = 'No Smoking Regulations' THEN T1.inspection_id END) AS NosmoNums FROM violation AS T1 INNER JOIN inspection_point AS T2 ON T1.point_id = T2.point_id",
        "amends": [
            "Do reference tables `violation` as T1 and `inspection_point` as T2 instead of table `inspections`. Do use `INNER JOIN` on `T1.point_id = T2.point_id` instead of no join condition. Do count `T1.inspection_id` based on `T2.category` values 'Toxic Items' and 'No Smoking Regulations' instead of using LIKE patterns '%toxic%' and '%smoking%' on `violation_description`. Do alias the counts as `Tox_nums` and `NosmoNums` instead of `toxic_inspections` and `smoking_inspections`. The amended query now correctly joins related tables and uses proper category-based filtering instead of text pattern matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN violation_description LIKE '%toxic%' THEN 1 END) AS toxic_inspections,\n    COUNT(CASE WHEN violation_description LIKE '%smoking%' THEN 1 END) AS smoking_inspections\nFROM inspections;",
            "SELECT \n    COUNT(CASE WHEN T2.category = 'Toxic Items' THEN T1.inspection_id END) AS Tox_nums,\n    COUNT(CASE WHEN T2.category = 'No Smoking Regulations' THEN T1.inspection_id END) AS NosmoNums\nFROM \n    violation AS T1\nINNER JOIN \n    inspection_point AS T2 ON T1.point_id = T2.point_id\nWHERE \n    T2.category IN ('Toxic Items', 'No Smoking Regulations')"
        ],
        "rule_sql": []
    },
    "8349": {
        "db_id": "mondial_geo",
        "question": "Which countries are dependent on the British Crown?",
        "ground_truth": "SELECT Country FROM politics WHERE Government = 'British crown dependency'",
        "amends": [
            "Do select `Country` from the `politics` table instead of `name` from the `countries` table. Do filter on `Government = 'British crown dependency'` instead of `dependent_on = 'British Crown'` to use the correct column name and value format. The amended query now correctly retrieves countries with British crown dependency status from the appropriate table and column structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE dependent_on = 'British Crown';",
            "SELECT Country FROM politics WHERE Government = 'British crown dependency'"
        ],
        "rule_sql": []
    },
    "1883": {
        "db_id": "soccer_2016",
        "question": "List down the name of venues in season 2.",
        "ground_truth": "SELECT T2.Venue_Name FROM Match AS T1 INNER JOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id WHERE T1.Season_Id = 2 GROUP BY T2.Venue_Name",
        "amends": [
            "Do join `Match AS T1` with `Venue AS T2` on `T2.Venue_Id = T1.Venue_Id` instead of querying `venues` table directly. Do filter on `T1.Season_Id = 2` instead of `season = 2`. Do add `GROUP BY T2.Venue_Name` instead of omitting aggregation. Do select `T2.Venue_Name` with table alias instead of `venue_name` without qualification. The amended query now correctly retrieves venue names from matches played in season 2 by joining through the Match table and grouping to eliminate duplicates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue_name FROM venues WHERE season = 2;",
            "SELECT T2.Venue_Name\nFROM Match AS T1\nJOIN Venue AS T2 ON T2.Venue_Id = T1.Venue_Id\nWHERE T1.Season_Id = 2\nGROUP BY T2.Venue_Name"
        ],
        "rule_sql": []
    },
    "9341": {
        "db_id": "movie_3",
        "question": "Which film titles have the most expensive rental rate?",
        "ground_truth": "SELECT title FROM film WHERE rental_rate = ( SELECT MAX(rental_rate) FROM film )",
        "amends": [
            "Do use a `WHERE` filter with a subquery to find `MAX(rental_rate)` instead of ordering and limiting to get the first result. Do remove the explicit `rental_rate` column from the `SELECT` list instead of including it. Do eliminate the `ORDER BY rental_rate ASC` and `LIMIT 1` clauses instead of using them to find the minimum rate. The amended query now correctly identifies films with the maximum rental rate rather than the minimum, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, rental_rate FROM film ORDER BY rental_rate ASC LIMIT 1;",
            "SELECT title FROM film WHERE rental_rate = (SELECT MAX(rental_rate) FROM film)"
        ],
        "rule_sql": []
    },
    "4387": {
        "db_id": "student_loan",
        "question": "Which school is student829 enrolled in?",
        "ground_truth": "SELECT school FROM enrolled WHERE name = 'student829'",
        "amends": [
            "Do select `school` from the `enrolled` table instead of `school_name` from the `students` table. Do filter on `name = 'student829'` instead of `student_id = 'student829'` to correctly identify the student by name rather than ID. The amended query now correctly retrieves school information from the appropriate table using the proper identifier field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name FROM students WHERE student_id = 'student829';",
            "SELECT school FROM enrolled WHERE name = 'student829';"
        ],
        "rule_sql": []
    },
    "7843": {
        "db_id": "world",
        "question": "What is the surface area of the country where Sutton Coldfield city belongs?",
        "ground_truth": "SELECT T1.SurfaceArea FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T2.Name = 'Sutton Coldfield'",
        "amends": [
            "Do select `T1.SurfaceArea` instead of `SUM(country.surface_area)` to return the individual surface area value rather than an aggregate sum. Do use `INNER JOIN` with `T1.Code = T2.CountryCode` instead of `JOIN` with `city.country_code = country.code` to properly reference the table aliases and column names. Do reference `T2.Name` in the WHERE clause instead of `city.name` to maintain consistent table alias usage throughout the query. The amended query now correctly retrieves the surface area of the country containing Sutton Coldfield instead of attempting to sum surface areas."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(country.surface_area) \nFROM city \nJOIN country ON city.country_code = country.code \nWHERE city.name = 'Sutton Coldfield'",
            "SELECT T1.SurfaceArea \nFROM Country AS T1 \nINNER JOIN City AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Name = 'Sutton Coldfield'"
        ],
        "rule_sql": []
    },
    "4142": {
        "db_id": "citeseer",
        "question": "For all words cited in paper ID 315017, state the other paper ID and class label which also cited those words.",
        "ground_truth": "SELECT T1.class_label, T2.word_cited_id FROM paper AS T1 INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE T1.paper_id = 315017",
        "amends": [
            "Do select `T1.class_label` and `T2.word_cited_id` instead of `p2.paper_id` and `p2.class_label`. Do use `paper AS T1` and `content AS T2` as FROM sources instead of multiple `words` and `papers` tables. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.paper_id = T2.paper_id` instead of complex joins between `words` tables and multiple `papers` tables. Do apply the filter `T1.paper_id = 315017` in WHERE instead of filtering both `p1.paper_id` and excluding `p2.paper_id`. Do remove the `DISTINCT` modifier instead of keeping it. The amended query now correctly retrieves class labels and word citations from the appropriate tables with proper join relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT p2.paper_id, p2.class_label \nFROM words w1\nJOIN words w2 ON w1.word = w2.word\nJOIN papers p1 ON w1.paper_id = p1.paper_id\nJOIN papers p2 ON w2.paper_id = p2.paper_id\nWHERE p1.paper_id = 315017\nAND p2.paper_id != 315017;",
            "SELECT T1.class_label, T2.word_cited_id\nFROM paper AS T1\nINNER JOIN content AS T2 ON T1.paper_id = T2.paper_id\nWHERE T1.paper_id = '315017'"
        ],
        "rule_sql": []
    },
    "2022": {
        "db_id": "soccer_2016",
        "question": "What is the outcome type of match ID 392195?",
        "ground_truth": "SELECT T2.Outcome_Type FROM Match AS T1 INNER JOIN Outcome AS T2 ON T1.Outcome_type = T2.Outcome_Id WHERE T1.Match_Id = '392195'",
        "amends": [
            "Do select `T2.Outcome_Type` instead of `outcome` and add the `AS T2` alias instead of omitting it. Do join `Match AS T1` and `Outcome AS T2` with `INNER JOIN` on `T1.Outcome_type = T2.Outcome_Id` instead of querying only the `matches` table without any joins. Do filter with `T1.Match_Id = '392195'` instead of `match_id = 392195` and use string comparison instead of numeric. The amended query now correctly retrieves outcome data through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT outcome FROM matches WHERE match_id = 392195",
            "SELECT T2.Outcome_Type \nFROM Match AS T1 \nINNER JOIN Outcome AS T2 ON T1.Outcome_type = T2.Outcome_Id \nWHERE T1.Match_Id = '392195'"
        ],
        "rule_sql": []
    },
    "2818": {
        "db_id": "professional_basketball",
        "question": "Of all the teams coached by the winner of the 1994 NBA Coach of the Year award, which team has lost the most times playing at home?",
        "ground_truth": "SELECT T3.tmID FROM awards_coaches AS T1 INNER JOIN coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN teams AS T3 ON T3.tmID = T2.tmID WHERE T1.year = 1994 AND T1.award = 'NBA Coach of the Year' GROUP BY T3.tmID ORDER BY SUM(T3.homeLost) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `g`, `t`, and `c`. Do select `T3.tmID` instead of `t.team_name` and `COUNT(*) AS home_losses`. Do join `awards_coaches AS T1` instead of omitting it. Do use `INNER JOIN coaches AS T2 ON T1.coachID = T2.coachID` instead of `JOIN coaches c ON t.team_id = c.team_id`. Do join `teams AS T3 ON T3.tmID = T2.tmID` instead of `JOIN teams t ON g.home_team_id = t.team_id`. Do filter on `T1.year = 1994` and `T1.award = 'NBA Coach of the Year'` instead of `c.year = 1994` and `c.award = 'NBA Coach of the Year'`. Do remove the `g.home_score < g.away_score` filter instead of keeping it. Do group by `T3.tmID` instead of `t.team_name`. Do order by `SUM(T3.homeLost) DESC` instead of `home_losses DESC`. The amended query now correctly identifies the team with the most home losses for the 1994 NBA Coach of the Year by using the proper schema relationships and pre-aggregated homeLost data instead of calculating losses from game scores.",
            "Do remove `SUM(T3.homeLost) AS home_losses` from the SELECT list instead of including it. Do remove the `T3.year = T2.year` condition from the INNER JOIN on `teams AS T3` instead of keeping it. Do move the `SUM(T3.homeLost)` aggregate function to the ORDER BY clause instead of having it in the SELECT list. The amended query now correctly identifies the team with the most home losses for the NBA Coach of the Year in 1994 by focusing on the team ID in the SELECT while ordering by the sum of home losses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT t.team_name, COUNT(*) AS home_losses\nFROM games g\nJOIN teams t ON g.home_team_id = t.team_id\nJOIN coaches c ON t.team_id = c.team_id\nWHERE c.award = 'NBA Coach of the Year'\nAND c.year = 1994\nAND g.home_score < g.away_score\nGROUP BY t.team_name\nORDER BY home_losses DESC\nLIMIT 1;",
            "SELECT T3.tmID, SUM(T3.homeLost) AS home_losses\nFROM awards_coaches AS T1\nINNER JOIN coaches AS T2 ON T1.coachID = T2.coachID\nINNER JOIN teams AS T3 ON T3.tmID = T2.tmID AND T3.year = T2.year\nWHERE T1.year = 1994 AND T1.award = 'NBA Coach of the Year'\nGROUP BY T3.tmID\nORDER BY home_losses DESC\nLIMIT 1;",
            "SELECT T3.tmID\nFROM awards_coaches AS T1\nINNER JOIN coaches AS T2 ON T1.coachID = T2.coachID\nINNER JOIN teams AS T3 ON T3.tmID = T2.tmID\nWHERE T1.year = 1994 AND T1.award = 'NBA Coach of the Year'\nGROUP BY T3.tmID\nORDER BY SUM(T3.homeLost) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8307": {
        "db_id": "mondial_geo",
        "question": "What is the greatest length of the border between 2 independent countries?",
        "ground_truth": "SELECT MAX(T3.Length) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN borders AS T3 ON T3.Country1 = T2.Country WHERE T2.Independence IS NOT NULL",
        "amends": [
            "Do join `country` and `politics` tables instead of querying `borders` alone, adding proper relationships through `T1.Code = T2.Country` and `T3.Country1 = T2.Country` instead of direct status filters. Do filter on `T2.Independence IS NOT NULL` instead of checking `country1_status` and `country2_status` equality conditions. Do select `MAX(T3.Length)` instead of `MAX(border_length)` to reference the correct column name from the joined table structure. The amended query now correctly identifies independent countries through the politics table's independence field and retrieves maximum border lengths from properly correlated tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(border_length) FROM borders WHERE country1_status = 'independent' AND country2_status = 'independent';",
            "SELECT MAX(T3.Length) \nFROM country T1 \nJOIN politics T2 ON T1.Code = T2.Country \nJOIN borders T3 ON T2.Country = T3.Country1 \nJOIN country T4 ON T3.Country2 = T4.Code \nJOIN politics T5 ON T4.Code = T5.Country \nWHERE T2.Independence IS NOT NULL AND T5.Independence IS NOT NULL"
        ],
        "rule_sql": []
    },
    "1391": {
        "db_id": "synthea",
        "question": "What is the most common allergy among patients?",
        "ground_truth": "SELECT DESCRIPTION FROM allergies GROUP BY DESCRIPTION ORDER BY COUNT(DESCRIPTION) DESC LIMIT 1",
        "amends": [
            "Do select `DESCRIPTION` from the `allergies` table instead of `allergy` from the `patients` table. Do group by `DESCRIPTION` instead of `allergy` and order by `COUNT(DESCRIPTION)` instead of the alias `count`. Do remove the explicit count column alias instead of keeping it. The amended query now correctly retrieves the most common allergy description from the allergies table rather than attempting to count allergy values from the patients table.",
            "Do remove `COUNT(DESCRIPTION) AS count` from the SELECT list instead of including it, as the query only needs to return the DESCRIPTION column while still using the count for ordering purposes. Do keep the GROUP BY on `DESCRIPTION` instead of changing it. Do maintain the ORDER BY `COUNT(DESCRIPTION) DESC` instead of altering it, as this correctly orders by the frequency count. Do preserve the LIMIT 1 instead of modifying it to return the single most frequent allergy description. The amended query now matches RIGHT_SQL's behavior by returning only the description column while maintaining the same grouping and ordering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT allergy, COUNT(*) as count FROM patients GROUP BY allergy ORDER BY count DESC LIMIT 1;",
            "SELECT DESCRIPTION, COUNT(DESCRIPTION) AS count FROM allergies GROUP BY DESCRIPTION ORDER BY COUNT(DESCRIPTION) DESC LIMIT 1;",
            "SELECT DESCRIPTION FROM allergies GROUP BY DESCRIPTION ORDER BY COUNT(DESCRIPTION) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3105": {
        "db_id": "cars",
        "question": "List the name of the cars with model year 1975.",
        "ground_truth": "SELECT T1.car_name FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T2.model_year = 1975",
        "amends": [
            "Do select `T1.car_name` instead of `name` and use table aliases. Do add `FROM data AS T1 INNER JOIN production AS T2` instead of just `FROM cars` to include the required join. Do use `ON T1.ID = T2.ID` instead of no join condition. Do change the WHERE filter to reference `T2.model_year` instead of an unspecified table's `model_year` and use numeric `1975` instead of string `'1975'` for proper type matching. The amended query now correctly joins the data and production tables to retrieve car names from the appropriate source while ensuring proper type handling for the model year filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cars WHERE model_year = '1975';",
            "SELECT T1.car_name FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T2.model_year = 1975"
        ],
        "rule_sql": []
    },
    "539": {
        "db_id": "movies_4",
        "question": "List the character names played by Catherine Deneuve.",
        "ground_truth": "SELECT T2.character_name FROM person AS T1 INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Catherine Deneuve'",
        "amends": [
            "Do select `T2.character_name` from the `movie_cast` table instead of `character_name` from the `actors` table. Do join `person AS T1` and `movie_cast AS T2` with an `INNER JOIN` on `T1.person_id = T2.person_id` instead of querying a single `actors` table. Do filter on `T1.person_name = 'Catherine Deneuve'` instead of `actor_name = 'Catherine Deneuve'`. The amended query now correctly retrieves character names by joining person and movie_cast tables with proper relationship semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM actors WHERE actor_name = 'Catherine Deneuve';",
            "SELECT T2.character_name FROM person AS T1 INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE T1.person_name = 'Catherine Deneuve'"
        ],
        "rule_sql": []
    },
    "6868": {
        "db_id": "retails",
        "question": "Please list the phone numbers of all the suppliers in Germany.",
        "ground_truth": "SELECT T1.s_phone FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T2.n_name = 'Germany'",
        "amends": [
            "Do use `T1.s_phone` with table alias instead of `phone` without qualification. Do join `supplier AS T1` with `nation AS T2` on `T1.s_nationkey = T2.n_nationkey` instead of querying `suppliers` table alone. Do filter on `T2.n_name = 'Germany'` instead of `country = 'Germany'` to properly reference the nation table. The amended query now correctly joins supplier and nation tables to filter by country name through the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM suppliers WHERE country = 'Germany';",
            "SELECT T1.s_phone FROM supplier AS T1 JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey WHERE T2.n_name = 'Germany'"
        ],
        "rule_sql": []
    },
    "8301": {
        "db_id": "mondial_geo",
        "question": "Among the independent countries whose type of government is republic, what is the biggest number of deserts they have?",
        "ground_truth": "SELECT COUNT(T3.Desert) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN geo_desert AS T3 ON T3.Country = T2.Country WHERE T2.Government = 'republic'",
        "amends": [
            "Do `COUNT(T3.Desert)` instead of `MAX(desert_count)` to count desert occurrences rather than finding a maximum value. Do join `country AS T1`, `politics AS T2`, and `geo_desert AS T3` instead of querying only `countries` to properly access the required tables. Do use `INNER JOIN` on `T1.Code = T2.Country` and `T3.Country = T2.Country` instead of no joins to establish the correct table relationships. Do filter on `T2.Government = 'republic'` instead of `government_type = 'republic' AND independence_status = 'independent'` to use the correct column name and remove the unnecessary independence filter. The amended query now correctly counts deserts for republic countries by properly joining the relevant tables.",
            "Do remove the `AS desert_count` alias from the `COUNT(T3.Desert)` expression instead of keeping it. Do remove the `GROUP BY T1.Code` clause instead of including it since the query only returns an aggregate count without grouping. Do remove the `ORDER BY desert_count DESC` and `LIMIT 1` clauses instead of keeping them, as the query should return a single count value rather than finding the maximum count. The amended query now correctly returns the total count of deserts for all republic countries instead of attempting to find the country with the most deserts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(desert_count) FROM countries WHERE government_type = 'republic' AND independence_status = 'independent';",
            "SELECT COUNT(T3.Desert) AS desert_count\nFROM country AS T1\nINNER JOIN politics AS T2 ON T1.Code = T2.Country\nINNER JOIN geo_desert AS T3 ON T3.Country = T2.Country\nWHERE T2.Government = 'republic'\nGROUP BY T1.Code\nORDER BY desert_count DESC\nLIMIT 1;",
            "SELECT COUNT(T3.Desert) \nFROM country AS T1\nINNER JOIN politics AS T2 ON T1.Code = T2.Country\nINNER JOIN geo_desert AS T3 ON T3.Country = T2.Country\nWHERE T2.Government = 'republic'"
        ],
        "rule_sql": []
    },
    "3537": {
        "db_id": "authors",
        "question": "What are the journal homepages and author ID of the papers published in 2000 to 2005 with a word \"social\" in its title?",
        "ground_truth": "SELECT T3.HomePage, T2.AuthorId FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id WHERE T1.Year BETWEEN 2000 AND 2005 AND T1.Title LIKE '%SOCIAL%'",
        "amends": [
            "Do use explicit table aliases `T3.HomePage` and `T2.AuthorId` instead of direct column names `journal_homepage` and `author_id`. Do add `INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` and `INNER JOIN Journal AS T3 ON T1.JournalId = T3.Id` instead of querying only the `papers` table. Do reference `T1.Year` and `T1.Title` with table aliases instead of unqualified `year` and `title`. Do use uppercase `'%SOCIAL%'` pattern instead of lowercase `'%social%'` for case sensitivity. The amended query now correctly joins through the PaperAuthor and Journal tables to retrieve the homepage and author information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT journal_homepage, author_id FROM papers WHERE year BETWEEN 2000 AND 2005 AND title LIKE '%social%';",
            "SELECT T3.HomePage, T2.AuthorId \nFROM Paper AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nINNER JOIN Journal AS T3 ON T1.JournalId = T3.Id\nWHERE T1.Year BETWEEN 2000 AND 2005 \nAND T1.Title LIKE '%SOCIAL%'"
        ],
        "rule_sql": []
    },
    "9261": {
        "db_id": "movie_3",
        "question": "How many actors with the surname Kilmer are there?",
        "ground_truth": "SELECT COUNT(actor_id) FROM actor WHERE last_name = 'Kilmer'",
        "amends": [
            "Do reference the `actor_id` column instead of using `COUNT(*)` to count specific non-null values. Do filter on `last_name = 'Kilmer'` instead of `first_name = 'Kilmer'` to correctly identify actors by their surname. Do use the table name `actor` instead of `actors` to match the correct schema. The amended query now properly counts Kilmer actors by their last name rather than first name and uses column-specific counting instead of star notation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM actors WHERE first_name = 'Kilmer';",
            "SELECT COUNT(actor_id) FROM actor WHERE last_name = 'Kilmer';"
        ],
        "rule_sql": []
    },
    "1017": {
        "db_id": "computer_student",
        "question": "How many non-faculty members are not undergoing the phase of qualifications?",
        "ground_truth": "SELECT COUNT(*) FROM person WHERE hasPosition = 0 AND inPhase = 0",
        "amends": [
            "Do reference table `person` instead of `members`. Do use filter `hasPosition = 0` instead of `faculty = 0`. Do use filter `inPhase = 0` instead of `phase != 'qualifications'`. The amended query now correctly counts records from the person table where position status and phase meet the specified criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE faculty = 0 AND phase != 'qualifications';",
            "SELECT COUNT(*) FROM person WHERE hasPosition = '0' AND inPhase = '0';"
        ],
        "rule_sql": []
    },
    "7521": {
        "db_id": "image_and_language",
        "question": "What are the captions of all the self-relation relationship prediction classes?",
        "ground_truth": "SELECT T2.PRED_CLASS FROM IMG_REL AS T1 INNER JOIN pred_classes AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T1.OBJ1_SAMPLE_ID = T1.OBJ2_SAMPLE_ID GROUP BY T2.PRED_CLASS",
        "amends": [
            "Do select `T2.PRED_CLASS` instead of `caption` and change the source table to `IMG_REL AS T1 INNER JOIN pred_classes AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` instead of querying `relationship_prediction_classes` alone. Do add a WHERE filter `T1.OBJ1_SAMPLE_ID = T1.OBJ2_SAMPLE_ID` instead of filtering by `relationship_type = 'self-relation'` and include `GROUP BY T2.PRED_CLASS` instead of omitting aggregation. The amended query now correctly joins the image relationship table with prediction classes and groups by the prediction class to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT caption FROM relationship_prediction_classes WHERE relationship_type = 'self-relation';",
            "SELECT T2.PRED_CLASS\nFROM IMG_REL AS T1\nINNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID\nWHERE T1.OBJ1_SAMPLE_ID = T1.OBJ2_SAMPLE_ID\nGROUP BY T2.PRED_CLASS"
        ],
        "rule_sql": []
    },
    "8654": {
        "db_id": "chicago_crime",
        "question": "Provide the occurrence date and location of the deceptive practice due to the unlawful use of recorded sound.",
        "ground_truth": "SELECT T2.date, T2.latitude, T2.longitude FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no WHERE T1.primary_description = 'DECEPTIVE PRACTICE' AND T1.secondary_description = 'UNLAWFUL USE OF RECORDED SOUND'",
        "amends": [
            "Do use table aliases `T2` and `T1` instead of no aliases. Do select `T2.latitude` and `T2.longitude` instead of `location`. Do join `IUCR AS T1` and `Crime AS T2` with `INNER JOIN` on `T2.iucr_no = T1.iucr_no` instead of querying only `deceptive_practices`. Do filter on `T1.primary_description = 'DECEPTIVE PRACTICE'` and `T1.secondary_description = 'UNLAWFUL USE OF RECORDED SOUND'` instead of `description = 'unlawful use of recorded sound'`. The amended query now correctly joins the IUCR and Crime tables to retrieve spatial coordinates for specific crime classifications."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, location FROM deceptive_practices WHERE description = 'unlawful use of recorded sound'",
            "SELECT T2.date, T2.latitude, T2.longitude\nFROM IUCR AS T1\nINNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no\nWHERE T1.primary_description = 'DECEPTIVE PRACTICE'\nAND T1.secondary_description = 'UNLAWFUL USE OF RECORDED SOUND'"
        ],
        "rule_sql": []
    },
    "4555": {
        "db_id": "student_loan",
        "question": "How many students enlisted in the Navy?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'navy'",
        "amends": [
            "Do count `name` instead of `*` to count non-null values. Do query from `enlist` instead of `students` as the correct data source. Do filter on `organ = 'navy'` instead of `branch = 'Army'` to use the proper column name and value. The amended query now correctly counts non-null names from the enlist table where organ equals navy."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE branch = 'Army';",
            "SELECT COUNT(name) FROM enlist WHERE organ = 'navy'"
        ],
        "rule_sql": []
    },
    "4355": {
        "db_id": "simpson_episodes",
        "question": "List down the episode ID of episodes aired in 2008 with 5 stars and below.",
        "ground_truth": "SELECT DISTINCT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' AND T2.stars < 5;",
        "amends": [
            "Do use `DISTINCT T1.episode_id` instead of non-distinct `episode_id`. Do join `Episode AS T1 INNER JOIN Vote AS T2` instead of querying only the `episodes` table. Do use `ON T2.episode_id = T1.episode_id` instead of no join condition. Do filter with `SUBSTR(T1.air_date, 1, 4) = '2008'` instead of `air_year = 2008`. Do use `T2.stars < 5` instead of `rating >= 5`. The amended query now correctly joins the Episode and Vote tables to find episodes from 2008 with votes below 5 stars, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id FROM episodes WHERE air_year = 2008 AND rating >= 5;",
            "SELECT DISTINCT T1.episode_id\nFROM Episode AS T1\nINNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE SUBSTR(T1.air_date, 1, 4) = '2008'\nAND T2.stars < 5"
        ],
        "rule_sql": []
    },
    "5751": {
        "db_id": "language_corpus",
        "question": "How many times on page number 16 does the second word in the pair of words 1 and 109 appear?",
        "ground_truth": "SELECT SUM(T1.occurrences) FROM pages_words AS T1 INNER JOIN biwords AS T2 ON T2.w2nd = T1.wid WHERE T2.w2nd = 109 AND T2.w1st = 1 AND T1.pid = 16",
        "amends": [
            "Do use `SUM(T1.occurrences)` instead of `COUNT(*)` to sum actual occurrence values rather than counting rows. Do join `pages_words AS T1` with `biwords AS T2` instead of querying only the `words` table, adding necessary tables for the relationship. Do specify `INNER JOIN` with `ON T2.w2nd = T1.wid` instead of no join condition, establishing the correct relationship between tables. Do filter with `T2.w2nd = 109 AND T2.w1st = 1 AND T1.pid = 16` instead of `page = 16 AND word_id = 109`, using the proper column names and adding the required `w1st` condition. The amended query now correctly calculates the sum of occurrences for the specified biword relationship rather than counting rows from an incorrect table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE page = 16 AND word_id = 109;",
            "SELECT SUM(T1.occurrences) \nFROM pages_words AS T1\nINNER JOIN biwords AS T2 ON T2.w2nd = T1.wid\nWHERE T2.w2nd = 109 AND T2.w1st = 1 AND T1.pid = 16"
        ],
        "rule_sql": []
    },
    "1817": {
        "db_id": "soccer_2016",
        "question": "What is the batting hand of MK Pandey?",
        "ground_truth": "SELECT T2.Batting_hand FROM Player AS T1 INNER JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id WHERE T1.Player_Name = 'MK Pandey'",
        "amends": [
            "Do join `Batting_Style` as `T2` on `T1.Batting_hand = T2.Batting_Id` instead of querying only the `players` table. Do select `T2.Batting_hand` from the joined table instead of directly selecting `batting_hand` from the players table. Do use table aliases `T1` for `Player` and `T2` for `Batting_Style` instead of no aliases. Do filter on `T1.Player_Name` instead of `name` to match the correct column name. The amended query now correctly retrieves the batting hand description from the reference table rather than the foreign key ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT batting_hand FROM players WHERE name = 'MK Pandey';",
            "SELECT T2.Batting_hand FROM Player AS T1 JOIN Batting_Style AS T2 ON T1.Batting_hand = T2.Batting_Id WHERE T1.Player_Name = 'MK Pandey'"
        ],
        "rule_sql": []
    },
    "313": {
        "db_id": "retail_complains",
        "question": "What is the average number of stars given by Oregon clients in their reviews?",
        "ground_truth": "SELECT CAST(SUM(T3.Stars) AS REAL) / COUNT(T3.Stars) AS average FROM state AS T1 INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN reviews AS T3 ON T2.district_id = T3.district_id WHERE T1.State = 'Oregon'",
        "amends": [
            "Do add explicit table joins with `state AS T1 INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN reviews AS T3 ON T2.district_id = T3.district_id` instead of querying `reviews` directly without proper relationships. Do use `T1.State = 'Oregon'` instead of `client_state = 'Oregon'` to filter by the correct state column. Do calculate average as `CAST(SUM(T3.Stars) AS REAL) / COUNT(T3.Stars) AS average` instead of using the `AVG` aggregate function. Do add proper table aliases `T1`, `T2`, and `T3` instead of referencing columns without table qualification. The amended query now correctly joins through the district relationship to calculate average stars for Oregon state."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(stars) FROM reviews WHERE client_state = 'Oregon';",
            "SELECT CAST(SUM(T3.Stars) AS REAL) / COUNT(T3.Stars) AS average\nFROM state AS T1 \nINNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev \nINNER JOIN reviews AS T3 ON T2.district_id = T3.district_id\nWHERE T1.State = 'Oregon'"
        ],
        "rule_sql": []
    },
    "2328": {
        "db_id": "movielens",
        "question": "How many 35-year-old female users gave the movie 1711133 a rating of 3?",
        "ground_truth": "SELECT COUNT(T1.userid) FROM users AS T1 INNER JOIN u2base AS T2 ON T1.userid = T2.userid WHERE T2.rating = 3 AND T2.movieid = '1711133' AND T1.age = 35 AND T1.u_gender = 'F'",
        "amends": [
            "Do use `COUNT(T1.userid)` instead of `COUNT(*)` to count specific non-null values. Do reference table `users AS T1` instead of `users u` and use column `T1.userid` instead of `u.user_id`. Do join with `u2base AS T2` instead of `ratings r` and use `T2.userid` instead of `r.user_id` for the join condition. Do filter on `T2.rating = 3` instead of `r.rating = 3` and `T2.movieid = '1711133'` instead of `r.movie_id = 1711133`, adding quotes around the movie ID value. Do filter on `T1.u_gender = 'F'` instead of `u.gender = 'F'` using the correct column name. The amended query now correctly counts users from the specified tables with the proper join conditions and filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM users u\nJOIN ratings r ON u.user_id = r.user_id\nWHERE u.age = 35 \nAND u.gender = 'F' \nAND r.movie_id = 1711133 \nAND r.rating = 3",
            "SELECT COUNT(T1.userid) \nFROM users AS T1\nJOIN u2base AS T2 ON T1.userid = T2.userid\nWHERE T1.age = '35' \nAND T1.u_gender = 'F' \nAND T2.movieid = '1711133' \nAND T2.rating = '3'"
        ],
        "rule_sql": []
    },
    "5086": {
        "db_id": "address",
        "question": "Among all the residential areas in Arecibo county, what is the zip_code of the one with the highest white population?",
        "ground_truth": "SELECT T1.zip_code FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'ARECIBO' ORDER BY T1.white_population DESC LIMIT 1",
        "amends": [
            "Do use `zip_data AS T1` as the main table instead of `residential_areas`, and add `INNER JOIN country AS T2` instead of omitting the join. Do use the join condition `T1.zip_code = T2.zip_code` instead of no join condition, and change the filter to `T2.county = 'ARECIBO'` instead of `county = 'Arecibo'` with proper table qualification and uppercase value. Do qualify `zip_code` as `T1.zip_code` and `white_population` as `T1.white_population` instead of unqualified column references. The amended query now correctly joins the necessary tables and uses proper table qualifications to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM residential_areas WHERE county = 'Arecibo' ORDER BY white_population DESC LIMIT 1;",
            "SELECT T1.zip_code\nFROM zip_data AS T1\nINNER JOIN country AS T2 ON T1.zip_code = T2.zip_code\nWHERE T2.county = 'ARECIBO'\nORDER BY T1.white_population DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6229": {
        "db_id": "food_inspection_2",
        "question": "Please list the names of taverns that paid a $100 fine upon inspection.",
        "ground_truth": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id WHERE T1.facility_type = 'Tavern' AND T3.fine = 100",
        "amends": [
            "Do select `T1.dba_name` instead of `name` and add `DISTINCT` instead of omitting it. Do use `establishment AS T1` instead of `taverns` and add `INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no` and `INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id` instead of a single table. Do change the WHERE clause to `T1.facility_type = 'Tavern' AND T3.fine = 100` instead of `fine_amount = 100` to properly filter by facility type and fine amount through the joined tables. The amended query now correctly retrieves distinct tavern names with $100 fines by joining the establishment, inspection, and violation tables with proper relationship conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM taverns WHERE fine_amount = 100;",
            "SELECT DISTINCT T1.dba_name\nFROM establishment AS T1\nINNER JOIN inspection AS T2 ON T1.license_no = T2.license_no\nINNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id\nWHERE T1.facility_type = 'Tavern' AND T3.fine = 100"
        ],
        "rule_sql": []
    },
    "8974": {
        "db_id": "human_resources",
        "question": "In which state can you find the highest amount of good performing Account Representatives?",
        "ground_truth": "SELECT T2.state FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID INNER JOIN position AS T3  ON T3.positionID = T1.positionID WHERE T3.positiontitle = 'Account Representative' AND T1.performance = 'Good' GROUP BY T2.state ORDER BY COUNT(T2.state) DESC LIMIT 1",
        "amends": [
            "Do join `employee` with `location` on `locationID` and `position` on `positionID` instead of querying only `employees` table. Do filter on `positiontitle = 'Account Representative'` from the joined `position` table instead of directly filtering `position` column. Do use `T1.performance = 'Good'` with proper case sensitivity instead of `performance = 'good'`. Do group by `T2.state` from the joined `location` table instead of grouping by `state` directly. Do order by `COUNT(T2.state)` instead of ordering by alias `count`. The amended query now correctly joins related tables and uses proper column references to match the intended logic.",
            "Do use `COUNT(T2.state)` instead of `COUNT(*)` in the ORDER BY clause to ensure consistent aggregation behavior. Do maintain the same join conditions and filter logic as the original query preserves all other elements including the SELECT list with `T2.state`, FROM sources with `employee`, `location`, and `position` tables using INNER JOINs, WHERE filters for `positiontitle` and `performance`, GROUP BY on `T2.state`, and LIMIT 1. The amended query now matches RIGHT_SQL's behavior by using the specific column count rather than counting all rows."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, COUNT(*) as count FROM employees WHERE position = 'Account Representative' AND performance = 'good' GROUP BY state ORDER BY count DESC LIMIT 1;",
            "SELECT T2.state, COUNT(*) as count\nFROM employee T1\nJOIN location T2 ON T1.locationID = T2.locationID\nJOIN position T3 ON T1.positionID = T3.positionID\nWHERE T3.positiontitle = 'Account Representative' AND T1.performance = 'Good'\nGROUP BY T2.state\nORDER BY COUNT(*) DESC\nLIMIT 1",
            "SELECT T2.state\nFROM employee T\nINNER JOIN location T2 ON T.locationID = T2.locationID\nINNER JOIN position T3 ON T.positionID = T3.positionID\nWHERE T3.positiontitle = 'Account Representative' AND T.performance = 'Good'\nGROUP BY T2.state\nORDER BY COUNT(T2.state) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "901": {
        "db_id": "cs_semester",
        "question": "Which of the two courses, \"Advanced Operating System\" or \"Intro to BlockChain', did most of the students receive an A in?",
        "ground_truth": "SELECT T2.name FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T1.grade = 'A' AND T2.name IN ('Advanced Operating System', 'Intro to BlockChain') GROUP BY T2.name ORDER BY COUNT(T1.student_id) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` instead of `course_name` and `COUNT(*) as a_count`. Do use `registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id` instead of just `FROM grades`. Do add filter `T1.grade = 'A' AND T2.name IN ('Advanced Operating System', 'Intro to BlockChain')` instead of only `WHERE grade = 'A'`. Do group by `T2.name` instead of `course_name`. Do order by `COUNT(T1.student_id) DESC` instead of `a_count DESC`. The amended query now correctly joins registration and course tables, filters for specific course names, and counts student IDs to match the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) as a_count` from the SELECT list instead of including it, and do add `LIMIT 1` at the end instead of omitting it. The amended query now matches RIGHT_SQL's behavior by returning only the top course name without the count column and limiting to a single result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_name, COUNT(*) as a_count\nFROM grades\nWHERE grade = 'A'\nGROUP BY course_name\nORDER BY a_count DESC\nLIMIT 1;",
            "SELECT T2.name, COUNT(*) as a_count\nFROM registration AS T1 \nINNER JOIN course AS T2 ON T1.course_id = T2.course_id\nWHERE T1.grade = 'A' AND T2.name IN ('Advanced Operating System', 'Intro to BlockChain')\nGROUP BY T2.name\nORDER BY COUNT(T1.student_id) DESC",
            "SELECT T2.name\nFROM registration AS T1\nINNER JOIN course AS T2 ON T1.course_id = T2.course_id\nWHERE T1.grade = 'A' AND T2.name IN ('Advanced Operating System', 'Intro to BlockChain')\nGROUP BY T2.name\nORDER BY COUNT(T1.student_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "299": {
        "db_id": "retail_complains",
        "question": "How many male clients are from the state of Massachusetts?",
        "ground_truth": "SELECT COUNT(T3.sex) FROM state AS T1 INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN client AS T3 ON T2.district_id = T3.district_id WHERE T1.state = 'Massachusetts' AND T3.sex = 'Male'",
        "amends": [
            "Do join tables `state AS T1`, `district AS T2`, and `client AS T3` instead of querying only `clients`. Do use `INNER JOIN` on `T1.StateCode = T2.state_abbrev` and `T2.district_id = T3.district_id` instead of no joins. Do filter on `T1.state = 'Massachusetts'` and `T3.sex = 'Male'` instead of `gender = 'female' AND state = 'Massachusetts'`. Do count `T3.sex` instead of `COUNT(*)`. The amended query now correctly counts male clients in Massachusetts through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE gender = 'female' AND state = 'Massachusetts';",
            "SELECT COUNT(T3.sex) \nFROM state AS T1\nINNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev\nINNER JOIN client AS T3 ON T2.district_id = T3.district_id\nWHERE T1.State = 'Massachusetts' AND T3.sex = 'Male'"
        ],
        "rule_sql": []
    },
    "3750": {
        "db_id": "college_completion",
        "question": "How many 4-year public institutions are there in the state of Florida? Give all of their names.",
        "ground_truth": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 WHERE T2.level = '4-year' AND T2.control = 'Public' AND T2.state = 'Florida'",
        "amends": [
            "Do select `T1.chronname` instead of `COUNT(*)`. Do use `INNER JOIN` between `institution_details AS T1` and `state_sector_details AS T2` instead of querying only `institutions`. Do filter on `T2.level = '4-year'` instead of `years = 4`. Do filter on `T2.control = 'Public'` instead of `type = 'public'`. Do filter on `T2.state = 'Florida'` instead of `state = 'Florida'`. The amended query now correctly joins the appropriate tables and uses the proper column names and values to match the intended behavior.",
            "Do remove the `ON T1.state = T2.state` join condition from the `INNER JOIN` instead of including it, as the tables are being joined without explicit join predicates. The amended query now correctly matches RIGHT_SQL's behavior by performing a cross join between the tables while maintaining the same filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM institutions WHERE state = 'Florida' AND type = 'public' AND years = 4;",
            "SELECT T1.chronname\nFROM institution_details AS T1\nINNER JOIN state_sector_details AS T2 ON T1.state = T2.state\nWHERE T2.level = '4-year' \nAND T2.control = 'Public' \nAND T2.state = 'Florida'",
            "SELECT T1.chronname\nFROM institution_details AS T1\nINNER JOIN state_sector_details AS T2\nWHERE T2.level = '4-year' \nAND T2.control = 'Public' \nAND T2.state = 'Florida'"
        ],
        "rule_sql": []
    },
    "5644": {
        "db_id": "shipping",
        "question": "How many trucks were manufactured in year 2009?",
        "ground_truth": "SELECT COUNT(truck_id) FROM truck WHERE model_year = 2009",
        "amends": [
            "Do reference the `truck` table instead of `trucks`. Do count `truck_id` instead of using `COUNT(*)`. Do filter on `model_year` instead of `year`. Do use integer value `2009` instead of string `'2009'`. The amended query now correctly counts specific truck records from the proper table with appropriate data type handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trucks WHERE year = '2009';",
            "SELECT COUNT(truck_id) FROM truck WHERE model_year = 2009"
        ],
        "rule_sql": []
    },
    "215": {
        "db_id": "book_publishing_company",
        "question": "What's the royalty for the bestseller book?",
        "ground_truth": "SELECT royalty FROM titles ORDER BY ytd_sales DESC LIMIT 1",
        "amends": [
            "Do select `royalty` from `titles` instead of `books` as the source table. Do use `ORDER BY ytd_sales DESC LIMIT 1` instead of a subquery with `WHERE sales = (SELECT MAX(sales) FROM books)` to find the maximum sales record. Do reference `ytd_sales` instead of `sales` as the sales column name. The amended query now correctly retrieves the royalty value from the record with the highest year-to-date sales using an efficient ordering and limiting approach instead of an equality subquery that could fail if multiple records share the maximum sales value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT royalty FROM books WHERE sales = (SELECT MAX(sales) FROM books);",
            "SELECT royalty FROM titles ORDER BY ytd_sales DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7515": {
        "db_id": "image_and_language",
        "question": "How many images have at least 5 \"black\" classes?",
        "ground_truth": "SELECT COUNT(IMGID) FROM ( SELECT T1.IMG_ID AS IMGID FROM IMG_OBJ_att AS T1 INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T2.ATT_CLASS = 'black' GROUP BY T1.IMG_ID HAVING COUNT(T1.ATT_CLASS_ID) >= 5 ) T3",
        "amends": [
            "Do use a subquery with proper table joins instead of querying a single table directly. Do select `COUNT(IMGID)` from a derived table instead of `COUNT(*)` from the base table. Do join `IMG_OBJ_att` with `ATT_CLASSES` on `T1.ATT_CLASS_ID = T2.ATT_CLASS_ID` instead of filtering on a non-existent `class` column. Do filter with `T2.ATT_CLASS = 'black'` in the WHERE clause instead of `class = 'black'`. Do group by `T1.IMG_ID` and use `HAVING COUNT(T1.ATT_CLASS_ID) >= 5` instead of placing the aggregate condition in the WHERE clause. Do properly reference the image ID column as `T1.IMG_ID` with alias `IMGID` instead of missing the image identifier entirely. The amended query now correctly counts images containing at least 5 black objects by properly joining classification tables and using appropriate grouping with HAVING clause."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE class = 'black' AND COUNT(class) >= 5",
            "SELECT COUNT(IMGID) \nFROM (\n    SELECT T1.IMG_ID AS IMGID\n    FROM IMG_OBJ_ATT T1\n    JOIN ATT_CLASSES T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID\n    WHERE T2.ATT_CLASS = 'black'\n    GROUP BY T1.IMG_ID\n    HAVING COUNT(T1.ATT_CLASS_ID) >= 5\n)"
        ],
        "rule_sql": []
    },
    "778": {
        "db_id": "social_media",
        "question": "How many tweets are seen by more than 1000 unique users?",
        "ground_truth": "SELECT COUNT(TweetID) AS tweet_number FROM twitter WHERE Reach > 1000",
        "amends": [
            "Do use `COUNT(TweetID)` with alias `tweet_number` instead of `COUNT(*)` without an alias. Do reference table `twitter` instead of `tweets`. Do filter on column `Reach > 1000` instead of `user_count > 1000`. The amended query now correctly counts tweets with reach exceeding 1000 using the proper table and column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE user_count > 1000;",
            "SELECT COUNT(TweetID) AS tweet_number FROM twitter WHERE Reach > 1000"
        ],
        "rule_sql": []
    },
    "578": {
        "db_id": "codebase_comments",
        "question": "In the \"https://github.com/wallerdev/htmlsharp.git\", give all the linearized sequenced of API calls.",
        "ground_truth": "SELECT T3.ApiCalls FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE T1.Url = 'https://github.com/wallerdev/htmlsharp.git'",
        "amends": [
            "Do select `T3.ApiCalls` instead of `*` to return only the specific column needed. Do use `FROM Repo AS T1` instead of `FROM api_calls` to start from the correct source table. Do add `INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId` instead of omitting the necessary join to connect repositories to solutions. Do add `INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId` instead of omitting the join to access method data. Do use `WHERE T1.Url = 'https://github.com/wallerdev/htmlsharp.git'` instead of `WHERE repository_url = 'https://github.com/wallerdev/htmlsharp.git'` to filter by the correct column name and table. Do remove `ORDER BY sequence_number` instead of keeping it as the query no longer needs ordering. The amended query now correctly joins through the repository-solution-method hierarchy to retrieve API calls for the specified repository, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM api_calls WHERE repository_url = 'https://github.com/wallerdev/htmlsharp.git' ORDER BY sequence_number;",
            "SELECT T3.ApiCalls \nFROM Repo AS T1 \nINNER JOIN Solution AS T2 ON T1.Id = T2.RepoId \nINNER JOIN Method AS T3 ON T2.Id = T3.SolutionId \nWHERE T1.Url = 'https://github.com/wallerdev/htmlsharp.git'"
        ],
        "rule_sql": []
    },
    "9217": {
        "db_id": "movie_3",
        "question": "Write down the inventories' IDs and actors' names of \"STREETCAR INTENTIONS\".",
        "ground_truth": "SELECT T4.inventory_id, T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN inventory AS T4 ON T2.film_id = T4.film_id WHERE T3.title = 'STREETCAR INTENTIONS'",
        "amends": [
            "Do add `last_name` to the SELECT list instead of omitting it. Do change the FROM clause to use `INNER JOIN` with `film_actor` as an intermediate table instead of directly joining `inventory` to `actor`. Do use proper join conditions `T1.actor_id = T2.actor_id` and `T2.film_id = T3.film_id` instead of incorrect `i.film_id = a.actor_id`. Do reference the title filter through the `film` table as `T3.title` instead of applying it directly to an undefined table. Do add proper table aliases `T1`, `T2`, `T3`, and `T4` for clarity instead of using ambiguous single-letter aliases. The amended query now correctly retrieves inventory and actor information for the specified film title through the proper relational path."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inventory_id, first_name FROM inventory i JOIN actor a ON i.film_id = a.actor_id WHERE title = 'STREETCAR INTENTIONS'",
            "SELECT T1.inventory_id, T4.first_name, T4.last_name\nFROM inventory T1\nINNER JOIN film T2 ON T1.film_id = T2.film_id\nINNER JOIN film_actor T3 ON T2.film_id = T3.film_id\nINNER JOIN actor T4 ON T3.actor_id = T4.actor_id\nWHERE T2.title = 'STREETCAR INTENTIONS'"
        ],
        "rule_sql": []
    },
    "1263": {
        "db_id": "law_episode",
        "question": "Which role did Joseph Blair play in the show?",
        "ground_truth": "SELECT T1.role FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T2.name = 'Joseph Blair'",
        "amends": [
            "Do select `T1.role` instead of `character_name` and use table aliases. Do join `Credit AS T1` and `Person AS T2` with an `INNER JOIN` on `T2.person_id = T1.person_id` instead of querying only the `actors` table. Do filter on `T2.name = 'Joseph Blair'` instead of `actor_name = 'Joseph Blair'` to reference the correct column in the joined table structure. The amended query now correctly retrieves role information from the proper table relationships instead of attempting to access non-existent columns in a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM actors WHERE actor_name = 'Joseph Blair';",
            "SELECT T1.role FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T2.name = 'Joseph Blair'"
        ],
        "rule_sql": []
    },
    "7407": {
        "db_id": "works_cycles",
        "question": "Where can I find the Valley Bicycle Specialists store?",
        "ground_truth": "SELECT T2.AddressLine1, T2.AddressLine2 FROM BusinessEntityAddress AS T1 INNER JOIN Address AS T2 ON T1.AddressID = T2.AddressID INNER JOIN Store AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T3.Name = 'Valley Bicycle Specialists'",
        "amends": [
            "Do select specific columns `T2.AddressLine1` and `T2.AddressLine2` instead of selecting all columns with `*`. Do join multiple tables `BusinessEntityAddress AS T1`, `Address AS T2`, and `Store AS T3` instead of querying only the `stores` table. Do use `INNER JOIN` with proper join conditions `T1.AddressID = T2.AddressID` and `T1.BusinessEntityID = T3.BusinessEntityID` instead of no joins. Do filter on `T3.Name` instead of filtering on a non-existent `name` column in the original table. The amended query now correctly retrieves address information for the specified store by properly joining the relevant business entity, address, and store tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM stores WHERE name = 'Valley Bicycle Specialists';",
            "SELECT T2.AddressLine1, T2.AddressLine2\nFROM BusinessEntityAddress AS T1\nINNER JOIN Address AS T2 ON T1.AddressID = T2.AddressID\nINNER JOIN Store AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID\nWHERE T3.Name = 'Valley Bicycle Specialists';"
        ],
        "rule_sql": []
    },
    "9329": {
        "db_id": "movie_3",
        "question": "How many customers have an address in Abu Dhabi city? List those customer names.",
        "ground_truth": "SELECT COUNT(T1.city_id) FROM city AS T1 INNER JOIN address AS T2 ON T1.city_id = T2.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id WHERE T1.city = 'Abu Dhabi'",
        "amends": [
            "Do use `COUNT(T1.city_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do join `city AS T1` instead of querying only the `customers` table to properly access city information. Do add `INNER JOIN address AS T2 ON T1.city_id = T2.city_id` instead of omitting the address table relationship. Do add `INNER JOIN customer AS T3 ON T2.address_id = T3.address_id` instead of directly querying customers without proper joins. Do filter on `T1.city = 'Abu Dhabi'` instead of `city = 'Abu Dhabi'` to reference the correct table. Do remove `customer_name` and the `as customer_count` alias instead of including them since the query now focuses on counting customers by city through proper table relationships. The amended query now correctly counts customers in Abu Dhabi through the proper city-address-customer relationship chain."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as customer_count, customer_name FROM customers WHERE city = 'Abu Dhabi';",
            "SELECT COUNT(T1.city_id) \nFROM city AS T1\nINNER JOIN address AS T2 ON T1.city_id = T2.city_id\nINNER JOIN customer AS T3 ON T2.address_id = T3.address_id\nWHERE T1.city = 'Abu Dhabi'"
        ],
        "rule_sql": []
    },
    "7607": {
        "db_id": "image_and_language",
        "question": "Name the most common predicate class of image ID 4434.",
        "ground_truth": "SELECT T2.PRED_CLASS FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T1.IMG_ID = 4434 ORDER BY T2.PRED_CLASS DESC LIMIT 1",
        "amends": [
            "Do select `T2.PRED_CLASS` instead of `predicate` and remove the `GROUP BY` and aggregate function. Do use `FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2` instead of `FROM images` with a single table. Do specify the join condition `ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` instead of no join. Do filter with `WHERE T1.IMG_ID = 4434` instead of `WHERE image_id = 4434`. Do order by `T2.PRED_CLASS DESC` instead of `ORDER BY COUNT(*) DESC` and remove the grouping. The amended query now correctly retrieves the predicate class through proper table joins and eliminates the unnecessary aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT predicate FROM images WHERE image_id = 4434 GROUP BY predicate ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T2.PRED_CLASS\nFROM IMG_REL AS T1\nINNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID\nWHERE T1.IMG_ID = 4434\nORDER BY T2.PRED_CLASS DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8442": {
        "db_id": "mondial_geo",
        "question": "How many businesses were founded after 1960 in a nation that wasn't independent?",
        "ground_truth": "SELECT COUNT(T3.Name) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN organization AS T3 ON T3.Country = T2.Country WHERE T2.Independence = NULL AND STRFTIME('%Y', T3.Established) > '1960'",
        "amends": [
            "Do use `COUNT(T3.Name)` instead of `COUNT(*)` to count specific non-null values. Do reference tables `country AS T1`, `politics AS T2`, and `organization AS T3` instead of `businesses` and `nations`. Do use `INNER JOIN` with `T1.Code = T2.Country` and `T3.Country = T2.Country` instead of `JOIN` with `b.nation_id = n.id`. Do filter with `T2.Independence = NULL` instead of `n.independent = 1` to check for null independence status. Do use `STRFTIME('%Y', T3.Established) > '1960'` instead of `b.founded_year > 1960` to extract year from date and compare as string. The amended query now correctly counts organizations in countries without independence dates established after 1960, matching RIGHT_SQL's behavior.",
            "Do use `T2.Independence = NULL` instead of `T2.Independence IS NULL` in the WHERE clause to properly handle NULL value comparisons. The amended query now matches RIGHT_SQL's behavior by using equality comparison with NULL rather than the IS NULL operator."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM businesses b\nJOIN nations n ON b.nation_id = n.id\nWHERE b.founded_year > 1960 \nAND n.independent = 1;",
            "SELECT COUNT(T3.Name) \nFROM country AS T1\nINNER JOIN politics AS T2 ON T1.Code = T2.Country\nINNER JOIN organization AS T3 ON T3.Country = T2.Country\nWHERE T2.Independence IS NULL\nAND STRFTIME('%Y', T3.Established) > '1960'",
            "SELECT COUNT(T3.Name) \nFROM country AS T1\nINNER JOIN politics AS T2 ON T1.Code = T2.Country\nINNER JOIN organization AS T3 ON T3.Country = T2.Country\nWHERE T2.Independence = NULL \nAND STRFTIME('%Y', T3.Established) > '1960'"
        ],
        "rule_sql": []
    },
    "2266": {
        "db_id": "movielens",
        "question": "List down the ID of movies with running time of 3 and average revenue of 1?",
        "ground_truth": "SELECT T1.movieid FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid INNER JOIN directors AS T3 ON T2.directorid = T3.directorid WHERE T1.runningtime = 3 AND T3.avg_revenue = 1",
        "amends": [
            "Do add `INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid` and `INNER JOIN directors AS T3 ON T2.directorid = T3.directorid` instead of querying only the `movies` table. Do change the filter from `revenue = 1` to `T3.avg_revenue = 1` instead of using the wrong column reference. Do use `T1.movieid` with table alias instead of `movie_id` without qualification. Do change `running_time` to `T1.runningtime` instead of the incorrect column name. The amended query now correctly joins through the relationship tables to filter by director's average revenue instead of a non-existent revenue column on movies."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT movie_id FROM movies WHERE running_time = 3 AND revenue = 1;",
            "SELECT T1.movieid\nFROM movies AS T1\nINNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid\nINNER JOIN directors AS T3 ON T2.directorid = T3.directorid\nWHERE T1.runningtime = 3 AND T3.avg_revenue = 1;"
        ],
        "rule_sql": []
    },
    "7471": {
        "db_id": "works_cycles",
        "question": "What is the the average percentage of profit for the all the product?",
        "ground_truth": "SELECT AVG((T1.ListPrice - T2.StandardCost) * 100 / T2.StandardCost) FROM ProductListPriceHistory AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID",
        "amends": [
            "Do calculate `AVG((T1.ListPrice - T2.StandardCost) * 100 / T2.StandardCost)` instead of simply `AVG(profit_percentage)` to properly compute the profit percentage formula. Do add `FROM ProductListPriceHistory AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID` instead of omitting the necessary tables and join condition. Do include the explicit join predicate `ON T1.ProductID = T2.ProductID` instead of having no join logic. The amended query now correctly calculates average profit percentage by joining the price and cost history tables with the proper mathematical formula."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(profit_percentage) FROM products;",
            "SELECT AVG((T1.ListPrice - T2.StandardCost) * 100 / T2.StandardCost) AS AverageProfitPercentage\nFROM ProductListPriceHistory AS T1 \nINNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID;"
        ],
        "rule_sql": []
    },
    "1499": {
        "db_id": "synthea",
        "question": "How many patients sought medical attention due to a second-degree burn? Describe the care plan recommended to them.",
        "ground_truth": "SELECT COUNT(DISTINCT T2.PATIENT), T2.DESCRIPTION FROM encounters AS T1 INNER JOIN careplans AS T2 ON T1.PATIENT = T2.PATIENT WHERE T2.REASONDESCRIPTION = 'Second degree burn'",
        "amends": [
            "Do select `COUNT(DISTINCT T2.PATIENT)` and `T2.DESCRIPTION` instead of `COUNT(*)` and `care_plan`. Do join `encounters AS T1` with `careplans AS T2` using `INNER JOIN` on `T1.PATIENT = T2.PATIENT` instead of querying only the `patients` table. Do filter on `T2.REASONDESCRIPTION = 'Second degree burn'` instead of `burn_degree = 'second'`. Do remove the `GROUP BY` clause instead of grouping by `care_plan`. The amended query now correctly counts distinct patients with second degree burn care plans from the joined encounters and careplans tables, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS patient_count, care_plan FROM patients WHERE burn_degree = 'second' GROUP BY care_plan;",
            "SELECT COUNT(DISTINCT T2.PATIENT), T2.DESCRIPTION\nFROM encounters AS T1\nINNER JOIN careplans AS T2 ON T1.PATIENT = T2.PATIENT\nWHERE T2.REASONDESCRIPTION = 'Second degree burn'"
        ],
        "rule_sql": []
    },
    "5661": {
        "db_id": "shipping",
        "question": "Calculate the average number of shipments that Zachery Hicks shipped in year 2017.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' THEN T1.ship_id ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE STRFTIME('%Y', T1.ship_date) = '2017'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' THEN T1.ship_id ELSE 0 END) AS REAL) * 100 / COUNT(*)` instead of `AVG(shipment_count)` to calculate a percentage rather than an average. Do join `driver AS T2` with `INNER JOIN` on `T1.driver_id = T2.driver_id` instead of querying only the shipments table. Do filter by `T2.first_name = 'Zachery' AND T2.last_name = 'Hicks'` in the CASE expression instead of `shipper_name = 'Zachery Hicks'` in WHERE. Do use `STRFTIME('%Y', T1.ship_date) = '2017'` for year filtering instead of `YEAR(shipment_date) = 2017`. The amended query now correctly calculates the percentage of shipments handled by the specific driver in 2017 rather than averaging shipment counts.",
            "Do use `T1.ship_id` in the CASE expression instead of `1` to count actual shipments instead of just occurrences. Do keep the same `INNER JOIN` on `T1.driver_id = T2.driver_id` and maintain the `WHERE` filter for year 2017 using `STRFTIME('%Y', T1.ship_date) = '2017'`. The amended query now correctly calculates the percentage of shipments handled by the specific driver rather than just counting join matches, ensuring the result reflects actual shipment volumes.",
            "Do use `T1.ship_id` in the CASE expression's THEN clause instead of the literal `1` to properly count shipments associated with the specific driver instead of just counting occurrences. The amended query now correctly calculates the percentage of shipments handled by driver Zachery Hicks in 2017 by summing actual shipment IDs rather than counting boolean matches, ensuring the result matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(shipment_count) \nFROM shipments \nWHERE shipper_name = 'Zachery Hicks' \nAND YEAR(shipment_date) = 2017",
            "SELECT \n    CAST(SUM(CASE WHEN T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentage\nFROM \n    shipment AS T1\nINNER JOIN \n    driver AS T2 ON T1.driver_id = T2.driver_id\nWHERE \n    STRFTIME('%Y', T1.ship_date) = '2017'",
            "SELECT CAST(SUM(CASE WHEN T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM shipment AS T1\nINNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id\nWHERE STRFTIME('%Y', T1.ship_date) = '2017'",
            "SELECT CAST(SUM(CASE WHEN T2.first_name = 'Zachery' AND T2.last_name = 'Hicks' THEN T1.ship_id ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM shipment AS T1\nINNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id\nWHERE STRFTIME('%Y', T1.ship_date) = '2017'"
        ],
        "rule_sql": []
    },
    "3126": {
        "db_id": "cars",
        "question": "Which country produced the car with the lowest price?",
        "ground_truth": "SELECT T3.country FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country ORDER BY T1.price ASC LIMIT 1",
        "amends": [
            "Do add joins to `price`, `production`, and `country` tables instead of querying only `cars` table. Do select `T3.country` instead of `country` to specify the table source. Do change the join structure to use `INNER JOIN production AS T2 ON T1.ID = T2.ID` and `INNER JOIN country AS T3 ON T3.origin = T2.country` instead of no joins. Do change the sort order to `ORDER BY T1.price ASC` instead of `ORDER BY price DESC` to sort ascending by the price column from the price table. The amended query now correctly joins the necessary tables to find the country associated with the lowest price vehicle."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cars ORDER BY price DESC LIMIT 1;",
            "SELECT T3.country\nFROM price AS T1\nINNER JOIN production AS T2 ON T1.ID = T2.ID\nINNER JOIN country AS T3 ON T3.origin = T2.country\nORDER BY T1.price ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1870": {
        "db_id": "soccer_2016",
        "question": "Who was the captain of the winning team in the match held on 1st June 2008?",
        "ground_truth": "SELECT T3.Player_Name FROM Player_Match AS T1 INNER JOIN Match AS T2 ON T2.Match_Id = T1.Match_Id INNER JOIN Player AS T3 ON T3.Player_Id = T1.Player_Id INNER JOIN Rolee AS T4 ON T4.Role_Id = T1.Role_Id WHERE T2.Match_Date = '2008-06-01' AND T4.Role_Desc = 'Captain' AND T2.Match_Winner = T1.Team_Id",
        "amends": [
            "Do select `T3.Player_Name` instead of `captain` from the `Player` table instead of a single table. Do join `Player_Match AS T1` instead of omitting it, then join `Match AS T2` on `T2.Match_Id = T1.Match_Id` instead of no join condition, then join `Player AS T3` on `T3.Player_Id = T1.Player_Id` instead of no player join, and join `Rolee AS T4` on `T4.Role_Id = T1.Role_Id` instead of omitting role information. Do filter with `T2.Match_Date = '2008-06-01'` instead of `date = '2008-06-01'`, add `T4.Role_Desc = 'Captain'` instead of assuming a captain column, and add `T2.Match_Winner = T1.Team_Id` instead of just `result = 'win'` to properly identify winning team captains. The amended query now correctly identifies player names who were captains on winning teams for the specified date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT captain FROM matches WHERE date = '2008-06-01' AND result = 'win';",
            "SELECT T3.Player_Name\nFROM Player_Match AS T1\nJOIN Match AS T2 ON T2.Match_Id = T1.Match_Id\nJOIN Player AS T3 ON T3.Player_Id = T1.Player_Id\nJOIN Rolee AS T4 ON T4.Role_Id = T1.Role_Id\nWHERE T2.Match_Date = '2008-06-01'\nAND T4.Role_Desc = 'Captain'\nAND T2.Match_Winner = T1.Team_Id;"
        ],
        "rule_sql": []
    },
    "4016": {
        "db_id": "public_review_platform",
        "question": "Among all the users who received the high number of compliments, what percent received the 'cute' type of compliment.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.compliment_type = 'cute' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.user_id) FROM Compliments AS T1 INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id WHERE T2.number_of_compliments = 'High'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.compliment_type = 'cute' THEN 1 ELSE 0 END)` with explicit `ELSE 0` instead of `COUNT(CASE WHEN compliment_type = 'cute' THEN 1 END)` without else clause. Do add explicit `CAST(... AS REAL)` for decimal division instead of implicit `100.0` casting. Do change from single table `users` to `INNER JOIN` between `Compliments AS T1` and `Users_Compliments AS T2` on `T1.compliment_id = T2.compliment_id` instead of no join. Do change filter to `WHERE T2.number_of_compliments = 'High'` instead of `WHERE total_compliments > 100`. Do remove `ORDER BY total_compliments DESC` and `LIMIT 10` instead of keeping them. Do reference `T2.user_id` in `COUNT(T2.user_id)` instead of `COUNT(*)`. The amended query now correctly calculates percentage using proper join relationships and explicit casting for accurate decimal results.",
            "Do place the division operation before the multiplication by 100 instead of multiplying by 100.0 after the division. Do remove the alias `percent_cute_compliments` instead of keeping it. The amended query now correctly calculates the percentage by dividing the count of cute compliments by the total user count before scaling to percentage, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 after the division instead of before it, changing `CAST(...) / COUNT(T2.user_id) * 100` to `CAST(...) * 100 / COUNT(T2.user_id)` to correctly calculate the percentage. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN compliment_type = 'cute' THEN 1 END) * 100.0 / COUNT(*)) AS percent_cute_compliments\nFROM users\nWHERE total_compliments > 100\nORDER BY total_compliments DESC\nLIMIT 10;",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.compliment_type = 'cute' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.user_id)) * 100.0 AS percent_cute_compliments\nFROM \n    Compliments AS T1\nINNER JOIN \n    Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id\nWHERE \n    T2.number_of_compliments = 'High'",
            "SELECT \n    CAST(SUM(CASE WHEN T1.compliment_type = 'cute' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.user_id) * 100\nFROM \n    Compliments AS T1\nINNER JOIN \n    Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id\nWHERE \n    T2.number_of_compliments = 'High'",
            "SELECT \n    CAST(SUM(CASE WHEN T1.compliment_type = 'cute' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.user_id) \nFROM \n    Compliments AS T1\n    INNER JOIN Users_Compliments AS T2 ON T1.compliment_id = T2.compliment_id\nWHERE \n    T2.number_of_compliments = 'High'"
        ],
        "rule_sql": []
    },
    "5113": {
        "db_id": "address",
        "question": "For the city with the most elders, what's its area code?",
        "ground_truth": "SELECT T2.area_code FROM zip_data AS T1 INNER JOIN area_code AS T2 ON T1.zip_code = T2.zip_code GROUP BY T2.area_code ORDER BY T1.over_65 DESC LIMIT 1",
        "amends": [
            "Do select `T2.area_code` from `zip_data AS T1` instead of `area_code` from `cities`. Do add `INNER JOIN area_code AS T2` on `T1.zip_code = T2.zip_code` instead of missing the join entirely. Do add `GROUP BY T2.area_code` instead of omitting grouping. Do order by `T1.over_65 DESC` instead of `COUNT(elders) DESC`. Do keep `LIMIT 1` as in the original. The amended query now correctly joins the necessary tables, groups by area code, and uses the proper elderly population column for ordering, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area_code FROM cities ORDER BY COUNT(elders) DESC LIMIT 1;",
            "SELECT T2.area_code\nFROM zip_data AS T1\nINNER JOIN area_code AS T2 ON T1.zip_code = T2.zip_code\nGROUP BY T2.area_code\nORDER BY T1.over_65 DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4573": {
        "db_id": "mental_health_survey",
        "question": "How many users, between the age 27 to 35, were surveyed in 2018?",
        "ground_truth": "SELECT T1.UserID FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T1.SurveyID = 2018 AND T2.questionid = 1 AND T1.AnswerText BETWEEN '27' AND '35'",
        "amends": [
            "Do select `T1.UserID` instead of `COUNT(*)` to return individual user identifiers rather than an aggregate count. Do use `Answer AS T1 INNER JOIN Question AS T2` instead of a single `users` table to properly join the answer and question data. Do apply the join condition `T1.QuestionID = T2.questionid` instead of no join condition to correctly relate answers to their corresponding questions. Do filter with `T1.SurveyID = 2018` instead of `survey_year = 2018` to use the correct column name for survey identification. Do add `T2.questionid = 1` to specifically target question 1 instead of no question filter. Do filter `T1.AnswerText BETWEEN '27' AND '35'` with string comparisons instead of `age BETWEEN 27 AND 35` with numeric comparisons to match the text-based answer storage format. The amended query now correctly identifies users who answered question 1 with age values between 27 and 35 in the 2018 survey."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age BETWEEN 27 AND 35 AND survey_year = 2018;",
            "SELECT T1.UserID\nFROM Answer AS T1\nINNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid\nWHERE T1.SurveyID = 2018\nAND T2.questionid = 1\nAND T1.AnswerText BETWEEN '27' AND '35'"
        ],
        "rule_sql": []
    },
    "9320": {
        "db_id": "movie_3",
        "question": "Which actor acted in the most films?",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T2.first_name, T2.last_name, SUM(T1.film_id) AS num FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id GROUP BY T2.first_name, T2.last_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do select `first_name` and `last_name` instead of `actor_id` and `film_count`. Do add `INNER JOIN` on `actor` table with `T1.actor_id = T2.actor_id` instead of omitting the join. Do use `SUM(T1.film_id)` as the aggregate instead of `COUNT(*)`. Do group by `first_name` and `last_name` instead of just `actor_id`. Do wrap the entire query in a subquery alias `T` instead of querying directly. The amended query now correctly retrieves the actor's name with their total film count and matches the RIGHT_SQL's behavior.",
            "Do use `SUM(T1.film_id)` within a subquery instead of directly in the main query, and do reference the aggregate result as `T.num` in the `ORDER BY` clause instead of the original alias `film_count`. Do wrap the entire grouped query in a subquery with alias `T` instead of having the aggregation in the main query, and do select only `T.first_name` and `T.last_name` in the outer query instead of including the aggregate column. Do maintain the same `INNER JOIN` on `T1.actor_id = T2.actor_id` and `GROUP BY T2.first_name, T2.last_name` within the subquery, and do keep the `ORDER BY T.num DESC LIMIT 1` structure to find the top result. The amended query now correctly isolates the aggregation in a subquery and references only the necessary columns in the final output, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id, COUNT(*) as film_count FROM film_actor GROUP BY actor_id ORDER BY film_count DESC LIMIT 1;",
            "SELECT T2.first_name, T2.last_name, SUM(T1.film_id) as film_count\nFROM (\n    SELECT actor_id, film_id\n    FROM film_actor\n) T1\nINNER JOIN actor T2 ON T1.actor_id = T2.actor_id\nGROUP BY T2.first_name, T2.last_name\nORDER BY film_count DESC\nLIMIT 1",
            "SELECT T.first_name, T.last_name\nFROM (\n    SELECT T2.first_name, T2.last_name, SUM(T1.film_id) AS num\n    FROM film_actor T1\n    INNER JOIN actor T2 ON T1.actor_id = T2.actor_id\n    GROUP BY T2.first_name, T2.last_name\n) T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7849": {
        "db_id": "world",
        "question": "List down the districts belong to the country headed by Adolf Ogi.",
        "ground_truth": "SELECT T2.District FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode WHERE T1.HeadOfState = 'Adolf Ogi'",
        "amends": [
            "Do join `Country` and `City` tables with `INNER JOIN` on `Code=CountryCode` instead of querying only the `countries` table. Do select `District` from the `City` table instead of `district` from the `countries` table. Do reference `HeadOfState` instead of `head_of_state` for the filter condition. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves districts from cities in countries where Adolf Ogi is head of state, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM countries WHERE head_of_state = 'Adolf Ogi';",
            "SELECT T2.District \nFROM Country T1 \nINNER JOIN City T2 ON T1.Code = T2.CountryCode \nWHERE T1.HeadOfState = 'Adolf Ogi'"
        ],
        "rule_sql": []
    },
    "7652": {
        "db_id": "hockey",
        "question": "How many teams have the same total number of postseason wins and postseason loses?",
        "ground_truth": "SELECT DISTINCT COUNT(tmID) FROM Goalies WHERE PostW = PostL",
        "amends": [
            "Do count `tmID` instead of `*` and add `DISTINCT` instead of omitting it. Do query from `Goalies` instead of `teams`. Do filter on `PostW = PostL` instead of `postseason_wins = postseason_losses`. Do remove the unnecessary table reference change while maintaining the same logical condition for counting goalies with equal postseason wins and losses.",
            "Do use `COUNT(tmID)` without `DISTINCT` instead of `COUNT(DISTINCT tmID)` to count all team IDs rather than counting distinct team IDs. Do add `DISTINCT` at the query level instead of omitting it to return only distinct count values. The amended query now correctly returns distinct count values rather than counting distinct team IDs, matching the right SQL's behavior.",
            "Do place `DISTINCT` before `COUNT` instead of inside the aggregate function, and do remove the parentheses around `COUNT(tmID)` instead of keeping them. Do maintain the `WHERE PostW = PostL` filter without changes. The amended query now correctly counts distinct team IDs where postseason wins equal losses, matching the intended behavior.",
            "Do use `DISTINCT COUNT(tmID)` instead of `COUNT(DISTINCT tmID)` to count distinct team IDs. Do keep the `WHERE PostW = PostL` filter unchanged instead of modifying it. The amended query now correctly counts distinct team IDs where post-season wins equal losses, matching the intended behavior.",
            "Do use `DISTINCT COUNT(tmID)` instead of `COUNT(DISTINCT tmID)` to count distinct team IDs. Do keep the `WHERE PostW = PostL` filter unchanged instead of modifying it. The amended query now correctly counts distinct team IDs where post wins equal post losses, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM teams \nWHERE postseason_wins = postseason_losses;",
            "SELECT COUNT(DISTINCT tmID) FROM Goalies WHERE PostW = PostL;",
            "SELECT COUNT(DISTINCT tmID) FROM Goalies WHERE PostW = PostL;",
            "SELECT COUNT(DISTINCT tmID) FROM Goalies WHERE PostW = PostL",
            "SELECT COUNT(DISTINCT tmID) FROM Goalies WHERE PostW = PostL",
            "SELECT DISTINCT COUNT(tmID) FROM Goalies WHERE PostW = PostL"
        ],
        "rule_sql": []
    },
    "8880": {
        "db_id": "cookbook",
        "question": "State the name of the optional ingredient of no.1397 recipe.",
        "ground_truth": "SELECT T1.name FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE T2.recipe_id = 1397 AND T2.optional = 'TRUE'",
        "amends": [
            "Do select `T1.name` instead of `ingredient_name` and use table aliases. Do join `Ingredient AS T1` with `Quantity AS T2` on `T1.ingredient_id = T2.ingredient_id` instead of querying a single table. Do filter on `T2.recipe_id = 1397` instead of `recipe_id = 1397` to reference the correct table. Do filter on `T2.optional = 'TRUE'` instead of `optional = 'yes'` to use the correct boolean representation. The amended query now correctly joins the ingredient and quantity tables to retrieve ingredient names for a specific recipe with optional ingredients, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ingredient_name FROM ingredients WHERE recipe_id = 1397 AND optional = 'yes';",
            "SELECT T1.name FROM Ingredient AS T1 JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE T2.recipe_id = 1397 AND T2.optional = 'TRUE'"
        ],
        "rule_sql": []
    },
    "2453": {
        "db_id": "superstore",
        "question": "Who is the customer with an order shipped on March 5, 2013, in the eastern region?",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.`Ship Date` = '2013-03-05'",
        "amends": [
            "Do select `T2.Customer Name` instead of `c.customer_name`. Do use `DISTINCT` instead of omitting it. Do join `east_superstore AS T1` instead of `customers c` and `orders o`. Do join `people AS T2` instead of `customers c`. Do use `INNER JOIN` on `T1.Customer ID = T2.Customer ID` instead of separate joins on `c.customer_id = o.customer_id` and `c.region_id = r.region_id`. Do filter on `T1.Ship Date = '2013-03-05'` instead of `o.ship_date = '2013-03-05'`. Do remove the `r.region_name = 'Eastern'` filter instead of keeping it. The amended query now correctly retrieves distinct customer names from the specified tables with proper join conditions and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.customer_name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN regions r ON c.region_id = r.region_id\nWHERE o.ship_date = '2013-03-05' \nAND r.region_name = 'Eastern';",
            "SELECT DISTINCT T2.\"Customer Name\"\nFROM east_superstore AS T1\nINNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nWHERE T1.\"Ship Date\" = '2013-03-05'"
        ],
        "rule_sql": []
    },
    "9128": {
        "db_id": "movie_3",
        "question": "For how many times has the customer RUTH MARTINEZ rented a film?",
        "ground_truth": "SELECT COUNT(T2.rental_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ'",
        "amends": [
            "Do add `INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id` instead of querying only the customer table. Do change the SELECT list to `COUNT(T2.rental_id)` instead of `COUNT(*)` to count rental records rather than customer records. Do add table alias `T1` for customer and reference columns as `T1.first_name` and `T1.last_name` instead of unqualified column names. The amended query now correctly counts rentals for the specified customer instead of just counting customer records, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customer WHERE first_name = 'RUTH' AND last_name = 'MARTINEZ';",
            "SELECT COUNT(T2.rental_id) \nFROM customer AS T1 \nINNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id \nWHERE T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ'"
        ],
        "rule_sql": []
    },
    "5687": {
        "db_id": "language_corpus",
        "question": "What is the title of Catalan language wikipedia page with revision page id '16203226'?",
        "ground_truth": "SELECT title FROM pages WHERE revision = 16203226",
        "amends": [
            "Do query the `pages` table instead of the `wikipedia` table. Do filter on `revision = 16203226` instead of `language = 'Catalan' AND page_id = '16203226'`. Do remove the language filter condition instead of including it. The amended query now correctly retrieves titles from the pages table based on revision number rather than incorrectly filtering by language and page_id in a non-existent table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM wikipedia WHERE language = 'Catalan' AND page_id = '16203226';",
            "SELECT title FROM pages WHERE revision = 16203226;"
        ],
        "rule_sql": []
    },
    "3425": {
        "db_id": "video_games",
        "question": "Which publisher published Overwatch?",
        "ground_truth": "SELECT T3.publisher_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE T1.game_name = 'Overwatch'",
        "amends": [
            "Do select `T3.publisher_name` instead of `title` from the result set. Do use `game AS T1` joined with `game_publisher AS T2` on `T1.id = T2.game_id` instead of querying only the `publishers` table. Do add a second join to `publisher AS T3` on `T2.publisher_id = T3.id` instead of omitting the necessary table relationships. Do filter on `T1.game_name = 'Overwatch'` instead of `game = 'Overwatch'` to use the correct column name from the proper table. The amended query now correctly navigates the relational schema through proper joins to retrieve publisher information for the specified game, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM publishers WHERE game = 'Overwatch';",
            "SELECT T3.publisher_name \nFROM game AS T1 \nJOIN game_publisher AS T2 ON T1.id = T2.game_id \nJOIN publisher AS T3 ON T2.publisher_id = T3.id \nWHERE T1.game_name = 'Overwatch'"
        ],
        "rule_sql": []
    },
    "4835": {
        "db_id": "legislator",
        "question": "Provide the google entity ID of the senators in New York.",
        "ground_truth": "SELECT T1.google_entity_id_id FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'sen' AND T2.state = 'NY'",
        "amends": [
            "Do select `T1.google_entity_id_id` instead of `google_entity_id`. Do use `FROM historical AS T1 INNER JOIN historical-terms AS T2 ON T1.bioguide_id = T2.bioguide` instead of `FROM senators`. Do add join condition `T1.bioguide_id = T2.bioguide` instead of omitting it. Do use filter `T2.type = 'sen' AND T2.state = 'NY'` instead of `state = 'New York'`. The amended query now correctly joins historical data with term information to identify senators from New York using proper state abbreviations and type filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT google_entity_id FROM senators WHERE state = 'New York';",
            "SELECT T1.google_entity_id_id FROM historical AS T1 INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'sen' AND T2.state = 'NY'"
        ],
        "rule_sql": []
    },
    "1501": {
        "db_id": "synthea",
        "question": "How many interactions did Lorri Simons have with medical professionals between 2010 and 2017? What percentage of encounters are attributed to prenatal visits?",
        "ground_truth": "SELECT COUNT(T1.patient) , CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Prenatal visit' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient) FROM patients AS T1 INNER JOIN encounters AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Lorri' AND T1.last = 'Simonis' AND strftime('%Y', T2.DATE) BETWEEN '2010' AND '2017'",
        "amends": [
            "Do use `COUNT(T1.patient)` instead of `COUNT(*)` to count specific patient records rather than all rows. Do join `patients AS T1` with `encounters AS T2` on `T1.patient = T2.PATIENT` instead of querying a single `interactions` table. Do filter on `T1.first = 'Lorri'` and `T1.last = 'Simonis'` instead of `patient_name = 'Lorri Simons'` to match the correct patient name format. Do use `strftime('%Y', T2.DATE)` for year extraction instead of `YEAR(interaction_date)` to handle SQLite date formatting. Do calculate the percentage using `CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Prenatal visit' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.patient)` instead of the subquery approach with `interaction_type = 'prenatal'`. Do remove the redundant subquery and instead perform the prenatal count calculation directly in the main SELECT clause using conditional aggregation. The amended query now correctly joins patient and encounter data, uses proper patient identification, and calculates prenatal percentages through conditional sum rather than subqueries, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS total_interactions,\n    (SELECT COUNT(*) FROM interactions WHERE interaction_type = 'prenatal' AND YEAR(interaction_date) BETWEEN 2010 AND 2017) * 100.0 / COUNT(*) AS prenatal_percentage\nFROM interactions \nWHERE patient_name = 'Lorri Simons' \nAND YEAR(interaction_date) BETWEEN 2010 AND 2017;",
            "SELECT \n    COUNT(T2.PATIENT) AS total_interactions,\n    CAST(SUM(CASE WHEN T2.DESCRIPTION = 'Prenatal visit' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.PATIENT) AS prenatal_percentage\nFROM \n    patients AS T1\nJOIN \n    encounters AS T2 ON T1.patient = T2.PATIENT\nWHERE \n    T1.first = 'Lorri' \n    AND T1.last = 'Simonis'\n    AND strftime('%Y', T2.DATE) BETWEEN '2010' AND '2017'"
        ],
        "rule_sql": []
    },
    "8188": {
        "db_id": "sales_in_weather",
        "question": "What is the earliest sunrise recorded in the stations with no more than 1 store in February 2012?",
        "ground_truth": "SELECT T1.station_nbr FROM relation AS T1 INNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr WHERE sunrise IS NOT NULL AND T2.`date` LIKE '%2012-02%' AND T1.station_nbr IN ( SELECT station_nbr FROM relation GROUP BY station_nbr HAVING COUNT(store_nbr) = 1 ) ORDER BY sunrise LIMIT 1",
        "amends": [
            "Do select `T1.station_nbr` instead of `MIN(sunrise)`. Do use `FROM relation AS T1 INNER JOIN weather AS T2` instead of `FROM stations`. Do add join condition `ON T1.station_nbr = T2.station_nbr` instead of omitting it. Do add filter `sunrise IS NOT NULL` instead of omitting it. Do use `T2.date LIKE '%2012-02%'` instead of `month = 2 AND year = 2012`. Do add subquery `T1.station_nbr IN (SELECT station_nbr FROM relation GROUP BY station_nbr HAVING COUNT(store_nbr) = 1)` instead of `stores <= 1`. Do add `ORDER BY sunrise LIMIT 1` instead of omitting it. The amended query now correctly identifies stations with exactly one store and finds the earliest sunrise in February 2012, matching the RIGHT_SQL's behavior.",
            "Do select `T1.station_nbr` instead of `MIN(T2.sunrise)` in the SELECT list. Do remove the aggregation function `MIN()` instead of keeping it. Do reference `sunrise` directly in ORDER BY instead of ordering by the aggregated result. Do use backticks for the date column `T2.\"date\"` instead of unquoted `T2.date` to handle reserved keywords properly. The amended query now correctly returns station numbers rather than aggregated sunrise times while maintaining the same filtering logic and ordering behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(sunrise) FROM stations WHERE stores <= 1 AND month = 2 AND year = 2012;",
            "SELECT MIN(T2.sunrise) \nFROM relation AS T1 \nINNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr \nWHERE T2.sunrise IS NOT NULL \nAND T2.date LIKE '%2012-02%' \nAND T1.station_nbr IN (\n    SELECT station_nbr \n    FROM relation \n    GROUP BY station_nbr \n    HAVING COUNT(store_nbr) = 1\n)\nORDER BY sunrise \nLIMIT 1",
            "SELECT T1.station_nbr\nFROM relation AS T1\nINNER JOIN weather AS T2 ON T1.station_nbr = T2.station_nbr\nWHERE T2.sunrise IS NOT NULL\nAND T2.\"date\" LIKE '%2012-02%'\nAND T1.station_nbr IN (\n    SELECT station_nbr \n    FROM relation \n    GROUP BY station_nbr \n    HAVING COUNT(store_nbr) = 1\n)\nORDER BY T2.sunrise\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8240": {
        "db_id": "mondial_geo",
        "question": "How much does the gross domestic products goes to the industry sector for Singapore?",
        "ground_truth": "SELECT T2.GDP * T2.Industry FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Singapore'",
        "amends": [
            "Do select `T2.GDP * T2.Industry` instead of `gdp_value`. Do use `FROM country AS T1 INNER JOIN economy AS T2` instead of `FROM gdp_data`. Do apply join condition `ON T1.Code = T2.Country` instead of no join. Do filter with `WHERE T1.Name = 'Singapore'` instead of `WHERE country = 'Singapore' AND sector = 'industry'`. The amended query now correctly joins country and economy tables to calculate industrial GDP for Singapore."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gdp_value FROM gdp_data WHERE country = 'Singapore' AND sector = 'industry';",
            "SELECT T2.GDP * T2.Industry AS industrial_gdp\nFROM country AS T1\nINNER JOIN economy AS T2 ON T1.Code = T2.Country\nWHERE T1.Name = 'Singapore';"
        ],
        "rule_sql": []
    },
    "5890": {
        "db_id": "airline",
        "question": "Provide the origin of the flight that has the shortest actual elapsed time.",
        "ground_truth": "SELECT ORIGIN FROM Airlines ORDER BY ACTUAL_ELAPSED_TIME ASC LIMIT 1",
        "amends": [
            "Do reference the `Airlines` table instead of the `flights` table. Do use uppercase column names `ORIGIN` and `ACTUAL_ELAPSED_TIME` instead of lowercase `origin` and `actual_elapsed_time`. The amended query now correctly references the intended table and columns while maintaining the same ordering and limiting behavior.",
            "Do use `ORDER BY ACTUAL_ELAPSED_TIME ASC` instead of a subquery with `MIN(ACTUAL_ELAPSED_TIME)` to find the minimum value. Do remove the subquery entirely instead of using it to filter for the minimum elapsed time. Do maintain the `LIMIT 1` clause instead of changing it, as both queries correctly return only one row. The amended query now correctly identifies the origin with the minimum actual elapsed time by sorting and limiting, avoiding potential issues with multiple rows having the same minimum value that the subquery approach might encounter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT origin FROM flights ORDER BY actual_elapsed_time ASC LIMIT 1;",
            "SELECT ORIGIN FROM Airlines WHERE ACTUAL_ELAPSED_TIME = (SELECT MIN(ACTUAL_ELAPSED_TIME) FROM Airlines) LIMIT 1;",
            "SELECT ORIGIN FROM Airlines ORDER BY ACTUAL_ELAPSED_TIME ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8781": {
        "db_id": "food_inspection",
        "question": "What is the description of the low risk violation of Tiramisu Kitchen on 2014/1/14?",
        "ground_truth": "SELECT T1.description FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.`date` = '2014-01-14' AND T2.name = 'Tiramisu Kitchen' AND T1.risk_category = 'Low Risk'",
        "amends": [
            "Do reference `T1.description` with table alias instead of just `description`. Do join `businesses AS T2` instead of querying only the `violations` table. Do use `INNER JOIN` on `T1.business_id = T2.business_id` instead of filtering by restaurant name directly. Do filter by `T1.date = '2014-01-14'` with ISO date format instead of '2014/1/14'. Do filter by `T2.name = 'Tiramisu Kitchen'` instead of `restaurant_name`. Do filter by `T1.risk_category = 'Low Risk'` with proper case instead of `risk_level = 'low'`. The amended query now correctly joins business information and uses proper column names and date format to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM violations WHERE restaurant_name = 'Tiramisu Kitchen' AND risk_level = 'low' AND date = '2014/1/14';",
            "SELECT T1.description \nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T2.name = 'Tiramisu Kitchen'\nAND T1.date = '2014-01-14'\nAND T1.risk_category = 'Low Risk'"
        ],
        "rule_sql": []
    },
    "3656": {
        "db_id": "authors",
        "question": "How many papers are preprint or not published?",
        "ground_truth": "SELECT COUNT(Id) FROM Paper WHERE Year = 0 OR (ConferenceId = 0 AND JournalId = 0)",
        "amends": [
            "Do count `Id` instead of `*` to avoid counting NULL values. Do reference table `Paper` instead of `papers` to use the correct table name. Do filter on `Year = 0` instead of `status = 'preprint'` to use the appropriate condition for identifying unpublished papers. Do add the compound condition `(ConferenceId = 0 AND JournalId = 0)` instead of `status != 'published'` to properly identify papers not associated with conferences or journals. The amended query now correctly counts unpublished papers by checking for zero year and missing conference/journal associations, matching the intended behavior.",
            "Do use `OR` instead of `AND` to combine the conditions, changing the logical operator from requiring all conditions to be true simultaneously to allowing either the year condition or the combined conference/journal condition to be true. Specifically, do `Year = 0 OR (ConferenceId = 0 AND JournalId = 0)` instead of `Year = 0 AND ConferenceId = 0 AND JournalId = 0`, which fixes the logic to properly count papers where either the year is zero or both conference and journal IDs are zero, rather than requiring all three conditions to be met simultaneously. The amended query now correctly matches the intended behavior of counting papers with year zero or those missing both conference and journal associations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE status = 'preprint' OR status != 'published';",
            "SELECT COUNT(Id) FROM Paper WHERE Year = 0 AND ConferenceId = 0 AND JournalId = 0;",
            "SELECT COUNT(Id) FROM Paper WHERE Year = 0 OR (ConferenceId = 0 AND JournalId = 0)"
        ],
        "rule_sql": []
    },
    "7341": {
        "db_id": "works_cycles",
        "question": "What categories of offers qualify for group discounts for resellers?",
        "ground_truth": "SELECT Type FROM SpecialOffer WHERE Category = 'Reseller'",
        "amends": [
            "Do select `Type` instead of `category` and use table `SpecialOffer` instead of `offers`. Do filter on `Category = 'Reseller'` instead of `discount_type = 'group' AND reseller_status = 'qualified'`. The amended query now correctly retrieves the Type column from the SpecialOffer table filtered by Reseller category, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM offers WHERE discount_type = 'group' AND reseller_status = 'qualified'",
            "SELECT Type FROM SpecialOffer WHERE Category = 'Reseller';"
        ],
        "rule_sql": []
    },
    "7799": {
        "db_id": "hockey",
        "question": "For the goalie who had the most shutouts in 2010, what's his catching hand?",
        "ground_truth": "SELECT T2.shootCatch FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.year = 2010 GROUP BY T2.shootCatch ORDER BY SUM(T1.SHO) DESC LIMIT 1",
        "amends": [
            "Do add `INNER JOIN Master AS T2 ON T1.playerID = T2.playerID` instead of querying only the `goalies` table. Do change the SELECT list to `T2.shootCatch` instead of `catching_hand`. Do add `GROUP BY T2.shootCatch` instead of selecting individual records. Do change the ORDER BY to `SUM(T1.SHO) DESC` instead of `shutouts DESC` to aggregate shutouts by catching hand. Do change the WHERE filter to `T1.year = 2010` with proper table aliasing instead of just `year = 2010`. The amended query now correctly aggregates shutouts by catching hand for the 2010 season and returns the catching hand with the highest total shutouts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT catching_hand \nFROM goalies \nWHERE year = 2010 \nORDER BY shutouts DESC \nLIMIT 1;",
            "SELECT T2.shootCatch\nFROM Goalies AS T1\nINNER JOIN Master AS T2 ON T1.playerID = T2.playerID\nWHERE T1.year = 2010\nGROUP BY T2.shootCatch\nORDER BY SUM(T1.SHO) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5207": {
        "db_id": "address",
        "question": "Give the country and area code of the city with zip code 1116.",
        "ground_truth": "SELECT T2.county, T1.area_code FROM area_code AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T1.zip_code = 1116",
        "amends": [
            "Do select `T2.county` and `T1.area_code` instead of `country` and `area_code` without table aliases. Do add `INNER JOIN` between `area_code AS T1` and `country AS T2` instead of querying only `cities` table. Do use join condition `T1.zip_code = T2.zip_code` instead of missing join predicate. Do use numeric comparison `T1.zip_code = 1116` instead of string literal `'1116'` for the WHERE filter. The amended query now correctly joins tables and uses proper data types for comparison, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, area_code FROM cities WHERE zip_code = '1116';",
            "SELECT T2.county, T1.area_code FROM area_code AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T1.zip_code = 1116"
        ],
        "rule_sql": []
    },
    "7709": {
        "db_id": "hockey",
        "question": "How many years were there after Don Waddell retired and became a coach in NHL?",
        "ground_truth": "SELECT MAX(T2.year) - MIN(T2.year) FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE T1.firstName = 'Don' AND T1.lastName = 'Waddell'",
        "amends": [
            "Do use `MAX(T2.year) - MIN(T2.year)` instead of `COUNT(DISTINCT year)` to calculate the year span instead of counting distinct years. Do join `Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID` instead of querying `nhl_coaches` alone with a subquery. Do filter on `T1.firstName = 'Don' AND T1.lastName = 'Waddell'` instead of `name = 'Don Waddell' AND position = 'Coach'` to properly match the coach by first and last name. Do remove the subquery condition `year > (SELECT MAX(year) FROM nhl_players WHERE name = 'Don Waddell')` instead of keeping it, as the right query calculates the full coaching tenure span without filtering years. The amended query now correctly calculates Don Waddell's coaching duration by joining coach metadata with coaching records and computing the year range difference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT year) \nFROM nhl_coaches \nWHERE name = 'Don Waddell' \nAND position = 'Coach' \nAND year > (SELECT MAX(year) FROM nhl_players WHERE name = 'Don Waddell');",
            "SELECT MAX(T2.year) - MIN(T2.year) AS coaching_years_span\nFROM Master AS T1\nINNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID\nWHERE T1.firstName = 'Don' AND T1.lastName = 'Waddell';"
        ],
        "rule_sql": []
    },
    "7432": {
        "db_id": "works_cycles",
        "question": "What is the average pay rate of the employees who worked in the Engineering Departmentin 2007?",
        "ground_truth": "SELECT AVG(T3.Rate) FROM EmployeeDepartmentHistory AS T1 INNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID INNER JOIN EmployeePayHistory AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T2.Name = 'Engineering' AND STRFTIME('%Y', EndDate) > '2007' AND STRFTIME('%Y', T1.StartDate) < '2007'",
        "amends": [
            "Do use explicit table aliases `T3.Rate` instead of the ambiguous `pay_rate`. Do join `EmployeeDepartmentHistory AS T1` and `Department AS T2` on `T1.DepartmentID = T2.DepartmentID` instead of missing these table sources entirely. Do add an additional join to `EmployeePayHistory AS T3` on `T1.BusinessEntityID = T3.BusinessEntityID` instead of omitting this relationship. Do filter on `T2.Name = 'Engineering'` instead of the generic `department = 'Engineering'`. Do use date functions `STRFTIME('%Y', EndDate) > '2007'` and `STRFTIME('%Y', T1.StartDate) < '2007'` for proper date range filtering instead of the incorrect `year = 2007` filter. The amended query now correctly calculates the average pay rate for engineering department employees active during 2007 by properly joining the relevant tables and using accurate date-based filtering.",
            "Do remove the alias `average_pay_rate` instead of keeping it. Do change the join syntax to explicit `INNER JOIN` instead of implicit `JOIN`. Do change the date filter condition to `STRFTIME('%Y', EndDate) > '2007'` instead of `T1.EndDate IS NULL OR STRFTIME('%Y', T1.EndDate) >= '2007'`. Do change the start date filter to `STRFTIME('%Y', T1.StartDate) < '2007'` instead of `STRFTIME('%Y', T1.StartDate) <= '2007'`. The amended query now correctly filters for employees who started before 2007 and ended after 2007 in the Engineering department, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(pay_rate) FROM employees WHERE department = 'Engineering' AND year = 2007;",
            "SELECT AVG(T3.Rate) AS average_pay_rate\nFROM EmployeeDepartmentHistory AS T1\nJOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID\nJOIN EmployeePayHistory AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID\nWHERE T2.Name = 'Engineering'\nAND STRFTIME('%Y', T1.StartDate) <= '2007'\nAND (T1.EndDate IS NULL OR STRFTIME('%Y', T1.EndDate) >= '2007');",
            "SELECT AVG(T3.Rate) \nFROM EmployeeDepartmentHistory AS T1\nINNER JOIN Department AS T2 ON T1.DepartmentID = T2.DepartmentID\nINNER JOIN EmployeePayHistory AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID\nWHERE T2.Name = 'Engineering'\nAND STRFTIME('%Y', T1.StartDate) < '2007'\nAND (T1.EndDate IS NULL OR STRFTIME('%Y', T1.EndDate) > '2007')"
        ],
        "rule_sql": []
    },
    "1321": {
        "db_id": "law_episode",
        "question": "Give me the years and episode IDs in which Constantine Makris was the winner of the Television Silver Gavel Award at the American Bar Association Silver Gavel Awards for Media and the Arts for two consecutive years.",
        "ground_truth": "SELECT t3.years, t3.episode_id FROM ( SELECT DISTINCT T2.year AS years, T2.episode_id, row_number() OVER (PARTITION BY T2.episode_id ORDER BY T2.year) AS rm FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id WHERE T2.award = 'Television' AND T2.award_category = 'Silver Gavel Award' AND T1.name = 'Constantine Makris' AND T2.result = 'Winner' AND T2.organization = 'American Bar Association Silver Gavel Awards for Media and the Arts' ) AS T3 GROUP BY t3.episode_id HAVING COUNT(t3.years - t3.rm) >= 2",
        "amends": [
            "Do use `t3.years` and `t3.episode_id` instead of `year` and `episode_id` from a subquery instead of directly from the awards table. Do add a subquery with `DISTINCT T2.year AS years, T2.episode_id` instead of selecting directly from the base table. Do use `INNER JOIN Person AS T1 ON T1.person_id = T2.person_id` instead of querying only the awards table without person joins. Do change the filter to `T2.award = 'Television' AND T2.award_category = 'Silver Gavel Award'` instead of `award_name = 'Television Silver Gavel Award'`. Do add `T1.name = 'Constantine Makris'` and `T2.result = 'Winner'` conditions instead of just `winner = 'Constantine Makris'`. Do add `row_number() OVER (PARTITION BY T2.episode_id ORDER BY T2.year) AS rm` window function instead of simple ordering. Do move to `GROUP BY t3.episode_id HAVING COUNT(t3.years - t3.rm) >= 2` instead of `ORDER BY year DESC LIMIT 2` to find episodes with at least two award years. The amended query now correctly identifies episodes with multiple award years for the specified person and award criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, episode_id \nFROM awards \nWHERE winner = 'Constantine Makris' \nAND award_name = 'Television Silver Gavel Award' \nAND organization = 'American Bar Association Silver Gavel Awards for Media and the Arts' \nORDER BY year DESC \nLIMIT 2;",
            "WITH AwardYears AS (\n    SELECT DISTINCT \n        T2.year AS years, \n        T2.episode_id,\n        row_number() OVER (PARTITION BY T2.episode_id ORDER BY T2.year) AS rm\n    FROM Award AS T2\n    INNER JOIN Person AS T1 ON T1.person_id = T2.person_id\n    WHERE T2.award = 'Television' \n      AND T2.award_category = 'Silver Gavel Award'\n      AND T1.name = 'Constantine Makris'\n      AND T2.result = 'Winner'\n)\nSELECT t3.years, t3.episode_id\nFROM AwardYears t3\nGROUP BY t3.episode_id\nHAVING COUNT(t3.years - t3.rm) >= 2\nORDER BY t3.years;"
        ],
        "rule_sql": []
    },
    "3446": {
        "db_id": "video_games",
        "question": "Calculate the percentage of games published by 'Brash Entertainment'?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.publisher_name = 'Brash Entertainment' THEN T2.game_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.game_id) FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join `publisher AS T1` with `game_publisher AS T2` on `T1.id = T2.publisher_id` instead of querying only the `games` table. Do calculate the percentage using `COUNT(CASE WHEN T1.publisher_name = 'Brash Entertainment' THEN T2.game_id ELSE NULL END)` divided by `COUNT(T2.game_id)` instead of counting all games and filtering by publisher. Do explicitly `CAST` the result to `REAL` instead of using decimal multiplication. Do reference `publisher_name` from the publisher table instead of `publisher` from the games table. The amended query now correctly calculates the percentage of games published by Brash Entertainment relative to all games in the joined dataset."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM games)) AS percentage FROM games WHERE publisher = 'Brash Entertainment';",
            "SELECT \n    CAST(COUNT(CASE WHEN T1.publisher_name = 'Brash Entertainment' THEN T2.game_id ELSE NULL END) AS REAL) / \n    COUNT(T2.game_id) * 100.0 AS percentage\nFROM \n    publisher AS T1\nJOIN \n    game_publisher AS T2 ON T1.id = T2.publisher_id"
        ],
        "rule_sql": []
    },
    "6929": {
        "db_id": "ice_hockey_draft",
        "question": "What is the weight in pounds of the heaviest player?",
        "ground_truth": "SELECT MAX(T2.weight_in_lbs) FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id",
        "amends": [
            "Do specify the full table source by joining `PlayerInfo AS T1` with `weight_info AS T2` on `T1.weight = T2.weight_id` instead of querying only the `players` table. Do reference the correct column `T2.weight_in_lbs` for the MAX aggregation instead of the ambiguous `weight` column. Do use an explicit `INNER JOIN` instead of assuming a single table structure. The amended query now correctly retrieves the maximum weight value from the joined weight information table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM players;",
            "SELECT MAX(T2.weight_in_lbs) AS max_weight_in_lbs\nFROM PlayerInfo AS T1\nINNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id;"
        ],
        "rule_sql": []
    },
    "8886": {
        "db_id": "cookbook",
        "question": "How much Vitamin A is in Sherry beef?",
        "ground_truth": "SELECT T2.vitamin_a FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Sherried Beef'",
        "amends": [
            "Do select `vitamin_a` from `Nutrition` table instead of `vitamin_c` from `foods` table. Do join `Recipe` table with `Nutrition` table using `INNER JOIN` on `recipe_id` instead of querying a single `foods` table. Do filter on `title = 'Sherried Beef'` instead of `name = 'Sherry beef'` to match the correct column name and spelling. The amended query now correctly retrieves vitamin A data from the Nutrition table by joining with the Recipe table and filtering on the recipe title, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vitamin_c FROM foods WHERE name = 'Sherry beef'",
            "SELECT n.vitamin_a FROM Nutrition n INNER JOIN Recipe r ON n.recipe_id = r.recipe_id WHERE r.title = 'Sherried Beef'"
        ],
        "rule_sql": []
    },
    "6997": {
        "db_id": "ice_hockey_draft",
        "question": "What is the percentage of Swedish players in playoffs games in the 1997 - 2000 season?",
        "ground_truth": "SELECT DISTINCT CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID ELSE NULL END) OVER (PARTITION BY T2.SEASON) AS REAL) * 100 / COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000')",
        "amends": [
            "Do use `DISTINCT` at the query level instead of omitting it. Do calculate percentages using window functions with `OVER (PARTITION BY T2.SEASON)` instead of simple aggregates. Do reference columns `T1.nation` and `T1.ELITEID` instead of `p.nationality` and `p.player_id`. Do join table `SeasonStatus AS T2` instead of `games g` and `game_stats gs`. Do use `INNER JOIN` on `T1.ELITEID = T2.ELITEID` instead of chained joins on player_id and game_id. Do filter with `T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000')` instead of `g.season BETWEEN 1997 AND 2000` and remove the `game_type = 'Playoffs'` condition. Do add explicit `CAST` to `REAL` instead of implicit conversion. Do handle NULL values with `ELSE NULL` in the CASE expression instead of relying on COUNT(DISTINCT). The amended query now correctly calculates Swedish player percentages per season using the appropriate schema and window functions.",
            "Do use window functions with `OVER (PARTITION BY T2.SEASON)` instead of `GROUP BY T2.SEASON` for both counts. Do remove `DISTINCT` from the count expressions instead of keeping `COUNT(DISTINCT ...)`. Do add `DISTINCT` at the query level instead of omitting it to return unique rows. Do remove the explicit `ELSE NULL` from the CASE statement instead of including it since it's redundant. Do remove the `AND T2.GAMETYPE = 'Playoffs'` filter from the WHERE clause instead of keeping it. Do remove the ORDER BY clause instead of including it since window functions handle the partitioning. Do use integer division with `/` instead of floating-point division with `* 100.0 /` for the percentage calculation. The amended query now correctly calculates the percentage of Swedish players per season without the playoffs filter and uses window functions for partitioned calculations.",
            "Do remove the explicit `ELSE NULL` from the `CASE` expression instead of including it, as it's redundant since NULL is the default. Do change the division order to `* 100 / COUNT` instead of `/ COUNT * 100` to ensure correct mathematical precedence. Do remove the column alias `percentage_swedish_players` instead of keeping it for a cleaner output. Do remove the explicit `DISTINCT` keyword instead of including it since window functions with PARTITION BY already produce distinct results per season. The amended query now correctly calculates the percentage without redundant syntax while maintaining the same mathematical result.",
            "Do remove the `DISTINCT` keyword instead of keeping it, as the window functions already produce distinct results per season. Do change the case expression to count `T1.ELITEID` when `nation = 'Sweden'` instead of counting 1s, ensuring proper aggregation. Do add explicit `CAST` to `REAL` instead of relying on implicit conversion, preventing integer division issues. Do remove the column alias `percentage` instead of including it, as the right query returns an unnamed expression. Do maintain the same `INNER JOIN` on `T1.ELITEID = T2.ELITEID` and `WHERE` filter on `T2.SEASON` values without changes. The amended query now correctly calculates the percentage of Swedish players per season using proper counting and real number division to match the right SQL's behavior.",
            "Do remove the explicit `SEASON` column from the SELECT list instead of including it, as the window function already partitions by this column. Do add `ELSE NULL` to the CASE expression instead of omitting it, ensuring proper NULL handling for non-Swedish players. Do remove the alias `percentage` instead of keeping it, as the RIGHT_SQL returns an unnamed expression. The amended query now correctly calculates the percentage of Swedish players per season without redundant output columns and with proper NULL semantics in the CASE expression, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN p.nationality = 'Sweden' THEN p.player_id END) * 100.0 / COUNT(DISTINCT p.player_id)) AS percentage_swedish_players\nFROM \n    players p\nJOIN \n    game_stats gs ON p.player_id = gs.player_id\nJOIN \n    games g ON gs.game_id = g.game_id\nWHERE \n    g.season BETWEEN 1997 AND 2000\n    AND g.game_type = 'Playoffs';",
            "SELECT \n    T2.SEASON,\n    CAST(COUNT(DISTINCT CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID ELSE NULL END) AS REAL) * 100.0 / COUNT(DISTINCT T1.ELITEID) AS percentage_swedish_players\nFROM \n    PlayerInfo AS T1\nINNER JOIN \n    SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID\nWHERE \n    T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000')\n    AND T2.GAMETYPE = 'Playoffs'\nGROUP BY \n    T2.SEASON\nORDER BY \n    T2.SEASON;",
            "SELECT DISTINCT\n    T2.SEASON,\n    CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID END) OVER (PARTITION BY T2.SEASON) AS REAL) / \n    CAST(COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON) AS REAL) * 100 AS percentage_swedish_players\nFROM \n    PlayerInfo T1\nINNER JOIN \n    SeasonStatus T2 ON T1.ELITEID = T2.ELITEID\nWHERE \n    T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000');",
            "SELECT DISTINCT\n    T2.SEASON,\n    (SUM(CASE WHEN T1.nation = 'Sweden' THEN 1 ELSE 0 END) OVER (PARTITION BY T2.SEASON) * 100 / \n     COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON)) AS percentage\nFROM \n    PlayerInfo T1\nINNER JOIN \n    SeasonStatus T2 ON T1.ELITEID = T2.ELITEID\nWHERE \n    T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000');",
            "SELECT DISTINCT\n    T2.SEASON,\n    CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID END) OVER (PARTITION BY T2.SEASON) AS REAL) * 100 / \n    COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON) AS percentage\nFROM \n    PlayerInfo T1\nINNER JOIN \n    SeasonStatus T2 ON T1.ELITEID = T2.ELITEID\nWHERE \n    T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000');",
            "SELECT DISTINCT \n    CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T1.ELITEID ELSE NULL END) OVER (PARTITION BY T2.SEASON) AS REAL) * 100 / \n    COUNT(T1.ELITEID) OVER (PARTITION BY T2.SEASON) AS percentage\nFROM PlayerInfo T1\nINNER JOIN SeasonStatus T2 ON T1.ELITEID = T2.ELITEID\nWHERE T2.SEASON IN ('1997-1998', '1998-1999', '1999-2000');"
        ],
        "rule_sql": []
    },
    "5728": {
        "db_id": "language_corpus",
        "question": "Calculate the percentage of pages that have 1500 different words.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN words = 1500 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(page) FROM pages WHERE words > 300 LIMIT 3",
        "amends": [
            "Do use `COUNT(CASE WHEN words = 1500 THEN 1 ELSE NULL END)` instead of `COUNT(*)` with a `WHERE word_count = 1500` filter. Do reference column `words` instead of `word_count` for the condition. Do add a `WHERE words > 300` filter instead of omitting it. Do use `COUNT(page)` instead of a subquery `(SELECT COUNT(*) FROM pages)` for the denominator. Do cast the result to `REAL` instead of using `100.0` for implicit casting. Do add `LIMIT 3` instead of omitting a row limit. The amended query now correctly calculates the percentage of pages with exactly 1500 words among pages with more than 300 words, returning only the top 3 results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM pages)) AS percentage\nFROM pages\nWHERE word_count = 1500;",
            "SELECT \n    CAST(COUNT(CASE WHEN words = 1500 THEN 1 ELSE NULL END) AS REAL) / COUNT(page) * 100 AS percentage\nFROM pages\nWHERE words > 300\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "8821": {
        "db_id": "food_inspection",
        "question": "Which establishment has the highest number of inspections done? Give the name of the establishment and calculate for its average score per inspection.",
        "ground_truth": "SELECT T2.name, AVG(T1.score) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id GROUP BY T2.name ORDER BY COUNT(T2.business_id) DESC LIMIT 1",
        "amends": [
            "Do join `businesses` as `T2` instead of querying only `inspections` table. Do use `INNER JOIN` on `T1.business_id = T2.business_id` instead of no join condition. Do select `T2.name` instead of `establishment_name`. Do aggregate `AVG(T1.score)` instead of `AVG(score)`. Do group by `T2.name` instead of `establishment_name`. Do order by `COUNT(T2.business_id)` instead of `inspection_count`. The amended query now correctly joins business data and calculates average scores per business name while maintaining the top result by inspection count behavior.",
            "Do remove `COUNT(T2.business_id) as inspection_count` from the SELECT list instead of including it, as this aggregate function is not needed in the output columns. Do keep `AVG(T1.score)` without an alias instead of using `as average_score`, since the alias was removed. Do maintain the same `INNER JOIN` on `T1.business_id = T2.business_id` between `inspections` and `businesses` tables. Do preserve the `GROUP BY T2.name` clause for proper aggregation. Do continue using `ORDER BY COUNT(T2.business_id) DESC` to sort by the count of business inspections. Do retain `LIMIT 1` to return only the top result. The amended query now correctly focuses on retrieving just the business name and average score without the unnecessary inspection count column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT establishment_name, COUNT(*) as inspection_count, AVG(score) as avg_score\nFROM inspections\nGROUP BY establishment_name\nORDER BY inspection_count DESC\nLIMIT 1;",
            "SELECT T2.name, AVG(T1.score) as average_score, COUNT(T2.business_id) as inspection_count\nFROM inspections T1\nINNER JOIN businesses T2 ON T1.business_id = T2.business_id\nGROUP BY T2.name\nORDER BY COUNT(T2.business_id) DESC\nLIMIT 1;",
            "SELECT T2.name, AVG(T1.score)\nFROM inspections T1\nINNER JOIN businesses T2 ON T1.business_id = T2.business_id\nGROUP BY T2.name\nORDER BY COUNT(T2.business_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "808": {
        "db_id": "social_media",
        "question": "Give the gender of the user who made the highest klout tweet on Wednesdays.",
        "ground_truth": "SELECT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.Weekday = 'Wednesday' ORDER BY T1.Klout DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do reference `T2.Gender` instead of `gender`. Do join `twitter AS T1` with `user AS T2` on `T1.UserID = T2.UserID` instead of using a subquery. Do filter on `T1.Weekday = 'Wednesday'` instead of `strftime('%w', created_at) = '3'`. Do order by `T1.Klout DESC` instead of `klout_score ASC`. Do maintain `LIMIT 1` but apply it after the join instead of within a subquery. The amended query now correctly joins user and tweet data, uses proper weekday filtering, and returns the gender of the user with the highest Klout score on Wednesdays, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE user_id IN (SELECT user_id FROM tweets WHERE strftime('%w', created_at) = '3' ORDER BY klout_score ASC LIMIT 1);",
            "SELECT T2.Gender\nFROM twitter AS T1\nJOIN user AS T2 ON T1.UserID = T2.UserID\nWHERE T1.Weekday = 'Wednesday'\nORDER BY T1.Klout DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4336": {
        "db_id": "simpson_episodes",
        "question": "Calculate the percentage of the nominees who were born in USA.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.result = 'Nominee';",
        "amends": [
            "Do use `SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only USA records. Do reference `T1.birth_country` instead of `country` for the country filter. Do add `INNER JOIN Award AS T2 ON T1.name = T2.person` instead of querying only the nominees table. Do add `WHERE T2.result = 'Nominee'` instead of omitting the result condition. Do use `CAST(... AS REAL)` instead of implicit casting with `100.0`. Do calculate percentage as `* 100 / COUNT(*)` instead of `* 100.0 / (SELECT COUNT(*) FROM nominees)`. Do remove the subquery and instead use the main query's `COUNT(*)` for the denominator. The amended query now correctly calculates the percentage of USA-born nominees by joining Person and Award tables with proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM nominees) AS percentage FROM nominees WHERE country = 'USA';",
            "SELECT CAST(SUM(CASE WHEN T1.birth_country = 'USA' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(*) AS percentage\nFROM Person AS T1\nINNER JOIN Award AS T2 ON T1.name = T2.person\nWHERE T2.result = 'Nominee'"
        ],
        "rule_sql": []
    },
    "2388": {
        "db_id": "superstore",
        "question": "List down the customers that purchased the product named Xerox 23 in the South region.",
        "ground_truth": "SELECT DISTINCT T2.`Customer Name` FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T1.Region = 'South' AND T3.`Product Name` = 'Xerox 23'",
        "amends": [
            "Do select `DISTINCT T2.Customer Name` instead of `c.customer_name` without distinct. Do use `south_superstore AS T1` as the primary table instead of `customers c`. Do join `people AS T2` on `T1.Customer ID = T2.Customer ID` instead of joining customers directly. Do join `product AS T3` on `T3.Product ID = T1.Product ID` instead of joining through orders. Do move the `Region = 'South'` filter to apply to `T1` instead of `c`. Do keep the `Product Name = 'Xerox 23'` filter on `T3` instead of `p`. The amended query now correctly identifies customers from the south region who purchased Xerox 23 products using the proper table relationships and distinct selection to avoid duplicates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.customer_name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN products p ON o.product_id = p.product_id\nWHERE p.product_name = 'Xerox 23'\nAND c.region = 'South';",
            "SELECT DISTINCT T2.\"Customer Name\"\nFROM south_superstore AS T1\nJOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\"\nJOIN product AS T3 ON T3.\"Product ID\" = T1.\"Product ID\"\nWHERE T3.\"Product Name\" = 'Xerox 23'"
        ],
        "rule_sql": []
    },
    "4841": {
        "db_id": "legislator",
        "question": "Give the state and type of term of the legislator with the google entity ID of kg:/m/02pyzk.",
        "ground_truth": "SELECT T2.state, T2.type FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.google_entity_id_id = 'kg:/m/02pyzk'",
        "amends": [
            "Do select `T2.state` and `T2.type` from the joined table instead of selecting `state` and `type` directly from the source table. Do use `FROM historical AS T1 INNER JOIN historical-terms AS T2` instead of `FROM legislators` to properly join the two related tables. Do apply the join condition `ON T1.bioguide_id = T2.bioguide` instead of no join condition to correctly relate the historical and historical-terms data. Do filter on `T1.google_entity_id_id = 'kg:/m/02pyzk'` instead of `google_entity_id = 'kg:/m/02pyzk'` to use the correct column name and table reference. The amended query now correctly retrieves state and type information by joining the appropriate tables with the proper relationship and filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, type FROM legislators WHERE google_entity_id = 'kg:/m/02pyzk';",
            "SELECT T2.state, T2.type FROM historical AS T1 INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.google_entity_id_id = 'kg:/m/02pyzk'"
        ],
        "rule_sql": []
    },
    "5150": {
        "db_id": "address",
        "question": "Among the cities with an area code 939, which city has the highest Asian population?",
        "ground_truth": "SELECT T2.city FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.area_code = 939 ORDER BY T2.asian_population DESC LIMIT 1",
        "amends": [
            "Do join `area_code AS T1` and `zip_data AS T2` with `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of querying only `cities` table. Do select `T2.city` instead of `city_name` from the wrong table. Do filter on `T1.area_code = 939` instead of `area_code = 939` from the correct joined table. Do order by `T2.asian_population DESC` instead of just `asian_population DESC` with proper table qualification. The amended query now correctly joins the necessary tables to find cities by area code through zip code relationships and returns the appropriate result matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name FROM cities WHERE area_code = 939 ORDER BY asian_population DESC LIMIT 1;",
            "SELECT T2.city\nFROM area_code AS T1\nINNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code\nWHERE T1.area_code = 939\nORDER BY T2.asian_population DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1707": {
        "db_id": "restaurant",
        "question": "How many American food restaurants are unpopular in Carmel?",
        "ground_truth": "SELECT COUNT(id_restaurant) FROM generalinfo WHERE food_type = 'american' AND city = 'carmel' AND review = ( SELECT MIN(review) FROM generalinfo WHERE food_type = 'american' AND city = 'carmel' )",
        "amends": [
            "Do use `COUNT(id_restaurant)` instead of `COUNT(*)` to count specific restaurant identifiers rather than all rows. Do query from `generalinfo` table instead of `restaurants` as the correct data source. Do filter by `food_type = 'american'` instead of `cuisine = 'American'` using the proper column name and lowercase value. Do filter by `city = 'carmel'` instead of `city = 'Carmel'` with consistent lowercase formatting. Do replace the `rating > 4.0` filter with a subquery condition `review = (SELECT MIN(review) FROM generalinfo WHERE food_type = 'american' AND city = 'carmel')` instead of a simple numeric comparison, which changes the logic to find restaurants with the minimum review score rather than those above a rating threshold. The amended query now correctly identifies restaurants with the lowest review score for American cuisine in Carmel, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE cuisine = 'American' AND city = 'Carmel' AND rating > 4.0;",
            "SELECT COUNT(id_restaurant) FROM generalinfo WHERE food_type = 'american' AND city = 'carmel' AND review = (SELECT MIN(review) FROM generalinfo WHERE food_type = 'american' AND city = 'carmel')"
        ],
        "rule_sql": []
    },
    "1143": {
        "db_id": "talkingdata",
        "question": "For the device with an event occurring on 2016/5/1 at 0:55:25, what is the gender of its user?",
        "ground_truth": "SELECT T1.gender FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE T2.timestamp = '2016-05-01 00:55:25'",
        "amends": [
            "Do select `T1.gender` from the `gender_age` table instead of `gender` from the `users` table. Do join `events AS T2` with `INNER JOIN` on `T1.device_id = T2.device_id` instead of using a subquery with `WHERE device_id = (SELECT device_id FROM events)`. Do filter on `T2.timestamp = '2016-05-01 00:55:25'` with proper date format instead of the incorrect '2016/5/1 0:55:25' format. The amended query now correctly joins the gender_age and events tables to retrieve gender information based on the timestamp condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE device_id = (SELECT device_id FROM events WHERE timestamp = '2016/5/1 0:55:25')",
            "SELECT T1.gender FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id WHERE T2.timestamp = '2016-05-01 00:55:25'"
        ],
        "rule_sql": []
    },
    "556": {
        "db_id": "movies_4",
        "question": "What keyword can the user use to search for the movie Finding Nemo?",
        "ground_truth": "SELECT T3.keyword_name FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE T1.title = 'Finding Nemo'",
        "amends": [
            "Do select only `T3.keyword_name` instead of all columns with `*`. Do join `movie` as `T1` with `movie_keywords` as `T2` on `T1.movie_id = T2.movie_id` instead of querying a single `movies` table. Do add a second join to `keyword` as `T3` on `T2.keyword_id = T3.keyword_id` instead of filtering directly on a `keyword` column. Do filter on `T1.title = 'Finding Nemo'` instead of both `title` and `keyword` conditions, as the keyword filtering is now handled through the join relationships. Do remove the direct `keyword = 'animation'` filter instead of keeping it, since the join structure properly connects movies to their keywords through the relationship tables. The amended query now correctly retrieves keywords associated with 'Finding Nemo' through proper table relationships instead of assuming incorrect schema structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM movies WHERE title = 'Finding Nemo' AND keyword = 'animation';",
            "SELECT T3.keyword_name\nFROM movie AS T1\nJOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id\nJOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id\nWHERE T1.title = 'Finding Nemo'"
        ],
        "rule_sql": []
    },
    "1113": {
        "db_id": "talkingdata",
        "question": "List at least 3 categories with the lowest number of users.",
        "ground_truth": "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id ORDER BY T2.label_id LIMIT 3",
        "amends": [
            "Do select `T1.category` instead of `category, COUNT(user_id) as user_count`. Do use `FROM label_categories AS T1 INNER JOIN app_labels AS T2` instead of `FROM users`. Do join on `T1.label_id = T2.label_id` instead of no join condition. Do remove `GROUP BY category` instead of keeping it. Do remove the aggregate function instead of using `COUNT`. Do order by `T2.label_id` instead of `user_count ASC`. Do keep `LIMIT 3` but with different underlying data. The amended query now correctly retrieves categories from joined tables ordered by label_id instead of counting users by category."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(user_id) as user_count FROM users GROUP BY category ORDER BY user_count ASC LIMIT 3;",
            "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id ORDER BY T2.label_id LIMIT 3"
        ],
        "rule_sql": []
    },
    "7660": {
        "db_id": "hockey",
        "question": "Among the coaches who have taught teams from the NHL League, how many of them are from Canada?",
        "ground_truth": "SELECT COUNT(T2.coachID) FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE T2.lgID = 'NHL' AND T1.birthCountry = 'Canada'",
        "amends": [
            "Do select `COUNT(T2.coachID)` instead of `COUNT(*)` to count specific coach records. Do join `Master AS T1` with `Coaches AS T2` on `T1.coachID = T2.coachID` instead of querying only the `coaches` table. Do filter on `T2.lgID = 'NHL'` instead of `league = 'NHL'` to use the correct column name. Do filter on `T1.birthCountry = 'Canada'` instead of `nationality = 'Canada'` to reference the proper table and column for Canadian birth country. The amended query now correctly counts NHL coaches born in Canada by joining the necessary tables and using the appropriate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM coaches WHERE nationality = 'Canada' AND league = 'NHL';",
            "SELECT COUNT(T2.coachID) \nFROM Master AS T1 \nJOIN Coaches AS T2 ON T1.coachID = T2.coachID \nWHERE T2.lgID = 'NHL' AND T1.birthCountry = 'Canada'"
        ],
        "rule_sql": []
    },
    "1236": {
        "db_id": "talkingdata",
        "question": "How many OPPO devices are there?",
        "ground_truth": "SELECT COUNT(device_id) FROM phone_brand_device_model2 WHERE phone_brand = 'OPPO'",
        "amends": [
            "Do count `device_id` instead of `*` to exclude null values. Do query from `phone_brand_device_model2` instead of `devices` to use the correct table. Do filter on `phone_brand = 'OPPO'` instead of `brand = 'Samsung'` to target the appropriate brand. The amended query now correctly counts OPPO devices from the specified table while excluding null device IDs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM devices WHERE brand = 'Samsung';",
            "SELECT COUNT(device_id) FROM phone_brand_device_model2 WHERE phone_brand = 'OPPO';"
        ],
        "rule_sql": []
    },
    "2286": {
        "db_id": "movielens",
        "question": "How many distinct movies in English stars a male actor who acts the best?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN movies AS T3 ON T2.movieid = T3.movieid WHERE T3.isEnglish = 'T' AND T1.a_gender = 'M' AND T1.a_quality = 5",
        "amends": [
            "Do count distinct `T1.actorid` instead of `m.movie_id`. Do join `actors AS T1` instead of `movies m` as the primary table. Do use `INNER JOIN movies2actors AS T2` instead of `JOIN movie_actors ma` with the join condition `T1.actorid = T2.actorid` instead of `m.movie_id = ma.movie_id`. Do use `INNER JOIN movies AS T3` instead of `JOIN actors a` with the join condition `T2.movieid = T3.movieid` instead of `ma.actor_id = a.actor_id`. Do filter with `T3.isEnglish = 'T'` instead of `m.language = 'English'`. Do filter with `T1.a_gender = 'M'` instead of `a.gender = 'Male'`. Do filter with `T1.a_quality = 5` instead of the subquery `a.rating = (SELECT MAX(rating) FROM actors)`. The amended query now correctly counts distinct actors meeting the quality threshold rather than movies with maximum-rated actors."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT m.movie_id) \nFROM movies m\nJOIN movie_actors ma ON m.movie_id = ma.movie_id\nJOIN actors a ON ma.actor_id = a.actor_id\nWHERE m.language = 'English' \nAND a.gender = 'Male'\nAND a.rating = (SELECT MAX(rating) FROM actors)",
            "SELECT COUNT(DISTINCT T1.actorid) \nFROM actors AS T1\nINNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid\nINNER JOIN movies AS T3 ON T2.movieid = T3.movieid\nWHERE T3.isEnglish = 'T'\nAND T1.a_gender = 'M'\nAND T1.a_quality = 5"
        ],
        "rule_sql": []
    },
    "7578": {
        "db_id": "image_and_language",
        "question": "How many images have an x-coordinate of 5 and y-coordinate of 5?",
        "ground_truth": "SELECT COUNT(IMG_ID) FROM IMG_OBJ WHERE X = 5 AND Y = 5",
        "amends": [
            "Do use table `IMG_OBJ` instead of `images` and count `IMG_ID` instead of `*`. Do use `AND` operator instead of `OR` for the coordinate conditions. Do reference columns `X` and `Y` instead of `x_coordinate` and `y_coordinate`. The amended query now correctly counts images where both coordinates equal 5 instead of counting images where either coordinate equals 5, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE x_coordinate = 5 OR y_coordinate = 5;",
            "SELECT COUNT(DISTINCT IMG_ID) FROM IMG_OBJ WHERE X = 5 AND Y = 5;"
        ],
        "rule_sql": []
    },
    "1200": {
        "db_id": "talkingdata",
        "question": "Among the users who use SUGAR, calculate the percentage of those who are above 20 years old.",
        "ground_truth": "SELECT SUM(IIF(T1.age > 20, 1, 0)) / COUNT(T1.device_id) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'SUGAR'",
        "amends": [
            "Do use `SUM(IIF(T1.age > 20, 1, 0)) / COUNT(T1.device_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE age > 20)` for the percentage calculation. Do join `gender_age AS T1` with `phone_brand_device_model2 AS T2` on `T1.device_id = T2.device_id` instead of querying only the `users` table. Do filter on `T2.phone_brand = 'SUGAR'` instead of `product = 'SUGAR'`. Do add proper table aliases `T1` and `T2` instead of omitting them. Do remove the subquery approach for counting age-filtered records instead of keeping it. The amended query now correctly calculates the percentage of users over age 20 among those with SUGAR phone brand devices.",
            "Do remove the multiplication by `100.0` from the percentage calculation instead of including it, and do change the alias from `percentage` to `per` instead of keeping the original. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`, though this is a cosmetic difference. The amended query now correctly calculates the proportion rather than a percentage and matches the RIGHT_SQL's behavior.",
            "Do remove the multiplication by `1.0` in the division expression instead of keeping it, as the division between integer values already produces the correct decimal result without explicit casting. Do maintain the same `SELECT` list with the `SUM(IIF(T1.age > 20, 1, 0)) / COUNT(T1.device_id)` calculation instead of the multiplied version. Do preserve the `FROM` source with `gender_age AS T1` and the `INNER JOIN` on `phone_brand_device_model2 AS T2` with the same join condition `T1.device_id = T2.device_id`. Do keep the `WHERE` filter on `T2.phone_brand = 'SUGAR'` unchanged. The amended query now correctly calculates the percentage without unnecessary type conversion and matches the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE age > 20) FROM users WHERE product = 'SUGAR'",
            "SELECT \n    (SUM(IIF(T1.age > 20, 1, 0)) * 100.0 / COUNT(T1.device_id)) AS percentage\nFROM \n    gender_age AS T1\nJOIN \n    phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE \n    T2.phone_brand = 'SUGAR';",
            "SELECT \n    SUM(IIF(T1.age > 20, 1, 0)) * 1.0 / COUNT(T1.device_id) AS per\nFROM \n    gender_age AS T1\nINNER JOIN \n    phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE \n    T2.phone_brand = 'SUGAR'",
            "SELECT SUM(IIF(T1.age > 20, 1, 0)) / COUNT(T1.device_id) AS per\nFROM gender_age AS T1\nINNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE T2.phone_brand = 'SUGAR'"
        ],
        "rule_sql": []
    },
    "6021": {
        "db_id": "books",
        "question": "What are the languages of the first two published books?",
        "ground_truth": "SELECT T2.language_name FROM book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id ORDER BY T1.publication_date ASC LIMIT 2",
        "amends": [
            "Do join `book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id` instead of querying only the `books` table. Do select `T2.language_name` instead of `language` from the books table. Do add the explicit `ASC` direction in `ORDER BY T1.publication_date ASC` instead of omitting it. The amended query now correctly retrieves language names from the joined language table rather than potentially incorrect language data from the books table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM books ORDER BY publication_date LIMIT 2;",
            "SELECT T2.language_name \nFROM book AS T1 \nINNER JOIN book_language AS T2 ON T1.language_id = T2.language_id \nORDER BY T1.publication_date ASC \nLIMIT 2"
        ],
        "rule_sql": []
    },
    "5583": {
        "db_id": "shipping",
        "question": "Among the customers having at least one shipment in 2017, how many of them have an annual revenue of over 30000000?",
        "ground_truth": "SELECT COUNT(COUNTCUSID) FROM ( SELECT COUNT(T1.cust_id) AS COUNTCUSID FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE STRFTIME('%Y', T2.ship_date) = '2017' AND T1.annual_revenue > 30000000 GROUP BY T1.cust_id HAVING COUNT(T2.ship_id) >= 1 ) T3",
        "amends": [
            "Do use `COUNT(COUNTCUSID)` on a subquery result instead of `COUNT(DISTINCT c.customer_id)` directly. Do reference tables as `customer AS T1` and `shipment AS T2` instead of `customers c` and `shipments s`. Do use `INNER JOIN` with `T1.cust_id = T2.cust_id` instead of `JOIN` with `c.customer_id = s.customer_id`. Do filter with `STRFTIME('%Y', T2.ship_date) = '2017'` instead of `s.shipment_date LIKE '2017%'` for proper year extraction. Do add `GROUP BY T1.cust_id` and `HAVING COUNT(T2.ship_id) >= 1` instead of omitting grouping and having clauses. Do use column names `cust_id`, `ship_date`, and `ship_id` instead of `customer_id`, `shipment_date`, and the missing shipment identifier. The amended query now correctly counts customers with at least one shipment in 2017 and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT c.customer_id) \nFROM customers c\nJOIN shipments s ON c.customer_id = s.customer_id\nWHERE s.shipment_date LIKE '2017%'\nAND c.annual_revenue > 30000000",
            "SELECT COUNT(*) AS count_customers\nFROM (\n    SELECT T1.cust_id\n    FROM customer AS T1\n    INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id\n    WHERE STRFTIME('%Y', T2.ship_date) = '2017'\n    AND T1.annual_revenue > 30000000\n    GROUP BY T1.cust_id\n    HAVING COUNT(T2.ship_id) >= 1\n) AS subquery"
        ],
        "rule_sql": []
    },
    "6762": {
        "db_id": "retails",
        "question": "What is the average number of items shipped each day in April of 1994?",
        "ground_truth": "SELECT AVG(l_linenumber) FROM lineitem WHERE l_shipdate BETWEEN '1994-01-01' AND '1994-01-30'",
        "amends": [
            "Do use `AVG(l_linenumber)` instead of `AVG(total_items)` for the aggregate calculation. Do query from `lineitem` table instead of `orders` table as the data source. Do apply a `BETWEEN '1994-01-01' AND '1994-01-30'` date range filter instead of a `LIKE '1994-04%'` pattern match on the shipping date. Do remove the subquery and `GROUP BY` clause instead of keeping the nested aggregation structure. Do filter directly on `l_shipdate` instead of using `DATE(shipped_date)` and grouping by day. The amended query now correctly calculates the average line item number for January 1994 shipments from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(total_items) FROM (\n    SELECT COUNT(*) as total_items, DATE(shipped_date) as ship_day\n    FROM orders \n    WHERE shipped_date LIKE '1994-04%'\n    GROUP BY ship_day\n)",
            "SELECT AVG(l_linenumber) FROM lineitem WHERE l_shipdate BETWEEN '1994-01-01' AND '1994-01-30';"
        ],
        "rule_sql": []
    },
    "7107": {
        "db_id": "works_cycles",
        "question": "What is the name of the supplier number 1492?",
        "ground_truth": "SELECT NAME FROM Vendor WHERE BusinessEntityID = 1492",
        "amends": [
            "Do select `NAME` instead of `supplier_name` and do reference `Vendor` instead of `suppliers` as the table source. Do filter on `BusinessEntityID = 1492` instead of `supplier_id = 1492` to match the correct column name and table structure. The amended query now correctly retrieves vendor information using the proper table and column names as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT supplier_name FROM suppliers WHERE supplier_id = 1492;",
            "SELECT Name FROM Vendor WHERE BusinessEntityID = 1492;"
        ],
        "rule_sql": []
    },
    "1945": {
        "db_id": "soccer_2016",
        "question": "Write down the player names and IDs of the English umpires.",
        "ground_truth": "SELECT T1.Umpire_Name, T1.Umpire_Id FROM Umpire AS T1 INNER JOIN Country AS T2 ON T1.Umpire_Country = T2.Country_Id WHERE T2.Country_Name = 'England'",
        "amends": [
            "Do reference `Umpire_Name` and `Umpire_Id` instead of `player_name` and `player_id`. Do use table alias `T1` for the `Umpire` table instead of directly querying `umpires`. Do add an `INNER JOIN` with `Country` table alias `T2` on `T1.Umpire_Country = T2.Country_Id` instead of omitting the join. Do filter on `T2.Country_Name = 'England'` instead of directly filtering `nationality = 'English'`. The amended query now correctly joins tables to filter by country name rather than relying on a potentially incorrect direct nationality field, matching the RIGHT_SQL's behavior.",
            "Do reverse the column order in the SELECT list to `Umpire_Name, Umpire_Id` instead of `Umpire_Id, Umpire_Name`. Do add explicit table aliases with `AS` keyword for both tables instead of omitting it. The amended query now correctly matches the RIGHT_SQL's behavior with the proper column sequence and explicit alias syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, player_id FROM umpires WHERE nationality = 'English';",
            "SELECT T1.Umpire_Id, T1.Umpire_Name FROM Umpire T1 INNER JOIN Country T2 ON T1.Umpire_Country = T2.Country_Id WHERE T2.Country_Name = 'England'",
            "SELECT T1.Umpire_Name, T1.Umpire_Id\nFROM Umpire AS T1\nINNER JOIN Country AS T2 ON T1.Umpire_Country = T2.Country_Id\nWHERE T2.Country_Name = 'England'"
        ],
        "rule_sql": []
    },
    "7006": {
        "db_id": "works_cycles",
        "question": "Which is a high quality product but with the lowest transacted quantity?",
        "ground_truth": "SELECT T1.Name FROM Product AS T1 INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Class = 'H' ORDER BY T2.Quantity ASC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `product_name, quality, SUM(quantity) as total_quantity`. Do use `FROM Product AS T1 INNER JOIN TransactionHistory AS T2` instead of `FROM products` alone. Do apply join condition `ON T1.ProductID = T2.ProductID` instead of no join. Do filter with `WHERE T1.Class = 'H'` instead of `WHERE quality = 'high'`. Do order by `T2.Quantity ASC` instead of `total_quantity ASC`. The amended query now correctly joins tables and uses proper column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, quality, SUM(quantity) as total_quantity \nFROM products \nWHERE quality = 'high' \nORDER BY total_quantity ASC \nLIMIT 1;",
            "SELECT T1.Name \nFROM Product AS T1 \nINNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID \nWHERE T1.Class = 'H' \nORDER BY T2.Quantity ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4752": {
        "db_id": "legislator",
        "question": "Among all the female current legislators, how many of them have served for more than 4 terms?",
        "ground_truth": "SELECT COUNT(CID) FROM ( SELECT T1.bioguide_id AS CID FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' GROUP BY T2.bioguide HAVING COUNT(T2.bioguide) > 4 )",
        "amends": [
            "Do use `COUNT(CID)` from a subquery instead of `COUNT(*)` directly. Do select from `current` table as `T1` instead of `legislators` table. Do join with `current-terms` as `T2` instead of no join. Do use `INNER JOIN` on `T1.bioguide_id = T2.bioguide` instead of no join condition. Do filter with `T1.gender_bio = 'F'` instead of `gender = 'F'`. Do group by `T2.bioguide` instead of no grouping. Do use `HAVING COUNT(T2.bioguide) > 4` instead of `WHERE terms_served > 4`. Do remove `current_status = 'active'` filter instead of keeping it. The amended query now correctly counts female legislators with more than 4 terms by joining current data with term information and using proper aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE gender = 'F' AND terms_served > 4 AND current_status = 'active';",
            "SELECT COUNT(*) FROM (\n    SELECT T2.bioguide\n    FROM current T1\n    INNER JOIN \"current-terms\" T2 ON T1.bioguide_id = T2.bioguide\n    WHERE T1.gender_bio = 'F'\n    GROUP BY T2.bioguide\n    HAVING COUNT(T2.bioguide) > 4\n) AS subquery"
        ],
        "rule_sql": []
    },
    "5395": {
        "db_id": "sales",
        "question": "Tally the product name and quantity of the first ten sales.",
        "ground_truth": "SELECT T3.Name, T2.Quantity FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T2.SalesID BETWEEN 1 AND 10",
        "amends": [
            "Do select `T3.Name` and `T2.Quantity` instead of `product_name` and `quantity`. Do add `Customers AS T1` with `INNER JOIN Sales AS T2` on `T1.CustomerID = T2.CustomerID` instead of only `FROM sales`. Do add another `INNER JOIN Products AS T3` on `T2.ProductID = T3.ProductID` instead of omitting these table joins. Do add `WHERE T2.SalesID BETWEEN 1 AND 10` instead of using `LIMIT 10`. Do remove `LIMIT` clause instead of keeping it as the row limitation is now handled by the WHERE filter on SalesID range. The amended query now correctly joins customer, sales, and product tables to retrieve product names with quantities for specific sales records instead of directly selecting from sales with arbitrary row limiting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, quantity FROM sales LIMIT 10;",
            "SELECT T3.Name, T2.Quantity \nFROM Customers AS T1 \nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID \nINNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID \nWHERE T2.SalesID BETWEEN 1 AND 10"
        ],
        "rule_sql": []
    },
    "6778": {
        "db_id": "retails",
        "question": "Among the suppliers in the European region, what percentage have a below-average account balance?",
        "ground_truth": "SELECT CAST(SUM(IIF(T3.s_acctbal < ( SELECT AVG(supplier.s_acctbal) FROM supplier ), 1, 0)) AS REAL) * 100 / COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey WHERE T2.r_name = 'EUROPE'",
        "amends": [
            "Do use explicit joins with `nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey` instead of subqueries for filtering European suppliers. Do move the `r_name = 'EUROPE'` filter to the `WHERE` clause instead of nesting it in subqueries. Do calculate the average account balance from the entire `supplier` table instead of limiting it to European suppliers only. Do use `SUM(IIF(T3.s_acctbal < (SELECT AVG(supplier.s_acctbal) FROM supplier), 1, 0))` instead of `COUNT(CASE WHEN s_acctbal < ... THEN 1 END)` for counting suppliers below average. Do cast the sum to `REAL` and divide by the count of nation keys instead of using percentage calculation with `* 100.0 / COUNT(*)`. The amended query now correctly calculates the percentage of European suppliers with account balances below the global average, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN s_acctbal < (SELECT AVG(s_acctbal) FROM supplier WHERE s_nationkey IN (SELECT n_nationkey FROM nation WHERE n_regionkey = (SELECT r_regionkey FROM region WHERE r_name = 'EUROPE')))) THEN 1 END) * 100.0 / COUNT(*) \nFROM supplier \nWHERE s_nationkey IN (SELECT n_nationkey FROM nation WHERE n_regionkey = (SELECT r_regionkey FROM region WHERE r_name = 'EUROPE'));",
            "SELECT \n    (SUM(IIF(T3.s_acctbal < (SELECT AVG(s_acctbal) FROM supplier), 1, 0)) * 100.0 / COUNT(*)) AS percentage\nFROM \n    nation AS T1 \n    INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey \n    INNER JOIN supplier AS T3 ON T1.n_nationkey = T3.s_nationkey\nWHERE \n    T2.r_name = 'EUROPE';"
        ],
        "rule_sql": []
    },
    "2048": {
        "db_id": "music_tracker",
        "question": "What are the top 5 tags with the highest amount of downloads?",
        "ground_truth": "SELECT T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.releaseType = 'album' ORDER BY T1.totalSnatched DESC LIMIT 5",
        "amends": [
            "Do select `T2.tag` and `T1.totalSnatched` instead of `tag_name` and `COUNT(*) as download_count`. Do use `FROM torrents AS T1` instead of `FROM tags` and change to `INNER JOIN tags AS T2` instead of `JOIN downloads`. Do add `ON T1.id = T2.id` instead of `ON tags.id = downloads.tag_id`. Do add `WHERE T1.releaseType = 'album'` instead of omitting this filter. Do remove `GROUP BY tag_name` and the aggregation instead of keeping them. Do change `ORDER BY T1.totalSnatched DESC` instead of `ORDER BY download_count DESC`. The amended query now correctly selects top tags by torrent snatches instead of download counts, filtering for album releases only.",
            "Do remove `T1.totalSnatched` from the SELECT list instead of including it, as the RIGHT_SQL only selects the tag column. The amended query now matches RIGHT_SQL's behavior by focusing solely on retrieving tag information without the unnecessary totalSnatched column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tag_name, COUNT(*) as download_count FROM tags JOIN downloads ON tags.id = downloads.tag_id GROUP BY tag_name ORDER BY download_count DESC LIMIT 5;",
            "SELECT T2.tag, T1.totalSnatched\nFROM torrents AS T1\nINNER JOIN tags AS T2 ON T1.id = T2.id\nWHERE T1.releaseType = 'album'\nORDER BY T1.totalSnatched DESC\nLIMIT 5",
            "SELECT T2.tag\nFROM torrents AS T1\nINNER JOIN tags AS T2 ON T1.id = T2.id\nWHERE T1.releaseType = 'album'\nORDER BY T1.totalSnatched DESC\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "6081": {
        "db_id": "books",
        "question": "What is the order price of the book \"The Servant Leader\" in 2003?",
        "ground_truth": "SELECT T2.price FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.title = 'The Servant Leader' AND STRFTIME('%Y', T1.publication_date) = '2003'",
        "amends": [
            "Do select `T2.price` from the `order_line` table instead of `price` from the `orders` table. Do join `book AS T1` with `order_line AS T2` using `INNER JOIN` on `T1.book_id = T2.book_id` instead of querying only the `orders` table. Do filter on `T1.title = 'The Servant Leader'` instead of `book_title = 'The Servant Leader'`. Do use `STRFTIME('%Y', T1.publication_date) = '2003'` to extract the year from the publication date instead of filtering on a `year` column. The amended query now correctly joins the book and order_line tables to retrieve prices for the specified book title and publication year, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM orders WHERE book_title = 'The Servant Leader' AND year = 2003;",
            "SELECT T2.price \nFROM book AS T1 \nINNER JOIN order_line AS T2 ON T1.book_id = T2.book_id \nWHERE T1.title = 'The Servant Leader' \nAND STRFTIME('%Y', T1.publication_date) = '2003'"
        ],
        "rule_sql": []
    },
    "5283": {
        "db_id": "beer_factory",
        "question": "What are the brands of the root beers that received 5-star ratings from no less than 5 customers?",
        "ground_truth": "SELECT T1.BrandName FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T2.StarRating = 5 GROUP BY T2.BrandID HAVING COUNT(T2.StarRating) >= 5",
        "amends": [
            "Do use `T1.BrandName` from the `rootbeerbrand` table instead of `brand` from a non-existent `root_beers` table. Do join `rootbeerbrand AS T1` with `rootbeerreview AS T2` on `T1.BrandID = T2.BrandID` instead of querying a single table. Do filter with `T2.StarRating = 5` in the WHERE clause instead of `rating = 5`. Do group by `T2.BrandID` instead of `brand`. Do use `HAVING COUNT(T2.StarRating) >= 5` instead of `COUNT(customer_id) >= 5` in the SELECT clause, moving the aggregate condition to the proper HAVING clause. The amended query now correctly identifies brands with at least five 5-star reviews by joining the appropriate tables and using proper grouping and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM root_beers WHERE rating = 5 AND COUNT(customer_id) >= 5 GROUP BY brand;",
            "SELECT T1.BrandName \nFROM rootbeerbrand AS T1\nJOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID\nWHERE T2.StarRating = 5\nGROUP BY T2.BrandID\nHAVING COUNT(T2.StarRating) >= 5"
        ],
        "rule_sql": []
    },
    "7058": {
        "db_id": "works_cycles",
        "question": "For the employees who have the highest pay frequency, please list their vacation hours.",
        "ground_truth": "SELECT T2.VacationHours FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.BusinessEntityID = ( SELECT BusinessEntityID FROM EmployeePayHistory ORDER BY Rate DESC LIMIT 1 )",
        "amends": [
            "Do use `EmployeePayHistory AS T1` and `Employee AS T2` as FROM sources instead of just `Employees`. Do perform an `INNER JOIN` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do select `T2.VacationHours` instead of just `VacationHours`. Do change the WHERE filter to `T2.BusinessEntityID = (subquery)` instead of `PayFrequency = (subquery)`. Do use a subquery that selects `BusinessEntityID` from `EmployeePayHistory` ordered by `Rate DESC` with `LIMIT 1` instead of selecting `MAX(PayFrequency)` from `Employees`. The amended query now correctly retrieves vacation hours for the employee with the highest pay rate by properly joining the Employee and EmployeePayHistory tables and using the appropriate subquery logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT VacationHours FROM Employees WHERE PayFrequency = (SELECT MAX(PayFrequency) FROM Employees);",
            "SELECT T2.VacationHours \nFROM EmployeePayHistory AS T1 \nINNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID \nWHERE T2.BusinessEntityID = (\n    SELECT BusinessEntityID \n    FROM EmployeePayHistory \n    ORDER BY Rate DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "1248": {
        "db_id": "law_episode",
        "question": "Please list all the keywords for the episodes with a rating of over 8.",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.rating > 8",
        "amends": [
            "Do select `T2.keyword` from the `Keyword` table instead of `keywords` from the `episodes` table. Do join `Episode AS T1` with `Keyword AS T2` using `INNER JOIN` on `T1.episode_id = T2.episode_id` instead of querying only the `episodes` table. Do apply the rating filter `T1.rating > 8` to the Episode table instead of applying it directly to the episodes table without proper table qualification. The amended query now correctly retrieves keywords associated with highly-rated episodes by joining the appropriate tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keywords FROM episodes WHERE rating > 8",
            "SELECT T2.keyword \nFROM Episode AS T1 \nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id \nWHERE T1.rating > 8"
        ],
        "rule_sql": []
    },
    "2101": {
        "db_id": "world_development_indicators",
        "question": "Please list the countries that got the footnote \"Data are classified as official aid.\" on the series code DC.DAC.AUSL.CD in 2002.",
        "ground_truth": "SELECT T1.SHORTNAME FROM Country AS T1 INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Description = 'Data are classified as official aid.' AND T2.Seriescode = 'DC.DAC.AUSL.CD' AND T2.Year LIKE '%2002%'",
        "amends": [
            "Do select `T1.SHORTNAME` instead of `country`. Do join `Country AS T1` and `FootNotes AS T2` with `INNER JOIN` on `T1.CountryCode = T2.Countrycode` instead of querying only `aid_data`. Do filter on `T2.Description = 'Data are classified as official aid.'` instead of `footnote`. Do filter on `T2.Seriescode = 'DC.DAC.AUSL.CD'` instead of `series_code`. Do filter on `T2.Year LIKE '%2002%'` instead of `year = 2002`. The amended query now correctly joins the Country and FootNotes tables to retrieve country names based on footnote descriptions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM aid_data WHERE series_code = 'DC.DAC.AUSL.CD' AND year = 2002 AND footnote = 'Data are classified as official aid.'",
            "SELECT T1.ShortName\nFROM Country AS T1\nINNER JOIN Footnotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T2.Description = 'Data are classified as official aid.'\nAND T2.Seriescode = 'DC.DAC.AUSL.CD'\nAND T2.Year LIKE '%2002%'"
        ],
        "rule_sql": []
    },
    "2585": {
        "db_id": "regional_sales",
        "question": "List the name of all customers who had made orders online.",
        "ground_truth": "SELECT T FROM ( SELECT CASE  WHEN T2.`Sales Channel` = 'Online' THEN T1.`Customer Names` ELSE NULL END AS T FROM Customers T1 INNER JOIN `Sales Orders` T2 ON T2._CustomerID = T1.CustomerID ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with CASE expression to transform `Sales Channel` values instead of directly filtering on `order_type`. Do add an INNER JOIN between `Customers` and `Sales Orders` tables on `T2._CustomerID = T1.CustomerID` instead of querying only the customers table. Do filter for 'Online' sales channel in the CASE expression instead of 'online' order_type. Do alias the CASE result as `T` and filter on `T IS NOT NULL` in the outer query instead of filtering directly in the WHERE clause. Do use proper table aliases T1 and T2 with qualified column references instead of unqualified column names. The amended query now correctly joins customer and sales data, handles the sales channel filtering through proper transformation, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM customers WHERE order_type = 'online';",
            "SELECT T1.\"Customer Names\"\nFROM Customers T1\nINNER JOIN \"Sales Orders\" T2 ON T2._CustomerID = T1.CustomerID\nWHERE (\n    CASE \n        WHEN T2.\"Sales Channel\" = 'Online' THEN 1 \n        ELSE NULL \n    END\n) IS NOT NULL\nGROUP BY T1.CustomerID, T1.\"Customer Names\""
        ],
        "rule_sql": []
    },
    "9016": {
        "db_id": "bike_share_1",
        "question": "What is the name of the station that is less used by customers who borrow bikes from? Indicate when was the station installed.",
        "ground_truth": "SELECT T1.start_station_name, T2.installation_date FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.subscription_type = 'Customer' GROUP BY T1.start_station_name ORDER BY COUNT(T1.subscription_type) LIMIT 1",
        "amends": [
            "Do select `T1.start_station_name` and `T2.installation_date` instead of `name` and `install_date`. Do use `FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name` instead of `FROM stations` without joins. Do add `WHERE T1.subscription_type = 'Customer'` instead of omitting any filters. Do add `GROUP BY T1.start_station_name` instead of omitting grouping. Do order by `COUNT(T1.subscription_type)` instead of `total_borrows ASC`. The amended query now correctly joins trip and station tables, filters for customer subscriptions, groups by station name, and orders by subscription count to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, install_date FROM stations ORDER BY total_borrows ASC LIMIT 1;",
            "SELECT T1.start_station_name, T2.installation_date\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.subscription_type = 'Customer'\nGROUP BY T1.start_station_name\nORDER BY COUNT(T1.subscription_type) ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7479": {
        "db_id": "image_and_language",
        "question": "How many object samples in image no.1 are in the class of \"man\"?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE 0 END) FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.IMG_ID = 1",
        "amends": [
            "Do use `SUM(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific records. Do join tables `OBJ_CLASSES AS T1` and `IMG_OBJ AS T2` with `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single table. Do filter with `WHERE T2.IMG_ID = 1` instead of `image_id = 1` to reference the correct table column. Do reference `T1.OBJ_CLASS` instead of `class` to use the proper table alias and column name. The amended query now correctly counts 'man' objects associated with image ID 1 through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM objects WHERE image_id = 1 AND class = 'man';",
            "SELECT SUM(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE 0 END) \nFROM OBJ_CLASSES AS T1 \nINNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID \nWHERE T2.IMG_ID = 1"
        ],
        "rule_sql": []
    },
    "7235": {
        "db_id": "works_cycles",
        "question": "What is the person's business ID with a vista credit card number \"11113366963373\"?",
        "ground_truth": "SELECT T2.BusinessEntityID FROM CreditCard AS T1 INNER JOIN PersonCreditCard AS T2 ON T1.CreditCardID = T2.CreditCardID WHERE T1.CardNumber = 11113366963373",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of plain table names. Do join `CreditCard AS T1` with `PersonCreditCard AS T2` on `T1.CreditCardID = T2.CreditCardID` instead of querying a single `people` table. Do filter on `T1.CardNumber = 11113366963373` instead of `credit_card = '11113366963373' AND card_type = 'mastercard'`. Do select `T2.BusinessEntityID` instead of `business_id`. The amended query now correctly joins the credit card and person credit card tables to find the associated business entity ID for the given card number."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM people WHERE credit_card = '11113366963373' AND card_type = 'mastercard';",
            "SELECT T2.BusinessEntityID \nFROM CreditCard AS T1 \nJOIN PersonCreditCard AS T2 ON T1.CreditCardID = T2.CreditCardID \nWHERE T1.CardNumber = '11113366963373'"
        ],
        "rule_sql": []
    },
    "6900": {
        "db_id": "retails",
        "question": "How many customers in the machinery segment are in debt?",
        "ground_truth": "SELECT COUNT(c_custkey) FROM customer WHERE c_acctbal < 0 AND c_mktsegment = 'MACHINERY'",
        "amends": [
            "Do reference `c_custkey` in the COUNT function instead of using `COUNT(*)` to count only non-null customer keys. Do use table name `customer` instead of `customers` as the data source. Do filter on `c_acctbal < 0` instead of `debt > 0` to identify customers with negative account balances. Do filter on `c_mktsegment = 'MACHINERY'` instead of `segment = 'machinery'` using the correct column name and uppercase value for market segment matching. The amended query now correctly counts machinery segment customers with negative account balances as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE segment = 'machinery' AND debt > 0;",
            "SELECT COUNT(c_custkey) FROM customer WHERE c_mktsegment = 'MACHINERY' AND c_acctbal < 0"
        ],
        "rule_sql": []
    },
    "4354": {
        "db_id": "simpson_episodes",
        "question": "Give the title of the episode won in Primetime Emmy Awards 2009.",
        "ground_truth": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.organization = 'Primetime Emmy Awards' AND T1.year = 2009 AND T1.result = 'Winner';",
        "amends": [
            "Do reference `T2.title` from the Episode table instead of just `title`. Do join `Award AS T1` with `Episode AS T2` on `T1.episode_id = T2.episode_id` instead of querying episodes directly. Do filter on `T1.organization = 'Primetime Emmy Awards'` instead of `award = 'Primetime Emmy'`. Do add `T1.result = 'Winner'` condition instead of omitting it. Do use `T1.year = 2009` from the Award table instead of `year = 2009` from episodes. The amended query now correctly identifies Emmy winners by joining award records with episodes and filtering for specific organization and result criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE year = 2009 AND award = 'Primetime Emmy'",
            "SELECT T2.title \nFROM Award AS T1 \nJOIN Episode AS T2 ON T1.episode_id = T2.episode_id \nWHERE T1.organization = 'Primetime Emmy Awards' \nAND T1.year = 2009 \nAND T1.result = 'Winner'"
        ],
        "rule_sql": []
    },
    "4134": {
        "db_id": "public_review_platform",
        "question": "Find the location of businesses that has business hours from 7 am to 7 pm every Wednesday.",
        "ground_truth": "SELECT DISTINCT T1.city FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T2.opening_time = '7AM' AND T2.closing_time = '7PM' AND T3.day_of_week = 'Wednesday'",
        "amends": [
            "Do use `SELECT DISTINCT T1.city` instead of `SELECT location` to return unique city names rather than location strings. Do join `Business AS T1` instead of querying only `businesses` table to properly access business data. Do add `INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id` instead of filtering directly on hours column to separate hours data into a dedicated table. Do add `INNER JOIN Days AS T3 ON T2.day_id = T3.day_id` instead of hardcoding day names to use a normalized days table. Do use `WHERE T2.opening_time = '7AM' AND T2.closing_time = '7PM'` instead of `hours LIKE '%7am%' AND hours LIKE '%7pm%'` to precisely match opening and closing times. Do use `T3.day_of_week = 'Wednesday'` instead of `hours LIKE '%Wednesday%'` to filter by day name in a normalized way. The amended query now correctly uses normalized table relationships and precise time/day matching instead of string pattern matching on a single column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM businesses WHERE hours LIKE '%Wednesday%' AND hours LIKE '%7am%' AND hours LIKE '%7pm%';",
            "SELECT DISTINCT T1.city\nFROM Business AS T1\nINNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id\nINNER JOIN Days AS T3 ON T2.day_id = T3.day_id\nWHERE T2.opening_time = '7AM' \nAND T2.closing_time = '7PM'\nAND T3.day_of_week = 'Wednesday'"
        ],
        "rule_sql": []
    },
    "2276": {
        "db_id": "movielens",
        "question": "Please list the genre of the movies that are the newest and is in English.",
        "ground_truth": "SELECT T2.genre FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.year = 4 AND T1.isEnglish = 'T'",
        "amends": [
            "Do join `movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid` instead of querying only the `movies` table. Do select `T2.genre` instead of `genre`. Do filter with `T1.year = 4 AND T1.isEnglish = 'T'` instead of `language = 'English'`. Do remove `ORDER BY release_date ASC LIMIT 1` instead of keeping the ordering and limiting. The amended query now correctly retrieves genre information from the joined relationship table with proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM movies WHERE language = 'English' ORDER BY release_date ASC LIMIT 1;",
            "SELECT T2.genre \nFROM movies AS T1 \nINNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid \nWHERE T1.year = 4 AND T1.isEnglish = 'T'"
        ],
        "rule_sql": []
    },
    "711": {
        "db_id": "trains",
        "question": "How many trains are running west?",
        "ground_truth": "SELECT COUNT(id) FROM trains WHERE direction = 'west'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trains WHERE direction = 'east';"
        ],
        "rule_sql": []
    },
    "3571": {
        "db_id": "authors",
        "question": "List author name for articles that are preprinted but not published.",
        "ground_truth": "SELECT T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Year = 0",
        "amends": [
            "Do select `T2.Name` from the `PaperAuthor` table instead of `author_name` from the `articles` table. Do join `Paper` as `T1` with `PaperAuthor` as `T2` using `INNER JOIN` on `T1.Id = T2.PaperId` instead of querying a single table. Do filter on `T1.Year = 0` instead of `is_preprinted = 1 AND is_published = 1`. The amended query now correctly retrieves author names from papers with year zero instead of published preprints, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM articles WHERE is_preprinted = 1 AND is_published = 1;",
            "SELECT T2.Name \nFROM Paper AS T1 \nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId \nWHERE T1.Year = 0"
        ],
        "rule_sql": []
    },
    "6834": {
        "db_id": "retails",
        "question": "What are the top 5 nations of suppliers with the lowest account balance?",
        "ground_truth": "SELECT T2.n_name FROM supplier AS T1 INNER JOIN nation AS T2 ON T1.s_nationkey = T2.n_nationkey ORDER BY T1.s_acctbal LIMIT 1",
        "amends": [
            "Do select only `n_name` instead of selecting both `n_name` and `SUM(s_acctbal)` with an alias. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` without aliases. Do remove the `GROUP BY n_name` clause instead of grouping by nation. Do remove the aggregation function `SUM(s_acctbal)` instead of calculating total balance. Do order by `T1.s_acctbal` directly instead of ordering by the aggregated `total_balance`. Do change the limit to `1` instead of `5` to get only the single record with the minimum account balance. The amended query now correctly finds the supplier with the smallest account balance and returns their nation name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n_name, SUM(s_acctbal) as total_balance \nFROM supplier \nJOIN nation ON supplier.s_nationkey = nation.n_nationkey \nGROUP BY n_name \nORDER BY total_balance ASC \nLIMIT 5;",
            "SELECT T2.n_name\nFROM supplier T1\nINNER JOIN nation T2 ON T1.s_nationkey = T2.n_nationkey\nORDER BY T1.s_acctbal ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8254": {
        "db_id": "mondial_geo",
        "question": "Which country has the most languages spoken?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country GROUP BY T1.Name ORDER BY COUNT(T2.Name) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do select `T1.Name` instead of `country`. Do use `INNER JOIN` between `country` and `language` tables instead of querying only the `countries` table. Do join on `T1.Code = T2.Country` instead of no join condition. Do aggregate by `T1.Name` instead of `country`. Do order by `COUNT(T2.Name)` instead of `language_count`. Do count `T2.Name` instead of `language`. The amended query now correctly joins country and language tables to find the country with the most languages, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(language) as language_count FROM countries GROUP BY country ORDER BY language_count DESC LIMIT 1;",
            "SELECT T1.Name\nFROM country AS T1\nINNER JOIN language AS T2 ON T1.Code = T2.Country\nGROUP BY T1.Name\nORDER BY COUNT(T2.Name) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4097": {
        "db_id": "public_review_platform",
        "question": "Among businesses with \"Wi-Fi\" attribute, which businesses id are located at SC State?",
        "ground_truth": "SELECT T3.business_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.attribute_name = 'Wi-Fi' AND T2.attribute_value = 'true' AND T3.state = 'SC'",
        "amends": [
            "Do use explicit table joins with `Attributes AS T1 INNER JOIN Business_Attributes AS T2` and `INNER JOIN Business AS T3` instead of querying a single `businesses` table. Do reference specific columns `T1.attribute_name` and `T2.attribute_value` instead of using `LIKE '%Wi-Fi%'` pattern matching. Do filter with exact equality `T1.attribute_name = 'Wi-Fi'` and `T2.attribute_value = 'true'` instead of the ambiguous `attributes LIKE '%Wi-Fi%'` condition. Do maintain the state filter as `T3.state = 'SC'` but reference it through the properly joined `Business` table instead of the original table. Do select from the correct table with `T3.business_id` instead of the ambiguous `business_id`. The amended query now correctly uses the normalized database schema with proper table relationships instead of relying on string pattern matching in a denormalized column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE attributes LIKE '%Wi-Fi%' AND state = 'SC';",
            "SELECT T3.business_id\nFROM Attributes AS T1\nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\nINNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nWHERE T1.attribute_name = 'Wi-Fi'\nAND T2.attribute_value = 'true'\nAND T3.state = 'SC'"
        ],
        "rule_sql": []
    },
    "5095": {
        "db_id": "address",
        "question": "What is the average median female age of all the residential areas in the Arecibo county?",
        "ground_truth": "SELECT SUM(T1.female_median_age) / COUNT(T1.zip_code) FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T2.county = 'ARECIBO'",
        "amends": [
            "Do use `SUM(T1.female_median_age) / COUNT(T1.zip_code)` instead of `AVG(median_female_age)` for calculating the weighted average. Do join `zip_data AS T1` with `country AS T2` on `T1.zip_code = T2.zip_code` instead of querying only `residential_areas`. Do filter on `T2.county = 'ARECIBO'` instead of `county = 'Arecibo'` with proper case handling. Do reference `T1.female_median_age` and `T1.zip_code` instead of `median_female_age` from the correct table structure. The amended query now correctly calculates the average female median age by properly joining the necessary tables and using the appropriate aggregation method."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(median_female_age) FROM residential_areas WHERE county = 'Arecibo';",
            "SELECT SUM(T1.female_median_age) / COUNT(T1.zip_code) AS average_female_median_age\nFROM zip_data AS T1\nJOIN country AS T2 ON T1.zip_code = T2.zip_code\nWHERE T2.county = 'ARECIBO';"
        ],
        "rule_sql": []
    },
    "3111": {
        "db_id": "cars",
        "question": "Give the model year of the heaviest car.",
        "ground_truth": "SELECT T2.model_year FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID ORDER BY T1.weight DESC LIMIT 1",
        "amends": [
            "Do select `T2.model_year` from the `production` table instead of `model_year` from the `cars` table. Do join `data AS T1` with `production AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table without any join. Do order by `T1.weight DESC` instead of `weight ASC` to sort in descending order rather than ascending. The amended query now correctly retrieves model year from the production table joined with data table and sorts by weight in descending order to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model_year FROM cars ORDER BY weight ASC LIMIT 1;",
            "SELECT T2.model_year FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID ORDER BY T1.weight DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "102": {
        "db_id": "movie_platform",
        "question": "Which movie has the highest average score in Mubi?",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id GROUP BY T2.movie_title ORDER BY SUM(T1.rating_score) / COUNT(T1.rating_id) DESC LIMIT 1",
        "amends": [
            "Do reference `T2.movie_title` instead of `title` and calculate the average as `SUM(T1.rating_score) / COUNT(T1.rating_id)` instead of `AVG(score)`. Do join `ratings AS T1` with `movies AS T2` using `INNER JOIN` on `T1.movie_id = T2.movie_id` instead of querying only the `movies` table with a `WHERE platform = 'Mubi'` filter. Do group by `T2.movie_title` instead of `title` and order by the calculated average instead of `average_score`. Do remove the platform filter instead of keeping it, as the correct logic aggregates all ratings across platforms. The amended query now correctly calculates movie averages from the ratings table and returns the highest-rated movie.",
            "Do remove the `SUM(T1.rating_score) / COUNT(T1.rating_id) AS average_score` column from the SELECT list instead of including it. Do move the average calculation `SUM(T1.rating_score) / COUNT(T1.rating_id)` to the ORDER BY clause instead of keeping it in the SELECT list. The amended query now correctly returns only the movie title while ordering by the average rating score, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, AVG(score) as average_score FROM movies WHERE platform = 'Mubi' GROUP BY title ORDER BY average_score DESC LIMIT 1;",
            "SELECT T2.movie_title, SUM(T1.rating_score) / COUNT(T1.rating_id) AS average_score\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nGROUP BY T2.movie_title\nORDER BY average_score DESC\nLIMIT 1;",
            "SELECT T2.movie_title\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nGROUP BY T2.movie_title\nORDER BY SUM(T1.rating_score) / COUNT(T1.rating_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8163": {
        "db_id": "sales_in_weather",
        "question": "Tell the temperature range of the home weather station of store no.7 on 2014/4/28.",
        "ground_truth": "SELECT T1.tmax - T1.tmin AS temprange FROM weather AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr WHERE T2.store_nbr = 7 AND T1.`date` = '2014-04-28'",
        "amends": [
            "Do select `T1.tmax - T1.tmin` as `temprange` instead of `MAX(temperature) - MIN(temperature)` as `temperature_range`. Do use `weather AS T1` and `relation AS T2` tables instead of `weather_stations`. Do perform an `INNER JOIN` on `T1.station_nbr = T2.station_nbr` instead of querying a single table. Do filter on `T2.store_nbr = 7` instead of `store_id = 7` and maintain `T1.date = '2014-04-28'` instead of `date = '2014-04-28'`. The amended query now correctly joins tables to access the required temperature range data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(temperature) - MIN(temperature) AS temperature_range FROM weather_stations WHERE store_id = 7 AND date = '2014-04-28';",
            "SELECT T1.tmax - T1.tmin AS temprange\nFROM weather AS T1\nINNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr\nWHERE T2.store_nbr = 7 AND T1.date = '2014-04-28'"
        ],
        "rule_sql": []
    },
    "4404": {
        "db_id": "student_loan",
        "question": "What percentage of students who enlisted in the navy make up the number of students enrolled in OCC?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.school = 'occ', 1.0, 0)) AS REAL) * 100 / COUNT(T1.name) FROM enrolled AS T1 INNER JOIN enlist AS T2 ON T1.`name` = T2.`name` WHERE T2.organ = 'navy'",
        "amends": [
            "Do use `SUM(IIF(T1.school = 'occ', 1.0, 0))` to count specific conditions instead of `COUNT(*)` with a WHERE filter. Do join `enrolled AS T1` with `enlist AS T2` on `T1.name = T2.name` instead of querying a single table. Do filter on `T2.organ = 'navy'` instead of `branch = 'Navy'`. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T1.name)` with proper casting instead of `(COUNT(*) * 100.0 / subquery)`. Do reference columns from joined tables `T1.school` and `T2.organ` instead of direct table columns. The amended query now correctly calculates the percentage of Navy-enlisted students enrolled in OCC programs using proper table relationships and conditional counting.",
            "Do use lowercase `'occ'` instead of uppercase `'OCC'` in the IIF condition to ensure case-sensitive matching. Do remove the alias `percentage` instead of keeping it since the RIGHT_SQL omits column naming. Do explicitly specify `INNER JOIN` instead of implicit `JOIN` for clarity. Do use backticks around `name` columns instead of plain identifiers to handle potential reserved keyword conflicts. The amended query now correctly calculates the percentage of 'occ' school enrollments in the navy without unnecessary aliasing and with proper case handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students WHERE branch = 'Navy')) AS percentage FROM students WHERE enrolled_in = 'OCC';",
            "SELECT \n    (CAST(SUM(IIF(T1.school = 'OCC', 1.0, 0)) AS REAL) * 100 / COUNT(T1.name)) AS percentage\nFROM \n    enrolled AS T1\nJOIN \n    enlist AS T2 ON T1.name = T2.name\nWHERE \n    T2.organ = 'navy'",
            "SELECT CAST(SUM(IIF(T1.school = 'occ', 1.0, 0)) AS REAL) * 100 / COUNT(T1.`name`) \nFROM `enrolled` AS T1 \nINNER JOIN `enlist` AS T2 ON T1.`name` = T2.`name` \nWHERE T2.organ = 'navy'"
        ],
        "rule_sql": []
    },
    "9374": {
        "db_id": "movie_3",
        "question": "Where can you rent the movie 'Wyoming Storm'? Identify the address of the rental store and the rental rate.",
        "ground_truth": "SELECT T2.store_id, T1.address, T4.rental_rate FROM address AS T1 INNER JOIN store AS T2 ON T1.address_id = T2.address_id INNER JOIN inventory AS T3 ON T2.store_id = T3.store_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE T4.title = 'WYOMING STORM'",
        "amends": [
            "Do add `T2.store_id` to the SELECT list instead of omitting it. Do use `address AS T1` instead of directly referencing `store.address` without joining to the address table. Do use `INNER JOIN` with explicit aliases `T1`, `T2`, `T3`, `T4` instead of simple table names without aliases. Do join `address AS T1` to `store AS T2` on `T1.address_id = T2.address_id` instead of missing this necessary join relationship. Do reference `T4.rental_rate` instead of `film.rental_rate` to maintain alias consistency. Do filter on `T4.title = 'WYOMING STORM'` with uppercase instead of `film.title = 'Wyoming Storm'` with mixed case. The amended query now correctly joins all necessary tables and matches RIGHT_SQL's behavior.",
            "Do reorder the SELECT list to `T2.store_id, T1.address, T4.rental_rate` instead of `T1.address, T4.rental_rate, T2.store_id` to match the column sequence in the correct query. The amended query now matches RIGHT_SQL's behavior with identical column ordering and output structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store.address, film.rental_rate \nFROM store \nJOIN inventory ON store.store_id = inventory.store_id \nJOIN film ON inventory.film_id = film.film_id \nWHERE film.title = 'Wyoming Storm';",
            "SELECT T1.address, T4.rental_rate, T2.store_id\nFROM address AS T1\nINNER JOIN store AS T2 ON T1.address_id = T2.address_id\nINNER JOIN inventory AS T3 ON T2.store_id = T3.store_id\nINNER JOIN film AS T4 ON T3.film_id = T4.film_id\nWHERE T4.title = 'WYOMING STORM'",
            "SELECT T2.store_id, T1.address, T4.rental_rate\nFROM address AS T1\nINNER JOIN store AS T2 ON T1.address_id = T2.address_id\nINNER JOIN inventory AS T3 ON T2.store_id = T3.store_id\nINNER JOIN film AS T4 ON T3.film_id = T4.film_id\nWHERE T4.title = 'WYOMING STORM'"
        ],
        "rule_sql": []
    },
    "79": {
        "db_id": "movie_platform",
        "question": "What's of rating on the movie \"Innocence Unprotected\" by the user who created the movie list \"250 Favourite Films\"?",
        "ground_truth": "SELECT T1.rating_score FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists AS T3 ON T3.user_id = T1.user_id WHERE T2.movie_title = 'Innocence Unprotected' AND T3.list_title = '250 Favourite Films'",
        "amends": [
            "Do select `rating_score` from `T1` instead of `rating` from `ratings`. Do join `movies AS T2` on `T1.movie_id = T2.movie_id` instead of directly filtering by movie title without a join. Do join `lists AS T3` on `T3.user_id = T1.user_id` instead of using a subquery to find user_id. Do filter with `T2.movie_title = 'Innocence Unprotected'` instead of directly on the ratings table. Do filter with `T3.list_title = '250 Favourite Films'` instead of using a subquery with `list_name`. Do remove the subquery entirely instead of keeping it for user lookup. The amended query now correctly joins through proper relationships and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating FROM ratings WHERE movie_title = 'Innocence Unprotected' AND user_id = (SELECT user_id FROM movie_lists WHERE list_name = '250 Favourite Films');",
            "SELECT T1.rating_score \nFROM ratings AS T1\nJOIN movies AS T2 ON T1.movie_id = T2.movie_id\nJOIN lists AS T3 ON T3.user_id = T1.user_id\nWHERE T2.movie_title = 'Innocence Unprotected' \nAND T3.list_title = '250 Favourite Films'"
        ],
        "rule_sql": []
    },
    "6788": {
        "db_id": "retails",
        "question": "To which segment belongs the customer that made the most orders in April 1994?",
        "ground_truth": "SELECT T.c_mktsegment FROM ( SELECT T2.c_mktsegment, COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T1.o_orderdate LIKE '1994-04-%' GROUP BY T1.o_custkey ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use `T.c_mktsegment` in the SELECT list instead of `segment` to reference the correct column name. Do add table aliases `T1` for `orders` and `T2` for `customer` instead of using unaliased table names. Do use `INNER JOIN` on `T1.o_custkey = T2.c_custkey` instead of the subquery approach to properly join the tables. Do move the date filter to `WHERE T1.o_orderdate LIKE '1994-04-%'` instead of applying it in a subquery. Do add `COUNT(T1.o_orderkey) AS num` as an aggregate instead of counting without specifying the column. Do change the GROUP BY to `T1.o_custkey` instead of `customer_id` to use the correct column name. Do wrap the query in a subquery `T` and order by `T.num DESC` instead of ordering within the subquery. The amended query now correctly finds the customer segment with the most orders in April 1994 by properly joining tables and counting orders per customer."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT segment FROM customers WHERE customer_id = (SELECT customer_id FROM orders WHERE order_date LIKE '1994-04%' GROUP BY customer_id ORDER BY COUNT(*) DESC LIMIT 1);",
            "SELECT T.c_mktsegment\nFROM (\n    SELECT T2.c_mktsegment, COUNT(T1.o_orderkey) AS num\n    FROM orders T1\n    INNER JOIN customer T2 ON T1.o_custkey = T2.c_custkey\n    WHERE T1.o_orderdate LIKE '1994-04-%'\n    GROUP BY T1.o_custkey\n) T\nORDER BY T.num DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8712": {
        "db_id": "chicago_crime",
        "question": "How many districts are there in the police district building with a zip code of 60608?",
        "ground_truth": "SELECT COUNT(*) AS cnt FROM District WHERE zip_code = 60608",
        "amends": [
            "Do use `AS cnt` to alias the count instead of omitting the alias. Do reference table `District` instead of `police_districts`. Do use numeric value `60608` without quotes instead of string `'60608'` for the zip_code comparison. The amended query now correctly counts records from the District table where zip_code equals the numeric value 60608."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM police_districts WHERE zip_code = '60608';",
            "SELECT COUNT(*) AS cnt FROM District WHERE zip_code = 60608;"
        ],
        "rule_sql": []
    },
    "1072": {
        "db_id": "talkingdata",
        "question": "What are the ages and genders of the LG L70 users?",
        "ground_truth": "SELECT T2.age, T2.gender FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'LG' AND T1.device_model = 'L70'",
        "amends": [
            "Do select `T2.age` and `T2.gender` from table aliases instead of `age` and `gender` without table references. Do use `phone_brand_device_model2 AS T1` and `gender_age AS T2` as FROM sources instead of just `users`. Do add `INNER JOIN` with predicate `T2.device_id = T1.device_id` instead of no join condition. Do change WHERE filter to `T1.phone_brand = 'LG' AND T1.device_model = 'L70'` instead of `device = 'LG L70'` to properly match brand and model separately. The amended query now correctly joins device information with user demographics and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age, gender FROM users WHERE device = 'LG L70';",
            "SELECT T2.age, T2.gender FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.phone_brand = 'LG' AND T1.device_model = 'L70'"
        ],
        "rule_sql": []
    },
    "8625": {
        "db_id": "chicago_crime",
        "question": "How many arrests were made in 2018 in an animal hospital under FBI code 08B?",
        "ground_truth": "SELECT SUM(CASE WHEN arrest = 'TRUE' THEN 1 ELSE 0 END) FROM Crime WHERE date LIKE '%2018%' AND location_description = 'ANIMAL HOSPITAL' AND fbi_code_no = '08B'",
        "amends": [
            "Do use `SUM(CASE WHEN arrest = 'TRUE' THEN 1 ELSE 0 END)` to count conditional arrests instead of `COUNT(*)` which counts all rows. Do query from table `Crime` instead of `arrests`. Do filter using `date LIKE '%2018%'` for year matching instead of `year = 2018`. Do use location filter `location_description = 'ANIMAL HOSPITAL'` instead of `location = 'animal hospital'`. Do reference column `fbi_code_no` instead of `fbi_code`. The amended query now correctly counts only actual arrests while matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM arrests WHERE year = 2018 AND location = 'animal hospital' AND fbi_code = '08B';",
            "SELECT SUM(CASE WHEN arrest = 'TRUE' THEN 1 ELSE 0 END) AS arrest_count\nFROM Crime\nWHERE date LIKE '%2018%'\nAND location_description = 'ANIMAL HOSPITAL'\nAND fbi_code_no = '08B';"
        ],
        "rule_sql": []
    },
    "7336": {
        "db_id": "works_cycles",
        "question": "Calculate the average age of employee in each department and state which department has the youngest employees.",
        "ground_truth": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1 , T3.Name FROM Employee AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 USING (BusinessEntityID) INNER JOIN Department AS T3 USING (DepartmentID) ORDER BY T1.BirthDate DESC LIMIT 1",
        "amends": [
            "Do calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1` instead of `AVG(age)` aggregation. Do select `T3.Name` instead of `department` and `average_age`. Do join `EmployeeDepartmentHistory AS T2` using `BusinessEntityID` instead of omitting this table. Do join `Department AS T3` using `DepartmentID` instead of omitting this table. Do remove `GROUP BY department` and aggregation entirely instead of grouping by department. Do order by `T1.BirthDate DESC` instead of `average_age DESC`. The amended query now correctly retrieves the most recent employee's age and department name by joining necessary tables and calculating age from birthdate rather than relying on a pre-calculated age field.",
            "Do use explicit column references `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1` and `T3.Name` in the SELECT list instead of aliasing them as `department_name` and `age`. Do use `INNER JOIN` with `USING (BusinessEntityID)` instead of `JOIN` with explicit `ON T1.BusinessEntityID = T2.BusinessEntityID`. Do use `INNER JOIN` with `USING (DepartmentID)` instead of `JOIN` with explicit `ON T2.DepartmentID = T3.DepartmentID`. The amended query now matches RIGHT_SQL's behavior by removing unnecessary aliases and using more concise JOIN syntax while maintaining the same logical result.",
            "Do reverse the column order in the SELECT list, placing the age calculation `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1` first instead of `T3.Name` first, while keeping all other elements including the FROM sources with `INNER JOIN` on `BusinessEntityID` and `DepartmentID`, the `ORDER BY T1.BirthDate DESC`, and `LIMIT 1` unchanged. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, AVG(age) as average_age FROM employees GROUP BY department ORDER BY average_age DESC LIMIT 1;",
            "SELECT \n    T3.Name AS department_name,\n    STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1 AS age\nFROM \n    Employee AS T1\nJOIN \n    EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nJOIN \n    Department AS T3 ON T2.DepartmentID = T3.DepartmentID\nORDER BY \n    T1.BirthDate DESC\nLIMIT 1;",
            "SELECT T3.Name, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1\nFROM Employee AS T1\nINNER JOIN EmployeeDepartmentHistory AS T2 USING (BusinessEntityID)\nINNER JOIN Department AS T3 USING (DepartmentID)\nORDER BY T1.BirthDate DESC\nLIMIT 1;",
            "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.BirthDate) + 1, T3.Name\nFROM Employee AS T1\nINNER JOIN EmployeeDepartmentHistory AS T2 USING (BusinessEntityID)\nINNER JOIN Department AS T3 USING (DepartmentID)\nORDER BY T1.BirthDate DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8114": {
        "db_id": "university",
        "question": "Calculate the average score of university ID 79 between year 2013 to 2015.",
        "ground_truth": "SELECT AVG(score) FROM university_ranking_year WHERE year BETWEEN 2013 AND 2015 AND university_id = 79",
        "amends": [
            "Do reference the `university_ranking_year` table instead of the incorrect `university_scores` table. Do maintain the same `AVG(score)` aggregation and `year BETWEEN 2013 AND 2015 AND university_id = 79` filter conditions, but correct the table name to ensure the query accesses the proper data source containing the university ranking scores. The amended query now correctly calculates the average score for university 79 between 2013 and 2015 from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) FROM university_scores WHERE university_id = 79 AND year BETWEEN 2013 AND 2015;",
            "SELECT AVG(score) FROM university_ranking_year WHERE year BETWEEN 2013 AND 2015 AND university_id = 79"
        ],
        "rule_sql": []
    },
    "8352": {
        "db_id": "mondial_geo",
        "question": "What province does the 4th most populous city in the United Kingdom belong to, and how many people live there?",
        "ground_truth": "SELECT T1.Province, T1.Population FROM city AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T2.Name = 'United Kingdom' ORDER BY T1.Population DESC LIMIT 3, 1",
        "amends": [
            "Do add `INNER JOIN country AS T2 ON T1.Country = T2.Code` instead of querying only the cities table. Do change the filter to `T2.Name = 'United Kingdom'` instead of `country = 'United Kingdom'` to properly reference the country name from the joined table. Do use `LIMIT 3, 1` instead of `LIMIT 1 OFFSET 3` to achieve the same pagination result with different syntax. Do add table aliases `T1` and `T2` instead of using unqualified column references. The amended query now correctly joins the city and country tables to filter by country name and returns the fourth largest city by population in the United Kingdom."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT province, population FROM cities WHERE country = 'United Kingdom' ORDER BY population DESC LIMIT 1 OFFSET 3;",
            "SELECT T1.Province, T1.Population\nFROM city AS T1\nINNER JOIN country AS T2 ON T1.Country = T2.Code\nWHERE T2.Name = 'United Kingdom'\nORDER BY T1.Population DESC\nLIMIT 3, 1"
        ],
        "rule_sql": []
    },
    "5239": {
        "db_id": "beer_factory",
        "question": "Among the transactions made in July, 2014, how many of them were made by a male customer?",
        "ground_truth": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Gender = 'M' AND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
        "amends": [
            "Do use `COUNT(T1.CustomerID)` instead of `COUNT(*)` to count specific customer records. Do reference `customers AS T1` and `transaction AS T2` instead of `transactions t` and `customers c` with different table aliases. Do use `INNER JOIN` instead of `JOIN` for explicit join type specification. Do join on `T1.CustomerID = T2.CustomerID` instead of `t.customer_id = c.customer_id` with corrected column references and join direction. Do filter with `T1.Gender = 'M'` instead of `c.gender = 'male'` using the correct gender code format. Do maintain the date filter `STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'` instead of the similar but differently aliased version. The amended query now correctly counts male customers with July 2014 transactions using proper table and column references.",
            "Do use backticks around the reserved word `transaction` instead of leaving it unquoted, which could cause syntax errors in some SQL dialects. The amended query now correctly handles the table name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM transactions t\nJOIN customers c ON t.customer_id = c.customer_id\nWHERE strftime('%Y-%m', t.transaction_date) = '2014-07'\nAND c.gender = 'male';",
            "SELECT COUNT(T1.CustomerID) \nFROM customers AS T1\nINNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Gender = 'M' \nAND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'",
            "SELECT COUNT(T1.CustomerID) \nFROM customers AS T1 \nINNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Gender = 'M' \nAND STRFTIME('%Y-%m', T2.TransactionDate) = '2014-07'"
        ],
        "rule_sql": []
    },
    "5670": {
        "db_id": "shipping",
        "question": "What is the truck's model year used to ship the ship ID 1245?",
        "ground_truth": "SELECT T1.model_year FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = '1245'",
        "amends": [
            "Do specify the table alias `T1.model_year` instead of just `model_year`. Do join `truck AS T1` with `shipment AS T2` instead of querying only the `trucks` table. Do use `INNER JOIN` with the predicate `T1.truck_id = T2.truck_id` instead of missing the join condition. Do filter on `T2.ship_id = '1245'` with string comparison instead of numeric `ship_id = 1245` against the wrong table. The amended query now correctly retrieves model_year by joining truck and shipment tables and filtering on the appropriate ship_id field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model_year FROM trucks WHERE ship_id = 1245;",
            "SELECT T1.model_year FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T2.ship_id = '1245'"
        ],
        "rule_sql": []
    },
    "5800": {
        "db_id": "language_corpus",
        "question": "How many times does the word \"her\u00f2dot\" appear in the Wikipedia page?",
        "ground_truth": "SELECT COUNT(T2.occurrences) FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE T1.word = 'her\u00f2dot'",
        "amends": [
            "Do use the `words` and `pages_words` tables instead of the `wikipedia_pages` table. Do join `words AS T1` with `pages_words AS T2` on `T1.wid = T2.wid` instead of querying a single table. Do filter on `T1.word = 'her\u00f2dot'` instead of using `LIKE '%her\u00f2dot%'` pattern matching. Do count `T2.occurrences` instead of counting all rows with `COUNT(*)`. The amended query now correctly counts specific word occurrences from the proper relational structure instead of performing inefficient text pattern matching on page content.",
            "Do use `COUNT(T2.occurrences)` instead of `SUM(T2.occurrences)` for counting occurrences. Do remove the `AS total_occurrences` alias instead of keeping it. Do specify `INNER JOIN` explicitly instead of using just `JOIN`. The amended query now correctly counts occurrences rather than summing them and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM wikipedia_pages WHERE page_content LIKE '%her\u00f2dot%';",
            "SELECT SUM(T2.occurrences) AS total_occurrences\nFROM words AS T1\nJOIN pages_words AS T2 ON T1.wid = T2.wid\nWHERE T1.word = 'her\u00f2dot';",
            "SELECT COUNT(T2.occurrences) FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid WHERE T1.word = 'her\u00f2dot'"
        ],
        "rule_sql": []
    },
    "8344": {
        "db_id": "mondial_geo",
        "question": "Provide all rivers name and length in USA.",
        "ground_truth": "SELECT DISTINCT T3.Name, T3.Length FROM city AS T1 INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE T2.Country = 'USA'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate river entries. Do select from `city AS T1` instead of directly from `rivers` to establish proper table relationships. Do add `INNER JOIN located AS T2 ON T1.Name = T2.City` instead of omitting this join to connect cities with their locations. Do add `INNER JOIN river AS T3 ON T3.Name = T2.River` instead of omitting this join to properly associate rivers with their locations. Do reference `T3.Name` and `T3.Length` instead of `name` and `length` to specify the correct table source. Do filter on `T2.Country = 'USA'` instead of `country = 'USA'` to use the correct country field from the location table. The amended query now correctly identifies rivers located in the USA through proper table relationships and joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, length FROM rivers WHERE country = 'USA';",
            "SELECT DISTINCT T3.Name, T3.Length\nFROM city AS T1\nINNER JOIN located AS T2 ON T1.Name = T2.City\nINNER JOIN river AS T3 ON T3.Name = T2.River\nWHERE T2.Country = 'USA'"
        ],
        "rule_sql": []
    },
    "1171": {
        "db_id": "talkingdata",
        "question": "List down the app IDs under the category of game-Rowing .",
        "ground_truth": "SELECT T2.app_id FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE T1.category = 'game-Rowing'",
        "amends": [
            "Do select `T2.app_id` from `app_labels` instead of `app_id` from `apps`. Do join `label_categories AS T1` with `app_labels AS T2` using `INNER JOIN` on `T1.label_id = T2.label_id` instead of querying only the `apps` table. Do filter on `T1.category = 'game-Rowing'` instead of filtering directly on the `apps.category` column. The amended query now correctly retrieves app IDs through the label categorization relationship instead of assuming apps have direct category attributes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_id FROM apps WHERE category = 'game-Rowing';",
            "SELECT T2.app_id \nFROM label_categories AS T1 \nINNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id \nWHERE T1.category = 'game-Rowing'"
        ],
        "rule_sql": []
    },
    "4533": {
        "db_id": "student_loan",
        "question": "Calculate the average duration of absense of female students.",
        "ground_truth": "SELECT AVG(T2.month) FROM person AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name LEFT JOIN male AS T3 ON T1.name = T3.name WHERE T3.name IS NULL",
        "amends": [
            "Do select `AVG(T2.month)` from `longest_absense_from_school` instead of `AVG(duration)` from `absences`. Do add `person` table with `INNER JOIN` on `T1.name = T2.name` instead of omitting it. Do add `LEFT JOIN` with `male` table on `T1.name = T3.name` instead of omitting it. Do change filter to `T3.name IS NULL` instead of `gender = 'female'`. Do remove the `WHERE` clause filtering by gender value and instead use a join condition to exclude males. The amended query now correctly calculates average month values from the appropriate table while properly excluding male records through a left join null check instead of relying on a potentially incorrect gender column value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM absences WHERE gender = 'female';",
            "SELECT AVG(T2.month) \nFROM person T1\nINNER JOIN longest_absense_from_school T2 ON T1.name = T2.name\nLEFT JOIN male T3 ON T1.name = T3.name\nWHERE T3.name IS NULL"
        ],
        "rule_sql": []
    },
    "4575": {
        "db_id": "mental_health_survey",
        "question": "Betweeen 2016 to 2019, which year recorded the highest number of people with mental illness?",
        "ground_truth": "SELECT T1.SurveyID FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T1.SurveyID BETWEEN 2016 AND 2019 AND T2.questionid = 34 AND T1.AnswerText LIKE 'Yes' GROUP BY T1.SurveyID ORDER BY COUNT(T1.UserID) DESC LIMIT 1",
        "amends": [
            "Do use `T1.SurveyID` in the SELECT list instead of `year` and remove the alias `mental_illness_count`. Do change the FROM clause to use `Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid` instead of a single table `mental_health_data`. Do add WHERE conditions `T2.questionid = 34 AND T1.AnswerText LIKE 'Yes'` instead of omitting them, while keeping the `T1.SurveyID BETWEEN 2016 AND 2019` filter. Do add `GROUP BY T1.SurveyID` instead of omitting grouping. Do change ORDER BY to use `COUNT(T1.UserID) DESC` instead of `mental_illness_count ASC`. The amended query now correctly joins tables, filters for specific question responses, groups by survey, and orders by user count to match the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T1.UserID)` from the SELECT list instead of including it, as only the SurveyID is needed for the final result. Do reorder the WHERE clause predicates for logical consistency instead of the original sequence, though this doesn't change the query semantics. The amended query now correctly returns only the SurveyID with the highest count of 'Yes' answers for question 34 between 2016 and 2019, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, COUNT(*) as mental_illness_count\nFROM mental_health_data\nWHERE year BETWEEN 2016 AND 2019\nORDER BY mental_illness_count ASC\nLIMIT 1;",
            "SELECT T1.SurveyID, COUNT(T1.UserID) \nFROM Answer AS T1 \nINNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid \nWHERE T2.questionid = 34 \nAND T1.AnswerText LIKE 'Yes' \nAND T1.SurveyID BETWEEN 2016 AND 2019 \nGROUP BY T1.SurveyID \nORDER BY COUNT(T1.UserID) DESC \nLIMIT 1",
            "SELECT T1.SurveyID\nFROM Answer AS T1\nINNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid\nWHERE T2.questionid = 34 \nAND T1.AnswerText LIKE 'Yes'\nAND T1.SurveyID BETWEEN 2016 AND 2019\nGROUP BY T1.SurveyID\nORDER BY COUNT(T1.UserID) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8470": {
        "db_id": "mondial_geo",
        "question": "List all members and member type of the Islamic Development Bank.",
        "ground_truth": "SELECT T2.Country, T2.Type FROM organization AS T1 INNER JOIN isMember AS T2 ON T1.Abbreviation = T2.Organization INNER JOIN country AS T3 ON T2.Country = T3.Code WHERE T1.Name = 'Islamic Development Bank'",
        "amends": [
            "Do select `Country` and `Type` columns instead of `member_name` and `member_type`. Do join `organization` as `T1` with `isMember` as `T2` on `T1.Abbreviation = T2.Organization` instead of querying a single table. Do add an additional join to `country` as `T3` on `T2.Country = T3.Code` instead of omitting this relationship. Do filter on `T1.Name = 'Islamic Development Bank'` instead of `bank_name = 'Islamic Development Bank'`. The amended query now correctly retrieves member countries and their types through proper organizational relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT member_name, member_type FROM islamic_development_bank_members WHERE bank_name = 'Islamic Development Bank';",
            "SELECT T2.Country, T2.Type\nFROM organization T1\nJOIN isMember T2 ON T1.Abbreviation = T2.Organization\nJOIN country T3 ON T2.Country = T3.Code\nWHERE T1.Name = 'Islamic Development Bank'"
        ],
        "rule_sql": []
    },
    "8197": {
        "db_id": "sales_in_weather",
        "question": "What is the maximum average speed?",
        "ground_truth": "SELECT MAX(avgspeed) FROM weather",
        "amends": [
            "Do select `MAX(avgspeed)` from the `weather` table instead of selecting `MIN(avg_speed)` from the `vehicles` table. Do use the correct column name `avgspeed` instead of the incorrect `avg_speed`. The amended query now correctly retrieves the maximum average speed from the weather data instead of attempting to find the minimum average speed from vehicles."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(avg_speed) FROM vehicles;",
            "SELECT MAX(avgspeed) FROM weather;"
        ],
        "rule_sql": []
    },
    "9076": {
        "db_id": "bike_share_1",
        "question": "What is the total number of bikes that can be hold in Redwood City before 2014.",
        "ground_truth": "SELECT SUM(CASE WHEN city = 'Redwood City' AND SUBSTR(installation_date, -4) < '2014' THEN dock_count ELSE 0 END) NUM FROM station",
        "amends": [
            "Do use `SUM(CASE WHEN city = 'Redwood City' AND SUBSTR(installation_date, -4) < '2014' THEN dock_count ELSE 0 END)` instead of `SUM(capacity)` to calculate the sum based on conditional logic. Do reference `installation_date` field instead of `year` column and extract year using `SUBSTR(installation_date, -4)` instead of direct year comparison. Do use `dock_count` instead of `capacity` as the aggregation value. Do add `NUM` as an alias instead of omitting column naming. Do query from `station` table instead of `bike_stations` table. Do remove explicit `WHERE` clause filtering and instead handle filtering within the `CASE` expression. The amended query now correctly calculates the sum of dock counts for Redwood City stations installed before 2014 by extracting year from the installation date string."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(capacity) FROM bike_stations WHERE city = 'Redwood City' AND year < 2014;",
            "SELECT SUM(CASE WHEN city = 'Redwood City' AND SUBSTR(installation_date, -4) < '2014' THEN dock_count ELSE 0 END) AS NUM FROM station"
        ],
        "rule_sql": []
    },
    "5693": {
        "db_id": "language_corpus",
        "question": "Show all the title of pages and number of occurences for each page where the word 'quipu' appears.",
        "ground_truth": "SELECT T1.title, T2.occurrences FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid INNER JOIN words AS T3 ON T2.wid = T3.wid WHERE T3.word = 'quipu'",
        "amends": [
            "Do select `T1.title` and `T2.occurrences` instead of `title` and `COUNT(*) as occurrences`. Do use `FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid INNER JOIN words AS T3 ON T2.wid = T3.wid` instead of `FROM pages` with no joins. Do add `WHERE T3.word = 'quipu'` instead of `WHERE content LIKE '%quipu%'`. Do remove `GROUP BY title` instead of keeping it. The amended query now correctly joins through the proper relationship tables to find exact word matches rather than using a content search with aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, COUNT(*) as occurrences FROM pages WHERE content LIKE '%quipu%' GROUP BY title;",
            "SELECT T1.title, T2.occurrences FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid INNER JOIN words AS T3 ON T2.wid = T3.wid WHERE T3.word = 'quipu'"
        ],
        "rule_sql": []
    },
    "3034": {
        "db_id": "shakespeare",
        "question": "What is the name of the character that can be found in paragraph 8 of chapter 18820?",
        "ground_truth": "SELECT T1.CharName FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T2.ParagraphNum = 8 AND T2.chapter_id = 18820",
        "amends": [
            "Do add `INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id` instead of querying only the characters table. Do change the column reference from `character_name` to `T1.CharName` instead of using the original column name. Do move the filter condition from `paragraph = 8` to `T2.ParagraphNum = 8` instead of filtering on the wrong table. Do change the filter condition from `chapter = 18820` to `T2.chapter_id = 18820` instead of filtering on the wrong column and table. The amended query now correctly joins the characters and paragraphs tables and filters on the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM characters WHERE paragraph = 8 AND chapter = 18820;",
            "SELECT T1.CharName \nFROM characters AS T1 \nINNER JOIN paragraphs AS T2 ON T1.id = T2.character_id \nWHERE T2.ParagraphNum = 8 \nAND T2.chapter_id = 18820"
        ],
        "rule_sql": []
    },
    "1318": {
        "db_id": "law_episode",
        "question": "How many 6-star votes did episode 12 get? Please include the air date and rating.",
        "ground_truth": "SELECT T2.air_date, T2.rating FROM Vote AS T1 INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE T1.stars = 6 AND T2.episode = 12",
        "amends": [
            "Do select specific columns `T2.air_date` and `T2.rating` instead of using `COUNT(*) AS vote_count` with additional columns. Do join `Episode AS T2` using `INNER JOIN` on `T2.episode_id = T1.episode_id` instead of querying only the `votes` table. Do filter on `T2.episode = 12` instead of `episode_id = 12` and maintain the `T1.stars = 6` condition. The amended query now correctly retrieves episode details from the Episode table joined with votes data, matching the RIGHT_SQL's behavior.",
            "Do remove `T1.votes` from the SELECT list instead of including it. Do reorder the WHERE clause predicates to `T1.stars = 6 AND T2.episode = 12` instead of `T2.episode = 12 AND T1.stars = 6`, though this is functionally equivalent. The amended query now correctly excludes the votes column and matches the right SQL's behavior.",
            "Do remove `T1.votes` from the SELECT list instead of including it, as the amended query now correctly excludes the votes column from Vote table which was not needed in the final output. The amended query maintains the same INNER JOIN on `T2.episode_id = T1.episode_id` and preserves the WHERE filters `T1.stars = 6 AND T2.episode = 12` without changes. This amendment ensures the query only returns air_date and rating columns as specified in the correct implementation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS vote_count, air_date, rating FROM votes WHERE episode_id = 12 AND stars = 6;",
            "SELECT T2.air_date, T2.rating, T1.votes\nFROM Vote AS T1\nINNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id\nWHERE T2.episode = 12 AND T1.stars = 6",
            "SELECT T2.air_date, T2.rating, T1.votes\nFROM Vote AS T1\nINNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.stars = 6 AND T2.episode = 12",
            "SELECT T2.air_date, T2.rating\nFROM Vote AS T1\nINNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.stars = 6 AND T2.episode = 12"
        ],
        "rule_sql": []
    },
    "7275": {
        "db_id": "works_cycles",
        "question": "How many salespersons haven't met quota?",
        "ground_truth": "SELECT COUNT(BusinessEntityID) FROM SalesPerson WHERE Bonus = 0",
        "amends": [
            "Do count `BusinessEntityID` instead of `*` to exclude null values. Do query from `SalesPerson` table instead of `salespersons` to use the correct table name. Do filter on `Bonus = 0` instead of `sales < quota` to apply the proper condition logic. The amended query now correctly counts salespersons with zero bonus using the appropriate table structure and filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM salespersons WHERE sales < quota;",
            "SELECT COUNT(BusinessEntityID) FROM SalesPerson WHERE Bonus = 0;"
        ],
        "rule_sql": []
    },
    "3478": {
        "db_id": "video_games",
        "question": "What are the genres of games published by the publisher with an ID of 464?",
        "ground_truth": "SELECT DISTINCT T2.genre_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id INNER JOIN game_publisher AS T3 ON T1.id = T3.game_id WHERE T3.publisher_id = 464",
        "amends": [
            "Do use `SELECT DISTINCT T2.genre_name` instead of `SELECT genre` to return unique genre names. Do join `game AS T1` and `genre AS T2` with `INNER JOIN` on `T1.genre_id = T2.id` instead of querying a single table. Do add another `INNER JOIN` to `game_publisher AS T3` on `T1.id = T3.game_id` instead of omitting this relationship. Do move the filter to `WHERE T3.publisher_id = 464` instead of `WHERE publisher_id = 464` to properly reference the joined table. The amended query now correctly retrieves distinct genre names through proper table relationships and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE publisher_id = 464;",
            "SELECT DISTINCT T2.genre_name\nFROM game AS T1\nINNER JOIN genre AS T2 ON T1.genre_id = T2.id\nINNER JOIN game_publisher AS T3 ON T1.id = T3.game_id\nWHERE T3.publisher_id = 464"
        ],
        "rule_sql": []
    },
    "2387": {
        "db_id": "superstore",
        "question": "What are the order date and product name of the order ID CA-2011-137274 from the Central region?",
        "ground_truth": "SELECT T1.`Order Date`, T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.`Order ID` = 'CA-2011-137274' AND T2.Region = 'Central'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.`Order Date`` and `T2.`Product Name`` instead of `order_date` and `product_name`. Do join `central_superstore AS T1` with `product AS T2` instead of querying only the `orders` table. Do use `INNER JOIN` with `T1.`Product ID` = T2.`Product ID`` instead of no join condition. Do filter on `T1.`Order ID` = 'CA-2011-137274'` instead of `order_id = 'CA-2011-137274'`. Do filter on `T2.Region = 'Central'` instead of `region = 'Central'`. The amended query now correctly joins the tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_date, product_name FROM orders WHERE order_id = 'CA-2011-137274' AND region = 'Central';",
            "SELECT T1.\"Order Date\", T2.\"Product Name\"\nFROM central_superstore AS T1\nINNER JOIN product AS T2 ON T1.\"Product ID\" = T2.\"Product ID\"\nWHERE T1.\"Order ID\" = 'CA-2011-137274'\nAND T2.Region = 'Central'"
        ],
        "rule_sql": []
    },
    "2650": {
        "db_id": "regional_sales",
        "question": "How many products sold by Adam Hernandez?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.`Sales Team` = 'Adam Hernandez' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID",
        "amends": [
            "Do use `SUM(CASE WHEN T2.\"Sales Team\" = 'Adam Hernandez' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific records. Do join `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID instead of querying only the products table. Do filter using the CASE expression within the aggregate instead of a WHERE clause on seller_name. Do reference the correct column `T2.\"Sales Team\"` instead of the non-existent `seller_name` column. The amended query now correctly counts sales orders associated with Adam Hernandez's sales team rather than incorrectly counting products by seller name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE seller_name = 'Adam Hernandez';",
            "SELECT SUM(CASE WHEN T2.\"Sales Team\" = 'Adam Hernandez' THEN 1 ELSE 0 END) AS product_count\nFROM \"Sales Orders\" AS T1\nINNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID;"
        ],
        "rule_sql": []
    },
    "8255": {
        "db_id": "mondial_geo",
        "question": "What is the capital city of the country that has the percentage of Armenian speakers over 90%?",
        "ground_truth": "SELECT T1.Capital FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Armenian' AND T2.Percentage > 90",
        "amends": [
            "Do join `country AS T1` with `language AS T2` on `T1.Code = T2.Country` instead of querying only the `countries` table without proper table relationships. Do reference `T2.Name` for the language filter instead of `language` column which doesn't exist in the schema. Do use `T2.Percentage` for the percentage condition instead of `percentage` column from the wrong table context. Do select `T1.Capital` from the joined country table instead of `capital` from a non-existent countries table. The amended query now correctly joins the country and language tables to find capitals where Armenian language percentage exceeds 90%, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT capital FROM countries WHERE language = 'Armenian' AND percentage > 90;",
            "SELECT T1.Capital FROM country AS T1 JOIN language AS T2 ON T1.Code = T2.Country WHERE T2.Name = 'Armenian' AND T2.Percentage > 90"
        ],
        "rule_sql": []
    },
    "966": {
        "db_id": "cs_semester",
        "question": "Among the students with a capability below 3, what is the difference of undergraduate students from research postgraduate students?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.type = 'UG' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.type = 'RPG' THEN 1 ELSE 0 END) FROM RA AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T1.capability < 3",
        "amends": [
            "Do use `SUM(CASE WHEN T2.type = 'UG' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN student_type = 'undergraduate' THEN 1 END)` for proper conditional counting. Do reference `T2.type` instead of `student_type` and use values `'UG'` and `'RPG'` instead of `'undergraduate'` and `'research postgraduate'`. Do change the data source to `RA AS T1 INNER JOIN student AS T2` instead of `students` alone. Do add the join condition `ON T1.student_id = T2.student_id` instead of omitting it. Do change the filter to `T1.capability < 3` instead of `capability > 3` with reversed inequality. The amended query now correctly calculates the difference between undergraduate and research postgraduate students with capability below 3 using proper table joins and conditional aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN student_type = 'undergraduate' THEN 1 END) - \n    COUNT(CASE WHEN student_type = 'research postgraduate' THEN 1 END) AS difference\nFROM students\nWHERE capability > 3;",
            "SELECT \n    SUM(CASE WHEN T2.type = 'UG' THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN T2.type = 'RPG' THEN 1 ELSE 0 END) AS difference\nFROM RA AS T1 \nINNER JOIN student AS T2 ON T1.student_id = T2.student_id\nWHERE T1.capability < 3"
        ],
        "rule_sql": []
    },
    "2511": {
        "db_id": "genes",
        "question": "Which negatively correlated, genetically interacting genes are non-essential? What percentage do they represent with respect to those that are essential?",
        "ground_truth": "SELECT CAST(COUNT(T1.GeneID) AS REAL) * 100 / ( SELECT COUNT(T1.GeneID) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T2.Expression_Corr < 0 ) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T2.Expression_Corr < 0 AND T1.Essential = 'Non-Essential'",
        "amends": [
            "Do use `CAST(COUNT(T1.GeneID) AS REAL) * 100 / (subquery)` instead of `COUNT(CASE WHEN essential = 'non-essential' THEN 1 END) * 100.0 / COUNT(*)` for the percentage calculation. Do change the FROM clause to `Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1` instead of a single table `gene_interactions`. Do modify the WHERE filter to `T2.Expression_Corr < 0 AND T1.Essential = 'Non-Essential'` instead of `correlation > 0 AND genetic_interaction = 'positive'`. Do add a correlated subquery `(SELECT COUNT(T1.GeneID) FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T2.Expression_Corr < 0)` as the denominator instead of a simple table count. Do reference specific table aliases `T1` and `T2` with qualified column names instead of unqualified column references. The amended query now correctly calculates the percentage of non-essential genes among those with negative expression correlation using proper table joins and subquery logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN essential = 'non-essential' THEN 1 END) * 100.0 / COUNT(*) AS percentage_non_essential\nFROM \n    gene_interactions\nWHERE \n    correlation > 0 AND genetic_interaction = 'positive';",
            "SELECT \n    CAST(COUNT(T1.GeneID) AS REAL) * 100 / (SELECT COUNT(T1.GeneID) \n                                          FROM Genes AS T1 \n                                          INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 \n                                          WHERE T2.Expression_Corr < 0) AS Percentage\nFROM Genes AS T1\nINNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1\nWHERE T2.Expression_Corr < 0 AND T1.Essential = 'Non-Essential';"
        ],
        "rule_sql": []
    },
    "5202": {
        "db_id": "address",
        "question": "Calculate the percentage of households in residential areas of countries over 10000.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.households > 10000 THEN T1.zip_code ELSE NULL END) AS REAL) * 100 / COUNT(T1.zip_code) FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code",
        "amends": [
            "Do use `CAST` and `REAL` for percentage calculation instead of implicit decimal conversion. Do select from `country` and `zip_data` tables instead of `households` and `countries`. Do use `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of joining on country_id. Do filter with `CASE WHEN T2.households > 10000` in the aggregate instead of using a WHERE clause on population. Do calculate percentage based on `zip_code` counts instead of residential area types. Do remove explicit GROUP BY and country_name selection instead of grouping by country_name. The amended query now correctly calculates the percentage of zip codes with households exceeding 10000 across all countries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    c.country_name,\n    (COUNT(CASE WHEN h.area_type = 'residential' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_residential\nFROM \n    households h\nJOIN \n    countries c ON h.country_id = c.country_id\nWHERE \n    c.population > 10000\nGROUP BY \n    c.country_name;",
            "SELECT \n    (CAST(COUNT(CASE WHEN T2.households > 10000 THEN 1 END) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    country T1\nINNER JOIN \n    zip_data T2 ON T1.zip_code = T2.zip_code;"
        ],
        "rule_sql": []
    },
    "3405": {
        "db_id": "video_games",
        "question": "Which publisher published the most games?",
        "ground_truth": "SELECT T.publisher_name FROM ( SELECT T1.publisher_name, COUNT(DISTINCT T2.game_id) FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id GROUP BY T1.publisher_name ORDER BY COUNT(DISTINCT T2.game_id) DESC LIMIT 1 ) t",
        "amends": [
            "Do use `T1.publisher_name` from the `publisher` table instead of `publisher` from the `games` table. Do join `publisher AS T1` with `game_publisher AS T2` on `T1.id = T2.publisher_id` instead of querying only the `games` table. Do count `COUNT(DISTINCT T2.game_id)` instead of `COUNT(*)` to count distinct games per publisher. Do order by `COUNT(DISTINCT T2.game_id) DESC` instead of `game_count ASC` to find the publisher with the most games. Do use a subquery structure instead of a simple query to properly handle the aggregation and ordering. The amended query now correctly identifies the publisher with the highest number of distinct games using the proper table relationships and aggregation logic.",
            "Do select only `T.publisher_name` instead of including `game_count` in the output. Do use a subquery to wrap the aggregation instead of selecting directly from the grouped results. Do reference the subquery with alias `t` instead of omitting the alias. Do order by `COUNT(DISTINCT T2.game_id)` directly instead of using the alias `game_count` in the ORDER BY clause. The amended query now correctly returns only the publisher name with the highest distinct game count while maintaining the same aggregation logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher, COUNT(*) as game_count FROM games GROUP BY publisher ORDER BY game_count ASC LIMIT 1;",
            "SELECT T1.publisher_name, COUNT(DISTINCT T2.game_id) AS game_count\nFROM publisher AS T1\nJOIN game_publisher AS T2 ON T1.id = T2.publisher_id\nGROUP BY T1.publisher_name\nORDER BY game_count DESC\nLIMIT 1;",
            "SELECT T1.publisher_name \nFROM publisher AS T1\nJOIN game_publisher AS T2 ON T1.id = T2.publisher_id\nGROUP BY T1.id, T1.publisher_name\nORDER BY COUNT(DISTINCT T2.game_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3680": {
        "db_id": "authors",
        "question": "Mention the name of author for paper id 5 and state the keyword of this page.",
        "ground_truth": "SELECT T1.Name, T3.Keyword FROM Author AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId INNER JOIN Paper AS T3 ON T2.PaperId = T3.Id WHERE T2.PaperId = 5",
        "amends": [
            "Do use explicit table aliases `T1.Name` and `T3.Keyword` instead of ambiguous column references `author_name` and `keyword`. Do add `INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId` and `INNER JOIN Paper AS T3 ON T2.PaperId = T3.Id` instead of querying only the `papers` table. Do change the filter to `T2.PaperId = 5` instead of `paper_id = 5` to properly reference the join table. The amended query now correctly joins the Author, PaperAuthor, and Paper tables to retrieve the author name and keyword for a specific paper ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name, keyword FROM papers WHERE paper_id = 5;",
            "SELECT T1.Name, T3.Keyword\nFROM Author AS T1\nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId\nINNER JOIN Paper AS T3 ON T2.PaperId = T3.Id\nWHERE T2.PaperId = 5"
        ],
        "rule_sql": []
    },
    "3774": {
        "db_id": "public_review_platform",
        "question": "Give the percentage of \"Automotive\" businesses among all the Yelp businesses.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.category_name LIKE 'Automotive' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) AS \"percentage\" FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
        "amends": [
            "Do use `SUM(CASE WHEN T2.category_name LIKE 'Automotive' THEN 1 ELSE 0 END)` instead of `COUNT(*) FILTER (WHERE category = 'Automotive')` for conditional counting. Do join `Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id` instead of querying `yelp_businesses` directly to properly access category relationships. Do reference `T2.category_name` instead of `category` to use the correct column from the joined table. Do use `CAST(... AS REAL)` instead of implicit casting to ensure proper floating-point division. Do calculate percentage as `SUM(...) * 100 / COUNT(T1.business_id)` instead of `(COUNT(...) / COUNT(*)) * 100` to maintain proper business-level counting. Do count `T1.business_id` instead of `*` to avoid potential duplicates from the join. The amended query now correctly handles the business-category relationship and produces accurate percentage calculations.",
            "Do use `LIKE 'Automotive'` instead of `= 'Automotive'` for the category name comparison. Do remove `DISTINCT` from `COUNT(T1.business_id)` instead of keeping it. Do place the multiplication by 100 outside the CAST function instead of inside it. Do use double quotes for the alias `\"percentage\"` instead of no quotes. The amended query now correctly calculates the percentage of automotive businesses without unnecessary DISTINCT and with proper operator usage."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) FILTER (WHERE category = 'Automotive') / COUNT(*)) * 100 AS percentage FROM yelp_businesses;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.category_name = 'Automotive' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT T1.business_id) AS REAL) AS percentage\nFROM \n    Business_Categories AS T1 \nINNER JOIN \n    Categories AS T2 ON T1.category_id = T2.category_id;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.category_name LIKE 'Automotive' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(T1.business_id) AS \"percentage\"\nFROM \n    Business_Categories AS T1 \nINNER JOIN \n    Categories AS T2 ON T1.category_id = T2.category_id"
        ],
        "rule_sql": []
    },
    "323": {
        "db_id": "retail_complains",
        "question": "How many clients who live in New York City submitted their complaints via fax?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'New York City' AND T2.`Submitted via` = 'Fax'",
        "amends": [
            "Do select `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific client records. Do add `INNER JOIN events AS T2` instead of querying only the clients table. Do use join condition `T1.client_id = T2.Client_ID` instead of no join. Do change filter to `T1.city = 'New York City'` instead of `city = 'New York'` for the correct city name. Do change filter to `T2.Submitted via = 'Fax'` instead of `complaint_method = 'fax'` using the proper column name and case from the events table. The amended query now correctly joins tables and uses accurate column references to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE city = 'New York' AND complaint_method = 'fax';",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.city = 'New York City' \nAND T2.\"Submitted via\" = 'Fax'"
        ],
        "rule_sql": []
    },
    "919": {
        "db_id": "cs_semester",
        "question": "Calculate the GPA of the semester for Laughton Antonio.",
        "ground_truth": "SELECT CAST(SUM(T3.credit * CASE T1.grade WHEN 'A' THEN 4 WHEN 'B' THEN 3 WHEN 'C' THEN 2 WHEN 'D' THEN 1 ELSE 1 END) AS REAL) / COUNT(T3.credit) FROM registration AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T1.course_id = T3.course_id WHERE T2.f_name = 'Laughton' AND T2.l_name = 'Antonio'",
        "amends": [
            "Do use `CAST(SUM(T3.credit * CASE T1.grade WHEN 'A' THEN 4 WHEN 'B' THEN 3 WHEN 'C' THEN 2 WHEN 'D' THEN 1 ELSE 1 END) AS REAL) / COUNT(T3.credit)` instead of `AVG(grade)` to calculate weighted GPA instead of simple average. Do join `registration AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T1.course_id = T3.course_id` instead of querying only `grades` table to access student and course information. Do filter with `T2.f_name = 'Laughton' AND T2.l_name = 'Antonio'` instead of `student_name = 'Laughton Antonio'` to match the normalized schema structure. Do remove `semester = 'Fall 2023'` filter instead of keeping it to calculate overall GPA across all semesters. The amended query now correctly calculates the weighted GPA using proper grade point conversion and course credits.",
            "Do use `COUNT(T3.credit)` instead of `SUM(T3.credit)` in the denominator calculation, as this correctly counts the number of courses rather than summing their credit values, which would produce an incorrect GPA calculation by overweighting courses with higher credit values. The amended query now matches RIGHT_SQL's behavior for accurate semester GPA computation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(grade) FROM grades WHERE student_name = 'Laughton Antonio' AND semester = 'Fall 2023';",
            "SELECT CAST(SUM(T3.credit * CASE T1.grade WHEN 'A' THEN 4 WHEN 'B' THEN 3 WHEN 'C' THEN 2 WHEN 'D' THEN 1 ELSE 1 END) AS REAL) / SUM(T3.credit) AS semester_gpa\nFROM registration AS T1 \nINNER JOIN student AS T2 ON T1.student_id = T2.student_id \nINNER JOIN course AS T3 ON T1.course_id = T3.course_id\nWHERE T2.f_name = 'Laughton' AND T2.l_name = 'Antonio'",
            "SELECT CAST(SUM(T3.credit * CASE T1.grade WHEN 'A' THEN 4 WHEN 'B' THEN 3 WHEN 'C' THEN 2 WHEN 'D' THEN 1 ELSE 1 END) AS REAL) / COUNT(T3.credit) AS semester_gpa\nFROM registration AS T1\nINNER JOIN student AS T2 ON T1.student_id = T2.student_id\nINNER JOIN course AS T3 ON T1.course_id = T3.course_id\nWHERE T2.f_name = 'Laughton' AND T2.l_name = 'Antonio'"
        ],
        "rule_sql": []
    },
    "8920": {
        "db_id": "cookbook",
        "question": "List the names of alcohol free recipes.",
        "ground_truth": "SELECT T1.title FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T2.alcohol = 0",
        "amends": [
            "Do select `T1.title` instead of `name` and use table alias `T1` instead of bare table name. Do join `Nutrition AS T2` instead of querying only the `recipes` table, using `INNER JOIN` instead of no join. Do use join condition `T1.recipe_id = T2.recipe_id` instead of no join predicate. Do filter on `T2.alcohol = 0` instead of `alcohol_content > 0`, changing both the column reference and the comparison operator. The amended query now correctly joins the Recipe and Nutrition tables to filter for non-alcoholic recipes based on the alcohol field instead of incorrectly checking for positive alcohol content in a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM recipes WHERE alcohol_content > 0;",
            "SELECT T1.title FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T2.alcohol = 0"
        ],
        "rule_sql": []
    },
    "8559": {
        "db_id": "software_company",
        "question": "List down the customer's reference ID with true response.",
        "ground_truth": "SELECT REFID FROM Mailings1_2 WHERE RESPONSE = 'true'",
        "amends": [
            "Do select `REFID` instead of `customer_id` and use table `Mailings1_2` instead of `customers` while keeping the filter `RESPONSE = 'true'` unchanged. The amended query now correctly retrieves response data from the appropriate table structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id FROM customers WHERE response = 'true';",
            "SELECT REFID FROM Mailings1_2 WHERE RESPONSE = 'true'"
        ],
        "rule_sql": []
    },
    "7176": {
        "db_id": "works_cycles",
        "question": "For the document Control Assistant who was hired on 2009/1/22, what is the percentage of private documents did he/she have?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.DocumentSummary IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.DocumentSummary) FROM Document AS T1 INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE T2.JobTitle = 'Document Control Assistant' AND T2.HireDate = '2009-01-22'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN T1.DocumentSummary IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.DocumentSummary)` instead of `(COUNT(CASE WHEN d.is_private = 1 THEN 1 END) * 100.0 / COUNT(*))` for the percentage calculation. Do join on `T1.Owner = T2.BusinessEntityID` instead of `d.assistant_id = e.employee_id` for the table relationship. Do filter for `T2.JobTitle = 'Document Control Assistant'` instead of `e.position = 'Control Assistant'` to match the correct job title. Do use date format `'2009-01-22'` instead of `'2009/1/22'` for proper date handling. Do reference tables `Document AS T1` and `Employee AS T2` instead of `documents d` and `employees e` with appropriate aliases. The amended query now correctly calculates the percentage of documents with non-null summaries for document control assistants hired on the specified date.",
            "Do remove the multiplication by `* 100` from the percentage calculation instead of including it, as the RIGHT_SQL correctly calculates the ratio without scaling to percentage. Do remove the alias `AS percentage_private_documents` instead of keeping it, as the RIGHT_SQL returns an unaliased result. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity, though this is functionally equivalent. The amended query now correctly returns the ratio of documents with summaries rather than a percentage value, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN d.is_private = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_private\nFROM \n    documents d\nJOIN \n    employees e ON d.assistant_id = e.employee_id\nWHERE \n    e.position = 'Control Assistant' \n    AND e.hire_date = '2009/1/22';",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.DocumentSummary IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.DocumentSummary)) * 100 AS percentage_private_documents\nFROM \n    Document AS T1\nJOIN \n    Employee AS T2 ON T1.Owner = T2.BusinessEntityID\nWHERE \n    T2.JobTitle = 'Document Control Assistant' \n    AND T2.HireDate = '2009-01-22';",
            "SELECT CAST(SUM(CASE WHEN T1.DocumentSummary IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.DocumentSummary)\nFROM Document AS T1\nINNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID\nWHERE T2.JobTitle = 'Document Control Assistant' \nAND T2.HireDate = '2009-01-22'"
        ],
        "rule_sql": []
    },
    "674": {
        "db_id": "codebase_comments",
        "question": "What is the task method of the tokenized name \"string extensions to pascal case\n\"?",
        "ground_truth": "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'string extensions to pascal case'",
        "amends": [
            "Do use `SELECT DISTINCT` instead of omitting the DISTINCT clause to eliminate duplicate results. Do use the `SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1)` expression instead of selecting `task_method` directly to extract the task portion from the Name field. Do alias the extracted result as `task` instead of using the original column name. Do query from the `Method` table instead of the `tokens` table to access the correct data source. Do use the filter condition `NameTokenized = 'string extensions to pascal case'` instead of `tokenized_name = 'string extensions to pascal case'` to reference the correct column name. The amended query now correctly extracts distinct task names from method names using proper string manipulation functions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT task_method FROM tokens WHERE tokenized_name = 'string extensions to pascal case';",
            "SELECT DISTINCT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) AS task FROM Method WHERE NameTokenized = 'string extensions to pascal case'"
        ],
        "rule_sql": []
    },
    "7764": {
        "db_id": "hockey",
        "question": "Please list the names of the teams that had a tie in 1909.",
        "ground_truth": "SELECT T2.name, T3.name FROM TeamVsTeam AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN Teams AS T3 ON T1.year = T3.year AND T1.oppID = T3.tmID WHERE T1.year = 1909 AND T1.T = 1",
        "amends": [
            "Do select `T2.name` and `T3.name` instead of `team_name`. Do use `TeamVsTeam AS T1` as the main source instead of `games`. Do add `INNER JOIN Teams AS T2` on `T1.tmID = T2.tmID AND T1.year = T2.year` instead of no join. Do add `INNER JOIN Teams AS T3` on `T1.year = T3.year AND T1.oppID = T3.tmID` instead of no second join. Do filter on `T1.year = 1909` instead of `year = 1909`. Do filter on `T1.T = 1` instead of `result = 'tie'`. The amended query now correctly retrieves both team names for tied games in 1909 by properly joining through the TeamVsTeam relationship table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM games WHERE year = 1909 AND result = 'tie';",
            "SELECT T2.name, T3.name \nFROM TeamVsTeam AS T1\nINNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nINNER JOIN Teams AS T3 ON T1.year = T3.year AND T1.oppID = T3.tmID\nWHERE T1.year = 1909 AND T1.T = 1"
        ],
        "rule_sql": []
    },
    "9385": {
        "db_id": "movie_3",
        "question": "How many film categories are there?",
        "ground_truth": "SELECT COUNT(DISTINCT category_id) FROM category",
        "amends": [
            "Do reference the `category` table instead of `categories` in the FROM clause. Do use `COUNT(DISTINCT category_id)` instead of `COUNT(*)` to count unique category identifiers rather than all rows. Do remove the `WHERE category_id IS NOT NULL` filter instead of keeping it since COUNT(DISTINCT) inherently ignores NULL values. The amended query now correctly counts distinct non-null category_id values from the category table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM categories WHERE category_id IS NOT NULL;",
            "SELECT COUNT(DISTINCT category_id) FROM category"
        ],
        "rule_sql": []
    },
    "1566": {
        "db_id": "car_retails",
        "question": "Please calculate the total payment amount of customers who come from the USA.",
        "ground_truth": "SELECT SUM(T1.amount) FROM payments AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE T2.country = 'USA'",
        "amends": [
            "Do add `INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber` instead of querying only the `payments` table. Do change the filter to `T2.country = 'USA'` instead of `country = 'USA'` to reference the correct table. Do add table alias `T1` to `amount` instead of using the column without qualification. The amended query now correctly joins the payments and customers tables to filter by customer country instead of attempting to filter payments directly by a country field they don't contain, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM payments WHERE country = 'USA';",
            "SELECT SUM(T1.amount) AS total_payment_amount\nFROM payments AS T1\nINNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber\nWHERE T2.country = 'USA'"
        ],
        "rule_sql": []
    },
    "4504": {
        "db_id": "student_loan",
        "question": "Please provide a disability breakdown for each school.",
        "ground_truth": "SELECT COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T2.name = T1.name GROUP BY T1.school",
        "amends": [
            "Do use `COUNT(T1.name)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do join tables `enrolled AS T1` and `disabled AS T2` with `INNER JOIN` on `T2.name = T1.name` instead of querying a single `students` table. Do group by `T1.school` instead of grouping by both `school_name` and `disability_type`. Do remove the selection of `school_name` and `disability_type` columns instead of including them in the output. The amended query now correctly counts enrolled students with disabilities by school rather than counting all students by school and disability type.",
            "Do remove `T1.school` from the SELECT list instead of including it, and do remove the alias `disability_count` instead of keeping it. Do maintain the same FROM source with `enrolled AS T1` INNER JOIN `disabled AS T2` on `T2.name = T1.name` instead of changing it, and preserve the GROUP BY `T1.school` clause instead of modifying it. The amended query now correctly counts names per school without unnecessary column selection and matches RIGHT_SQL's behavior.",
            "Do remove `T1.school` from the SELECT list instead of including it, as the GROUP BY clause already groups by `T1.school` but the aggregate function `COUNT(T1.name)` should be the only element in the SELECT list when grouping by that column. The amended query now correctly returns only the count of names per school group instead of attempting to select both the school and count values together."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, disability_type, COUNT(*) FROM students GROUP BY school_name, disability_type",
            "SELECT T1.school, COUNT(T1.name) AS disability_count FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T2.name = T1.name GROUP BY T1.school;",
            "SELECT T1.school, COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T2.name = T1.name GROUP BY T1.school",
            "SELECT COUNT(T1.name) FROM enrolled AS T1 INNER JOIN disabled AS T2 ON T2.name = T1.name GROUP BY T1.school"
        ],
        "rule_sql": []
    },
    "3791": {
        "db_id": "public_review_platform",
        "question": "Who has got the most number of \"funny\" type of compliments? Give the user ID.",
        "ground_truth": "SELECT user_id FROM Users_Compliments WHERE compliment_id IN ( SELECT compliment_id FROM Compliments WHERE compliment_type LIKE 'funny' )",
        "amends": [
            "Do reference the `Users_Compliments` table instead of `compliments` and use a subquery to filter by `compliment_type LIKE 'funny'` instead of directly filtering `type = 'funny'` in the main query. Do remove the `GROUP BY user_id`, `ORDER BY COUNT(*) DESC`, and `LIMIT 1` clauses instead of keeping them, as the right query returns all matching user IDs rather than just the top one by count. Do use `compliment_id IN (subquery)` instead of direct filtering and aggregation. The amended query now correctly retrieves all users who received funny compliments without aggregation or ranking, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM compliments WHERE type = 'funny' GROUP BY user_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT user_id FROM Users_Compliments WHERE compliment_id IN (SELECT compliment_id FROM Compliments WHERE compliment_type LIKE 'funny')"
        ],
        "rule_sql": []
    },
    "4232": {
        "db_id": "simpson_episodes",
        "question": "What is the total number of awards won by The simpson 20s: Season 20?",
        "ground_truth": "SELECT COUNT(award_id) FROM Award WHERE result = 'Winner';",
        "amends": [
            "Do count `award_id` instead of `*` to exclude null values. Do reference table `Award` instead of `awards` to use the correct table name. Do filter on `result = 'Winner'` instead of `show_name = 'The simpson 20s: Season 20'` to count only winning awards rather than filtering by show name. The amended query now correctly counts winning awards from the proper table while excluding null values.",
            "Do remove the `season = '20'` filter from the `WHERE` clause instead of keeping it, as the correct logic should count all winners regardless of season rather than restricting to a specific season. The amended query now matches RIGHT_SQL's behavior by counting all award winners without seasonal constraints."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE show_name = 'The simpson 20s: Season 20';",
            "SELECT COUNT(award_id) FROM Award WHERE result = 'Winner' AND season = '20';",
            "SELECT COUNT(award_id) FROM Award WHERE result = 'Winner';"
        ],
        "rule_sql": []
    },
    "9361": {
        "db_id": "movie_3",
        "question": "Among the adult films, how many of them have a rental duration of fewer than 4 days?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE rating = 'NC-17' AND rental_duration < 4",
        "amends": [
            "Do count `film_id` instead of `*` to exclude NULL values. Do filter for `rating = 'NC-17'` instead of `rating = 'R'` to target a different rating category. Do use `rental_duration < 4` instead of `rental_duration > 4` to capture films with shorter rental periods. The amended query now correctly counts NC-17 rated films with rental duration less than 4 days."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film WHERE rating = 'R' AND rental_duration > 4;",
            "SELECT COUNT(film_id) FROM film WHERE rating = 'NC-17' AND rental_duration < 4"
        ],
        "rule_sql": []
    },
    "3091": {
        "db_id": "cars",
        "question": "What is the name of the most expensive car?",
        "ground_truth": "SELECT T1.car_name FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY T2.price DESC LIMIT 1",
        "amends": [
            "Do select `T1.car_name` from the `data` table instead of `name` from the `cars` table. Do add an `INNER JOIN` with the `price` table on `T1.ID = T2.ID` instead of querying a single table. Do order by `T2.price DESC` instead of `price ASC`. The amended query now correctly joins the data and price tables to retrieve car names ordered by price in descending order, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cars ORDER BY price ASC LIMIT 1;",
            "SELECT T1.car_name FROM data T1 INNER JOIN price T2 ON T1.ID = T2.ID ORDER BY T2.price DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "3028": {
        "db_id": "shakespeare",
        "question": "How many \"all\" character names have the \"all\" abbreviation?",
        "ground_truth": "SELECT COUNT(id) FROM characters WHERE Abbrev = 'All'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do filter on `Abbrev = 'All'` instead of `name = 'all' AND abbreviation = 'all'` to use the correct column name and single condition. Do remove the `name` filter entirely instead of including it since it's not needed for the correct logic. The amended query now correctly counts records where the abbreviation matches 'All' using the proper column name and avoids unnecessary conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM characters WHERE name = 'all' AND abbreviation = 'all';",
            "SELECT COUNT(id) FROM characters WHERE Abbrev = 'All';"
        ],
        "rule_sql": []
    },
    "6100": {
        "db_id": "books",
        "question": "What is the title of the book in the order ID 931?",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T2.order_id = 931",
        "amends": [
            "Do add `INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id` instead of querying only the `books` table. Do reference `T2.order_id` in the WHERE clause instead of `order_id` from the base table. Do use table alias `T1.title` instead of just `title` to specify the source table. The amended query now correctly joins the book and order_line tables to filter by order_id in the related table instead of incorrectly assuming order_id exists in the books table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE order_id = 931;",
            "SELECT T1.title FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T2.order_id = 931"
        ],
        "rule_sql": []
    },
    "3677": {
        "db_id": "authors",
        "question": "How many papers were written by authors who cooperated with University of Hong Kong?",
        "ground_truth": "SELECT COUNT(T2.PaperId) FROM Author AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId WHERE T1.Affiliation = 'University of Hong Kong'",
        "amends": [
            "Do select `COUNT(T2.PaperId)` instead of `COUNT(*)` to count specific paper IDs rather than all rows. Do use `Author AS T1` and `PaperAuthor AS T2` tables instead of just `papers` to properly model the relationship between authors and their papers. Do perform an `INNER JOIN` on `T1.Id = T2.AuthorId` instead of querying a single table to correctly link authors with their publications. Do filter on `T1.Affiliation = 'University of Hong Kong'` instead of `author = 'University of Hong Kong'` to search by institutional affiliation rather than author name. The amended query now correctly counts papers by authors affiliated with the specified university, matching the intended behavior.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the query should count all paper IDs from authors at the University of Hong Kong rather than counting distinct paper IDs. The amended query now matches RIGHT_SQL's behavior by returning the total count of papers rather than the count of distinct papers."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM papers WHERE author = 'University of Hong Kong';",
            "SELECT COUNT(DISTINCT T2.PaperId) \nFROM Author AS T1 \nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId \nWHERE T1.Affiliation = 'University of Hong Kong'",
            "SELECT COUNT(T2.PaperId) \nFROM Author AS T1 \nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId \nWHERE T1.Affiliation = 'University of Hong Kong'"
        ],
        "rule_sql": []
    },
    "829": {
        "db_id": "social_media",
        "question": "Write down the tweet text posted from Rawang, Selangor, Malaysia.",
        "ground_truth": "SELECT T1.text FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.City = 'Rawang' AND T2.State = 'Selangor' AND T2.Country = 'Malaysia'",
        "amends": [
            "Do select `T1.text` instead of `tweet_text`. Do use `twitter AS T1` and `location AS T2` as table sources instead of just `tweets`. Do add `INNER JOIN` on `T1.LocationID = T2.LocationID` instead of no join. Do change the filter to `T2.City = 'Rawang' AND T2.State = 'Selangor' AND T2.Country = 'Malaysia'` instead of `location = 'Rawang, Malaysia'` to properly match normalized location data. The amended query now correctly joins tables and uses precise location criteria to match the intended results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tweet_text FROM tweets WHERE location = 'Rawang, Malaysia';",
            "SELECT T1.text FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.City = 'Rawang' AND T2.State = 'Selangor' AND T2.Country = 'Malaysia'"
        ],
        "rule_sql": []
    },
    "5576": {
        "db_id": "menu",
        "question": "How much space does page 1 of the menu \"Zentral Theater Terrace\" cover?",
        "ground_truth": "SELECT T2.full_height * T2.full_width FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE T1.name = 'Zentral Theater Terrace' AND T2.page_number = 1",
        "amends": [
            "Do select `T2.full_height * T2.full_width` instead of `SUM(area)` to calculate the area from individual dimensions rather than summing a precomputed area column. Do use `FROM Menu AS T1 INNER JOIN MenuPage AS T2` instead of `FROM menu_pages` to properly join the Menu and MenuPage tables. Do add the join condition `ON T1.id = T2.menu_id` instead of omitting it to correctly relate menu pages to their parent menus. Do change the filter to `T1.name = 'Zentral Theater Terrace'` instead of `menu_name = 'Zentral Theater Terrace'` to filter on the menu name from the correct table. Do keep `T2.page_number = 1` as the page filter but apply it to the joined MenuPage table instead of the original single table. The amended query now correctly calculates individual page areas by joining related tables and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(area) FROM menu_pages WHERE menu_name = 'Zentral Theater Terrace' AND page_number = 1",
            "SELECT T2.full_height * T2.full_width AS area\nFROM Menu AS T1\nINNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id\nWHERE T1.name = 'Zentral Theater Terrace' AND T2.page_number = 1;"
        ],
        "rule_sql": []
    },
    "3093": {
        "db_id": "cars",
        "question": "How much is the car with the highest sweep volume?",
        "ground_truth": "SELECT T2.price FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY T1.displacement / T1.cylinders DESC LIMIT 1",
        "amends": [
            "Do select `T2.price` instead of `MAX(sweep_volume)`. Do use `FROM data AS T1 INNER JOIN price AS T2` instead of `FROM cars`. Do add join condition `ON T1.ID = T2.ID` instead of omitting it. Do remove the subquery filter `WHERE sweep_volume = (SELECT MIN(sweep_volume) FROM cars)` instead of keeping it. Do add `ORDER BY T1.displacement / T1.cylinders DESC` instead of omitting it. Do add `LIMIT 1` instead of omitting it. The amended query now correctly joins tables and retrieves the highest price based on displacement per cylinder ratio rather than finding maximum sweep volume matching minimum sweep volume."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(sweep_volume) FROM cars WHERE sweep_volume = (SELECT MIN(sweep_volume) FROM cars);",
            "SELECT T2.price \nFROM data AS T1 \nINNER JOIN price AS T2 ON T1.ID = T2.ID \nORDER BY T1.displacement / T1.cylinders DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4451": {
        "db_id": "student_loan",
        "question": "Which female students had never been absent?",
        "ground_truth": "SELECT T2.name FROM male AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name <> T2.name WHERE T2.month = 0",
        "amends": [
            "Do select only `T2.name` instead of all columns with `*`. Do use `FROM male AS T1 INNER JOIN longest_absense_from_school AS T2` instead of `FROM students`. Do use join condition `ON T1.name <> T2.name` instead of filtering by `gender = 'female'`. Do add filter `WHERE T2.month = 0` instead of `absences = 0`. The amended query now correctly joins the male table with the longest absence table using a non-equality condition and filters for zero month values, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE gender = 'female' AND absences = 0;",
            "SELECT T2.name FROM male AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name <> T2.name WHERE T2.month = 0"
        ],
        "rule_sql": []
    },
    "2084": {
        "db_id": "music_tracker",
        "question": "Please list all tags of kurtis blow from 2000 to 2010.",
        "ground_truth": "SELECT T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.groupYear BETWEEN 2000 AND 2010 AND T1.artist LIKE 'kurtis blow'",
        "amends": [
            "Do select `T2.tag` from the `tags` table instead of `tag` from `artists`. Do join `torrents AS T1` with `tags AS T2` using `INNER JOIN` on `T1.id = T2.id` instead of querying only the `artists` table. Do filter on `T1.groupYear BETWEEN 2000 AND 2010` instead of `year BETWEEN 2000 AND 2010`. Do use `T1.artist LIKE 'kurtis blow'` instead of `name = 'kurtis blow'`. The amended query now correctly joins the torrents and tags tables to retrieve tags associated with Kurtis Blow's music from the specified year range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tag FROM artists WHERE name = 'kurtis blow' AND year BETWEEN 2000 AND 2010;",
            "SELECT T2.tag FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T1.artist LIKE 'kurtis blow' AND T1.groupYear BETWEEN 2000 AND 2010"
        ],
        "rule_sql": []
    },
    "9056": {
        "db_id": "bike_share_1",
        "question": "What was the mean humidity of a trip with id 4275?",
        "ground_truth": "SELECT T2.mean_humidity FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T1.id = 4275",
        "amends": [
            "Do select `T2.mean_humidity` instead of `AVG(temperature)` and change the source from `trips` to `trip AS T1 INNER JOIN weather AS T2` instead of a single table. Do add the join condition `ON T2.zip_code = T1.zip_code` instead of omitting it. Do change the filter to `T1.id = 4275` instead of `trip_id = 4275` and move it from the trips table to the trip table. The amended query now correctly joins the trip and weather tables to retrieve mean_humidity for the specified trip ID, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(temperature) FROM trips WHERE trip_id = 4275;",
            "SELECT T2.mean_humidity\nFROM trip AS T1\nINNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code\nWHERE T1.id = 4275"
        ],
        "rule_sql": []
    },
    "7039": {
        "db_id": "works_cycles",
        "question": "Which store sales person was reently hired? Indicate his/her full name and gender.",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName, T1.Gender FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.PersonType = 'SP'",
        "amends": [
            "Do select `T2.FirstName`, `T2.MiddleName`, `T2.LastName`, and `T1.Gender` instead of only `first_name`, `last_name`, and `gender`. Do use `FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` instead of `FROM sales_persons`. Do add `WHERE T2.PersonType = 'SP'` instead of omitting this filter. Do remove `ORDER BY hire_date DESC LIMIT 1` instead of keeping this ordering and limiting clause. The amended query now correctly joins the Employee and Person tables to retrieve sales personnel with the appropriate filtering and returns all matching records instead of just the most recently hired one."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, gender FROM sales_persons ORDER BY hire_date DESC LIMIT 1;",
            "SELECT T2.FirstName, T2.MiddleName, T2.LastName, T1.Gender\nFROM Employee AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T2.PersonType = 'SP'"
        ],
        "rule_sql": []
    },
    "3708": {
        "db_id": "college_completion",
        "question": "Among the public institutes in the state of Alabama, how many of them have over 30 students who graduated within 100 percent of normal/expected time in 2011?",
        "ground_truth": "SELECT COUNT(T1.chronname) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.state = 'Alabama' AND T1.control = 'Public' AND T2.year = 2011 AND T2.grad_100 > 30",
        "amends": [
            "Do select `COUNT(T1.chronname)` instead of `COUNT(*)` to count specific institution names rather than all rows. Do use tables `institution_details AS T1` and `institution_grads AS T2` instead of a single `institutes` table to properly separate institutional details from graduation data. Do perform an `INNER JOIN` on `T2.unitid = T1.unitid` instead of querying a single table to correctly relate graduation records to their respective institutions. Do filter by `T1.state = 'Alabama'` instead of `state = 'Alabama'` with proper table qualification. Do use `T1.control = 'Public'` instead of `public = 1` to match the correct categorical value format. Do add `T2.year = 2011` instead of omitting the year filter to specifically target 2011 graduation data. Do use `T2.grad_100 > 30` instead of `graduates_2011 > 30 AND completion_rate = 100` to correctly filter for institutions with more than 30 graduates who completed in 100% normal time. Do remove the incorrect `completion_rate = 100` condition instead of keeping it since the graduation completion logic is now properly handled through the join and `grad_100` filter. The amended query now correctly counts public Alabama institutions with more than 30 graduates in 2011 who completed in normal time."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM institutes WHERE state = 'Alabama' AND public = 1 AND graduates_2011 > 30 AND completion_rate = 100;",
            "SELECT COUNT(T1.chronname) \nFROM institution_details AS T1\nINNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid\nWHERE T1.state = 'Alabama' \nAND T1.control = 'Public'\nAND T2.year = 2011\nAND T2.grad_100 > 30"
        ],
        "rule_sql": []
    },
    "9134": {
        "db_id": "movie_3",
        "question": "Please give the full name of the customer that have rented the most films.",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T1.first_name, T1.last_name, COUNT(T2.rental_id) AS num FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.first_name, T1.last_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name \nFROM customer c\nJOIN rental r ON c.customer_id = r.customer_id\nGROUP BY c.customer_id\nORDER BY COUNT(r.rental_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5713": {
        "db_id": "language_corpus",
        "question": "Is word id \"88\" the word id for title \"Animals\"?",
        "ground_truth": "SELECT CASE WHEN COUNT(T1.pid) > 0 THEN 'YES' ELSE 'NO' END AS YORN FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T2.wid = 88 AND T1.title = 'Animals'",
        "amends": [
            "Do use a `CASE` expression with `COUNT(T1.pid)` to return 'YES' or 'NO' instead of selecting all columns with `*`. Do join `pages AS T1` and `pages_words AS T2` with `INNER JOIN` on `T1.pid = T2.pid` instead of querying only the `words` table. Do filter on `T2.wid = 88` and `T1.title = 'Animals'` instead of filtering on `word_id = 88` and `title = 'Animals'` from the wrong table. The amended query now correctly checks for the existence of related records and returns the appropriate boolean indicator instead of raw data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM words WHERE word_id = 88 AND title = 'Animals';",
            "SELECT CASE WHEN COUNT(T1.pid) > 0 THEN 'YES' ELSE 'NO' END AS result\nFROM pages AS T1\nINNER JOIN pages_words AS T2 ON T1.pid = T2.pid\nWHERE T2.wid = 88 AND T1.title = 'Animals';"
        ],
        "rule_sql": []
    },
    "2209": {
        "db_id": "world_development_indicators",
        "question": "What was the deposit interest rate in the Commonwealth of Australia in 1979 in percentage?",
        "ground_truth": "SELECT T1.Value FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.LongName = 'Commonwealth of Australia' AND T1.IndicatorName = 'Deposit interest rate (%)' AND T1.Year = 1979",
        "amends": [
            "Do select `T1.Value` instead of `interest_rate`. Do use `FROM Indicators AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode` instead of `FROM australia_deposits`. Do add join condition `T1.CountryCode = T2.CountryCode` instead of omitting it. Do change filter to `T2.LongName = 'Commonwealth of Australia'` instead of `country = 'Commonwealth of Australia'`. Do add filter `T1.IndicatorName = 'Deposit interest rate (%)'` instead of omitting it. Do change year filter to `T1.Year = 1979` instead of `year = 1979`. The amended query now correctly joins the necessary tables and applies proper filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT interest_rate FROM australia_deposits WHERE country = 'Commonwealth of Australia' AND year = 1979;",
            "SELECT T1.Value \nFROM Indicators AS T1 \nINNER JOIN Country AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.LongName = 'Commonwealth of Australia' \nAND T1.IndicatorName = 'Deposit interest rate (%)' \nAND T1.Year = 1979"
        ],
        "rule_sql": []
    },
    "2140": {
        "db_id": "world_development_indicators",
        "question": "Please list annual indicator names which have values of more than 100 in 1965.",
        "ground_truth": "SELECT DISTINCT T2.IndicatorName FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE T1.Year = 1965 AND T1.Value > 100 AND T2.Periodicity = 'Annual'",
        "amends": [
            "Do use `DISTINCT T2.IndicatorName` instead of `indicator_name` without distinct. Do join `Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName` instead of querying only `annual_data`. Do add filter `T2.Periodicity = 'Annual'` instead of omitting it. Do use `T1.Year = 1965` and `T1.Value > 100` instead of filtering on the wrong table's columns. The amended query now correctly joins the necessary tables and applies proper filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT indicator_name FROM annual_data WHERE year = 1965 AND value > 100;",
            "SELECT DISTINCT T2.IndicatorName\nFROM Indicators AS T1\nINNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName\nWHERE T1.Year = 1965\nAND T1.Value > 100\nAND T2.Periodicity = 'Annual'"
        ],
        "rule_sql": []
    },
    "4517": {
        "db_id": "student_loan",
        "question": "Calculate the average duration of absense of disabled male students.",
        "ground_truth": "SELECT AVG(T1.month) FROM longest_absense_from_school AS T1 INNER JOIN disabled AS T2 ON T2.name = T1.name INNER JOIN male AS T3 ON T3.name = T2.name",
        "amends": [
            "Do select `AVG(T1.month)` from the `longest_absense_from_school` table instead of `AVG(duration)` from the `absences` table. Do use `INNER JOIN disabled AS T2 ON T2.name = T1.name` and `INNER JOIN male AS T3 ON T3.name = T2.name` instead of filtering with `WHERE gender = 'male' AND disabled = 1`. Do completely change the data source from the `absences` table to joining `longest_absense_from_school`, `disabled`, and `male` tables on name relationships instead of using a single table with direct filters. The amended query now correctly calculates the average month from the appropriate joined tables rather than averaging duration from a single table with potentially incorrect filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM absences WHERE gender = 'male' AND disabled = 1;",
            "SELECT AVG(T1.month) \nFROM longest_absense_from_school AS T1\nINNER JOIN disabled AS T2 ON T2.name = T1.name\nINNER JOIN male AS T3 ON T3.name = T2.name"
        ],
        "rule_sql": []
    },
    "8351": {
        "db_id": "mondial_geo",
        "question": "What is the name of the country whose citizens have the lowest purchasing power?",
        "ground_truth": "SELECT T2.Name FROM economy AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code ORDER BY T1.Inflation DESC LIMIT 1",
        "amends": [
            "Do select `T2.Name` from the `country` table instead of `country_name` from the `countries` table. Do join `economy AS T1` with `country AS T2` using `INNER JOIN` on `T1.Country = T2.Code` instead of querying a single table. Do order by `T1.Inflation DESC` instead of `purchasing_power DESC` to sort by the correct economic indicator. The amended query now correctly retrieves the country name with the highest inflation rate by joining the economy and country tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries ORDER BY purchasing_power DESC LIMIT 1;",
            "SELECT T2.Name \nFROM economy AS T1 \nINNER JOIN country AS T2 ON T1.Country = T2.Code \nORDER BY T1.Inflation DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8365": {
        "db_id": "mondial_geo",
        "question": "How many lakes are there in the 4th most populous African country with a republican form of government?",
        "ground_truth": "SELECT COUNT(*) FROM geo_lake WHERE Country = ( SELECT T4.Code FROM ( SELECT T2.Code, T2.Population FROM encompasses AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code INNER JOIN politics AS T3 ON T1.Country = T3.Country WHERE T1.Continent = 'Africa' AND T1.Percentage = 100 AND T3.Government = 'republic' ORDER BY Population DESC LIMIT 4 ) AS T4 ORDER BY population ASC LIMIT 1 )",
        "amends": [
            "Do use a subquery to find the country code instead of directly joining tables. Do reference `geo_lake` table instead of `lakes` and use `Country` column instead of `country_id` for filtering. Do add a nested subquery with proper table aliases `T1`, `T2`, `T3`, and `T4` instead of simple table joins. Do filter on `T1.Continent = 'Africa'` and `T1.Percentage = 100` instead of just `continent = 'Africa'`. Do use `T3.Government = 'republic'` instead of `government_form = 'Republic'` with different case sensitivity. Do order by `Population DESC` with `LIMIT 4` in the inner query instead of ordering by `population DESC` with `LIMIT 1 OFFSET 3`. Do add a second ordering by `population ASC` with `LIMIT 1` on the outer subquery result instead of applying offset directly. Do remove the explicit `ORDER BY` and `LIMIT/OFFSET` from the main query since the filtering is now handled through the subquery. The amended query now correctly identifies the fourth most populous African republic country with 100% continent coverage and counts lakes in that specific country, matching the RIGHT_SQL's behavior.",
            "Do use `INNER JOIN` with `country AS T2` on `T1.Country = T2.Code` instead of the nested subquery approach, and do add `INNER JOIN` with `politics AS T3` on `T1.Country = T3.Country` instead of omitting it. Do move the `Government = 'republic'` filter to the `politics` table join condition instead of keeping it in the `WHERE` clause of the country subquery. Do remove the unnecessary `T2.Government` column from the intermediate selection instead of including it. Do use direct column references `Population` and `population` instead of fully qualified `T3.Population` and `T4.Population` in the ordering clauses. Do remove the `AS lake_count` alias from the outer `COUNT(*)` instead of keeping it. The amended query now correctly joins the necessary tables and matches the RIGHT_SQL's behavior.",
            "Do select `T4.Code` instead of `T1.Country` in the subquery's SELECT list. Do move the `T3.Government = 'republic'` filter from the JOIN condition to the WHERE clause instead of keeping it in the ON predicate. Do remove the redundant table alias `T1.Country` in the outer subquery and use `T4.Code` instead. Do reference `Population` and `population` directly without table aliases in the ORDER BY clauses instead of using `T2.Population` and `T4.Population`. The amended query now correctly identifies countries by their code rather than name and properly filters for republic governments, matching the RIGHT_SQL's behavior.",
            "Do select `T2.Code` instead of `T1.Country` in the subquery's SELECT list to ensure the correct country code is returned for comparison. Do reference `Population` without table alias instead of `T4.Population` in the outer ORDER BY to maintain consistency with the subquery's column selection. Do use lowercase `population` instead of `T4.Population` in the final ORDER BY to match the column alias from the subquery. The amended query now correctly identifies the country with the smallest population among the four largest African republics to count the corresponding lakes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM lakes l\nJOIN countries c ON l.country_id = c.id\nWHERE c.continent = 'Africa' \nAND c.government_form = 'Republic'\nORDER BY c.population DESC\nLIMIT 1 OFFSET 3;",
            "SELECT COUNT(*) AS lake_count\nFROM geo_lake\nWHERE Country = (\n    SELECT T4.Code\n    FROM (\n        SELECT T3.Code, T3.Population\n        FROM (\n            SELECT T2.Code, T2.Population, T2.Government\n            FROM (\n                SELECT T1.Country\n                FROM encompasses T1\n                WHERE T1.Continent = 'Africa' AND T1.Percentage = 100\n            ) AS african_countries\n            JOIN country T2 ON african_countries.Country = T2.Code\n            WHERE T2.Government = 'republic'\n        ) AS T3\n        ORDER BY T3.Population DESC\n        LIMIT 4\n    ) AS T4\n    ORDER BY T4.Population ASC\n    LIMIT 1\n)",
            "SELECT COUNT(*)\nFROM geo_lake\nWHERE Country = (\n    SELECT T1.Country\n    FROM (\n        SELECT T1.Country, T2.Population\n        FROM encompasses AS T1\n        INNER JOIN country AS T2 ON T1.Country = T2.Code\n        INNER JOIN politics AS T3 ON T1.Country = T3.Country AND T3.Government = 'republic'\n        WHERE T1.Continent = 'Africa' AND T1.Percentage = 100\n        ORDER BY T2.Population DESC\n        LIMIT 4\n    ) AS T4\n    ORDER BY T4.Population ASC\n    LIMIT 1\n)",
            "SELECT COUNT(*)\nFROM geo_lake\nWHERE Country = (\n    SELECT T4.Code\n    FROM (\n        SELECT T1.Country, T2.Population\n        FROM encompasses AS T1\n        INNER JOIN country AS T2 ON T1.Country = T2.Code\n        INNER JOIN politics AS T3 ON T1.Country = T3.Country\n        WHERE T1.Continent = 'Africa' \n          AND T1.Percentage = 100\n          AND T3.Government = 'republic'\n        ORDER BY T2.Population DESC\n        LIMIT 4\n    ) AS T4\n    ORDER BY T4.Population ASC\n    LIMIT 1\n)",
            "SELECT COUNT(*)\nFROM geo_lake\nWHERE Country = (\n    SELECT T4.Code\n    FROM (\n        SELECT T2.Code, T2.Population\n        FROM encompasses AS T1\n        INNER JOIN country AS T2 ON T1.Country = T2.Code\n        INNER JOIN politics AS T3 ON T1.Country = T3.Country\n        WHERE T1.Continent = 'Africa' \n          AND T1.Percentage = 100\n          AND T3.Government = 'republic'\n        ORDER BY Population DESC\n        LIMIT 4\n    ) AS T4\n    ORDER BY population ASC\n    LIMIT 1\n)"
        ],
        "rule_sql": []
    },
    "870": {
        "db_id": "cs_semester",
        "question": "What is the average gpa of Ogdon Zywicki's research assistants?",
        "ground_truth": "SELECT SUM(T3.gpa) / COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id INNER JOIN student AS T3 ON T1.student_id = T3.student_id WHERE T2.first_name = 'Ogdon' AND T2.last_name = 'Zywicki'",
        "amends": [
            "Do use `SUM(T3.gpa) / COUNT(T1.student_id)` instead of `AVG(gpa)` to calculate the average manually. Do join tables `RA AS T1`, `prof AS T2`, and `student AS T3` instead of querying only `students`. Do use `INNER JOIN` on `T1.prof_id = T2.prof_id` and `T1.student_id = T3.student_id` instead of no joins. Do filter on `T2.first_name = 'Ogdon' AND T2.last_name = 'Zywicki'` instead of `name = 'Ogdon Zywicki' AND role = 'research assistant'`. The amended query now correctly calculates the average GPA for research assistants working under Professor Ogdon Zywicki by properly joining the relevant tables and using accurate filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(gpa) FROM students WHERE name = 'Ogdon Zywicki' AND role = 'research assistant';",
            "SELECT SUM(T3.gpa) / COUNT(T1.student_id) AS average_gpa\nFROM RA AS T1\nINNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id\nINNER JOIN student AS T3 ON T1.student_id = T3.student_id\nWHERE T2.first_name = 'Ogdon' AND T2.last_name = 'Zywicki'"
        ],
        "rule_sql": []
    },
    "883": {
        "db_id": "cs_semester",
        "question": "Provide the number of students enrolled in the \"Statistical Learning\" course.",
        "ground_truth": "SELECT COUNT(T2.student_id) FROM course AS T1 INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE T1.name = 'Statistical learning'",
        "amends": [
            "Do specify `COUNT(T2.student_id)` instead of `COUNT(*)` to count actual student registrations rather than all rows. Do join tables `course AS T1 INNER JOIN registration AS T2` instead of querying only the `students` table to properly relate courses to registrations. Do use the join condition `ON T1.course_id = T2.course_id` instead of no join to correctly link courses with their registrations. Do filter on `T1.name = 'Statistical learning'` instead of `course_name = 'Statistical Learning'` to use the proper table column name and case sensitivity. The amended query now correctly counts students registered for the specified course by properly joining the course and registration tables.",
            "Do use lowercase 'Statistical learning' in the WHERE filter instead of 'Statistical Learning' to ensure case-sensitive matching accuracy. The amended query now correctly matches the RIGHT_SQL's behavior with proper text case handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE course_name = 'Statistical Learning';",
            "SELECT COUNT(T2.student_id) \nFROM course AS T1 \nINNER JOIN registration AS T2 ON T1.course_id = T2.course_id \nWHERE T1.name = 'Statistical Learning'",
            "SELECT COUNT(T2.student_id) \nFROM course AS T1 \nINNER JOIN registration AS T2 ON T1.course_id = T2.course_id \nWHERE T1.name = 'Statistical learning'"
        ],
        "rule_sql": []
    },
    "2091": {
        "db_id": "world_development_indicators",
        "question": "Please list the countries under the lending category of the International Development Associations and have a external debt reporting finished by estimation.",
        "ground_truth": "SELECT ShortName, ExternalDebtReportingStatus FROM Country WHERE LendingCategory = 'IDA'",
        "amends": [
            "Do select `ShortName` and `ExternalDebtReportingStatus` instead of just `country`. Do use table `Country` instead of `lending_categories`. Do filter on `LendingCategory = 'IDA'` instead of `category = 'International Development Associations'`. Do remove the additional filter on `external_debt_reporting = 'finished by estimation'` instead of keeping it. The amended query now correctly retrieves the country short names and their external debt reporting status for IDA lending category countries."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM lending_categories WHERE category = 'International Development Associations' AND external_debt_reporting = 'finished by estimation';",
            "SELECT ShortName, ExternalDebtReportingStatus FROM Country WHERE LendingCategory = 'IDA';"
        ],
        "rule_sql": []
    },
    "182": {
        "db_id": "book_publishing_company",
        "question": "Which employee has the lowest job level. State the first name, last name and when he /she was hired.",
        "ground_truth": "SELECT fname, lname, hire_date FROM employee ORDER BY job_lvl LIMIT 1",
        "amends": [
            "Do select `fname` and `lname` instead of `first_name` and `last_name`. Do reference table `employee` instead of `employees`. Do order by `job_lvl` instead of `job_level`. Do use ascending order instead of descending order. The amended query now correctly retrieves the employee with the highest job level using the proper column names and table reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, hire_date FROM employees ORDER BY job_level DESC LIMIT 1;",
            "SELECT fname, lname, hire_date FROM employee ORDER BY job_lvl ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "561": {
        "db_id": "movies_4",
        "question": "Which movies have the participation of actor Harrison Ford?",
        "ground_truth": "SELECT T1.title FROM movie AS T1 INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T3.person_name = 'Harrison Ford'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `m` and `a`. Do join `movie_cast AS T2` instead of directly joining an actors table. Do use join condition `T1.movie_id = T2.movie_id` instead of `m.actor_id = a.id`. Do add a second join to `person AS T3` with condition `T2.person_id = T3.person_id` instead of a single join. Do filter on `T3.person_name = 'Harrison Ford'` instead of `a.name = 'Harrison Ford'`. Do reference column `T1.title` instead of `m.title`. The amended query now correctly navigates through the movie_cast bridge table to find movies featuring Harrison Ford, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title FROM movies m JOIN actors a ON m.actor_id = a.id WHERE a.name = 'Harrison Ford';",
            "SELECT T1.title\nFROM movie AS T1\nJOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id\nJOIN person AS T3 ON T2.person_id = T3.person_id\nWHERE T3.person_name = 'Harrison Ford'"
        ],
        "rule_sql": []
    },
    "1552": {
        "db_id": "car_retails",
        "question": "How many checks were issued by Euro+ Shopping Channel in the year 2004?",
        "ground_truth": "SELECT COUNT(T1.checkNumber) FROM payments AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE customerName = 'Euro+ Shopping Channel' AND STRFTIME('%Y', T1.paymentDate) = '2004'",
        "amends": [
            "Do select `COUNT(T1.checkNumber)` from the `payments` table instead of `COUNT(*)` from the `checks` table. Do join `customers AS T2` with `payments AS T1` using `T1.customerNumber = T2.customerNumber` instead of querying a single table. Do filter by `customerName = 'Euro+ Shopping Channel'` instead of `issuer = 'Euro+ Shopping Channel'`. Do use `STRFTIME('%Y', T1.paymentDate) = '2004'` for year extraction instead of a simple `year = 2004` column comparison. The amended query now correctly counts payments from the specified customer in 2004 using the proper table relationships and date handling."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM checks WHERE issuer = 'Euro+ Shopping Channel' AND year = 2004;",
            "SELECT COUNT(T1.checkNumber) \nFROM payments AS T1\nJOIN customers AS T2 ON T1.customerNumber = T2.customerNumber\nWHERE T2.customerName = 'Euro+ Shopping Channel'\nAND STRFTIME('%Y', T1.paymentDate) = '2004'"
        ],
        "rule_sql": []
    },
    "3853": {
        "db_id": "public_review_platform",
        "question": "Please list the business IDs of all the Yelp_Businesses that are good for kids.",
        "ground_truth": "SELECT T2.business_id FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name LIKE 'Good for Kids' AND T2.attribute_value LIKE 'TRUE'",
        "amends": [
            "Do select `T2.business_id` from the joined result instead of directly selecting `business_id` from a single table. Do join `Attributes AS T1` and `Business_Attributes AS T2` with an `INNER JOIN` on `T1.attribute_id = T2.attribute_id` instead of querying only `Yelp_Businesses` without any joins. Do filter on `T1.attribute_name LIKE 'Good for Kids'` and `T2.attribute_value LIKE 'TRUE'` instead of using `good_for_kids = 'no'` which incorrectly assumes the column exists in the original table and uses the wrong value format. The amended query correctly accesses the normalized attribute data structure to find businesses where the 'Good for Kids' attribute is set to 'TRUE', fixing the logical error in the original query that used non-existent columns and incorrect filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM Yelp_Businesses WHERE good_for_kids = 'no';",
            "SELECT T2.business_id\nFROM Attributes AS T1\nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\nWHERE T1.attribute_name LIKE 'Good for Kids'\nAND T2.attribute_value LIKE 'TRUE'"
        ],
        "rule_sql": []
    },
    "7549": {
        "db_id": "image_and_language",
        "question": "Count the image numbers that contain the \"paint\" object.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.IMG_ID) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'paint'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.IMG_ID)` instead of `COUNT(*)` to count distinct image IDs rather than all rows. Do join `IMG_OBJ AS T1` and `OBJ_CLASSES AS T2` with `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single `images` table. Do filter on `T2.OBJ_CLASS = 'paint'` instead of `object = 'paint'` to properly reference the joined classification table. The amended query now correctly counts distinct images associated with the 'paint' object class through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE object = 'paint';",
            "SELECT COUNT(DISTINCT T1.IMG_ID) \nFROM IMG_OBJ AS T1 \nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID \nWHERE T2.OBJ_CLASS = 'paint'"
        ],
        "rule_sql": []
    },
    "5315": {
        "db_id": "beer_factory",
        "question": "What is the precise location of zip code 95819?",
        "ground_truth": "SELECT T2.Latitude, T2.Longitude FROM location AS T1 INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE T1.ZipCode = 95819",
        "amends": [
            "Do select specific columns `T2.Latitude` and `T2.Longitude` instead of selecting all columns with `*`. Do join tables using `INNER JOIN` between `location AS T1` and `geolocation AS T2` on `T1.LocationID = T2.LocationID` instead of querying a single table `zip_codes`. Do filter on `T1.ZipCode = 95819` using a numeric value instead of filtering `zip_code = '95819'` with a string literal. The amended query now correctly retrieves geolocation coordinates by joining location data with geolocation information using proper table relationships and data types."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM zip_codes WHERE zip_code = '95819';",
            "SELECT T2.Latitude, T2.Longitude\nFROM location AS T1\nINNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID\nWHERE T1.ZipCode = 95819"
        ],
        "rule_sql": []
    },
    "8769": {
        "db_id": "chicago_crime",
        "question": "Which district commander was responsible for more incidents in January, 2018, Robert A. Rubio or Glenn White?",
        "ground_truth": "SELECT T1.commander FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander IN ('Robert A. Rubio', 'Glenn White') AND SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' GROUP BY T1.commander",
        "amends": [
            "Do query from `District AS T1` and `Crime AS T2` with an `INNER JOIN` on `T1.district_no = T2.district_no` instead of querying only from `incidents`. Do filter commanders with `T1.commander IN ('Robert A. Rubio', 'Glenn White')` instead of applying the same filter. Do add date filtering with `SUBSTR(T2.date, 1, 1) = '1'` for month and `SUBSTR(T2.date, 5, 4) = '2018'` for year instead of using `BETWEEN` on a full date range. Do remove `COUNT(*) as incident_count`, `ORDER BY incident_count DESC`, and `LIMIT 1` instead of keeping aggregation and ranking. Do select only `T1.commander` instead of selecting both commander and count. The amended query now correctly joins district and crime data while filtering for January 2018 incidents and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT commander, COUNT(*) as incident_count \nFROM incidents \nWHERE date BETWEEN '2018-01-01' AND '2018-01-31' \nAND commander IN ('Robert A. Rubio', 'Glenn White') \nGROUP BY commander \nORDER BY incident_count DESC \nLIMIT 1;",
            "SELECT T1.commander\nFROM District AS T1\nINNER JOIN Crime AS T2 ON T1.district_no = T2.district_no\nWHERE T1.commander IN ('Robert A. Rubio', 'Glenn White')\nAND SUBSTR(T2.date, 1, 1) = '1'\nAND SUBSTR(T2.date, 5, 4) = '2018'"
        ],
        "rule_sql": []
    },
    "4946": {
        "db_id": "olympics",
        "question": "How many athletes are from Australia?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'Australia'",
        "amends": [
            "Do select `COUNT(T2.person_id)` instead of `COUNT(*)` to count specific person records. Do use `noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id` instead of querying `athletes` directly to properly join region tables. Do filter on `T1.region_name = 'Australia'` instead of `country = 'USA'` to target the correct region. Do remove the incorrect table reference `athletes` and add the proper table structure with join relationships. The amended query now correctly counts persons associated with Australia instead of incorrectly counting all USA athletes."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE country = 'USA';",
            "SELECT COUNT(T2.person_id) \nFROM noc_region AS T1 \nINNER JOIN person_region AS T2 ON T1.id = T2.region_id \nWHERE T1.region_name = 'Australia'"
        ],
        "rule_sql": []
    },
    "8213": {
        "db_id": "sales_in_weather",
        "question": "How many units are being sold for item 1 when the average temperature is 83?",
        "ground_truth": "SELECT SUM(units) FROM weather AS T1 INNER JOIN sales_in_weather AS T2 ON T1.`date` = T2.`date` INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr WHERE T2.item_nbr = 1 AND T1.tavg = 83",
        "amends": [
            "Do change the source table from `sales` to a join between `weather AS T1`, `sales_in_weather AS T2`, and `relation AS T3` instead of querying a single table. Do use `INNER JOIN` on `T1.date = T2.date` and `INNER JOIN` on `T2.store_nbr = T3.store_nbr` instead of no joins. Do change the aggregation column from `SUM(units_sold)` to `SUM(units)` instead of using the wrong column name. Do change the filter condition from `item_id = 1` to `T2.item_nbr = 1` instead of using incorrect column reference and naming. Do change the temperature filter from `temperature = 83` to `T1.tavg = 83` instead of using the wrong column name and table reference. The amended query now correctly joins the necessary tables and uses the appropriate column references to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(units_sold) FROM sales WHERE item_id = 1 AND temperature = 83;",
            "SELECT SUM(T2.units) \nFROM weather AS T1\nINNER JOIN sales_in_weather AS T2 ON T1.date = T2.date\nINNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr\nWHERE T2.item_nbr = 1 AND T1.tavg = 83"
        ],
        "rule_sql": []
    },
    "3468": {
        "db_id": "video_games",
        "question": "List down the platform IDs of the games with a region ID of 3.",
        "ground_truth": "SELECT T2.id FROM region_sales AS T1 INNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id WHERE T1.region_id = 3",
        "amends": [
            "Do select `T2.id` from `region_sales AS T1` instead of `game_id` from `games`. Do add `INNER JOIN` with `game_platform AS T2` on `T1.game_platform_id = T2.id` instead of querying only the `games` table. Do filter on `T1.region_id = 3` instead of `region_id = 3` from the original table. The amended query now correctly joins the region sales data with game platform information to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_id FROM games WHERE region_id = 3;",
            "SELECT T2.id \nFROM region_sales AS T1 \nINNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id \nWHERE T1.region_id = 3"
        ],
        "rule_sql": []
    },
    "1192": {
        "db_id": "talkingdata",
        "question": "Mention the group of age of users who use phone brand of LG.",
        "ground_truth": "SELECT T1.`group` FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'LG'",
        "amends": [
            "Do select `T1.group` from `gender_age AS T1` instead of `age_group` from `users`. Do add `INNER JOIN phone_brand_device_model2 AS T2` on `T1.device_id = T2.device_id` instead of querying only the `users` table. Do move the filter `phone_brand = 'LG'` to the joined table `T2` instead of applying it to the original table. Do remove `GROUP BY age_group` instead of keeping it since no aggregation is needed. The amended query now correctly joins the relevant tables and matches the RIGHT_SQL's behavior.",
            "Do use backticks around the column name `group` instead of leaving it unquoted, as `group` is a reserved keyword in SQL that requires quoting to avoid syntax errors. The amended query now correctly handles the reserved keyword and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age_group FROM users WHERE phone_brand = 'LG' GROUP BY age_group",
            "SELECT T1.group FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'LG'",
            "SELECT T1.`group` FROM `gender_age` AS T1 INNER JOIN `phone_brand_device_model2` AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'LG'"
        ],
        "rule_sql": []
    },
    "6847": {
        "db_id": "retails",
        "question": "List the 5 orders with the highest total price, indicating the delivery date.",
        "ground_truth": "SELECT T1.o_orderkey, T2.l_shipdate FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey ORDER BY T1.o_totalprice DESC LIMIT 5",
        "amends": [
            "Do select `T1.o_orderkey` and `T2.l_shipdate` instead of `order_id`, `delivery_date`, and `total_price`. Do add `INNER JOIN lineitem AS T2` with predicate `ON T1.o_orderkey = T2.l_orderkey` instead of querying only the `orders` table. Do use `T1.o_totalprice` for ordering instead of `total_price`. Do reference tables with aliases `T1` and `T2` instead of using unaliased table names. The amended query now correctly joins orders with lineitem and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, delivery_date, total_price FROM orders ORDER BY total_price DESC LIMIT 5;",
            "SELECT T1.o_orderkey, T2.l_shipdate\nFROM orders AS T1\nINNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey\nORDER BY T1.o_totalprice DESC\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "8532": {
        "db_id": "software_company",
        "question": "What is the total number of customers with an age below 30?",
        "ground_truth": "SELECT COUNT(ID) FROM Customers WHERE age < 30",
        "amends": [
            "Do count `ID` instead of `*` to count specific non-null values rather than all rows. Do reference table `Customers` instead of `customers` to match the correct case sensitivity. Do use filter `age < 30` instead of `age > 30` to correctly identify customers under 30 years old rather than over 30. The amended query now matches RIGHT_SQL's behavior by accurately counting customers below the age threshold."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE age > 30;",
            "SELECT COUNT(ID) FROM Customers WHERE age < 30"
        ],
        "rule_sql": []
    },
    "8033": {
        "db_id": "university",
        "question": "Which university had the highest reputation in 2012?",
        "ground_truth": "SELECT T2.university_name FROM university_ranking_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2012 ORDER BY T1.score DESC LIMIT 1",
        "amends": [
            "Do join `university_ranking_year AS T1` with `university AS T2` on `T1.university_id = T2.id` instead of querying only the `universities` table. Do select `T2.university_name` instead of `university_name`. Do filter on `T1.year = 2012` instead of `year = 2012`. Do order by `T1.score DESC` instead of `reputation_score ASC`. The amended query now correctly retrieves the university with the highest score in 2012 by joining the ranking data with university details and ordering by score in descending order."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_name FROM universities WHERE year = 2012 ORDER BY reputation_score ASC LIMIT 1;",
            "SELECT T2.university_name\nFROM university_ranking_year AS T1\nJOIN university AS T2 ON T1.university_id = T2.id\nWHERE T1.year = 2012\nORDER BY T1.score DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3009": {
        "db_id": "shakespeare",
        "question": "When did Shakespeare create his work that has 154 scenes?",
        "ground_truth": "SELECT T1.Date, T1.id FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Scene = 154",
        "amends": [
            "Do select `T1.Date` and `T1.id` instead of just `creation_date`. Do use `works AS T1` as the main table instead of `shakespeare_works`. Do add an `INNER JOIN` with `chapters AS T2` on `T1.id = T2.work_id` instead of querying a single table. Do filter on `T2.Scene = 154` instead of `scene_count = 154`. The amended query now correctly joins the works and chapters tables to find works with scenes matching the specified count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT creation_date FROM shakespeare_works WHERE scene_count = 154;",
            "SELECT T1.Date, T1.id FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Scene = 154"
        ],
        "rule_sql": []
    },
    "4182": {
        "db_id": "simpson_episodes",
        "question": "How many episodes have more than 1000 votes?",
        "ground_truth": "SELECT COUNT(episode_id) FROM Episode WHERE votes > 1000;",
        "amends": [
            "Do reference table `Episode` instead of `episodes` and count `episode_id` instead of `*` to exclude NULL values. Do use filter `votes > 1000` instead of `votes < 1000` to count episodes with high vote counts rather than low ones. The amended query now correctly counts non-NULL episode IDs where votes exceed 1000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE votes < 1000;",
            "SELECT COUNT(episode_id) FROM Episode WHERE votes > 1000"
        ],
        "rule_sql": []
    },
    "4681": {
        "db_id": "disney",
        "question": "Who is the villain in Little Mermaid?",
        "ground_truth": "SELECT villian FROM characters WHERE movie_title = 'Little Mermaid'",
        "amends": [
            "Do select `villian` instead of `name` from the `characters` table instead of the `villains` table, and filter on `movie_title = 'Little Mermaid'` instead of `movie = 'Little Mermaid'`. The amended query now correctly retrieves villain names from the characters table using the appropriate column and table names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM villains WHERE movie = 'Little Mermaid';",
            "SELECT villian FROM characters WHERE movie_title = 'Little Mermaid';"
        ],
        "rule_sql": []
    },
    "3313": {
        "db_id": "video_games",
        "question": "Among the games published by 10TACLE Studios, how many of them are puzzles?",
        "ground_truth": "SELECT COUNT(T1.id) FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id INNER JOIN genre AS T4 ON T1.genre_id = T4.id WHERE T4.genre_name = 'Puzzle' AND T3.publisher_name = '10TACLE Studios'",
        "amends": [
            "Do join multiple tables instead of querying a single table, specifically adding `game_publisher`, `publisher`, and `genre` tables instead of omitting them. Do use proper join conditions with `INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id`, `INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id`, and `INNER JOIN genre AS T4 ON T1.genre_id = T4.id` instead of direct column references. Do filter on `T4.genre_name = 'Puzzle'` instead of `genre = 'Action'` to match the correct genre criteria. Do filter on `T3.publisher_name = '10TACLE Studios'` instead of `publisher = '10TACLE Studios'` to use the proper publisher name column. Do count `T1.id` instead of `COUNT(*)` for more precise counting of game records. The amended query now correctly counts puzzle games from the specified publisher by properly joining the normalized database tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE publisher = '10TACLE Studios' AND genre = 'Action';",
            "SELECT COUNT(T1.id) \nFROM game AS T1\nINNER JOIN game_publisher AS T2 ON T1.id = T2.game_id\nINNER JOIN publisher AS T3 ON T2.publisher_id = T3.id\nINNER JOIN genre AS T4 ON T1.genre_id = T4.id\nWHERE T3.publisher_name = '10TACLE Studios' AND T4.genre_name = 'Puzzle'"
        ],
        "rule_sql": []
    },
    "836": {
        "db_id": "social_media",
        "question": "Please give the user ID of the user who has posted the most tweets.",
        "ground_truth": "SELECT UserID FROM twitter GROUP BY UserID ORDER BY COUNT(DISTINCT TweetID) DESC LIMIT 1",
        "amends": [
            "Do reference the `UserID` column instead of `user_id` and use the `twitter` table instead of `tweets`. Do count `COUNT(DISTINCT TweetID)` instead of `COUNT(*)` to count unique tweet identifiers rather than all rows. The amended query now correctly identifies the user with the most distinct tweets by counting unique TweetIDs instead of all records, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM tweets GROUP BY user_id ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT UserID\nFROM twitter\nGROUP BY UserID\nORDER BY COUNT(DISTINCT TweetID) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3832": {
        "db_id": "public_review_platform",
        "question": "What are the attributes that business number 56 have?",
        "ground_truth": "SELECT T1.attribute_name FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_value LIKE 'TRUE' AND T2.business_id = 56",
        "amends": [
            "Do select `T1.attribute_name` instead of `*` from all columns. Do add `Attributes AS T1` and `Business_Attributes AS T2` tables instead of only `businesses`. Do use `INNER JOIN` on `T1.attribute_id = T2.attribute_id` instead of no join. Do add `WHERE` filters for `T2.attribute_value LIKE 'TRUE'` and `T2.business_id = 56` instead of only `business_id = 56`. The amended query now correctly retrieves specific attribute names for business 56 where the attribute value is 'TRUE' instead of returning all columns from a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM businesses WHERE business_id = 56;",
            "SELECT T1.attribute_name \nFROM Attributes AS T1 \nINNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id \nWHERE T2.business_id = 56 AND T2.attribute_value LIKE 'TRUE'"
        ],
        "rule_sql": []
    },
    "1216": {
        "db_id": "talkingdata",
        "question": "Calculate the average age of people who have apps installed but are not active on their devices.",
        "ground_truth": "SELECT AVG(T1.age) FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id INNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id WHERE T3.is_installed = 1 AND T3.is_active = 0",
        "amends": [
            "Do specify the source table as `gender_age AS T1` instead of the generic `people`. Do add `INNER JOIN` with `events_relevant AS T2` on `T1.device_id = T2.device_id` instead of omitting this table. Do add another `INNER JOIN` with `app_events_relevant AS T3` on `T2.event_id = T3.event_id` instead of omitting this table. Do use `T3.is_installed = 1` instead of `app_installed = 1` to reference the correct joined table column. Do use `T3.is_active = 0` instead of `active = 0` to reference the correct joined table column. Do qualify the column reference as `T1.age` instead of just `age` for clarity. The amended query now correctly joins the necessary tables to filter on installation and active status from the appropriate source and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM people WHERE app_installed = 1 AND active = 0;",
            "SELECT AVG(T1.age) AS average_age\nFROM gender_age AS T1\nINNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id\nINNER JOIN app_events_relevant AS T3 ON T2.event_id = T3.event_id\nWHERE T3.is_installed = 1 AND T3.is_active = 0;"
        ],
        "rule_sql": []
    },
    "1057": {
        "db_id": "talkingdata",
        "question": "What were the locations of the events on 8th May, 2016?",
        "ground_truth": "SELECT longitude, latitude FROM `events` WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-08'",
        "amends": [
            "Do select `longitude, latitude` instead of `location` in the SELECT list. Do use `SUBSTR(timestamp, 1, 10)` instead of `date` in the WHERE filter to extract the date portion from a timestamp column. Do reference the table as `events` with backticks instead of plain `events`. The amended query now correctly extracts longitude and latitude coordinates by filtering on the date portion of a timestamp field rather than relying on a potentially non-existent date column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM events WHERE date = '2016-05-08';",
            "SELECT `longitude`, `latitude` FROM `events` WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-08'"
        ],
        "rule_sql": []
    },
    "7567": {
        "db_id": "image_and_language",
        "question": "List all the IDs of images that have objects with the attributes of 'wired'.",
        "ground_truth": "SELECT DISTINCT T2.IMG_ID FROM ATT_CLASSES AS T1 INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T1.ATT_CLASS = 'wired'",
        "amends": [
            "Do select `DISTINCT T2.IMG_ID` from `ATT_CLASSES AS T1` and `IMG_OBJ_ATT AS T2` instead of `image_id` from `images`. Do use `INNER JOIN` on `T1.ATT_CLASS_ID = T2.ATT_CLASS_ID` instead of no join. Do filter on `T1.ATT_CLASS = 'wired'` instead of `attribute = 'wired'`. The amended query now correctly joins the classification and image-object-attribute tables to find distinct images with the 'wired' attribute class, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id FROM images WHERE attribute = 'wired';",
            "SELECT DISTINCT T2.IMG_ID\nFROM ATT_CLASSES AS T1\nINNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID\nWHERE T1.ATT_CLASS = 'wired'"
        ],
        "rule_sql": []
    },
    "1128": {
        "db_id": "talkingdata",
        "question": "For the event which happened at 23:33:34 on 2016/5/6, how many installed apps were involved?",
        "ground_truth": "SELECT COUNT(T1.event_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id WHERE SUBSTR(T2.`timestamp`, 1, 10) = '2016-05-06' AND T1.is_installed = '1'",
        "amends": [
            "Do select `COUNT(T1.event_id)` from specific column instead of `COUNT(*)` from all rows. Do use `app_events AS T1` and `events AS T2` tables with an `INNER JOIN` on `T1.event_id = T2.event_id` instead of querying only the `installed_apps` table. Do add a WHERE clause with `SUBSTR(T2.timestamp, 1, 10) = '2016-05-06'` for date filtering and `T1.is_installed = '1'` for installation status instead of the simple `event_time = '2016/5/6 23:33:34'` exact timestamp match. Do use proper date format '2016-05-06' instead of '2016/5/6' and extract only the date portion instead of the full timestamp. The amended query now correctly counts installed app events for the specified date by joining relevant tables and applying proper filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM installed_apps WHERE event_time = '2016/5/6 23:33:34';",
            "SELECT COUNT(T1.event_id) \nFROM app_events AS T1 \nINNER JOIN events AS T2 ON T1.event_id = T2.event_id \nWHERE SUBSTR(T2.timestamp, 1, 10) = '2016-05-06' \nAND T1.is_installed = 1"
        ],
        "rule_sql": []
    },
    "1294": {
        "db_id": "law_episode",
        "question": "How many people did not enjoy the finale episode?",
        "ground_truth": "SELECT COUNT(T1.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T1.episode = 24 AND T2.stars = 1",
        "amends": [
            "Do select `COUNT(T1.episode_id)` from `Episode AS T1` instead of `COUNT(*)` from `viewers`. Do add `INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id` instead of omitting any joins. Do use filter `T1.episode = 24 AND T2.stars = 1` instead of `enjoyed_finale = 'no'`. The amended query now correctly counts votes with one star for episode 24 rather than counting viewers who didn't enjoy the finale."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM viewers WHERE enjoyed_finale = 'no';",
            "SELECT COUNT(T1.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T1.episode = 24 AND T2.stars = 1"
        ],
        "rule_sql": []
    },
    "9427": {
        "db_id": "movie_3",
        "question": "What is the average amount of money spent by a customer in Italy on a single film rental?",
        "ground_truth": "SELECT AVG(T5.amount) FROM address AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id INNER JOIN customer AS T4 ON T1.address_id = T4.address_id INNER JOIN payment AS T5 ON T4.customer_id = T5.customer_id WHERE T3.country = 'Italy'",
        "amends": [
            "Do join `address`, `city`, and `country` tables instead of omitting them, using `INNER JOIN` chains through `T1.city_id=T2.city_id`, `T2.country_id=T3.country_id`, and `T1.address_id=T4.address_id` instead of directly joining `customer` to `payment`. Do filter on `T3.country='Italy'` instead of `customer.country='Italy'` to correctly reference the country table. Do remove `GROUP BY payment.rental_id` instead of keeping it since the query now calculates a single average across all Italian payments. Do reference `T5.amount` instead of `payment.amount` to match the table alias convention. The amended query now correctly aggregates payments from Italian customers by properly traversing the address-city-country relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(payment.amount) \nFROM payment \nJOIN customer ON payment.customer_id = customer.customer_id \nWHERE customer.country = 'Italy' \nGROUP BY payment.rental_id",
            "SELECT AVG(payment.amount) AS average_amount\nFROM payment\nINNER JOIN customer ON payment.customer_id = customer.customer_id\nINNER JOIN address ON customer.address_id = address.address_id\nINNER JOIN city ON address.city_id = city.city_id\nINNER JOIN country ON city.country_id = country.country_id\nWHERE country.country = 'Italy';"
        ],
        "rule_sql": []
    },
    "5581": {
        "db_id": "shipping",
        "question": "How many shipments were ordered by a customer in Florida?",
        "ground_truth": "SELECT COUNT(T1.cust_id) FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE T1.state = 'FL'",
        "amends": [
            "Do select `COUNT(T1.cust_id)` instead of `COUNT(*)` to count specific customer IDs rather than all rows. Do use `customer AS T1 INNER JOIN shipment AS T2` instead of querying only the `shipments` table to properly join customer and shipment data. Do join on `T1.cust_id = T2.cust_id` instead of missing the join condition entirely. Do filter on `T1.state = 'FL'` instead of `customer_state = 'Florida'` to use the correct column name and state abbreviation format. The amended query now correctly counts shipments for Florida customers by properly joining the tables and using appropriate filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE customer_state = 'Florida';",
            "SELECT COUNT(T2.cust_id) \nFROM customer AS T1 \nINNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id \nWHERE T1.state = 'FL'"
        ],
        "rule_sql": []
    },
    "5818": {
        "db_id": "language_corpus",
        "question": "Among the biwords pairs with \"\u00e0bac\" as its first word, how many of them have an occurrence of over 10?",
        "ground_truth": "SELECT COUNT(T2.w2nd) FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w1st WHERE T1.word = '\u00e0bac' AND T2.occurrences > 10",
        "amends": [
            "Do select `COUNT(T2.w2nd)` instead of `COUNT(*)` to count specific column values rather than all rows. Do join `words AS T1` with `biwords AS T2` using `INNER JOIN` instead of querying only `biwords` table. Do use join condition `T1.wid = T2.w1st` instead of no join condition to properly relate the tables. Do filter on `T1.word = '\u00e0bac'` instead of `first_word = '\u00e0bac'` to reference the correct table column. Do filter on `T2.occurrences > 10` instead of `occurrence > 10` to use the correct column name and table reference. The amended query now correctly counts biwords where the first word matches '\u00e0bac' and occurrences exceed 10 by properly joining the words and biwords tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM biwords WHERE first_word = '\u00e0bac' AND occurrence > 10;",
            "SELECT COUNT(T2.w2nd) \nFROM words AS T1 \nINNER JOIN biwords AS T2 ON T1.wid = T2.w1st \nWHERE T1.word = '\u00e0bac' AND T2.occurrences > 10"
        ],
        "rule_sql": []
    },
    "8072": {
        "db_id": "university",
        "question": "In which year did university ID 1 have the most students?",
        "ground_truth": "SELECT year FROM university_year WHERE university_id = 1 ORDER BY num_students DESC LIMIT 1",
        "amends": [
            "Do query the `university_year` table instead of the `university_enrollment` table. Do use the `num_students` column for ordering instead of `student_count`. Do sort by `DESC` instead of `ASC` to get the year with the highest enrollment instead of the lowest. The amended query now correctly retrieves the year with the maximum number of students for university_id 1 from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM university_enrollment WHERE university_id = 1 ORDER BY student_count ASC LIMIT 1;",
            "SELECT year FROM university_year WHERE university_id = 1 ORDER BY num_students DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8632": {
        "db_id": "chicago_crime",
        "question": "In the most populated ward, how many incidents of domestic violence were reported in a bar or tavern?",
        "ground_truth": "SELECT COUNT(T2.report_no) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.domestic = 'TRUE' AND T2.location_description = 'BAR OR TAVERN' ORDER BY T1.Population DESC LIMIT 1",
        "amends": [
            "Do select `COUNT(T2.report_no)` instead of `COUNT(*)` to count specific report numbers rather than all rows. Do use `Ward AS T1 INNER JOIN Crime AS T2` instead of querying only `incidents` table to properly join ward and crime data. Do join on `T1.ward_no = T2.ward_no` instead of no join condition to establish the correct relationship between tables. Do filter with `T2.domestic = 'TRUE'` instead of `incident_type = 'domestic violence'` to use the correct boolean column for domestic incidents. Do filter with `T2.location_description = 'BAR OR TAVERN'` instead of `location_type = 'bar'` to match the precise location description format. Do order by `T1.Population DESC` instead of just `population DESC` to explicitly reference the ward table's population column. The amended query now correctly counts domestic violence incidents at bar locations by joining ward and crime tables with proper filtering and returns the count from the ward with the highest population.",
            "Do remove the subquery filter `WHERE T1.Population = (SELECT MAX(Population) FROM Ward)` instead of keeping it, and do add `ORDER BY T1.Population DESC LIMIT 1` instead of omitting it to correctly find the ward with maximum population while maintaining the same `COUNT` aggregation and `INNER JOIN` on `T1.ward_no = T2.ward_no` with filters on `T2.domestic = 'TRUE'` and `T2.location_description = 'BAR OR TAVERN'`. The amended query now matches RIGHT_SQL's behavior by ordering and limiting rather than using a subquery comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM incidents \nWHERE incident_type = 'domestic violence' \nAND location_type = 'bar' \nORDER BY population DESC \nLIMIT 1;",
            "SELECT COUNT(T2.report_no) \nFROM Ward AS T1 \nINNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no \nWHERE T1.Population = (SELECT MAX(Population) FROM Ward) \nAND T2.domestic = 'TRUE' \nAND T2.location_description = 'BAR OR TAVERN'",
            "SELECT COUNT(T2.report_no) \nFROM Ward AS T1 \nINNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no \nWHERE T2.domestic = 'TRUE' \nAND T2.location_description = 'BAR OR TAVERN' \nORDER BY T1.Population DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8246": {
        "db_id": "mondial_geo",
        "question": "Among the countries with a population of over 10000000, how many of them have a GDP of over 500000?",
        "ground_truth": "SELECT COUNT(T1.Name) FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE T2.GDP > 500000 AND T1.Population > 10000000",
        "amends": [
            "Do join `country AS T1` with `economy AS T2` on `T1.Code = T2.Country` instead of querying only the `countries` table. Do reference `T2.GDP` and `T1.Population` in the WHERE clause instead of `gdp` and `population` from a single table. Do count `T1.Name` instead of using `COUNT(*)` to ensure only non-null country names are counted. Do use explicit table aliases `T1` and `T2` instead of implicit single table references. The amended query now correctly joins the country and economy tables to count countries meeting both population and GDP criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE population > 10000000 AND gdp > 500000;",
            "SELECT COUNT(T1.Name) \nFROM country AS T1 \nJOIN economy AS T2 ON T1.Code = T2.Country \nWHERE T1.Population > 10000000 AND T2.GDP > 500000"
        ],
        "rule_sql": []
    },
    "2272": {
        "db_id": "movielens",
        "question": "Please list down ID of movies acted by top 5 actors based on actor rating.",
        "ground_truth": "SELECT T2.movieid FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid GROUP BY T2.actorid ORDER BY AVG(T1.a_quality) DESC LIMIT 5",
        "amends": [
            "Do use `T2.movieid` instead of `m.movie_id` in the SELECT list. Do join `actors AS T1` and `movies2actors AS T2` instead of joining `movies`, `movie_actors`, and `actors`. Do use `INNER JOIN` on `T1.actorid = T2.actorid` instead of joining through multiple tables with different join conditions. Do add `GROUP BY T2.actorid` instead of omitting grouping. Do add `ORDER BY AVG(T1.a_quality) DESC` instead of ordering by movie_id. Do add `LIMIT 5` at the query level instead of using a subquery with LIMIT. Do remove the WHERE clause with subquery instead of keeping it. The amended query now correctly groups by actor and orders by average quality to get the top 5 movies, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.movie_id \nFROM movies m\nJOIN movie_actors ma ON m.movie_id = ma.movie_id\nJOIN actors a ON ma.actor_id = a.actor_id\nWHERE a.actor_id IN (\n    SELECT actor_id \n    FROM actors \n    ORDER BY rating DESC \n    LIMIT 5\n)\nORDER BY m.movie_id;",
            "SELECT T2.movieid\nFROM actors AS T1\nINNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid\nGROUP BY T2.actorid\nORDER BY AVG(T1.a_quality) DESC\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "7332": {
        "db_id": "works_cycles",
        "question": "Who is the oldest married male? State his job title.",
        "ground_truth": "SELECT T2.FirstName, T2.LastName, T1.JobTitle FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.Gender = 'M' AND T1.MaritalStatus = 'M' ORDER BY T1.BirthDate LIMIT 1",
        "amends": [
            "Do select `T2.FirstName`, `T2.LastName`, and `T1.JobTitle` instead of `name` and `job_title`. Do use `INNER JOIN` between `Employee AS T1` and `Person AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying only from `employees`. Do filter on `T1.Gender = 'M'` and `T1.MaritalStatus = 'M'` instead of `gender = 'male'` and `marital_status = 'married'`. Do order by `T1.BirthDate` instead of `age ASC`. The amended query now correctly joins related tables, uses proper column references with table aliases, and matches the intended filtering and sorting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, job_title FROM employees WHERE gender = 'male' AND marital_status = 'married' ORDER BY age ASC LIMIT 1;",
            "SELECT T2.FirstName, T2.LastName, T1.JobTitle\nFROM Employee AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.Gender = 'M' AND T1.MaritalStatus = 'M'\nORDER BY T1.BirthDate ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5401": {
        "db_id": "sales",
        "question": "Among all customers handled by Innes E. del Castillo, how many have purchased Short-Sleeve Classic Jersey, L?",
        "ground_truth": "SELECT COUNT(T2.CustomerID) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID WHERE T3.FirstName = 'Innes' AND T3.LastName = 'del Castillo' AND T1.Name = 'Short-Sleeve Classic Jersey, L' AND T3.MiddleInitial = 'e'",
        "amends": [
            "Do use `COUNT(T2.CustomerID)` instead of `COUNT(*)` to count specific customer records. Do reference tables `Products AS T1`, `Sales AS T2`, and `Employees AS T3` instead of `customers c`, `orders o`, `order_items oi`, `products p`, and `employees e`. Do use `INNER JOIN` between `T1` and `T2` on `T1.ProductID = T2.ProductID` instead of multiple joins through order-related tables. Do join `T2` and `T3` on `T2.SalesPersonID = T3.EmployeeID` instead of joining employees through orders. Do add filter `T3.MiddleInitial = 'e'` instead of omitting this additional employee condition. Do reference `T1.Name` instead of `p.product_name` for the product filter. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper table relationships and additional filtering conditions.",
            "Do use lowercase `'e'` for the MiddleInitial filter instead of uppercase `'E'` to match the case-sensitive data format. Do keep all other elements identical including the SELECT list with `COUNT(T2.CustomerID)`, FROM sources with `Products`, `Sales`, and `Employees` tables joined via `INNER JOIN` on `T1.ProductID = T2.ProductID` and `T2.SalesPersonID = T3.EmployeeID`, WHERE filters for `T3.FirstName = 'Innes'`, `T3.LastName = 'del Castillo'`, `T1.Name = 'Short-Sleeve Classic Jersey, L'`, and maintain the same logical structure throughout. The amended query now correctly matches the case-sensitive MiddleInitial value and produces the same results as the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN order_items oi ON o.order_id = oi.order_id\nJOIN products p ON oi.product_id = p.product_id\nJOIN employees e ON o.employee_id = e.employee_id\nWHERE e.first_name = 'Innes' AND e.last_name = 'del Castillo'\nAND p.product_name = 'Short-Sleeve Classic Jersey, L';",
            "SELECT COUNT(T2.CustomerID) \nFROM Products AS T1\nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nINNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID\nWHERE T3.FirstName = 'Innes' \nAND T3.MiddleInitial = 'E' \nAND T3.LastName = 'del Castillo'\nAND T1.Name = 'Short-Sleeve Classic Jersey, L'",
            "SELECT COUNT(T2.CustomerID)\nFROM Products AS T1\nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nINNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID\nWHERE T3.FirstName = 'Innes'\nAND T3.MiddleInitial = 'e'\nAND T3.LastName = 'del Castillo'\nAND T1.Name = 'Short-Sleeve Classic Jersey, L'"
        ],
        "rule_sql": []
    },
    "8241": {
        "db_id": "mondial_geo",
        "question": "How much is her GDP in agriculture for the country with the least area?",
        "ground_truth": "SELECT T2.GDP * T2.Agriculture FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY T1.Area ASC LIMIT 1",
        "amends": [
            "Do select `T2.GDP * T2.Agriculture` instead of `gdp_agriculture`. Do use `INNER JOIN` between `country AS T1` and `economy AS T2` on `T1.Code = T2.Country` instead of querying only from `countries` table. Do remove the `WHERE` clause with `area = (SELECT MIN(area) FROM countries)` and `gender = 'female'` conditions instead of keeping them. Do add `ORDER BY T1.Area ASC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly joins country and economy tables to calculate GDP multiplied by agriculture percentage and returns the result for the country with smallest area."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gdp_agriculture FROM countries WHERE area = (SELECT MIN(area) FROM countries) AND gender = 'female';",
            "SELECT T2.GDP * T2.Agriculture \nFROM country AS T1 \nINNER JOIN economy AS T2 ON T1.Code = T2.Country \nORDER BY T1.Area ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1205": {
        "db_id": "talkingdata",
        "question": "Identify by their id all the devices that are used by women who are in the age range of 29 to 31 years.",
        "ground_truth": "SELECT device_id FROM gender_age_train WHERE age BETWEEN 29 AND 31 AND gender = 'F'",
        "amends": [
            "Do query table `gender_age_train` instead of `users`. Do use gender value `'F'` instead of `'female'`. Do maintain the same `age BETWEEN 29 AND 31` filter and `device_id` selection. The amended query now correctly references the appropriate table and uses the proper gender encoding format."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_id FROM users WHERE gender = 'female' AND age BETWEEN 29 AND 31;",
            "SELECT device_id FROM gender_age_train WHERE gender = 'F' AND age BETWEEN 29 AND 31"
        ],
        "rule_sql": []
    },
    "6131": {
        "db_id": "food_inspection_2",
        "question": "For the grocery store located at \"3635 W DIVERSEY AVE\", how many inspections did it have?",
        "ground_truth": "SELECT COUNT(T2.inspection_id) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.address = '3635 W DIVERSEY AVE ' AND T1.facility_type = 'Grocery Store'",
        "amends": [
            "Do join `establishment AS T1` and `inspection AS T2` with `INNER JOIN` on `T1.license_no = T2.license_no` instead of querying only the `inspections` table. Do filter on `T1.address = '3635 W DIVERSEY AVE'` and `T1.facility_type = 'Grocery Store'` instead of filtering only on `store_address`. Do count `T2.inspection_id` instead of counting all rows with `COUNT(*)`. The amended query now correctly counts inspections for grocery stores at the specified address by properly joining establishment and inspection tables.",
            "Do include a trailing space in the address filter `'3635 W DIVERSEY AVE '` instead of omitting it, as the exact string match requires precise whitespace handling to correctly identify the establishment record. The amended query now matches RIGHT_SQL's behavior with the corrected address predicate."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE store_address = '3635 W DIVERSEY AVE';",
            "SELECT COUNT(T2.inspection_id) \nFROM establishment AS T1 \nINNER JOIN inspection AS T2 ON T1.license_no = T2.license_no \nWHERE T1.address = '3635 W DIVERSEY AVE' AND T1.facility_type = 'Grocery Store'",
            "SELECT COUNT(T2.inspection_id) \nFROM establishment AS T1 \nINNER JOIN inspection AS T2 ON T1.license_no = T2.license_no \nWHERE T1.address = '3635 W DIVERSEY AVE ' AND T1.facility_type = 'Grocery Store'"
        ],
        "rule_sql": []
    },
    "3056": {
        "db_id": "shakespeare",
        "question": "In Act 1 Scene 2 of the Twelfth Night, what is the total number of of lines said by Viola?",
        "ground_truth": "SELECT COUNT(T4.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T2.Act = 1 AND T2.Scene = 2 AND T4.id = 1238 AND T4.CharName = 'Viola' AND T1.Title = 'Twelfth Night'",
        "amends": [
            "Do join multiple tables starting from `works AS T1` instead of querying only `lines` table. Do add explicit joins with `INNER JOIN chapters AS T2 ON T1.id = T2.work_id`, `INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id`, and `INNER JOIN characters AS T4 ON T3.character_id = T4.id` instead of missing these relationships. Do filter on `T2.Act = 1 AND T2.Scene = 2` instead of filtering directly on act and scene columns in the wrong table. Do add conditions `T4.id = 1238 AND T4.CharName = 'Viola'` instead of only filtering by character name. Do include `T1.Title = 'Twelfth Night'` to specify the work instead of omitting this constraint. Do count `T4.id` instead of counting all rows with `COUNT(*)`. The amended query now correctly counts specific character appearances within the proper table relationships and constraints."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM lines WHERE character = 'Viola' AND act = 1 AND scene = 2;",
            "SELECT COUNT(T4.id) \nFROM works AS T1\nINNER JOIN chapters AS T2 ON T1.id = T2.work_id\nINNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id\nINNER JOIN characters AS T4 ON T3.character_id = T4.id\nWHERE T1.Title = 'Twelfth Night'\nAND T2.Act = 1\nAND T2.Scene = 2\nAND T4.id = 1238\nAND T4.CharName = 'Viola'"
        ],
        "rule_sql": []
    },
    "3953": {
        "db_id": "public_review_platform",
        "question": "How many actively running Yelp businesses are there located in \"Phoenix\" city?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE active = 'true' AND city = 'Phoenix'",
        "amends": [
            "Do count `business_id` instead of `*` to exclude null values. Do reference table `Business` instead of `businesses` with proper case. Do filter on `active = 'true'` instead of `is_open = 1` to use the correct boolean representation. Do remove the unnecessary `AND` clause since the condition structure remains the same. The amended query now correctly counts only active businesses in Phoenix using the proper table name and boolean condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Phoenix' AND is_open = 1;",
            "SELECT COUNT(business_id) FROM Business WHERE active = 'true' AND city = 'Phoenix'"
        ],
        "rule_sql": []
    },
    "1360": {
        "db_id": "synthea",
        "question": "By how much did Elly Koss's weight increase from the observation in 2008 to the observation in 2009?",
        "ground_truth": "SELECT SUM(CASE WHEN strftime('%Y', T2.date) = '2009' THEN T2.VALUE END) - SUM(CASE WHEN strftime('%Y', T2.date) = '2008' THEN T2.VALUE END) AS increase , T2.units FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description = 'Body Height'",
        "amends": [
            "Do use `SUM(CASE WHEN strftime('%Y', T2.date) = '2009' THEN T2.VALUE END) - SUM(CASE WHEN strftime('%Y', T2.date) = '2008' THEN T2.VALUE END)` instead of `(weight_2009 - weight_2008)` for conditional aggregation based on year. Do add `T2.units` to the SELECT list instead of omitting it. Do change FROM source to `patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT` instead of single table `observations`. Do change WHERE filter to `T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description = 'Body Height'` instead of `name = 'Elly Koss' AND year IN (2008, 2009)`. Do use date parsing with `strftime('%Y', T2.date)` instead of direct year column comparison. The amended query now correctly calculates height increase using proper patient identification and conditional year-based aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (weight_2009 - weight_2008) AS weight_increase FROM observations WHERE name = 'Elly Koss' AND year IN (2008, 2009)",
            "SELECT \n    SUM(CASE WHEN strftime('%Y', T2.DATE) = '2009' THEN T2.VALUE END) - \n    SUM(CASE WHEN strftime('%Y', T2.DATE) = '2008' THEN T2.VALUE END) AS weight_increase,\n    T2.UNITS\nFROM \n    patients AS T1 \nINNER JOIN \n    observations AS T2 ON T1.patient = T2.PATIENT\nWHERE \n    T1.first = 'Elly' \n    AND T1.last = 'Koss' \n    AND T2.DESCRIPTION = 'Body Height'\nGROUP BY \n    T2.UNITS"
        ],
        "rule_sql": []
    },
    "765": {
        "db_id": "movie",
        "question": "What is the genre of PG rated movie starred by the actor with highest net worth?",
        "ground_truth": "SELECT T1.Genre FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T1.`MPAA Rating` = 'PG' ORDER BY CAST(REPLACE(REPLACE(T3.NetWorth, ',', ''), '$', '') AS REAL) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Genre` from `movie` instead of `g.genre` from `movies`. Do join `characters` on `T1.MovieID = T2.MovieID` instead of joining `movie_genres` and `genres`. Do join `actor` on `T3.ActorID = T2.ActorID` instead of joining `movie_actors` and `actors`. Do filter on `T1.MPAA Rating` instead of `m.rating`. Do order by casting and cleaning `T3.NetWorth` instead of raw `a.net_worth`. The amended query now correctly handles numeric formatting and uses the proper schema relationships to match the intended behavior.",
            "Do use `REPLACE(REPLACE(T3.NetWorth, ',', ''), '$', '')` for proper numeric conversion instead of only removing dollar signs, which could leave commas that would break the cast. Do cast to `REAL` instead of `NUMERIC` for the net worth comparison. Do use backticks for the column name `MPAA Rating` instead of double quotes to ensure proper identifier quoting. The amended query now correctly handles numeric values with commas and dollar signs, ensuring accurate sorting by net worth while maintaining the same join structure and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.genre \nFROM movies m\nJOIN movie_genres mg ON m.movie_id = mg.movie_id\nJOIN genres g ON mg.genre_id = g.genre_id\nJOIN movie_actors ma ON m.movie_id = ma.movie_id\nJOIN actors a ON ma.actor_id = a.actor_id\nWHERE m.rating = 'PG'\nORDER BY a.net_worth DESC\nLIMIT 1;",
            "SELECT T1.Genre \nFROM movie T1\nJOIN characters T2 ON T1.MovieID = T2.MovieID\nJOIN actor T3 ON T3.ActorID = T2.ActorID\nWHERE T1.\"MPAA Rating\" = 'PG'\nORDER BY CAST(REPLACE(T3.NetWorth, '$', '') AS NUMERIC) DESC\nLIMIT 1",
            "SELECT T1.Genre\nFROM movie T1\nJOIN characters T2 ON T1.MovieID = T2.MovieID\nJOIN actor T3 ON T3.ActorID = T2.ActorID\nWHERE T1.`MPAA Rating` = 'PG'\nORDER BY CAST(REPLACE(REPLACE(T3.NetWorth, ',', ''), '$', '') AS REAL) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "9251": {
        "db_id": "movie_3",
        "question": "Give the full name of the actor who acted the most in drama movies?",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T1.first_name, T1.last_name, COUNT(T2.film_id) AS num FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film_category AS T3 ON T2.film_id = T3.film_id WHERE T3.category_id = 7 GROUP BY T1.first_name, T1.last_name ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `a`, `ma`, and `m`. Do select only `first_name` and `last_name` in the outer query instead of including `movie_count`. Do use `INNER JOIN` consistently instead of `JOIN`. Do join `film_actor` instead of `movie_actors` and `film_category` instead of `movies`. Do filter on `category_id = 7` instead of `genre = 'Drama'`. Do count `film_id` instead of using `COUNT(*)`. Do group by `first_name` and `last_name` instead of `actor_id`. Do wrap the aggregate query in a subquery alias `T` instead of querying directly. The amended query now correctly identifies actors by film category rather than genre and matches the RIGHT_SQL's behavior.",
            "Do use a subquery with `COUNT(T2.film_id) AS num` instead of omitting the count column, and do remove the complex `HAVING` clause with nested subquery instead of keeping it. Do add `ORDER BY T.num DESC LIMIT 1` instead of omitting ordering and limiting, which changes the logic from finding actors with the maximum count to simply retrieving the top actor. Do maintain the same `FROM` sources with `INNER JOIN` on `T1.actor_id = T2.actor_id` and `T2.film_id = T3.film_id`, and keep the `WHERE T3.category_id = 7` filter and `GROUP BY T1.first_name, T1.last_name` unchanged. The amended query now correctly returns the single actor with the highest film count in category 7 rather than all actors tied for the maximum count."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.first_name, a.last_name, COUNT(*) as movie_count\nFROM actors a\nJOIN movie_actors ma ON a.actor_id = ma.actor_id\nJOIN movies m ON ma.movie_id = m.movie_id\nWHERE m.genre = 'Drama'\nGROUP BY a.actor_id\nORDER BY movie_count DESC\nLIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM actor T1\nINNER JOIN film_actor T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film_category T3 ON T2.film_id = T3.film_id\nWHERE T3.category_id = 7\nGROUP BY T1.first_name, T1.last_name\nHAVING COUNT(T2.film_id) = (\n    SELECT MAX(movie_count)\n    FROM (\n        SELECT COUNT(T4.film_id) AS movie_count\n        FROM actor T4\n        INNER JOIN film_actor T5 ON T4.actor_id = T5.actor_id\n        INNER JOIN film_category T6 ON T5.film_id = T6.film_id\n        WHERE T6.category_id = 7\n        GROUP BY T4.first_name, T4.last_name\n    ) T\n)",
            "SELECT T1.first_name, T1.last_name\nFROM actor T1\nINNER JOIN film_actor T2 ON T1.actor_id = T2.actor_id\nINNER JOIN film_category T3 ON T2.film_id = T3.film_id\nWHERE T3.category_id = 7\nGROUP BY T1.first_name, T1.last_name\nHAVING COUNT(T2.film_id) = (\n    SELECT MAX(num)\n    FROM (\n        SELECT COUNT(T2.film_id) AS num\n        FROM actor T1\n        INNER JOIN film_actor T2 ON T1.actor_id = T2.actor_id\n        INNER JOIN film_category T3 ON T2.film_id = T3.film_id\n        WHERE T3.category_id = 7\n        GROUP BY T1.first_name, T1.last_name\n    ) T\n)"
        ],
        "rule_sql": []
    },
    "8845": {
        "db_id": "food_inspection",
        "question": "Among the businesses with score that ranges from 70 to 80, list their violation type ID and risk category.",
        "ground_truth": "SELECT DISTINCT T1.violation_type_id, T1.risk_category FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id INNER JOIN inspections AS T3 ON T2.business_id = T3.business_id WHERE T3.score BETWEEN 70 AND 80",
        "amends": [
            "Do select `DISTINCT T1.violation_type_id, T1.risk_category` from `violations AS T1` instead of `violation_type_id, risk_category` from `businesses`. Do add `INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id` and `INNER JOIN inspections AS T3 ON T2.business_id = T3.business_id` instead of querying only the businesses table. Do apply the score filter on `T3.score BETWEEN 70 AND 80` instead of directly on the businesses table score column. The amended query now correctly joins violation, business, and inspection data to return distinct violation types and risk categories for businesses with inspection scores in the specified range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT violation_type_id, risk_category FROM businesses WHERE score BETWEEN 70 AND 80;",
            "SELECT DISTINCT T1.violation_type_id, T1.risk_category\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nINNER JOIN inspections AS T3 ON T2.business_id = T3.business_id\nWHERE T3.score BETWEEN 70 AND 80"
        ],
        "rule_sql": []
    },
    "604": {
        "db_id": "codebase_comments",
        "question": "Show the full Comment of the method \"DE2_UE_Fahrradkurier.de2_uebung_fahrradkurierDataSet1TableAdapters.TableAdapterManager.UpdateInsertedRows\".",
        "ground_truth": "SELECT FullComment FROM Method WHERE Name = 'DE2_UE_Fahrradkurier.de2_uebung_fahrradkurierDataSet1TableAdapters.TableAdapterManager.UpdateInsertedRows'",
        "amends": [
            "Do select only `FullComment` instead of all columns with `*`. Do query from the `Method` table instead of the `Comments` table. Do filter on the `Name` column instead of the `MethodName` column. The amended query now correctly retrieves the specific comment from the appropriate table using the proper column names."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM Comments WHERE MethodName = 'DE2_UE_Fahrradkurier.de2_uebung_fahrradkurierDataSet1TableAdapters.TableAdapterManager.UpdateInsertedRows';",
            "SELECT FullComment FROM Method WHERE Name = 'DE2_UE_Fahrradkurier.de2_uebung_fahrradkurierDataSet1TableAdapters.TableAdapterManager.UpdateInsertedRows';"
        ],
        "rule_sql": []
    },
    "3480": {
        "db_id": "video_games",
        "question": "Calculate the total sales made by the games released in 2000.",
        "ground_truth": "SELECT SUM(T1.num_sales) FROM region_sales AS T1 INNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id WHERE T2.release_year = 2000",
        "amends": [
            "Do use `SUM(T1.num_sales)` instead of `SUM(sales)` to reference the correct column from the joined table. Do add `region_sales AS T1 INNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id` instead of querying only the `games` table, properly joining the sales data with game platform information. Do move the year filter to `T2.release_year = 2000` instead of applying it directly to a non-existent column in the original table, ensuring the condition correctly filters based on the joined table's release year. The amended query now correctly aggregates sales data by joining the necessary tables and filtering on the appropriate release year column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(sales) FROM games WHERE release_year = 2000;",
            "SELECT SUM(T1.num_sales) AS total_sales\nFROM region_sales AS T1\nINNER JOIN game_platform AS T2 ON T1.game_platform_id = T2.id\nWHERE T2.release_year = 2000"
        ],
        "rule_sql": []
    },
    "4825": {
        "db_id": "legislator",
        "question": "How many of the legislators are male?",
        "ground_truth": "SELECT COUNT(*) FROM current WHERE gender_bio = 'M'",
        "amends": [
            "Do reference table `current` instead of `legislators` and filter on column `gender_bio = 'M'` instead of `gender = 'female'`."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM legislators WHERE gender = 'female';",
            "SELECT COUNT(*) FROM current WHERE gender_bio = 'M'"
        ],
        "rule_sql": []
    },
    "9394": {
        "db_id": "movie_3",
        "question": "Who are the actors starred in the film \"Bound Cheaper\"?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.title = 'BOUND CHEAPER'",
        "amends": [
            "Do join `film_actor` on `a.actor_id = fa.actor_id` instead of `a.actor_id = fa.film_id`. Do join `film` on `fa.film_id = f.film_id` instead of `fa.film_id = f.actor_id`. Do filter on `T3.title = 'BOUND CHEAPER'` instead of `f.title = 'Bound Cheaper'` to match the exact case-sensitive title. The amended query now correctly retrieves actors who appeared in the specified film by fixing the join conditions between tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT a.first_name, a.last_name FROM actor a JOIN film_actor fa ON a.actor_id = fa.film_id JOIN film f ON fa.film_id = f.actor_id WHERE f.title = 'Bound Cheaper';",
            "SELECT a.first_name, a.last_name\nFROM actor a\nJOIN film_actor fa ON a.actor_id = fa.actor_id\nJOIN film f ON fa.film_id = f.film_id\nWHERE f.title = 'BOUND CHEAPER';"
        ],
        "rule_sql": []
    },
    "4089": {
        "db_id": "public_review_platform",
        "question": "For users with average ratings of 3, what kind of tip length they mostly left?",
        "ground_truth": "SELECT T2.tip_length FROM Users AS T1 INNER JOIN Tips AS T2 ON T1.user_id = T2.user_id WHERE T1.user_average_stars = 3 GROUP BY T2.tip_length ORDER BY COUNT(T2.tip_length) DESC LIMIT 1",
        "amends": [
            "Do reference `tip_length` from the `Tips` table as `T2.tip_length` instead of the ambiguous `tip_length`. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do filter on `T1.user_average_stars = 3` instead of `u.average_rating = 3`. Do group by `T2.tip_length` instead of the ambiguous `tip_length`. Do order by `COUNT(T2.tip_length)` instead of the alias `count`. Do use table aliases `T1` for `Users` and `T2` for `Tips` instead of `u` and `t`. The amended query now correctly references specific table columns, uses proper table aliases, and ensures accurate aggregation and ordering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tip_length, COUNT(*) as count\nFROM users u\nJOIN tips t ON u.user_id = t.user_id\nWHERE u.average_rating = 3\nGROUP BY tip_length\nORDER BY count DESC\nLIMIT 1;",
            "SELECT T2.tip_length, COUNT(T2.tip_length) AS tip_count\nFROM Users T1\nINNER JOIN Tips T2 ON T1.user_id = T2.user_id\nWHERE T1.user_average_stars = '3'\nGROUP BY T2.tip_length\nORDER BY COUNT(T2.tip_length) DESC;"
        ],
        "rule_sql": []
    },
    "3509": {
        "db_id": "authors",
        "question": "What is the paper \"Stitching videos streamed by mobile phones in real-time\" about?",
        "ground_truth": "SELECT Keyword FROM Paper WHERE Title = 'Stitching videos streamed by mobile phones in real-time'",
        "amends": [
            "Do select `Keyword` instead of `*` to return only the specific column needed. Do reference table `Paper` instead of `papers` to use the correct table name. Do filter on column `Title` instead of `title` to match the proper case-sensitive column name while maintaining the same filter condition. The amended query now correctly retrieves only the Keyword column from the Paper table where the Title matches the specified value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM papers WHERE title = 'Stitching videos streamed by mobile phones in real-time';",
            "SELECT Keyword FROM Paper WHERE Title = 'Stitching videos streamed by mobile phones in real-time';"
        ],
        "rule_sql": []
    },
    "2211": {
        "db_id": "world_development_indicators",
        "question": "Please provide the subject of series of Austria.",
        "ground_truth": "SELECT DISTINCT T3.Topic FROM CountryNotes AS T1 INNER JOIN Country AS T2 ON T1.Countrycode = T2.CountryCode INNER JOIN Series AS T3 ON T1.Seriescode = T3.SeriesCode WHERE T2.ShortName = 'Austria'",
        "amends": [
            "Do use `DISTINCT T3.Topic` instead of `title` in the SELECT list. Do add `CountryNotes AS T1 INNER JOIN Country AS T2 ON T1.Countrycode = T2.CountryCode INNER JOIN Series AS T3 ON T1.Seriescode = T3.SeriesCode` instead of the single table `series`. Do change the WHERE filter to `T2.ShortName = 'Austria'` instead of `country = 'Germany'`. The amended query now correctly retrieves distinct topics from Series by joining through CountryNotes and Country tables with proper relationship conditions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM series WHERE country = 'Germany';",
            "SELECT DISTINCT T3.Topic\nFROM CountryNotes AS T1\nINNER JOIN Country AS T2 ON T1.Countrycode = T2.CountryCode\nINNER JOIN Series AS T3 ON T1.Seriescode = T3.SeriesCode\nWHERE T2.ShortName = 'Austria'"
        ],
        "rule_sql": []
    },
    "9381": {
        "db_id": "movie_3",
        "question": "Indicate the percentage of inactive customers at store no.1.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN active = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(customer_id) FROM customer WHERE store_id = 1",
        "amends": [
            "Do use `SUM(CASE WHEN active = 0 THEN 1 ELSE 0 END)` to count inactive customers instead of `COUNT(*)` with a `WHERE active = 0` filter. Do cast the result to `REAL` for proper division instead of integer division. Do divide by `COUNT(customer_id)` of all customers instead of using a subquery `(SELECT COUNT(*) FROM customers WHERE store_id = 1)`. Do reference the correct table name `customer` instead of `customers`. Do remove the `AS percentage_inactive` alias instead of keeping it. The amended query now correctly calculates the percentage of inactive customers using proper floating-point division and eliminates the unnecessary subquery."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM customers WHERE store_id = 1) AS percentage_inactive FROM customers WHERE store_id = 1 AND active = 0;",
            "SELECT (SUM(CASE WHEN active = 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(customer_id)) FROM customer WHERE store_id = 1;"
        ],
        "rule_sql": []
    },
    "2987": {
        "db_id": "shakespeare",
        "question": "How many poems did Shakespeare write?",
        "ground_truth": "SELECT COUNT(id) FROM works WHERE GenreType = 'Poem'",
        "amends": [
            "Do select `COUNT(id)` instead of `COUNT(*)` to count specific non-null identifiers rather than all rows. Do query from `works` table instead of `poems` table as the correct data source. Do filter on `GenreType = 'Poem'` instead of `author = 'Shakespeare'` to properly identify poetic works by genre rather than filtering by a specific author. The amended query now correctly counts poems in the works table using appropriate genre-based filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM poems WHERE author = 'Shakespeare';",
            "SELECT COUNT(id) FROM works WHERE GenreType = 'Poem'"
        ],
        "rule_sql": []
    },
    "1683": {
        "db_id": "restaurant",
        "question": "What type of food is served at the restaurant located at 3140, Alpine Road at San Mateo County?",
        "ground_truth": "SELECT T2.food_type FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant INNER JOIN geographic AS T3 ON T2.city = T3.city WHERE T3.County = 'san mateo county' AND T1.street_name = 'alpine rd' AND T1.street_num = 3140",
        "amends": [
            "Do join `location AS T1` and `generalinfo AS T2` on `T1.id_restaurant = T2.id_restaurant` instead of querying `restaurants` directly. Do add `geographic AS T3` joined on `T2.city = T3.city` instead of omitting this table. Do filter on `T3.County = 'san mateo county'` instead of `county = 'San Mateo County'`. Do filter on `T1.street_name = 'alpine rd'` and `T1.street_num = 3140` instead of `address = '3140, Alpine Road'`. Do select `T2.food_type` instead of `food_type`. The amended query now correctly joins multiple tables to retrieve food_type based on precise location details."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT food_type FROM restaurants WHERE address = '3140, Alpine Road' AND county = 'San Mateo County';",
            "SELECT T2.food_type \nFROM location AS T1 \nJOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant \nJOIN geographic AS T3 ON T2.city = T3.city \nWHERE T3.county = 'san mateo county' \nAND T1.street_name = 'alpine rd' \nAND T1.street_num = 3140"
        ],
        "rule_sql": []
    },
    "7750": {
        "db_id": "hockey",
        "question": "How many Canadian players, between the ages of 18 and 24 when they initially played their first NHL, had a cumulative goal total of no more than 5? Indicate their complete names, the year, and the team for which they scored the specified amount of goals.",
        "ground_truth": "SELECT T2.nameGiven, T2.lastName, T2.birthYear, birthMon, birthDay , T3.tmID FROM Scoring AS T1 INNER JOIN Master AS T2 ON T2.playerID = T1.playerID INNER JOIN Teams AS T3 ON T3.tmID = T1.tmID WHERE (T2.firstNHL - T2.birthYear) BETWEEN 18 AND 24 AND T3.G < 5",
        "amends": [
            "Do select `nameGiven`, `lastName`, `birthYear`, `birthMon`, `birthDay`, and `tmID` instead of `name`, `year`, `team`, and `total_goals`. Do use `INNER JOIN` on `Master` with `playerID` instead of `JOIN` on `players` with `player_id`. Do add `INNER JOIN` on `Teams` with `tmID` instead of omitting it. Do filter with `(firstNHL - birthYear)` age calculation instead of direct `age` column. Do filter with `G < 5` instead of `total_goals <= 5`. Do remove `GROUP BY` and aggregate function instead of keeping them. Do remove `ORDER BY` instead of keeping it. The amended query now correctly calculates age from birth and debut years and filters by team goals instead of attempting to filter aggregates in WHERE.",
            "Do use table aliases `T2` and `T3` instead of full table names `m` and `t`. Do reference `T1.playerID` instead of `m.playerID` in the join condition. Do join on `T3.tmID = T1.tmID` instead of `s.tmID = t.tmID AND s.year = t.year`. Do remove the `m.birthCountry = 'CAN'` filter instead of keeping it. Do use direct subtraction `T2.firstNHL - T2.birthYear` instead of casting both to integers. Do reference `T3.G` instead of `s.G` for the goals filter. The amended query now correctly filters by team goals instead of player goals and removes the unnecessary country filter and year join condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name, p.year, p.team, COUNT(g.goal_id) as total_goals\nFROM players p\nJOIN goals g ON p.player_id = g.player_id\nWHERE p.nationality = 'Canadian'\n  AND p.age BETWEEN 18 AND 24\n  AND total_goals <= 5\nGROUP BY p.player_id\nORDER BY total_goals DESC;",
            "SELECT m.nameGiven, m.lastName, m.birthYear, m.birthMon, m.birthDay, s.tmID\nFROM Master m\nINNER JOIN Scoring s ON m.playerID = s.playerID\nINNER JOIN Teams t ON s.year = t.year AND s.tmID = t.tmID\nWHERE m.birthCountry = 'CAN'\n  AND CAST(m.firstNHL AS INTEGER) - CAST(m.birthYear AS INTEGER) BETWEEN 18 AND 24\n  AND s.G < 5;",
            "SELECT T2.nameGiven, T2.lastName, T2.birthYear, T2.birthMon, T2.birthDay, T1.tmID\nFROM Scoring T1\nINNER JOIN Master T2 ON T1.playerID = T2.playerID\nINNER JOIN Teams T3 ON T3.tmID = T1.tmID\nWHERE (T2.firstNHL - T2.birthYear) BETWEEN 18 AND 24\nAND T3.G < 5"
        ],
        "rule_sql": []
    },
    "2096": {
        "db_id": "world_development_indicators",
        "question": "How many low-income countries under the lending category of the International Development Associations have a note on the series code SM.POP.TOTL?",
        "ground_truth": "SELECT COUNT(T1.Countrycode) FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.LendingCategory = 'IDA' AND T2.Seriescode = 'SM.POP.TOTL' AND IncomeGroup = 'Low income'",
        "amends": [
            "Do use `COUNT(T1.Countrycode)` instead of `COUNT(*)` to count specific non-null values. Do reference `Country AS T1` and `CountryNotes AS T2` instead of `countries c`, `lending_categories lc`, and `series_notes sn` with corrected table names. Do use `INNER JOIN` with `T1.CountryCode = T2.Countrycode` instead of multiple joins including `c.lending_category_id = lc.id` and `c.country_code = sn.country_code`. Do filter with `T1.LendingCategory = 'IDA'` instead of joining to a separate lending_categories table and checking `lc.category_name = 'International Development Associations'`. Do include `IncomeGroup = 'Low income'` in WHERE clause instead of `c.income_level = 'Low income'` with corrected column name. Do maintain the filter `T2.Seriescode = 'SM.POP.TOTL'` but with corrected table alias and column name. The amended query now correctly counts low-income IDA countries with population series data using proper table relationships and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM countries c\nJOIN lending_categories lc ON c.lending_category_id = lc.id\nJOIN series_notes sn ON c.country_code = sn.country_code\nWHERE c.income_level = 'Low income'\nAND lc.category_name = 'International Development Associations'\nAND sn.series_code = 'SM.POP.TOTL';",
            "SELECT COUNT(T1.CountryCode) \nFROM Country AS T1\nINNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode\nWHERE T1.IncomeGroup = 'Low income' \nAND T1.LendingCategory = 'IDA' \nAND T2.Seriescode = 'SM.POP.TOTL'"
        ],
        "rule_sql": []
    },
    "221": {
        "db_id": "book_publishing_company",
        "question": "How many levels are there left for Diego W Roel to reach if he/she could go to the max level for his/her position?",
        "ground_truth": "SELECT T2.max_lvl - T1.job_lvl FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE T1.fname = 'Diego' AND T1.minit = 'W' AND T1.lname = 'Roel'",
        "amends": [
            "Do reference `employee` and `jobs` tables instead of only `employees`. Do use `INNER JOIN` on `job_id` instead of subqueries for position matching. Do filter by `fname`, `minit`, and `lname` columns instead of just `name`. Do calculate `max_lvl - job_lvl` directly instead of using a subquery for Diego's level. Do remove the subquery in the WHERE clause and instead join on `job_id` to get the position relationship. The amended query now correctly joins employee and job tables to calculate the level difference for the specified employee."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(level) - (SELECT level FROM employees WHERE name = 'Diego W Roel') AS levels_left FROM employees WHERE position = (SELECT position FROM employees WHERE name = 'Diego W Roel');",
            "SELECT j.max_lvl - e.job_lvl AS levels_left\nFROM employee e\nINNER JOIN jobs j ON e.job_id = j.job_id\nWHERE e.fname = 'Diego' AND e.minit = 'W' AND e.lname = 'Roel';"
        ],
        "rule_sql": []
    },
    "8158": {
        "db_id": "sales_in_weather",
        "question": "How many no.9 items from store no.11 were sold on 2012/12/7?",
        "ground_truth": "SELECT units FROM sales_in_weather WHERE `date` = '2012-12-07' AND store_nbr = 11 AND item_nbr = 9",
        "amends": [
            "Do select `units` instead of `COUNT(*)` to retrieve actual values rather than a count. Do reference table `sales_in_weather` instead of `sales` to access the correct data source. Do filter on column `date` with value '2012-12-07' instead of `sale_date` with '2012/12/7' to use the proper date column and ISO format. Do filter on `store_nbr = 11` instead of `store_id = 11` to use the correct column name for store identification. Do filter on `item_nbr = 9` instead of `item_id = 9` to use the proper column name for item identification. The amended query now correctly retrieves specific unit data from the appropriate table with accurate column references and date formatting."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE item_id = 9 AND store_id = 11 AND sale_date = '2012/12/7';",
            "SELECT units FROM sales_in_weather WHERE date = '2012-12-07' AND store_nbr = 11 AND item_nbr = 9"
        ],
        "rule_sql": []
    },
    "5966": {
        "db_id": "books",
        "question": "Among the books that cost less than 1 dollar, how many were published by Berkley Trade?",
        "ground_truth": "SELECT COUNT(*) FROM publisher AS T1 INNER JOIN book AS T2 ON T1.publisher_id = T2.publisher_id INNER JOIN order_line AS T3 ON T3.book_id = T2.book_id WHERE T1.publisher_name = 'Berkley' AND T3.price < 1",
        "amends": [
            "Do join `publisher AS T1` and `book AS T2` on `T1.publisher_id = T2.publisher_id` instead of querying `books` table directly. Do add join to `order_line AS T3` on `T3.book_id = T2.book_id` instead of omitting order line data. Do filter on `T1.publisher_name = 'Berkley'` instead of `publisher = 'Berkley Trade'` to match the correct publisher identifier. Do apply price filter `T3.price < 1` to order line prices instead of book prices. The amended query now correctly counts books from Berkley publisher with order line prices below $1.00, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE price < 1.00 AND publisher = 'Berkley Trade';",
            "SELECT COUNT(DISTINCT T2.book_id) \nFROM publisher AS T1 \nJOIN book AS T2 ON T1.publisher_id = T2.publisher_id \nJOIN order_line AS T3 ON T3.book_id = T2.book_id \nWHERE T1.publisher_name = 'Berkley' \nAND T3.price < 1"
        ],
        "rule_sql": []
    },
    "5455": {
        "db_id": "sales",
        "question": "Among the \"Mountain-500 Black\" product types, which type was purchased the most?",
        "ground_truth": "SELECT T1.Name FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name LIKE 'Mountain-500 Black%' GROUP BY T2.Quantity, T1.Name ORDER BY SUM(T2.Quantity) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `ProductType` and `COUNT(*) as PurchaseCount`. Do join `Sales AS T2` with `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying only the `Products` table. Do filter with `T1.Name LIKE 'Mountain-500 Black%'` instead of `ProductName = 'Mountain-500 Black'` for partial matching. Do group by `T2.Quantity, T1.Name` instead of only `ProductType`. Do order by `SUM(T2.Quantity) DESC` instead of `PurchaseCount DESC` to sort by total sales quantity rather than purchase count. The amended query now correctly joins sales data, uses proper partial string matching, aggregates sales quantities, and matches the RIGHT_SQL's behavior.",
            "Do remove `SUM(T2.Quantity) as TotalQuantity` from the SELECT list instead of including it. Do change the GROUP BY clause to include `T2.Quantity` along with `T1.Name` instead of grouping by `T1.Name` alone. Do change the ORDER BY clause to use `SUM(T2.Quantity) DESC` instead of `TotalQuantity DESC`. The amended query now correctly groups by both quantity and name while ordering by the sum of quantities, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*) as PurchaseCount` from the SELECT list instead of including it. Do change the GROUP BY clause to group by `T2.Quantity, T1.Name` instead of grouping by `T1.Name` alone. Do keep the ORDER BY clause with `SUM(T2.Quantity) DESC` instead of ordering by a different expression. Do maintain the LIMIT 1 constraint instead of removing it. The amended query now correctly focuses on retrieving the product name with the highest total quantity sold while maintaining proper grouping semantics."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ProductType, COUNT(*) as PurchaseCount \nFROM Products \nWHERE ProductName = 'Mountain-500 Black' \nGROUP BY ProductType \nORDER BY PurchaseCount DESC \nLIMIT 1;",
            "SELECT T1.Name, SUM(T2.Quantity) as TotalQuantity\nFROM Products AS T1\nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nWHERE T1.Name LIKE 'Mountain-500 Black%'\nGROUP BY T1.Name\nORDER BY TotalQuantity DESC\nLIMIT 1;",
            "SELECT T1.Name, COUNT(*) as PurchaseCount\nFROM Products AS T1\nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nWHERE T1.Name LIKE 'Mountain-500 Black%'\nGROUP BY T2.Quantity, T1.Name\nORDER BY SUM(T2.Quantity) DESC\nLIMIT 1;",
            "SELECT T1.Name\nFROM Products AS T1\nINNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID\nWHERE T1.Name LIKE 'Mountain-500 Black%'\nGROUP BY T2.Quantity, T1.Name\nORDER BY SUM(T2.Quantity) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8952": {
        "db_id": "human_resources",
        "question": "In which state does Emily Wood work?",
        "ground_truth": "SELECT T2.state FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID WHERE T1.firstname = 'Emily' AND T1.lastname = 'Wood'",
        "amends": [
            "Do select `T2.state` from the location table instead of `state` from employees. Do add `INNER JOIN location AS T2` on `T1.locationID = T2.locationID` instead of querying only the employees table. Do reference `T1.firstname` and `T1.lastname` with proper table aliases instead of direct column names without qualification. The amended query now correctly joins to the location table to retrieve the state information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM employees WHERE first_name = 'Emily' AND last_name = 'Wood';",
            "SELECT T2.state FROM employee AS T1 INNER JOIN location AS T2 ON T1.locationID = T2.locationID WHERE T1.firstname = 'Emily' AND T1.lastname = 'Wood'"
        ],
        "rule_sql": []
    },
    "955": {
        "db_id": "cs_semester",
        "question": "Calculate the difference between the average satisfaction of the students with high salaries and no salary.",
        "ground_truth": "SELECT AVG(T2.sat) - ( SELECT AVG(T2.sat) FROM RA AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE T1.salary = 'free' ) AS diff FROM RA AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE T1.salary = 'high'",
        "amends": [
            "Do use explicit table joins with `RA AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id` instead of querying a single table. Do filter with `WHERE T1.salary = 'high'` for the first average instead of using a CASE expression. Do calculate the second average as a correlated subquery `(SELECT AVG(T2.sat) FROM RA AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id WHERE T1.salary = 'free')` instead of using another CASE expression. Do reference the satisfaction column as `T2.sat` instead of just `satisfaction`. Do use salary value 'free' instead of 'no salary' in the subquery condition. The amended query now correctly calculates the satisfaction difference between high-salary and free-salary students using proper table relationships and avoids the incorrect single-table approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(CASE WHEN salary = 'high' THEN satisfaction END) - AVG(CASE WHEN salary = 'no salary' THEN satisfaction END) AS satisfaction_difference FROM students;",
            "SELECT \n    (SELECT AVG(T2.sat) \n     FROM RA AS T1 \n     INNER JOIN registration AS T2 ON T1.student_id = T2.student_id \n     WHERE T1.salary = 'high') - \n    (SELECT AVG(T2.sat) \n     FROM RA AS T1 \n     INNER JOIN registration AS T2 ON T1.student_id = T2.student_id \n     WHERE T1.salary = 'free') \n    AS satisfaction_difference"
        ],
        "rule_sql": []
    },
    "4144": {
        "db_id": "citeseer",
        "question": "Calculate the percentage of words used in Agents class label.",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.class_label = 'Agents' THEN T2.word_cited_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.word_cited_id) FROM paper AS T1 INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id",
        "amends": [
            "Do use `CAST(... AS REAL)` for precise division instead of implicit casting. Do calculate percentage from `COUNT(DISTINCT CASE WHEN T1.class_label = 'Agents' THEN T2.word_cited_id ELSE NULL END)` instead of simple `COUNT(*)` with a `WHERE` filter. Do reference tables `paper AS T1` and `content AS T2` with an `INNER JOIN` on `T1.paper_id = T2.paper_id` instead of querying only the `words` table. Do use `COUNT(DISTINCT T2.word_cited_id)` as the denominator instead of `(SELECT COUNT(*) FROM words)`. Do remove the subquery in favor of a single query with proper joins and conditional counting. The amended query now correctly calculates the percentage of distinct word citations classified as 'Agents' across joined paper and content tables, matching the RIGHT_SQL's behavior.",
            "Do place the multiplication by `100` after the division instead of before it, and do remove the redundant parentheses and explicit `* 100.0` formatting instead of keeping them. Do maintain the same `SELECT` list structure with the percentage calculation, `FROM` sources with `paper AS T1`, `INNER JOIN` type with `content AS T2` on `T1.paper_id = T2.paper_id`, and identical `COUNT(DISTINCT)` aggregations with the same `CASE` expression for filtering `class_label = 'Agents'`. The amended query now correctly calculates the percentage by multiplying after division and matches RIGHT_SQL's behavior.",
            "Do place the multiplication by 100 outside the division instead of multiplying the entire division result by 100.0. Do remove the explicit CAST operations around the denominator COUNT instead of keeping them. Do omit the column alias `percentage` instead of including it. The amended query now correctly calculates the percentage by multiplying the numerator by 100 before division, matches the RIGHT_SQL's behavior, and produces the same mathematical result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM words)) AS percentage FROM words WHERE class = 'Agents';",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.class_label = 'Agents' THEN T2.word_cited_id ELSE NULL END) AS REAL) / \n     CAST(COUNT(DISTINCT T2.word_cited_id) AS REAL)) * 100.0 AS percentage\nFROM \n    paper AS T1\nINNER JOIN \n    content AS T2 ON T1.paper_id = T2.paper_id;",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.class_label = 'Agents' THEN T2.word_cited_id ELSE NULL END) AS REAL) / \n     CAST(COUNT(DISTINCT T2.word_cited_id) AS REAL)) * 100.0 AS percentage\nFROM \n    paper AS T1\nINNER JOIN \n    content AS T2 ON T1.paper_id = T2.paper_id;",
            "SELECT \n    (COUNT(DISTINCT CASE WHEN T1.class_label = 'Agents' THEN T2.word_cited_id ELSE NULL END) * 100.0) / \n    COUNT(DISTINCT T2.word_cited_id) \nFROM \n    paper AS T1 \nINNER JOIN \n    content AS T2 ON T1.paper_id = T2.paper_id;"
        ],
        "rule_sql": []
    },
    "8828": {
        "db_id": "food_inspection",
        "question": "Mention the violation type ID and description of high risk category for STARBUCKS.",
        "ground_truth": "SELECT DISTINCT T1.violation_type_id, T1.description FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.name = 'STARBUCKS' AND T1.risk_category = 'High Risk'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do add table alias `T1` for the violations table instead of using the bare table name. Do add `INNER JOIN` to the `businesses` table (aliased as `T2`) instead of omitting this join entirely. Do change the join condition to `T1.business_id = T2.business_id` instead of the missing join. Do move the business name filter to reference `T2.name` instead of the non-existent `business_name` column. Do keep the `risk_category` filter but reference it through the table alias `T1` instead of the bare column name. The amended query now correctly joins to the businesses table to filter by business name and returns distinct results matching RIGHT_SQL's behavior.",
            "Do change the filter condition `T1.risk_category = 'High Risk'` instead of `T1.risk_category = 'high'` to match the correct risk category value in the database. The amended query now correctly filters for high risk violations with the proper category designation while maintaining the same join structure and business name filter, ensuring the results match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT violation_type_id, description FROM violations WHERE risk_category = 'High Risk' AND business_name = 'STARBUCKS';",
            "SELECT DISTINCT T1.violation_type_id, T1.description\nFROM violations T1\nINNER JOIN businesses T2 ON T1.business_id = T2.business_id\nWHERE T2.name = 'STARBUCKS' AND T1.risk_category = 'high'",
            "SELECT DISTINCT T1.violation_type_id, T1.description\nFROM violations T1\nINNER JOIN businesses T2 ON T1.business_id = T2.business_id\nWHERE T2.name = 'STARBUCKS' AND T1.risk_category = 'High Risk'"
        ],
        "rule_sql": []
    },
    "3442": {
        "db_id": "video_games",
        "question": "Which publisher has published the game 'Pachi-Slot Kanzen Kouryaku 3: Universal Koushiki Gaido Volume 3'?",
        "ground_truth": "SELECT T1.publisher_name FROM publisher AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.publisher_id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T3.game_name = 'Pachi-Slot Kanzen Kouryaku 3: Universal Koushiki Gaido Volume 3'",
        "amends": [
            "Do select `T1.publisher_name` from the `publisher` table instead of `publisher` from the `games` table. Do join `publisher AS T1` with `game_publisher AS T2` on `T1.id = T2.publisher_id` instead of querying a single table. Do add a second join with `game AS T3` on `T2.game_id = T3.id` instead of no joins. Do filter on `T3.game_name` instead of `title` to match the correct column name. The amended query now correctly retrieves publisher information through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM games WHERE title = 'Pachi-Slot Kanzen Kouryaku 3: Universal Koushiki Gaido Volume 3';",
            "SELECT T1.publisher_name \nFROM publisher AS T1\nJOIN game_publisher AS T2 ON T1.id = T2.publisher_id\nJOIN game AS T3 ON T2.game_id = T3.id\nWHERE T3.game_name = 'Pachi-Slot Kanzen Kouryaku 3: Universal Koushiki Gaido Volume 3'"
        ],
        "rule_sql": []
    },
    "6759": {
        "db_id": "retails",
        "question": "List the country name of the customers in the building marketing segment with an account balance greater than 80% of the average account balance of all customers.",
        "ground_truth": "SELECT T2.n_name FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey INNER JOIN ( SELECT AVG(c_acctbal) * 0.8 AS avg_acctbal FROM customer ) AS T3 WHERE T1.c_acctbal > T3.avg_acctbal",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `c_nationkey` and `n_nationkey` for the join condition instead of unspecified columns. Do add an explicit `INNER JOIN` with the nation table instead of omitting it. Do change the table name from `customers` to `customer` instead of using the wrong table name. Do use `c_acctbal` instead of `account_balance` for the balance comparison. Do replace the subquery in the WHERE clause with a derived table `T3` containing the calculated average balance instead of using a correlated subquery. Do use `n_name` instead of `country_name` for the output column instead of the incorrect column reference. Do remove the `building_segment` filter condition instead of including an irrelevant filter. The amended query now correctly joins customer and nation tables and compares account balances against a calculated threshold without unnecessary filters."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name \nFROM customers \nWHERE building_segment = 'marketing' \nAND account_balance > (SELECT AVG(account_balance) * 0.8 FROM customers);",
            "SELECT T2.n_name\nFROM customer T1\nINNER JOIN nation T2 ON T1.c_nationkey = T2.n_nationkey\nWHERE T1.c_mktsegment = 'BUILDING'\nAND T1.c_acctbal > (\n    SELECT AVG(c_acctbal) * 0.8 \n    FROM customer\n)"
        ],
        "rule_sql": []
    },
    "7055": {
        "db_id": "works_cycles",
        "question": "For the employee who has been hired the latest, what is his or her pay rate?",
        "ground_truth": "SELECT T1.Rate FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID ORDER BY T2.HireDate DESC LIMIT 1",
        "amends": [
            "Do select `T1.Rate` from the `EmployeePayHistory` table instead of `pay_rate` from `employees`. Do join `Employee AS T2` using `INNER JOIN` with predicate `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying a single table. Do order by `T2.HireDate DESC` instead of `hire_date ASC`. The amended query now correctly retrieves the most recent hire's pay rate from the joined employee pay history and employee tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pay_rate FROM employees ORDER BY hire_date ASC LIMIT 1;",
            "SELECT T1.Rate \nFROM EmployeePayHistory AS T1\nINNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nORDER BY T2.HireDate DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1880": {
        "db_id": "soccer_2016",
        "question": "List down names of teams that have played as second team against Pune Warriors.",
        "ground_truth": "SELECT T2.Team_Name FROM Match AS T1 INNER JOIN Team AS T2 ON T2.Team_Id = T1.Team_2 WHERE T1.Team_1 = ( SELECT Team_Id FROM Team WHERE Team_Name = 'Pune Warriors' ) GROUP BY T2.Team_Name",
        "amends": [
            "Do use `INNER JOIN` between `Match` and `Team` tables instead of a subquery with `IN` clause. Do join on `T2.Team_Id = T1.Team_2` instead of referencing `second_team_id` from the matches table. Do reference `T1.Team_1` in the subquery condition instead of `first_team_id`. Do add `GROUP BY T2.Team_Name` to handle potential duplicates instead of omitting aggregation. Do use table aliases `T1` and `T2` for clarity instead of no aliases. The amended query now correctly joins the tables directly and groups results to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE team_id IN (SELECT second_team_id FROM matches WHERE first_team_id = (SELECT team_id FROM teams WHERE team_name = 'Pune Warriors'))",
            "SELECT T2.Team_Name\nFROM Match T1\nINNER JOIN Team T2 ON T2.Team_Id = T1.Team_2\nWHERE T1.Team_1 = (\n    SELECT Team_Id \n    FROM Team \n    WHERE Team_Name = 'Pune Warriors'\n)\nGROUP BY T2.Team_Name;"
        ],
        "rule_sql": []
    },
    "8112": {
        "db_id": "university",
        "question": "What is the average score of all universities in 2012?",
        "ground_truth": "SELECT AVG(score) FROM university_ranking_year WHERE year = 2012",
        "amends": [
            "Do reference the `university_ranking_year` table instead of `universities` to access the correct data source containing score information. Do filter for `year = 2012` instead of `year = 2011` to calculate the average score for the correct year. The amended query now correctly retrieves the average score from the appropriate table for the specified year, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) FROM universities WHERE year = 2011;",
            "SELECT AVG(score) AS average_score FROM university_ranking_year WHERE year = 2012"
        ],
        "rule_sql": []
    },
    "2579": {
        "db_id": "regional_sales",
        "question": "List all the order numbers along with its product name for each order under the sales team of 'Douglas Tucker'.",
        "ground_truth": "SELECT DISTINCT T1.ProductID, T1.`Product Name` FROM Products AS T1 INNER JOIN `Sales Orders` AS T2 ON T2._ProductID = T1.ProductID INNER JOIN `Sales Team` AS T3 ON T3.SalesTeamID = T2._SalesTeamID WHERE T3.`Sales Team` = 'Douglas Tucker'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `ProductID` and `Product Name` instead of `order_number` and `product_name` to return product identifiers rather than order details. Do join `Sales Orders` as `T2` instead of directly joining `orders` to establish the proper relationship between products and sales team. Do use `INNER JOIN` with `T2._ProductID = T1.ProductID` instead of `JOIN` with `o.product_id = p.product_id` to correctly link products to sales orders. Do join `Sales Team` as `T3` with `T3.SalesTeamID = T2._SalesTeamID` instead of joining `sales_team` with `o.sales_team_id = s.team_id` to properly associate sales teams with orders. Do filter on `Sales Team` = 'Douglas Tucker' instead of `team_leader` = 'Douglas Tucker' to match the correct column name for team identification. The amended query now correctly returns distinct products sold by Douglas Tucker's sales team instead of order details.",
            "Do select `T1.ProductID` and `T1.Product Name` instead of `T2.OrderNumber` and `T1.Product Name`. Do use backticks for `Product Name` and table names instead of double quotes. Do remove the alias `AS` from `Products AS T1` instead of keeping it. Do use backticks for `Sales Orders` and `Sales Team` instead of double quotes. The amended query now correctly returns product information instead of order numbers and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o.order_number, p.product_name\nFROM orders o\nJOIN products p ON o.product_id = p.product_id\nJOIN sales_team s ON o.sales_team_id = s.team_id\nWHERE s.team_leader = 'Douglas Tucker';",
            "SELECT DISTINCT T2.OrderNumber, T1.\"Product Name\"\nFROM Products T1\nINNER JOIN \"Sales Orders\" T2 ON T2._ProductID = T1.ProductID\nINNER JOIN \"Sales Team\" T3 ON T3.SalesTeamID = T2._SalesTeamID\nWHERE T3.\"Sales Team\" = 'Douglas Tucker'",
            "SELECT DISTINCT T1.ProductID, T1.`Product Name`\nFROM Products T1\nINNER JOIN `Sales Orders` T2 ON T2._ProductID = T1.ProductID\nINNER JOIN `Sales Team` T3 ON T3.SalesTeamID = T2._SalesTeamID\nWHERE T3.`Sales Team` = 'Douglas Tucker'"
        ],
        "rule_sql": []
    },
    "5339": {
        "db_id": "beer_factory",
        "question": "How many bottles of beer have been bought by Jim Breech?",
        "ground_truth": "SELECT COUNT(T3.ContainerType) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T2.CustomerID = T1.CustomerID INNER JOIN rootbeer AS T3 ON T3.RootBeerID = T2.RootBeerID WHERE T3.ContainerType = 'Bottle' AND T1.First = 'Jim' AND T1.Last = 'Breech'",
        "amends": [
            "Do use `COUNT(T3.ContainerType)` instead of `COUNT(*)` to count specific non-null values. Do join three tables `customers AS T1`, `transaction AS T2`, and `rootbeer AS T3` with `INNER JOIN` conditions instead of querying a single `purchases` table. Do filter on `T3.ContainerType = 'Bottle'` instead of `product_type = 'wine'` to target different product criteria. Do filter customer name using separate `T1.First = 'Jim'` and `T1.Last = 'Breech'` conditions instead of a single `customer_name = 'Jim Breech'` field. The amended query now correctly joins related tables and applies appropriate filters to match the intended business logic.",
            "Do maintain the same `COUNT(T3.ContainerType)` in the SELECT list instead of changing it. Do keep the same table aliases `T1`, `T2`, and `T3` instead of altering them. Do correct the join condition in the first INNER JOIN to use `T2.CustomerID = T1.CustomerID` instead of `T1.CustomerID = T2.CustomerID` to ensure proper join direction. Do fix the second INNER JOIN condition to use `T3.RootBeerID = T2.RootBeerID` instead of `T2.RootBeerID = T3.RootBeerID` for consistent join predicate structure. Do reorder the WHERE clause predicates to place `T3.ContainerType = 'Bottle'` first instead of last, while maintaining the same logical filtering conditions with `T1.First = 'Jim'` and `T1.Last = 'Breech'`. The amended query now correctly matches the RIGHT_SQL's behavior with proper join conditions and predicate ordering.",
            "Do use backticks around the reserved word `transaction` in the FROM clause instead of leaving it unquoted. The amended query now correctly handles the reserved keyword and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM purchases WHERE customer_name = 'Jim Breech' AND product_type = 'wine';",
            "SELECT COUNT(T3.ContainerType) \nFROM customers AS T1\nINNER JOIN transaction AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID\nWHERE T1.First = 'Jim' \nAND T1.Last = 'Breech' \nAND T3.ContainerType = 'Bottle'",
            "SELECT COUNT(T3.ContainerType)\nFROM customers AS T1\nINNER JOIN transaction AS T2 ON T2.CustomerID = T1.CustomerID\nINNER JOIN rootbeer AS T3 ON T3.RootBeerID = T2.RootBeerID\nWHERE T3.ContainerType = 'Bottle'\nAND T1.First = 'Jim'\nAND T1.Last = 'Breech'",
            "SELECT COUNT(T3.ContainerType)\nFROM customers AS T1\nINNER JOIN `transaction` AS T2 ON T2.CustomerID = T1.CustomerID\nINNER JOIN rootbeer AS T3 ON T3.RootBeerID = T2.RootBeerID\nWHERE T3.ContainerType = 'Bottle'\nAND T1.First = 'Jim'\nAND T1.Last = 'Breech'"
        ],
        "rule_sql": []
    },
    "5888": {
        "db_id": "airline",
        "question": "How many cancelled flights are there?",
        "ground_truth": "SELECT COUNT(*) FROM Airlines WHERE CANCELLED = 1",
        "amends": [
            "Do reference the `Airlines` table instead of the `flights` table. Do filter on `CANCELLED = 1` instead of `status = 'cancelled'`. Do use the numeric flag `1` for cancellation status instead of the string literal 'cancelled'. The amended query now correctly counts cancelled flights from the appropriate table using the proper cancellation indicator."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE status = 'cancelled';",
            "SELECT COUNT(*) FROM Airlines WHERE CANCELLED = 1;"
        ],
        "rule_sql": []
    },
    "1971": {
        "db_id": "soccer_2016",
        "question": "Provide the players' names in both teams of the match that was held in June 2014.",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id WHERE SUBSTR(T3.Match_Date, 1, 4) = '2014' AND SUBSTR(T3.Match_Date, 7, 1) = '6' LIMIT 2",
        "amends": [
            "Do select `T1.Player_Name` from the `Player` table instead of `player_name` from `matches`. Do join `Player` as `T1` with `Player_Match` as `T2` on `T1.Player_Id = T2.Player_Id` instead of querying only the `matches` table. Do add a second join with `Match` as `T3` on `T2.Match_Id = T3.Match_Id` instead of missing these table relationships. Do use `SUBSTR(T3.Match_Date, 1, 4) = '2014'` and `SUBSTR(T3.Match_Date, 7, 1) = '6'` for precise date filtering instead of the ambiguous `LIKE '2014-06%'` pattern. Do add `LIMIT 2` to restrict results instead of returning all matches. The amended query now correctly joins the necessary tables and uses proper date extraction functions to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM matches WHERE match_date LIKE '2014-06%'",
            "SELECT T1.Player_Name\nFROM Player AS T1\nJOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id\nJOIN Match AS T3 ON T2.Match_Id = T3.Match_Id\nWHERE SUBSTR(T3.Match_Date, 1, 4) = '2014' \nAND SUBSTR(T3.Match_Date, 7, 1) = '6'\nLIMIT 2;"
        ],
        "rule_sql": []
    },
    "5901": {
        "db_id": "airline",
        "question": "From August 10 to August 20, 2018, how many cancelled flights of air carrier named Spirit Air Lines: NK are there?",
        "ground_truth": "SELECT COUNT(*) FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Spirit Air Lines: NK' AND T2.CANCELLED = 0 AND T2.FL_DATE BETWEEN '2018/8/10' AND '2018/8/20'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `f` and `c`. Do join on `T1.Code = T2.OP_CARRIER_AIRLINE_ID` instead of `f.carrier_id = c.id`. Do filter on `T1.Description = 'Spirit Air Lines: NK'` instead of `c.name = 'Spirit Air Lines: NK'`. Do filter on `T2.CANCELLED = 0` instead of `f.cancelled = 1`. Do use date format `'2018/8/10'` and `'2018/8/20'` instead of `'2018-08-10'` and `'2018-08-20'`. The amended query now correctly counts non-cancelled Spirit Air Lines flights within the specified date range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM flights f\nJOIN carriers c ON f.carrier_id = c.id\nWHERE c.name = 'Spirit Air Lines: NK'\nAND f.cancelled = 1\nAND f.flight_date BETWEEN '2018-08-10' AND '2018-08-20';",
            "SELECT COUNT(*) \nFROM \"Air Carriers\" T1\nJOIN Airlines T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID\nWHERE T1.Description = 'Spirit Air Lines: NK'\nAND T2.FL_DATE BETWEEN '2018/8/10' AND '2018/8/20'\nAND T2.CANCELLED = 0"
        ],
        "rule_sql": []
    },
    "437": {
        "db_id": "movies_4",
        "question": "What is the title of the movie that was made with the most money and resources?",
        "ground_truth": "SELECT title FROM movie ORDER BY budget DESC LIMIT 1",
        "amends": [
            "Do reference the `movie` table instead of the `movies` table in the FROM clause. The amended query now correctly references the single table `movie` and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies ORDER BY budget DESC LIMIT 1;",
            "SELECT title FROM movie ORDER BY budget DESC, revenue DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3786": {
        "db_id": "public_review_platform",
        "question": "Tell the number of \"hair removal\" Yelp businesses.",
        "ground_truth": "SELECT COUNT(T1.category_id) FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE T1.category_name LIKE 'Hair Removal'",
        "amends": [
            "Do select `COUNT(T1.category_id)` instead of `COUNT(*)` to count specific category instances rather than all rows. Do use `Categories AS T1` and `Business_Categories AS T2` as FROM sources instead of just `businesses`, adding an `INNER JOIN` on `T1.category_id = T2.category_id` instead of querying a single table. Do filter with `T1.category_name LIKE 'Hair Removal'` instead of `category = 'hair removal'` to use proper case-insensitive pattern matching against the category name field rather than an exact match on a different column. The amended query now correctly counts business categories by joining the appropriate tables and using proper filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE category = 'hair removal'",
            "SELECT COUNT(T2.category_id) \nFROM Categories AS T1 \nINNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id \nWHERE T1.category_name LIKE 'Hair Removal'"
        ],
        "rule_sql": []
    },
    "9242": {
        "db_id": "movie_3",
        "question": "Among the films starred by Nick Wahlberg, what is the percentage of the films with G rating?",
        "ground_truth": "SELECT CAST(SUM(IIF(T3.rating = 'G', 1, 0)) AS REAL) / COUNT(T3.film_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'Elvis' AND T1.last_name = 'Marx'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN f.rating = 'G' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_g_rated\nFROM film f\nJOIN film_actor fa ON f.film_id = fa.film_id\nJOIN actor a ON fa.actor_id = a.actor_id\nWHERE a.first_name = 'Nick' AND a.last_name = 'Wahlberg';"
        ],
        "rule_sql": []
    },
    "4485": {
        "db_id": "student_loan",
        "question": "List down the enrolled schools and duration of student214.",
        "ground_truth": "SELECT school, month FROM enrolled WHERE name = 'student214'",
        "amends": [
            "Do select `school` and `month` columns instead of `school_name` and `duration`. Do query from the `enrolled` table instead of the `students` table. Do filter on `name = 'student214'` instead of `student_id = 'student214'`. The amended query now correctly retrieves enrollment information from the appropriate table with the proper identifier column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, duration FROM students WHERE student_id = 'student214';",
            "SELECT school, month FROM enrolled WHERE name = 'student214';"
        ],
        "rule_sql": []
    },
    "7036": {
        "db_id": "works_cycles",
        "question": "Who is the Vice President of Engineering and when did he join the company? Indicate his/her full name.",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleName, T2.LastName, T1.HireDate FROM Employee AS T1 INNER JOIN Person AS T2 USING (BusinessEntityID) WHERE T1.JobTitle = 'Vice President of Engineering'",
        "amends": [
            "Do select `FirstName`, `MiddleName`, `LastName`, and `HireDate` instead of `name` and `join_date`. Do use `INNER JOIN` with `Person` table using `BusinessEntityID` instead of querying only the `employees` table. Do filter on `JobTitle` instead of `title`. Do add table aliases `T1` and `T2` instead of omitting them. The amended query now correctly joins employee and person data to retrieve complete name information with proper hire date filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, join_date FROM employees WHERE title = 'Vice President of Engineering';",
            "SELECT T2.FirstName, T2.MiddleName, T2.LastName, T1.HireDate\nFROM Employee AS T1\nINNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nWHERE T1.JobTitle = 'Vice President of Engineering';"
        ],
        "rule_sql": []
    },
    "119": {
        "db_id": "movie_platform",
        "question": "What's the number of users gave the movie \"Downfall\" a rating of \"4\"?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Downfall' AND T1.rating_score = 4",
        "amends": [
            "Do reference `T1.user_id` in the COUNT instead of `*` to count specific users. Do join `ratings AS T1` and `movies AS T2` instead of querying only the `users` table. Do use the join condition `T1.movie_id = T2.movie_id` instead of missing the necessary table relationship. Do filter on `T2.movie_title = 'Downfall'` instead of applying it to a non-existent column in the users table. Do filter on `T1.rating_score = 4` instead of `rating = 4` to use the correct column name from the ratings table. The amended query now correctly counts users who rated the specific movie with the specified score by properly joining the relevant tables.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the query already filters for specific ratings of a particular movie where user counts would naturally be distinct. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity, though both are functionally equivalent. The amended query now correctly counts all users who rated 'Downfall' with a score of 4, matching the intended behavior without unnecessary deduplication."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE movie_title = 'Downfall' AND rating = 4;",
            "SELECT COUNT(DISTINCT T1.user_id) \nFROM ratings AS T1 \nJOIN movies AS T2 ON T1.movie_id = T2.movie_id \nWHERE T2.movie_title = 'Downfall' AND T1.rating_score = 4",
            "SELECT COUNT(T1.user_id) \nFROM ratings AS T1 \nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id \nWHERE T2.movie_title = 'Downfall' AND T1.rating_score = 4"
        ],
        "rule_sql": []
    },
    "2941": {
        "db_id": "professional_basketball",
        "question": "Where was the high school of the player who had the most rebounds in the NBA allstar history?",
        "ground_truth": "SELECT T2.highSchool FROM player_allstar AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID ORDER BY T1.rebounds DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` between `player_allstar` and `players` tables on `playerID` instead of a subquery with `ORDER BY` and `LIMIT`. Do reference `highSchool` from the joined `players` table instead of `high_school` from the original table. Do apply the `ORDER BY rebounds DESC` and `LIMIT 1` to the main query instead of within a subquery. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly retrieves the high school of the player with the highest rebounds from the all-star statistics table instead of potentially incorrect results from the original approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT high_school FROM players WHERE player_id = (SELECT player_id FROM nba_allstar_stats ORDER BY rebounds DESC LIMIT 1);",
            "SELECT p.highSchool \nFROM player_allstar pa \nINNER JOIN players p ON pa.playerID = p.playerID \nORDER BY pa.rebounds DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4697": {
        "db_id": "disney",
        "question": "Among the movies released from 1991 to 2000, calculate the percentage of comedy movies. Provide any five movie titles and directors.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.genre = 'Comedy' THEN T1.movie_title ELSE NULL END) AS REAL) * 100 / COUNT(T1.movie_title), group_concat(T1.movie_title), group_concat(T2.director) FROM movies_total_gross AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name WHERE SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) BETWEEN '1991' AND '2000'",
        "amends": [
            "Do use `CAST(COUNT(CASE WHEN T1.genre = 'Comedy' THEN T1.movie_title ELSE NULL END) AS REAL) * 100 / COUNT(T1.movie_title)` instead of `(COUNT(CASE WHEN g.genre = 'Comedy' THEN 1 END) * 100.0 / COUNT(*))` for proper percentage calculation with explicit casting and movie_title counting. Do use `INNER JOIN director AS T2 ON T1.movie_title = T2.name` instead of `LEFT JOIN movie_genres mg ON m.id = mg.movie_id LEFT JOIN genres g ON mg.genre_id = g.id` to join directly with director table using movie_title matching. Do use `WHERE SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) BETWEEN '1991' AND '2000'` instead of `WHERE m.year BETWEEN 1991 AND 2000` to extract year from release_date string. Do add `group_concat(T1.movie_title)` and `group_concat(T2.director)` instead of selecting individual columns to aggregate results. Do remove `GROUP BY m.title, m.director` and `LIMIT 5` instead of keeping them since the query now returns aggregated results. The amended query now correctly calculates comedy percentages from the movies_total_gross table with proper year extraction and director joining."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    m.title, \n    m.director,\n    (COUNT(CASE WHEN g.genre = 'Comedy' THEN 1 END) * 100.0 / COUNT(*)) AS comedy_percentage\nFROM movies m\nLEFT JOIN movie_genres mg ON m.id = mg.movie_id\nLEFT JOIN genres g ON mg.genre_id = g.id\nWHERE m.year BETWEEN 1991 AND 2000\nGROUP BY m.title, m.director\nLIMIT 5;",
            "SELECT \n    CAST(COUNT(CASE WHEN T1.genre = 'Comedy' THEN T1.movie_title ELSE NULL END) AS REAL) * 100 / COUNT(T1.movie_title) AS comedy_percentage,\n    group_concat(T1.movie_title) AS movie_titles,\n    group_concat(T2.director) AS directors\nFROM \n    movies_total_gross AS T1\nINNER JOIN \n    director AS T2 ON T1.movie_title = T2.name\nWHERE \n    SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) BETWEEN '1991' AND '2000'\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "1846": {
        "db_id": "soccer_2016",
        "question": "List the cities located in U.A.E.",
        "ground_truth": "SELECT T1.City_Name FROM City AS T1 INNER JOIN Country AS T2 ON T2.Country_Id = T1.Country_id WHERE T2.Country_Name = 'U.A.E'",
        "amends": [
            "Do specify `T1.City_Name` in the SELECT list instead of using `*` to select all columns. Do join `City AS T1` with `Country AS T2` using `INNER JOIN` instead of querying only the `cities` table. Do use the join condition `T2.Country_Id = T1.Country_id` instead of no join condition. Do filter on `T2.Country_Name = 'U.A.E'` instead of `country = 'United Arab Emirates'` to correctly reference the joined table and use the proper country name format. The amended query now correctly retrieves city names by joining with the country table and using the appropriate country identifier, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cities WHERE country = 'United Arab Emirates';",
            "SELECT T1.City_Name FROM City AS T1 INNER JOIN Country AS T2 ON T2.Country_Id = T1.Country_id WHERE T2.Country_Name = 'U.A.E'"
        ],
        "rule_sql": []
    },
    "8162": {
        "db_id": "sales_in_weather",
        "question": "Which weather station does store no.20 belong to?",
        "ground_truth": "SELECT station_nbr FROM relation WHERE store_nbr = 20",
        "amends": [
            "Do select `station_nbr` instead of `*` for all columns. Do query from `relation` table instead of `stores` table. Do filter on `store_nbr = 20` instead of `store_id = 20` to use the correct column name and table structure. The amended query now correctly retrieves station numbers from the relation table for store number 20, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM stores WHERE store_id = 20;",
            "SELECT station_nbr FROM relation WHERE store_nbr = 20"
        ],
        "rule_sql": []
    },
    "4422": {
        "db_id": "student_loan",
        "question": "Which organization does student 313 belong to?",
        "ground_truth": "SELECT organ FROM enlist WHERE name = 'studenT113'",
        "amends": [
            "Do select `organ` instead of `organization` and do query from `enlist` instead of `students`. Do filter on `name = 'studenT113'` instead of `student_id = 313`. The amended query now correctly retrieves data from the appropriate table with the proper filtering condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization FROM students WHERE student_id = 313;",
            "SELECT organ FROM enlist WHERE name = 'studenT113';"
        ],
        "rule_sql": []
    },
    "5069": {
        "db_id": "olympics",
        "question": "List down the games ID of games held in Tokyo.",
        "ground_truth": "SELECT T1.games_id FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE T2.city_name = 'Tokyo'",
        "amends": [
            "Do reference `T1.games_id` from the `games_city` table instead of `game_id` from the `games` table. Do join `games_city AS T1` with `city AS T2` on `T1.city_id = T2.id` instead of querying the `games` table directly. Do filter on `T2.city_name = 'Tokyo'` instead of `city = 'Tokyo'` to properly reference the normalized city name. The amended query now correctly joins the relationship table and uses the proper foreign key relationships to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_id FROM games WHERE city = 'Tokyo';",
            "SELECT T1.games_id FROM games_city AS T1 JOIN city AS T2 ON T1.city_id = T2.id WHERE T2.city_name = 'Tokyo'"
        ],
        "rule_sql": []
    },
    "320": {
        "db_id": "retail_complains",
        "question": "What are the products that people who were born after 2005 complain about?",
        "ground_truth": "SELECT DISTINCT T2.Product FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.year > 2005",
        "amends": [
            "Do use `DISTINCT` on `T2.Product` instead of omitting it to eliminate duplicate product entries. Do reference tables `client AS T1` and `events AS T2` instead of `products`, `complaints`, and `customers` to align with the correct schema. Do perform an `INNER JOIN` on `T1.client_id = T2.Client_ID` instead of chained joins on `p.product_id = c.product_id` and `c.customer_id = cust.customer_id` to establish the proper relationship. Do filter on `T1.year > 2005` instead of `cust.birth_year > 2005` to use the correct column name and table reference. The amended query now correctly retrieves distinct products from events for clients born after 2005, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.product_name \nFROM products p\nJOIN complaints c ON p.product_id = c.product_id\nJOIN customers cust ON c.customer_id = cust.customer_id\nWHERE cust.birth_year > 2005;",
            "SELECT DISTINCT T2.Product\nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T1.year > 2005"
        ],
        "rule_sql": []
    },
    "164": {
        "db_id": "movie_platform",
        "question": "Who is the director of the most popular movie of all time and when was it released? Indicate the average rating score of the users who were on a trialist when they rated the movie.",
        "ground_truth": "SELECT T1.director_name, T1.movie_release_year , SUM(T2.rating_score) / COUNT(T2.user_id) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T2.user_trialist = 1 ORDER BY T1.movie_popularity DESC LIMIT 1",
        "amends": [
            "Do select `director_name` and `movie_release_year` instead of `d.name` and `m.release_date`, and calculate average rating using `SUM(T2.rating_score) / COUNT(T2.user_id)` instead of `AVG(r.rating)`. Do join only `movies` and `ratings` tables instead of including unnecessary `directors` and `users` tables. Do filter with `WHERE T2.user_trialist = 1` instead of joining the `users` table and checking `u.status = 'trialist'`. Do remove the subquery for maximum popularity and instead use `ORDER BY T1.movie_popularity DESC` to get the most popular movie. Do remove `GROUP BY` since we're only returning one row with the highest popularity. The amended query now correctly finds the most popular movie's director, release year, and average rating from trialist users only.",
            "Do remove the `GROUP BY` clause with `m.movie_id`, `m.director_name`, and `m.movie_release_year` instead of grouping by multiple columns. Do replace the subquery filter `m.movie_popularity = (SELECT MAX(movie_popularity) FROM movies)` with `ORDER BY T1.movie_popularity DESC LIMIT 1` instead of using an equality comparison. Do add `ORDER BY T1.movie_popularity DESC` instead of omitting ordering. Do remove the alias `AS average_rating` from the aggregate calculation instead of keeping it. Do change the join syntax to `INNER JOIN` with explicit `AS` table aliases instead of implicit aliases. The amended query now correctly returns the single most popular movie with trialist ratings instead of potentially multiple grouped results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT d.name, m.release_date, AVG(r.rating) as avg_rating\nFROM directors d\nJOIN movies m ON d.movie_id = m.id\nJOIN ratings r ON m.id = r.movie_id\nJOIN users u ON r.user_id = u.id\nWHERE m.popularity = (SELECT MAX(popularity) FROM movies)\nAND u.status = 'trialist'\nGROUP BY d.name, m.release_date\nLIMIT 1;",
            "SELECT \n    m.director_name,\n    m.movie_release_year,\n    SUM(r.rating_score) / COUNT(r.user_id) AS average_rating\nFROM \n    movies m\nJOIN \n    ratings r ON m.movie_id = r.movie_id\nWHERE \n    r.user_trialist = 1\n    AND m.movie_popularity = (SELECT MAX(movie_popularity) FROM movies)\nGROUP BY \n    m.movie_id, m.director_name, m.movie_release_year\nLIMIT 1;",
            "SELECT \n    T1.director_name, \n    T1.movie_release_year,\n    SUM(T2.rating_score) / COUNT(T2.user_id) AS average_rating\nFROM movies AS T1\nINNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id\nWHERE T2.user_trialist = 1\nORDER BY T1.movie_popularity DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8052": {
        "db_id": "university",
        "question": "How many universities got less than 50 scores under ranking criteria ID 6 in 2011?",
        "ground_truth": "SELECT COUNT(*) FROM university_ranking_year WHERE ranking_criteria_id = 6 AND year = 2011 AND score < 50",
        "amends": [
            "Do query the `university_ranking_year` table instead of `university_rankings`. Do use the filter `score < 50` instead of `score > 50` to count records with scores below 50 rather than above 50. The amended query now correctly counts universities meeting the specified ranking criteria and year with scores less than 50, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM university_rankings WHERE ranking_criteria_id = 6 AND year = 2011 AND score > 50;",
            "SELECT COUNT(DISTINCT university_id) \nFROM university_ranking_year \nWHERE ranking_criteria_id = 6 \nAND year = 2011 \nAND score < 50"
        ],
        "rule_sql": []
    },
    "269": {
        "db_id": "retail_complains",
        "question": "What was the phone of number of the client who made the complaint call \"CR0100432\" \uff1f",
        "ground_truth": "SELECT T1.phone FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Complaint ID` = 'CR0100432'",
        "amends": [
            "Do select `phone` from the `client` table instead of `phone_number` from the `complaints` table. Do join `client AS T1` with `events AS T2` using an `INNER JOIN` on `T1.client_id = T2.Client_ID` instead of querying the `complaints` table directly. Do filter on `T2.Complaint ID = 'CR0100432'` instead of filtering directly on `complaint_id` in the complaints table. The amended query now correctly retrieves the phone number from the client table by joining with events using the proper relationship between client_id and Client_ID, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM complaints WHERE complaint_id = 'CR0100432';",
            "SELECT T1.phone FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.\"Complaint ID\" = 'CR0100432'"
        ],
        "rule_sql": []
    },
    "7490": {
        "db_id": "image_and_language",
        "question": "What is the percentage of the object samples in the class of \"man\" in image no.1?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.OBJ_CLASS_ID) FROM OBJ_CLASSES AS T1 INNER JOIN IMG_OBJ AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.IMG_ID = 1",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of direct table references. Do join tables `OBJ_CLASSES` and `IMG_OBJ` with `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of querying a single table. Do filter on `T2.IMG_ID = 1` instead of `image_id = 1`. Do calculate percentage using `COUNT(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE NULL END)` for conditional counting instead of `COUNT(*)` with WHERE filter. Do divide by `COUNT(T1.OBJ_CLASS_ID)` instead of a subquery count. Do explicitly `CAST` the result to `REAL` instead of using decimal multiplication. Do remove the subquery entirely instead of keeping it. The amended query now correctly calculates the percentage of 'man' objects relative to all objects in image 1 using proper table joins and conditional aggregation.",
            "Do remove the parentheses around the division operation instead of keeping them, as the mathematical operator precedence makes them unnecessary. Do maintain the same `SELECT` list with `CAST`, `COUNT` with `CASE` expression for 'man' detection, and division by total count multiplied by 100 instead of changing the calculation logic. Do preserve the `INNER JOIN` on `T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID` instead of altering the join condition. Do keep the `WHERE` filter on `T2.IMG_ID = 1` instead of modifying it. The amended query now correctly calculates the percentage without redundant parentheses while maintaining identical behavior to the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM objects WHERE image_id = 1)) AS percentage FROM objects WHERE class = 'man' AND image_id = 1;",
            "SELECT \n    (CAST(COUNT(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE NULL END) AS REAL) / COUNT(T1.OBJ_CLASS_ID)) * 100.0 AS percentage\nFROM \n    OBJ_CLASSES T1\nINNER JOIN \n    IMG_OBJ T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE \n    T2.IMG_ID = 1",
            "SELECT CAST(COUNT(CASE WHEN T1.OBJ_CLASS = 'man' THEN 1 ELSE NULL END) * 100.0 / COUNT(T2.OBJ_CLASS_ID) AS REAL) AS percentage\nFROM OBJ_CLASSES T1\nINNER JOIN IMG_OBJ T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nWHERE T2.IMG_ID = 1"
        ],
        "rule_sql": []
    },
    "5993": {
        "db_id": "books",
        "question": "What is the most common domain for the email address among all the customers?",
        "ground_truth": "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS ym FROM customer GROUP BY SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do extract the domain part using `SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))` as `ym` instead of selecting the full `email` column. Do group by the extracted domain expression instead of grouping by the full email address. Do order by `COUNT(*)` descending instead of ordering by the alias `count`. Do reference the correct table name `customer` instead of `customers`. The amended query now correctly identifies the most common email domain rather than counting individual email addresses, matching the intended behavior.",
            "Do alias the domain extraction as `ym` instead of `domain` in the SELECT list, while keeping the same SUBSTR expression and GROUP BY clause unchanged. Do maintain the ORDER BY `COUNT(*) DESC` and `LIMIT 1` to find the most frequent email domain. The amended query now matches RIGHT_SQL's behavior with the corrected alias name.",
            "Do group by the full `SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))` expression instead of grouping by the alias `ym` to ensure proper aggregation behavior. Do keep the `ORDER BY COUNT(*) DESC LIMIT 1` clause unchanged as it correctly identifies the most frequent domain. The amended query now correctly groups by the actual domain extraction expression rather than the column alias, ensuring accurate results while maintaining the same ordering and limiting behavior.",
            "Do remove the `COUNT(*) AS count` column from the SELECT list instead of including it, as the RIGHT_SQL only needs the domain portion extracted from email addresses. Do keep the identical GROUP BY expression using `SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))` for grouping by email domains. Do maintain the `ORDER BY COUNT(*) DESC` clause to sort by the count of occurrences in descending order instead of changing it. Do preserve the `LIMIT 1` clause to return only the most frequent domain instead of retrieving multiple results. The amended query now correctly returns only the most common email domain without the count column, matching RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email, COUNT(*) as count FROM customers GROUP BY email ORDER BY count DESC LIMIT 1;",
            "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS domain, COUNT(*) AS count FROM customer GROUP BY SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS ym, COUNT(*) AS count FROM customer GROUP BY ym ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS ym, COUNT(*) AS count\nFROM customer\nGROUP BY SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@')) AS ym\nFROM customer\nGROUP BY SUBSTR(email, INSTR(email, '@') + 1, LENGTH(email) - INSTR(email, '@'))\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7002": {
        "db_id": "works_cycles",
        "question": "Name all products and total quantity for each item for shopping cart ID 14951.",
        "ground_truth": "SELECT T1.Name, T2.Quantity FROM Product AS T1 INNER JOIN ShoppingCartItem AS T2 ON T1.ProductID = T2.ProductID WHERE T2.ShoppingCartID = 14951",
        "amends": [
            "Do select `T1.Name` and `T2.Quantity` instead of `product_name` and `SUM(quantity) as total_quantity`. Do use `FROM Product AS T1 INNER JOIN ShoppingCartItem AS T2` instead of `FROM shopping_cart_items` alone. Do add join condition `ON T1.ProductID = T2.ProductID` instead of omitting the table join entirely. Do move the filter to `WHERE T2.ShoppingCartID = 14951` instead of `WHERE cart_id = 14951` with different column reference. Do remove `GROUP BY product_id` and aggregation instead of keeping them, as the right query returns individual rows rather than aggregated totals. The amended query now correctly joins product information with cart items and returns individual item quantities instead of aggregated sums, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, SUM(quantity) as total_quantity FROM shopping_cart_items WHERE cart_id = 14951 GROUP BY product_id;",
            "SELECT T1.Name, T2.Quantity\nFROM Product AS T1\nINNER JOIN ShoppingCartItem AS T2 ON T1.ProductID = T2.ProductID\nWHERE T2.ShoppingCartID = '14951'"
        ],
        "rule_sql": []
    },
    "3224": {
        "db_id": "donor",
        "question": "Among the schools whose donators are teachers, what is the percentage of schools that are in Brooklyn?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.school_city LIKE 'Brooklyn' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.teacher_acctid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.is_teacher_acct = 't'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.school_city LIKE 'Brooklyn' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN s.borough = 'Brooklyn' THEN 1 END)` for conditional counting. Do join `projects AS T1` instead of `schools s` as the main table. Do use `INNER JOIN donations AS T2 ON T1.projectid = T2.projectid` instead of `JOIN donations d ON s.school_id = d.school_id` with corrected join condition. Do remove the `teachers t` table join entirely instead of keeping it. Do filter with `WHERE T2.is_teacher_acct = 't'` instead of `WHERE t.occupation = 'teacher'`. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T1.teacher_acctid)` instead of `* 100.0 / COUNT(*)` with proper casting and count of specific column. Do reference `school_city` instead of `borough` for the location field. The amended query now correctly calculates the percentage of Brooklyn-based teacher account donations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN s.borough = 'Brooklyn' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM schools s\nJOIN donations d ON s.school_id = d.school_id\nJOIN teachers t ON d.donator_id = t.teacher_id\nWHERE t.occupation = 'teacher';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.school_city LIKE 'Brooklyn' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.teacher_acctid) AS percentage\nFROM \n    projects AS T1\nINNER JOIN \n    donations AS T2 ON T1.projectid = T2.projectid\nWHERE \n    T2.is_teacher_acct = 't';"
        ],
        "rule_sql": []
    },
    "2838": {
        "db_id": "professional_basketball",
        "question": "How many teams have played more than 3800 points and have player with \"Most Valuable Player\" award?",
        "ground_truth": "SELECT COUNT(DISTINCT T4.name) FROM ( SELECT T1.name, SUM(T2.points) FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year INNER JOIN awards_players AS T3 ON T2.playerID = T3.playerID WHERE T3.award = 'Most Valuable Player' GROUP BY T1.name HAVING SUM(T2.points) >= 3800 ) AS T4",
        "amends": [
            "Do use `COUNT(DISTINCT T4.name)` instead of `COUNT(*)` to count distinct team names rather than all player-team combinations. Do change the FROM clause to use a subquery `T4` instead of directly joining tables. Do add `teams AS T1` with proper alias instead of just `teams t`. Do use `INNER JOIN players_teams AS T2` with join condition `T1.tmID = T2.tmID AND T1.year = T2.year` instead of `JOIN players p ON t.team_id = p.team_id`. Do add `INNER JOIN awards_players AS T3 ON T2.playerID = T3.playerID` to connect to awards data instead of filtering players directly. Do move the award filter to `WHERE T3.award = 'Most Valuable Player'` instead of `WHERE p.award`. Do use `GROUP BY T1.name` and `HAVING SUM(T2.points) >= 3800` instead of `WHERE t.points > 3800` to aggregate team points and filter after aggregation. The amended query now correctly counts distinct teams that have players who won MVP awards with total points of at least 3800, matching the RIGHT_SQL's behavior.",
            "Do use a subquery to calculate `SUM(T2.points)` and filter teams with `>= 3800` points instead of filtering with `> 3800` in the `HAVING` clause. Do reference the subquery alias `T4` instead of directly using `T1.name` in the outer query. Do change the inequality operator to `>=` instead of `>` to include teams with exactly 3800 points. Do restructure the query to count distinct team names from the filtered subquery results instead of applying the aggregate filter directly in the main query's HAVING clause. The amended query now correctly counts teams with MVP players that have at least 3800 total points, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM teams t\nJOIN players p ON t.team_id = p.team_id\nWHERE t.points > 3800\nAND p.award = 'Most Valuable Player';",
            "SELECT COUNT(DISTINCT T1.name) \nFROM teams AS T1\nINNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\nINNER JOIN awards_players AS T3 ON T2.playerID = T3.playerID\nWHERE T3.award = 'Most Valuable Player'\nGROUP BY T1.name\nHAVING SUM(T2.points) > 3800",
            "SELECT COUNT(DISTINCT T4.name)\nFROM (\n    SELECT T1.name, SUM(T2.points) AS total_points\n    FROM teams AS T1\n    INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year\n    INNER JOIN awards_players AS T3 ON T2.playerID = T3.playerID\n    WHERE T3.award = 'Most Valuable Player'\n    GROUP BY T1.name\n    HAVING SUM(T2.points) >= 3800\n) AS T4"
        ],
        "rule_sql": []
    },
    "5144": {
        "db_id": "address",
        "question": "Which zip code in Massachusetts that have more than 1 area code?",
        "ground_truth": "SELECT T1.zip_code FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.state = 'MA' GROUP BY T1.zip_code HAVING COUNT(T1.area_code) > 1",
        "amends": [
            "Do select `T1.zip_code` with table alias instead of `zip_code` without qualification. Do join `area_code AS T1` and `zip_data AS T2` with `INNER JOIN` on `T1.zip_code = T2.zip_code` instead of querying only `massachusetts_zip_codes`. Do add filter `T2.state = 'MA'` instead of omitting state filtering. Do add `GROUP BY T1.zip_code` and `HAVING COUNT(T1.area_code) > 1` instead of simple `WHERE area_code > 1` filter, which now correctly counts area codes per zip code rather than comparing a single area code value. The amended query now matches RIGHT_SQL's behavior by properly joining tables, filtering for Massachusetts, and counting area codes per zip code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM massachusetts_zip_codes WHERE area_code > 1;",
            "SELECT T1.zip_code\nFROM area_code AS T1\nINNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code\nWHERE T2.state = 'MA'\nGROUP BY T1.zip_code\nHAVING COUNT(T1.area_code) > 1"
        ],
        "rule_sql": []
    },
    "47": {
        "db_id": "movie_platform",
        "question": "What is the average popularity of each movie that was directed by Christopher Nolan? Indicate which movie directed by him has received the highest number of 5 rating scores.",
        "ground_truth": "SELECT AVG(T2.movie_popularity) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.director_name = 'Christopher Nolan'",
        "amends": [
            "Do use `AVG(T2.movie_popularity)` as the sole aggregate instead of selecting `m.title`, `AVG(r.rating)`, and `COUNT(CASE WHEN r.rating = 5 THEN 1 END)`. Do join `ratings AS T1` with `movies AS T2` using `T1.movie_id = T2.movie_id` instead of joining `movies m` with `directors d` on `m.director_id = d.director_id` and then with `ratings r` on `m.movie_id = r.movie_id`. Do filter directly on `T2.director_name = 'Christopher Nolan'` instead of filtering through the directors table. Do remove `GROUP BY m.title`, `ORDER BY five_star_count DESC`, and `LIMIT 1` instead of keeping them. The amended query now correctly calculates the average popularity of Christopher Nolan's movies by directly accessing the director_name field in the movies table rather than through an unnecessary join to the directors table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    m.title,\n    AVG(r.rating) AS average_popularity,\n    COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_count\nFROM movies m\nJOIN directors d ON m.director_id = d.director_id\nJOIN ratings r ON m.movie_id = r.movie_id\nWHERE d.director_name = 'Christopher Nolan'\nGROUP BY m.title\nORDER BY five_star_count DESC\nLIMIT 1;",
            "SELECT AVG(T2.movie_popularity) AS average_popularity\nFROM ratings AS T1\nJOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE T2.director_name = 'Christopher Nolan'"
        ],
        "rule_sql": []
    },
    "794": {
        "db_id": "social_media",
        "question": "What is the average number of tweets posted by the users in a city in Argentina?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.City = 'Buenos Aires' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID) AS avg FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T2.Country = 'Argentina'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.City = 'Buenos Aires' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID)` instead of `AVG(tweet_count)` to calculate the specific ratio of Buenos Aires tweets to total tweets. Do join `twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID` instead of querying only the `users` table to properly relate tweet and location data. Do filter with `WHERE T2.Country = 'Argentina'` instead of `WHERE country = 'Argentina'` to use the correct table reference. Do remove `GROUP BY city` instead of keeping it since the query now calculates a single aggregate ratio rather than per-city averages. The amended query now correctly computes the proportion of tweets from Buenos Aires among all Argentine tweets, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(tweet_count) FROM users WHERE country = 'Argentina' GROUP BY city;",
            "SELECT SUM(CASE WHEN T2.City = 'Buenos Aires' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID) \nFROM twitter AS T1 \nINNER JOIN location AS T2 ON T2.LocationID = T1.LocationID \nWHERE T2.Country = 'Argentina'"
        ],
        "rule_sql": []
    },
    "2614": {
        "db_id": "regional_sales",
        "question": "Calculate the average net profit of phones which have sales channel of distributor.",
        "ground_truth": "SELECT SUM(REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '')) / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID WHERE T2.`Product Name` = 'Phones' AND T1.`Sales Channel` = 'Distributor'",
        "amends": [
            "Do use `SUM(REPLACE(T1.Unit Price, ',', '') - REPLACE(T1.Unit Cost, ',', '')) / COUNT(T1.OrderNumber)` instead of `AVG(price - cost)` for proper numeric calculation with comma removal. Do join `Sales Orders AS T1 INNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID` instead of querying only the `phones` table. Do filter on `T2.Product Name = 'Phones' AND T1.Sales Channel = 'Distributor'` instead of `sales_channel = 'retailer'` to target the correct product category and sales channel. The amended query now correctly calculates average profit margin for phone products sold through the distributor channel."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price - cost) FROM phones WHERE sales_channel = 'retailer';",
            "SELECT SUM(REPLACE(T1.\"Unit Price\", ',', '') - REPLACE(T1.\"Unit Cost\", ',', '')) / COUNT(T1.OrderNumber) AS average_net_profit\nFROM \"Sales Orders\" AS T1\nINNER JOIN Products AS T2 ON T2.ProductID = T1._ProductID\nWHERE T2.\"Product Name\" = 'Phones' AND T1.\"Sales Channel\" = 'Distributor'"
        ],
        "rule_sql": []
    },
    "2958": {
        "db_id": "shakespeare",
        "question": "Please list the character names of all the characters from the work Twelfth Night.",
        "ground_truth": "SELECT DISTINCT T4.CharName FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.Title = 'Twelfth Night'",
        "amends": [
            "Do use `DISTINCT T4.CharName` instead of `character_name` without distinct. Do join multiple tables starting with `works AS T1` instead of querying only the `characters` table. Do add `INNER JOIN chapters AS T2 ON T1.id = T2.work_id` instead of omitting this relationship. Do add `INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id` instead of omitting this intermediate table. Do add `INNER JOIN characters AS T4 ON T3.character_id = T4.id` instead of directly querying characters. Do filter on `T1.Title = 'Twelfth Night'` instead of `work_title = 'Hamlet'` to reference the correct work title. The amended query now correctly retrieves distinct character names from the specified work through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM characters WHERE work_title = 'Hamlet';",
            "SELECT DISTINCT T4.CharName\nFROM works AS T1\nINNER JOIN chapters AS T2 ON T1.id = T2.work_id\nINNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id\nINNER JOIN characters AS T4 ON T3.character_id = T4.id\nWHERE T1.Title = 'Twelfth Night'"
        ],
        "rule_sql": []
    },
    "1744": {
        "db_id": "restaurant",
        "question": "Please indicate the street names of restaurants with food type is American.",
        "ground_truth": "SELECT T1.street_name FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T2.food_type = 'American'",
        "amends": [
            "Do select `T1.street_name` from the `location` table instead of `street_name` from the `restaurants` table. Do join `generalinfo AS T2` using `INNER JOIN` on `T1.city = T2.city` instead of querying a single table. Do filter on `T2.food_type = 'American'` in the WHERE clause instead of filtering directly on the restaurants table. The amended query now correctly joins location and generalinfo tables to retrieve street names for American food restaurants, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street_name FROM restaurants WHERE food_type = 'American';",
            "SELECT T1.street_name FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T2.food_type = 'American'"
        ],
        "rule_sql": []
    },
    "1233": {
        "db_id": "talkingdata",
        "question": "Please provide the gender of at least one user who owns an HTC Desire 826 device.",
        "ground_truth": "SELECT T1.gender FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Desire 826' AND T2.phone_brand = 'HTC'",
        "amends": [
            "Do select `T1.gender` from the `gender_age` table instead of `gender` from the `users` table. Do join `phone_brand_device_model2` as `T2` with an `INNER JOIN` on `T1.device_id = T2.device_id` instead of querying a single table. Do filter on `T2.device_model = 'Desire 826'` and `T2.phone_brand = 'HTC'` instead of `device = 'HTC Desire 826'`. Do remove the `LIMIT 1` clause instead of keeping it. The amended query now correctly retrieves gender information by joining device tables with proper brand and model filtering instead of relying on a single table with combined device strings."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE device = 'HTC Desire 826' LIMIT 1;",
            "SELECT T1.gender FROM gender_age T1 INNER JOIN phone_brand_device_model2 T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'HTC' AND T2.device_model = 'Desire 826'"
        ],
        "rule_sql": []
    },
    "1898": {
        "db_id": "soccer_2016",
        "question": "In the players, how many were out by hit wicket?",
        "ground_truth": "SELECT Player_Out FROM Wicket_Taken AS T1 INNER JOIN Out_Type AS T2 ON T1.Kind_Out = T2.Out_Id WHERE Out_Name = 'hit wicket'",
        "amends": [
            "Do select `Player_Out` instead of `COUNT(*)` to return individual player IDs rather than an aggregate count. Do use `FROM Wicket_Taken AS T1 INNER JOIN Out_Type AS T2` instead of `FROM players` to join the wicket and out type tables rather than querying a single players table. Do add join condition `ON T1.Kind_Out = T2.Out_Id` instead of omitting it to properly relate the wicket type to the out type. Do change filter to `WHERE Out_Name = 'hit wicket'` instead of `WHERE dismissal = 'hit wicket'` to filter on the descriptive out name column rather than a dismissal column that may not exist. The amended query now correctly identifies players who were out by hit wicket by joining the appropriate tables and filtering on the proper out type description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE dismissal = 'hit wicket';",
            "SELECT Player_Out FROM Wicket_Taken AS T1 INNER JOIN Out_Type AS T2 ON T1.Kind_Out = T2.Out_Id WHERE Out_Name = 'hit wicket'"
        ],
        "rule_sql": []
    },
    "5835": {
        "db_id": "airline",
        "question": "Which airline operated more flights on 2018/8/1, American Airlines Inc. or Endeavor Air Inc.?",
        "ground_truth": "SELECT CASE WHEN COUNT(CASE WHEN T3.Description = 'American Airlines Inc.: AA' THEN 1 ELSE NULL END) > COUNT(CASE WHEN T3.Description = 'Endeavor Air Inc.: 9E' THEN 1 ELSE NULL END) THEN 'American Airlines Inc.: AA' ELSE 'Endeavor Air Inc.: 9E' END AS RESULT FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN `Air Carriers` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE T2.FL_DATE = '2018/8/1'",
        "amends": [
            "Do use a `CASE` expression with conditional counts comparing `American Airlines Inc.: AA` and `Endeavor Air Inc.: 9E` instead of a simple `COUNT(*)` grouped by airline. Do join `Airports` as `T1` with `Airlines` as `T2` on `T1.Code = T2.ORIGIN` instead of querying only the `flights` table. Do add an additional join to `Air Carriers` as `T3` on `T2.OP_CARRIER_AIRLINE_ID = T3.Code` instead of using an `IN` clause with airline names. Do filter on `T2.FL_DATE = '2018/8/1'` instead of `date = '2018/8/1'`. Do remove `GROUP BY`, `ORDER BY`, and `LIMIT` clauses instead of keeping them, as the conditional count comparison replaces the ranking logic. The amended query now correctly compares flight counts between the two specific airline codes and returns the appropriate result based on which has more flights on the given date.",
            "Do add the `Airports` table with an `INNER JOIN` on `T1.Code = T2.ORIGIN` instead of omitting it entirely. Do change the join with `Air Carriers` to use `INNER JOIN` instead of `JOIN` while keeping the same `ON T2.OP_CARRIER_AIRLINE_ID = T3.Code` predicate. Do replace the two separate `SUM` aggregates with a single `CASE` expression that compares `COUNT` of conditional cases for different carrier descriptions instead of summing individual flight counts. Do use `COUNT` with `CASE WHEN T3.Description = 'American Airlines Inc.: AA' THEN 1 ELSE NULL END` instead of `SUM(CASE WHEN T3.Description = 'American Airlines Inc.' THEN 1 ELSE 0 END)` to properly count non-null occurrences. Do change the description values to include carrier codes like `'American Airlines Inc.: AA'` and `'Endeavor Air Inc.: 9E'` instead of just the airline names. Do remove the individual column aliases `American_Flights` and `Endeavor_Flights` and instead use a single `RESULT` alias for the comparison outcome. Do keep the same `WHERE T2.FL_DATE = '2018/8/1'` filter unchanged. The amended query now correctly compares flight counts between specific carriers with proper codes and returns the carrier with more flights on the given date.",
            "Do use the full carrier description 'American Airlines Inc.: AA' in the THEN clause instead of the truncated 'American Airlines Inc.', and do use 'Endeavor Air Inc.: 9E' in the ELSE clause instead of 'Endeavor Air Inc.' to maintain consistency with the comparison logic. Do add explicit table aliases with AS syntax for T1 and T2 instead of omitting them, and do use backticks for the \"Air Carriers\" table name instead of quotes to ensure proper identifier handling. The amended query now correctly compares and returns the full carrier descriptions as specified in the RIGHT_SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT airline, COUNT(*) as flight_count \nFROM flights \nWHERE date = '2018/8/1' \nAND airline IN ('American Airlines Inc.', 'Endeavor Air Inc.') \nGROUP BY airline \nORDER BY flight_count DESC \nLIMIT 1;",
            "SELECT \n    SUM(CASE WHEN T3.Description = 'American Airlines Inc.' THEN 1 ELSE 0 END) AS American_Flights,\n    SUM(CASE WHEN T3.Description = 'Endeavor Air Inc.' THEN 1 ELSE 0 END) AS Endeavor_Flights\nFROM \n    Airlines T2\nJOIN \n    \"Air Carriers\" T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code\nWHERE \n    T2.FL_DATE = '2018/8/1';",
            "SELECT \n    CASE \n        WHEN COUNT(CASE WHEN T3.Description = 'American Airlines Inc.: AA' THEN 1 ELSE NULL END) > \n             COUNT(CASE WHEN T3.Description = 'Endeavor Air Inc.: 9E' THEN 1 ELSE NULL END) \n        THEN 'American Airlines Inc.'\n        ELSE 'Endeavor Air Inc.'\n    END AS RESULT\nFROM Airlines T2\nINNER JOIN Airports T1 ON T1.Code = T2.ORIGIN\nINNER JOIN \"Air Carriers\" T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code\nWHERE T2.FL_DATE = '2018/8/1'",
            "SELECT \n    CASE \n        WHEN COUNT(CASE WHEN T3.Description = 'American Airlines Inc.: AA' THEN 1 ELSE NULL END) > \n             COUNT(CASE WHEN T3.Description = 'Endeavor Air Inc.: 9E' THEN 1 ELSE NULL END)\n        THEN 'American Airlines Inc.: AA'\n        ELSE 'Endeavor Air Inc.: 9E'\n    END AS RESULT\nFROM Airports AS T1\nINNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN\nINNER JOIN `Air Carriers` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code\nWHERE T2.FL_DATE = '2018/8/1'"
        ],
        "rule_sql": []
    },
    "6251": {
        "db_id": "coinmarketcap",
        "question": "List the price for Zetacoin on 13/11/1 and the next 7 consecutive days. What is the average price for these 7 days?",
        "ground_truth": "SELECT T2.price FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Zetacoin' AND T2.date BETWEEN '2013-11-01' AND '2013-11-07' UNION ALL SELECT AVG(T2.PRICE) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Zetacoin' AND T2.date BETWEEN '2013-11-01' AND '2013-11-07'",
        "amends": [
            "Do select `T2.price` and a separate `AVG(T2.PRICE)` instead of selecting `date`, `price`, and a window function average. Do use `coins AS T1` and `historical AS T2` tables instead of `cryptocurrency_prices`. Do use `INNER JOIN` on `T1.id = T2.coin_id` instead of no join. Do filter with `T1.name = 'Zetacoin'` instead of `cryptocurrency = 'Zetacoin'`. Do use `T2.date BETWEEN '2013-11-01' AND '2013-11-07'` instead of `date = '2013-11-01'`. Do remove the window function and instead use `UNION ALL` to combine individual prices with their average. Do remove `ORDER BY date` instead of keeping it. The amended query now correctly retrieves both individual daily prices and their average for the specified date range."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    date,\n    price,\n    AVG(price) OVER (ORDER BY date ROWS BETWEEN CURRENT ROW AND 6 FOLLOWING) as avg_price\nFROM cryptocurrency_prices \nWHERE cryptocurrency = 'Zetacoin' \n    AND date = '2013-11-01'\nORDER BY date;",
            "SELECT T2.price FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Zetacoin' AND T2.date BETWEEN '2013-11-01' AND '2013-11-07'\nUNION ALL\nSELECT AVG(T2.price) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Zetacoin' AND T2.date BETWEEN '2013-11-01' AND '2013-11-07'"
        ],
        "rule_sql": []
    },
    "5521": {
        "db_id": "menu",
        "question": "List down the name of dishes that were positioned on the left upper corner.",
        "ground_truth": "SELECT T1.name FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T2.xpos < 0.25 AND T2.ypos < 0.25",
        "amends": [
            "Do reference the `Dish` table as `T1` and join with `MenuItem` as `T2` on `T1.id = T2.dish_id` instead of querying only the `dishes` table. Do filter on `T2.xpos < 0.25 AND T2.ypos < 0.25` instead of using the string condition `position = 'left upper corner'`. Do qualify the column reference as `T1.name` instead of just `name`. The amended query now correctly identifies dishes in the left upper quadrant through coordinate-based filtering instead of relying on a potentially ambiguous string value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM dishes WHERE position = 'left upper corner';",
            "SELECT T1.name FROM Dish AS T1 JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T2.xpos < 0.25 AND T2.ypos < 0.25;"
        ],
        "rule_sql": []
    },
    "2167": {
        "db_id": "world_development_indicators",
        "question": "Which low income country has a series code of DT.DOD.DECT.CD? Name the country code of it.",
        "ground_truth": "SELECT T1.CountryCode FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.IncomeGroup = 'Low income' AND T2.Seriescode = 'DT.DOD.DECT.CD'",
        "amends": [
            "Do select `CountryCode` from table `Country` instead of `country_code` from table `countries`. Do join with `CountryNotes` using `INNER JOIN` on `CountryCode=Countrycode` instead of querying a single table. Do filter on `IncomeGroup='Low income'` instead of `income_level='Low income'`. Do filter on `Seriescode='DT.DOD.DECT.CD'` from the joined `CountryNotes` table instead of `series_code='DT.DOD.DECT.CD'` from the original table. The amended query now correctly joins the necessary tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE series_code = 'DT.DOD.DECT.CD' AND income_level = 'Low income';",
            "SELECT c.CountryCode \nFROM Country c\nINNER JOIN CountryNotes cn ON c.CountryCode = cn.Countrycode\nWHERE c.IncomeGroup = 'Low income'\nAND cn.Seriescode = 'DT.DOD.DECT.CD'"
        ],
        "rule_sql": []
    },
    "7908": {
        "db_id": "world",
        "question": "What is the local name of the country where \"The Valley\" city belongs?",
        "ground_truth": "SELECT T2.LocalName FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.Name = 'The Valley'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do reference `T2.LocalName` instead of `country.local_name` in the SELECT list. Do use `INNER JOIN` explicitly instead of just `JOIN`. Do join on `T1.CountryCode = T2.Code` instead of `country.country_id = city.country_id`. Do filter on `T1.Name = 'The Valley'` instead of `city.name = 'The Valley'`. The amended query now correctly matches the intended logic by using proper column references and join conditions between the City and Country tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country.local_name FROM country JOIN city ON country.country_id = city.country_id WHERE city.name = 'The Valley';",
            "SELECT T2.LocalName FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.Name = 'The Valley'"
        ],
        "rule_sql": []
    },
    "1101": {
        "db_id": "talkingdata",
        "question": "How many female users belong to the age group of 27 to 28?",
        "ground_truth": "SELECT COUNT(device_id) FROM gender_age WHERE `group` = 'F27-28' AND gender = 'F'",
        "amends": [
            "Do reference table `gender_age` instead of `users` and count `device_id` instead of all rows with `COUNT(*)`. Do filter on column `group` with value 'F27-28' instead of filtering on `age BETWEEN 27 AND 28`, and do filter on `gender = 'F'` instead of `gender = 'male'`. The amended query now correctly counts female users in the 27-28 age group from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE gender = 'male' AND age BETWEEN 27 AND 28;",
            "SELECT COUNT(device_id) FROM gender_age WHERE gender = 'F' AND \"group\" = 'F27-28'"
        ],
        "rule_sql": []
    },
    "6332": {
        "db_id": "retail_world",
        "question": "Give the full name of the youngest employee.",
        "ground_truth": "SELECT FirstName, LastName FROM Employees WHERE BirthDate = ( SELECT MAX(BirthDate) FROM Employees )",
        "amends": [
            "Do use column names `FirstName` and `LastName` instead of `first_name` and `last_name`. Do add a WHERE clause with a subquery filter `BirthDate = (SELECT MAX(BirthDate) FROM Employees)` instead of ordering by `birth_date ASC` with LIMIT 1. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly finds the employee(s) with the most recent birth date by using a subquery to identify the maximum birth date rather than relying on sorting and limiting, which ensures all employees with that maximum date are returned."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY birth_date ASC LIMIT 1;",
            "SELECT FirstName, LastName FROM Employees WHERE BirthDate = (SELECT MAX(BirthDate) FROM Employees)"
        ],
        "rule_sql": []
    },
    "5320": {
        "db_id": "beer_factory",
        "question": "How many brands of bottle root beer were purchased between 4/3/2015 and 10/26/2015?",
        "ground_truth": "SELECT COUNT(BrandID) FROM rootbeer WHERE ContainerType = 'Bottle' AND PurchaseDate BETWEEN '2015-04-03' AND '2015-10-26'",
        "amends": [
            "Do count `BrandID` instead of `*` to count non-null brand identifiers rather than all rows. Do query the `rootbeer` table instead of `purchases` to access the correct data source. Do filter for `ContainerType = 'Bottle'` instead of `product_type = 'bottle root beer'` to use the proper column name and value format. Do adjust the date range to `BETWEEN '2015-04-03' AND '2015-10-26'` instead of `BETWEEN '2015-03-04' AND '2015-10-26'` to correct the start date. The amended query now correctly counts bottled root beer purchases within the specified date range using the appropriate table structure and column names.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the right query counts all BrandID values including duplicates rather than counting only distinct BrandID values. The amended query now matches RIGHT_SQL's behavior by returning the total count of BrandID occurrences rather than the count of distinct BrandID values."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM purchases WHERE product_type = 'bottle root beer' AND purchase_date BETWEEN '2015-03-04' AND '2015-10-26';",
            "SELECT COUNT(DISTINCT BrandID) \nFROM rootbeer \nWHERE ContainerType = 'Bottle' \nAND PurchaseDate BETWEEN '2015-04-03' AND '2015-10-26'",
            "SELECT COUNT(BrandID) \nFROM rootbeer \nWHERE ContainerType = 'Bottle' \nAND PurchaseDate BETWEEN '2015-04-03' AND '2015-10-26'"
        ],
        "rule_sql": []
    },
    "1751": {
        "db_id": "restaurant",
        "question": "List down the cities with unknown country.",
        "ground_truth": "SELECT city FROM geographic WHERE county = 'unknown'",
        "amends": [
            "Do reference table `geographic` instead of `cities` in the FROM clause. Do use filter `county = 'unknown'` instead of `country = NULL` in the WHERE clause, replacing the incorrect NULL comparison with a proper string literal check. The amended query now correctly retrieves cities from the geographic table where the county value is 'unknown', matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM cities WHERE country = NULL",
            "SELECT city FROM geographic WHERE county = 'unknown';"
        ],
        "rule_sql": []
    },
    "5599": {
        "db_id": "shipping",
        "question": "Provide the ship date of the first shipment to customers in South Carolina.",
        "ground_truth": "SELECT MIN(T1.ship_date) FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE T2.state = 'SC'",
        "amends": [
            "Do use `INNER JOIN` on `customer` table with join condition `T1.cust_id = T2.cust_id` instead of querying only the `shipments` table. Do filter on `T2.state = 'SC'` instead of `customer_state = 'South Carolina'` to use the correct state abbreviation. Do reference `T1.ship_date` with table alias instead of just `ship_date` for explicit table qualification. The amended query now correctly joins the shipment and customer tables to find the minimum ship date for South Carolina customers using the proper state code."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(ship_date) FROM shipments WHERE customer_state = 'South Carolina';",
            "SELECT MIN(T1.ship_date) FROM shipment T1 INNER JOIN customer T2 ON T1.cust_id = T2.cust_id WHERE T2.state = 'SC'"
        ],
        "rule_sql": []
    },
    "643": {
        "db_id": "codebase_comments",
        "question": "What is the solution's path of method \"HtmlSharp.HtmlParser.Feed\"?",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'HtmlSharp.HtmlParser.Feed'",
        "amends": [
            "Do select `T1.Path` instead of `method_name`. Do use `FROM Solution AS T1 INNER JOIN Method AS T2` instead of `FROM methods`. Do add join condition `ON T1.Id = T2.SolutionId` instead of omitting it. Do change filter to `WHERE T2.Name = 'HtmlSharp.HtmlParser.Feed'` instead of `WHERE method_name = 'HtmlSharp.HtmlParser.Feed'`. The amended query now correctly joins the Solution and Method tables to find the path associated with the specified method name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT method_name FROM methods WHERE method_name = 'HtmlSharp.HtmlParser.Feed';",
            "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'HtmlSharp.HtmlParser.Feed'"
        ],
        "rule_sql": []
    },
    "360": {
        "db_id": "retail_complains",
        "question": "Write down the date received of complaints sent via Fax.",
        "ground_truth": "SELECT T1.`Date received` FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.`Submitted via` = 'Fax'",
        "amends": [
            "Do select `T1.Date received` from `callcenterlogs AS T1` instead of `date_received` from `complaints`. Do add `INNER JOIN events AS T2` on `T1.Complaint ID = T2.Complaint ID` instead of omitting the join entirely. Do change the filter to `T2.Submitted via = 'Fax'` instead of `sent_via = 'Email'`. The amended query now correctly retrieves fax-submitted complaint dates from the joined call center and events tables instead of email complaints from a single table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date_received FROM complaints WHERE sent_via = 'Email';",
            "SELECT T1.\"Date received\"\nFROM callcenterlogs AS T1\nINNER JOIN events AS T2 ON T1.\"Complaint ID\" = T2.\"Complaint ID\"\nWHERE T2.\"Submitted via\" = 'Fax'"
        ],
        "rule_sql": []
    },
    "6184": {
        "db_id": "food_inspection_2",
        "question": "List the types and results of the inspections done on Riverwalk caf\u00e9.",
        "ground_truth": "SELECT T2.inspection_type, T2.results FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.facility_type = 'RIVERWALK CAFE'",
        "amends": [
            "Do select `T2.inspection_type` and `T2.results` instead of `inspection_type` and `result`. Do join `establishment AS T1` with `inspection AS T2` using `INNER JOIN` on `T1.license_no = T2.license_no` instead of querying only the `inspections` table. Do filter on `T1.facility_type = 'RIVERWALK CAFE'` instead of `restaurant_name = 'Riverwalk caf\u00e9'`. The amended query now correctly joins establishment and inspection tables using license numbers and filters by facility type instead of restaurant name, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_type, result FROM inspections WHERE restaurant_name = 'Riverwalk caf\u00e9'",
            "SELECT T2.inspection_type, T2.results\nFROM establishment AS T1\nINNER JOIN inspection AS T2 ON T1.license_no = T2.license_no\nWHERE T1.facility_type = 'RIVERWALK CAFE';"
        ],
        "rule_sql": []
    },
    "5981": {
        "db_id": "books",
        "question": "Which publisher published Barry Eisler's book?",
        "ground_truth": "SELECT T4.publisher_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE T3.author_name = 'Barry Eisler'",
        "amends": [
            "Do join `book_author` and `author` tables to properly link authors to books instead of directly filtering on a non-existent `author` column in the `books` table. Do use `T3.author_name = 'Barry Eisler'` instead of `author = 'John Eisler'` to correctly filter by author name. Do add joins to `publisher` table via `T4.publisher_id = T1.publisher_id` instead of omitting the publisher relationship. Do select `T4.publisher_name` instead of just `publisher` to explicitly reference the publisher name from the joined table. The amended query now correctly retrieves publisher names for the specified author through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM books WHERE author = 'John Eisler';",
            "SELECT DISTINCT p.publisher_name\nFROM book b\nJOIN book_author ba ON b.book_id = ba.book_id\nJOIN author a ON ba.author_id = a.author_id\nJOIN publisher p ON b.publisher_id = p.publisher_id\nWHERE a.author_name = 'Barry Eisler';"
        ],
        "rule_sql": []
    },
    "8253": {
        "db_id": "mondial_geo",
        "question": "How many lakes in the Canary Islands cover an area of over 1000000?",
        "ground_truth": "SELECT COUNT(T2.Name) FROM located AS T1 INNER JOIN lake AS T2 ON T1.Lake = T2.Name WHERE T1.Province = 'Canary Islands' AND T2.Area > 1000000",
        "amends": [
            "Do select `COUNT(T2.Name)` from the `lake` table instead of `COUNT(*)` from a non-existent `lakes` table. Do join `located AS T1` with `lake AS T2` using `INNER JOIN` on `T1.Lake = T2.Name` instead of querying a single table. Do filter on `T1.Province = 'Canary Islands'` instead of `islands = 'Canary Islands'` and maintain `T2.Area > 1000000` instead of `area > 1000000`. The amended query correctly counts lakes in the Canary Islands province with area over 1,000,000 by properly joining the location and lake tables, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM lakes WHERE islands = 'Canary Islands' AND area > 1000000;",
            "SELECT COUNT(T2.Name) \nFROM located AS T1 \nINNER JOIN lake AS T2 ON T1.Lake = T2.Name \nWHERE T1.Province = 'Canary Islands' AND T2.Area > 1000000"
        ],
        "rule_sql": []
    },
    "4264": {
        "db_id": "simpson_episodes",
        "question": "What award did the character Homer simpson 20 achieve in 2009?",
        "ground_truth": "SELECT DISTINCT T1.award FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T1.year = 2009 AND T2.character = 'Homer Simpson';",
        "amends": [
            "Do use `DISTINCT T1.award` instead of `award_name` without distinct. Do join `Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id` instead of querying a single `awards` table. Do filter with `T1.year = 2009` instead of `year = 2009` and `T2.character = 'Homer Simpson'` instead of `character_name = 'Homer Simpson'`. Do remove the `achievement_id = 20` filter instead of keeping it. The amended query now correctly retrieves distinct awards by joining the proper tables and filtering on the appropriate columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT award_name FROM awards WHERE character_name = 'Homer Simpson' AND year = 2009 AND achievement_id = 20;",
            "SELECT DISTINCT T1.award\nFROM Award AS T1\nINNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id\nWHERE T1.year = 2009 AND T2.character = 'Homer Simpson'"
        ],
        "rule_sql": []
    },
    "8979": {
        "db_id": "human_resources",
        "question": "What is the maximum salary of position \"Trainer\"?",
        "ground_truth": "SELECT maxsalary FROM position WHERE positiontitle = 'Trainee'",
        "amends": [
            "Do select `maxsalary` from the `position` table instead of selecting `MIN(salary)` from the `employees` table. Do filter on `positiontitle = 'Trainee'` instead of filtering on `position = 'Trainer'`. The amended query now correctly retrieves the maximum salary for Trainee positions from the appropriate table rather than attempting to find minimum salaries for Trainer positions from an employee table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(salary) FROM employees WHERE position = 'Trainer';",
            "SELECT maxsalary FROM position WHERE positiontitle = 'Trainee';"
        ],
        "rule_sql": []
    },
    "264": {
        "db_id": "retail_complains",
        "question": "Which district did the review on 2018/9/11 come from? Give the name of the city.",
        "ground_truth": "SELECT T2.district_id, T2.city FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.Date = '2018-09-11'",
        "amends": [
            "Do select `T2.district_id, T2.city` instead of just `city`. Do use `reviews AS T1 INNER JOIN district AS T2` instead of `districts JOIN reviews` with reversed table order and explicit aliasing. Do specify the join condition as `T1.district_id = T2.district_id` instead of `districts.district_id = reviews.district_id` with proper table qualification. Do filter on `T1.Date = '2018-09-11'` instead of `review_date = '2018/9/11'` with corrected date format and proper table reference. The amended query now correctly retrieves district information from the proper table while filtering on review dates with the appropriate syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM districts JOIN reviews ON districts.district_id = reviews.district_id WHERE review_date = '2018/9/11';",
            "SELECT T2.district_id, T2.city\nFROM reviews AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.Date = '2018-09-11'"
        ],
        "rule_sql": []
    },
    "1012": {
        "db_id": "computer_student",
        "question": "List the professor ID who taught the course ID from 121 to 130 of basic undergraduate courses.",
        "ground_truth": "SELECT T2.p_id FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE T1.courseLevel = 'Level_300' AND T1.course_id > 121 AND T1.course_id < 130",
        "amends": [
            "Do select `T2.p_id` instead of `professor_id` from a different table. Do use `INNER JOIN` on `taughtBy AS T2` with predicate `T1.course_id = T2.course_id` instead of querying only the `courses` table. Do filter on `T1.courseLevel = 'Level_300'` instead of `course_level = 'undergraduate'` with different level semantics. Do use range conditions `T1.course_id > 121 AND T1.course_id < 130` instead of `BETWEEN 121 AND 130` to exclude the boundary values. The amended query now correctly joins the course and taughtBy tables to retrieve professor IDs for specific course levels within an exclusive ID range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professor_id FROM courses WHERE course_id BETWEEN 121 AND 130 AND course_level = 'undergraduate'",
            "SELECT T2.p_id\nFROM course AS T1\nINNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id\nWHERE T1.courseLevel = 'Level_300'\nAND T1.course_id > 121\nAND T1.course_id < 130"
        ],
        "rule_sql": []
    },
    "3038": {
        "db_id": "shakespeare",
        "question": "How many chapters have the name Gratiano as a character for \"friend to Antonio and Bassiano\"?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.chapter_id) FROM characters AS T1 INNER JOIN paragraphs AS T2 ON T1.id = T2.character_id WHERE T1.CharName = 'Gratiano' AND T1.Description = 'friend to Antonio and Bassiano'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.chapter_id)` instead of `COUNT(*)` to count unique chapters. Do join `characters AS T1` with `paragraphs AS T2` on `T1.id = T2.character_id` instead of querying `chapters` table directly. Do filter on `T1.CharName` and `T1.Description` instead of filtering on non-existent columns in the chapters table. Do add the required table joins instead of omitting them. The amended query now correctly counts distinct chapters containing paragraphs spoken by the specified character with matching description, fixing the original query's incorrect table structure and filtering approach."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM chapters WHERE character_name = 'Gratiano' AND description = 'friend to Antonio and Bassiano'",
            "SELECT COUNT(DISTINCT T2.chapter_id) \nFROM characters AS T1 \nJOIN paragraphs AS T2 ON T1.id = T2.character_id \nWHERE T1.CharName = 'Gratiano' \nAND T1.Description = 'friend to Antonio and Bassiano'"
        ],
        "rule_sql": []
    },
    "4137": {
        "db_id": "public_review_platform",
        "question": "Among the businesses with a category of Food, what is the percentage of the business with greater than 3 stars?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.stars > 3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.stars) FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE T3.category_name = 'Food'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `Business` with `Business_Categories` on `business_id` and then with `Categories` on `category_id` instead of querying a single table. Do filter on `T3.category_name = 'Food'` instead of `category = 'Food'`. Do calculate percentage using `SUM(CASE WHEN T1.stars > 3 THEN 1 ELSE 0 END) * 100 / COUNT(T1.stars)` with explicit `CAST` to `REAL` instead of `COUNT(*) * 100.0 / subquery`. Do remove the subquery in favor of proper join relationships. The amended query now correctly handles the business-category relationships and calculates the percentage of Food businesses with more than 3 stars using proper table joins and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM businesses WHERE category = 'Food')) AS percentage\nFROM businesses \nWHERE category = 'Food' AND stars > 3;",
            "SELECT \n    CAST(SUM(CASE WHEN T1.stars > 3 THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.stars) AS REAL) AS percentage\nFROM \n    Business T1\nJOIN \n    Business_Categories T2 ON T1.business_id = T2.business_id\nJOIN \n    Categories T3 ON T2.category_id = T3.category_id\nWHERE \n    T3.category_name = 'Food'"
        ],
        "rule_sql": []
    },
    "8281": {
        "db_id": "mondial_geo",
        "question": "What is the area of Egypt as a percentage of Asia?",
        "ground_truth": "SELECT T1.Area * 100 / T3.Area FROM country AS T1 INNER JOIN encompasses AS T2 ON T1.Code = T2.Country INNER JOIN continent AS T3 ON T3.Name = T2.Continent WHERE T3.Name = 'Asia' AND T1.Name = 'Egypt'",
        "amends": [
            "Do use explicit `INNER JOIN` syntax with proper table aliases instead of implicit comma joins. Do join through the `encompasses` bridge table to connect countries to continents instead of directly joining two `countries` table instances. Do reference `T1.Area` and `T3.Area` from properly joined tables instead of `Egypt.area` and `Asia.area` from incorrectly joined table instances. Do calculate the percentage as `T1.Area * 100 / T3.Area` instead of `(Egypt.area / Asia.area) * 100` to avoid division by zero and ensure correct mathematical order. Do filter on `T3.Name = 'Asia'` and `T1.Name = 'Egypt'` through proper table relationships instead of filtering two separate instances of the same table. The amended query now correctly calculates Egypt's area as a percentage of Asia's total area using proper database relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (Egypt.area / Asia.area) * 100 AS percentage FROM countries Egypt, countries Asia WHERE Egypt.name = 'Egypt' AND Asia.name = 'Asia';",
            "SELECT (T1.Area * 100 / T3.Area) AS percentage\nFROM country T1\nINNER JOIN encompasses T2 ON T1.Code = T2.Country\nINNER JOIN continent T3 ON T2.Continent = T3.Name\nWHERE T1.Name = 'Egypt' AND T3.Name = 'Asia'"
        ],
        "rule_sql": []
    },
    "4208": {
        "db_id": "simpson_episodes",
        "question": "What is the birth place of the cast or crew member who won the Best Voice-Over Performance in Online Film & Television Association in 2009?",
        "ground_truth": "SELECT T1.birth_place FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.award = 'Best Voice-Over Performance' AND T2.organization = 'Online Film & Television Association' AND T2.year = 2009;",
        "amends": [
            "Do join `Person AS T1` and `Award AS T2` with `INNER JOIN` on `T1.name = T2.person` instead of querying only `cast_crew` table. Do select `T1.birth_place` from the joined tables instead of `birth_place` from a single table. Do filter on `T2.award`, `T2.organization`, and `T2.year` from the Award table instead of filtering directly on the cast_crew table columns. Do use table aliases `T1` and `T2` to qualify column references instead of unqualified column names. The amended query now correctly retrieves birth places by joining person and award data with proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_place FROM cast_crew WHERE award = 'Best Voice-Over Performance' AND year = 2009 AND organization = 'Online Film & Television Association';",
            "SELECT T1.birth_place\nFROM Person AS T1\nINNER JOIN Award AS T2 ON T1.name = T2.person\nWHERE T2.award = 'Best Voice-Over Performance'\nAND T2.organization = 'Online Film & Television Association'\nAND T2.year = 2009;"
        ],
        "rule_sql": []
    },
    "9089": {
        "db_id": "bike_share_1",
        "question": "List the names of the stations within Mountain View that were installed on 12/31/2013.",
        "ground_truth": "SELECT name FROM station WHERE installation_date = '12/31/2013' AND city = 'Mountain View'",
        "amends": [
            "Do reference table `station` instead of `stations` in the FROM clause. Do use date format `'12/31/2013'` instead of `'2013-12-31'` for the installation_date filter. Do maintain the same WHERE clause conditions but with the corrected date format and table reference, ensuring the query now correctly filters for stations in Mountain View installed on December 31, 2013. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM stations WHERE city = 'Mountain View' AND installation_date = '2013-12-31';",
            "SELECT name FROM station WHERE city = 'Mountain View' AND installation_date = '12/31/2013'"
        ],
        "rule_sql": []
    },
    "3102": {
        "db_id": "cars",
        "question": "What is the miles per square hour of the cheapest car produced by the USA?",
        "ground_truth": "SELECT T4.acceleration FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE T3.country = 'USA' ORDER BY T1.price ASC LIMIT 1",
        "amends": [
            "Do select `T4.acceleration` instead of `MIN(price) / (miles_per_gallon * 3600) AS miles_per_square_hour`. Do use multiple table joins including `price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID`, `INNER JOIN country AS T3 ON T3.origin = T2.country`, and `INNER JOIN data AS T4 ON T4.ID = T1.ID` instead of a single `FROM cars` table. Do filter with `T3.country = 'USA'` instead of `country = 'USA'`. Do order by `T1.price ASC` instead of `price ASC`. The amended query now correctly retrieves acceleration data through proper table relationships and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(price) / (miles_per_gallon * 3600) AS miles_per_square_hour \nFROM cars \nWHERE country = 'USA' \nORDER BY price ASC \nLIMIT 1;",
            "SELECT T4.acceleration \nFROM price AS T1 \nINNER JOIN production AS T2 ON T1.ID = T2.ID \nINNER JOIN country AS T3 ON T3.origin = T2.country \nINNER JOIN data AS T4 ON T4.ID = T1.ID \nWHERE T3.country = 'USA' \nORDER BY T1.price ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "4945": {
        "db_id": "olympics",
        "question": "What is the name of the event where competitors received the most gold medals?",
        "ground_truth": "SELECT T2.event_name FROM competitor_event AS T1 INNER JOIN event AS T2 ON T1.event_id = T2.id INNER JOIN medal AS T3 ON T1.medal_id = T3.id WHERE T3.medal_name = 'Gold' GROUP BY T2.id ORDER BY COUNT(T1.event_id) DESC LIMIT 1",
        "amends": [
            "Do select `T2.event_name` from the `event` table instead of `event_name` from the `events` table. Do add joins to `competitor_event` as `T1` and `medal` as `T3` instead of querying a single table. Do use `INNER JOIN` on `T1.event_id = T2.id` and `T1.medal_id = T3.id` instead of no joins. Do add a WHERE filter for `T3.medal_name = 'Gold'` instead of no filtering. Do add GROUP BY on `T2.id` and aggregate with `COUNT(T1.event_id)` instead of no grouping. Do order by the count of events `DESC` instead of by `gold_medals DESC`. The amended query now correctly identifies the event with the most gold medals by joining related tables and counting actual medal assignments."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_name FROM events ORDER BY gold_medals DESC LIMIT 1;",
            "SELECT T2.event_name\nFROM competitor_event T1\nINNER JOIN event T2 ON T1.event_id = T2.id\nINNER JOIN medal T3 ON T1.medal_id = T3.id\nWHERE T3.medal_name = 'Gold'\nGROUP BY T2.id\nORDER BY COUNT(T1.event_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1253": {
        "db_id": "law_episode",
        "question": "How many people had filled a role in the episode titled \"Cherished\", but did not show up in the on-screen credits?",
        "ground_truth": "SELECT COUNT(T1.episode_id) FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Cherished' AND T2.credited = 'false'",
        "amends": [
            "Do select `COUNT(T1.episode_id)` instead of `COUNT(*)` to count specific episode occurrences rather than all rows. Do use `INNER JOIN` between `Episode` and `Credit` tables instead of joining `people`, `roles`, and `episodes` with complex filtering. Do filter on `T1.title = 'Cherished'` instead of the same condition but with different table aliases. Do add `T2.credited = 'false'` condition instead of the subquery checking for person exclusions, which simplifies the logic by directly filtering uncredited appearances. Do remove the unnecessary subquery and multiple table joins that were attempting to achieve the same result through more complex means. The amended query now correctly counts episodes titled 'Cherished' where credits are marked as false, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM people p\nJOIN roles r ON p.person_id = r.person_id\nJOIN episodes e ON r.episode_id = e.episode_id\nWHERE e.title = 'Cherished'\nAND p.person_id NOT IN (SELECT person_id FROM credits WHERE episode_id = e.episode_id)",
            "SELECT COUNT(T1.episode_id) \nFROM Episode T1\nINNER JOIN Credit T2 ON T1.episode_id = T2.episode_id\nWHERE T1.title = 'Cherished' AND T2.credited = 'false'"
        ],
        "rule_sql": []
    },
    "3186": {
        "db_id": "donor",
        "question": "List the title of all projects located in Chicago along with the ID of the donor.",
        "ground_truth": "SELECT T1.title, T3.donor_acctid FROM essays AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid INNER JOIN donations AS T3 ON T2.projectid = T3.projectid WHERE T2.school_city LIKE 'Chicago'",
        "amends": [
            "Do select `T1.title` and `T3.donor_acctid` instead of `title` and `donor_id`. Do use `essays AS T1` joined with `projects AS T2` on `T1.projectid = T2.projectid` instead of querying `projects` alone. Do add `donations AS T3` joined on `T2.projectid = T3.projectid` instead of omitting this table. Do use `WHERE T2.school_city LIKE 'Chicago'` instead of `WHERE location = 'Chicago'`. The amended query now correctly joins the necessary tables to retrieve essay titles with their associated donor account IDs for Chicago-based projects."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, donor_id FROM projects WHERE location = 'Chicago';",
            "SELECT T1.title, T3.donor_acctid \nFROM essays AS T1 \nJOIN projects AS T2 ON T1.projectid = T2.projectid \nJOIN donations AS T3 ON T2.projectid = T3.projectid \nWHERE T2.school_city LIKE 'Chicago'"
        ],
        "rule_sql": []
    },
    "3678": {
        "db_id": "authors",
        "question": "State the year and title of papers written by Barrasa.",
        "ground_truth": "SELECT T1.Year, T1.Title FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T2.Name = 'Barrasa'",
        "amends": [
            "Do join `Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` instead of querying only the `papers` table. Do filter on `T2.Name = 'Barrasa'` instead of `author = 'Barrasa'` since the author information is stored in the PaperAuthor table. Do select `T1.Year` and `T1.Title` instead of `year` and `title` with proper table qualification. The amended query now correctly retrieves papers by joining with the author table and filtering on the author name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, title FROM papers WHERE author = 'Barrasa'",
            "SELECT T1.Year, T1.Title FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T2.Name = 'Barrasa'"
        ],
        "rule_sql": []
    },
    "5684": {
        "db_id": "language_corpus",
        "question": "Name the longest Catalan language Wikipedia page title and state the number of different words in this page.",
        "ground_truth": "SELECT title, words FROM pages WHERE title = ( SELECT MAX(LENGTH(title)) FROM pages )",
        "amends": [
            "Do select `title` and `words` instead of `title` and `COUNT(DISTINCT word)` with alias `word_count`. Do use `FROM pages` instead of `FROM wikipedia`. Do remove the `WHERE language = 'Catalan'` filter instead of keeping it. Do use a subquery `SELECT MAX(LENGTH(title)) FROM pages` in the WHERE clause instead of no subquery. Do change the ORDER BY from `LENGTH(title) DESC` to using the subquery result for comparison. Do remove the `LIMIT 1` clause instead of keeping it since the subquery ensures single result matching. The amended query now correctly retrieves the title and words from the pages table where the title has the maximum length, matching the RIGHT_SQL's behavior.",
            "Do use `title =` instead of `LENGTH(title) =` in the WHERE clause to compare the actual title value rather than its length. Do place the subquery `(SELECT MAX(LENGTH(title)) FROM pages)` directly in the equality comparison instead of comparing length values. The amended query now correctly filters for titles that match the maximum length title value rather than titles whose length equals the maximum title length, ensuring it returns the actual title with maximum length instead of potentially multiple titles with the same length as the maximum.",
            "Do use `title =` instead of `LENGTH(title) =` in the WHERE clause comparison. Do reference the column `title` directly instead of applying the LENGTH function to it in the main query's filter condition. Do keep the subquery `(SELECT MAX(LENGTH(title)) FROM pages)` unchanged as it correctly calculates the maximum title length. The amended query now correctly filters for rows where the title value equals the maximum title length value returned by the subquery, matching the RIGHT_SQL's behavior.",
            "Do use `title =` instead of `LENGTH(title) =` in the WHERE clause filter. Do reference the subquery result directly in the equality comparison instead of applying LENGTH function to the title column. Do maintain the same subquery structure that calculates `MAX(LENGTH(title)) FROM pages` but use it for direct comparison with the title field rather than comparing lengths. The amended query now correctly identifies rows where the title matches the maximum length value instead of incorrectly comparing the length of title against the maximum length value."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, COUNT(DISTINCT word) AS word_count FROM wikipedia WHERE language = 'Catalan' ORDER BY LENGTH(title) DESC LIMIT 1;",
            "SELECT title, words FROM pages WHERE LENGTH(title) = (SELECT MAX(LENGTH(title)) FROM pages);",
            "SELECT title, words FROM pages WHERE LENGTH(title) = (SELECT MAX(LENGTH(title)) FROM pages);",
            "SELECT title, words FROM pages WHERE LENGTH(title) = (SELECT MAX(LENGTH(title)) FROM pages);",
            "SELECT title, words FROM pages WHERE title = (SELECT MAX(LENGTH(title)) FROM pages);"
        ],
        "rule_sql": []
    },
    "745": {
        "db_id": "movie",
        "question": "What is the MPAA rating for the movie with the character named \"Peter Quill\" in it?",
        "ground_truth": "SELECT T1.`MPAA Rating` FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T2.`Character Name` = 'Peter Quill'",
        "amends": [
            "Do join `movie AS T1` with `characters AS T2` on `T1.MovieID = T2.MovieID` instead of querying only the `movies` table. Do filter on `T2.Character Name = 'Peter Quill'` instead of filtering on `character_name` from the wrong table. Do select `T1.MPAA Rating` instead of selecting `mpaa_rating` without proper table qualification. The amended query now correctly retrieves MPAA ratings by joining the movie and characters tables and filtering on the character name, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT mpaa_rating FROM movies WHERE character_name = 'Peter Quill';",
            "SELECT T1.\"MPAA Rating\" FROM movie AS T1 JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T2.\"Character Name\" = 'Peter Quill'"
        ],
        "rule_sql": []
    },
    "4487": {
        "db_id": "student_loan",
        "question": "Among students who have been absent for nine months, how many of them are disabled?",
        "ground_truth": "SELECT COUNT(T1.name) FROM disabled AS T1 LEFT JOIN longest_absense_from_school AS T2 ON T2.name = T1.name WHERE T2.month = 9",
        "amends": [
            "Do select `COUNT(T1.name)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do use `FROM disabled AS T1 LEFT JOIN longest_absense_from_school AS T2` instead of `FROM students` to join two tables with a left join instead of querying a single table. Do apply the join condition `ON T2.name = T1.name` instead of no join condition to properly relate the tables. Do filter with `WHERE T2.month = 9` instead of `WHERE absences = 9 AND disabled = 'yes'` to filter on the joined table's month column rather than direct column filters. Do remove the `disabled = 'yes'` filter instead of keeping it since the join to the disabled table already ensures this condition. The amended query now correctly counts disabled students with absences in month 9 by joining the appropriate tables and filtering on the correct criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE absences = 9 AND disabled = 'yes';",
            "SELECT COUNT(T1.name) FROM disabled AS T1 LEFT JOIN longest_absense_from_school AS T2 ON T2.name = T1.name WHERE T2.month = 9"
        ],
        "rule_sql": []
    },
    "875": {
        "db_id": "cs_semester",
        "question": "How many students took the hardest course?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM registration AS T1 INNER JOIN course AS T2 ON T1.course_id = T2.course_id WHERE T2.diff = 5",
        "amends": [
            "Do reference the `registration` table instead of `students`, and join with `course` on `T1.course_id = T2.course_id` instead of using a subquery. Do filter on `T2.diff = 5` instead of finding the maximum difficulty course. Do count `T1.student_id` instead of using `COUNT(*)` to ensure accurate student counts from the registration table. The amended query now correctly counts students registered for courses with difficulty level 5 rather than attempting to find the most difficult course, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE course_id = (SELECT course_id FROM courses ORDER BY difficulty DESC LIMIT 1);",
            "SELECT COUNT(DISTINCT T1.student_id) \nFROM registration T1 \nJOIN course T2 ON T1.course_id = T2.course_id \nWHERE T2.diff = 5"
        ],
        "rule_sql": []
    },
    "5697": {
        "db_id": "language_corpus",
        "question": "What is the word id of the catalan language that was repeated no more than 10 times in the said language?",
        "ground_truth": "SELECT wid FROM langs_words WHERE occurrences <= 10",
        "amends": [
            "Do select `wid` instead of `word_id` and do use `occurrences` instead of `repetition_count` in the filter condition. Do change the table reference to `langs_words` instead of `words` and remove the `language = 'catalan'` filter instead of keeping it. Do maintain the `LIMIT 1` clause to preserve the single row result. The amended query now correctly retrieves word IDs with low occurrence counts from the appropriate table structure.",
            "Do remove the `LIMIT 1` clause instead of keeping it, as the query should return all matching rows rather than just the first one. The amended query now matches RIGHT_SQL's behavior by returning all word IDs where occurrences are less than or equal to 10."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id FROM words WHERE language = 'catalan' AND repetition_count <= 10 LIMIT 1;",
            "SELECT wid FROM langs_words WHERE occurrences <= 10 LIMIT 1;",
            "SELECT wid FROM langs_words WHERE occurrences <= 10"
        ],
        "rule_sql": []
    },
    "1427": {
        "db_id": "synthea",
        "question": "Provide medications received by patients with an allergy to mould on 6th June 2016.",
        "ground_truth": "SELECT T2.DESCRIPTION FROM allergies AS T1 INNER JOIN medications AS T2 ON T1.PATIENT = T2.PATIENT WHERE T1.START = '6/6/16' AND T1.DESCRIPTION = 'Allergy to mould'",
        "amends": [
            "Do select `T2.DESCRIPTION` instead of `m.medication_name`. Do use `allergies AS T1` and `medications AS T2` as table sources instead of `medications m`, `patients p`, and `allergies a`. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.PATIENT = T2.PATIENT` instead of joining through a patients table with `m.patient_id = p.patient_id` and `p.patient_id = a.patient_id`. Do filter with `T1.START = '6/6/16'` instead of `m.medication_date = '2016-06-06'`. Do filter with `T1.DESCRIPTION = 'Allergy to mould'` instead of `a.allergy_name = 'mould'`. The amended query now correctly matches the RIGHT_SQL's behavior by directly joining allergies to medications on patient ID and using the appropriate date format and allergy description filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.medication_name \nFROM medications m\nJOIN patients p ON m.patient_id = p.patient_id\nJOIN allergies a ON p.patient_id = a.patient_id\nWHERE a.allergy_name = 'mould'\nAND m.medication_date = '2016-06-06';",
            "SELECT T2.DESCRIPTION \nFROM allergies AS T1 \nINNER JOIN medications AS T2 ON T1.PATIENT = T2.PATIENT \nWHERE T1.START = '6/6/16' \nAND T1.DESCRIPTION = 'Allergy to mould'"
        ],
        "rule_sql": []
    },
    "8175": {
        "db_id": "sales_in_weather",
        "question": "What percentage was the total unit sales of store no.10 to the total sales of its weather station on 2014/10/31?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.store_nbr = 10 THEN units * 1 ELSE 0 END) AS REAL) * 100 / SUM(units) FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE T1.`date` = '2014-10-31'",
        "amends": [
            "Do use `CAST` with `REAL` for the percentage calculation instead of direct division. Do calculate the percentage using `SUM(CASE WHEN T2.store_nbr = 10 THEN units * 1 ELSE 0 END) * 100 / SUM(units)` instead of dividing by a subquery total. Do reference tables `sales_in_weather AS T1` and `relation AS T2` instead of `sales`, `stores`, and `weather`. Do use `INNER JOIN` on `T1.store_nbr = T2.store_nbr` instead of joining through multiple tables with `sales.store = stores.store` and `stores.station = weather.station`. Do filter with `T1.date = '2014-10-31'` in the WHERE clause instead of applying the date filter to both the main query and subquery. Do remove the store filter from the WHERE clause and instead handle it conditionally in the CASE statement within the aggregate function. The amended query now correctly calculates the percentage of units for store 10 relative to the total units on the specified date."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(sales.units) / (SELECT SUM(sales.units) FROM sales \n                        JOIN stores ON sales.store = stores.store \n                        JOIN weather ON stores.station = weather.station \n                        WHERE weather.date = '2014-10-31')) * 100 AS percentage\nFROM sales\nJOIN stores ON sales.store = stores.store\nJOIN weather ON stores.station = weather.station\nWHERE stores.store = 10 \nAND weather.date = '2014-10-31';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.store_nbr = 10 THEN units ELSE 0 END) * 100.0 / SUM(units) AS REAL) AS percentage\nFROM \n    sales_in_weather AS T1\nINNER JOIN \n    relation AS T2 ON T1.store_nbr = T2.store_nbr\nWHERE \n    T1.date = '2014-10-31'"
        ],
        "rule_sql": []
    },
    "3462": {
        "db_id": "video_games",
        "question": "How much are the sales of the games in region ID 4?",
        "ground_truth": "SELECT SUM(T.num_sales) * 100000 FROM region_sales AS T WHERE T.region_id = 4",
        "amends": [
            "Do use `SUM(T.num_sales) * 100000` instead of `SUM(price)` to calculate total sales in units of 100,000. Do reference the `region_sales` table with alias `T` instead of the `games` table. Do filter on `T.region_id = 4` instead of `region_id = 4` to maintain proper table qualification. The amended query now correctly calculates total sales in the specified units from the appropriate sales data table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM games WHERE region_id = 4;",
            "SELECT SUM(T.num_sales) * 100000 AS total_sales FROM region_sales T WHERE T.region_id = 4"
        ],
        "rule_sql": []
    },
    "5544": {
        "db_id": "menu",
        "question": "On 1887-07-21, what was the event that lead to the creation of menu id 21380?",
        "ground_truth": "SELECT event FROM Menu WHERE date = '1887-07-21' AND id = 21380",
        "amends": [
            "Do select `event` instead of `*` from the `Menu` table instead of the `events` table. Do filter on `id = 21380` instead of `menu_id = 21380` while keeping the date filter `date = '1887-07-21'` unchanged. The amended query now correctly retrieves events from the Menu table using the proper primary key reference."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM events WHERE date = '1887-07-21' AND menu_id = 21380;",
            "SELECT event FROM Menu WHERE id = 21380 AND date = '1887-07-21';"
        ],
        "rule_sql": []
    },
    "763": {
        "db_id": "movie",
        "question": "In romantic movies, how many of them starred by John Travolta?",
        "ground_truth": "SELECT COUNT(*) FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID INNER JOIN actor AS T3 ON T3.ActorID = T2.ActorID WHERE T1.Genre = 'Romance' AND T3.Name = 'John Travolta'",
        "amends": [
            "Do join `movie AS T1` with `characters AS T2` on `T1.MovieID = T2.MovieID` and `actor AS T3` on `T3.ActorID = T2.ActorID` instead of querying only `movies` table. Do filter on `T1.Genre = 'Romance'` instead of `genre = 'romantic'` and on `T3.Name = 'John Travolta'` instead of `actor = 'John Travolta'`. The amended query now correctly joins related tables to count movies where John Travolta acted in romance genre films, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE genre = 'romantic' AND actor = 'John Travolta';",
            "SELECT COUNT(DISTINCT T1.MovieID) \nFROM movie AS T1 \nJOIN characters AS T2 ON T1.MovieID = T2.MovieID \nJOIN actor AS T3 ON T3.ActorID = T2.ActorID \nWHERE T1.Genre = 'Romance' AND T3.Name = 'John Travolta'"
        ],
        "rule_sql": []
    },
    "1969": {
        "db_id": "soccer_2016",
        "question": "Calculate the win rate of the toss-winners in 2012.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Toss_Winner = Match_Winner THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Match_Date LIKE '2012%' THEN 1 ELSE 0 END) FROM `Match`",
        "amends": [
            "Do use `CAST` to convert the sum to `REAL` instead of integer division, and do reference `Match_Winner` instead of `winner` for the win condition. Do filter by `Match_Date LIKE '2012%'` instead of `year = 2012`, and do calculate the win rate as a direct division of two sums instead of using `COUNT(*)` and percentage multiplication. Do remove the column aliases `total_matches`, `toss_winner_wins`, and `win_rate` instead of keeping them, and do reference table `Match` instead of `matches`. The amended query now correctly handles the win rate calculation with proper type casting and date filtering to match the intended behavior.",
            "Do use `SUM(CASE WHEN Match_Date LIKE '2012%' THEN 1 ELSE 0 END)` in the denominator instead of `COUNT(*)` to properly filter the denominator to only 2012 matches, ensuring the ratio calculation includes only matches from the specified year in both numerator and denominator. Do remove the `WHERE Match_Date LIKE '2012%'` clause instead of keeping it, as the date filtering is now handled within the conditional sum in the denominator. The amended query now correctly calculates the proportion of matches where toss winner equals match winner specifically for 2012 matches only."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS total_matches, \n       SUM(CASE WHEN toss_winner = winner THEN 1 ELSE 0 END) AS toss_winner_wins,\n       (SUM(CASE WHEN toss_winner = winner THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS win_rate\nFROM matches\nWHERE year = 2012;",
            "SELECT CAST(SUM(CASE WHEN Toss_Winner = Match_Winner THEN 1 ELSE 0 END) AS REAL) / COUNT(*) FROM Match WHERE Match_Date LIKE '2012%'",
            "SELECT CAST(SUM(CASE WHEN Toss_Winner = Match_Winner THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Match_Date LIKE '2012%' THEN 1 ELSE 0 END) FROM Match;"
        ],
        "rule_sql": []
    },
    "651": {
        "db_id": "codebase_comments",
        "question": "What is the url of solution 1?",
        "ground_truth": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 1",
        "amends": [
            "Do select `T1.Url` from `Repo AS T1` instead of `url` from `solutions`. Do add `INNER JOIN Solution AS T2` instead of omitting it. Do use join condition `T1.Id = T2.RepoId` instead of no join. Do filter with `T2.Id = 1` instead of `solution_id = 1`. The amended query now correctly joins tables and filters by the appropriate ID column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT url FROM solutions WHERE solution_id = 1;",
            "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 1"
        ],
        "rule_sql": []
    },
    "4183": {
        "db_id": "simpson_episodes",
        "question": "How many persons were born in New York, USA?",
        "ground_truth": "SELECT COUNT(name) FROM Person WHERE birth_place = 'New York City' AND birth_country = 'USA';",
        "amends": [
            "Do reference table `Person` instead of `persons` in the FROM clause. Do use column `birth_place` with value 'New York City' instead of `city` with value 'New York' in the WHERE filter. Do use column `birth_country` instead of `country` in the WHERE filter. Do count `name` column instead of using `COUNT(*)` to count all rows. The amended query now correctly counts persons born in New York City, USA rather than those currently residing there."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM persons WHERE city = 'New York' AND country = 'USA';",
            "SELECT COUNT(name) FROM Person WHERE birth_place = 'New York City' AND birth_country = 'USA';"
        ],
        "rule_sql": []
    },
    "5316": {
        "db_id": "beer_factory",
        "question": "What brands of beers are manufactured at coordinates 38,566,129, -121,426,432?",
        "ground_truth": "SELECT DISTINCT T2.BrandName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID INNER JOIN geolocation AS T3 ON T1.LocationID = T3.LocationID WHERE T3.Latitude = '38.566129' AND T3.Longitude = '-121.426432'",
        "amends": [
            "Do use `DISTINCT T2.BrandName` instead of `brand` to select from the correct table with deduplication. Do join `rootbeer AS T1` with `rootbeerbrand AS T2` on `T1.BrandID = T2.BrandID` instead of querying `beers` directly. Do add an additional join to `geolocation AS T3` on `T1.LocationID = T3.LocationID` instead of accessing latitude and longitude directly from the beers table. Do filter on `T3.Latitude = '38.566129'` and `T3.Longitude = '-121.426432'` with proper string formatting and decimal points instead of using commas and incorrect numeric format. The amended query now correctly retrieves distinct brand names from the joined tables based on geographic coordinates."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM beers WHERE latitude = 38,566,129 AND longitude = -121,426,432;",
            "SELECT DISTINCT T2.BrandName\nFROM rootbeer AS T1\nJOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID\nJOIN geolocation AS T3 ON T1.LocationID = T3.LocationID\nWHERE T3.Latitude = 38.566129 AND T3.Longitude = -121.426432"
        ],
        "rule_sql": []
    },
    "2617": {
        "db_id": "regional_sales",
        "question": "What is the region of stores which have type of \"Town\" in the list?",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T2.Type = 'Town' THEN T1.Region END AS T FROM Regions T1 INNER JOIN `Store Locations` T2 ON T2.StateCode = T1.StateCode ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `SELECT DISTINCT CASE` instead of a simple `SELECT region`. Do add an `INNER JOIN` between `Regions` and `Store Locations` on `T2.StateCode = T1.StateCode` instead of querying only the `stores` table. Do apply the filter `T2.Type = 'Town'` within the CASE expression instead of a WHERE clause on `type = 'Town'`. Do add a final outer filter `WHERE T IS NOT NULL` instead of omitting NULL handling. Do return the result column as alias `T` instead of directly selecting `region`. The amended query now correctly handles the relationship between regions and store locations while filtering for town types and excluding NULL results."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region FROM stores WHERE type = 'Town';",
            "SELECT DISTINCT CASE WHEN T2.Type = 'Town' THEN T1.Region ELSE NULL END AS T\nFROM Regions T1\nINNER JOIN \"Store Locations\" T2 ON T1.StateCode = T2.StateCode\nWHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "1237": {
        "db_id": "talkingdata",
        "question": "What is the most common age group among all device users?",
        "ground_truth": "SELECT T.num FROM ( SELECT `group`, COUNT(`group`) AS num FROM gender_age GROUP BY `group` ) T",
        "amends": [
            "Do select `T.num` from a derived table instead of directly selecting `age` and `COUNT(*) as count`. Do use a subquery that selects `group` and `COUNT(group) AS num` from the `gender_age` table instead of selecting from the `users` table. Do group by `group` instead of grouping by `age`. Do remove the `ORDER BY count DESC LIMIT 1` clause instead of keeping it, as the right query returns all grouped counts rather than just the maximum count. The amended query now correctly counts groups from the gender_age table and returns all group counts through the derived table T."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age, COUNT(*) as count FROM users GROUP BY age ORDER BY count DESC LIMIT 1;",
            "SELECT T.num FROM (SELECT `group`, COUNT(`group`) AS num FROM gender_age GROUP BY `group`) AS T"
        ],
        "rule_sql": []
    },
    "3445": {
        "db_id": "video_games",
        "question": "Calculate the average game sales for the PS2 platform.",
        "ground_truth": "SELECT SUM(T3.num_sales * 100000) / COUNT(T1.id) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN region_sales AS T3 ON T2.id = T3.game_platform_id WHERE T1.platform_name = 'PS2'",
        "amends": [
            "Do use `SUM(T3.num_sales * 100000) / COUNT(T1.id)` instead of `AVG(sales)` to calculate the weighted average of sales in millions. Do add `platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN region_sales AS T3 ON T2.id = T3.game_platform_id` instead of the single table `games` to properly join the platform, game_platform, and region_sales tables. Do filter on `T1.platform_name = 'PS2'` instead of `platform = 'PS3'` to target the correct platform. The amended query now correctly calculates the average sales per game for PS2 by summing all regional sales (converted from hundred-thousands to units) and dividing by the count of games, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(sales) FROM games WHERE platform = 'PS3';",
            "SELECT SUM(T3.num_sales * 100000) / COUNT(T1.id) AS average_sales\nFROM platform AS T1 \nINNER JOIN game_platform AS T2 ON T1.id = T2.platform_id \nINNER JOIN region_sales AS T3 ON T2.id = T3.game_platform_id\nWHERE T1.platform_name = 'PS2'"
        ],
        "rule_sql": []
    },
    "9298": {
        "db_id": "movie_3",
        "question": "How many English films have a duration of over 50 minutes and the cost of replacement are under 10.99?",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film AS T1 INNER JOIN language AS T2 ON T1.language_id = T2.language_id WHERE T2.name = 'English' AND T1.length > 50 AND T1.replacement_cost < 10.99",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film WHERE language_id = 1 AND length > 50 AND replacement_cost < 10.99;"
        ],
        "rule_sql": []
    },
    "7830": {
        "db_id": "world",
        "question": "List any five countries which use English as an official language.",
        "ground_truth": "SELECT T1.Name FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' LIMIT 5",
        "amends": [
            "Do join `Country AS T1` with `CountryLanguage AS T2` on `T1.Code = T2.CountryCode` instead of querying only the `countries` table. Do filter on `T2.Language = 'English'` and `T2.IsOfficial = 'T'` instead of filtering only on `official_language = 'English'`. Do select `T1.Name` instead of `name` to specify the table source. The amended query now correctly identifies countries where English is an official language by joining the Country and CountryLanguage tables with proper join conditions and official status filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE official_language = 'English' LIMIT 5;",
            "SELECT T1.Name \nFROM Country AS T1 \nJOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode \nWHERE T2.Language = 'English' AND T2.IsOfficial = 'T' \nLIMIT 5"
        ],
        "rule_sql": []
    },
    "1892": {
        "db_id": "soccer_2016",
        "question": "What are the average extra runs given in the second innings of every match?",
        "ground_truth": "SELECT AVG(Innings_No) FROM Extra_Runs WHERE Innings_No = 2",
        "amends": [
            "Do use `AVG(Innings_No)` instead of `AVG(extra_runs)` and change the column being averaged. Do reference table `Extra_Runs` instead of `deliveries` as the data source. Do filter with `WHERE Innings_No = 2` instead of `WHERE innings = 2` and use the correct column name. Do remove `GROUP BY match_id` instead of keeping it since the query now calculates a single aggregate value. Do omit `match_id` from the SELECT list instead of including it as a grouping column. The amended query now correctly calculates the average innings number from the Extra_Runs table filtered to the second innings, matching the right SQL's behavior.",
            "Do calculate the average of `Innings_No` instead of `Extra_Runs` in the SELECT clause while maintaining the same WHERE filter condition `Innings_No = 2`. The amended query now correctly computes the average innings number rather than extra runs, matching the intended behavior of the right SQL."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT match_id, AVG(extra_runs) as avg_extra_runs FROM deliveries WHERE innings = 2 GROUP BY match_id;",
            "SELECT AVG(Extra_Runs) FROM Extra_Runs WHERE Innings_No = 2;",
            "SELECT AVG(Innings_No) FROM Extra_Runs WHERE Innings_No = 2;"
        ],
        "rule_sql": []
    },
    "8753": {
        "db_id": "chicago_crime",
        "question": "List down the report number of crimes associated with the district commander named Jill M. Stevens.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.commander = 'Jill M. Stevens' THEN 1 ELSE 0 END) FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no",
        "amends": [
            "Do use `SUM(CASE WHEN T1.commander = 'Jill M. Stevens' THEN 1 ELSE 0 END)` instead of selecting `report_number` directly. Do join `District AS T1` with `Crime AS T2` using `INNER JOIN` on `T1.district_no = T2.district_no` instead of querying only the `crimes` table. Do reference the commander field as `T1.commander` instead of `district_commander` and perform the count through conditional aggregation rather than individual row selection. The amended query now correctly counts reports by district commander through proper table joining and aggregation."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT report_number FROM crimes WHERE district_commander = 'Jill M. Stevens';",
            "SELECT SUM(CASE WHEN T1.commander = 'Jill M. Stevens' THEN 1 ELSE 0 END) AS report_count\nFROM District AS T1\nINNER JOIN Crime AS T2 ON T1.district_no = T2.district_no;"
        ],
        "rule_sql": []
    },
    "8468": {
        "db_id": "mondial_geo",
        "question": "State all countries with border greater than 4,000. List the full country name.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN borders AS T2 ON T1.Code = T2.Country1 WHERE T2.Length > 4000",
        "amends": [
            "Do use `T1.Name` with table alias instead of `name` without qualification. Do join `country AS T1` with `borders AS T2` instead of querying `countries` table alone. Do specify `INNER JOIN` with join condition `ON T1.Code = T2.Country1` instead of no join. Do filter on `T2.Length > 4000` instead of `border > 4000` which references a non-existent column. The amended query now correctly joins the country and borders tables to find countries with border lengths exceeding 4000, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE border > 4000;",
            "SELECT T1.Name \nFROM country AS T1 \nINNER JOIN borders AS T2 ON T1.Code = T2.Country1 \nWHERE T2.Length > 4000"
        ],
        "rule_sql": []
    },
    "9393": {
        "db_id": "movie_3",
        "question": "Provide the full name of all the actors of the film \"Ending Crowds\".",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T3.title = 'ENDING CROWDS'",
        "amends": [
            "Do specify table aliases `T2.first_name` and `T2.last_name` instead of unqualified column names. Do add `film_actor AS T1` and `film AS T3` tables instead of querying only the `actors` table. Do use `INNER JOIN` on `T1.actor_id = T2.actor_id` and `T1.film_id = T3.film_id` instead of missing join conditions. Do filter on `T3.title = 'ENDING CROWDS'` with proper table qualification instead of `film_title = 'Ending Crowds'` with incorrect column name and case sensitivity. The amended query now correctly joins through the film_actor junction table to find actors in the specified film."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM actors WHERE film_title = 'Ending Crowds';",
            "SELECT T2.first_name, T2.last_name\nFROM actor AS T2\nINNER JOIN film_actor AS T1 ON T1.actor_id = T2.actor_id\nINNER JOIN film AS T3 ON T1.film_id = T3.film_id\nWHERE T3.title = 'ENDING CROWDS';"
        ],
        "rule_sql": []
    },
    "752": {
        "db_id": "movie",
        "question": "Give the biography of the actor who played \"Michael Moscovitz\".",
        "ground_truth": "SELECT T2.Biography FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE T1.`Character Name` = 'Michael Moscovitz'",
        "amends": [
            "Do join `characters AS T1` and `actor AS T2` with `INNER JOIN` on `T1.ActorID = T2.ActorID` instead of querying only the `actors` table. Do select `T2.Biography` from the joined actor table instead of selecting `biography` directly from the actors table. Do filter on `T1.Character Name` instead of filtering on `character_name` in the actors table. The amended query now correctly retrieves biography information by joining the characters and actor tables to match character names with their corresponding actor biographies."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT biography FROM actors WHERE character_name = 'Michael Moscovitz';",
            "SELECT T2.Biography FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE T1.\"Character Name\" = 'Michael Moscovitz'"
        ],
        "rule_sql": []
    },
    "176": {
        "db_id": "book_publishing_company",
        "question": "List all titles with sales of quantity more than 20 and store located in the CA state.",
        "ground_truth": "SELECT T1.title, T2.qty FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id INNER JOIN stores AS T3 ON T2.stor_id = T3.stor_id WHERE T2.qty > 20 AND T3.state = 'CA'",
        "amends": [
            "Do use `T1.title, T2.qty` in the SELECT list instead of just `title`. Do reference `titles AS T1` instead of `books` as the main table. Do use `INNER JOIN sales AS T2 ON T1.title_id = T2.title_id` instead of `JOIN sales ON books.id = sales.book_id`. Do use `INNER JOIN stores AS T3 ON T2.stor_id = T3.stor_id` instead of `JOIN stores ON sales.store_id = stores.id`. Do filter on `T2.qty > 20` instead of `sales.quantity > 20`. Do filter on `T3.state = 'CA'` instead of `stores.state = 'CA'`. The amended query now correctly joins on the proper key relationships and selects the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books JOIN sales ON books.id = sales.book_id JOIN stores ON sales.store_id = stores.id WHERE sales.quantity > 20 AND stores.state = 'CA';",
            "SELECT T1.title, T2.qty\nFROM titles AS T1\nINNER JOIN sales AS T2 ON T1.title_id = T2.title_id\nINNER JOIN stores AS T3 ON T2.stor_id = T3.stor_id\nWHERE T2.qty > 20 AND T3.state = 'CA'"
        ],
        "rule_sql": []
    },
    "46": {
        "db_id": "movie_platform",
        "question": "What is the URL to the rating on Mubi made by user 45579900 for the movie \"The Vertical Ray of the Sun\" that received 20 likes?",
        "ground_truth": "SELECT T2.rating_url FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id WHERE T2.user_id = 45579900 AND T1.movie_title = 'The Vertical Ray of the Sun' AND T2.critic_likes = 20",
        "amends": [
            "Do select `T2.rating_url` instead of `url` and use table alias `T2` for the ratings table. Do join `movies AS T1` instead of querying only the ratings table, using `INNER JOIN` on `T1.movie_id = T2.movie_id` instead of no join condition. Do filter on `T2.critic_likes = 20` instead of `likes = 20` to reference the correct column name. Do maintain the filter on `T2.user_id = 45579900` and add the movie title filter on `T1.movie_title` instead of filtering directly on the ratings table. The amended query now correctly joins movies and ratings tables to find the rating URL with proper column references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT url FROM ratings WHERE user_id = 45579900 AND movie_title = 'The Vertical Ray of the Sun' AND likes = 20;",
            "SELECT T2.rating_url\nFROM movies AS T1\nINNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id\nWHERE T2.user_id = 45579900\nAND T1.movie_title = 'The Vertical Ray of the Sun'\nAND T2.critic_likes = 20"
        ],
        "rule_sql": []
    },
    "6051": {
        "db_id": "books",
        "question": "Identify the publisher of the book Girls' Night In.",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T1.title = 'Girls'' Night In'",
        "amends": [
            "Do select `T2.publisher_name` instead of `author` to retrieve publisher information rather than author. Do add `INNER JOIN publisher AS T2` instead of omitting the join to incorporate publisher data. Do use join condition `T1.publisher_id = T2.publisher_id` instead of no join condition to properly relate books to their publishers. The amended query now correctly retrieves the publisher name for the specified book title instead of the author, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM books WHERE title = 'Girls'' Night In';",
            "SELECT T2.publisher_name\nFROM book AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id\nWHERE T1.title = \"Girls' Night In\";"
        ],
        "rule_sql": []
    },
    "5035": {
        "db_id": "olympics",
        "question": "What is the region id of Christine Jacoba Aaftink?",
        "ground_truth": "SELECT T1.region_id FROM person_region AS T1 INNER JOIN person AS T2 ON T1.person_id = T2.id WHERE T2.full_name = 'Christine Jacoba Aaftink'",
        "amends": [
            "Do select `T1.region_id` from `person_region AS T1` instead of `region_id` from `athletes`. Do join `person AS T2` with `INNER JOIN` on `T1.person_id = T2.id` instead of querying the `athletes` table directly. Do filter with `T2.full_name = 'Christine Jacoba Aaftink'` instead of separate `first_name` and `last_name` conditions. The amended query now correctly retrieves region information through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_id FROM athletes WHERE first_name = 'Christine' AND last_name = 'Jacoba Aaftink';",
            "SELECT T1.region_id FROM person_region AS T1 INNER JOIN person AS T2 ON T1.person_id = T2.id WHERE T2.full_name = 'Christine Jacoba Aaftink'"
        ],
        "rule_sql": []
    },
    "4397": {
        "db_id": "student_loan",
        "question": "How many male students have no due payments?",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN male AS T2 ON T1.name = T2.name WHERE T1.bool = 'neg'",
        "amends": [
            "Do select `COUNT(T1.name)` instead of `COUNT(*)`. Do use `FROM no_payment_due AS T1 INNER JOIN male AS T2 ON T1.name = T2.name` instead of `FROM students` with a single table. Do add join condition `ON T1.name = T2.name` instead of no join. Do change filter to `WHERE T1.bool = 'neg'` instead of `WHERE gender = 'female' AND payment_due = 0`. Do remove the `gender = 'female'` condition and add the `T1.bool = 'neg'` condition instead. The amended query now correctly counts names from the joined tables with the specified boolean filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'female' AND payment_due = 0;",
            "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN male AS T2 ON T1.name = T2.name WHERE T1.bool = 'neg'"
        ],
        "rule_sql": []
    },
    "4492": {
        "db_id": "student_loan",
        "question": "Among the students with disabilities, list any five students' names who are unemployed.",
        "ground_truth": "SELECT T1.name FROM disabled AS T1 INNER JOIN unemployed AS T2 ON T2.name = T1.name LIMIT 5",
        "amends": [
            "Do select `T1.name` with explicit table alias instead of `name` without qualification. Do use `FROM disabled AS T1 INNER JOIN unemployed AS T2` instead of `FROM students` with filter conditions. Do join on `T2.name = T1.name` instead of filtering with `disability = 'yes' AND employment_status = 'unemployed'`. The amended query now correctly joins two separate tables to find disabled and unemployed individuals rather than relying on potentially incorrect column values in a single table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE disability = 'yes' AND employment_status = 'unemployed' LIMIT 5;",
            "SELECT T1.name FROM disabled AS T1 INNER JOIN unemployed AS T2 ON T2.name = T1.name LIMIT 5"
        ],
        "rule_sql": []
    },
    "3551": {
        "db_id": "authors",
        "question": "List the paper title and journal ID which were published under the conference name of \"International Symposium of Robotics Research\".",
        "ground_truth": "SELECT DISTINCT T2.Title, T2.JournalId FROM Conference AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId WHERE T1.FullName = 'International Symposium of Robotics Research' AND T2.Year = 2003",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate results. Do select `T2.Title` and `T2.JournalId` instead of `paper_title` and `journal_id` to match the correct column names. Do join `Conference AS T1` and `Paper AS T2` with `INNER JOIN` on `T1.Id = T2.ConferenceId` instead of querying only the `papers` table to properly relate conference and paper data. Do filter with `T1.FullName = 'International Symposium of Robotics Research'` instead of `conference_name` to use the correct conference name column. Do add `T2.Year = 2003` instead of omitting it to filter for papers from the specific year 2003. The amended query now correctly retrieves distinct paper titles and journal IDs for the specified conference and year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paper_title, journal_id FROM papers WHERE conference_name = 'International Symposium of Robotics Research'",
            "SELECT DISTINCT T2.Title, T2.JournalId\nFROM Conference AS T1\nINNER JOIN Paper AS T2 ON T1.Id = T2.ConferenceId\nWHERE T1.FullName = 'International Symposium of Robotics Research'\nAND T2.Year = 2003"
        ],
        "rule_sql": []
    },
    "9093": {
        "db_id": "bike_share_1",
        "question": "What is the percentage ration of customers to subscribers that started their trips within the city of San Francisco?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.subscription_type = 'Customer' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.subscription_type = 'Subscriber' THEN 1 ELSE 0 END) FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'San Francisco'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN T1.subscription_type = 'Customer' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.subscription_type = 'Subscriber' THEN 1 ELSE 0 END)` instead of `(COUNT(DISTINCT customer_id) * 100.0 / COUNT(DISTINCT subscriber_id))` for calculating the percentage ratio based on subscription types rather than distinct IDs. Do add `LEFT JOIN station AS T2 ON T2.name = T1.start_station_name` instead of omitting the station table join. Do move the city filter to `T2.city = 'San Francisco'` instead of `start_city = 'San Francisco'` to filter by station city rather than trip start city. Do remove the `DISTINCT` operations instead of keeping them since the logic now counts occurrences rather than unique values. The amended query now correctly calculates the percentage of customer trips versus subscriber trips from San Francisco stations."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT customer_id) * 100.0 / COUNT(DISTINCT subscriber_id)) AS percentage_ratio\nFROM trips\nWHERE start_city = 'San Francisco';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.subscription_type = 'Customer' THEN 1 ELSE 0 END) AS REAL) * 100 / \n    SUM(CASE WHEN T1.subscription_type = 'Subscriber' THEN 1 ELSE 0 END) AS percentage_ratio\nFROM \n    trip AS T1\nLEFT JOIN \n    station AS T2 ON T2.name = T1.start_station_name\nWHERE \n    T2.city = 'San Francisco'"
        ],
        "rule_sql": []
    },
    "8096": {
        "db_id": "university",
        "question": "How many students were there in University of Michigan in 2011?",
        "ground_truth": "SELECT COUNT(*) FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id WHERE T1.university_name = 'University of Michigan' AND T2.year = 2011",
        "amends": [
            "Do join `university AS T1` and `university_year AS T2` with `INNER JOIN` on `T1.id = T2.university_id` instead of querying only the `students` table. Do filter on `T1.university_name = 'University of Michigan'` instead of `university = 'University of Michigan'` and do filter on `T2.year = 2011` instead of `year = 2011`. The amended query now correctly counts records by joining the university and university_year tables with proper relationship constraints instead of relying on a single table with potentially incorrect schema.",
            "Do use `COUNT(*)` instead of selecting `T2.num_students` to count records instead of retrieving a specific column value. Do remove the explicit column reference and instead aggregate with a count function to obtain the total number of matching records rather than individual student counts. The amended query now correctly counts all university-year records for the specified university and year instead of returning the num_students field directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university = 'University of Michigan' AND year = 2011;",
            "SELECT T2.num_students \nFROM university AS T1 \nINNER JOIN university_year AS T2 ON T1.id = T2.university_id \nWHERE T1.university_name = 'University of Michigan' \nAND T2.year = 2011",
            "SELECT COUNT(*) \nFROM university AS T1 \nINNER JOIN university_year AS T2 ON T1.id = T2.university_id \nWHERE T1.university_name = 'University of Michigan' \nAND T2.year = 2011"
        ],
        "rule_sql": []
    },
    "2079": {
        "db_id": "music_tracker",
        "question": "List the name of artists who have released albums and mixtape from 1980 to 1985 in \"dance\" genre.",
        "ground_truth": "SELECT COUNT(T1.artist) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'dance' AND T1.groupYear BETWEEN 1980 AND 1985 AND T1.releaseType LIKE 'album' OR T1.releaseType LIKE 'mixtape'",
        "amends": [
            "Do use `COUNT(T1.artist)` instead of selecting `name`. Do change the FROM clause to use `torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id` instead of querying only the `artists` table. Do replace the WHERE condition with `T2.tag = 'dance' AND T1.groupYear BETWEEN 1980 AND 1985 AND (T1.releaseType LIKE 'album' OR T1.releaseType LIKE 'mixtape')` instead of `genre = 'dance' AND year BETWEEN 1980 AND 1985`, adding release type filtering and proper table aliasing. The amended query now correctly counts artists from joined torrent and tag data with appropriate filtering conditions.",
            "Do remove `T1.artist` from the SELECT list instead of including it, and do remove the GROUP BY clause instead of keeping it. Do fix the WHERE clause by removing parentheses around the OR condition instead of having them, changing `(T1.releaseType LIKE 'album' OR T1.releaseType LIKE 'mixtape')` to `T1.releaseType LIKE 'album' OR T1.releaseType LIKE 'mixtape'` to ensure proper operator precedence. The amended query now correctly returns a single count of dance albums or mixtapes from 1980-1985 without grouping by artist, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM artists WHERE genre = 'dance' AND year BETWEEN 1980 AND 1985;",
            "SELECT T1.artist, COUNT(T1.artist) \nFROM torrents AS T1 \nINNER JOIN tags AS T2 ON T1.id = T2.id \nWHERE T2.tag = 'dance' \nAND T1.groupYear BETWEEN 1980 AND 1985 \nAND (T1.releaseType LIKE 'album' OR T1.releaseType LIKE 'mixtape')\nGROUP BY T1.artist",
            "SELECT COUNT(T1.artist) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = 'dance' AND T1.groupYear BETWEEN 1980 AND 1985 AND T1.releaseType LIKE 'album' OR T1.releaseType LIKE 'mixtape'"
        ],
        "rule_sql": []
    },
    "6746": {
        "db_id": "retails",
        "question": "What is the order priority of the order with the highest total price?",
        "ground_truth": "SELECT o_orderpriority FROM orders WHERE o_totalprice = ( SELECT MAX(o_totalprice) FROM orders )",
        "amends": [
            "Do select `o_orderpriority` instead of `priority` and do move the maximum value calculation to a subquery instead of using `ORDER BY...LIMIT 1`. Do add a `WHERE` clause with `o_totalprice = (subquery)` instead of omitting it, and do use the correct column name `o_totalprice` instead of `total_price`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the subquery approach more accurately identifies the maximum value. The amended query now correctly returns the order priority for the order with the highest total price, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT priority FROM orders ORDER BY total_price DESC LIMIT 1;",
            "SELECT o_orderpriority FROM orders WHERE o_totalprice = (SELECT MAX(o_totalprice) FROM orders);"
        ],
        "rule_sql": []
    },
    "1356": {
        "db_id": "law_episode",
        "question": "Which episode has the two keywords \"nun\" and \"priest\"?",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T2.keyword IN ('nun', 'priest')",
        "amends": [
            "Do use `T1.title` instead of `episode_name` for the column selection. Do join `Episode AS T1` with `Keyword AS T2` instead of querying a single table. Do use `INNER JOIN` with `T1.episode_id = T2.episode_id` instead of no join condition. Do use `T2.keyword IN ('nun', 'priest')` instead of `keyword = 'nun' OR keyword = 'priest'` for the filter condition. The amended query now correctly joins the Episode and Keyword tables to find titles associated with the specified keywords, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_name FROM episodes WHERE keyword = 'nun' OR keyword = 'priest';",
            "SELECT T1.title\nFROM Episode AS T1\nINNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id\nWHERE T2.keyword IN ('nun', 'priest')\nGROUP BY T1.episode_id\nHAVING COUNT(DISTINCT T2.keyword) = 2;"
        ],
        "rule_sql": []
    },
    "6156": {
        "db_id": "food_inspection_2",
        "question": "What is the full name of the employee who gave the highest amount of fine of all time?",
        "ground_truth": "SELECT T.first_name, T.last_name FROM ( SELECT T1.first_name, T1.last_name, SUM(T3.fine) FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id GROUP BY T1.first_name, T1.last_name ORDER BY SUM(T3.fine) DESC LIMIT 1 ) t",
        "amends": [
            "Do add table aliases `T.first_name` and `T.last_name` instead of using unqualified column names. Do replace the direct `FROM employees` with a subquery that joins `employee AS T1`, `inspection AS T2`, and `violation AS T3` instead of accessing a single table. Do add `INNER JOIN` on `T1.employee_id = T2.employee_id` and `INNER JOIN` on `T2.inspection_id = T3.inspection_id` instead of no joins. Do add `SUM(T3.fine)` aggregate instead of omitting it. Do add `GROUP BY T1.first_name, T1.last_name` instead of no grouping. Do change `ORDER BY SUM(T3.fine) DESC` instead of `ORDER BY fine_amount DESC` to use the calculated sum rather than a non-existent column. The amended query now correctly calculates total fines per employee and returns the employee with the highest total fine amount."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM employees ORDER BY fine_amount DESC LIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM employee AS T1\nINNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nINNER JOIN violation AS T3 ON T2.inspection_id = T3.inspection_id\nGROUP BY T1.first_name, T1.last_name\nORDER BY SUM(T3.fine) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7531": {
        "db_id": "image_and_language",
        "question": "Name the object element that is described as being scattered on image no. 10.",
        "ground_truth": "SELECT T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID INNER JOIN IMG_OBJ_ATT AS T3 ON T1.IMG_ID = T3.IMG_ID INNER JOIN ATT_CLASSES AS T4 ON T3.ATT_CLASS_ID = T4.ATT_CLASS_ID WHERE T4.ATT_CLASS = 'scattered' AND T1.IMG_ID = 10 GROUP BY T2.OBJ_CLASS",
        "amends": [
            "Do select `T2.OBJ_CLASS` instead of `object_name` and add `GROUP BY T2.OBJ_CLASS` instead of omitting aggregation. Do change FROM to join multiple tables including `IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID INNER JOIN IMG_OBJ_ATT AS T3 ON T1.IMG_ID = T3.IMG_ID INNER JOIN ATT_CLASSES AS T4 ON T3.ATT_CLASS_ID = T4.ATT_CLASS_ID` instead of a single `images` table. Do change WHERE filter to `T4.ATT_CLASS = 'scattered' AND T1.IMG_ID = 10` instead of `image_id = 10 AND description LIKE '%scattered%'`, removing the LIKE pattern match and using exact equality on the attribute class. The amended query now correctly joins the necessary tables to establish proper relationships between images, objects, and attributes, ensuring accurate filtering and result grouping.",
            "Do remove the `T1.OBJ_SAMPLE_ID = T3.OBJ_SAMPLE_ID` condition from the `IMG_OBJ_ATT` join instead of including it, as the right query only joins on `IMG_ID` between these tables. The amended query now correctly matches the RIGHT_SQL's behavior by simplifying the join condition to focus solely on image ID matching for the attribute relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_name FROM images WHERE image_id = 10 AND description LIKE '%scattered%';",
            "SELECT T2.OBJ_CLASS\nFROM IMG_OBJ AS T1\nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nINNER JOIN IMG_OBJ_ATT AS T3 ON T1.IMG_ID = T3.IMG_ID AND T1.OBJ_SAMPLE_ID = T3.OBJ_SAMPLE_ID\nINNER JOIN ATT_CLASSES AS T4 ON T3.ATT_CLASS_ID = T4.ATT_CLASS_ID\nWHERE T4.ATT_CLASS = 'scattered' AND T1.IMG_ID = 10\nGROUP BY T2.OBJ_CLASS",
            "SELECT T2.OBJ_CLASS\nFROM IMG_OBJ AS T1\nINNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID\nINNER JOIN IMG_OBJ_ATT AS T3 ON T1.IMG_ID = T3.IMG_ID\nINNER JOIN ATT_CLASSES AS T4 ON T3.ATT_CLASS_ID = T4.ATT_CLASS_ID\nWHERE T4.ATT_CLASS = 'scattered' AND T1.IMG_ID = 10\nGROUP BY T2.OBJ_CLASS"
        ],
        "rule_sql": []
    },
    "2694": {
        "db_id": "regional_sales",
        "question": "How many stores with less need for products, and purchased through a distributor, are located in Washtenaw County?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.`Order Quantity` = 1 AND T1.`Sales Channel` = 'Distributor' AND T2.County = 'Washtenaw County' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID",
        "amends": [
            "Do use `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count conditional rows. Do reference `T1.\\`Order Quantity\\` = 1` instead of `product_need > 100` for the quantity filter. Do use `T1.\\`Sales Channel\\` = 'Distributor'` instead of `purchase_method = 'distributor'` for the channel filter. Do reference `T2.County = 'Washtenaw County'` instead of `county = 'Washtenaw'` for the county filter. Do add `INNER JOIN \\`Store Locations\\` AS T2 ON T2.StoreID = T1._StoreID` instead of querying only the stores table. Do use table aliases `T1` and `T2` instead of direct table references. The amended query now correctly joins sales orders with store locations and counts only the specific conditional matches."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores WHERE county = 'Washtenaw' AND purchase_method = 'distributor' AND product_need > 100;",
            "SELECT SUM(CASE WHEN T1.\"Order Quantity\" = 1 AND T1.\"Sales Channel\" = 'Distributor' THEN 1 ELSE 0 END) AS store_count\nFROM \"Sales Orders\" AS T1\nINNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID\nWHERE T2.County = 'Washtenaw County'"
        ],
        "rule_sql": []
    },
    "6902": {
        "db_id": "retails",
        "question": "What is the name of the customer whose order was delivered the longest?",
        "ground_truth": "SELECT T3.c_name FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey INNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey ORDER BY (JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate)) DESC LIMIT 1",
        "amends": [
            "Do select `T3.c_name` from the `customer` table instead of `customer_name` from `customers`. Do join `orders AS T1` with `lineitem AS T2` on `T1.o_orderkey = T2.l_orderkey` instead of querying a single table. Do add an additional `INNER JOIN` to `customer AS T3` on `T1.o_custkey = T3.c_custkey` instead of omitting these table relationships. Do order by the calculated date difference `(JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate))` instead of simply `delivery_date`. The amended query now correctly identifies the customer with the longest receipt-to-commit timeline by joining the necessary tables and calculating the precise date interval, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers ORDER BY delivery_date DESC LIMIT 1;",
            "SELECT T3.c_name\nFROM orders AS T1\nINNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey\nINNER JOIN customer AS T3 ON T1.o_custkey = T3.c_custkey\nORDER BY (JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate)) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1285": {
        "db_id": "law_episode",
        "question": "How many awards did the \"Agony\" win?",
        "ground_truth": "SELECT COUNT(T2.award) FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Agony' AND T2.result = 'Winner'",
        "amends": [
            "Do select `COUNT(T2.award)` from the `Award` table instead of `COUNT(*)` from a non-existent `awards` table. Do join `Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id` instead of querying a single incorrect table. Do add filter conditions `T1.title = 'Agony' AND T2.result = 'Winner'` instead of the incorrect `award_name = 'Agony'` predicate. The amended query now correctly counts award winners for the 'Agony' episode instead of attempting to count from a non-existent table with incorrect filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE award_name = 'Agony';",
            "SELECT COUNT(T2.award) \nFROM Episode AS T1 \nINNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id \nWHERE T1.title = 'Agony' AND T2.result = 'Winner'"
        ],
        "rule_sql": []
    },
    "7487": {
        "db_id": "image_and_language",
        "question": "To which predicted relation class does the self-relation of the object sample in image no.5 belong?",
        "ground_truth": "SELECT T1.PRED_CLASS FROM PRED_CLASSES AS T1 INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T2.IMG_ID = 5 AND T2.OBJ1_SAMPLE_ID = T2.OBJ2_SAMPLE_ID",
        "amends": [
            "Do select `T1.PRED_CLASS` from table `PRED_CLASSES AS T1` instead of `predicted_relation_class` from `image_objects`. Do use `INNER JOIN` on `IMG_REL AS T2` with predicate `T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` instead of no join. Do filter with `T2.IMG_ID = 5` instead of `image_id = 5` and `T2.OBJ1_SAMPLE_ID = T2.OBJ2_SAMPLE_ID` instead of the tautological `object_id = object_id`. The amended query now correctly joins the classification and relationship tables to find matching object pairs within the specified image."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT predicted_relation_class FROM image_objects WHERE image_id = 5 AND object_id = object_id;",
            "SELECT T1.PRED_CLASS \nFROM PRED_CLASSES AS T1\nINNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID\nWHERE T2.IMG_ID = 5 \nAND T2.OBJ1_SAMPLE_ID = T2.OBJ2_SAMPLE_ID"
        ],
        "rule_sql": []
    },
    "8817": {
        "db_id": "food_inspection",
        "question": "Between 2014 to 2016, what is the average inpsection score of the establishment owned by Yiu Tim Chan in 808 Pacific Ave, San Francisco?",
        "ground_truth": "SELECT AVG(T1.score) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE STRFTIME('%Y', T1.`date`) BETWEEN '2014' AND '2016' AND T2.owner_name = 'Yiu Tim Chan' AND T2.address = '808 Pacific Ave' AND T2.city = 'San Francisco'",
        "amends": [
            "Do join `businesses AS T2` on `T1.business_id = T2.business_id` instead of querying only the `inspections` table. Do filter by `STRFTIME('%Y', T1.date)` between '2014' and '2016' instead of filtering by exact date range on the raw date field. Do reference `T2.owner_name` and `T2.address` from the joined businesses table instead of using those fields directly from inspections. Do add `T2.city = 'San Francisco'` instead of including city in the address string. Do qualify the aggregate as `AVG(T1.score)` instead of just `AVG(score)`. The amended query now correctly joins the necessary tables and uses proper date filtering by year while maintaining the correct business location criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) \nFROM inspections \nWHERE owner_name = 'Yiu Tim Chan' \nAND address = '808 Pacific Ave, San Francisco' \nAND date BETWEEN '2014-01-01' AND '2016-12-31';",
            "SELECT AVG(T1.score) \nFROM inspections AS T1\nJOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE STRFTIME('%Y', T1.date) BETWEEN '2014' AND '2016'\nAND T2.owner_name = 'Yiu Tim Chan'\nAND T2.address = '808 Pacific Ave'\nAND T2.city = 'San Francisco'"
        ],
        "rule_sql": []
    },
    "5822": {
        "db_id": "airline",
        "question": "Please list the destination cities of all the flights that were cancelled on 2018/8/1.",
        "ground_truth": "SELECT DEST FROM Airlines WHERE FL_DATE = '2018/8/1' AND CANCELLED = 1 GROUP BY DEST",
        "amends": [
            "Do select `DEST` instead of `departure_city` and use `GROUP BY DEST` instead of omitting aggregation. Do use table `Airlines` instead of `flights` and filter on `CANCELLED = 1` instead of `status = 'cancelled'`. Do keep the date filter `FL_DATE = '2018/8/1'` instead of `date = '2018/8/1'` but maintain the same date value. The amended query now correctly groups by destination and uses the proper table and column names to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT departure_city FROM flights WHERE status = 'cancelled' AND date = '2018/8/1';",
            "SELECT DEST FROM Airlines WHERE FL_DATE = '2018/8/1' AND CANCELLED = 1 GROUP BY DEST"
        ],
        "rule_sql": []
    },
    "2927": {
        "db_id": "professional_basketball",
        "question": "How many turnovers per game did the assist champion had in the 2003 NBA season?",
        "ground_truth": "SELECT AVG(T2.turnovers) FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.year = 2003 GROUP BY T1.playerID, T2.assists ORDER BY T2.assists DESC LIMIT 1",
        "amends": [
            "Do use `AVG(T2.turnovers)` instead of `AVG(turnovers)` with explicit table alias. Do join `players AS T1` and `players_teams AS T2` on `T1.playerID = T2.playerID` instead of querying a single `player_stats` table. Do filter on `T2.year = 2003` instead of `season = '2003'` with numeric comparison rather than string. Do add `GROUP BY T1.playerID, T2.assists` instead of omitting grouping. Do add `ORDER BY T2.assists DESC LIMIT 1` instead of using a subquery with `MAX(assists)`. Do remove the subquery entirely instead of keeping it. The amended query now correctly calculates average turnovers for the player with maximum assists in 2003 through proper table joins and grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(turnovers) AS turnovers_per_game \nFROM player_stats \nWHERE season = '2003' \nAND assists = (SELECT MAX(assists) FROM player_stats WHERE season = '2003')",
            "SELECT AVG(T2.turnovers) AS turnovers_per_game\nFROM players AS T1\nJOIN players_teams AS T2 ON T1.playerID = T2.playerID\nWHERE T2.year = 2003\nGROUP BY T1.playerID, T2.assists\nORDER BY T2.assists DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "1840": {
        "db_id": "soccer_2016",
        "question": "How many matches were played by the player with player ID 2?",
        "ground_truth": "SELECT SUM(CASE WHEN Player_Id = 2 THEN 1 ELSE 0 END) FROM Player_Match",
        "amends": [
            "Do reference the `Player_Match` table instead of the `matches` table. Do use the `Player_Id` column instead of separate `player1_id` and `player2_id` columns. Do use a `SUM` with a `CASE` expression that counts when `Player_Id = 2` instead of using `COUNT(*)` with an `OR` condition on two different columns. Do remove the `WHERE` clause filter entirely instead of keeping it, as the conditional counting is now handled within the `CASE` expression. The amended query now correctly counts matches where the specified player participated, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE player1_id = 2 OR player2_id = 2;",
            "SELECT SUM(CASE WHEN Player_Id = 2 THEN 1 ELSE 0 END) AS match_count FROM Player_Match;"
        ],
        "rule_sql": []
    },
    "6796": {
        "db_id": "retails",
        "question": "How many products shipped on 19/11/1994 were ordered on 21/09/1994?",
        "ground_truth": "SELECT COUNT(T2.l_partkey) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderdate = '1994-09-21' AND T2.l_shipdate = '1994-11-19'",
        "amends": [
            "Do join `orders AS T1` with `lineitem AS T2` on `T1.o_orderkey = T2.l_orderkey` instead of querying only the `Orders` table. Do filter on `T1.o_orderdate = '1994-09-21'` instead of `OrderDate = '1994-09-21'` and use `T2.l_shipdate = '1994-11-19'` instead of `ShippedDate = '1994-11-19'`. Do count `T2.l_partkey` instead of `COUNT(*)` to count specific line items rather than all orders. The amended query now correctly counts line items shipped on 1994-11-19 from orders placed on 1994-09-21, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Orders WHERE ShippedDate = '1994-11-19' AND OrderDate = '1994-09-21';",
            "SELECT COUNT(T2.l_partkey) \nFROM orders AS T1 \nJOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey \nWHERE T1.o_orderdate = '1994-09-21' \nAND T2.l_shipdate = '1994-11-19'"
        ],
        "rule_sql": []
    },
    "7252": {
        "db_id": "works_cycles",
        "question": "How many departments did Sheela Ward work in between 1/1/2011 to 12/31/2012",
        "ground_truth": "SELECT COUNT(T3.Name) FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.FirstName = 'Sheela' AND T1.LastName = 'Word' AND STRFTIME('%Y', T3.ModifiedDate) BETWEEN '2011' AND '2012'",
        "amends": [
            "Do use `COUNT(T3.Name)` instead of `COUNT(DISTINCT department_id)` to count department names rather than distinct department IDs. Do join `Person AS T1` instead of querying only `employees` table, and add `INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID` and `INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID` instead of no joins. Do filter on `T1.FirstName = 'Sheela' AND T1.LastName = 'Word'` instead of `first_name = 'Sheela' AND last_name = 'Ward'` with corrected last name spelling. Do use `STRFTIME('%Y', T3.ModifiedDate) BETWEEN '2011' AND '2012'` for year-based date filtering instead of `hire_date BETWEEN '2011-01-01' AND '2012-12-31'` with full date range. The amended query now correctly joins multiple tables, uses proper date extraction, and matches the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT department_id) \nFROM employees \nWHERE first_name = 'Sheela' AND last_name = 'Ward' \nAND hire_date BETWEEN '2011-01-01' AND '2012-12-31'",
            "SELECT COUNT(T3.Name) \nFROM Person AS T1\nINNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID\nWHERE T1.FirstName = 'Sheela' AND T1.LastName = 'Ward'\nAND STRFTIME('%Y', T2.StartDate) BETWEEN '2011' AND '2012'"
        ],
        "rule_sql": []
    },
    "1635": {
        "db_id": "car_retails",
        "question": "Which product did Cruz & Sons Co. ask for the biggest amount in a single order?",
        "ground_truth": "SELECT t4.productName FROM orderdetails AS t1 INNER JOIN orders AS t2 ON t1.orderNumber = t2.orderNumber INNER JOIN customers AS t3 ON t2.customerNumber = t3.customerNumber INNER JOIN products AS t4 ON t1.productCode = t4.productCode WHERE t3.customerName = 'Cruz & Sons Co.' ORDER BY t1.priceEach * t1.quantityOrdered DESC LIMIT 1",
        "amends": [
            "Do join `orderdetails`, `orders`, `customers`, and `products` tables instead of querying only `orders`. Do select `productName` instead of `product_name` and `MAX(quantity)`. Do use `INNER JOIN` on `orderNumber` and `customerNumber` instead of no joins. Do filter on `customerName = 'Cruz & Sons Co.'` instead of `company_name = 'Cruz & Sons Co.'`. Do order by `priceEach * quantityOrdered` descending instead of `max_quantity` descending. Do remove `GROUP BY` instead of grouping by `product_name`. The amended query now correctly identifies the highest value product ordered by the specific customer.",
            "Do select only `productName` instead of including `quantityOrdered`, `priceEach`, and `totalAmount`. Do use table aliases `t1`, `t2`, `t3`, and `t4` instead of `od`, `o`, `c`, and `p`. Do calculate the ordering expression directly as `t1.priceEach * t1.quantityOrdered` in the ORDER BY clause instead of using a column alias `totalAmount`. The amended query now correctly returns only the product name with the highest total amount for the specified customer, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, MAX(quantity) as max_quantity\nFROM orders\nWHERE company_name = 'Cruz & Sons Co.'\nGROUP BY product_name\nORDER BY max_quantity DESC\nLIMIT 1;",
            "SELECT p.productName, od.quantityOrdered, od.priceEach, (od.quantityOrdered * od.priceEach) as totalAmount\nFROM orderdetails od\nINNER JOIN orders o ON od.orderNumber = o.orderNumber\nINNER JOIN customers c ON o.customerNumber = c.customerNumber\nINNER JOIN products p ON od.productCode = p.productCode\nWHERE c.customerName = 'Cruz & Sons Co.'\nORDER BY totalAmount DESC\nLIMIT 1;",
            "SELECT p.productName\nFROM orderdetails t1\nINNER JOIN orders t2 ON t1.orderNumber = t2.orderNumber\nINNER JOIN customers t3 ON t2.customerNumber = t3.customerNumber\nINNER JOIN products p ON t1.productCode = p.productCode\nWHERE t3.customerName = 'Cruz & Sons Co.'\nORDER BY t1.priceEach * t1.quantityOrdered DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5116": {
        "db_id": "address",
        "question": "Show the zip code of the county represented by Buchanan Vernon.",
        "ground_truth": "SELECT T2.zip_code FROM congress AS T1 INNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district WHERE T1.first_name = 'Buchanan' AND T1.last_name = 'Vernon'",
        "amends": [
            "Do select `T2.zip_code` from the `zip_congress` table instead of `zip_code` from the `counties` table. Do join `congress AS T1` with `zip_congress AS T2` using `INNER JOIN` on `T1.congress_rep_id = T2.district` instead of querying only the `counties` table. Do filter with `T1.first_name = 'Buchanan' AND T1.last_name = 'Vernon'` instead of `representative = 'Buchanan Vernon'` to properly match the representative's first and last name in separate columns. The amended query now correctly retrieves zip codes associated with the congressional district of representative Buchanan Vernon by joining the appropriate tables and using proper name filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code FROM counties WHERE representative = 'Buchanan Vernon';",
            "SELECT T2.zip_code\nFROM congress AS T1\nINNER JOIN zip_congress AS T2 ON T1.cognress_rep_id = T2.district\nWHERE T1.first_name = 'Buchanan' AND T1.last_name = 'Vernon';"
        ],
        "rule_sql": []
    },
    "8050": {
        "db_id": "university",
        "question": "What is the ID of the Publications Rank criteria?",
        "ground_truth": "SELECT id FROM ranking_criteria WHERE criteria_name = 'Publications Rank'",
        "amends": [
            "Do reference table `ranking_criteria` instead of `criteria`. Do use column `criteria_name` for filtering instead of `name`. The amended query now correctly retrieves the ID from the appropriate table using the correct column name for filtering, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM criteria WHERE name = 'Publications Rank';",
            "SELECT id FROM ranking_criteria WHERE criteria_name = 'Publications Rank';"
        ],
        "rule_sql": []
    },
    "2004": {
        "db_id": "soccer_2016",
        "question": "What is the city name of country ID 3?",
        "ground_truth": "SELECT City_Name FROM City WHERE Country_ID = 3",
        "amends": [
            "Do reference the `City_Name` column instead of `city` and use the `City` table instead of `countries`. Do filter on `Country_ID` instead of `country_id` while maintaining the same filter value of 3. The amended query now correctly selects city names from the appropriate table with the proper column and filter names, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM countries WHERE country_id = 3;",
            "SELECT City_Name FROM City WHERE Country_Id = 3;"
        ],
        "rule_sql": []
    },
    "9315": {
        "db_id": "movie_3",
        "question": "List the top 5 most-rented films.",
        "ground_truth": "SELECT T.title FROM ( SELECT T3.title, COUNT(T2.inventory_id) AS num FROM rental AS T1 INNER JOIN inventory AS T2 ON T1.inventory_id = T2.inventory_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id GROUP BY T3.title ) AS T ORDER BY T.num DESC LIMIT 5",
        "amends": [
            "Do join `rental` and `inventory` on `inventory_id` instead of omitting these tables entirely. Do join `film` through `inventory.film_id` instead of querying `film` table directly without rental context. Do aggregate `COUNT(T2.inventory_id)` instead of `COUNT(*)` to count actual rentals. Do group by `T3.title` instead of `film_id, title` to ensure proper title-based counting. Do use a subquery to encapsulate the aggregation before ordering instead of applying `ORDER BY` directly on the grouped results. The amended query now correctly identifies the most rented films by joining rental records with inventory and film data, counting actual rental occurrences per film title.",
            "Do use `T3.title` in the outer SELECT instead of selecting both `title` and `rental_count` from the subquery. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins. Do alias the subquery as `T` instead of `film_rentals` and reference `T.num` in the ORDER BY instead of `rental_count`. Do remove the explicit column alias `rental_count` from the subquery and use `num` instead. The amended query now correctly returns only the film titles while maintaining the same ranking logic based on rental counts."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT film_id, title, COUNT(*) as rental_count FROM film GROUP BY film_id, title ORDER BY rental_count DESC LIMIT 5;",
            "SELECT title, rental_count\nFROM (\n    SELECT f.title, COUNT(r.inventory_id) AS rental_count\n    FROM rental r\n    JOIN inventory i ON r.inventory_id = i.inventory_id\n    JOIN film f ON i.film_id = f.film_id\n    GROUP BY f.title\n) AS film_rentals\nORDER BY rental_count DESC\nLIMIT 5",
            "SELECT T.title\nFROM (\n    SELECT T3.title, COUNT(T2.inventory_id) AS num\n    FROM rental T1\n    INNER JOIN inventory T2 ON T1.inventory_id = T2.inventory_id\n    INNER JOIN film T3 ON T2.film_id = T3.film_id\n    GROUP BY T3.title\n) T\nORDER BY T.num DESC\nLIMIT 5"
        ],
        "rule_sql": []
    },
    "5859": {
        "db_id": "airline",
        "question": "How many flights depart to Hartsfield-Jackson Atlanta International from Chicago O'Hare International?",
        "ground_truth": "SELECT COUNT(FL_DATE) FROM Airlines WHERE ORIGIN = ( SELECT T2.ORIGIN FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T1.Description = 'Chicago, IL: Chicago O''Hare International' ) AND DEST = ( SELECT T4.DEST FROM Airports AS T3 INNER JOIN Airlines AS T4 ON T3.Code = T4.DEST WHERE T3.Description = 'Atlanta, GA: Hartsfield-Jackson Atlanta International' )",
        "amends": [
            "Do use `COUNT(FL_DATE)` instead of `COUNT(*)` to count specific flight dates rather than all rows. Do query from the `Airlines` table instead of `flights` to access the correct flight data schema. Do replace direct string comparisons with subqueries that join `Airports` to `Airlines` on airport codes instead of hardcoded origin and destination names. Do use `ORIGIN` and `DEST` column names instead of `origin` and `destination` to match the actual schema. Do add proper table aliases `T1`, `T2`, `T3`, and `T4` instead of no aliases to distinguish between the airport and airline tables in the subqueries. Do use `INNER JOIN` operations with `ON T1.Code = T2.ORIGIN` and `ON T3.Code = T4.DEST` instead of simple WHERE conditions to properly relate airports to their corresponding flight records. Do reference airport descriptions with complete location prefixes like 'Chicago, IL: Chicago O''Hare International' instead of partial airport names to ensure accurate matching. The amended query now correctly counts flights between the specified airports by properly joining airport metadata with flight records."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE origin = 'Chicago O\\'Hare International' AND destination = 'Hartsfield-Jackson Atlanta International';",
            "SELECT COUNT(FL_DATE) \nFROM Airlines\nWHERE ORIGIN IN (\n    SELECT Code \n    FROM Airports \n    WHERE Description = 'Chicago, IL: Chicago O''Hare International'\n) \nAND DEST IN (\n    SELECT Code \n    FROM Airports \n    WHERE Description = 'Atlanta, GA: Hartsfield-Jackson Atlanta International'\n)"
        ],
        "rule_sql": []
    },
    "4256": {
        "db_id": "simpson_episodes",
        "question": "Who is the recipient of the Primetime Emmy Award with the most votes?",
        "ground_truth": "SELECT T1.person FROM Award AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.award_category = 'Primetime Emmy' ORDER BY T2.votes DESC LIMIT 1;",
        "amends": [
            "Do select `T1.person` instead of `recipient` and add `FROM Award AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id` instead of just `FROM emmy_awards`. Do add `WHERE T1.award_category = 'Primetime Emmy'` instead of omitting this filter. Do order by `T2.votes DESC` instead of `votes DESC` while maintaining the same `LIMIT 1`. The amended query now correctly joins the Award and Vote tables with proper filtering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT recipient FROM emmy_awards ORDER BY votes DESC LIMIT 1;",
            "SELECT T1.person\nFROM Award AS T1\nINNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.award_category = 'Primetime Emmy'\nORDER BY T2.votes DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5421": {
        "db_id": "sales",
        "question": "Among the customers whose first name is Cameron, who bought the product in the most quantity?",
        "ground_truth": "SELECT T1.FirstName, T1.LastName FROM Customers AS T1 INNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.FirstName = 'Cameron' ORDER BY T2.Quantity DESC LIMIT 1",
        "amends": [
            "Do select `T1.FirstName` and `T1.LastName` instead of `c.first_name`, `c.last_name`, and `SUM(oi.quantity)` with aggregation. Do use `Customers AS T1` instead of `customers c` and `Sales AS T2` instead of `orders o` and `order_items oi`. Do perform `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of joining through multiple tables with `c.customer_id = o.customer_id` and `o.order_id = oi.order_id`. Do keep the `WHERE T1.FirstName = 'Cameron'` filter instead of `c.first_name = 'Cameron'`. Do remove `GROUP BY` and aggregation instead of grouping by `c.customer_id`. Do order by `T2.Quantity DESC` instead of `total_quantity DESC` while keeping the `LIMIT 1`. The amended query now correctly retrieves Cameron's sales records from the Sales table instead of aggregating order items quantities."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name, SUM(oi.quantity) as total_quantity\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN order_items oi ON o.order_id = oi.order_id\nWHERE c.first_name = 'Cameron'\nGROUP BY c.customer_id\nORDER BY total_quantity DESC\nLIMIT 1;",
            "SELECT T1.FirstName, T1.LastName\nFROM Customers AS T1\nINNER JOIN Sales AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.FirstName = 'Cameron'\nORDER BY T2.Quantity DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4271": {
        "db_id": "simpson_episodes",
        "question": "How many people were considered as prospective recipients of the \"Animation\" award?",
        "ground_truth": "SELECT COUNT(*) FROM Award WHERE award = 'Animation' AND result = 'Nominee';",
        "amends": [
            "Do reference the `Award` table instead of the `recipients` table. Do add the filter `result = 'Nominee'` instead of omitting it, and do change the filter condition to `award = 'Animation'` instead of `award_category = 'Animation'`. The amended query now correctly counts Animation nominees from the Award table with proper filtering criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM recipients WHERE award_category = 'Animation';",
            "SELECT COUNT(DISTINCT person) FROM Award WHERE award = 'Animation' AND result = 'Nominee'"
        ],
        "rule_sql": []
    },
    "9220": {
        "db_id": "movie_3",
        "question": "Describe the full names and cities of the customers who rented \"DREAM PICKUP\".",
        "ground_truth": "SELECT T4.first_name, T4.last_name, T6.city FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN customer AS T4 ON T3.customer_id = T4.customer_id INNER JOIN address AS T5 ON T4.address_id = T5.address_id INNER JOIN city AS T6 ON T5.city_id = T6.city_id WHERE T1.title = 'DREAM PICKUP'",
        "amends": [
            "Do add table joins through `film AS T1`, `inventory AS T2`, `rental AS T3`, `customer AS T4`, `address AS T5`, and `city AS T6` instead of querying only `customers`. Do use `T1.title = 'DREAM PICKUP'` instead of `rental_title = 'DREAM PICKUP'` since the title filter belongs on the film table. Do select `T6.city` instead of just `city` to properly reference the joined city table. Do specify full table aliases for all columns (`T4.first_name`, `T4.last_name`) instead of unqualified column names. The amended query now correctly joins through the film inventory and rental relationships to find customers who rented the specific film, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, city FROM customers WHERE rental_title = 'DREAM PICKUP'",
            "SELECT T4.first_name, T4.last_name, T6.city\nFROM film AS T1\nJOIN inventory AS T2 ON T1.film_id = T2.film_id\nJOIN rental AS T3 ON T2.inventory_id = T3.inventory_id\nJOIN customer AS T4 ON T3.customer_id = T4.customer_id\nJOIN address AS T5 ON T4.address_id = T5.address_id\nJOIN city AS T6 ON T5.city_id = T6.city_id\nWHERE T1.title = 'DREAM PICKUP'"
        ],
        "rule_sql": []
    },
    "3604": {
        "db_id": "authors",
        "question": "What is the average number of papers published in the World Computer Congress each year?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id) AS Div1, T1.Year FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id GROUP BY T1.YEAR HAVING Div1 != 0",
        "amends": [
            "Do use `SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END)` instead of `AVG(papers)` for conditional counting. Do add `T1.Year` to the SELECT list instead of omitting it. Do change the FROM source to `Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id` instead of `conference` with a simple filter. Do remove the WHERE clause and instead use a CASE expression within the aggregate. Do add a HAVING clause with `Div1 != 0` instead of omitting it to filter out zero-division cases. Do include a CAST to REAL for the division operation instead of performing integer division. The amended query now correctly calculates the ratio of papers from a specific journal series while avoiding division by zero.",
            "Do reference `Journal` instead of `Conference` as the joined table. Do join on `T1.JournalId = T2.Id` instead of `T1.ConferenceId = T2.Id`. Do check for `'International Congress Series'` instead of `'World Computer Congress'` in the CASE condition. Do use `COUNT(T1.Id)` instead of `COUNT(*)` in the division denominator. Do rename the result column as `Div1` instead of `avg_papers`. Do move the `T1.Year` column to the SELECT list instead of placing it first. Do filter with `HAVING Div1 != 0` instead of `HAVING COUNT(*) != 0`. The amended query now correctly calculates the ratio of papers from International Congress Series journals per year while excluding years with zero ratio.",
            "Do move `T1.Year` to the SELECT list instead of placing it first in the column order. Do keep the same aggregate calculation with `SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END)` divided by `COUNT(T1.Id)` as `Div1`. Do maintain the same `INNER JOIN` between `Paper AS T1` and `Journal AS T2` on `T1.JournalId = T2.Id`. Do preserve the `GROUP BY T1.Year` grouping. Do retain the `HAVING Div1 != 0` filter to exclude zero division results. The amended query now matches RIGHT_SQL's behavior with identical logic and output.",
            "Do place `T1.Year` in the SELECT list after the division expression instead of before it. Do keep the same `INNER JOIN` on `T1.JournalId = T2.Id` and maintain the identical aggregate calculation with `SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END)` divided by `COUNT(T1.Id)`. Do preserve the `GROUP BY T1.Year` and `HAVING Div1 != 0` clauses unchanged. The amended query now matches RIGHT_SQL's behavior with the correct column ordering.",
            "Do move `T1.Year` to the SELECT list instead of placing it first in the column order. Do keep the same aggregate calculation with `SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END)` divided by `COUNT(T1.Id)` as `Div1`. Do maintain the same `INNER JOIN` between `Paper AS T1` and `Journal AS T2` on `T1.JournalId = T2.Id`. Do preserve the `GROUP BY T1.Year` grouping. Do retain the `HAVING Div1 != 0` filter condition. The amended query now matches RIGHT_SQL's behavior with identical logic and output."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(papers) FROM conference WHERE name = 'World Computer Congress' GROUP BY year;",
            "SELECT T1.Year, \n       CAST(SUM(CASE WHEN T2.FullName = 'World Computer Congress' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS avg_papers\nFROM Paper AS T1 \nINNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id\nGROUP BY T1.Year\nHAVING COUNT(*) != 0;",
            "SELECT \n    T1.Year,\n    CAST(SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id) AS Div1\nFROM \n    Paper AS T1 \n    INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id\nGROUP BY \n    T1.Year\nHAVING \n    Div1 != 0",
            "SELECT \n    T1.Year,\n    CAST(SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id) AS Div1\nFROM \n    Paper AS T1 \nINNER JOIN \n    Journal AS T2 ON T1.JournalId = T2.Id\nGROUP BY \n    T1.Year\nHAVING \n    Div1 != 0",
            "SELECT \n    T1.Year,\n    CAST(SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id) AS Div1\nFROM \n    Paper AS T1 \n    INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id\nGROUP BY \n    T1.Year\nHAVING \n    Div1 != 0",
            "SELECT \n    CAST(SUM(CASE WHEN T2.FullName = 'International Congress Series' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.Id) AS Div1,\n    T1.Year\nFROM \n    Paper AS T1 \n    INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id\nGROUP BY \n    T1.Year\nHAVING \n    Div1 != 0"
        ],
        "rule_sql": []
    },
    "4090": {
        "db_id": "public_review_platform",
        "question": "Sum up the likes get by short reviews on businesses located in City Goodyear.",
        "ground_truth": "SELECT SUM(T2.likes) AS likes FROM Business AS T1 INNER JOIN Tips AS T2 ON T1.business_id = T2.business_id WHERE T1.city = 'Goodyear'",
        "amends": [
            "Do specify the full table reference `T2.likes` with an alias `AS likes` instead of using just `likes` without qualification. Do join `Business AS T1` with `Tips AS T2` on `T1.business_id = T2.business_id` instead of querying only the `reviews` table. Do filter on `T1.city = 'Goodyear'` instead of `city = 'Goodyear'` to reference the correct table. Do remove the unnecessary `review_type = 'short'` filter instead of keeping it, as the right query aggregates all tips regardless of type. The amended query now correctly joins business and tips data to sum likes for businesses in Goodyear, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(likes) FROM reviews WHERE city = 'Goodyear' AND review_type = 'short';",
            "SELECT SUM(T2.likes) AS total_likes\nFROM Business AS T1\nJOIN Tips AS T2 ON T1.business_id = T2.business_id\nWHERE T1.city = 'Goodyear'"
        ],
        "rule_sql": []
    },
    "8761": {
        "db_id": "chicago_crime",
        "question": "Among the crimes in the ward with the most population, how many of them are cases of domestic violence?",
        "ground_truth": "SELECT COUNT(T1.ward_no) AS num FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.domestic = 'TRUE' ORDER BY T1.Population = ( SELECT Population FROM Ward ORDER BY Population DESC LIMIT 1 )",
        "amends": [
            "Do use explicit column selection `COUNT(T1.ward_no)` with alias `num` instead of `COUNT(*)` without alias. Do join tables `Ward AS T1 INNER JOIN Crime AS T2` instead of querying only `crimes` table. Do use join condition `T1.ward_no = T2.ward_no` instead of subquery correlation. Do filter with `T2.domestic = 'TRUE'` instead of `crime_type = 'domestic violence'`. Do add `ORDER BY T1.Population = (subquery)` instead of omitting ordering. Do use subquery `SELECT Population FROM Ward ORDER BY Population DESC LIMIT 1` for comparison instead of `SELECT ward_id FROM wards ORDER BY population DESC LIMIT 1` in WHERE clause. The amended query now correctly joins Ward and Crime tables to count domestic crimes in the most populous ward.",
            "Do remove the redundant WHERE clause filtering on `T1.Population = subquery` instead of keeping it, as the population filter is already handled in the ORDER BY clause. Do change the COUNT expression to use `T1.ward_no` instead of `T2.ward_no` to ensure accurate counting from the Ward table. Do keep the INNER JOIN on `T1.ward_no = T2.ward_no` and maintain the domestic filter `T2.domestic = 'TRUE'` as well as the ORDER BY clause using the population subquery. The amended query now correctly counts crimes in wards with domestic incidents while ordering by population, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM crimes \nWHERE crime_type = 'domestic violence' \nAND ward_id = (SELECT ward_id FROM wards ORDER BY population DESC LIMIT 1);",
            "SELECT COUNT(T2.ward_no) AS num\nFROM Ward AS T1\nINNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no\nWHERE T1.Population = (SELECT Population FROM Ward ORDER BY Population DESC LIMIT 1)\nAND T2.domestic = 'TRUE'\nORDER BY T1.Population = (SELECT Population FROM Ward ORDER BY Population DESC LIMIT 1);",
            "SELECT COUNT(T1.ward_no) AS num\nFROM Ward AS T1\nINNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no\nWHERE T2.domestic = 'TRUE'\nORDER BY T1.Population = (SELECT Population FROM Ward ORDER BY Population DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "8376": {
        "db_id": "mondial_geo",
        "question": "What's the name of the second biggest desert?",
        "ground_truth": "SELECT Name FROM desert ORDER BY Area DESC LIMIT 1, 1",
        "amends": [
            "Do reference table `desert` instead of `deserts` to use the correct table name. Do use column `Name` instead of `name` to match the proper column casing. Do use `Area` instead of `area` for the ORDER BY clause to maintain consistent column naming. Do use `LIMIT 1, 1` syntax instead of `LIMIT 1 OFFSET 1` to achieve the same second row result with more concise MySQL syntax. The amended query now correctly retrieves the second largest desert by area from the proper table with consistent column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM deserts ORDER BY area DESC LIMIT 1 OFFSET 1;",
            "SELECT Name FROM desert ORDER BY Area DESC LIMIT 1 OFFSET 1;"
        ],
        "rule_sql": []
    },
    "1693": {
        "db_id": "restaurant",
        "question": "On what street in Tuolumne County is Good Heavens restaurant located?",
        "ground_truth": "SELECT T1.street_name FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant INNER JOIN geographic AS T3 ON T2.city = T3.city WHERE T2.label = 'good heavens' AND T3.county = 'tuolumne county'",
        "amends": [
            "Do select `T1.street_name` instead of `street` and use proper table aliasing. Do add `INNER JOIN generalinfo AS T2` and `INNER JOIN geographic AS T3` instead of querying a single table. Do join on `T1.id_restaurant = T2.id_restaurant` and `T2.city = T3.city` instead of no joins. Do filter on `T2.label = 'good heavens'` instead of `name = 'Good Heavens'` with proper case handling. Do filter on `T3.county = 'tuolumne county'` instead of `county = 'Tuolumne'` with full county name. The amended query now correctly joins across multiple tables to retrieve the street address while matching the intended filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street FROM restaurants WHERE county = 'Tuolumne' AND name = 'Good Heavens';",
            "SELECT T1.street_name \nFROM location AS T1\nINNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant\nINNER JOIN geographic AS T3 ON T2.city = T3.city\nWHERE T2.label = 'good heavens' \nAND T3.county = 'tuolumne county'"
        ],
        "rule_sql": []
    },
    "8599": {
        "db_id": "chicago_crime",
        "question": "How many crimes had happened in the community area with the most population?",
        "ground_truth": "SELECT COUNT(T2.report_no) FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no GROUP BY T1.community_area_name ORDER BY T1.population DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(T2.report_no)` instead of `COUNT(*)` to count specific crime records. Do add `GROUP BY T1.community_area_name` instead of omitting it to aggregate counts per community area. Do use `INNER JOIN` on `T1.community_area_no = T2.community_area_no` instead of `JOIN` on `c.community_area_id = ca.id` with corrected join condition and column references. Do remove the `ORDER BY ca.population DESC LIMIT 1` from the main query instead of keeping it, as the grouping and ordering logic is now properly handled. The amended query now correctly counts crimes per community area and matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes c JOIN community_areas ca ON c.community_area_id = ca.id ORDER BY ca.population DESC LIMIT 1;",
            "SELECT COUNT(T2.report_no) AS crime_count\nFROM Community_Area T1\nINNER JOIN Crime T2 ON T1.community_area_no = T2.community_area_no\nWHERE T1.population = (SELECT MAX(population) FROM Community_Area)\nGROUP BY T1.community_area_name"
        ],
        "rule_sql": []
    },
    "8741": {
        "db_id": "chicago_crime",
        "question": "Please name three communities that experience the fraud incident.",
        "ground_truth": "SELECT T3.community_area_name FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no INNER JOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no WHERE T1.title = 'Criminal Sexual Assault' LIMIT 3",
        "amends": [
            "Do select `T3.community_area_name` from `Community_Area` instead of `community_name` from `fraud_incidents`. Do add `INNER JOIN` on `FBI_Code` with predicate `T1.fbi_code_no = T2.fbi_code_no` instead of omitting this table and join. Do add `INNER JOIN` on `Community_Area` with predicate `T2.community_area_no = T3.community_area_no` instead of omitting this table and join. Do add `WHERE` filter `T1.title = 'Criminal Sexual Assault'` instead of omitting this condition. The amended query now correctly retrieves community area names for criminal sexual assault incidents instead of fraud incidents."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_name FROM fraud_incidents LIMIT 3;",
            "SELECT T3.community_area_name\nFROM Crime T1\nINNER JOIN FBI_Code T2 ON T1.fbi_code_no = T2.fbi_code_no\nINNER JOIN Community_Area T3 ON T1.community_area_no = T3.community_area_no\nWHERE T2.title = 'Criminal Sexual Assault'\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "7153": {
        "db_id": "works_cycles",
        "question": "What is the product ID No.793's model name?",
        "ground_truth": "SELECT T1.Name FROM Product AS T1 INNER JOIN ProductModel AS T2 ON T1.ProductModelID = T2.ProductModelID WHERE T1.ProductID = 793",
        "amends": [
            "Do add `INNER JOIN ProductModel AS T2 ON T1.ProductModelID = T2.ProductModelID` instead of querying only the `products` table. Do change the table reference to `Product AS T1` instead of `products`. Do specify `T1.Name` instead of `product_name` in the SELECT list. Do use `T1.ProductID = 793` instead of `product_id = 793` in the WHERE clause. The amended query now correctly joins the Product and ProductModel tables to retrieve the product name while matching the RIGHT_SQL's behavior.",
            "Do select `T1.Name` from the `Product` table instead of `T2.Name` from the `ProductModel` table, as the product name should be retrieved from the Product table where the ProductID filter is applied rather than from the joined ProductModel table. The join condition using `T1.ProductModelID = T2.ProductModelID` and the WHERE filter on `T1.ProductID = 793` remain unchanged. The amended query now correctly retrieves the product name from the appropriate table source while maintaining the same join logic and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE product_id = 793;",
            "SELECT T2.Name \nFROM Product AS T1 \nINNER JOIN ProductModel AS T2 ON T1.ProductModelID = T2.ProductModelID \nWHERE T1.ProductID = 793",
            "SELECT T1.Name \nFROM Product AS T1 \nINNER JOIN ProductModel AS T2 ON T1.ProductModelID = T2.ProductModelID \nWHERE T1.ProductID = 793"
        ],
        "rule_sql": []
    },
    "3675": {
        "db_id": "authors",
        "question": "List out the full name and URL link of ICCI?",
        "ground_truth": "SELECT FullName, HomePage FROM Conference WHERE ShortName = 'ICCI'",
        "amends": [
            "Do select `FullName` and `HomePage` instead of `name` and `url`. Do filter on `ShortName = 'ICCI'` instead of `id = 1`. Do query from `Conference` table instead of `icci` table. The amended query now correctly retrieves conference details by matching the short name rather than using an incorrect table reference and numeric ID filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, url FROM icci WHERE id = 1;",
            "SELECT FullName, HomePage FROM Conference WHERE ShortName = 'ICCI';"
        ],
        "rule_sql": []
    },
    "4133": {
        "db_id": "public_review_platform",
        "question": "List the categories of active businesses in Glendale, AZ.",
        "ground_truth": "SELECT DISTINCT T3.category_name FROM Business_Categories AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T1.category_id = T3.category_id WHERE T2.active = 'true' AND T2.state = 'AZ' AND T2.city = 'Glendale'",
        "amends": [
            "Do select `T3.category_name` instead of `category` and add `DISTINCT` instead of omitting it. Do use `Business_Categories AS T1` instead of `businesses` and add `INNER JOIN Business AS T2 ON T1.business_id = T2.business_id` instead of omitting it, then add `INNER JOIN Categories AS T3 ON T1.category_id = T3.category_id` instead of omitting it. Do change filter `T2.active = 'true'` instead of `active = 'yes'` while keeping `T2.state = 'AZ'` and `T2.city = 'Glendale'` instead of `state = 'AZ'` and `city = 'Glendale'`. The amended query now correctly joins multiple tables to retrieve category names from the proper relationships and uses appropriate boolean value syntax."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM businesses WHERE city = 'Glendale' AND state = 'AZ' AND active = 'yes'",
            "SELECT DISTINCT T3.category_name\nFROM Business_Categories AS T1\nINNER JOIN Business AS T2 ON T1.business_id = T2.business_id\nINNER JOIN Categories AS T3 ON T1.category_id = T3.category_id\nWHERE T2.active = 'true'\nAND T2.city = 'Glendale'\nAND T2.state = 'AZ'"
        ],
        "rule_sql": []
    },
    "337": {
        "db_id": "retail_complains",
        "question": "What is the name of the state that the client with the email \"skylar.ramirez@gmail.com\" lives in?",
        "ground_truth": "SELECT T3.state FROM state AS T1 INNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev INNER JOIN client AS T3 ON T2.district_id = T3.district_id WHERE T3.email = 'skylar.ramirez@gmail.com'",
        "amends": [
            "Do select `T3.state` from joined tables instead of `state` directly from a single table. Do add `INNER JOIN state AS T1` and `INNER JOIN district AS T2` with join conditions `ON T1.StateCode = T2.state_abbrev` instead of omitting these table relationships. Do add `INNER JOIN client AS T3` with join condition `ON T2.district_id = T3.district_id` instead of querying `clients` table directly. Do filter on `T3.email` instead of `email` to reference the correct table after joining. The amended query now correctly retrieves state information through proper table relationships and matches RIGHT_SQL's behavior.",
            "Do select `T3.state` instead of `T1.State` in the SELECT list to correctly reference the state column from the client table rather than the state table. End with confirmation that the amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM clients WHERE email = 'skylar.ramirez@gmail.com';",
            "SELECT T1.State\nFROM state AS T1\nINNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev\nINNER JOIN client AS T3 ON T2.district_id = T3.district_id\nWHERE T3.email = 'skylar.ramirez@gmail.com'",
            "SELECT T3.state\nFROM state AS T1\nINNER JOIN district AS T2 ON T1.StateCode = T2.state_abbrev\nINNER JOIN client AS T3 ON T2.district_id = T3.district_id\nWHERE T3.email = 'skylar.ramirez@gmail.com'"
        ],
        "rule_sql": []
    },
    "8372": {
        "db_id": "mondial_geo",
        "question": "What are the names of the cities along the Euphrat River's course? Indicate the capital city of the nation where the Euphrat River flows.",
        "ground_truth": "SELECT T2.City, T1.Capital FROM country AS T1 INNER JOIN located AS T2 ON T1.Code = T2.Country INNER JOIN river AS T3 ON T3.Name = T2.River WHERE T3.Name = 'Euphrat'",
        "amends": [
            "Do use explicit table aliases `T1.Capital` and `T2.City` instead of generic column names `city_name` and `capital_status`. Do join three tables `country AS T1`, `located AS T2`, and `river AS T3` instead of querying a single table. Do use `INNER JOIN` with `T1.Code = T2.Country` and `T3.Name = T2.River` instead of simple column references. Do filter on `T3.Name = 'Euphrat'` instead of `river_name = 'Euphrat'`. Do remove the `ORDER BY river_position` clause instead of keeping it. The amended query now correctly joins relational data across multiple tables to find cities on the Euphrates river with their capital status.",
            "Do include both `T2.City` and `T1.Capital` columns in the SELECT list instead of using a CASE expression to derive `capital_status`. Do remove the CASE expression that checks `T2.City = T1.Capital` instead of keeping it, as the RIGHT_SQL directly returns both columns without transformation. The FROM clause with `INNER JOIN` between `country` and `located` on `T1.Code = T2.Country` remains unchanged, as does the second `INNER JOIN` to `river` on `T3.Name = T2.River` and the WHERE filter on `T3.Name = 'Euphrat'`. The amended query now matches RIGHT_SQL's behavior by returning the raw city and capital data rather than a derived status field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city_name, capital_status FROM cities WHERE river_name = 'Euphrat' ORDER BY river_position;",
            "SELECT T2.City, \n       CASE WHEN T2.City = T1.Capital THEN 'Capital' ELSE 'Not Capital' END AS capital_status\nFROM country AS T1\nINNER JOIN located AS T2 ON T1.Code = T2.Country\nINNER JOIN river AS T3 ON T3.Name = T2.River\nWHERE T3.Name = 'Euphrat'",
            "SELECT T2.City, T1.Capital\nFROM country AS T1\nINNER JOIN located AS T2 ON T1.Code = T2.Country\nINNER JOIN river AS T3 ON T3.Name = T2.River\nWHERE T3.Name = 'Euphrat'"
        ],
        "rule_sql": []
    },
    "8791": {
        "db_id": "food_inspection",
        "question": "Give the name of the business which met all the required standards during the unscheduled routine inspection on 2016/9/28.",
        "ground_truth": "SELECT T2.name FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100 AND T1.`date` = '2016-09-28' AND T1.type = 'Routine - Unscheduled'",
        "amends": [
            "Do select `T2.name` from the joined table instead of `name` directly from businesses. Do join `inspections AS T1` with `businesses AS T2` using `INNER JOIN` on `T1.business_id = T2.business_id` instead of querying only the businesses table. Do filter on `T1.score = 100` instead of `standards_met = 'all'`. Do use date format `'2016-09-28'` with hyphens instead of `'2016/9/28'` with slashes. Do filter on `T1.type = 'Routine - Unscheduled'` instead of `inspection_type = 'unscheduled routine'`. The amended query now correctly joins inspection records with business data and uses proper date formatting and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM businesses WHERE inspection_date = '2016/9/28' AND inspection_type = 'unscheduled routine' AND standards_met = 'all';",
            "SELECT T2.name \nFROM inspections AS T1 \nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id \nWHERE T1.score = 100 \nAND T1.date = '2016-09-28' \nAND T1.type = 'Routine - Unscheduled'"
        ],
        "rule_sql": []
    },
    "6057": {
        "db_id": "books",
        "question": "Provide the International Standard Book Number of the book The Mystery in the Rocky Mountains.",
        "ground_truth": "SELECT isbn13 FROM book WHERE title = 'The Mystery in the Rocky Mountains'",
        "amends": [
            "Do select `isbn13` instead of `isbn` to retrieve the correct ISBN format. Do reference table `book` instead of `books` to use the proper table name. The amended query now correctly retrieves the 13-digit ISBN from the appropriate book table while maintaining the same title filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT isbn FROM books WHERE title = 'The Mystery in the Rocky Mountains';",
            "SELECT isbn13 FROM book WHERE title = 'The Mystery in the Rocky Mountains';"
        ],
        "rule_sql": []
    },
    "7632": {
        "db_id": "hockey",
        "question": "State the nick name of the tallest player? If the player had left NHL, mention the last season he was with NHL.",
        "ground_truth": "SELECT nameNick, lastNHL FROM Master ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select `nameNick` and `lastNHL` instead of `nickname` and `last_season`. Do query from `Master` table instead of `players` table. Do remove the `WHERE` clause with subquery and `left_nhl` filter instead of keeping them. Do add `ORDER BY height DESC` and `LIMIT 1` instead of using a subquery to find maximum height. Do remove the `AND left_nhl = 1` condition instead of including it. The amended query now correctly retrieves the tallest player's details from the Master table using efficient ordering and limiting instead of complex subqueries and incorrect filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nickname, last_season \nFROM players \nWHERE height = (SELECT MAX(height) FROM players) \nAND left_nhl = 1;",
            "SELECT nameNick, lastNHL FROM Master ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8760": {
        "db_id": "chicago_crime",
        "question": "Which alderman represents the ward with the most number of crimes in January, 2018? Please give his or her full name.",
        "ground_truth": "SELECT T1.ward_no, T1.alderman_first_name, T1.alderman_last_name, T1.alderman_name_suffix FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018' GROUP BY T1.ward_no ORDER BY COUNT(T1.ward_no) DESC LIMIT 1",
        "amends": [
            "Do select `T1.ward_no`, `T1.alderman_first_name`, `T1.alderman_last_name`, and `T1.alderman_name_suffix` instead of just `alderman_name`. Do join `Ward AS T1` with `Crime AS T2` using `INNER JOIN` on `T1.ward_no = T2.ward_no` instead of querying only the `crimes` table. Do use `SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018'` for date filtering instead of `date LIKE '2018-01%'`. Do group by `T1.ward_no` instead of `ward`. Do order by `COUNT(T1.ward_no)` instead of `COUNT(*)`. The amended query now correctly joins ward information with crime data and uses proper date extraction to filter January 2018 crimes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT alderman_name FROM crimes WHERE date LIKE '2018-01%' GROUP BY ward ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT T1.ward_no, T1.alderman_first_name, T1.alderman_last_name, T1.alderman_name_suffix\nFROM Ward AS T1\nINNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no\nWHERE SUBSTR(T2.date, 1, 1) = '1' AND SUBSTR(T2.date, 5, 4) = '2018'\nGROUP BY T1.ward_no\nORDER BY COUNT(T1.ward_no) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4962": {
        "db_id": "olympics",
        "question": "What is the name of the oldest person who participated in the Olympic Games?",
        "ground_truth": "SELECT T1.full_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id ORDER BY T2.age DESC LIMIT 1",
        "amends": [
            "Do select `full_name` from the `person` table instead of `name` from `athletes`. Do join `games_competitor` using `INNER JOIN` on `person.id = games_competitor.person_id` instead of querying a single table. Do order by `age` from the joined `games_competitor` table instead of from the original table. The amended query now correctly retrieves the competitor's full name with their age from the appropriate joined tables, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM athletes ORDER BY age DESC LIMIT 1;",
            "SELECT p.full_name\nFROM person p\nINNER JOIN games_competitor gc ON p.id = gc.person_id\nORDER BY gc.age DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6810": {
        "db_id": "retails",
        "question": "Please list any two parts that come with the wrap bag container and have a supply cost of under 10.",
        "ground_truth": "SELECT T1.p_name FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey WHERE T2.ps_supplycost < 10 AND T1.p_container = 'WRAP BAG' LIMIT 2",
        "amends": [
            "Do select `T1.p_name` from the `part` table instead of `part_name` from the `parts` table. Do add an `INNER JOIN` with `partsupp AS T2` on `T1.p_partkey = T2.ps_partkey` instead of querying a single table. Do filter on `T2.ps_supplycost < 10` instead of `supply_cost > 10` with the opposite comparison operator. Do use `T1.p_container = 'WRAP BAG'` instead of `container_type = 'wrap bag'` with different case sensitivity. The amended query now correctly joins the part and partsupp tables to filter by supply cost and container type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT part_name FROM parts WHERE container_type = 'wrap bag' AND supply_cost > 10 LIMIT 2;",
            "SELECT T1.p_name\nFROM part AS T1\nINNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey\nWHERE T1.p_container = 'WRAP BAG'\nAND T2.ps_supplycost < 10\nLIMIT 2"
        ],
        "rule_sql": []
    },
    "7396": {
        "db_id": "works_cycles",
        "question": "What is the average profit of all the low class universal road frames? Indicate how many variety of sizes are there and the available colors.",
        "ground_truth": "SELECT AVG(T1.ListPrice - T1.StandardCost), COUNT(DISTINCT T1.Size) , COUNT(DISTINCT T1.Style) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID WHERE T1.Class = 'L' AND T2.Name = 'Road Frames' GROUP BY T1.Class, T1.Color",
        "amends": [
            "Do calculate `AVG(T1.ListPrice - T1.StandardCost)` instead of `AVG(profit)` to properly compute profit margin from component columns. Do count `COUNT(DISTINCT T1.Style)` instead of `GROUP_CONCAT(DISTINCT color)` to track style varieties rather than concatenating colors. Do join `INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID` instead of querying a single table to properly relate products to their subcategory. Do filter on `T1.Class = 'L'` instead of `class = 'low'` to use the correct class code, and do filter on `T2.Name = 'Road Frames'` instead of `type = 'universal road frame'` to use the proper subcategory name for filtering. Do add `GROUP BY T1.Class, T1.Color` instead of omitting grouping to properly aggregate by these dimensions. The amended query now correctly calculates profit metrics for road frame products with proper table relationships and filtering logic.",
            "Do include `COUNT(DISTINCT T1.Size)` and `COUNT(DISTINCT T1.Style)` in the SELECT list instead of only `COUNT(DISTINCT T1.Style)` and `AVG(T1.ListPrice - T1.StandardCost)`. Do remove the alias `AverageProfit` and `VarietyOfSizes` instead of keeping them. Do maintain the same `FROM` clause with `INNER JOIN` on `T1.ProductSubcategoryID = T2.ProductSubcategoryID` and the same `WHERE` filters on `T1.Class = 'L'` and `T2.Name = 'Road Frames'`. Do keep the same `GROUP BY` on `T1.Class, T1.Color` instead of changing it. The amended query now correctly counts distinct sizes and styles while maintaining the same aggregation behavior.",
            "Do remove the alias `AverageProfit` from the `AVG` expression instead of keeping it. Do remove the aliases `VarietyOfSizes` and `VarietyOfStyles` from the `COUNT` expressions instead of keeping them. Do remove the column `T1.Color` from the SELECT list instead of including it, as it is already part of the GROUP BY clause and should not be selected separately. The amended query now correctly matches the RIGHT_SQL's behavior by focusing only on the aggregate calculations without redundant column selections and aliases."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(profit) as average_profit, COUNT(DISTINCT size) as size_varieties, GROUP_CONCAT(DISTINCT color) as available_colors \nFROM products \nWHERE class = 'low' AND type = 'universal road frame'",
            "SELECT \n    AVG(T1.ListPrice - T1.StandardCost) AS AverageProfit,\n    COUNT(DISTINCT T1.Style) AS VarietyOfSizes,\n    T1.Color\nFROM \n    Product AS T1\nINNER JOIN \n    ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID\nWHERE \n    T1.Class = 'L' \n    AND T2.Name = 'Road Frames'\nGROUP BY \n    T1.Class, T1.Color",
            "SELECT \n    AVG(T1.ListPrice - T1.StandardCost) AS AverageProfit,\n    COUNT(DISTINCT T1.Size) AS VarietyOfSizes,\n    COUNT(DISTINCT T1.Style) AS VarietyOfStyles,\n    T1.Color\nFROM \n    Product AS T1\nINNER JOIN \n    ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID\nWHERE \n    T1.Class = 'L' \n    AND T2.Name = 'Road Frames'\nGROUP BY \n    T1.Class, T1.Color",
            "SELECT AVG(T1.ListPrice - T1.StandardCost), COUNT(DISTINCT T1.Size), COUNT(DISTINCT T1.Style) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID WHERE T1.Class = 'L' AND T2.Name = 'Road Frames' GROUP BY T1.Class, T1.Color;"
        ],
        "rule_sql": []
    },
    "9262": {
        "db_id": "movie_3",
        "question": "How many movies have a length longer than 100?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE length > 100",
        "amends": [
            "Do reference table `film` instead of `movies` and count `film_id` instead of `*` instead of counting all rows. Do filter on `length > 100` instead of `length < 100` to count films longer than 100 minutes rather than shorter ones. The amended query now correctly counts films exceeding 100 minutes in length from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE length < 100;",
            "SELECT COUNT(film_id) FROM film WHERE length > 100;"
        ],
        "rule_sql": []
    },
    "7904": {
        "db_id": "world",
        "question": "List the names of the country that officially uses English as their language.",
        "ground_truth": "SELECT T2.Name FROM CountryLanguage AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.IsOfficial = 'T' AND T1.Language = 'English'",
        "amends": [
            "Do select `T2.Name` from the `Country` table instead of `name` from the `country` table. Do add an `INNER JOIN` between `CountryLanguage AS T1` and `Country AS T2` on `T1.CountryCode = T2.Code` instead of querying a single table. Do add filter conditions `T1.IsOfficial = 'T'` and `T1.Language = 'English'` instead of just `language = 'English'` to ensure only official English languages are returned. The amended query now correctly joins the language and country tables to return country names where English is an official language, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM country WHERE language = 'English';",
            "SELECT T2.Name \nFROM CountryLanguage AS T1 \nINNER JOIN Country AS T2 ON T1.CountryCode = T2.Code \nWHERE T1.IsOfficial = 'T' AND T1.Language = 'English'"
        ],
        "rule_sql": []
    },
    "7086": {
        "db_id": "works_cycles",
        "question": "What is the percentage, by number of sales order units, for orders with quantities not greater than 3 and a discount of 0.2?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN OrderQty < 3 AND UnitPriceDiscount = 0.2 THEN 1 ELSE 0 END) AS REAL) / COUNT(SalesOrderID) FROM SalesOrderDetail",
        "amends": [
            "Do use `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN ... THEN 1 END)` to properly count conditional cases. Do reference `OrderQty` instead of `Quantity` and `UnitPriceDiscount` instead of `Discount` for correct column names. Do use `< 3` comparison instead of `<= 3` for the quantity threshold. Do explicitly cast the result to `REAL` instead of multiplying by `100.0` for proper numeric handling. Do count `SalesOrderID` instead of using `COUNT(*)` for more precise row counting. The amended query now correctly calculates the percentage of orders meeting the specified criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN Quantity <= 3 AND Discount = 0.2 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM SalesOrderDetail;",
            "SELECT \n    (SUM(CASE WHEN sod.OrderQty < 3 AND sod.UnitPriceDiscount = 0.2 THEN 1 ELSE 0 END) * 100.0 / COUNT(sod.SalesOrderID)) AS Percentage\nFROM \n    SalesOrderDetail sod;"
        ],
        "rule_sql": []
    },
    "1912": {
        "db_id": "soccer_2016",
        "question": "How many games were played in March 2010?",
        "ground_truth": "SELECT SUM(CASE WHEN Match_Date LIKE '2010-03%' THEN 1 ELSE 0 END) FROM `Match`",
        "amends": [
            "Do use `SUM(CASE WHEN Match_Date LIKE '2010-03%' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only rows matching the date pattern. Do reference table `Match` instead of `games` as the data source. Do use column `Match_Date` instead of `date` for the date filtering condition. The amended query now correctly counts only matches from March 2010 while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE date LIKE '2010-03%';",
            "SELECT SUM(CASE WHEN Match_Date LIKE '2010-03%' THEN 1 ELSE 0 END) AS games_count FROM Match;"
        ],
        "rule_sql": []
    },
    "5464": {
        "db_id": "sales",
        "question": "Find and list the full name of customers who bought products above-average quantity.",
        "ground_truth": "SELECT T2.FirstName, T2.MiddleInitial, T2.LastName FROM Sales AS T1 INNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Quantity HAVING T1.Quantity > ( SELECT AVG(Quantity) FROM Sales )",
        "amends": [
            "Do select `T2.FirstName`, `T2.MiddleInitial`, and `T2.LastName` instead of `c.first_name` and `c.last_name`. Do use `INNER JOIN` between `Sales AS T1` and `Customers AS T2` on `T1.CustomerID = T2.CustomerID` instead of joining `customers`, `orders`, and `order_items` with different join conditions. Do move the quantity filter to `HAVING T1.Quantity > (SELECT AVG(Quantity) FROM Sales)` instead of using a `WHERE` clause with a subquery on `order_items`. Do group by `T1.Quantity` instead of grouping by `c.customer_id`. Do reference the `Sales` table in the subquery instead of `order_items`. The amended query now correctly filters aggregated results using HAVING and uses the appropriate table relationships to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.first_name, c.last_name \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN order_items oi ON o.order_id = oi.order_id\nWHERE oi.quantity > (SELECT AVG(quantity) FROM order_items)\nGROUP BY c.customer_id;",
            "SELECT T2.FirstName, T2.MiddleInitial, T2.LastName\nFROM Sales AS T1\nINNER JOIN Customers AS T2 ON T1.CustomerID = T2.CustomerID\nGROUP BY T1.Quantity\nHAVING T1.Quantity > (SELECT AVG(Quantity) FROM Sales)"
        ],
        "rule_sql": []
    },
    "1167": {
        "db_id": "talkingdata",
        "question": "How many app users belong to label ID of \"48\"?",
        "ground_truth": "SELECT COUNT(app_id) FROM app_labels WHERE label_id = 48",
        "amends": [
            "Do select `COUNT(app_id)` from the `app_labels` table instead of `COUNT(*)` from the `users` table. Do query the `app_labels` table with filter `label_id = 48` instead of the `users` table with the same filter condition. The amended query now correctly counts app_id values from the appropriate table that contains the label relationship data."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE label_id = 48;",
            "SELECT COUNT(app_id) FROM app_labels WHERE label_id = 48"
        ],
        "rule_sql": []
    },
    "964": {
        "db_id": "cs_semester",
        "question": "List the student's first and last name that got a C in the course named \"Applied Deep Learning\".",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Applied Deep Learning ' AND T2.grade = 'C'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `s`, `g`, and `c`. Do select columns `f_name` and `l_name` instead of `first_name` and `last_name`. Do join table `registration` instead of `grades` and `course` instead of `courses`. Do use join condition `T1.student_id = T2.student_id` instead of `s.student_id = g.student_id` and `T2.course_id = T3.course_id` instead of `g.course_id = c.course_id`. Do filter on column `name` instead of `course_name` and value `'C'` instead of `'A'` for the grade condition. The amended query now correctly reflects the intended logic with proper table relationships and filtering criteria.",
            "Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins. Do add `AS` keyword for table aliases instead of omitting it. Do include a space in the string literal `'Applied Deep Learning '` instead of `'Applied Deep Learning'` to match the expected data format. The amended query now correctly uses explicit join syntax with proper alias formatting and matches the exact string filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.last_name \nFROM students s\nJOIN grades g ON s.student_id = g.student_id\nJOIN courses c ON g.course_id = c.course_id\nWHERE c.course_name = 'Applied Deep Learning' AND g.grade = 'A'",
            "SELECT T1.f_name, T1.l_name\nFROM student T1\nJOIN registration T2 ON T1.student_id = T2.student_id\nJOIN course T3 ON T2.course_id = T3.course_id\nWHERE T3.name = 'Applied Deep Learning' AND T2.grade = 'C'",
            "SELECT T1.f_name, T1.l_name\nFROM student AS T1\nINNER JOIN registration AS T2 ON T1.student_id = T2.student_id\nINNER JOIN course AS T3 ON T2.course_id = T3.course_id\nWHERE T3.name = 'Applied Deep Learning '\nAND T2.grade = 'C';"
        ],
        "rule_sql": []
    },
    "4954": {
        "db_id": "olympics",
        "question": "In the Winter and Summer Olympics of 1988, which game has the most number of competitors? Find the difference of the number of competitors between the two games.",
        "ground_truth": "SELECT P1 , ( SELECT MAX(P2) - MIN(P2) FROM ( SELECT COUNT(T2.person_id) AS P2 FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name IN ('1988 Winter', '1988 Summer') GROUP BY T1.season ) ORDER BY P2 DESC LIMIT 1 ) FROM ( SELECT T1.season AS P1, COUNT(T2.person_id) AS P2 FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name IN ('1988 Winter', '1988 Summer') GROUP BY T1.season ) ORDER BY P2 DESC LIMIT 1",
        "amends": [
            "Do use a subquery with `games` and `games_competitor` tables joined on `T1.id = T2.games_id` instead of querying a single `competitors` table. Do filter by `games_name IN ('1988 Winter', '1988 Summer')` instead of `game = 'Winter Olympics 1988'` and `game = 'Summer Olympics 1988'`. Do calculate the difference as `MAX(P2) - MIN(P2)` from grouped season counts instead of subtracting two separate counts. Do include `GROUP BY T1.season` to aggregate by season instead of counting all records without grouping. Do structure the query with an outer select retrieving `P1` (season) and inner calculation instead of a simple arithmetic difference between two subqueries. Do add `ORDER BY P2 DESC LIMIT 1` to get the maximum difference instead of assuming the order of operations. The amended query now correctly calculates the maximum difference in competitor counts between the 1988 Winter and Summer Olympics seasons.",
            "Do add an outer query selecting `P1` and a subquery for the difference calculation instead of selecting only the difference. Do use `COUNT(T2.person_id)` instead of `COUNT(*)` in both aggregate calculations to count distinct competitors rather than all rows. Do maintain `INNER JOIN` on `T1.id = T2.games_id` instead of changing the join type. Do preserve the `WHERE` filter on `T1.games_name IN ('1988 Winter', '1988 Summer')` and `GROUP BY T1.season` without modification. Do keep the `ORDER BY P2 DESC LIMIT 1` structure but apply it to both the outer query and the subquery instead of only once. The amended query now correctly returns both the season with the highest competitor count and the range difference between maximum and minimum counts across seasons, matching the RIGHT_SQL's behavior.",
            "Do use a scalar subquery to calculate `MAX(P2) - MIN(P2)` instead of applying the aggregate functions directly in the outer SELECT. Do maintain the same subquery structure for season counts but move the difference calculation to a separate subquery instead of performing it in the main query. Do preserve the same `INNER JOIN` on `T1.id = T2.games_id` and `WHERE` filter on `T1.games_name IN ('1988 Winter', '1988 Summer')` without changes. Do keep the same `GROUP BY T1.season` and `ORDER BY P2 DESC LIMIT 1` logic in both the main query and subquery. The amended query now correctly calculates the difference between maximum and minimum competitor counts across seasons while maintaining the same result filtering and grouping behavior.",
            "Do calculate `MAX(P2) - MIN(P2)` within a single subquery instead of subtracting two separate subqueries. Do remove `DISTINCT` from `COUNT` instead of keeping it to count all competitors rather than distinct ones. Do add an outer query that selects `P1` (season) instead of omitting it. Do move the `ORDER BY P2 DESC LIMIT 1` to the outer query instead of placing it in the subquery to get the season with the highest competitor count. Do restructure the query to return both the season and the difference calculation instead of only the difference value. The amended query now correctly returns the season with the highest competitor count along with the difference between maximum and minimum competitor counts for the specified games."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM competitors WHERE game = 'Winter Olympics 1988') - \n    (SELECT COUNT(*) FROM competitors WHERE game = 'Summer Olympics 1988') AS difference;",
            "SELECT MAX(P2) - MIN(P2) AS difference\nFROM (\n    SELECT T1.season AS P1, COUNT(*) AS P2\n    FROM games T1\n    JOIN games_competitor T2 ON T1.id = T2.games_id\n    WHERE T1.games_name IN ('1988 Winter', '1988 Summer')\n    GROUP BY T1.season\n) AS season_counts\nORDER BY P2 DESC\nLIMIT 1;",
            "SELECT \n    P1,\n    (MAX(P2) - MIN(P2)) AS difference\nFROM (\n    SELECT \n        T1.season AS P1,\n        COUNT(T2.person_id) AS P2\n    FROM \n        games T1\n    INNER JOIN \n        games_competitor T2 ON T1.id = T2.games_id\n    WHERE \n        T1.games_name IN ('1988 Winter', '1988 Summer')\n    GROUP BY \n        T1.season\n) AS season_counts\nORDER BY \n    P2 DESC\nLIMIT 1",
            "SELECT \n    (SELECT MAX(competitor_count) FROM (\n        SELECT T1.season, COUNT(DISTINCT T2.person_id) AS competitor_count\n        FROM games T1\n        INNER JOIN games_competitor T2 ON T1.id = T2.games_id\n        WHERE T1.games_name IN ('1988 Winter', '1988 Summer')\n        GROUP BY T1.season\n    )) - \n    (SELECT MIN(competitor_count) FROM (\n        SELECT T1.season, COUNT(DISTINCT T2.person_id) AS competitor_count\n        FROM games T1\n        INNER JOIN games_competitor T2 ON T1.id = T2.games_id\n        WHERE T1.games_name IN ('1988 Winter', '1988 Summer')\n        GROUP BY T1.season\n    )) AS difference",
            "SELECT \n    T1.season AS P1,\n    (SELECT MAX(P2) - MIN(P2) FROM (\n        SELECT COUNT(T2.person_id) AS P2\n        FROM games T1\n        INNER JOIN games_competitor T2 ON T1.id = T2.games_id\n        WHERE T1.games_name IN ('1988 Winter', '1988 Summer')\n        GROUP BY T1.season\n    )) AS difference\nFROM games T1\nINNER JOIN games_competitor T2 ON T1.id = T2.games_id\nWHERE T1.games_name IN ('1988 Winter', '1988 Summer')\nGROUP BY T1.season\nORDER BY COUNT(T2.person_id) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7491": {
        "db_id": "image_and_language",
        "question": "State the total number of the attribute classes.",
        "ground_truth": "SELECT COUNT(ATT_CLASS_ID) FROM ATT_CLASSES",
        "amends": [
            "Do count `ATT_CLASS_ID` instead of counting all rows with `COUNT(*)` to exclude null values from the count. Do reference the `ATT_CLASSES` table instead of the `classes` table to ensure the correct data source is queried. The amended query now correctly counts non-null class identifiers from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM classes;",
            "SELECT COUNT(ATT_CLASS_ID) FROM ATT_CLASSES;"
        ],
        "rule_sql": []
    },
    "6898": {
        "db_id": "retails",
        "question": "How many customers are in the furniture segment?",
        "ground_truth": "SELECT COUNT(c_custkey) FROM customer WHERE c_mktsegment = 'FURNITURE'",
        "amends": [
            "Do reference the correct table name `customer` instead of `customers` and use the proper column name `c_custkey` for counting instead of `*`. Do use the correct column name `c_mktsegment` for filtering instead of `segment` and match the exact case `FURNITURE` instead of `furniture`. The amended query now correctly counts customers in the furniture market segment using the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE segment = 'furniture';",
            "SELECT COUNT(c_custkey) FROM customer WHERE c_mktsegment = 'FURNITURE';"
        ],
        "rule_sql": []
    },
    "9150": {
        "db_id": "movie_3",
        "question": "What is the description of the film Artist Coldblooded?",
        "ground_truth": "SELECT description FROM film WHERE title = 'ARTIST COLDBLOODED'",
        "amends": [
            "Do select `description` instead of `title` in the SELECT list. Do filter on `title = 'ARTIST COLDBLOODED'` instead of `description = 'Artist Coldblooded'` in the WHERE clause. Do reference table `film` instead of `films` in the FROM clause. The amended query now correctly retrieves the description for the film titled 'ARTIST COLDBLOODED' instead of incorrectly searching for titles with a specific description."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE description = 'Artist Coldblooded';",
            "SELECT description FROM film WHERE title = 'ARTIST COLDBLOODED'"
        ],
        "rule_sql": []
    },
    "242": {
        "db_id": "retail_complains",
        "question": "Which complaint is more urgent, complaint ID CR2400594 or ID CR2405641?",
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN `Complaint ID` = 'CR2400594' THEN priority END) > SUM(CASE WHEN `Complaint ID` = 'CR2405641' THEN priority END) THEN 'CR2400594' ELSE 'CR2405641' END FROM callcenterlogs",
        "amends": [
            "Do use a `CASE` expression with conditional aggregation on `priority` instead of selecting `complaint_id` and `urgency` directly. Do aggregate from `callcenterlogs` table instead of filtering from `complaints` table. Do compare the sum of `priority` values for specific complaint IDs instead of using an `IN` filter with hardcoded values. Do remove the `ORDER BY urgency DESC LIMIT 1` clause instead of keeping it, as the logic now uses conditional comparison rather than sorting. The amended query now correctly compares priority values between two specific complaint IDs to determine which has higher priority, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT complaint_id, urgency FROM complaints WHERE complaint_id IN ('CR2400594', 'CR2405641') ORDER BY urgency DESC LIMIT 1;",
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN \"Complaint ID\" = 'CR2400594' THEN priority ELSE 0 END) > \n             SUM(CASE WHEN \"Complaint ID\" = 'CR2405641' THEN priority ELSE 0 END) \n        THEN 'CR2400594' \n        ELSE 'CR2405641' \n    END AS more_urgent_complaint\nFROM callcenterlogs\nWHERE \"Complaint ID\" IN ('CR2400594', 'CR2405641');"
        ],
        "rule_sql": []
    },
    "2846": {
        "db_id": "professional_basketball",
        "question": "What is the minimum weight of all-star players coming from UCLA college?",
        "ground_truth": "SELECT MIN(T1.weight) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T1.college = 'UCLA'",
        "amends": [
            "Do use `MIN(T1.weight)` instead of `MAX(weight)` for the aggregate function. Do add `INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID` instead of omitting the join to the all-star table. Do reference `T1.college` instead of just `college` for table qualification. Do remove the `all_star = 1` filter from the WHERE clause instead of keeping it, since the join to player_allstar table inherently filters for all-star players. The amended query now correctly finds the minimum weight of UCLA players who are all-stars by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM players WHERE college = 'UCLA' AND all_star = 1;",
            "SELECT MIN(T1.weight) \nFROM players AS T1\nINNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID\nWHERE T1.college = 'UCLA'"
        ],
        "rule_sql": []
    },
    "4967": {
        "db_id": "olympics",
        "question": "How many persons in total have participated in 12 meter Mixed Sailing competitions?",
        "ground_truth": "SELECT COUNT(T1.competitor_id) FROM competitor_event AS T1 INNER JOIN event AS T2 ON T1.event_id = T2.id INNER JOIN sport AS T3 ON T2.sport_id = T3.id WHERE T2.event_name = 'Sailing Mixed 12 metres'",
        "amends": [
            "Do select `COUNT(T1.competitor_id)` instead of `COUNT(*)` to count specific competitor entries. Do use `FROM competitor_event AS T1 INNER JOIN event AS T2 ON T1.event_id = T2.id INNER JOIN sport AS T3 ON T2.sport_id = T3.id` instead of `FROM persons` to properly join the relevant tables for sailing events. Do filter with `T2.event_name = 'Sailing Mixed 12 metres'` instead of `competition_type = '12 meter Mixed Sailing'` to use the correct column name and event naming convention. The amended query now correctly counts competitors for the specific sailing event by joining the appropriate tables and using the proper event name filter."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM persons WHERE competition_type = '12 meter Mixed Sailing';",
            "SELECT COUNT(DISTINCT T4.person_id) \nFROM competitor_event AS T1 \nINNER JOIN event AS T2 ON T1.event_id = T2.id \nINNER JOIN sport AS T3 ON T2.sport_id = T3.id \nINNER JOIN games_competitor AS T4 ON T1.competitor_id = T4.id \nWHERE T2.event_name = 'Sailing Mixed 12 metres'"
        ],
        "rule_sql": []
    },
    "7793": {
        "db_id": "hockey",
        "question": "For the goalkeeper that became a coach than a Hall of Famer, who played for BOS in 1972?",
        "ground_truth": "SELECT T2.firstName, T2.lastName , IIF(T1.tmID = 'BOS', 'YES', 'NO') FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.year = 1972 AND T1.tmID = 'BOS' AND T2.coachID IS NOT NULL AND T2.hofID IS NULL",
        "amends": [
            "Do select `T2.firstName`, `T2.lastName`, and an `IIF` expression instead of only `p.name`. Do use `Goalies AS T1` and `Master AS T2` with an `INNER JOIN` on `T1.playerID = T2.playerID` instead of `players` and `teams` with a join on `p.team_id = t.id`. Do filter on `T1.year = 1972` and `T1.tmID = 'BOS'` instead of `p.year = 1972` and `t.abbreviation = 'BOS'`. Do add `T2.coachID IS NOT NULL` instead of `p.became_coach = 1`. Do use `T2.hofID IS NULL` instead of `p.hall_of_famer = 1`. The amended query now correctly identifies Boston goalies from 1972 who became coaches but are not Hall of Famers, matching the intended behavior.",
            "Do use `IIF(T1.tmID = 'BOS', 'YES', 'NO')` instead of `IIF(T2.coachID IS NOT NULL, 'Yes', 'No') AS became_coach` and `IIF(T2.hofID IS NOT NULL, 'Yes', 'No') AS hall_of_famer` in the SELECT list. Do change the WHERE condition to `T2.hofID IS NULL` instead of `T2.hofID IS NOT NULL`. Do remove the alias `AS became_coach` and `AS hall_of_famer` instead of keeping them. The amended query now correctly checks for players who were not Hall of Famers while maintaining the Boston team filter and coach status condition, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM players p\nJOIN teams t ON p.team_id = t.id\nWHERE t.abbreviation = 'BOS' \nAND p.position = 'Goalkeeper'\nAND p.year = 1972\nAND p.became_coach = 1\nAND p.hall_of_famer = 1;",
            "SELECT T2.firstName, T2.lastName, \n       IIF(T2.coachID IS NOT NULL, 'Yes', 'No') AS became_coach,\n       IIF(T2.hofID IS NOT NULL, 'Yes', 'No') AS hall_of_famer\nFROM Goalies AS T1\nINNER JOIN Master AS T2 ON T1.playerID = T2.playerID\nWHERE T1.year = 1972 \n  AND T1.tmID = 'BOS'\n  AND T2.coachID IS NOT NULL\n  AND T2.hofID IS NOT NULL",
            "SELECT T2.firstName, T2.lastName, IIF(T1.tmID = 'BOS', 'YES', 'NO') \nFROM Goalies AS T1 \nINNER JOIN Master AS T2 ON T1.playerID = T2.playerID \nWHERE T1.year = 1972 \nAND T1.tmID = 'BOS' \nAND T2.coachID IS NOT NULL \nAND T2.hofID IS NULL"
        ],
        "rule_sql": []
    },
    "8007": {
        "db_id": "university",
        "question": "What is the university ID of the university with the largest student staff ratio?",
        "ground_truth": "SELECT university_id FROM university_year ORDER BY student_staff_ratio DESC LIMIT 1",
        "amends": [
            "Do query the `university_year` table instead of the `universities` table to access the correct source containing student-staff ratio data. The amended query now correctly retrieves the university_id with the highest student-staff ratio from the appropriate table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_id FROM universities ORDER BY student_staff_ratio DESC LIMIT 1;",
            "SELECT university_id FROM university_year ORDER BY student_staff_ratio DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7538": {
        "db_id": "image_and_language",
        "question": "How many object elements can be detected on image no. 31?",
        "ground_truth": "SELECT COUNT(OBJ_CLASS_ID) FROM IMG_OBJ WHERE IMG_ID = 31",
        "amends": [
            "Do reference table `IMG_OBJ` instead of `objects` and column `IMG_ID` instead of `image_id` in the WHERE clause. Do count `OBJ_CLASS_ID` instead of using `COUNT(*)` to count non-null values of a specific column rather than all rows. The amended query now correctly counts object class IDs from the IMG_OBJ table where the image ID equals 31, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM objects WHERE image_id = 31;",
            "SELECT COUNT(OBJ_CLASS_ID) FROM IMG_OBJ WHERE IMG_ID = 31"
        ],
        "rule_sql": []
    },
    "432": {
        "db_id": "movies_4",
        "question": "Give the number of movies with \"saving the world\" as the keyword.",
        "ground_truth": "SELECT COUNT(T2.movie_id) FROM keyword AS T1 INNER JOIN movie_keywords AS T2 ON T1.keyword_id = T2.keyword_id WHERE keyword_name = 'saving the world'",
        "amends": [
            "Do join `keyword AS T1` and `movie_keywords AS T2` with `INNER JOIN` on `T1.keyword_id = T2.keyword_id` instead of querying `movies` table directly. Do filter on `keyword_name = 'saving the world'` instead of `keyword = 'saving the world'`. Do count `T2.movie_id` instead of `COUNT(*)` to accurately count movies associated with the keyword. The amended query now correctly joins the keyword and movie_keywords tables to count movies by keyword name instead of incorrectly assuming the keyword column exists in the movies table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE keyword = 'saving the world';",
            "SELECT COUNT(DISTINCT T2.movie_id) \nFROM keyword AS T1 \nINNER JOIN movie_keywords AS T2 ON T1.keyword_id = T2.keyword_id \nWHERE T1.keyword_name = 'saving the world'"
        ],
        "rule_sql": []
    },
    "5848": {
        "db_id": "airline",
        "question": "For the flight from ATL to PHL on 2018/8/1 that scheduled local departure time as \"2040\", which air carrier does this flight belong to?",
        "ground_truth": "SELECT T2.Description FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T1.FL_DATE = '2018/8/1' AND T1.ORIGIN = 'ATL' AND T1.DEST = 'PHL' AND T1.CRS_DEP_TIME = '2040' GROUP BY T2.Description",
        "amends": [
            "Do select `T2.Description` instead of `carrier` and add `GROUP BY T2.Description` instead of omitting it. Do join `Airlines AS T1` with `Air Carriers AS T2` on `T1.OP_CARRIER_AIRLINE_ID = T2.Code` instead of querying only `flights` table. Do filter on `T1.FL_DATE = '2018/8/1'` instead of separate `year`, `month`, and `day` columns, and use `T1.CRS_DEP_TIME = '2040'` instead of `dep_time = 2040` while maintaining `T1.ORIGIN = 'ATL'` and `T1.DEST = 'PHL'` filters. The amended query now correctly joins airline carrier information and matches the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT carrier FROM flights WHERE origin = 'ATL' AND dest = 'PHL' AND year = 2018 AND month = 8 AND day = 1 AND dep_time = 2040;",
            "SELECT T2.Description\nFROM Airlines AS T1\nJOIN \"Air Carriers\" AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code\nWHERE T1.FL_DATE = '2018/8/1'\nAND T1.ORIGIN = 'ATL'\nAND T1.DEST = 'PHL'\nAND T1.CRS_DEP_TIME = '2040'\nGROUP BY T2.Description"
        ],
        "rule_sql": []
    },
    "7606": {
        "db_id": "image_and_language",
        "question": "How many 'has' predicate classes does image ID 107 have?",
        "ground_truth": "SELECT COUNT(T2.PRED_CLASS) FROM IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T1.IMG_ID = 107 AND T2.PRED_CLASS = 'has'",
        "amends": [
            "Do use `COUNT(T2.PRED_CLASS)` instead of `COUNT(*)` to count specific non-null values. Do change the FROM clause to use `IMG_REL AS T1 INNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID` instead of a single `predicates` table. Do filter on `T1.IMG_ID = 107` instead of `image_id = 107` to reference the correct table's column. Do filter on `T2.PRED_CLASS = 'has'` instead of `predicate = 'has'` to use the proper column name from the joined table. The amended query now correctly joins the relationship and classification tables to count valid predicate instances matching the specified criteria."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM predicates WHERE image_id = 107 AND predicate = 'has';",
            "SELECT COUNT(T2.PRED_CLASS) \nFROM IMG_REL AS T1 \nINNER JOIN PRED_CLASSES AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID \nWHERE T1.IMG_ID = 107 AND T2.PRED_CLASS = 'has'"
        ],
        "rule_sql": []
    },
    "3043": {
        "db_id": "shakespeare",
        "question": "How many acts can be found in the comedy \"Two Gentlemen of Verona\"?",
        "ground_truth": "SELECT COUNT(T1.ACT) FROM chapters AS T1 LEFT JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.GenreType = 'Comedy' AND T2.Title = 'Two Gentlemen of Verona'",
        "amends": [
            "Do select `COUNT(T1.ACT)` instead of `COUNT(*)` to count specific column values rather than all rows. Do use `FROM chapters AS T1 LEFT JOIN works AS T2` instead of `FROM plays` to join two tables with a left join relationship. Do apply join condition `ON T1.work_id = T2.id` instead of no join condition to properly relate the tables. Do filter with `WHERE T2.GenreType = 'Comedy'` instead of `genre = 'comedy'` to use the correct column name and case. Do filter with `WHERE T2.Title = 'Two Gentlemen of Verona'` instead of `title = 'Two Gentlemen of Verona'` to reference the joined table's column. The amended query now correctly counts acts from chapters of the specified comedy work instead of counting rows from a single table.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the right query counts all acts without deduplication. Do maintain the same `LEFT JOIN` on `T1.work_id = T2.id` and identical `WHERE` filters for `T2.GenreType = 'Comedy'` and `T2.Title = 'Two Gentlemen of Verona'`. The amended query now correctly counts all acts from comedy works with the specified title rather than counting distinct acts only."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM plays WHERE title = 'Two Gentlemen of Verona' AND genre = 'comedy';",
            "SELECT COUNT(DISTINCT T1.Act) FROM chapters AS T1 LEFT JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.GenreType = 'Comedy' AND T2.Title = 'Two Gentlemen of Verona'",
            "SELECT COUNT(T1.Act) FROM chapters AS T1 LEFT JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.GenreType = 'Comedy' AND T2.Title = 'Two Gentlemen of Verona'"
        ],
        "rule_sql": []
    },
    "9398": {
        "db_id": "movie_3",
        "question": "List all the description of the films starring Lucille Tracy?",
        "ground_truth": "SELECT T1.film_id FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id WHERE T2.first_name = 'LUCILLE' AND T2.last_name = 'TRACY'",
        "amends": [
            "Do select `T1.film_id` instead of `description` from a different table. Do use `film_actor AS T1` and `actor AS T2` as source tables instead of just `films`. Do add an `INNER JOIN` between `T1.actor_id = T2.actor_id` instead of no join condition. Do change the filter to `T2.first_name = 'LUCILLE' AND T2.last_name = 'TRACY'` instead of `star = 'Lucille Tracy'` to properly match against normalized first and last name columns. The amended query now correctly retrieves film IDs by joining through the actor relationship table instead of relying on a denormalized star field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM films WHERE star = 'Lucille Tracy';",
            "SELECT T1.film_id FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id WHERE T2.first_name = 'LUCILLE' AND T2.last_name = 'TRACY'"
        ],
        "rule_sql": []
    },
    "5539": {
        "db_id": "menu",
        "question": "What is the position coordinate on the page menu of the \"Small Hominy\" dish and how long did it appear?",
        "ground_truth": "SELECT T2.xpos, T2.ypos, T1.last_appeared - T1.first_appeared FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Small Hominy'",
        "amends": [
            "Do select `T2.xpos`, `T2.ypos`, and `T1.last_appeared - T1.first_appeared` instead of `position` and `duration`. Do use `INNER JOIN` between `Dish AS T1` and `MenuItem AS T2` on `T1.id = T2.dish_id` instead of querying only `menu_items`. Do filter on `T1.name = 'Small Hominy'` instead of `dish_name = 'Small Hominy'`. The amended query now correctly joins related tables and calculates duration from timestamp differences rather than relying on a single table with potentially incorrect columns."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position, duration FROM menu_items WHERE dish_name = 'Small Hominy';",
            "SELECT T2.xpos, T2.ypos, T1.last_appeared - T1.first_appeared AS duration\nFROM Dish AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id\nWHERE T1.name = 'Small Hominy'"
        ],
        "rule_sql": []
    },
    "9156": {
        "db_id": "movie_3",
        "question": "Sherri Rhodes rented a film at 12:27:27 on 2005/7/28, when did she/he return that film?",
        "ground_truth": "SELECT T2.return_date FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'SHERRI' AND T1.last_name = 'RHODES' AND T2.rental_date = '2005-07-28 12:27:27'",
        "amends": [
            "Do join `customer AS T1` with `rental AS T2` on `T1.customer_id = T2.customer_id` instead of querying only the `rental` table without proper customer linkage. Do filter on `T1.first_name = 'SHERRI'` and `T1.last_name = 'RHODES'` instead of using the non-existent `customer_name` column. Do select `T2.return_date` with table qualification instead of just `return_date` without source specification. The amended query now correctly joins customer and rental tables using the proper foreign key relationship and filters on the actual first_name and last_name columns instead of the fictional customer_name field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT return_date FROM rental WHERE customer_name = 'Sherri Rhodes' AND rental_date = '2005-07-28 12:27:27';",
            "SELECT T2.return_date\nFROM customer AS T1\nJOIN rental AS T2 ON T1.customer_id = T2.customer_id\nWHERE T1.first_name = 'SHERRI' \nAND T1.last_name = 'RHODES' \nAND T2.rental_date = '2005-07-28 12:27:27'"
        ],
        "rule_sql": []
    },
    "2791": {
        "db_id": "european_football_1",
        "question": "Please list the home teams in the matches of the Bundesliga division that ended with a home victory in the 2021 season.",
        "ground_truth": "SELECT DISTINCT T1.HomeTeam FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.season = 2021 AND T1.FTR = 'H' AND T2.name = 'Bundesliga'",
        "amends": [
            "Do use `DISTINCT T1.HomeTeam` instead of `home_team` to eliminate duplicates. Do join `matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division` instead of querying only the `matches` table to properly relate teams to divisions. Do filter with `T1.FTR = 'H'` instead of `home_score > away_score` to use the standardized result indicator. Do filter with `T2.name = 'Bundesliga'` instead of `division = 'Bundesliga'` to reference the correct column name in the joined table. The amended query now correctly identifies home teams that won Bundesliga matches in 2021 by properly joining division data and using the standardized result field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT home_team FROM matches WHERE division = 'Bundesliga' AND season = 2021 AND home_score > away_score;",
            "SELECT DISTINCT T1.HomeTeam\nFROM matchs AS T1\nINNER JOIN divisions AS T2 ON T1.Div = T2.division\nWHERE T1.FTR = 'H'\nAND T2.name = 'Bundesliga'\nAND T1.season = 2021"
        ],
        "rule_sql": []
    },
    "1517": {
        "db_id": "synthea",
        "question": "List the full names of patients with nut allergy.",
        "ground_truth": "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Allergy to nut'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select columns `first` and `last` instead of `first_name` and `last_name` to match the correct column names. Do add `INNER JOIN` on `allergies AS T2` with predicate `ON T1.patient = T2.PATIENT` instead of querying only the `patients` table to properly relate the tables. Do change the filter to `T2.DESCRIPTION = 'Allergy to nut'` instead of `allergy = 'peanut'` to use the correct condition from the joined table. Do add table alias `AS T1` instead of omitting it for clarity. The amended query now correctly identifies patients with nut allergies by joining the appropriate tables and using the correct filter condition."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM patients WHERE allergy = 'peanut'",
            "SELECT DISTINCT T1.first, T1.last FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Allergy to nut'"
        ],
        "rule_sql": []
    },
    "8770": {
        "db_id": "chicago_crime",
        "question": "Please list the blocks where all the incidents in the district commanded by Robert A. Rubio took place.",
        "ground_truth": "SELECT T2.block FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander = 'Robert A. Rubio'",
        "amends": [
            "Do use explicit table aliases `T2.block` instead of just `block`. Do join `District AS T1` and `Crime AS T2` with `INNER JOIN` on `T1.district_no = T2.district_no` instead of using a subquery. Do filter directly with `T1.commander = 'Robert A. Rubio'` instead of the nested subquery `WHERE district = (SELECT district FROM commanders WHERE name = 'Robert A. Rubio')`. Do remove `DISTINCT` instead of keeping it since the join and filter conditions ensure uniqueness. The amended query now correctly retrieves blocks from the Crime table based on the district commander's name through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT block FROM incidents WHERE district = (SELECT district FROM commanders WHERE name = 'Robert A. Rubio')",
            "SELECT T2.block FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T1.commander = 'Robert A. Rubio'"
        ],
        "rule_sql": []
    },
    "6842": {
        "db_id": "retails",
        "question": "Which line item with the highest quantity is shipped by air?",
        "ground_truth": "SELECT l_linenumber FROM lineitem WHERE l_shipmode = 'AIR' ORDER BY l_quantity DESC LIMIT 1",
        "amends": [
            "Do select `l_linenumber` instead of `*` for all columns. Do use table alias `lineitem` instead of `line_items`. Do move the `WHERE` clause before `ORDER BY` instead of after it. Do filter on `l_shipmode = 'AIR'` instead of `shipping_method = 'air'`. Do order by `l_quantity DESC` instead of `quantity DESC`. The amended query now correctly filters before sorting and uses the proper column names and table reference to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM line_items ORDER BY quantity DESC LIMIT 1 WHERE shipping_method = 'air';",
            "SELECT l_linenumber FROM lineitem WHERE l_shipmode = 'AIR' ORDER BY l_quantity DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2520": {
        "db_id": "app_store",
        "question": "What are the top 5 installed free apps?",
        "ground_truth": "SELECT App FROM playstore WHERE Price = 0 ORDER BY CAST(REPLACE(REPLACE(Installs, ',', ''), '+', '') AS INTEGER) DESC LIMIT 5",
        "amends": [
            "Do select `App` instead of `*` to return only the application name column. Do use table `playstore` instead of `apps` as the correct data source. Do filter on `Price = 0` instead of `price = 0` to match the correct column name casing. Do order by `CAST(REPLACE(REPLACE(Installs, ',', ''), '+', '') AS INTEGER)` instead of `downloads` to properly convert the install count string with commas and plus signs to a numeric value for correct sorting. The amended query now correctly handles the string-to-integer conversion of installation counts and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM apps WHERE price = 0 ORDER BY downloads DESC LIMIT 5;",
            "SELECT App FROM playstore WHERE Price = '0' ORDER BY CAST(REPLACE(REPLACE(Installs, ',', ''), '+', '') AS INTEGER) DESC LIMIT 5"
        ],
        "rule_sql": []
    },
    "8074": {
        "db_id": "university",
        "question": "What is the name of the university with the most international students in 2011?",
        "ground_truth": "SELECT T2.university_name FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2011 ORDER BY T1.pct_international_students DESC LIMIT 1",
        "amends": [
            "Do select `T2.university_name` from the `university` table instead of `name` from the `universities` table. Do join `university_year AS T1` with `university AS T2` on `T1.university_id = T2.id` instead of querying a single table. Do filter on `T1.year = 2011` instead of `year = 2011`. Do order by `T1.pct_international_students DESC` instead of `domestic_students DESC`. The amended query now correctly retrieves the university with the highest percentage of international students for 2011 rather than domestic students, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM universities WHERE year = 2011 ORDER BY domestic_students DESC LIMIT 1;",
            "SELECT T2.university_name \nFROM university_year AS T1 \nJOIN university AS T2 ON T1.university_id = T2.id \nWHERE T1.year = 2011 \nORDER BY T1.pct_international_students DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "7412": {
        "db_id": "works_cycles",
        "question": "Please show the credit card number of David Bradley.",
        "ground_truth": "SELECT T3.CardNumber FROM Person AS T1 INNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID WHERE T1.FirstName = 'David' AND T1.LastName = 'Bradley'",
        "amends": [
            "Do select `T3.CardNumber` instead of `credit_card`. Do use `Person AS T1` joined with `PersonCreditCard AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of querying `customers` directly. Do add `INNER JOIN` with `CreditCard AS T3` on `T2.CreditCardID = T3.CreditCardID` instead of omitting these table relationships. Do filter on `T1.FirstName` and `T1.LastName` instead of `first_name` and `last_name` from the original table. The amended query now correctly joins the necessary tables to retrieve credit card information through proper entity relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_card FROM customers WHERE first_name = 'David' AND last_name = 'Bradley';",
            "SELECT T3.CardNumber \nFROM Person AS T1\nINNER JOIN PersonCreditCard AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN CreditCard AS T3 ON T2.CreditCardID = T3.CreditCardID\nWHERE T1.FirstName = 'David' AND T1.LastName = 'Bradley'"
        ],
        "rule_sql": []
    },
    "9216": {
        "db_id": "movie_3",
        "question": "List the films' titles which were rented by Brian Wyman in July, 2005.",
        "ground_truth": "SELECT T4.title FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE T1.first_name = 'BRIAN' AND T1.last_name = 'WYMAN' AND STRFTIME('%Y', T2.rental_date) = '2005' AND STRFTIME('%m',T2.rental_date) = '7'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title \nFROM film f\nJOIN inventory i ON f.film_id = i.film_id\nJOIN rental r ON i.inventory_id = r.inventory_id\nJOIN customer c ON r.customer_id = c.customer_id\nWHERE c.first_name = 'Brian' \nAND c.last_name = 'Wyman'\nAND r.rental_date BETWEEN '2005-07-01' AND '2005-07-31';"
        ],
        "rule_sql": []
    },
    "8026": {
        "db_id": "university",
        "question": "Among universities that score below 80 in 2015, what is the percentage of international students?",
        "ground_truth": "SELECT SUM(CAST(T1.num_students * T1.pct_international_students AS REAL) / 100) / COUNT(*) * 100 FROM university_year AS T1 INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE T2.score < 80 AND T1.year = 2015",
        "amends": [
            "Do use `SUM(CAST(T1.num_students * T1.pct_international_students AS REAL) / 100) / COUNT(*) * 100` instead of `(international_students / total_students) * 100` to calculate the weighted average percentage. Do join `university_year AS T1 INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id` instead of querying only `universities` table. Do add filter `T2.score < 80 AND T1.year = 2015` instead of `score_2015 < 80` to properly filter by year and score. The amended query now correctly calculates the average international student percentage across universities with scores below 80 in 2015.",
            "Do remove the `AND T2.year = 2015` filter from the WHERE clause instead of keeping it, as the join condition already ensures university_id matching and the T1.year=2015 filter provides the necessary temporal constraint. Do maintain the same SELECT list with the `avg_international_student_percentage` alias instead of removing it, though this is a cosmetic difference that doesn't affect the calculation logic. The amended query now correctly calculates the average international student percentage for universities with scores below 80 in 2015 without the redundant year filter on the joined table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (international_students / total_students) * 100 AS percentage_international \nFROM universities \nWHERE score_2015 < 80;",
            "SELECT \n    SUM(CAST(T1.num_students * T1.pct_international_students AS REAL) / 100) / COUNT(*) * 100 AS avg_international_student_percentage\nFROM \n    university_year AS T1 \nINNER JOIN \n    university_ranking_year AS T2 ON T1.university_id = T2.university_id\nWHERE \n    T2.score < 80 \n    AND T1.year = 2015 \n    AND T2.year = 2015;",
            "SELECT SUM(CAST(T1.num_students * T1.pct_international_students AS REAL) / 100) / COUNT(*) * 100 AS avg_international_student_percentage\nFROM university_year AS T1\nINNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id\nWHERE T2.score < 80 AND T1.year = 2015"
        ],
        "rule_sql": []
    },
    "5825": {
        "db_id": "airline",
        "question": "Among the flights on 2018/8/1, how many of them were scheduled to depart from John F. Kennedy International in New York?",
        "ground_truth": "SELECT COUNT(T1.Code) FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T2.FL_DATE = '2018/8/1' AND T1.Description = 'New York, NY: John F. Kennedy International'",
        "amends": [
            "Do join `Airports AS T1` and `Airlines AS T2` with `INNER JOIN` on `T1.Code = T2.ORIGIN` instead of querying only the `flights` table. Do count `T1.Code` instead of `COUNT(*)` to ensure accurate counting of airport codes. Do filter on `T2.FL_DATE = '2018/8/1'` instead of `date = '2018/8/1'` to use the correct date column from the joined table. Do filter on `T1.Description = 'New York, NY: John F. Kennedy International'` instead of separate `departure_airport` and `city` conditions to match the combined airport description format. The amended query now correctly joins airport and airline data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM flights WHERE date = '2018/8/1' AND departure_airport = 'John F. Kennedy International' AND city = 'New York';",
            "SELECT COUNT(T1.Code) \nFROM Airports AS T1 \nINNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN \nWHERE T2.FL_DATE = '2018/8/1' \nAND T1.Description = 'New York, NY: John F. Kennedy International'"
        ],
        "rule_sql": []
    },
    "1146": {
        "db_id": "talkingdata",
        "question": "Please list the location coordinates of all the Galaxy Note 2 devices when an event happened.",
        "ground_truth": "SELECT T1.longitude, T1.latitude FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Galaxy Note 2'",
        "amends": [
            "Do select `T1.longitude` and `T1.latitude` instead of `latitude` and `longitude` without table aliases. Do use `INNER JOIN` with `phone_brand_device_model2 AS T2` instead of querying only the `devices` table. Do join on `T1.device_id = T2.device_id` instead of missing the join condition entirely. Do filter on `T2.device_model = 'Galaxy Note 2'` instead of `model = 'Galaxy Note 2'` and remove the `event_id IS NOT NULL` condition. The amended query now correctly joins the events and device model tables to retrieve location data for the specified device model."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude, longitude FROM devices WHERE model = 'Galaxy Note 2' AND event_id IS NOT NULL",
            "SELECT T1.longitude, T1.latitude\nFROM events AS T1\nINNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id\nWHERE T2.device_model = 'Galaxy Note 2'"
        ],
        "rule_sql": []
    },
    "3502": {
        "db_id": "video_games",
        "question": "How many games available on PSP were released in 2004?",
        "ground_truth": "SELECT COUNT(T3.game_id) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE T1.platform_name = 'PSP' AND T2.release_year = 2004",
        "amends": [
            "Do select `COUNT(T3.game_id)` instead of `COUNT(*)` to count specific game IDs rather than all rows. Do join `platform AS T1` instead of querying games directly to properly access platform information. Do add `INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id` instead of omitting this relationship to connect platforms to game releases. Do add `INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id` instead of omitting this relationship to access game identifiers. Do filter on `T1.platform_name = 'PSP'` instead of `platform = 'PSP'` to use the correct column name from the platform table. Do filter on `T2.release_year = 2004` instead of `release_year = 2004` to use the correct column from the game_platform junction table. The amended query now correctly counts PSP games from 2004 by properly navigating the relational schema through the appropriate table joins."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE platform = 'PSP' AND release_year = 2004;",
            "SELECT COUNT(T3.game_id) \nFROM platform AS T1\nINNER JOIN game_platform AS T2 ON T1.id = T2.platform_id\nINNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id\nWHERE T1.platform_name = 'PSP' AND T2.release_year = 2004"
        ],
        "rule_sql": []
    },
    "8925": {
        "db_id": "cookbook",
        "question": "How many recipes are non-dairy?",
        "ground_truth": "SELECT COUNT(T2.recipe_id) FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id INNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id WHERE T1.category NOT LIKE '%dairy%'",
        "amends": [
            "Do join tables `Ingredient`, `Quantity`, and `Nutrition` instead of querying only the `recipes` table. Do filter with `T1.category NOT LIKE '%dairy%'` instead of `dairy = 'yes'`. Do count `T2.recipe_id` instead of using `COUNT(*)`. Do use proper table aliases and join conditions with `T2.ingredient_id = T1.ingredient_id` and `T3.recipe_id = T2.recipe_id` instead of the simple single-table approach. The amended query now correctly counts recipes that do not contain dairy ingredients by joining through the ingredient relationships rather than relying on a direct dairy flag.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the RIGHT_SQL counts all recipe_id values without deduplication. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for both table joins, though this is semantically equivalent. Do add table aliases with `AS` keyword for `Ingredient AS T1` and `Quantity AS T2` instead of omitting the `AS`, though this is purely cosmetic. The amended query now matches RIGHT_SQL's behavior by removing the unnecessary DISTINCT modifier while maintaining the same join logic and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM recipes WHERE dairy = 'yes';",
            "SELECT COUNT(DISTINCT T2.recipe_id) \nFROM Ingredient T1\nJOIN Quantity T2 ON T2.ingredient_id = T1.ingredient_id\nJOIN Nutrition T3 ON T3.recipe_id = T2.recipe_id\nWHERE T1.category NOT LIKE '%dairy%'",
            "SELECT COUNT(T2.recipe_id) \nFROM Ingredient AS T1 \nINNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id \nINNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id \nWHERE T1.category NOT LIKE '%dairy%'"
        ],
        "rule_sql": []
    },
    "7417": {
        "db_id": "works_cycles",
        "question": "Please list the departments that David Bradley used to belong to.",
        "ground_truth": "SELECT T2.DepartmentID FROM Person AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID WHERE T1.FirstName = 'David' AND T1.LastName = 'Bradley'",
        "amends": [
            "Do select `T2.DepartmentID` instead of `department_name` from the wrong table. Do use `Person AS T1` as the main table instead of `employees` which doesn't exist in the schema. Do add `INNER JOIN EmployeeDepartmentHistory AS T2` on `T1.BusinessEntityID = T2.BusinessEntityID` instead of missing this join entirely. Do add `INNER JOIN Department AS T3` on `T2.DepartmentID = T3.DepartmentID` instead of omitting this necessary join. Do filter on `T1.FirstName` and `T1.LastName` instead of filtering on non-existent columns in the wrong table. The amended query now correctly joins the three required tables to find the department ID for the specified person, matching the RIGHT_SQL's behavior.",
            "Do select `T2.DepartmentID` instead of `T3.Name AS DepartmentName` in the SELECT list. Do remove the alias `AS DepartmentName` instead of keeping it. The amended query now correctly retrieves the DepartmentID from the EmployeeDepartmentHistory table instead of the Department name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department_name FROM employees WHERE first_name = 'David' AND last_name = 'Bradley'",
            "SELECT T3.Name AS DepartmentName\nFROM Person AS T1\nINNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID\nWHERE T1.FirstName = 'David' AND T1.LastName = 'Bradley'",
            "SELECT T2.DepartmentID\nFROM Person AS T1\nINNER JOIN EmployeeDepartmentHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID\nINNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID\nWHERE T1.FirstName = 'David' AND T1.LastName = 'Bradley'"
        ],
        "rule_sql": []
    },
    "7735": {
        "db_id": "hockey",
        "question": "What is the total amount of assists of the NHL player with the most assists in history? Please indicate his/her full name.",
        "ground_truth": "SELECT SUM(T1.A), T2.firstName, T2.lastName FROM Scoring AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.lgID = 'NHL' GROUP BY T2.firstName, T2.lastName ORDER BY SUM(T1.A) DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.A)` for assists instead of `SUM(goals)` as total_assists. Do join `Scoring AS T1` with `Master AS T2` on `T1.playerID = T2.playerID` instead of querying only `nhl_player_stats`. Do add filter `WHERE T1.lgID = 'NHL'` instead of omitting league specification. Do group by `T2.firstName, T2.lastName` instead of just `player_name`. Do order by `SUM(T1.A)` instead of `total_assists`. The amended query now correctly calculates NHL assists by joining player scoring data with master information and filtering for the NHL league.",
            "Do select `SUM(T1.A)`, `T2.firstName`, and `T2.lastName` as separate columns instead of concatenating them into a single `full_name` alias. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN`. Do remove the column alias `total_assists` for the aggregate function instead of keeping it. The amended query now correctly returns individual columns for the sum and player names rather than concatenating them, while maintaining the same join logic, filtering, grouping, and ordering behavior to match the RIGHT_SQL's output structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, SUM(goals) as total_assists \nFROM nhl_player_stats \nGROUP BY player_name \nORDER BY total_assists DESC \nLIMIT 1;",
            "SELECT T2.firstName || ' ' || T2.lastName AS full_name, SUM(T1.A) AS total_assists\nFROM Scoring AS T1\nJOIN Master AS T2 ON T1.playerID = T2.playerID\nWHERE T1.lgID = 'NHL'\nGROUP BY T2.firstName, T2.lastName\nORDER BY SUM(T1.A) DESC\nLIMIT 1;",
            "SELECT SUM(T1.A), T2.firstName, T2.lastName\nFROM Scoring AS T1\nINNER JOIN Master AS T2 ON T1.playerID = T2.playerID\nWHERE T1.lgID = 'NHL'\nGROUP BY T2.firstName, T2.lastName\nORDER BY SUM(T1.A) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "252": {
        "db_id": "retail_complains",
        "question": "Among the clients who did receive a timely response for their complaint, how many of them are from New York?",
        "ground_truth": "SELECT COUNT(T1.city) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Timely response?` = 'No' AND T1.city = 'New York City'",
        "amends": [
            "Do select `COUNT(T1.city)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do use table alias `T1` for the client table instead of the unaliased `clients` reference. Do add `INNER JOIN events AS T2` instead of querying only the clients table to incorporate event data. Do use join condition `T1.client_id = T2.Client_ID` instead of no join to properly relate clients to their events. Do change filter to `T2.\"Timely response?\" = 'No'` instead of `complaint_response_time <= 24 AND complaint_received = 1` to check for untimely responses specifically. Do filter on `T1.city = 'New York City'` instead of `state = 'New York'` to target the specific city rather than the entire state. The amended query now correctly counts clients from New York City with untimely responses, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM clients \nWHERE state = 'New York' \nAND complaint_response_time <= 24 \nAND complaint_received = 1",
            "SELECT COUNT(T1.city) \nFROM client AS T1\nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID\nWHERE T2.\"Timely response?\" = 'No'\nAND T1.city = 'New York City'"
        ],
        "rule_sql": []
    },
    "5571": {
        "db_id": "menu",
        "question": "Please list the page numbers of all the menu pages on which the dish \"Chicken gumbo\" had appeared.",
        "ground_truth": "SELECT T1.page_number FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE T3.name = 'Chicken gumbo'",
        "amends": [
            "Do add `MenuPage AS T1` and `MenuItem AS T2` with `INNER JOIN` on `T1.id = T2.menu_page_id` instead of querying only `menu_pages` directly. Do add `Dish AS T3` with `INNER JOIN` on `T2.dish_id = T3.id` instead of filtering by `dish_name` directly from the menu_pages table. Do filter on `T3.name = 'Chicken gumbo'` instead of `dish_name = 'Chicken gumbo'` to properly reference the dish name from the Dish table. Do specify `T1.page_number` instead of just `page_number` to explicitly reference the source table. The amended query now correctly joins through the relational structure to find menu pages containing the specified dish, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_number FROM menu_pages WHERE dish_name = 'Chicken gumbo';",
            "SELECT T1.page_number\nFROM MenuPage AS T1\nINNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id\nINNER JOIN Dish AS T3 ON T2.dish_id = T3.id\nWHERE T3.name = 'Chicken gumbo'"
        ],
        "rule_sql": []
    },
    "7954": {
        "db_id": "music_platform_2",
        "question": "What dates were the Don't Lie To Your Life Coach podcast reviews created?",
        "ground_truth": "SELECT created_at FROM reviews WHERE podcast_id = ( SELECT podcast_id FROM podcasts WHERE title = 'Don''t Lie To Your Life Coach' )",
        "amends": [
            "Do select `created_at` instead of `review_date` and use a subquery to get `podcast_id` from the `podcasts` table instead of directly filtering by `podcast_name`. Do filter on `podcast_id` in the main query instead of `podcast_name` and reference the `reviews` table instead of `podcast_reviews`. Do use the correct table name `podcasts` with column `title` for the filter condition instead of assuming a `podcast_name` column exists in the reviews table. The amended query now correctly retrieves review timestamps by first identifying the podcast ID through its title, ensuring accurate data retrieval from the proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT review_date FROM podcast_reviews WHERE podcast_name = 'Don\\'t Lie To Your Life Coach'",
            "SELECT created_at FROM reviews WHERE podcast_id = (SELECT podcast_id FROM podcasts WHERE title = 'Don''t Lie To Your Life Coach')"
        ],
        "rule_sql": []
    },
    "3759": {
        "db_id": "public_review_platform",
        "question": "What is the quantity of the closed or not running Yelp Businesses in 'AZ'?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE state LIKE 'AZ' AND active LIKE 'False'",
        "amends": [
            "Do count `business_id` instead of `*` to avoid counting NULL values. Do use table alias `Business` instead of `yelp_businesses` for correct table reference. Do use `LIKE` operator with `'False'` instead of complex OR conditions with `'closed'` and `'running'` to properly filter inactive businesses. Do remove the unnecessary parentheses around the status conditions. The amended query now correctly counts only active business IDs in Arizona with proper table and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM yelp_businesses WHERE state = 'AZ' AND (status = 'closed' OR status != 'running');",
            "SELECT COUNT(business_id) FROM Business WHERE state = 'AZ' AND active LIKE 'False';"
        ],
        "rule_sql": []
    },
    "6726": {
        "db_id": "retails",
        "question": "Calculate the percentage of customers' accounts in debt.",
        "ground_truth": "SELECT CAST(SUM(IIF(c_acctbal < 0, 1, 0)) AS REAL) * 100 / COUNT(c_custkey) FROM customer",
        "amends": [
            "Do use `SUM(IIF(c_acctbal < 0, 1, 0))` to count negative balances instead of `COUNT(*)` with `balance > 0` which incorrectly counts positive balances. Do calculate the percentage of customers in debt instead of accounts with positive balance by changing the data source from `accounts` to `customer` table. Do use `c_custkey` for the denominator count instead of a separate subquery counting all customers. Do cast the result to `REAL` for proper decimal division instead of using `* 100.0` without explicit casting. Do remove the incorrect `WHERE balance > 0` filter that was counting the opposite condition and instead use conditional logic within the aggregation. The amended query now correctly calculates the percentage of customers with negative account balances."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM customers) AS percentage_in_debt FROM accounts WHERE balance > 0;",
            "SELECT CAST(SUM(IIF(c_acctbal < 0, 1, 0)) AS REAL) / COUNT(c_custkey) * 100.0 AS percentage_in_debt FROM customer;"
        ],
        "rule_sql": []
    },
    "5093": {
        "db_id": "address",
        "question": "Please list the bad alias of all the residential areas with a median female age of over 32.",
        "ground_truth": "SELECT DISTINCT T2.bad_alias FROM zip_data AS T1 INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code WHERE T1.female_median_age > 32",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the source from `residential_areas` to `zip_data AS T1 INNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code` instead of a single table. Do use qualified column reference `T2.bad_alias` instead of unqualified `bad_alias`. Do change the filter to `T1.female_median_age > 32` instead of `median_female_age > 32` and move it to the correct table context. The amended query now correctly joins the necessary tables and applies the appropriate filtering logic to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT bad_alias FROM residential_areas WHERE median_female_age > 32",
            "SELECT DISTINCT T2.bad_alias\nFROM zip_data AS T1\nINNER JOIN avoid AS T2 ON T1.zip_code = T2.zip_code\nWHERE T1.female_median_age > 32"
        ],
        "rule_sql": []
    },
    "5488": {
        "db_id": "menu",
        "question": "How many menu items were created on 28th March 2011?",
        "ground_truth": "SELECT COUNT(*) FROM MenuItem WHERE created_at LIKE '2011-03-28%'",
        "amends": [
            "Do reference the `MenuItem` table instead of `menu_items` for the correct table name. Do use `created_at` column instead of `created_date` for the correct date column. Do use `LIKE '2011-03-28%'` pattern matching instead of exact equality `= '2011-03-28'` to capture all records from that date regardless of time component. The amended query now correctly counts all menu items created on March 28, 2011, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menu_items WHERE created_date = '2011-03-28';",
            "SELECT COUNT(*) FROM MenuItem WHERE created_at LIKE '2011-03-28%'"
        ],
        "rule_sql": []
    },
    "9097": {
        "db_id": "bike_share_1",
        "question": "Name the city of the station that trip ID 585842 borrowed a bike and indicate when that station was first installed.",
        "ground_truth": "SELECT T2.city, T2.installation_date FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.id = 585842",
        "amends": [
            "Do use explicit table aliases `T2.city` and `T2.installation_date` instead of bare column names. Do join `trip AS T1` and `station AS T2` with an `INNER JOIN` on `T2.name = T1.start_station_name` instead of using a subquery with `station_id = start_station_id`. Do filter directly on `T1.id = 585842` in the WHERE clause instead of using a subquery with `trip_id = 585842`. The amended query now correctly joins tables based on station names rather than IDs and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, installation_date FROM stations WHERE station_id = (SELECT start_station_id FROM trips WHERE trip_id = 585842);",
            "SELECT T2.city, T2.installation_date\nFROM trip AS T1\nINNER JOIN station AS T2 ON T2.name = T1.start_station_name\nWHERE T1.id = 585842"
        ],
        "rule_sql": []
    },
    "5706": {
        "db_id": "language_corpus",
        "question": "What is the revision page ID of title \"Aigua dol\u00c3\u00a7a\"?",
        "ground_truth": "SELECT revision FROM pages WHERE title = 'Aigua dol\u00c3\u00a7a'",
        "amends": [
            "Do select `revision` instead of `page_id` from the result set. Do query from table `pages` instead of `page` as the data source. The WHERE clause filter on `title = 'Aigua dol\u00c3\u00a7a'` remains unchanged. The amended query now correctly retrieves the revision identifier from the pages table instead of the page identifier from the page table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_id FROM page WHERE title = 'Aigua dol\u00c3\u00a7a';",
            "SELECT revision FROM pages WHERE title = 'Aigua dol\u00c3\u00a7a';"
        ],
        "rule_sql": []
    },
    "6285": {
        "db_id": "coinmarketcap",
        "question": "When is the best time to purchase Bitcoin?",
        "ground_truth": "SELECT T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Bitcoin' ORDER BY T2.low LIMIT 1",
        "amends": [
            "Do select `T2.date` instead of `*` and change the source from `bitcoin_prices` to an `INNER JOIN` between `coins AS T1` and `historical AS T2` on `T1.id = T2.coin_id` instead of a single table. Do add a `WHERE` filter for `T1.name = 'Bitcoin'` instead of the subquery approach, and do add `ORDER BY T2.low LIMIT 1` instead of using a subquery to find the minimum price. Do remove the subquery entirely instead of keeping it. The amended query now correctly identifies the date with the lowest Bitcoin price by joining the appropriate tables and using proper ordering with limit instead of an equality subquery that could return multiple rows."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM bitcoin_prices WHERE price = (SELECT MIN(price) FROM bitcoin_prices);",
            "SELECT T2.date\nFROM coins AS T1\nINNER JOIN historical AS T2 ON T1.id = T2.coin_id\nWHERE T1.name = 'Bitcoin'\nORDER BY T2.low\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "5017": {
        "db_id": "olympics",
        "question": "What is the percentage of athletes from Vanuatu who are taller than 175?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.height > 175 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.person_id) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Vanuatu'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `noc_region AS T1` with `person_region AS T2` on `T1.id = T2.region_id` instead of querying the `athletes` table directly. Do then join `person AS T3` on `T2.person_id = T3.id` instead of accessing height directly from the main table. Do filter on `T1.region_name = 'Vanuatu'` instead of `country = 'Vanuatu'`. Do calculate percentage using `CAST(COUNT(CASE WHEN T3.height > 175 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.person_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM athletes WHERE country = 'Vanuatu')`. Do remove the subquery and instead perform the calculation in a single query with proper joins and conditional counting. The amended query now correctly handles the three-table relationship between regions, person-region mappings, and person details to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM athletes WHERE country = 'Vanuatu')) AS percentage\nFROM athletes \nWHERE country = 'Vanuatu' AND height > 175;",
            "SELECT \n    CAST(COUNT(CASE WHEN T3.height > 175 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.person_id) AS percentage\nFROM \n    noc_region AS T1\nJOIN \n    person_region AS T2 ON T1.id = T2.region_id\nJOIN \n    person AS T3 ON T2.person_id = T3.id\nWHERE \n    T1.region_name = 'Vanuatu'"
        ],
        "rule_sql": []
    },
    "3602": {
        "db_id": "authors",
        "question": "Among the authors affiliated with Soongsil University, list the authors' names and papers published during the year 2000.",
        "ground_truth": "SELECT T2.Title, T1.Name FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE T1.Affiliation = 'Soongsil University' AND T2.Year = 2000",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of full table names. Do select `T2.Title` and `T1.Name` instead of `author_name` and `paper_title`. Do reference `PaperAuthor` as `T1` instead of `authors` and `Paper` as `T2` instead of `papers`. Do join on `T1.PaperId = T2.Id` instead of `authors.author_id = papers.author_id`. Do filter on `T1.Affiliation = 'Soongsil University'` instead of `authors.affiliation = 'Soongsil University'` and `T2.Year = 2000` instead of `papers.publication_year = 2000`. The amended query now correctly matches the RIGHT_SQL's behavior with proper table references and column names.",
            "Do swap the column order in the SELECT list to `T2.Title, T1.Name` instead of `T1.Name, T2.Title`. Do add explicit `AS` aliases for both tables instead of omitting them. Do use explicit `INNER JOIN` instead of just `JOIN`. The amended query now correctly matches the RIGHT_SQL's behavior with identical logic and output structure."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name, paper_title FROM authors JOIN papers ON authors.author_id = papers.author_id WHERE authors.affiliation = 'Soongsil University' AND papers.publication_year = 2000;",
            "SELECT T1.Name, T2.Title FROM PaperAuthor T1 JOIN Paper T2 ON T1.PaperId = T2.Id WHERE T1.Affiliation = 'Soongsil University' AND T2.Year = 2000",
            "SELECT T2.Title, T1.Name\nFROM PaperAuthor AS T1\nINNER JOIN Paper AS T2 ON T1.PaperId = T2.Id\nWHERE T1.Affiliation = 'Soongsil University' AND T2.Year = 2000"
        ],
        "rule_sql": []
    },
    "9338": {
        "db_id": "movie_3",
        "question": "How many film titles were released in 2006?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE release_year = 2006",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film WHERE release_year = 2006;"
        ],
        "rule_sql": []
    },
    "8476": {
        "db_id": "mondial_geo",
        "question": "What is the capital of Australia? Is the capital a headquarter to any organization? Name the organization(s).",
        "ground_truth": "SELECT T2.Capital, T1.Name FROM organization AS T1 INNER JOIN country AS T2 ON T1.City = T2.Capital WHERE T2.Name = 'Australia'",
        "amends": [
            "Do select `T2.Capital` and `T1.Name` instead of `city.name` and `organization.name`. Do use `INNER JOIN` with `country AS T2` instead of joining only `organizations` and `cities`. Do join on `T1.City = T2.Capital` instead of `city.id = organization.headquarter_city_id`. Do filter with `T2.Name = 'Australia'` instead of `city.country = 'Australia' AND city.is_capital = 1`. Do remove the `is_capital` filter condition since the join on `T1.City = T2.Capital` inherently selects capital cities. The amended query now correctly retrieves organizations located in Australia's capital cities by properly joining through the country table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city.name, organization.name \nFROM cities city\nJOIN organizations organization ON city.id = organization.headquarter_city_id\nWHERE city.country = 'Australia' AND city.is_capital = 1;",
            "SELECT T2.Capital, T1.Name \nFROM organization AS T1 \nINNER JOIN country AS T2 ON T1.City = T2.Capital \nWHERE T2.Name = 'Australia'"
        ],
        "rule_sql": []
    },
    "3994": {
        "db_id": "public_review_platform",
        "question": "List the business ID of shopping business that have 4 stars ratings.",
        "ground_truth": "SELECT T1.business_id FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE T3.category_name = 'Shopping' AND T1.stars = 4",
        "amends": [
            "Do add `Business_Categories` and `Categories` tables with `INNER JOIN` relationships instead of querying only the `businesses` table. Do join `Business` to `Business_Categories` on `business_id` instead of missing this relationship entirely. Do join `Business_Categories` to `Categories` on `category_id` instead of having no category table connection. Do filter on `category_name = 'Shopping'` from the `Categories` table instead of filtering directly on `category = 'shopping'` in the base table. Do use proper table aliases `T1`, `T2`, and `T3` with qualified column references instead of unqualified column names. The amended query now correctly joins through the category relationship tables to filter businesses by category name while maintaining the star rating filter, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM businesses WHERE category = 'shopping' AND stars = 4;",
            "SELECT T1.business_id\nFROM Business T1\nINNER JOIN Business_Categories T2 ON T1.business_id = T2.business_id\nINNER JOIN Categories T3 ON T2.category_id = T3.category_id\nWHERE T3.category_name = 'Shopping' AND T1.stars = 4"
        ],
        "rule_sql": []
    },
    "7045": {
        "db_id": "works_cycles",
        "question": "How many accounts have an address that is too long?",
        "ground_truth": "SELECT COUNT(*) FROM Address WHERE AddressLine2 <> ''",
        "amends": [
            "Do reference the `Address` table instead of `accounts` in the FROM clause. Do filter with `AddressLine2 <> ''` instead of `LENGTH(address) > 100` in the WHERE clause, changing from checking string length to checking for non-empty values. The amended query now correctly counts records where the second address line is populated rather than where address length exceeds 100 characters, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE LENGTH(address) > 100;",
            "SELECT COUNT(*) FROM Address WHERE AddressLine2 <> ''"
        ],
        "rule_sql": []
    },
    "2155": {
        "db_id": "world_development_indicators",
        "question": "Mention the series code of countries using Australian dollar as their currency unit. Which country belongs to middle income group among them.",
        "ground_truth": "SELECT T1.CountryCode, T2.SeriesCode FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.CurrencyUnit = 'Australian dollar' AND T1.IncomeGroup = 'Lower middle income'",
        "amends": [
            "Do select `T1.CountryCode` and `T2.SeriesCode` instead of only `series_code`. Do use `FROM Country AS T1 INNER JOIN CountryNotes AS T2` instead of `FROM countries` alone. Do join on `T1.CountryCode = T2.Countrycode` instead of no join condition. Do filter on `T1.CurrencyUnit = 'Australian dollar'` instead of `currency = 'Australian dollar'`. Do filter on `T1.IncomeGroup = 'Lower middle income'` instead of `income_group = 'middle income'`. Do remove `LIMIT 1` instead of keeping it. The amended query now correctly joins tables and uses accurate column names and filter values to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_code \nFROM countries \nWHERE currency = 'Australian dollar' \nAND income_group = 'middle income' \nLIMIT 1;",
            "SELECT T1.CountryCode, T2.SeriesCode \nFROM Country AS T1 \nINNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode \nWHERE T1.CurrencyUnit = 'Australian dollar' \nAND T1.IncomeGroup = 'Lower middle income'"
        ],
        "rule_sql": []
    },
    "144": {
        "db_id": "movie_platform",
        "question": "For all list titles with at least 200 movies in the list, what is their average number of followers?",
        "ground_truth": "SELECT AVG(list_followers) FROM lists WHERE list_movie_number > 200",
        "amends": [
            "Do select only `AVG(list_followers)` instead of selecting both `list_title` and `AVG(followers)`. Do use table `lists` instead of `movie_lists`. Do apply filter `list_movie_number > 200` instead of `movie_count >= 200`. Do remove the `GROUP BY list_title` clause instead of keeping it. The amended query now correctly calculates the average followers across all qualifying lists without unnecessary grouping."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT list_title, AVG(followers) \nFROM movie_lists \nWHERE movie_count >= 200 \nGROUP BY list_title",
            "SELECT AVG(list_followers) FROM lists WHERE list_movie_number > 200;"
        ],
        "rule_sql": []
    },
    "6020": {
        "db_id": "books",
        "question": "How many customers ordered Stephen King's first book?",
        "ground_truth": "SELECT COUNT(T1.publication_date) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN order_line AS T4 ON T4.book_id = T1.book_id WHERE T3.author_name = 'Stephen King' ORDER BY T1.publication_date ASC LIMIT 1",
        "amends": [
            "Do count `T1.publication_date` instead of `COUNT(*)` and change the aggregation approach. Do use tables `book`, `book_author`, `author`, and `order_line` instead of `customers`, `orders`, and `books`. Do perform `INNER JOIN` operations with proper foreign key relationships (`T1.book_id = T2.book_id`, `T3.author_id = T2.author_id`, `T4.book_id = T1.book_id`) instead of the incorrect join structure. Do filter on `T3.author_name = 'Stephen King'` instead of the complex subquery approach with `MIN(publication_year)`. Do add `ORDER BY T1.publication_date ASC LIMIT 1` to get the earliest publication instead of counting all records. Do remove the subquery and year-based filtering logic entirely. The amended query now correctly retrieves the earliest publication date for Stephen King's books by joining through proper relationship tables and using ordering with limit instead of aggregation with subqueries.",
            "Do select `COUNT(T1.publication_date)` instead of `COUNT(DISTINCT c.customer_id)` to count publication dates rather than distinct customers. Do use only `book`, `book_author`, `author`, and `order_line` tables instead of including unnecessary `customer` and `cust_order` tables. Do move the subquery logic into the main query by adding `ORDER BY T1.publication_date ASC LIMIT 1` instead of using a correlated subquery to find the earliest Stephen King book. Do remove the redundant subquery entirely instead of keeping it, as the main query now handles the earliest book selection directly. Do add the `ORDER BY` and `LIMIT` clauses to the main query instead of omitting them, ensuring only the earliest publication date is considered. The amended query now correctly counts order lines for Stephen King's earliest published book rather than counting distinct customers who ordered any Stephen King book matching a specific subquery result."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN books b ON o.book_id = b.book_id WHERE b.author = 'Stephen King' AND b.publication_year = (SELECT MIN(publication_year) FROM books WHERE author = 'Stephen King')",
            "SELECT COUNT(DISTINCT c.customer_id) \nFROM customer c\nINNER JOIN cust_order co ON c.customer_id = co.customer_id\nINNER JOIN order_line ol ON co.order_id = ol.order_id\nINNER JOIN book b ON ol.book_id = b.book_id\nINNER JOIN book_author ba ON b.book_id = ba.book_id\nINNER JOIN author a ON ba.author_id = a.author_id\nWHERE a.author_name = 'Stephen King'\nAND b.book_id = (\n    SELECT b2.book_id\n    FROM book b2\n    INNER JOIN book_author ba2 ON b2.book_id = ba2.book_id\n    INNER JOIN author a2 ON ba2.author_id = a2.author_id\n    WHERE a2.author_name = 'Stephen King'\n    ORDER BY b2.publication_date ASC\n    LIMIT 1\n)",
            "SELECT COUNT(T1.publication_date) \nFROM book T1\nINNER JOIN book_author T2 ON T1.book_id = T2.book_id\nINNER JOIN author T3 ON T2.author_id = T3.author_id\nINNER JOIN order_line T4 ON T1.book_id = T4.book_id\nWHERE T3.author_name = 'Stephen King'\nORDER BY T1.publication_date ASC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "6875": {
        "db_id": "retails",
        "question": "How many suppliers for the part \"hot spring dodger dim light\" are in Vietnam?",
        "ground_truth": "SELECT COUNT(T3.s_name) FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey INNER JOIN nation AS T4 ON T3.s_nationkey = T4.n_nationkey WHERE T1.p_name = 'hot spring dodger dim light' AND T4.n_name = 'VIETNAM'",
        "amends": [
            "Do join multiple tables including `part`, `partsupp`, `supplier`, and `nation` instead of querying only the `suppliers` table. Do filter on `p_name` instead of `part_name` and use `n_name` for country comparison instead of `country`. Do count `T3.s_name` instead of using `COUNT(*)` to ensure supplier-specific counting. Do use proper join conditions with `T1.p_partkey = T2.ps_partkey`, `T2.ps_suppkey = T3.s_suppkey`, and `T3.s_nationkey = T4.n_nationkey` instead of simple WHERE filters. Do use exact case matching with `'VIETNAM'` instead of `'Vietnam'` for consistent data matching. The amended query now correctly counts suppliers providing the specified part from Vietnam through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE part_name = 'hot spring dodger dim light' AND country = 'Vietnam';",
            "SELECT COUNT(DISTINCT s.s_name) \nFROM part p\nJOIN partsupp ps ON p.p_partkey = ps.ps_partkey\nJOIN supplier s ON ps.ps_suppkey = s.s_suppkey\nJOIN nation n ON s.s_nationkey = n.n_nationkey\nWHERE p.p_name = 'hot spring dodger dim light'\nAND n.n_name = 'VIETNAM'"
        ],
        "rule_sql": []
    },
    "2698": {
        "db_id": "regional_sales",
        "question": "What is the average land area of \u200b\u200bthe cities in which stores that purchased products for a unit price of 998.30 are located?",
        "ground_truth": "SELECT AVG(T2.`Land Area`) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID WHERE T1.`Unit Price` = '998.30'",
        "amends": [
            "Do use table alias `T2` for `Store Locations` instead of `c` for `cities`, and reference `Land Area` instead of `land_area`. Do use `INNER JOIN` with `Store Locations` as `T2` instead of `JOIN` with `cities` as `c`, and join on `T2.StoreID = T1._StoreID` instead of `c.city_id = s.city_id`. Do reference `Sales Orders` as `T1` instead of `stores` as `s` and `purchases` as `p`, and filter on `T1.Unit Price` = '998.30' instead of `p.unit_price` = 998.30. Do remove the unnecessary join to `purchases` table and instead filter directly on `Sales Orders`. Do use string literal '998.30' instead of numeric 998.30 for the price comparison. The amended query now correctly calculates the average land area for stores with sales at the specified unit price."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(c.land_area) \nFROM cities c\nJOIN stores s ON c.city_id = s.city_id\nJOIN purchases p ON s.store_id = p.store_id\nWHERE p.unit_price = 998.30;",
            "SELECT AVG(T2.\"Land Area\") AS \"Average Land Area\"\nFROM \"Sales Orders\" AS T1\nINNER JOIN \"Store Locations\" AS T2 ON T2.StoreID = T1._StoreID\nWHERE T1.\"Unit Price\" = '998.30'"
        ],
        "rule_sql": []
    },
    "4359": {
        "db_id": "simpson_episodes",
        "question": "In episode nominated in Annie Awards, how many of the episodes have a percent greater than 6?",
        "ground_truth": "SELECT COUNT(*) FROM Award AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T1.organization = 'Annie Awards' AND T1.result = 'Nominee' AND T2.percent > 6;",
        "amends": [
            "Do join `Award` and `Vote` tables with `INNER JOIN` on `T2.episode_id = T1.episode_id` instead of using a subquery with `IN` clause. Do filter by `T1.organization = 'Annie Awards'` and `T1.result = 'Nominee'` in the `WHERE` clause instead of only checking `award_name = 'Annie Awards'` in the subquery. Do apply the `percent > 6` filter directly on the joined `Vote` table instead of on the main `episodes` table. Do remove the subquery structure entirely instead of maintaining it, as the join approach provides better performance and clarity. The amended query now correctly counts nominations from the Annie Awards organization where the result is 'Nominee' and the vote percentage exceeds 6, matching the intended behavior.",
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT T1.episode_id)` to count all matching rows rather than distinct episode IDs. Do specify table aliases with `AS` keyword as in `Award AS T1` and `Vote AS T2` instead of omitting it. Do maintain the same join condition `T2.episode_id = T1.episode_id` instead of `T1.episode_id = T2.episode_id` while preserving the same logical equivalence. The amended query now correctly counts all award nominations from Annie Awards with vote percentages exceeding 6, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE percent > 6 AND episode_id IN (SELECT episode_id FROM nominations WHERE award_name = 'Annie Awards');",
            "SELECT COUNT(DISTINCT T1.episode_id) \nFROM Award T1 \nINNER JOIN Vote T2 ON T1.episode_id = T2.episode_id \nWHERE T1.organization = 'Annie Awards' \nAND T1.result = 'Nominee' \nAND T2.percent > 6",
            "SELECT COUNT(*)\nFROM Award AS T1\nINNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id\nWHERE T1.organization = 'Annie Awards'\nAND T1.result = 'Nominee'\nAND T2.percent > 6"
        ],
        "rule_sql": []
    },
    "4781": {
        "db_id": "legislator",
        "question": "Which legislator has the YouTube channel 'RoskamIL06?' Write the official full name.",
        "ground_truth": "SELECT T1.official_full_name FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id WHERE T2.youtube = 'RoskamIL06'",
        "amends": [
            "Do select `official_full_name` from the `current` table instead of `first_name` from `legislators`. Do join the `social-media` table using `INNER JOIN` on `bioguide = bioguide_id` instead of querying a single table. Do filter on `youtube = 'RoskamIL06'` instead of `youtube_channel = 'RoskamIL06'`. The amended query now correctly retrieves the official full name by joining the appropriate tables and using the correct column names for both the social media platform and identifier matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM legislators WHERE youtube_channel = 'RoskamIL06'",
            "SELECT c.official_full_name\nFROM current c\nINNER JOIN \"social-media\" sm ON c.bioguide_id = sm.bioguide\nWHERE sm.youtube = 'RoskamIL06'"
        ],
        "rule_sql": []
    },
    "632": {
        "db_id": "codebase_comments",
        "question": "What is the path of solution of \"spinachLexer.mT__55\" method?",
        "ground_truth": "SELECT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'spinachLexer.mT__55'",
        "amends": [
            "Do reference the `Path` column from the `Solution` table (aliased as `T1`) instead of selecting `path` from the `solutions` table. Do join the `Method` table (aliased as `T2`) using `INNER JOIN` with the predicate `T1.Id = T2.SolutionId` instead of querying a single table without any joins. Do filter on `T2.Name = 'spinachLexer.mT__55'` in the WHERE clause instead of filtering on `method_name` from a non-existent column in the original table. The amended query now correctly joins the Solution and Method tables to find the path associated with the specified method name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path FROM solutions WHERE method_name = 'spinachLexer.mT__55';",
            "SELECT T1.Path FROM Solution T1 INNER JOIN Method T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'spinachLexer.mT__55'"
        ],
        "rule_sql": []
    },
    "3727": {
        "db_id": "college_completion",
        "question": "Give the total number of all graduated students from a 2-year public schools in Alabama in 2011.",
        "ground_truth": "SELECT SUM(T2.grad_cohort) FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T1.state = 'Alabama' AND T2.year = 2011 AND T1.level = '2-year' AND T1.control = 'Public' AND T2.race = 'X'",
        "amends": [
            "Do use `SUM(T2.grad_cohort)` instead of `COUNT(*)` to sum graduation cohort numbers rather than counting rows. Do change the FROM clause to use `state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid` instead of querying only the `students` table, adding proper table joins with correct join conditions. Do modify the WHERE clause to use `T1.state = 'Alabama'` instead of `state = 'Alabama'`, `T2.year = 2011` instead of `graduation_year = 2011`, `T1.level = '2-year'` instead of `school_duration = 2`, and `T1.control = 'Public'` instead of `school_type = 'public'`, while also adding the required filter `T2.race = 'X'` instead of omitting it. The amended query now correctly aggregates graduation cohort data from the appropriate joined tables with the proper filtering conditions to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE school_type = 'public' AND state = 'Alabama' AND graduation_year = 2011 AND school_duration = 2;",
            "SELECT SUM(T2.grad_cohort) AS total_graduated_students\nFROM state_sector_details AS T1\nINNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid\nWHERE T1.state = 'Alabama'\nAND T2.year = 2011\nAND T1.level = '2-year'\nAND T1.control = 'Public'\nAND T2.race = 'X'"
        ],
        "rule_sql": []
    },
    "1083": {
        "db_id": "talkingdata",
        "question": "What is the device model of the device used by the oldest user?",
        "ground_truth": "SELECT device_model FROM phone_brand_device_model2 WHERE device_id IN ( SELECT device_id FROM gender_age WHERE age = ( SELECT MAX(age) FROM gender_age ) )",
        "amends": [
            "Do select `device_model` from `phone_brand_device_model2` instead of `users`. Do use a subquery to find the maximum age from `gender_age` instead of directly ordering by `age` from `users`. Do filter by `device_id` in the subquery result instead of limiting to one row. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the maximum age is now determined through aggregation. The amended query now correctly identifies devices associated with users of maximum age by properly joining across the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT device_model FROM users ORDER BY age DESC LIMIT 1;",
            "SELECT p.device_model \nFROM phone_brand_device_model2 p\nJOIN gender_age g ON p.device_id = g.device_id\nWHERE g.age = (SELECT MAX(age) FROM gender_age)"
        ],
        "rule_sql": []
    },
    "1842": {
        "db_id": "soccer_2016",
        "question": "Give the country where St. George's Park is located.",
        "ground_truth": "SELECT T3.Country_Name FROM Venue AS T1 INNER JOIN City AS T2 ON T2.City_Id = T1.City_Id INNER JOIN Country AS T3 ON T3.Country_Id = T2.Country_id WHERE T1.Venue_Name = 'St George''s Park'",
        "amends": [
            "Do select `T3.Country_Name` instead of `country` and use proper table aliases. Do join `Venue AS T1` instead of querying `parks` directly, then add `INNER JOIN City AS T2 ON T2.City_Id = T1.City_Id` and `INNER JOIN Country AS T3 ON T3.Country_Id = T2.Country_id` instead of no joins. Do filter on `T1.Venue_Name = 'St George''s Park'` instead of `name = 'St. George''s Park'` with corrected apostrophe handling. The amended query now correctly retrieves country information through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM parks WHERE name = 'St. George''s Park';",
            "SELECT T3.Country_Name\nFROM Venue AS T1\nINNER JOIN City AS T2 ON T2.City_Id = T1.City_Id\nINNER JOIN Country AS T3 ON T3.Country_Id = T2.Country_id\nWHERE T1.Venue_Name = 'St George''s Park'"
        ],
        "rule_sql": []
    },
    "1768": {
        "db_id": "restaurant",
        "question": "List the restaurant's ID that has a review greater than the 70% of average review of all American restaurants with street number greater than 2000.",
        "ground_truth": "SELECT T1.id_restaurant FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.food_type = 'american' AND T1.street_num > 2000 GROUP BY T1.id_restaurant ORDER BY AVG(T2.review) * 0.7 DESC",
        "amends": [
            "Do select `T1.id_restaurant` instead of `restaurant_id`. Do use `FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant` instead of `FROM restaurants` alone. Do add `WHERE T2.food_type = 'american'` instead of omitting it. Do use `T1.street_num > 2000` instead of `street_number > 2000`. Do add `GROUP BY T1.id_restaurant` instead of omitting it. Do add `ORDER BY AVG(T2.review) * 0.7 DESC` instead of using the subquery comparison `review > (SELECT AVG(review) * 0.7 FROM restaurants WHERE cuisine = 'American' AND street_number > 2000)`. Do remove the subquery entirely instead of keeping it. The amended query now correctly joins location and generalinfo tables, filters by food_type and street_num, groups by restaurant, and orders by the calculated average review score instead of using a subquery for comparison."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT restaurant_id FROM restaurants WHERE review > (SELECT AVG(review) * 0.7 FROM restaurants WHERE cuisine = 'American' AND street_number > 2000);",
            "SELECT T1.id_restaurant\nFROM location AS T1\nINNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant\nWHERE T2.food_type = 'american' AND T1.street_num > 2000\nGROUP BY T1.id_restaurant\nORDER BY AVG(T2.review) * 0.7 DESC"
        ],
        "rule_sql": []
    },
    "8776": {
        "db_id": "food_inspection",
        "question": "Please list the names of all the restaurants that have met all requirements in one inspection.",
        "ground_truth": "SELECT DISTINCT T2.name FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.score = 100",
        "amends": [
            "Do use `DISTINCT T2.name` instead of `name` to eliminate duplicate restaurant names. Do join `inspections AS T1` and `businesses AS T2` instead of querying only `restaurants` to properly relate inspection scores to business entities. Do use `INNER JOIN` with `T1.business_id = T2.business_id` instead of no join condition to correctly associate inspections with their respective businesses. Do filter on `T1.score = 100` instead of `inspection_score = 100` to reference the correct column from the inspections table. The amended query now correctly retrieves distinct restaurant names that have received perfect inspection scores by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE inspection_score = 100;",
            "SELECT DISTINCT T2.name \nFROM inspections AS T1 \nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id \nWHERE T1.score = 100"
        ],
        "rule_sql": []
    },
    "4687": {
        "db_id": "disney",
        "question": "Provide the titles, main characters, and associated songs of the movies directed by Wolfgang Reitherman in 1977.",
        "ground_truth": "SELECT T1.movie_title, T2.hero, T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title INNER JOIN director AS T3 ON T1.movie_title = T3.name WHERE T3.director = 'Wolfgang Reitherman' AND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1977'",
        "amends": [
            "Do select `movie_title`, `hero`, and `song` instead of `title`, `main_characters`, and `song_name`. Do use table aliases `T1`, `T2`, and `T3` instead of `m` and `s`. Do join `movies_total_gross AS T1` with `characters AS T2` on `T1.movie_title = T2.movie_title` instead of joining `movies` with `songs` on `movie_id`. Do add an additional `INNER JOIN` with `director AS T3` on `T1.movie_title = T3.name` instead of omitting the director table. Do filter on `T3.director = 'Wolfgang Reitherman'` instead of filtering on the movies table's director column. Do use `SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1977'` to extract the year from a date string instead of filtering on a simple `year` column. The amended query now correctly joins multiple tables and handles date extraction to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, m.main_characters, s.song_name \nFROM movies m \nJOIN songs s ON m.movie_id = s.movie_id \nWHERE m.director = 'Wolfgang Reitherman' AND m.year = 1977;",
            "SELECT T2.movie_title, T2.hero, T2.song\nFROM movies_total_gross AS T1\nINNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title\nINNER JOIN director AS T3 ON T1.movie_title = T3.name\nWHERE T3.director = 'Wolfgang Reitherman'\nAND SUBSTR(T1.release_date, LENGTH(T1.release_date) - 3, LENGTH(T1.release_date)) = '1977'"
        ],
        "rule_sql": []
    },
    "2536": {
        "db_id": "app_store",
        "question": "List all the negative comments on the \"Dog Run - Pet Dog Simulator\" app.",
        "ground_truth": "SELECT Translated_Review FROM user_reviews WHERE App = 'Dog Run - Pet Dog Simulator' AND Sentiment = 'Negative'",
        "amends": [
            "Do select `Translated_Review` instead of `*` and use table `user_reviews` instead of `comments`. Do filter on `App = 'Dog Run - Pet Dog Simulator'` instead of `app_name = 'Dog Run - Pet Dog Simulator'` and use `Sentiment = 'Negative'` instead of `rating > 0`. The amended query now correctly retrieves negative translated reviews for the specified app from the appropriate table."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM comments WHERE app_name = 'Dog Run - Pet Dog Simulator' AND rating > 0;",
            "SELECT Translated_Review FROM user_reviews WHERE App = 'Dog Run - Pet Dog Simulator' AND Sentiment = 'Negative'"
        ],
        "rule_sql": []
    },
    "4883": {
        "db_id": "legislator",
        "question": "Among all the current legislators born after the year 1960, how many of them are not google entities?",
        "ground_truth": "SELECT COUNT(*) FROM current WHERE strftime('%Y', birthday_bio) > '1960' AND google_entity_id_id IS NULL",
        "amends": [
            "Do reference the `current` table instead of `legislators`. Do filter using `strftime('%Y', birthday_bio) > '1960'` instead of `birth_year > 1960`. Do check `google_entity_id_id IS NULL` instead of `google_entity = 0`. Do remove the `is_current = 1` filter instead of keeping it, as the current table inherently contains only current records. The amended query now correctly counts current legislators born after 1960 without Google entity IDs."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM legislators \nWHERE birth_year > 1960 \nAND is_current = 1 \nAND google_entity = 0;",
            "SELECT COUNT(*) \nFROM current \nWHERE strftime('%Y', birthday_bio) > '1960' \nAND google_entity_id_id IS NULL"
        ],
        "rule_sql": []
    },
    "5518": {
        "db_id": "menu",
        "question": "List down the name of dishes from menu created in April.",
        "ground_truth": "SELECT T2.name FROM MenuItem AS T1 INNER JOIN Dish AS T2 ON T2.id = T1.dish_id WHERE SUBSTR(T1.created_at, 7, 1) = '4'",
        "amends": [
            "Do select `T2.name` from the `Dish` table instead of `name` from the `menu` table. Do use `INNER JOIN` between `MenuItem AS T1` and `Dish AS T2` on `T2.id = T1.dish_id` instead of querying a single table. Do filter with `SUBSTR(T1.created_at, 7, 1) = '4'` to extract the month digit instead of using `LIKE '%-04-%'` for pattern matching. Do reference the correct table aliases and column sources throughout the query. The amended query now correctly joins the MenuItem and Dish tables to retrieve dish names while properly filtering for April-created items using substring extraction instead of pattern matching."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM menu WHERE created_date LIKE '%-04-%'",
            "SELECT T2.name \nFROM MenuItem AS T1\nINNER JOIN Dish AS T2 ON T2.id = T1.dish_id\nWHERE SUBSTR(T1.created_at, 7, 1) = '4'"
        ],
        "rule_sql": []
    },
    "5363": {
        "db_id": "sales",
        "question": "How many sales ids are there for customer id 80?",
        "ground_truth": "SELECT COUNT(SalesID) FROM Sales WHERE CustomerID = 80",
        "amends": [
            "Do count `SalesID` instead of `*` to exclude NULL values from the count. Do use consistent case `CustomerID` instead of `customer_id` to match the actual column name. The amended query now correctly counts only non-NULL SalesID values for customer 80, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE customer_id = 80;",
            "SELECT COUNT(SalesID) FROM Sales WHERE CustomerID = 80;"
        ],
        "rule_sql": []
    },
    "6199": {
        "db_id": "food_inspection_2",
        "question": "What type of inspection was done at John Schaller?",
        "ground_truth": "SELECT DISTINCT T2.inspection_type FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.dba_name = 'JOHN SCHALLER'",
        "amends": [
            "Do use `DISTINCT` on `T2.inspection_type` instead of omitting it to eliminate duplicates. Do join `establishment AS T1` with `inspection AS T2` on `T1.license_no = T2.license_no` instead of querying only the `inspections` table. Do filter on `T1.dba_name = 'JOHN SCHALLER'` instead of `location = 'John Schaller'` to correctly match the establishment name. The amended query now properly retrieves unique inspection types by joining establishment and inspection tables and filtering by the correct business name field."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_type FROM inspections WHERE location = 'John Schaller'",
            "SELECT DISTINCT T2.inspection_type\nFROM establishment AS T1\nJOIN inspection AS T2 ON T1.license_no = T2.license_no\nWHERE T1.dba_name = 'JOHN SCHALLER'"
        ],
        "rule_sql": []
    },
    "9309": {
        "db_id": "movie_3",
        "question": "How many films did a customer named Francis Sikes rent?",
        "ground_truth": "SELECT COUNT(T1.customer_id) FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T1.first_name = 'FRANCIS' AND T1.last_name = 'SIKES'",
        "amends": [
            "Do use `COUNT(T1.customer_id)` instead of `COUNT(*)` to count specific customer instances rather than all rows. Do add table aliases `AS T1` and `AS T2` instead of omitting explicit aliasing. Do use uppercase comparison values `'FRANCIS'` and `'SIKES'` instead of mixed case `'Francis'` and `'Sikes'` to ensure case-insensitive matching. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity, though both are functionally equivalent. The amended query now correctly counts rental records for the specified customer while maintaining the same join logic and filtering conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customer c JOIN rental r ON c.customer_id = r.customer_id WHERE c.first_name = 'Francis' AND c.last_name = 'Sikes'",
            "SELECT COUNT(T1.customer_id) \nFROM rental AS T1\nINNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id\nWHERE T2.first_name = 'FRANCIS' AND T2.last_name = 'SIKES';"
        ],
        "rule_sql": []
    },
    "5812": {
        "db_id": "language_corpus",
        "question": "What is the revision ID for the page on Catalan titled \"Arqueologia\"?",
        "ground_truth": "SELECT revision FROM pages WHERE lid = 1 AND title = 'Arqueologia'",
        "amends": [
            "Do select `revision` instead of `revision_id` and use table `pages` instead of `page_revisions`. Do filter on `lid = 1` instead of `page_title = 'Catalan'` and use exact match `title = 'Arqueologia'` instead of pattern matching `page_content LIKE '%Arqueologia%'`. The amended query now correctly retrieves the revision from the pages table with the specified lid and exact title match, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT revision_id FROM page_revisions WHERE page_title = 'Catalan' AND page_content LIKE '%Arqueologia%';",
            "SELECT revision FROM pages WHERE lid = 1 AND title = 'Arqueologia';"
        ],
        "rule_sql": []
    },
    "3239": {
        "db_id": "donor",
        "question": "State the short description for the project which got the donation at 14:44:29 on 2012/9/6.",
        "ground_truth": "SELECT T1.short_description FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.donation_timestamp LIKE '2012-09-06 14:44:29'",
        "amends": [
            "Do select `T1.short_description` from the `essays` table instead of `short_description` from the `projects` table. Do join `donations AS T2` with `INNER JOIN` on `T1.projectid = T2.projectid` instead of querying only the `projects` table. Do filter with `T2.donation_timestamp LIKE '2012-09-06 14:44:29'` instead of separate `donation_time = '14:44:29'` and `donation_date = '2012/9/6'` conditions. The amended query now correctly joins the tables and uses a unified timestamp comparison instead of separate date and time fields, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT short_description FROM projects WHERE donation_time = '14:44:29' AND donation_date = '2012/9/6';",
            "SELECT T1.short_description FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.donation_timestamp LIKE '2012-09-06 14:44:29'"
        ],
        "rule_sql": []
    },
    "1423": {
        "db_id": "synthea",
        "question": "Name the patients who had an allergy to soy.",
        "ground_truth": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Allergy to soya'",
        "amends": [
            "Do select `T1.first` and `T1.last` instead of just `name`. Do add `INNER JOIN allergies AS T2` instead of querying only the `patients` table. Do use join condition `ON T1.patient = T2.PATIENT` instead of filtering directly on the patients table. Do filter on `T2.DESCRIPTION = 'Allergy to soya'` instead of `allergy = 'soy'` to properly reference the joined allergies table. The amended query now correctly joins the patients and allergies tables to identify patients with soy allergies."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM patients WHERE allergy = 'soy';",
            "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Allergy to soya'"
        ],
        "rule_sql": []
    },
    "3627": {
        "db_id": "authors",
        "question": "For the paper which was presented by \"Zvezdan Proti\u0107\", was it preprinted?",
        "ground_truth": "SELECT CASE WHEN T1.Year = 0 THEN 'TRUE' ELSE 'FALSE' END FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T2.Name = 'Zvezdan Proti\u0107' AND T1.ConferenceId = 0 AND T1.JournalId = 0",
        "amends": [
            "Do select `CASE WHEN T1.Year = 0 THEN 'TRUE' ELSE 'FALSE' END` instead of `preprinted`. Do join `Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId` instead of querying only `papers`. Do add filter `T2.Name = 'Zvezdan Proti\u0107'` instead of `author = 'Zvezdan Proti\u0107'`. Do add additional filters `T1.ConferenceId = 0 AND T1.JournalId = 0` instead of omitting them. The amended query now correctly identifies papers by the specified author with conference and journal constraints, returning a boolean indicator for year zero instead of a preprinted status."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT preprinted FROM papers WHERE author = 'Zvezdan Proti\u0107';",
            "SELECT CASE WHEN T1.Year = 0 THEN 'TRUE' ELSE 'FALSE' END\nFROM Paper AS T1 \nINNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId\nWHERE T2.Name = 'Zvezdan Proti\u0107'\nAND T1.ConferenceId = 0 \nAND T1.JournalId = 0"
        ],
        "rule_sql": []
    },
    "4878": {
        "db_id": "legislator",
        "question": "List the official full names of all the legislators that served 13 district for 26 consecutive years.",
        "ground_truth": "SELECT DISTINCT CASE WHEN SUM(CAST(strftime('%Y', T2.end) AS int) - CAST(strftime('%Y', T2.start) AS int)) = 26 THEN T1.official_full_name END FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide GROUP BY T1.official_full_name, T2.district HAVING COUNT(T1.official_full_name) = 13",
        "amends": [
            "Do use `SELECT DISTINCT` with a `CASE` expression instead of selecting `first_name` and `last_name` directly. Do calculate years served using `SUM(CAST(strftime('%Y', T2.end) AS int) - CAST(strftime('%Y', T2.start) AS int))` instead of a simple `years_served` column. Do join `current AS T1` with `current-terms AS T2` on `T1.bioguide_id = T2.bioguide` instead of querying a single `legislators` table. Do filter by `HAVING COUNT(T1.official_full_name) = 13` instead of `WHERE district = 13`. Do group by `T1.official_full_name` and `T2.district` instead of ordering by `last_name`. The amended query now correctly calculates cumulative years served across terms and filters by district count rather than district value, matching the intended behavior.",
            "Do use a `CASE` expression to conditionally return `official_full_name` only when the sum equals 26 instead of selecting it directly and filtering with `HAVING`. Do remove the explicit `years_served` alias from the `SELECT` list instead of including it. Do change the join to `INNER JOIN` instead of `JOIN` for clarity. Do remove the `HAVING` condition `years_served = 26` since the conditional logic is now handled in the `SELECT` instead of filtering aggregated results. The amended query now correctly uses conditional logic to return names only when the total years served equals 26, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM legislators WHERE district = 13 AND years_served = 26 ORDER BY last_name;",
            "SELECT DISTINCT\n    T1.official_full_name,\n    SUM(CAST(strftime('%Y', T2.end) AS int) - CAST(strftime('%Y', T2.start) AS int)) AS years_served\nFROM \n    current AS T1\nJOIN \n    \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nGROUP BY \n    T1.official_full_name, T2.district\nHAVING \n    COUNT(T1.official_full_name) = 13\n    AND years_served = 26;",
            "SELECT DISTINCT\n    CASE \n        WHEN SUM(CAST(strftime('%Y', T2.end) AS int) - CAST(strftime('%Y', T2.start) AS int)) = 26 \n        THEN T1.official_full_name \n    END AS official_full_name\nFROM current AS T1\nINNER JOIN \"current-terms\" AS T2 ON T1.bioguide_id = T2.bioguide\nGROUP BY T1.official_full_name, T2.district\nHAVING COUNT(T1.official_full_name) = 13"
        ],
        "rule_sql": []
    },
    "3693": {
        "db_id": "college_completion",
        "question": "Calculate the percentage of Black students in all private for profit institutions.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.race = 'B' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(T2.grad_cohort) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T1.unitid = T2.unitid WHERE T2.race = 'B' AND T1.control = 'Private for-profit'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.race = 'B' THEN 1 ELSE 0 END)` for counting specific race records instead of `COUNT(*)` which counts all rows. Do reference `T2.grad_cohort` in the denominator instead of a subquery counting all students. Do use `INNER JOIN` on `T1.unitid = T2.unitid` instead of `JOIN` on `s.institution_id = i.institution_id`. Do filter on `T2.race = 'B'` in the WHERE clause instead of `s.race = 'Black'`. Do use table aliases `T1` and `T2` for `institution_details` and `institution_grads` instead of `i` and `s` for `institutions` and `students`. Do apply `CAST(... AS REAL)` for floating-point division instead of implicit casting with `100.0`. Do reference the correct column names `unitid`, `control`, and `race` with appropriate values instead of the previous schema's column names. The amended query now correctly calculates the percentage using graduation cohort data with proper table relationships and filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM students)) AS percentage_black_students\nFROM students s\nJOIN institutions i ON s.institution_id = i.institution_id\nWHERE i.control = 'Private for-profit'\nAND s.race = 'Black';",
            "SELECT \n    (SUM(CASE WHEN T2.race = 'B' THEN 1 ELSE 0 END) * 100.0 / SUM(CAST(T2.grad_cohort AS REAL))) AS percentage_black_students\nFROM \n    institution_details T1\nINNER JOIN \n    institution_grads T2 ON T1.unitid = T2.unitid\nWHERE \n    T1.control = 'Private for-profit' \n    AND T2.race = 'B';"
        ],
        "rule_sql": []
    },
    "7219": {
        "db_id": "works_cycles",
        "question": "What is the total shipment by \"cargo transport 5\" cost of all purchase orders created on 12/14/2011?",
        "ground_truth": "SELECT SUM(t2.freight) FROM ShipMethod AS t1 INNER JOIN PurchaseOrderHeader AS t2 ON t1.shipmethodid = t2.shipmethodid WHERE t1.name = 'cargo transport 5' AND t2.orderdate = '2011-12-14'",
        "amends": [
            "Do join `ShipMethod AS t1` and `PurchaseOrderHeader AS t2` instead of querying only `purchase_orders`. Do use `INNER JOIN` on `t1.shipmethodid = t2.shipmethodid` instead of no join condition. Do filter on `t1.name = 'cargo transport 5'` instead of directly referencing `cargo_transport_5` as a column. Do filter on `t2.orderdate = '2011-12-14'` with proper date format instead of `created_date = '12/14/2011'`. Do aggregate `SUM(t2.freight)` instead of `SUM(cargo_transport_5)`. The amended query now correctly joins related tables, uses proper date formatting, and references the appropriate columns to match the intended logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(cargo_transport_5) FROM purchase_orders WHERE created_date = '12/14/2011';",
            "SELECT SUM(t2.Freight) AS TotalShipmentCost\nFROM ShipMethod AS t1\nINNER JOIN PurchaseOrderHeader AS t2 ON t1.ShipMethodID = t2.ShipMethodID\nWHERE t1.Name = 'cargo transport 5'\nAND t2.OrderDate = '2011-12-14'"
        ],
        "rule_sql": []
    },
    "4352": {
        "db_id": "simpson_episodes",
        "question": "In between the episode 5 and10 of season 2, how many of them are credited for casting?",
        "ground_truth": "SELECT COUNT(credited) FROM Credit WHERE episode_id IN ( 'S20-E5',  'S20-E6',  'S20-E7',  'S20-E8',  'S20-E9',  'S20-E10' ) AND credited = 'true' AND role = 'casting';",
        "amends": [
            "Do query the `Credit` table instead of the `episodes` table. Do use `COUNT(credited)` instead of `COUNT(*)`. Do filter by `episode_id IN` specific episode identifiers instead of `season = 2 AND episode_number BETWEEN 5 AND 10`. Do use `credited = 'true'` instead of `credited_for_casting = 'yes'`. Do add the condition `role = 'casting'` instead of omitting it. The amended query now correctly counts casting credits for specific episodes with proper boolean value handling and role filtering.",
            "Do use a hardcoded list of episode IDs `'S20-E5', 'S20-E6', 'S20-E7', 'S20-E8', 'S20-E9', 'S20-E10'` instead of a subquery `SELECT episode_id FROM Episode WHERE season = 2 AND episode BETWEEN 5 AND 10` to filter by specific episodes. Do reorder the WHERE clause conditions to place `credited = 'true'` before `role = 'casting'` instead of the original order. The amended query now directly specifies the target episodes rather than relying on a potentially incorrect season/episode mapping, ensuring it matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE season = 2 AND episode_number BETWEEN 5 AND 10 AND credited_for_casting = 'yes';",
            "SELECT COUNT(credited) FROM Credit WHERE episode_id IN (SELECT episode_id FROM Episode WHERE season = 2 AND episode BETWEEN 5 AND 10) AND role = 'casting' AND credited = 'true';",
            "SELECT COUNT(credited) FROM Credit WHERE episode_id IN ('S20-E5', 'S20-E6', 'S20-E7', 'S20-E8', 'S20-E9', 'S20-E10') AND credited = 'true' AND role = 'casting'"
        ],
        "rule_sql": []
    },
    "9347": {
        "db_id": "movie_3",
        "question": "List down all ratings of action film titles.",
        "ground_truth": "SELECT T1.description FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'action'",
        "amends": [
            "Do select `description` from the `film` table instead of `rating` from `films`. Do join `film_category` on `film_id` and `category` on `category_id` instead of querying a single table. Do filter on `category.name = 'action'` instead of `genre = 'action'`. The amended query now correctly retrieves film descriptions by joining through the category relationship instead of relying on a direct genre column.",
            "Do select `description` instead of `rating` from the film table. Do use table aliases `T1`, `T2`, and `T3` instead of `f`, `fc`, and `c` for consistency. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use lowercase `'action'` instead of `'Action'` in the WHERE filter to ensure case-insensitive matching. The amended query now correctly retrieves film descriptions instead of ratings for action category films."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating FROM films WHERE genre = 'action';",
            "SELECT f.rating\nFROM film f\nJOIN film_category fc ON f.film_id = fc.film_id\nJOIN category c ON fc.category_id = c.category_id\nWHERE c.name = 'Action';",
            "SELECT T1.description \nFROM film T1\nINNER JOIN film_category T2 ON T1.film_id = T2.film_id\nINNER JOIN category T3 ON T2.category_id = T3.category_id\nWHERE T3.name = 'action'"
        ],
        "rule_sql": []
    },
    "150": {
        "db_id": "movie_platform",
        "question": "List all movies rated by user 39115684. State the title, rating date and rating score.",
        "ground_truth": "SELECT T2.movie_title, T1.rating_timestamp_utc, T1.rating_score FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T1.user_id = 39115684",
        "amends": [
            "Do reference `T2.movie_title` instead of `title` and `T1.rating_timestamp_utc` instead of `rating_date` in the SELECT list. Do add an `INNER JOIN` between `ratings AS T1` and `movies AS T2` on `T1.movie_id = T2.movie_id` instead of querying only the movies table. Do filter on `T1.user_id = 39115684` instead of `user_id = 39115684` to reference the correct table. The amended query now correctly joins ratings and movies tables to return the user's movie ratings with proper table references and join conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, rating_date, rating_score FROM movies WHERE user_id = 39115684;",
            "SELECT T2.movie_title, T1.rating_timestamp_utc, T1.rating_score\nFROM ratings AS T1\nINNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id\nWHERE T1.user_id = 39115684"
        ],
        "rule_sql": []
    },
    "1722": {
        "db_id": "restaurant",
        "question": "Which street has the most restaurants?",
        "ground_truth": "SELECT street_name FROM location GROUP BY street_name ORDER BY COUNT(street_name) DESC LIMIT 1",
        "amends": [
            "Do select `street_name` from the `location` table instead of `street` from the `restaurants` table. Do group by `street_name` instead of `street`. Do order by `COUNT(street_name)` instead of the alias `restaurant_count`. Do remove the explicit count column alias `restaurant_count` instead of keeping it. The amended query now correctly counts restaurants by street name from the appropriate location table and orders by the actual count value rather than an alias.",
            "Do remove `COUNT(street_name)` from the SELECT list instead of including it, as the aggregate function is only needed for ordering purposes. Do keep the `GROUP BY street_name` clause to group by street names. Do maintain `ORDER BY COUNT(street_name) DESC` to order by the count of street names in descending order. Do preserve `LIMIT 1` to return only the top result. The amended query now correctly returns only the street_name column while maintaining the same grouping and ordering logic to identify the most frequent street name."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street, COUNT(*) as restaurant_count FROM restaurants GROUP BY street ORDER BY restaurant_count DESC LIMIT 1;",
            "SELECT street_name, COUNT(street_name) FROM location GROUP BY street_name ORDER BY COUNT(street_name) DESC LIMIT 1;",
            "SELECT street_name FROM location GROUP BY street_name ORDER BY COUNT(street_name) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3303": {
        "db_id": "donor",
        "question": "For what grade was the project \"Too Close for Comfort\" for?",
        "ground_truth": "SELECT T1.grade_level FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T2.title LIKE 'Too Close for Comfort'",
        "amends": [
            "Do select `grade_level` from the `projects` table instead of `grade` from the `projects` table. Do join `essays` with an `INNER JOIN` on `projectid` instead of querying only the `projects` table. Do filter on `title LIKE 'Too Close for Comfort'` from the `essays` table instead of filtering on `project_name = 'Too Close for Comfort'` from the `projects` table. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins the tables and filters on the appropriate column to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT grade FROM projects WHERE project_name = 'Too Close for Comfort';",
            "SELECT T2.grade_level\nFROM essays T1\nINNER JOIN projects T2 ON T1.projectid = T2.projectid\nWHERE T1.title = 'Too Close for Comfort';"
        ],
        "rule_sql": []
    },
    "2232": {
        "db_id": "world_development_indicators",
        "question": "How many countries in the North America Region has completed the vital registration?",
        "ground_truth": "SELECT COUNT(CountryCode) FROM Country WHERE VitalRegistrationComplete = 'Yes' AND Region = 'North America'",
        "amends": [
            "Do `COUNT(CountryCode)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference table `Country` instead of `countries` with proper case sensitivity. Do use column `VitalRegistrationComplete = 'Yes'` instead of `vital_registration = 'completed'` to match the correct column name and valid value format. Do maintain the filter `Region = 'North America'` but with proper column name capitalization. The amended query now correctly counts countries with complete vital registration in North America using the proper schema elements."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE region = 'North America' AND vital_registration = 'completed';",
            "SELECT COUNT(CountryCode) FROM Country WHERE Region = 'North America' AND VitalRegistrationComplete = 'Yes'"
        ],
        "rule_sql": []
    },
    "2318": {
        "db_id": "movielens",
        "question": "How many French movies got the highest ranking?",
        "ground_truth": "SELECT COUNT(movieid) FROM movies WHERE country = 'France' AND movieid IN ( SELECT movieid FROM u2base WHERE rating = ( SELECT MAX(rating) FROM u2base ) )",
        "amends": [
            "Do select `COUNT(movieid)` instead of `COUNT(*)` to count specific non-null values. Do filter on `country = 'France'` instead of `language = 'French'` to correctly identify French movies by country rather than language. Do use a subquery with `movieid IN` instead of comparing `ranking` directly to match movies with maximum ratings. Do reference the `u2base` table instead of the `movies` table in the subquery to access user ratings data. Do filter on `rating = MAX(rating)` instead of `ranking = MAX(ranking)` to find movies with the highest user ratings rather than internal ranking values. The amended query now correctly counts French movies that have received the maximum user rating."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE language = 'French' AND ranking = (SELECT MAX(ranking) FROM movies);",
            "SELECT COUNT(movieid) \nFROM movies \nWHERE country = 'France' \nAND movieid IN (\n    SELECT movieid \n    FROM u2base \n    WHERE rating = (\n        SELECT MAX(rating) \n        FROM u2base\n    )\n)"
        ],
        "rule_sql": []
    },
    "3430": {
        "db_id": "video_games",
        "question": "What are the three largest numbers of games sold?",
        "ground_truth": "SELECT T.game_platform_id, SUM(T.num_sales) * 100000 FROM region_sales AS T GROUP BY game_platform_id ORDER BY SUM(T.num_sales) * 100000 DESC LIMIT 3",
        "amends": [
            "Do select `T.game_platform_id` and `SUM(T.num_sales) * 100000` instead of just `COUNT(*)`. Do add `FROM region_sales AS T` instead of `FROM games`. Do add `GROUP BY game_platform_id` instead of omitting grouping. Do change the ORDER BY to `SUM(T.num_sales) * 100000 DESC` instead of `sales DESC`. The amended query now correctly calculates total sales by game platform and returns the top 3 platforms by sales volume, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games ORDER BY sales DESC LIMIT 3;",
            "SELECT T.game_platform_id, SUM(T.num_sales) * 100000 AS total_sales\nFROM region_sales AS T\nGROUP BY game_platform_id\nORDER BY SUM(T.num_sales) * 100000 DESC\nLIMIT 3"
        ],
        "rule_sql": []
    },
    "867": {
        "db_id": "cs_semester",
        "question": "Among the professors who have more than 3 research assistants, how many of them are male?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.prof_id FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.gender = 'Male' GROUP BY T1.prof_id HAVING COUNT(T1.student_id) > 3 )",
        "amends": [
            "Do use table aliases `prof AS T2` and `RA AS T1` instead of full table names `professors` and `research_assistants`. Do join tables with `INNER JOIN` on `T1.prof_id = T2.prof_id` instead of using a subquery with `INNER JOIN` on `professor_id`. Do filter with `WHERE T2.gender = 'Male'` instead of `WHERE gender = 'male'`. Do group by `T1.prof_id` instead of `professor_id`. Do count `T1.student_id` in the `HAVING` clause instead of using `COUNT(*)`. Do wrap the entire query in an outer `SELECT COUNT(*)` from the subquery instead of counting directly on the main query. The amended query now correctly counts male professors with more than 3 research assistants by properly joining tables and using appropriate grouping and counting logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM professors \nWHERE gender = 'male' \nAND professor_id IN (\n    SELECT professor_id \n    FROM research_assistants \n    GROUP BY professor_id \n    HAVING COUNT(*) > 3\n)",
            "SELECT COUNT(*) FROM (\n    SELECT T1.prof_id\n    FROM RA AS T1\n    INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id\n    WHERE T2.gender = 'Male'\n    GROUP BY T1.prof_id\n    HAVING COUNT(T1.student_id) > 3\n) AS subquery"
        ],
        "rule_sql": []
    },
    "642": {
        "db_id": "codebase_comments",
        "question": "Please provide the id of the respository that the most people like.",
        "ground_truth": "SELECT Id FROM Repo WHERE Stars = ( SELECT MAX(Stars) FROM Repo )",
        "amends": [
            "Do select `Id` from the `Repo` table instead of `repository_id` from the `likes` table. Do use a subquery with `MAX(Stars)` to find the maximum star count instead of grouping by `repository_id` and counting `user_id`. Do filter with `WHERE Stars =` the maximum value instead of ordering by count and limiting to one result. Do remove the `GROUP BY`, `ORDER BY`, and `LIMIT` clauses entirely instead of keeping them. The amended query now correctly identifies the repository with the maximum stars rather than the repository with the most likes, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT repository_id FROM likes GROUP BY repository_id ORDER BY COUNT(user_id) DESC LIMIT 1;",
            "SELECT Id FROM Repo WHERE Stars = (SELECT MAX(Stars) FROM Repo)"
        ],
        "rule_sql": []
    },
    "3129": {
        "db_id": "cars",
        "question": "List the names and prices of the cars with model 82 and mileage per gallon of greater than 30.",
        "ground_truth": "SELECT T2.car_name, T1.price FROM price AS T1 INNER JOIN data AS T2 ON T1.ID = T2.ID WHERE T2.model = 82 AND T2.mpg > 30",
        "amends": [
            "Do select `T2.car_name` and `T1.price` instead of `name` and `price` without table qualification. Do add `FROM price AS T1 INNER JOIN data AS T2` instead of `FROM cars` with a single table. Do use `ON T1.ID = T2.ID` to join the tables instead of missing the join condition entirely. Do move the `model = 82` and `mpg > 30` filters to reference `T2` instead of the original table. The amended query now correctly joins the price and data tables to retrieve car names with their corresponding prices while maintaining the same filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, price FROM cars WHERE model = 82 AND mpg > 30;",
            "SELECT T2.car_name, T1.price\nFROM price AS T1\nINNER JOIN data AS T2 ON T1.ID = T2.ID\nWHERE T2.model = 82 AND T2.mpg > 30;"
        ],
        "rule_sql": []
    },
    "8792": {
        "db_id": "food_inspection",
        "question": "Which business had the most number of high risk violations? Give the name of the business.",
        "ground_truth": "SELECT T2.name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.risk_category = 'High Risk' GROUP BY T2.name ORDER BY COUNT(T2.name) DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` from the `businesses` table instead of `business_name` from `violations`. Do add an `INNER JOIN` on `businesses AS T2` with predicate `T1.business_id = T2.business_id` instead of querying only the `violations` table. Do add a `WHERE` filter for `risk_category = 'High Risk'` instead of omitting any filtering. Do add `GROUP BY T2.name` and change the `ORDER BY` to use `COUNT(T2.name) DESC` instead of `violation_count DESC`. The amended query now correctly joins to the businesses table to get the business name, filters for high-risk violations only, groups by business name to count violations per business, and orders by the actual violation count instead of a potentially incorrect column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_name FROM violations ORDER BY violation_count DESC LIMIT 1;",
            "SELECT T2.name\nFROM violations AS T1\nINNER JOIN businesses AS T2 ON T1.business_id = T2.business_id\nWHERE T1.risk_category = 'High Risk'\nGROUP BY T2.name\nORDER BY COUNT(T2.name) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8750": {
        "db_id": "chicago_crime",
        "question": "What is the neighborhood name in the community area of Lake View?",
        "ground_truth": "SELECT T2.neighborhood_name FROM Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.community_area_name = 'Lake View'",
        "amends": [
            "Do join `Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no` instead of querying only `community_areas`. Do select `T2.neighborhood_name` instead of `neighborhood_name` without table qualification. Do filter on `T1.community_area_name = 'Lake View'` instead of `area_name = 'Lake View'`. The amended query now correctly retrieves neighborhood names by joining the appropriate tables and using the correct column names for filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT neighborhood_name FROM community_areas WHERE area_name = 'Lake View';",
            "SELECT T2.neighborhood_name FROM Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.community_area_name = 'Lake View'"
        ],
        "rule_sql": []
    },
    "2702": {
        "db_id": "regional_sales",
        "question": "How many sales channels does the sales team have in the Midwest?",
        "ground_truth": "SELECT COUNT(T1.`Sales Channel`) FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T2.Region = 'Midwest'",
        "amends": [
            "Do select `COUNT(T1.Sales Channel)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do change the FROM source to `Sales Orders AS T1` instead of `sales_team` to access the correct table. Do add `INNER JOIN Sales Team AS T2` instead of querying a single table to properly relate sales data with team information. Do specify the join condition `ON T2.SalesTeamID = T1._SalesTeamID` instead of no join condition to correctly link the tables. Do move the region filter to the joined table as `T2.Region = 'Midwest'` instead of applying it directly to the sales table, ensuring the count reflects sales from the Midwest region team members. The amended query now correctly counts sales channel entries from the Midwest region by properly joining the relevant tables."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales_team WHERE region = 'Midwest';",
            "SELECT COUNT(T1.\"Sales Channel\") \nFROM \"Sales Orders\" AS T1\nINNER JOIN \"Sales Team\" AS T2 ON T2.SalesTeamID = T1._SalesTeamID\nWHERE T2.Region = 'Midwest'"
        ],
        "rule_sql": []
    },
    "4712": {
        "db_id": "disney",
        "question": "Which director had the most popular film from 1937 to 1990?",
        "ground_truth": "SELECT T2.director FROM characters AS T1 INNER JOIN director AS T2 ON T1.movie_title = T2.name INNER JOIN movies_total_gross AS T3 ON T3.movie_title = T1.movie_title WHERE SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date)) BETWEEN '1937' AND '1990' ORDER BY CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "amends": [
            "Do use `T2.director` from the `director` table instead of `director` from an unspecified source. Do join `characters AS T1` and `director AS T2` on `T1.movie_title = T2.name` instead of querying a single `films` table. Do add an additional `INNER JOIN` to `movies_total_gross AS T3` on `T3.movie_title = T1.movie_title` instead of omitting this table. Do filter using `SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date)) BETWEEN '1937' AND '1990'` on the release date instead of a simple `year BETWEEN 1937 AND 1990`. Do order by `CAST(REPLACE(trim(T3.total_gross, '$'), ',', '') AS REAL) DESC` based on processed gross revenue instead of `MAX(popularity) DESC`. Do remove the `GROUP BY director` and `MAX(popularity)` aggregation instead of keeping them. The amended query now correctly joins multiple tables, processes financial data, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT director, MAX(popularity) FROM films WHERE year BETWEEN 1937 AND 1990 GROUP BY director ORDER BY MAX(popularity) DESC LIMIT 1;",
            "SELECT T2.director\nFROM characters AS T1\nINNER JOIN director AS T2 ON T1.movie_title = T2.name\nINNER JOIN movies_total_gross AS T3 ON T3.movie_title = T1.movie_title\nWHERE SUBSTR(T3.release_date, LENGTH(T3.release_date) - 3, LENGTH(T3.release_date)) BETWEEN '1937' AND '1990'\nORDER BY CAST(REPLACE(TRIM(T3.total_gross, '$'), ',', '') AS REAL) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3658": {
        "db_id": "authors",
        "question": "How many papers were published in 2005. Calculate the difference between the number of paper published in 2005 and the number of paper published in the previous year.",
        "ground_truth": "SELECT SUM(CASE WHEN Year = 2005 THEN 1 ELSE 0 END) , SUM(CASE WHEN year = 2005 THEN 1 ELSE 0 END) - SUM(CASE WHEN year = 2004 THEN 1 ELSE 0 END) AS diff FROM Paper",
        "amends": [
            "Do use `SUM(CASE WHEN Year = 2005 THEN 1 ELSE 0 END)` instead of `COUNT(*)` with a `WHERE year = 2005` filter to count 2005 papers. Do calculate the difference as `SUM(CASE WHEN year = 2005 THEN 1 ELSE 0 END) - SUM(CASE WHEN year = 2004 THEN 1 ELSE 0 END)` instead of using a correlated subquery `(SELECT COUNT(*) FROM papers WHERE year = 2004)` within the main query. Do remove the explicit column alias `papers_2005` instead of keeping it, and do use `diff` instead of `difference` for the difference column alias. Do query from `Paper` instead of `papers` table. The amended query now correctly calculates both counts and their difference in a single table scan without subqueries, matching the RIGHT_SQL's behavior.",
            "Do include both individual aggregate columns `SUM(CASE WHEN Year = 2005 THEN 1 ELSE 0 END)` and the calculated difference instead of only showing the difference column. Do maintain consistent case sensitivity with `year` instead of mixing `Year` and `year` in the CASE conditions. Do separate the individual 2005 count from the difference calculation instead of combining them into a single expression. The amended query now correctly displays both the 2005 paper count and the year-over-year difference while maintaining consistent column naming."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(*) AS papers_2005,\n    (SELECT COUNT(*) FROM papers WHERE year = 2004) AS papers_2004,\n    COUNT(*) - (SELECT COUNT(*) FROM papers WHERE year = 2004) AS difference\nFROM papers \nWHERE year = 2005;",
            "SELECT \n    SUM(CASE WHEN Year = 2005 THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN Year = 2004 THEN 1 ELSE 0 END) AS diff\nFROM Paper;",
            "SELECT \n    SUM(CASE WHEN Year = 2005 THEN 1 ELSE 0 END) AS papers_2005,\n    SUM(CASE WHEN Year = 2005 THEN 1 ELSE 0 END) - SUM(CASE WHEN Year = 2004 THEN 1 ELSE 0 END) AS diff\nFROM Paper;"
        ],
        "rule_sql": []
    },
    "3794": {
        "db_id": "public_review_platform",
        "question": "For all the Yelp businesses that allow customers bring their own beer, what percentage of them are in \"Phoenix\"?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.business_id) AS \"percentage\" FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.attribute_name LIKE 'BYOB' AND T2.attribute_value LIKE 'TRUE'",
        "amends": [
            "Do use `SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END)` with explicit `ELSE 0` instead of `COUNT(CASE WHEN city = 'Phoenix' THEN 1 END)` for percentage calculation. Do add explicit `CAST` to `REAL` instead of implicit float conversion. Do join `Attributes`, `Business_Attributes`, and `Business` tables with proper foreign key relationships instead of querying only the `business` table. Do filter on `T1.attribute_name LIKE 'BYOB' AND T2.attribute_value LIKE 'TRUE'` instead of searching for string patterns in a single `attributes` column. Do reference `T3.city` and `T2.business_id` with proper table aliases instead of unqualified column names. The amended query now correctly handles the normalized schema structure and accurately calculates the percentage of Phoenix businesses with BYOB attributes set to TRUE.",
            "Do use `COUNT(T2.business_id)` instead of `COUNT(*)` to avoid counting null business records. Do place the multiplication by 100 after the division instead of before it to ensure correct percentage calculation. Do add explicit `AS` aliases for table references instead of omitting them. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. The amended query now correctly calculates the percentage of Phoenix businesses with BYOB attributes set to TRUE by ensuring proper counting and mathematical operation order.",
            "Do place the multiplication by 100 after the division instead of before it to correctly calculate the percentage. Do add table aliases with `AS` for all tables instead of omitting them. Do remove the unnecessary parentheses around the entire expression instead of keeping them. Do add double quotes around the alias `percentage` instead of leaving it unquoted. The amended query now correctly calculates the percentage of Phoenix businesses with BYOB attribute set to TRUE by performing the division before multiplication.",
            "Do place the multiplication by 100 before the division instead of after it, changing `SUM(...) / COUNT(...) * 100` to `SUM(...) * 100 / COUNT(...)` to correctly calculate the percentage by first scaling the numerator before division. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN city = 'Phoenix' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM business\nWHERE attributes LIKE '%BYOB%' OR attributes LIKE '%bring your own beer%';",
            "SELECT \n    (CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    Attributes T1\n    JOIN Business_Attributes T2 ON T1.attribute_id = T2.attribute_id\n    JOIN Business T3 ON T2.business_id = T3.business_id\nWHERE \n    T1.attribute_name LIKE 'BYOB' \n    AND T2.attribute_value LIKE 'TRUE'",
            "SELECT \n    (CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.business_id)) * 100 AS percentage\nFROM \n    Attributes T1\nINNER JOIN \n    Business_Attributes T2 ON T1.attribute_id = T2.attribute_id\nINNER JOIN \n    Business T3 ON T2.business_id = T3.business_id\nWHERE \n    T1.attribute_name LIKE 'BYOB' \n    AND T2.attribute_value LIKE 'TRUE'",
            "SELECT \n    CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.business_id) * 100 AS \"percentage\"\nFROM \n    Attributes AS T1\n    INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\n    INNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nWHERE \n    T1.attribute_name LIKE 'BYOB' \n    AND T2.attribute_value LIKE 'TRUE'",
            "SELECT \n    CAST(SUM(CASE WHEN T3.city LIKE 'Phoenix' THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(T2.business_id) AS percentage\nFROM \n    Attributes AS T1\n    INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id\n    INNER JOIN Business AS T3 ON T2.business_id = T3.business_id\nWHERE \n    T1.attribute_name LIKE 'BYOB' \n    AND T2.attribute_value LIKE 'TRUE'"
        ],
        "rule_sql": []
    },
    "607": {
        "db_id": "codebase_comments",
        "question": "How many stars does the repository of the solution No. 45997 have?",
        "ground_truth": "SELECT T1.Stars FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Id = 45997",
        "amends": [
            "Do join `Repo AS T1` with `Solution AS T2` on `T1.Id = T2.RepoId` instead of querying `repositories` table directly without any join. Do select `T1.Stars` from the joined tables instead of selecting `stars` from a single table. Do filter on `T2.Id = 45997` in the WHERE clause instead of filtering on `solution_id = 45997` directly in the repositories table. The amended query now correctly retrieves stars from the repository associated with the specified solution ID through the proper table relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stars FROM repositories WHERE solution_id = 45997;",
            "SELECT T1.Stars \nFROM Repo AS T1 \nJOIN Solution AS T2 ON T1.Id = T2.RepoId \nWHERE T2.Id = 45997"
        ],
        "rule_sql": []
    },
    "6111": {
        "db_id": "food_inspection_2",
        "question": "Please list the full names of the sanitarians who did at least one inspection in May, 2010.",
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE strftime('%Y-%m', T2.inspection_date) = '2010-05' AND T1.title = 'Sanitarian'",
        "amends": [
            "Do select `T1.first_name` and `T1.last_name` instead of just `sanitarian_name`. Do add `DISTINCT` instead of omitting it. Do join `employee AS T1` with `inspection AS T2` on `T1.employee_id = T2.employee_id` instead of querying only the `inspections` table. Do filter with `strftime('%Y-%m', T2.inspection_date) = '2010-05'` instead of `LIKE '2010-05%'` for proper date handling. Do add `T1.title = 'Sanitarian'` instead of omitting the title filter. The amended query now correctly identifies sanitarian employees who conducted inspections in May 2010."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sanitarian_name FROM inspections WHERE inspection_date LIKE '2010-05%'",
            "SELECT DISTINCT T1.first_name, T1.last_name\nFROM employee AS T1\nJOIN inspection AS T2 ON T1.employee_id = T2.employee_id\nWHERE T1.title = 'Sanitarian'\nAND strftime('%Y-%m', T2.inspection_date) = '2010-05'"
        ],
        "rule_sql": []
    },
    "3715": {
        "db_id": "college_completion",
        "question": "Tell the abbreviation for \"Delaware\" state.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE WHEN state = 'Delaware' THEN state_abbr ELSE NULL END AS T FROM state_sector_grads ) WHERE T IS NOT NULL",
        "amends": [
            "Do use a subquery with `CASE WHEN state = 'Delaware' THEN state_abbr ELSE NULL END AS T` instead of directly selecting `state_name` from the states table. Do add `DISTINCT` to eliminate duplicates instead of omitting it. Do filter with `WHERE T IS NOT NULL` instead of using `WHERE abbreviation = 'Delaware'`. Do reference the `state_sector_grads` table instead of the `states` table. The amended query now correctly handles the transformation and filtering logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state_name FROM states WHERE abbreviation = 'Delaware';",
            "SELECT DISTINCT \n    CASE WHEN state = 'Delaware' THEN state_abbr ELSE NULL END AS T \nFROM state_sector_grads \nWHERE T IS NOT NULL"
        ],
        "rule_sql": []
    },
    "8706": {
        "db_id": "chicago_crime",
        "question": "In which ward of more than 55,000 inhabitants are there more crimes of intimidation with extortion?",
        "ground_truth": "SELECT T3.ward_no FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN Ward AS T3 ON T3.ward_no = T2.ward_no WHERE T1.primary_description = 'INTIMIDATION' AND T1.secondary_description = 'EXTORTION' AND T3.Population > 55000 GROUP BY T3.ward_no ORDER BY COUNT(T3.ward_no) DESC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` for `IUCR`, `Crime`, and `Ward` tables instead of a single `crimes` table. Do join `IUCR` and `Crime` on `T2.iucr_no = T1.iucr_no` instead of no join condition, and do join `Ward` on `T3.ward_no = T2.ward_no` instead of no ward table. Do filter on `T1.primary_description = 'INTIMIDATION'` and `T1.secondary_description = 'EXTORTION'` instead of `crime_type = 'intimidation with extortion'`. Do move the population filter to `WHERE T3.Population > 55000` instead of `HAVING population > 55000`. Do aggregate with `COUNT(T3.ward_no)` instead of `COUNT(*)` and do order by the count instead of crime_count alias. The amended query now correctly joins the necessary tables, uses proper filtering conditions, and aggregates ward counts appropriately.",
            "Do remove the `COUNT(T3.ward_no) AS crime_count` column from the SELECT list instead of including it. Do change the ORDER BY clause to use `COUNT(T3.ward_no) DESC` instead of ordering by the alias `crime_count`. Do add `LIMIT 1` at the end instead of omitting it to return only the top result. The amended query now matches RIGHT_SQL's behavior by selecting only the ward number and returning the single ward with the highest crime count for the specified crime type in populous wards."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ward, COUNT(*) as crime_count \nFROM crimes \nWHERE crime_type = 'intimidation with extortion' \nGROUP BY ward \nHAVING population > 55000 \nORDER BY crime_count DESC \nLIMIT 1;",
            "SELECT T3.ward_no, COUNT(T3.ward_no) AS crime_count\nFROM IUCR T1\nJOIN Crime T2 ON T2.iucr_no = T1.iucr_no\nJOIN Ward T3 ON T3.ward_no = T2.ward_no\nWHERE T1.primary_description = 'INTIMIDATION' \nAND T1.secondary_description = 'EXTORTION'\nAND T3.Population > 55000\nGROUP BY T3.ward_no\nORDER BY crime_count DESC;",
            "SELECT T3.ward_no\nFROM IUCR T1\nJOIN Crime T2 ON T2.iucr_no = T1.iucr_no\nJOIN Ward T3 ON T3.ward_no = T2.ward_no\nWHERE T1.primary_description = 'INTIMIDATION' \nAND T1.secondary_description = 'EXTORTION'\nAND T3.Population > 55000\nGROUP BY T3.ward_no\nORDER BY COUNT(T3.ward_no) DESC\nLIMIT 1"
        ],
        "rule_sql": []
    },
    "2903": {
        "db_id": "professional_basketball",
        "question": "Which winning team in the 1947 playoff quarterfinals managed to score 3,513 defensive points that same year?",
        "ground_truth": "SELECT T2.tmID FROM series_post AS T1 INNER JOIN teams AS T2 ON T1.tmIDWinner = T2.tmID WHERE T1.year = 1947 AND T1.round = 'QF' AND T2.d_pts = 3513",
        "amends": [
            "Do select `T2.tmID` instead of `team_name` and use table alias `T2` instead of full table name. Do join `series_post AS T1` instead of `playoff_results` and use `INNER JOIN` instead of `JOIN`. Do use join condition `T1.tmIDWinner = T2.tmID` instead of `teams.team_id = playoff_results.team_id`. Do filter on `T1.year = 1947` instead of `playoff_results.year = 1947` and `T1.round = 'QF'` instead of `playoff_results.round = 'quarterfinals'`. Do remove the `playoff_results.winner = 1` condition instead of keeping it. Do filter on `T2.d_pts = 3513` instead of `teams.defensive_points = 3513`. The amended query now correctly identifies the winning team from the 1947 quarterfinals with the specified defensive points."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name \nFROM teams \nJOIN playoff_results ON teams.team_id = playoff_results.team_id \nWHERE playoff_results.year = 1947 \nAND playoff_results.round = 'quarterfinals' \nAND playoff_results.winner = 1 \nAND teams.defensive_points = 3513;",
            "SELECT T2.tmID\nFROM series_post AS T1\nINNER JOIN teams AS T2 ON T1.tmIDWinner = T2.tmID\nWHERE T1.year = 1947\nAND T1.round = 'QF'\nAND T2.d_pts = 3513"
        ],
        "rule_sql": []
    },
    "5876": {
        "db_id": "airline",
        "question": "What is the only flight destination for flights from Albany?",
        "ground_truth": "SELECT DEST FROM Airlines WHERE ORIGIN = 'ABY' GROUP BY DEST",
        "amends": [
            "Do reference table `Airlines` instead of `flights` and use column `DEST` instead of `destination` in the SELECT list. Do use filter condition `ORIGIN = 'ABY'` instead of `origin = 'Albany'` to match the correct airport code format. Do remove the HAVING clause `COUNT(*) > 1` instead of keeping it, as the right query does not include this aggregation filter. The amended query now correctly selects destinations from the Airlines table filtered by origin airport code without unnecessary aggregation constraints."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination FROM flights WHERE origin = 'Albany' GROUP BY destination HAVING COUNT(*) > 1;",
            "SELECT DISTINCT DEST FROM Airlines WHERE ORIGIN = 'ABY'"
        ],
        "rule_sql": []
    },
    "388": {
        "db_id": "retail_complains",
        "question": "In 2012, how many complaints about Credit card product came from clients in Omaha?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'Omaha' AND strftime('%Y', T2.`Date received`) = '2012' AND T2.Product = 'Credit card'",
        "amends": [
            "Do select `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific client records. Do use `FROM client AS T1 INNER JOIN events AS T2` instead of `FROM complaints` to join two tables rather than querying a single table. Do apply join condition `ON T1.client_id = T2.Client_ID` instead of no join condition. Do move the year filter to `strftime('%Y', T2.Date received) = '2012'` instead of `year = 2012` to properly extract year from a date field. Do filter by `T2.Product = 'Credit card'` instead of `product = 'Credit card'` to reference the correct table's product column. Do keep `T1.city = 'Omaha'` but reference it from the client table instead of a complaints table. The amended query now correctly joins client and events tables to count Omaha clients with credit card complaints from 2012, matching the right SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE year = 2012 AND product = 'Credit card' AND city = 'Omaha';",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1 \nINNER JOIN events AS T2 ON T1.client_id = T2.Client_ID \nWHERE strftime('%Y', T2.\"Date received\") = '2012' \nAND T2.Product = 'Credit card' \nAND T1.city = 'Omaha'"
        ],
        "rule_sql": []
    },
    "1283": {
        "db_id": "law_episode",
        "question": "How many episodes are there in the 9th season of Law and Order? Calculate the average number of casts per season of the said series.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.season = 9 THEN 1 ELSE 0 END) AS num , CAST(SUM(CASE WHEN T2.season = 9 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.episode_id) FROM Credit AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.category = 'Cast' AND T2.series = 'Law and Order'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.season = 9 THEN 1 ELSE 0 END)` for counting season 9 episodes instead of `COUNT(*)` across all seasons. Do calculate the ratio of season 9 episodes to total cast credits using `CAST(SUM(...) AS REAL) / COUNT(T1.episode_id)` instead of averaging season averages. Do join `Credit` table with `Episode` table on `T1.episode_id = T2.episode_id` instead of self-joining episodes. Do filter on `T1.category = 'Cast'` instead of omitting category filtering. Do use `T2.series = 'Law and Order'` instead of `series_name` column name. Do remove the subquery calculating season averages and the GROUP BY clause instead of keeping the nested aggregation. The amended query now correctly counts cast appearances for season 9 and calculates the proper ratio against total cast credits across all seasons, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS episode_count, AVG(season_avg_casts) AS avg_casts_per_season\nFROM episodes e\nJOIN (\n    SELECT season_number, AVG(CAST(episode_count AS FLOAT)) AS season_avg_casts\n    FROM episodes\n    WHERE series_name = 'Law and Order'\n    GROUP BY season_number\n) s ON e.season_number = s.season_number\nWHERE e.series_name = 'Law and Order' AND e.season_number = 9;",
            "SELECT \n    SUM(CASE WHEN T2.season = 9 THEN 1 ELSE 0 END) AS season_9_episodes,\n    CAST(SUM(CASE WHEN T2.season = 9 THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.episode_id) AS avg_casts_per_season\nFROM Credit T1\nJOIN Episode T2 ON T1.episode_id = T2.episode_id\nWHERE T1.category = 'Cast' AND T2.series = 'Law and Order'"
        ],
        "rule_sql": []
    },
    "3263": {
        "db_id": "donor",
        "question": "Which cities in the Los Angeles Unified School District has bought supplies from Quill.com?",
        "ground_truth": "SELECT T2.school_city FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_district = 'Los Angeles Unif Sch Dist' AND T1.vendor_name = 'Quill.com'",
        "amends": [
            "Do select `T2.school_city` instead of `city`. Do use `resources AS T1` and `projects AS T2` as FROM sources instead of `purchases`. Do add `INNER JOIN` on `T1.projectid = T2.projectid` instead of no join. Do filter on `T2.school_district = 'Los Angeles Unif Sch Dist'` instead of `district = 'Los Angeles Unified School District'`. Do filter on `T1.vendor_name = 'Quill.com'` instead of `supplier = 'Quill.com'`. The amended query now correctly joins the resources and projects tables to retrieve school city information with the proper district abbreviation and vendor name filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM purchases WHERE district = 'Los Angeles Unified School District' AND supplier = 'Quill.com';",
            "SELECT DISTINCT T2.school_city\nFROM resources AS T1\nINNER JOIN projects AS T2 ON T1.projectid = T2.projectid\nWHERE T2.school_district = 'Los Angeles Unif Sch Dist'\nAND T1.vendor_name = 'Quill.com'"
        ],
        "rule_sql": []
    },
    "7628": {
        "db_id": "hockey",
        "question": "Name the goalie and the season he played where he had 5% shutouts among the number of goals recorded while the goalie was on the ice.",
        "ground_truth": "SELECT DISTINCT T1.firstName, T1.lastName, T2.year FROM Master AS T1 INNER JOIN ( SELECT playerID, year FROM Goalies WHERE CAST(SHO AS REAL) / GA > 0.05 ) AS T2 ON T2.playerID = T1.playerID",
        "amends": [
            "Do select `firstName` and `lastName` from the `Master` table instead of `goalie_name` from `goalie_stats`, and add `year` instead of `season`. Do use a subquery to filter `Goalies` where `CAST(SHO AS REAL) / GA > 0.05` instead of directly filtering `(shutouts / goals_against) = 0.05` in the WHERE clause. Do perform an `INNER JOIN` between `Master` and the subquery on `playerID` instead of querying only the `goalie_stats` table. Do add `DISTINCT` to eliminate duplicate rows instead of omitting it. Do use proper column names `SHO` and `GA` with explicit casting to `REAL` for division instead of assuming numeric types. The amended query now correctly identifies players with shutout ratios exceeding 0.05 and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT goalie_name, season \nFROM goalie_stats \nWHERE (shutouts / goals_against) = 0.05;",
            "SELECT DISTINCT m.firstName, m.lastName, g.year\nFROM Master m\nINNER JOIN (\n    SELECT playerID, year\n    FROM Goalies\n    WHERE CAST(SHO AS REAL) / CAST(GA AS REAL) > 0.05\n) g ON m.playerID = g.playerID;"
        ],
        "rule_sql": []
    },
    "812": {
        "db_id": "social_media",
        "question": "What is the percentage of male Twitter users from Florida?",
        "ground_truth": "SELECT SUM(CASE WHEN T3.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID) AS percentage FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID INNER JOIN user AS T3 ON T3.UserID = T1.UserID WHERE T2.State = 'Florida'",
        "amends": [
            "Do use `SUM(CASE WHEN T3.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE state = 'Florida')` for calculating the percentage. Do join `twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID` and `INNER JOIN user AS T3 ON T3.UserID = T1.UserID` instead of querying only the `users` table. Do filter with `T2.State = 'Florida'` instead of `state = 'Florida'` in a subquery. Do reference `T3.Gender = 'Male'` instead of `gender = 'male'` for the gender condition. The amended query now correctly calculates the percentage of male users among Florida Twitter users by properly joining the relevant tables and using appropriate aggregation logic.",
            "Do use `percentage` as the alias instead of `percentage_male` and remove the multiplication by `100.0` instead of keeping it, which changes the calculation from a percentage to a proportion. Do maintain the same `SELECT` list structure with `SUM(CASE WHEN T3.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID)` instead of altering the aggregation logic. Do preserve the identical `FROM` clause with `twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID INNER JOIN user AS T3 ON T3.UserID = T1.UserID` instead of modifying the join conditions or tables. Do keep the same `WHERE` filter `T2.State = 'Florida'` instead of changing the filtering criteria. The amended query now correctly calculates the proportion of male users rather than a percentage, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users WHERE state = 'Florida')) AS percentage FROM users WHERE gender = 'male';",
            "SELECT \n    (SUM(CASE WHEN T3.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID)) * 100.0 AS percentage_male\nFROM \n    twitter AS T1 \n    INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID\n    INNER JOIN user AS T3 ON T3.UserID = T1.UserID\nWHERE \n    T2.State = 'Florida';",
            "SELECT SUM(CASE WHEN T3.Gender = 'Male' THEN 1.0 ELSE 0 END) / COUNT(T1.TweetID) AS percentage\nFROM twitter AS T1 \nINNER JOIN location AS T2 ON T2.LocationID = T1.LocationID \nINNER JOIN user AS T3 ON T3.UserID = T1.UserID\nWHERE T2.State = 'Florida'"
        ],
        "rule_sql": []
    },
    "8038": {
        "db_id": "university",
        "question": "In which nation is Harvard University located?",
        "ground_truth": "SELECT T2.country_name FROM university AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE T1.university_name = 'Harvard University'",
        "amends": [
            "Do select `T2.country_name` instead of `nation` to use the correct column name from the joined table. Do use `university AS T1 INNER JOIN country AS T2` instead of just `universities` to properly join the tables with explicit aliases. Do specify the join condition `ON T1.country_id = T2.id` instead of omitting it to establish the correct relationship between tables. Do filter on `T1.university_name = 'Harvard University'` instead of `name` to use the correct column name from the university table. The amended query now correctly retrieves the country name through proper table joins and column references."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nation FROM universities WHERE name = 'Harvard University';",
            "SELECT T2.country_name FROM university AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE T1.university_name = 'Harvard University'"
        ],
        "rule_sql": []
    },
    "4388": {
        "db_id": "student_loan",
        "question": "How many months has student217 been absent?",
        "ground_truth": "SELECT month FROM longest_absense_from_school WHERE name = 'student217'",
        "amends": [
            "Do select `month` instead of `COUNT(*)` and change the source table to `longest_absense_from_school` instead of `attendance`. Do remove the `status = 'absent'` filter instead of keeping it, as the new table specifically tracks absence data. The amended query now correctly retrieves the month of longest absence for the specified student instead of counting absence occurrences."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM attendance WHERE student_id = 'student217' AND status = 'absent';",
            "SELECT month FROM longest_absense_from_school WHERE name = 'student217'"
        ],
        "rule_sql": []
    },
    "3732": {
        "db_id": "college_completion",
        "question": "Among the race of all students, what is the control of institution and level of institution with highest number of students?",
        "ground_truth": "SELECT DISTINCT T1.control, T1.level FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.race = 'X' AND T1.student_count = ( SELECT MAX(T1.student_count) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T2.race = 'X' )",
        "amends": [
            "Do use `SELECT DISTINCT T1.control, T1.level` instead of `SELECT race, control_of_institution, level_of_institution, COUNT(*) as student_count`. Do join `institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid` instead of querying only `FROM students`. Do add `WHERE T2.race = 'X'` filter instead of omitting race filtering. Do use a subquery with `MAX(T1.student_count)` comparison instead of `GROUP BY race` with `COUNT(*)`. Do remove the explicit `ORDER BY student_count DESC LIMIT 1` instead of keeping it, as the maximum comparison handles the ranking logic. The amended query now correctly identifies the institution control and level with maximum student count for race 'X' instead of counting all races without proper filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT race, control_of_institution, level_of_institution, COUNT(*) as student_count\nFROM students\nGROUP BY race\nORDER BY student_count DESC\nLIMIT 1;",
            "SELECT DISTINCT T1.control, T1.level\nFROM institution_details AS T1\nINNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid\nWHERE T2.race = 'X'\nAND T1.student_count = (SELECT MAX(student_count) FROM institution_details WHERE unitid IN (SELECT unitid FROM institution_grads WHERE race = 'X'))"
        ],
        "rule_sql": []
    },
    "3486": {
        "db_id": "video_games",
        "question": "Give the game name of the game ID 44.",
        "ground_truth": "SELECT T.game_name FROM game AS T WHERE T.id = 44",
        "amends": [
            "Do use table alias `T` for the `game` table instead of omitting it. Do reference column as `T.game_name` instead of just `game_name`. Do use correct table name `game` instead of `games`. Do filter on `T.id = 44` instead of `game_id = 44` to use the correct column name. The amended query now correctly selects from the `game` table using proper aliasing and references the appropriate primary key column for filtering."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE game_id = 44;",
            "SELECT T.game_name FROM game T WHERE T.id = 44"
        ],
        "rule_sql": []
    },
    "1214": {
        "db_id": "talkingdata",
        "question": "Locate all events on devices of women under 30 years old.",
        "ground_truth": "SELECT T1.device_id FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE T1.gender = 'F' AND T1.age < 30",
        "amends": [
            "Do select `T1.device_id` instead of `*` to specify the exact column needed. Do use table `gender_age AS T1` instead of `events` to access the correct source with gender and age data. Do add `INNER JOIN events_relevant AS T2` instead of omitting it to incorporate the required events data. Do use join condition `T1.device_id = T2.device_id` instead of no join to properly link the tables. Do reference `T1.gender` instead of just `gender` to qualify the column with its table alias. Do use gender value `'F'` instead of `'female'` to match the correct data format. Do reference `T1.age` instead of just `age` to qualify the column with its table alias. The amended query now correctly joins the necessary tables and filters on the appropriate columns to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM events WHERE gender = 'female' AND age < 30",
            "SELECT T1.device_id\nFROM gender_age AS T1\nINNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id\nWHERE T1.gender = 'F' AND T1.age < 30"
        ],
        "rule_sql": []
    },
    "2443": {
        "db_id": "superstore",
        "question": "How many orders were made by customers who live in Texas at the Central superstore?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.`Order ID`) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T1.State = 'Texas'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.Order ID)` instead of `COUNT(*)` to count unique orders. Do join `people AS T1` instead of `customers c` and `central_superstore AS T2` instead of both `orders o` and `stores s`. Do use `INNER JOIN` on `T1.Customer ID = T2.Customer ID` instead of separate joins on `o.customer_id = c.customer_id` and `o.store_id = s.store_id`. Do filter with `T1.State = 'Texas'` instead of `c.state = 'Texas' AND s.store_name = 'Central'`, removing the store filter entirely. The amended query now correctly counts distinct orders from Texas customers in the central superstore, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nJOIN stores s ON o.store_id = s.store_id\nWHERE c.state = 'Texas' AND s.store_name = 'Central'",
            "SELECT COUNT(DISTINCT T2.\"Order ID\") \nFROM people AS T1 \nINNER JOIN central_superstore AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" \nWHERE T1.State = 'Texas'"
        ],
        "rule_sql": []
    },
    "3465": {
        "db_id": "video_games",
        "question": "List down the platform IDs of the games released in 2007.",
        "ground_truth": "SELECT DISTINCT T.platform_id FROM game_platform AS T WHERE T.release_year = 2007",
        "amends": [
            "Do select `DISTINCT T.platform_id` instead of `platform_id` without distinct. Do reference table `game_platform AS T` instead of `games`. Do use qualified column `T.release_year` instead of unqualified `release_year`. The amended query now correctly returns unique platform IDs from the game_platform table for the specified release year."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform_id FROM games WHERE release_year = 2007;",
            "SELECT DISTINCT T.platform_id FROM game_platform AS T WHERE T.release_year = 2007"
        ],
        "rule_sql": []
    },
    "259": {
        "db_id": "retail_complains",
        "question": "Which state does the owner of \"wyatt.collins@gmail.com\" live in? Give the full name of the state.",
        "ground_truth": "SELECT T1.state FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.email = 'wyatt.collins@gmail.com'",
        "amends": [
            "Do select `T1.state` from the `client` table instead of `state` from the `owners` table. Do join `district AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only the `owners` table without any joins. Do filter on `T1.email` instead of `email` from the original table. The amended query now correctly retrieves state information by joining client and district tables based on the proper relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM owners WHERE email = 'wyatt.collins@gmail.com';",
            "SELECT T2.state_abbrev \nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.email = 'wyatt.collins@gmail.com'"
        ],
        "rule_sql": []
    },
    "1103": {
        "db_id": "talkingdata",
        "question": "How many users installed the app but are not active?",
        "ground_truth": "SELECT COUNT(app_id) FROM app_events WHERE is_installed = 1 AND is_active = 0",
        "amends": [
            "Do query the `app_events` table instead of the `users` table. Do count `app_id` instead of using `COUNT(*)`. Do use the `is_installed` column instead of `installed` for the installation status filter. Do filter for `is_active = 0` instead of `active = 1` to count inactive rather than active records. The amended query now correctly counts inactive installed applications from the app_events table, matching the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE installed = 1 AND active = 1;",
            "SELECT COUNT(app_id) FROM app_events WHERE is_installed = 1 AND is_active = 0"
        ],
        "rule_sql": []
    },
    "9149": {
        "db_id": "movie_3",
        "question": "Tell the special features of the film Uprising Uptown.",
        "ground_truth": "SELECT special_features FROM film WHERE title = 'UPRISING UPTOWN'",
        "amends": [
            "Do select only `special_features` instead of both `title` and `special_features`. Do use case-insensitive comparison `'UPRISING UPTOWN'` instead of case-sensitive `'Uprising Uptown'` to ensure proper matching regardless of case variations in the data. The amended query now correctly returns only the special_features column for films with the specified title while handling case sensitivity appropriately."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, special_features FROM film WHERE title = 'Uprising Uptown';",
            "SELECT special_features FROM film WHERE UPPER(title) = 'UPRISING UPTOWN';"
        ],
        "rule_sql": []
    },
    "7902": {
        "db_id": "world",
        "question": "What are the official languages of the country where you can find the city with the least population?",
        "ground_truth": "SELECT T2.Language FROM City AS T1 INNER JOIN CountryLanguage AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.IsOfficial = 'T' ORDER BY T1.Population ASC LIMIT 1",
        "amends": [
            "Do use `T2.Language` instead of `l.Language` for the SELECT list. Do join `City AS T1` and `CountryLanguage AS T2` instead of including the `Country` table. Do use `T1.CountryCode = T2.CountryCode` for the join condition instead of multiple joins through the Country table. Do move the population filter to `ORDER BY T1.Population ASC LIMIT 1` instead of using a subquery with `MIN(Population)`. Do keep the `T2.IsOfficial = 'T'` filter in the WHERE clause instead of changing it. Do add `ORDER BY T1.Population ASC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly finds the official language of the city with the smallest population."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT l.Language \nFROM Country c\nJOIN City ct ON c.Code = ct.CountryCode\nJOIN CountryLanguage l ON c.Code = l.CountryCode\nWHERE ct.Population = (SELECT MIN(Population) FROM City)\nAND l.IsOfficial = 'T';",
            "SELECT T2.Language \nFROM City AS T1 \nJOIN CountryLanguage AS T2 ON T1.CountryCode = T2.CountryCode \nWHERE T2.IsOfficial = 'T' \nORDER BY T1.Population ASC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "8341": {
        "db_id": "mondial_geo",
        "question": "Name the river at Little Rock city. State the length of the river.",
        "ground_truth": "SELECT T3.Length FROM city AS T1 INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE T1.Name = 'Little Rock'",
        "amends": [
            "Do select `T3.Length` instead of `river.name, river.length`. Do use `city AS T1` instead of `city` and add `located AS T2` and `river AS T3` instead of just `river`. Do perform `INNER JOIN located AS T2 ON T1.Name = T2.City` and `INNER JOIN river AS T3 ON T3.Name = T2.River` instead of `JOIN city ON river.city_id = city.id`. Do keep the filter `WHERE T1.Name = 'Little Rock'` but apply it to the city table instead of directly joining on city. The amended query now correctly joins through the located table to find rivers associated with Little Rock and returns only the river length, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT river.name, river.length FROM river JOIN city ON river.city_id = city.id WHERE city.name = 'Little Rock';",
            "SELECT T3.Length FROM city AS T1 INNER JOIN located AS T2 ON T1.Name = T2.City INNER JOIN river AS T3 ON T3.Name = T2.River WHERE T1.Name = 'Little Rock'"
        ],
        "rule_sql": []
    },
    "4877": {
        "db_id": "legislator",
        "question": "What are the Wikipedia page names of all the anti-administration senators?",
        "ground_truth": "SELECT T1.wikipedia_id FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'sen' AND T2.party = 'Anti-Administration'",
        "amends": [
            "Do select `T1.wikipedia_id` instead of `name` and change the data source to use `historical AS T1` instead of `wikipedia_pages`. Do add an `INNER JOIN` with `historical-terms AS T2` on `T1.bioguide_id = T2.bioguide` instead of no join. Do change the filter to use `T2.type = 'sen' AND T2.party = 'Anti-Administration'` instead of `senator_type = 'anti-administration'`, moving from a single table condition to joined table conditions. The amended query now correctly joins historical data with term information to identify Anti-Administration senators and retrieves the appropriate Wikipedia identifier, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM wikipedia_pages WHERE senator_type = 'anti-administration'",
            "SELECT T1.wikipedia_id FROM historical AS T1 INNER JOIN \"historical-terms\" AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'sen' AND T2.party = 'Anti-Administration'"
        ],
        "rule_sql": []
    },
    "6193": {
        "db_id": "food_inspection_2",
        "question": "Write down the last name of employee who did inspection ID 52238?",
        "ground_truth": "SELECT T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_id = 52238",
        "amends": [
            "Do select `T1.last_name` instead of `first_name` and do add table alias `T1` instead of omitting it. Do add `INNER JOIN inspection AS T2` instead of querying only the employees table. Do add join condition `ON T1.employee_id = T2.employee_id` instead of missing the table relationship. Do keep the filter on `inspection_id = 52238` but apply it to `T2.inspection_id` instead of the base table. The amended query now correctly retrieves the last name by joining the employee and inspection tables and filtering on the inspection ID."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE inspection_id = 52238;",
            "SELECT T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_id = 52238"
        ],
        "rule_sql": []
    },
    "2460": {
        "db_id": "superstore",
        "question": "Among the customers from Indiana, what is the percentage of their purchased orders in the Central region with no discount?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN T2.Discount = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` WHERE T2.Region = 'Central' AND T1.State = 'Indiana'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.Discount = 0 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN o.region = 'Central' AND o.discount = 0 THEN 1 END)` for conditional counting. Do reference `central_superstore` as T2 instead of `orders` as o for the main table. Do reference `people` as T1 instead of `customers` as c for the customer table. Do use `T1.`Customer ID` = T2.`Customer ID`` instead of `o.customer_id = c.customer_id` for the join condition. Do move the `Region = 'Central'` filter from the CASE condition to the WHERE clause instead of keeping it in the conditional expression. Do add explicit `CAST` to `REAL` instead of using implicit `100.0` for floating-point division. Do use `T1.State = 'Indiana'` instead of `c.state = 'Indiana'` for the state filter. The amended query now correctly calculates the percentage of orders without discount for Central region customers from Indiana."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN o.region = 'Central' AND o.discount = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE c.state = 'Indiana';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.Discount = 0 THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(*) AS REAL) * 100.0 AS percentage\nFROM \n    people T1\nJOIN \n    central_superstore T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" AND T1.Region = T2.Region\nWHERE \n    T1.State = 'Indiana' AND T2.Region = 'Central'"
        ],
        "rule_sql": []
    },
    "8100": {
        "db_id": "university",
        "question": "Which ranking system is criteria \"Total Shanghai\" in?",
        "ground_truth": "SELECT T1.system_name FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T2.criteria_name = 'Total Shanghai'",
        "amends": [
            "Do select `system_name` from table `ranking_system` instead of `ranking_system` from table `criteria`. Do join `ranking_criteria` with `ranking_system` using `ON T1.id = T2.ranking_system_id` instead of querying a single table. Do filter on `criteria_name` in the joined `ranking_criteria` table instead of in a standalone `criteria` table. The amended query now correctly retrieves the system name by joining the appropriate tables through their relationship."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_system FROM criteria WHERE criteria_name = 'Total Shanghai';",
            "SELECT rs.system_name \nFROM ranking_system rs\nJOIN ranking_criteria rc ON rs.id = rc.ranking_system_id\nWHERE rc.criteria_name = 'Total Shanghai';"
        ],
        "rule_sql": []
    },
    "8008": {
        "db_id": "university",
        "question": "Give the year where a university had the lowest number of students.",
        "ground_truth": "SELECT year FROM university_year ORDER BY num_students ASC LIMIT 1",
        "amends": [
            "Do select from `university_year` table instead of `universities` table. Do order by `num_students` column instead of `students` column. Do use `ASC` sort order instead of `DESC` sort order. The amended query now correctly retrieves data from the appropriate table with the correct column name and sort direction to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM universities ORDER BY students DESC LIMIT 1;",
            "SELECT year FROM university_year ORDER BY num_students ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7806": {
        "db_id": "hockey",
        "question": "List down the first name of coaches who still coach after year 2000.",
        "ground_truth": "SELECT DISTINCT T1.firstName FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE T2.year > 2000",
        "amends": [
            "Do use `DISTINCT T1.firstName` instead of `first_name` to select unique first names from the Master table. Do join `Master AS T1 INNER JOIN Coaches AS T2` instead of querying only the `coaches` table to properly relate coach information. Do apply the join condition `ON T1.coachID = T2.coachID` instead of omitting any relationship between tables. Do keep the filter `T2.year > 2000` but apply it to the Coaches table instead of an unspecified source. The amended query now correctly retrieves unique coach first names by properly joining the Master and Coaches tables with the appropriate relationship and filtering logic."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM coaches WHERE year > 2000;",
            "SELECT DISTINCT T1.firstName\nFROM Master AS T1\nINNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID\nWHERE T2.year > 2000"
        ],
        "rule_sql": []
    },
    "227": {
        "db_id": "book_publishing_company",
        "question": "How many sales did the store in Remulade make?",
        "ground_truth": "SELECT COUNT(T1.ord_num) FROM sales AS T1 INNER JOIN stores AS T2 ON T1.stor_id = T2.stor_id WHERE T2.city = 'Remulade'",
        "amends": [
            "Do join `stores` table via `INNER JOIN` on `T1.stor_id = T2.stor_id` instead of querying only the `sales` table. Do filter on `T2.city = 'Remulade'` instead of incorrectly filtering on `store_name = 'Remulade'` which doesn't exist in the sales table. Do count `T1.ord_num` instead of counting all rows with `COUNT(*)`. The amended query now correctly counts orders from stores located in Remulade city rather than attempting to filter on a non-existent column."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE store_name = 'Remulade';",
            "SELECT COUNT(s.ord_num) \nFROM sales s\nINNER JOIN stores st ON s.stor_id = st.stor_id\nWHERE st.city = 'Remulade'"
        ],
        "rule_sql": []
    },
    "3492": {
        "db_id": "video_games",
        "question": "Provide the name of game produced by 505 Games in 2006.",
        "ground_truth": "SELECT T3.game_name FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN publisher AS T4 ON T2.publisher_id = T4.id WHERE T4.publisher_name = '505 Games' AND T1.release_year = 2006",
        "amends": [
            "Do select `T3.game_name` instead of `name` to use the correct column from the game table. Do join multiple tables including `game_platform AS T1`, `game_publisher AS T2`, `game AS T3`, and `publisher AS T4` instead of querying a single `games` table. Do use `INNER JOIN` with proper join conditions `T1.game_publisher_id = T2.id`, `T2.game_id = T3.id`, and `T2.publisher_id = T4.id` instead of no joins. Do filter on `T4.publisher_name = '505 Games'` instead of `publisher = '505 Games'` to use the correct publisher name column. Do filter on `T1.release_year = 2006` instead of `year = 2006` to use the correct year column from the appropriate table. The amended query now correctly joins the necessary tables to find games published by 505 Games in 2006, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE publisher = '505 Games' AND year = 2006;",
            "SELECT T3.game_name\nFROM game_platform AS T1\nINNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id\nINNER JOIN game AS T3 ON T2.game_id = T3.id\nINNER JOIN publisher AS T4 ON T2.publisher_id = T4.id\nWHERE T4.publisher_name = '505 Games'\nAND T1.release_year = 2006"
        ],
        "rule_sql": []
    },
    "14": {
        "db_id": "movie_platform",
        "question": "What is the percentage of rated movies were released in year 2021?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.movie_release_year = 2021 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM movies AS T1 INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id",
        "amends": [
            "Do use `SUM(CASE WHEN T1.movie_release_year = 2021 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN release_year = 2021 THEN 1 END)` to properly count 2021 movies with 1s and 0s. Do add explicit `CAST(... AS REAL)` instead of implicit decimal conversion. Do change from `rating IS NOT NULL` filter to `INNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id` instead of omitting the join, ensuring we only count movies that have ratings. Do use table alias `T1` for movies and reference `movie_release_year` instead of `release_year`. Do remove the percentage calculation parentheses and use proper division order instead of the original grouping. The amended query now correctly calculates the percentage of 2021 movies that have ratings by joining with the ratings table.",
            "Do place the multiplication by 100 after the division instead of before it, changing `(CAST(SUM(CASE WHEN T1.movie_release_year = 2021 THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100` to `CAST(SUM(CASE WHEN T1.movie_release_year = 2021 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)` to ensure correct mathematical order of operations. Do remove the alias `percentage_2021_movies` instead of keeping it for a more concise result. The amended query now correctly calculates the percentage by first multiplying the count of 2021 movies by 100 before dividing by the total count, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN release_year = 2021 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM movies\nWHERE rating IS NOT NULL;",
            "SELECT \n    (CAST(SUM(CASE WHEN T1.movie_release_year = 2021 THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 AS percentage_2021_movies\nFROM \n    movies AS T1\nINNER JOIN \n    ratings AS T2 ON T1.movie_id = T2.movie_id",
            "SELECT CAST(SUM(CASE WHEN T1.movie_release_year = 2021 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM movies AS T1 \nINNER JOIN ratings AS T2 ON T1.movie_id = T2.movie_id;"
        ],
        "rule_sql": []
    },
    "5250": {
        "db_id": "beer_factory",
        "question": "What is the average number of root beers of the brand A&W sold in a day in August, 2014?",
        "ground_truth": "SELECT CAST(COUNT(T1.BrandID) AS REAL) / 31 FROM rootbeer AS T1 INNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE T2.TransactionDate LIKE '2014-08%' AND T3.BrandName = 'A&W'",
        "amends": [
            "Do use `CAST(COUNT(T1.BrandID) AS REAL) / 31` instead of `AVG(quantity)` for calculating daily average. Do change FROM sources to `rootbeer AS T1 INNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID` instead of a single `sales` table. Do modify WHERE filters to `T2.TransactionDate LIKE '2014-08%' AND T3.BrandName = 'A&W'` instead of `brand = 'A&W' AND month = 'August' AND year = 2014`. Do add proper table joins through `T1.RootBeerID = T2.RootBeerID` and `T1.BrandID = T3.BrandID` instead of missing relationship definitions. The amended query now correctly calculates the daily average count for August 2014 by properly joining the relevant tables and using appropriate date filtering.",
            "Do use the same SELECT clause with `CAST(COUNT(T1.BrandID) AS REAL) / 31` instead of adding an alias `average_daily_sales`. Do maintain the same FROM sources with `rootbeer AS T1 INNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID` instead of changing any join conditions. Do preserve the identical WHERE filters with `T2.TransactionDate LIKE '2014-08%' AND T3.BrandName = 'A&W'` instead of modifying any predicate logic. The amended query now matches RIGHT_SQL's behavior by removing the unnecessary column alias while maintaining all functional components.",
            "Do use backticks around the reserved keyword `transaction` in the FROM clause instead of leaving it unquoted. The amended query now correctly handles the reserved word and matches the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(quantity) FROM sales WHERE brand = 'A&W' AND month = 'August' AND year = 2014",
            "SELECT CAST(COUNT(T1.BrandID) AS REAL) / 31 AS average_daily_sales\nFROM rootbeer AS T1 \nINNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID \nINNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID\nWHERE T2.TransactionDate LIKE '2014-08%' \nAND T3.BrandName = 'A&W'",
            "SELECT CAST(COUNT(T1.BrandID) AS REAL) / 31 \nFROM rootbeer AS T1 \nINNER JOIN transaction AS T2 ON T1.RootBeerID = T2.RootBeerID \nINNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID \nWHERE T2.TransactionDate LIKE '2014-08%' AND T3.BrandName = 'A&W'",
            "SELECT CAST(COUNT(T1.BrandID) AS REAL) / 31\nFROM rootbeer AS T1 \nINNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID \nINNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID\nWHERE T2.TransactionDate LIKE '2014-08%' AND T3.BrandName = 'A&W'"
        ],
        "rule_sql": []
    },
    "1980": {
        "db_id": "soccer_2016",
        "question": "How many matches did the Sunrisers Hyderabad team win in 2013?",
        "ground_truth": "SELECT SUM(CASE WHEN Match_Date LIKE '2013%' THEN 1 ELSE 0 END) FROM `Match` AS T1 INNER JOIN Team AS T2 ON T1.Match_Winner = T2.Team_Id WHERE T2.Team_Name = 'Sunrisers Hyderabad'",
        "amends": [
            "Do use `SUM(CASE WHEN Match_Date LIKE '2013%' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only 2013 matches. Do join `Match` table with `Team` table using `INNER JOIN` on `Match_Winner = Team_Id` instead of querying a single table. Do filter by `Team_Name = 'Sunrisers Hyderabad'` in the `WHERE` clause instead of directly filtering by winner name. Do check for the year 2013 using `Match_Date LIKE '2013%'` in a conditional expression instead of a direct `season = 2013` filter. The amended query now correctly handles team identification through proper table joins and date-based filtering to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE winner = 'Sunrisers Hyderabad' AND season = 2013;",
            "SELECT SUM(CASE WHEN m.Match_Date LIKE '2013%' THEN 1 ELSE 0 END) AS matches_won\nFROM Match m\nINNER JOIN Team t ON m.Match_Winner = t.Team_Id\nWHERE t.Team_Name = 'Sunrisers Hyderabad';"
        ],
        "rule_sql": []
    },
    "8705": {
        "db_id": "chicago_crime",
        "question": "What types of domestic crimes have occurred the most in the North Lawndale community?",
        "ground_truth": "SELECT T2.domestic FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no WHERE T1.community_area_name = 'North Lawndale' AND T2.domestic = 'TRUE' GROUP BY T2.domestic ORDER BY COUNT(T2.domestic) DESC LIMIT 1",
        "amends": [
            "Do select `T2.domestic` instead of `crime_type` and `COUNT(*)`. Do use `Community_Area AS T1` and `Crime AS T2` tables instead of just `crimes`. Do perform `INNER JOIN` on `T2.community_area_no = T1.community_area_no` instead of filtering by community area name directly. Do filter with `T1.community_area_name = 'North Lawndale'` and `T2.domestic = 'TRUE'` instead of `community_area = 'North Lawndale'` and `crime_type LIKE '%domestic%'`. Do group by `T2.domestic` instead of `crime_type`. Do order by `COUNT(T2.domestic)` instead of `count`. The amended query now correctly joins the community area and crime tables, filters for domestic crimes specifically using the boolean domestic field, and matches the RIGHT_SQL's behavior.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the domestic value. Do add `LIMIT 1` at the end instead of omitting it, to ensure only the top result is returned when ordering by count. The amended query now correctly returns just the domestic value with a limit of 1, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT crime_type, COUNT(*) as count \nFROM crimes \nWHERE community_area = 'North Lawndale' \nAND crime_type LIKE '%domestic%' \nGROUP BY crime_type \nORDER BY count DESC \nLIMIT 1;",
            "SELECT T2.domestic, COUNT(*) \nFROM Community_Area AS T1 \nINNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no \nWHERE T1.community_area_name = 'North Lawndale' AND T2.domestic = 'TRUE' \nGROUP BY T2.domestic \nORDER BY COUNT(T2.domestic) DESC;",
            "SELECT T2.domestic \nFROM Community_Area AS T1 \nINNER JOIN Crime AS T2 ON T2.community_area_no = T1.community_area_no \nWHERE T1.community_area_name = 'North Lawndale' \nAND T2.domestic = 'TRUE' \nGROUP BY T2.domestic \nORDER BY COUNT(T2.domestic) DESC \nLIMIT 1"
        ],
        "rule_sql": []
    },
    "3123": {
        "db_id": "cars",
        "question": "Provide the name and model of the car with the highest price.",
        "ground_truth": "SELECT T1.car_name, T1.model FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY T2.price DESC LIMIT 1",
        "amends": [
            "Do select `T1.car_name` and `T1.model` instead of `name` and `model`. Do add `FROM data AS T1 INNER JOIN price AS T2` instead of omitting the join and using only `cars`. Do add join condition `ON T1.ID = T2.ID` instead of having no join predicate. Do order by `T2.price DESC` instead of `price ASC`. The amended query now correctly joins the data and price tables to access the price column and sorts in descending order to find the highest-priced car, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, model FROM cars ORDER BY price ASC LIMIT 1;",
            "SELECT T1.car_name, T1.model FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID ORDER BY T2.price DESC LIMIT 1"
        ],
        "rule_sql": []
    },
    "8889": {
        "db_id": "cookbook",
        "question": "What is the average calorie count for all recipes using coarsely ground black pepper?",
        "ground_truth": "SELECT AVG(T3.calories) FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id INNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id WHERE T1.name = 'coarsely ground black pepper'",
        "amends": [
            "Do use explicit table joins with `Ingredient AS T1 INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id INNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id` instead of querying a single `recipes` table. Do filter on `T1.name = 'coarsely ground black pepper'` instead of using `LIKE '%black pepper%'` for more precise ingredient matching. Do reference `AVG(T3.calories)` from the Nutrition table instead of `AVG(calories)` from an unspecified source. The amended query now correctly calculates average calories for recipes containing the specific ingredient through proper table relationships."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(calories) FROM recipes WHERE ingredients LIKE '%black pepper%';",
            "SELECT AVG(T3.calories) AS average_calories\nFROM Ingredient AS T1 \nINNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id \nINNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id\nWHERE T1.name = 'coarsely ground black pepper'"
        ],
        "rule_sql": []
    },
    "7966": {
        "db_id": "music_platform_2",
        "question": "What is the review with the title \"Hosts bring the show down\" for?",
        "ground_truth": "SELECT title FROM podcasts WHERE podcast_id = ( SELECT podcast_id FROM reviews WHERE title = 'Hosts bring the show down' )",
        "amends": [
            "Do select only `title` instead of all columns with `*`. Do query from `podcasts` table instead of `reviews` table. Do add a subquery to filter by `podcast_id` instead of directly filtering by title. Do use the subquery `SELECT podcast_id FROM reviews WHERE title = 'Hosts bring the show down'` to find the correct podcast identifier instead of directly selecting reviews. The amended query now correctly retrieves the podcast title based on a review's content rather than incorrectly returning review records themselves, matching the RIGHT_SQL's behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM reviews WHERE title = 'Hosts bring the show down';",
            "SELECT title FROM podcasts WHERE podcast_id IN (SELECT podcast_id FROM reviews WHERE title = 'Hosts bring the show down')"
        ],
        "rule_sql": []
    },
    "5107": {
        "db_id": "address",
        "question": "In the state where Lisa Murkowski is the representative, how many cities have zero employees?",
        "ground_truth": "SELECT COUNT(T3.city) FROM congress AS T1 INNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation INNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state WHERE T1.first_name = 'Murkowski' AND T1.last_name = 'Lisa' AND T3.employees = 0",
        "amends": [
            "Do `COUNT(T3.city)` instead of `COUNT(*)` to count specific cities rather than all rows. Do `congress AS T1` instead of `representatives r` with different table naming. Do `state AS T2` instead of `states s` with different table naming. Do `zip_data AS T3` instead of `cities c` with different table naming. Do `INNER JOIN` on `T1.abbreviation = T2.abbreviation` instead of `JOIN` on `c.state_id = s.id` with different join condition using abbreviations. Do `INNER JOIN` on `T2.abbreviation = T3.state` instead of `JOIN` on `s.id = r.state_id` with different join condition using state abbreviations. Do filter `T1.first_name = 'Murkowski' AND T1.last_name = 'Lisa'` instead of `r.name = 'Lisa Murkowski'` by splitting the name into separate first and last name fields. Do keep `T3.employees = 0` filter instead of `c.employees = 0` with the same condition but on different table. The amended query now correctly counts cities with zero employees for representative Lisa Murkowski using proper table relationships and name filtering.",
            "Do swap the `first_name` and `last_name` filter values in the `WHERE` clause, using `first_name = 'Murkowski'` and `last_name = 'Lisa'` instead of `first_name = 'Lisa'` and `last_name = 'Murkowski'`, to correctly match the intended person's name format. The amended query now matches RIGHT_SQL's behavior by fixing the name filter conditions."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities c\nJOIN states s ON c.state_id = s.id\nJOIN representatives r ON s.id = r.state_id\nWHERE r.name = 'Lisa Murkowski'\nAND c.employees = 0;",
            "SELECT COUNT(T3.city)\nFROM congress AS T1\nINNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation\nINNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state\nWHERE T1.first_name = 'Lisa' \nAND T1.last_name = 'Murkowski'\nAND T3.employees = 0;",
            "SELECT COUNT(T3.city)\nFROM congress AS T1\nINNER JOIN state AS T2 ON T1.abbreviation = T2.abbreviation\nINNER JOIN zip_data AS T3 ON T2.abbreviation = T3.state\nWHERE T1.first_name = 'Murkowski' \nAND T1.last_name = 'Lisa' \nAND T3.employees = 0"
        ],
        "rule_sql": []
    },
    "2377": {
        "db_id": "superstore",
        "question": "What category does the item ordered by Katherine Murray on 11/4/2018 in the South region belong to?",
        "ground_truth": "SELECT DISTINCT T3.Category FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Katherine Murray' AND T1.`Order Date` = '2018-11-04' AND T2.Region = 'South'",
        "amends": [
            "Do use `DISTINCT T3.Category` instead of `category` without distinct. Do join `south_superstore AS T1` instead of querying `orders` directly. Do add `INNER JOIN people AS T2 ON T1.Customer ID = T2.Customer ID` instead of omitting the people table join. Do add `INNER JOIN product AS T3 ON T3.Product ID = T1.Product ID` instead of omitting the product table join. Do filter on `T2.Customer Name = 'Katherine Murray'` instead of `customer_name`. Do filter on `T1.Order Date = '2018-11-04'` with ISO format instead of `order_date = '11/4/2018'`. Do filter on `T2.Region = 'South'` instead of `region = 'South'` from the wrong table. The amended query now correctly joins the necessary tables and uses proper date formatting to match the intended behavior."
        ],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM orders WHERE customer_name = 'Katherine Murray' AND order_date = '11/4/2018' AND region = 'South'",
            "SELECT DISTINCT T3.Category\nFROM south_superstore AS T1\nINNER JOIN people AS T2 ON T1.\"Customer ID\" = T2.\"Customer ID\" AND T1.Region = T2.Region\nINNER JOIN product AS T3 ON T1.\"Product ID\" = T3.\"Product ID\" AND T1.Region = T3.Region\nWHERE T2.\"Customer Name\" = 'Katherine Murray'\nAND T1.\"Order Date\" = '2018-11-04'\nAND T2.Region = 'South'"
        ],
        "rule_sql": []
    },
    "4086": {
        "db_id": "public_review_platform",
        "question": "Which business ID received the review of 4 star and above by 65% of user? Describe their active status and city.",
        "ground_truth": "SELECT DISTINCT T2.business_id, T2.city FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T1.review_stars >= 4 AND ( SELECT CAST(( SELECT COUNT(DISTINCT T1.user_id) FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T1.review_stars >= 4 ) AS REAL) * 100 / ( SELECT COUNT(user_id) FROM Users ) > 65 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id, active, city \nFROM businesses \nWHERE review_count >= 4 \nAND (SELECT COUNT(*) FROM reviews WHERE reviews.business_id = businesses.business_id AND stars >= 4) / (SELECT COUNT(*) FROM reviews WHERE reviews.business_id = businesses.business_id) >= 0.65;"
        ],
        "rule_sql": []
    },
    "2998": {
        "db_id": "shakespeare",
        "question": "Other than \"stage directions\", what is the name of the character that appeared 5 times in \"the sea-coast\"?",
        "ground_truth": "SELECT T.CharName FROM ( SELECT T3.CharName, COUNT(T3.id) AS num FROM paragraphs AS T1 INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id INNER JOIN characters AS T3 ON T1.character_id = T3.id WHERE T2.Description = 'The sea-coast.' AND T3.CharName != '(stage directions)' AND T1.chapter_id = 18709 GROUP BY T3.id, T3.CharName ) AS T WHERE T.num = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM characters WHERE location = 'the sea-coast' AND character_name != 'stage directions' AND appearance_count = 5;"
        ],
        "rule_sql": []
    },
    "3062": {
        "db_id": "shakespeare",
        "question": "Among the comedy works of Shakespeare, what is the percentage of his works with a character named \"antonio\"?",
        "ground_truth": "SELECT CAST(SUM(IIF(T4.CharName = 'antonio', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id WHERE T1.GenreType = 'Comedy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM works WHERE genre = 'comedy')) AS percentage\nFROM works \nWHERE genre = 'comedy' \nAND title LIKE '%antonio%';"
        ],
        "rule_sql": []
    },
    "4165": {
        "db_id": "simpson_episodes",
        "question": "Please list all the keywords of the episode Lost Verizon.",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Lost Verizon';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword FROM episodes WHERE title = 'Lost Verizon';"
        ],
        "rule_sql": []
    },
    "1153": {
        "db_id": "talkingdata",
        "question": "What are the top 3 categories with the most app users?",
        "ground_truth": "SELECT T.category FROM ( SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id GROUP BY T2.category ) AS T ORDER BY T.num DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(*) as user_count FROM apps GROUP BY category ORDER BY user_count DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "594": {
        "db_id": "codebase_comments",
        "question": "Which solution contains files within a more popular repository, the solution ID18 or solution ID19?",
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T2.Id = 18 THEN T1.Watchers ELSE 0 END) > SUM(CASE WHEN T2.Id = 19 THEN T1.Watchers ELSE 0 END) THEN 'SolutionID18' WHEN SUM(CASE WHEN T2.Id = 18 THEN T1.Watchers ELSE 0 END) < SUM(CASE WHEN T2.Id = 19 THEN T1.Watchers ELSE 0 END) THEN 'SolutionID19' END isMorePopular FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN s1.popularity > s2.popularity THEN 'ID18' \n        ELSE 'ID19' \n    END as more_popular_solution\nFROM solutions s1, solutions s2\nWHERE s1.id = 'ID18' AND s2.id = 'ID19';"
        ],
        "rule_sql": []
    },
    "7257": {
        "db_id": "works_cycles",
        "question": "Who made the purchase order with the greatest total due before freight? Indicate her employee ID and calculate for his/her age when he/she was hired.",
        "ground_truth": "SELECT T2.BusinessEntityID, STRFTIME('%Y', T2.HireDate) - STRFTIME('%Y', T2.BirthDate) FROM PurchaseOrderHeader AS T1 INNER JOIN Employee AS T2 ON T1.EmployeeID = T2.BusinessEntityID ORDER BY T1.TotalDue DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    e.EmployeeID,\n    (strftime('%Y', e.HireDate) - strftime('%Y', e.BirthDate)) AS AgeAtHire,\n    MAX(po.TotalDue) AS MaxTotalDue\nFROM \n    PurchaseOrderHeader po\nJOIN \n    Employee e ON po.EmployeeID = e.EmployeeID\nWHERE \n    po.Freight > 0\nGROUP BY \n    e.EmployeeID\nORDER BY \n    MaxTotalDue DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5826": {
        "db_id": "airline",
        "question": "For the flight on 2018/8/1 that was delayed for the longest time, which was the destination airport of this flight?",
        "ground_truth": "SELECT T1.Description FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.DEST WHERE T2.FL_DATE = '2018/8/1' ORDER BY T2.DEP_DELAY DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT destination_airport FROM flights WHERE date = '2018/8/1' ORDER BY delay_time DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5015": {
        "db_id": "olympics",
        "question": "Tell the host city of the 1968 Winter Olympic Games.",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T3.games_name = '1968 Winter'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM olympic_games WHERE year = 1968 AND season = 'Summer';"
        ],
        "rule_sql": []
    },
    "1297": {
        "db_id": "law_episode",
        "question": "Which episodes of the Law & Order have been nominated for the Primetime Emmy Awards?",
        "ground_truth": "SELECT DISTINCT episode_id FROM Award WHERE award_category = 'Primetime Emmy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_title FROM episodes \nWHERE show_name = 'Law & Order' \nAND award_nomination = 'Primetime Emmy Awards';"
        ],
        "rule_sql": []
    },
    "2000": {
        "db_id": "soccer_2016",
        "question": "How many players have the bowling skill greater than 2?",
        "ground_truth": "SELECT COUNT(Player_Name) FROM Player WHERE Bowling_skill > 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE bowling_skill > 2"
        ],
        "rule_sql": []
    },
    "8565": {
        "db_id": "software_company",
        "question": "What is the response and number of inhabitants of the oldest female customer?",
        "ground_truth": "SELECT T2.RESPONSE, T3.INHABITANTS_K FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE T1.SEX = 'Female' ORDER BY T1.age DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT response, inhabitants FROM customers WHERE gender = 'female' ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "457": {
        "db_id": "movies_4",
        "question": "In Movie No. 19, how many people are there in Department No. 7? Please give me their job.",
        "ground_truth": "SELECT COUNT(DISTINCT job) FROM movie_crew WHERE movie_id = 19 AND department_id = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job FROM employees WHERE movie_id = 19 AND department_id = 7"
        ],
        "rule_sql": []
    },
    "3562": {
        "db_id": "authors",
        "question": "List down all paper name that were published in conference \"International Conference on Internet Computing\".",
        "ground_truth": "SELECT T1.Title FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T2.FullName = 'International Conference on Internet Computing' AND T1.Title <> ''",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT paper_name FROM papers WHERE conference = 'International Conference on Internet Computing';"
        ],
        "rule_sql": []
    },
    "3935": {
        "db_id": "public_review_platform",
        "question": "How many users have no followers in 2014?",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year = 2004 AND user_fans LIKE 'None'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE user_id NOT IN (SELECT follower_id FROM follows WHERE strftime('%Y', follow_date) = '2014')"
        ],
        "rule_sql": []
    },
    "2771": {
        "db_id": "european_football_1",
        "question": "How many Away Victories happened on 2016/3/27 in the LaLiga 2 division?",
        "ground_truth": "SELECT COUNT(T1.FTR) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'LaLiga 2' AND T1.Date = '2016-03-27' AND T1.FTR = 'A'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE date = '2016/3/27' AND division = 'LaLiga 2' AND home_goals < away_goals;"
        ],
        "rule_sql": []
    },
    "8978": {
        "db_id": "human_resources",
        "question": "Which positions are suitable with 4 years degree education?",
        "ground_truth": "SELECT positiontitle FROM position WHERE educationrequired = '4 year degree'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position FROM jobs WHERE education = '4 years degree'"
        ],
        "rule_sql": []
    },
    "1242": {
        "db_id": "talkingdata",
        "question": "List all the devices' brands and models of events on 5/7/2016 at 6:03:22 AM.",
        "ground_truth": "SELECT T1.phone_brand, T1.device_model FROM phone_brand_device_model2 AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE T2.timestamp = '2016-05-07 06:03:22'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand, model FROM events WHERE date = '5/7/2016' AND time = '6:03:22 AM'"
        ],
        "rule_sql": []
    },
    "4010": {
        "db_id": "public_review_platform",
        "question": "Identify the user who has been yelping since 2004. Is he or she an Yelp Elite member?",
        "ground_truth": "SELECT DISTINCT T2.user_id FROM Users AS T1 INNER JOIN Elite AS T2 ON T1.user_id = T2.user_id WHERE T1.user_yelping_since_year = 2004",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, elite FROM users WHERE yelping_since = '2004' AND elite = 'yes';"
        ],
        "rule_sql": []
    },
    "3336": {
        "db_id": "video_games",
        "question": "How many more sports games than simulation games?",
        "ground_truth": "SELECT COUNT(CASE WHEN T1.genre_name = 'Sports' THEN T2.id ELSE NULL END) - COUNT(CASE WHEN T1.genre_name = 'Simulation' THEN T2.id ELSE NULL END) FROM genre AS T1 INNER JOIN game AS T2 ON T1.id = T2.genre_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE genre = 'Sports' AND genre = 'Simulation';"
        ],
        "rule_sql": []
    },
    "8142": {
        "db_id": "sales_in_weather",
        "question": "On which day was the weather more windy in station no.1, 2012/1/1 or 2012/1/2?",
        "ground_truth": "SELECT CASE WHEN (SUM(CASE WHEN `date` = '2012-01-01' THEN avgspeed ELSE 0 END) - SUM(CASE WHEN `date` = '2012-01-02' THEN avgspeed ELSE 0 END)) > 0 THEN '2012-01-01' ELSE '2012-01-02' END FROM weather WHERE station_nbr = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM weather WHERE station_id = 1 AND date IN ('2012/1/1', '2012/1/2') ORDER BY temperature DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8048": {
        "db_id": "university",
        "question": "What is the country ID of the University of Tokyo?",
        "ground_truth": "SELECT country_id FROM university WHERE university_name = 'University of Tokyo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_id FROM universities WHERE name = 'University of Tokyo';"
        ],
        "rule_sql": []
    },
    "8097": {
        "db_id": "university",
        "question": "For Chosun University, what was its score on \"Influence Rank\" in 2015?",
        "ground_truth": "SELECT T2.score FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE T3.university_name = 'Chosun University' AND T1.criteria_name = 'Influence Rank' AND T2.year = 2015",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT score FROM university_rankings WHERE university = 'Chosun University' AND year = 2015 AND rank_type = 'Academic Rank';"
        ],
        "rule_sql": []
    },
    "3243": {
        "db_id": "donor",
        "question": "What was the title for the project which got the biggest donation?",
        "ground_truth": "SELECT T1.title FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.donation_total = ( SELECT MAX(donation_total) FROM donations )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM projects ORDER BY donation_amount ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8848": {
        "db_id": "food_inspection",
        "question": "Who is the owner of the business that has a high risk violation of 103109 and described as unclean or unsanitary food contact surfaces?",
        "ground_truth": "SELECT DISTINCT T2.owner_name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.risk_category = 'High Risk' AND T1.violation_type_id = 103109 AND T1.description = 'Unclean or unsanitary food contact surfaces'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_name FROM businesses WHERE violation_code = '103109' AND description = 'unclean or unsanitary food contact surfaces';"
        ],
        "rule_sql": []
    },
    "9247": {
        "db_id": "movie_3",
        "question": "Calculate the average rent amount paid by the customer with customer id 15.",
        "ground_truth": "SELECT AVG(amount) FROM payment WHERE customer_id = 15",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(amount) FROM payments WHERE customer_id = 15;"
        ],
        "rule_sql": []
    },
    "7627": {
        "db_id": "hockey",
        "question": "Name the goalies with the most seasons played. State the average time he played for each season.",
        "ground_truth": "SELECT T1.firstName, T1.lastName, T2.year, AVG(T2.Min) FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T1.playerID = ( SELECT playerID FROM Goalies GROUP BY playerID ORDER BY COUNT(playerID) DESC LIMIT 1 ) GROUP BY T1.firstName, T1.lastName, T2.year",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.name, COUNT(s.season_id) as seasons_played, AVG(s.minutes_played) as avg_minutes_per_season\nFROM goalies g\nJOIN seasons s ON g.goalie_id = s.goalie_id\nGROUP BY g.goalie_id\nORDER BY seasons_played DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2891": {
        "db_id": "professional_basketball",
        "question": "Name the teams along with the coaches that went to 'Quarter Final' round in 1946.",
        "ground_truth": "SELECT DISTINCT T1.coachID, T3.name FROM coaches AS T1 JOIN series_post AS T2 ON T1.tmID = T2.tmIDWinner JOIN teams AS T3 ON T3.tmID = T1.tmID WHERE T2.round = 'QF' AND T2.year = 1946",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, coach_name FROM teams WHERE round = 'Quarter Final' AND year = 1946;"
        ],
        "rule_sql": []
    },
    "5608": {
        "db_id": "shipping",
        "question": "What is the full name of the driver who transported the first shipment of the company?",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id ORDER BY T1.ship_date ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM drivers ORDER BY shipment_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "926": {
        "db_id": "cs_semester",
        "question": "Among the students with a gpa of 3.1 to 3.7, how many of them are undergraduate students?",
        "ground_truth": "SELECT COUNT(student_id) FROM student WHERE gpa BETWEEN 3.1 AND 3.7 AND type = 'UG'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gpa BETWEEN 3.1 AND 3.7 AND student_type = 'undergraduate';"
        ],
        "rule_sql": []
    },
    "5846": {
        "db_id": "airline",
        "question": "For the flight with the tail number 'N702SK', which air carrier does it belong to?",
        "ground_truth": "SELECT T2.Description FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T1.TAIL_NUM = 'N702SK' GROUP BY T2.Description",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT carrier_name FROM flights WHERE tail_number = 'N702SK';"
        ],
        "rule_sql": []
    },
    "1895": {
        "db_id": "soccer_2016",
        "question": "Of the wickets taken in the third overs, how many are without the involvement of fielders?",
        "ground_truth": "SELECT SUM(CASE WHEN Fielders = '' THEN 1 ELSE 0 END) FROM Wicket_Taken WHERE Over_Id = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM wickets \nWHERE over = 3 \nAND fielder_id IS NULL;"
        ],
        "rule_sql": []
    },
    "6086": {
        "db_id": "books",
        "question": "Name the publisher who published the most books.",
        "ground_truth": "SELECT T2.publisher_name FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id GROUP BY T2.publisher_name ORDER BY COUNT(T2.publisher_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher, COUNT(*) as book_count FROM books GROUP BY publisher ORDER BY book_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7277": {
        "db_id": "works_cycles",
        "question": "Please give the highest product cost of a purchase order.",
        "ground_truth": "SELECT ActualCost FROM TransactionHistory WHERE TransactionType = 'P' ORDER BY ActualCost DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(price) FROM products;"
        ],
        "rule_sql": []
    },
    "2497": {
        "db_id": "genes",
        "question": "Please list the motif of the genes that are located in the cytoplasm and have 7 chromosomes.",
        "ground_truth": "SELECT T2.GeneID1, T2.GeneID2 FROM Genes AS T1 INNER JOIN Interactions AS T2 ON T1.GeneID = T2.GeneID1 WHERE T1.Localization = 'cytoplasm' AND T1.Chromosome = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT motif FROM genes WHERE location = 'cytoplasm' AND chromosome = 7;"
        ],
        "rule_sql": []
    },
    "6082": {
        "db_id": "books",
        "question": "What is the current address of customer Kandy?",
        "ground_truth": "SELECT T3.street_number, T3.street_name, T3.city FROM customer AS T1 INNER JOIN customer_address AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id INNER JOIN address_status AS T4 ON T4.status_id = T2.status_id WHERE T1.first_name = 'Kandy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM customers WHERE name = 'Kandy';"
        ],
        "rule_sql": []
    },
    "1333": {
        "db_id": "law_episode",
        "question": "List out all the credit names for episode 9.",
        "ground_truth": "SELECT T3.name FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE T1.episode = 9",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_name FROM credits WHERE episode_id = 9;"
        ],
        "rule_sql": []
    },
    "56": {
        "db_id": "movie_platform",
        "question": "Please give me the url of the movie \"La Antena\".",
        "ground_truth": "SELECT movie_url FROM movies WHERE movie_title = 'La Antena'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE url = 'La Antena';"
        ],
        "rule_sql": []
    },
    "1650": {
        "db_id": "car_retails",
        "question": "Calculate the actual profit for order number 10100.",
        "ground_truth": "SELECT SUM((t1.priceEach - t2.buyPrice) * t1.quantityOrdered) FROM orderdetails AS t1 INNER JOIN products AS t2 ON t1.productCode = t2.productCode WHERE t1.orderNumber = '10100'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantityOrdered * priceEach) AS actual_profit FROM orderdetails WHERE orderNumber = 10100"
        ],
        "rule_sql": []
    },
    "7654": {
        "db_id": "hockey",
        "question": "How many people were in the Hall of Fame's Builder category?",
        "ground_truth": "SELECT COUNT(hofID) FROM HOF WHERE category = 'Builder'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM HallOfFame WHERE category = 'Builder';"
        ],
        "rule_sql": []
    },
    "1079": {
        "db_id": "talkingdata",
        "question": "What is the age of the oldest device user?",
        "ground_truth": "SELECT MAX(age) FROM gender_age",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(age) FROM users;"
        ],
        "rule_sql": []
    },
    "2505": {
        "db_id": "genes",
        "question": "What percentage of genes located in the cytoskeleton are of unknown class? And of these, how many are not conditional phenotypes?",
        "ground_truth": "SELECT SUM(Localization = 'cytoskeleton' AND Phenotype = 'Conditional phenotypes') , CAST(SUM(Localization = 'cytoskeleton') AS REAL) * 100 / COUNT(GeneID) FROM Genes;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gene_class = 'unknown' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_unknown,\n    COUNT(CASE WHEN gene_class = 'unknown' AND phenotype_type != 'conditional' THEN 1 END) AS non_conditional_count\nFROM genes\nWHERE location = 'cytoskeleton';"
        ],
        "rule_sql": []
    },
    "3528": {
        "db_id": "authors",
        "question": "List the title of papers with a conference ID from 160 to 170, include their conference short name.",
        "ground_truth": "SELECT DISTINCT T1.Title, T2.ShortName FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T1.ConferenceId BETWEEN 160 AND 170",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.title, c.short_name \nFROM papers p \nJOIN conferences c ON p.conference_id = c.id \nWHERE p.conference_id BETWEEN 160 AND 170;"
        ],
        "rule_sql": []
    },
    "307": {
        "db_id": "retail_complains",
        "question": "How many clients with the last name Alvarado are from Maryland?",
        "ground_truth": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN state AS T3 ON T1.state_abbrev = T3.StateCode WHERE T2.last = 'Alvarado' AND T2.state = 'MD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE last_name = 'Alvarado' AND state = 'Maryland';"
        ],
        "rule_sql": []
    },
    "1699": {
        "db_id": "restaurant",
        "question": "What percentage of streets named 11th Street are in Alameda County?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.street_name = '11th st', 1, 0)) AS REAL) * 100 / COUNT(T1.id_restaurant) FROM location AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T2.County = 'alameda county'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN street_name = '11th Street' AND county = 'Alameda County' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN street_name = '11th Street' THEN 1 END)) AS percentage\nFROM streets;"
        ],
        "rule_sql": []
    },
    "8460": {
        "db_id": "mondial_geo",
        "question": "What is the full name of ABEDA and when was it established?",
        "ground_truth": "SELECT Name, Established FROM organization WHERE Abbreviation = 'ABEDA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, established_year FROM organizations WHERE name = 'ABEDA';"
        ],
        "rule_sql": []
    },
    "6862": {
        "db_id": "retails",
        "question": "What is the name of the product with the highest retail price?",
        "ground_truth": "SELECT p_name FROM part WHERE p_retailprice = ( SELECT MAX(p_retailprice) FROM part )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products ORDER BY retail_price ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2300": {
        "db_id": "movielens",
        "question": "Which genre contains the greatest number of non-English films?",
        "ground_truth": "SELECT T2.genre FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.isEnglish = 'F' GROUP BY T2.genre ORDER BY COUNT(T1.movieid) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre, COUNT(*) as film_count \nFROM films \nWHERE language != 'English' \nGROUP BY genre \nORDER BY film_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "729": {
        "db_id": "trains",
        "question": "List all the load shapes of all head cars of each train and identify which load shape has the highest number. Calculate the percentage of the trains with the said head car that are running eas",
        "ground_truth": "SELECT DISTINCT T3.load_shape FROM ( SELECT load_shape, train_id FROM cars WHERE position = 1 ORDER BY train_id DESC ) AS T3 UNION ALL SELECT T4.load_shape FROM ( SELECT load_shape, train_id FROM cars WHERE position = 1 ORDER BY train_id DESC LIMIT 1 ) AS T4 UNION ALL SELECT (CAST(COUNT(DISTINCT CASE WHEN T2.direction = 'east' THEN T2.id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.id)) FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.position = 1 AND T1.load_shape = ( SELECT T4.load_shape FROM ( SELECT load_shape, train_id FROM cars AS T WHERE position = 1 ORDER BY train_id DESC LIMIT 1 ) AS T4 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    hs.load_shape,\n    COUNT(*) as train_count,\n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM trains t2 JOIN head_cars hc2 ON t2.head_car_id = hc2.id WHERE hc2.load_shape = hs.load_shape)) as percentage\nFROM \n    trains t\nJOIN \n    head_cars hc ON t.head_car_id = hc.id\nJOIN \n    head_shapes hs ON hc.shape_id = hs.id\nGROUP BY \n    hs.load_shape\nORDER BY \n    train_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5487": {
        "db_id": "menu",
        "question": "What is the average price of the dishes on the menu \"Zentral Theater Terrace\"?",
        "ground_truth": "SELECT SUM(T1.price) / COUNT(T1.price) FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id WHERE T3.name = 'Zentral Theater Terrace'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM dishes WHERE menu_name = 'Zentral Theater Terrace';"
        ],
        "rule_sql": []
    },
    "8364": {
        "db_id": "mondial_geo",
        "question": "What provinces encompass the world's biggest desert in terms of overall area?",
        "ground_truth": "SELECT Province FROM geo_desert WHERE Desert = ( SELECT Name FROM desert ORDER BY Area DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT province_name FROM provinces WHERE desert_area = (SELECT MAX(desert_area) FROM provinces);"
        ],
        "rule_sql": []
    },
    "7098": {
        "db_id": "works_cycles",
        "question": "If we discount the products that do not have any type of offer, how many different products have been sold in an amount greater than 2 units per order?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ProductID) FROM SalesOrderDetail AS T1 INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID INNER JOIN SpecialOffer AS T3 ON T2.SpecialOfferID = T3.SpecialOfferID WHERE T1.OrderQty > 2 AND T1.UnitPriceDiscount = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT product_id) \nFROM orders \nWHERE quantity > 2 \nAND offer_id IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "8316": {
        "db_id": "mondial_geo",
        "question": "What is the average percentage of agriculture of GDP in countries on the African Continent?",
        "ground_truth": "SELECT AVG(T4.Agriculture) FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN economy AS T4 ON T4.Country = T3.Code WHERE T1.Name = 'Africa'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(agriculture_percentage_of_gdp) FROM countries WHERE continent = 'Africa';"
        ],
        "rule_sql": []
    },
    "5475": {
        "db_id": "menu",
        "question": "Please list the prices of the dish \"Clear green turtle\" on every menu page it appeared on.",
        "ground_truth": "SELECT T2.price FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id WHERE T1.name = 'Clear green turtle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT menu_page_id, price FROM dishes WHERE dish_name = 'Clear green turtle'"
        ],
        "rule_sql": []
    },
    "680": {
        "db_id": "codebase_comments",
        "question": "How many XML format does the github address \"https://github.com/dogeth/vss2git.git\" have?",
        "ground_truth": "SELECT COUNT(T3.CommentIsXml) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId INNER JOIN Method AS T3 ON T2.Id = T3.SolutionId WHERE T1.Url = 'https://github.com/dogeth/vss2git.git' AND T3.CommentIsXml = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM github_repositories WHERE address = 'https://github.com/dogeth/vss2git.git' AND format = 'XML';"
        ],
        "rule_sql": []
    },
    "7950": {
        "db_id": "music_platform_2",
        "question": "Indicate the id of the reviewer whose itunes id is 1516665400.",
        "ground_truth": "SELECT T2.author_id FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.itunes_id = 1516665400",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reviewer_id FROM reviewers WHERE itunes_id = '1516665400';"
        ],
        "rule_sql": []
    },
    "6103": {
        "db_id": "books",
        "question": "List the ISBN of the books that cost 7.5 dollars.",
        "ground_truth": "SELECT T1.isbn13 FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T2.price = 7.5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE price = 7.5;"
        ],
        "rule_sql": []
    },
    "7650": {
        "db_id": "hockey",
        "question": "How many teams scored against their opponent who had pulled their goalie in the year 2005?",
        "ground_truth": "SELECT COUNT(tmID) FROM Goalies WHERE year = 2005 AND ENG IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM games \nWHERE year = 2005 \nAND goalie_pulled = 1 \nAND score > opponent_score;"
        ],
        "rule_sql": []
    },
    "8649": {
        "db_id": "chicago_crime",
        "question": "How many crimes were Misc Non-Index Offense?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.title = 'Misc Non-Index Offense' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE offense_type = 'Misc Non-Index Offense';"
        ],
        "rule_sql": []
    },
    "7225": {
        "db_id": "works_cycles",
        "question": "Among all the production technicians, how many have a below average pay rate for a production technician?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle LIKE 'Production Technician%' AND T2.Rate < ( SELECT AVG(T2.Rate) FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle LIKE 'Production Technician%' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM employees \nWHERE JobTitle = 'Production Technician' \nAND PayRate < (SELECT AVG(PayRate) FROM employees)"
        ],
        "rule_sql": []
    },
    "9113": {
        "db_id": "movie_3",
        "question": "In which year was the film with the highest replacement cost released?",
        "ground_truth": "SELECT DISTINCT release_year FROM film WHERE replacement_cost = ( SELECT MAX(replacement_cost) FROM film )",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_year FROM film ORDER BY replacement_cost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7114": {
        "db_id": "works_cycles",
        "question": "Please list the top three employees with the most unused sick leave along with their position titles.",
        "ground_truth": "SELECT JobTitle FROM Employee ORDER BY SickLeaveHours DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.name, e.position_title, COUNT(s.leave_id) as unused_sick_leave\nFROM employees e\nLEFT JOIN sick_leave s ON e.employee_id = s.employee_id AND s.used = 0\nGROUP BY e.employee_id\nORDER BY unused_sick_leave DESC\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "4193": {
        "db_id": "simpson_episodes",
        "question": "Which episode has the most vote for 10 stars rating?",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 10 ORDER BY T1.votes DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_id, COUNT(*) as vote_count FROM ratings WHERE rating = 10 GROUP BY episode_id ORDER BY vote_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7930": {
        "db_id": "music_platform_2",
        "question": "Which podcast was reviewed the latest? State the date of creation, podcast tile and rating.",
        "ground_truth": "SELECT T1.podcast_id, T2.created_at, T2.title, T2.rating FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id ORDER BY T2.created_at DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT creation_date, podcast_title, rating FROM reviews ORDER BY creation_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7982": {
        "db_id": "music_platform_2",
        "question": "How many reviews are created for the podcast \"Scaling Global\" under?",
        "ground_truth": "SELECT COUNT(T2.content) FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'Scaling Global'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE podcast_name = 'Scaling Global'"
        ],
        "rule_sql": []
    },
    "5306": {
        "db_id": "beer_factory",
        "question": "What is the precise location of all paying customers with American Express?",
        "ground_truth": "SELECT DISTINCT T2.Latitude, T2.Longitude FROM `transaction` AS T1 INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE T1.CreditCardType = 'American Express'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE payment_method = 'American Express' AND status = 'paying';"
        ],
        "rule_sql": []
    },
    "6899": {
        "db_id": "retails",
        "question": "Among the items shipped in 1994 via truck, how many items were returned?",
        "ground_truth": "SELECT COUNT(l_orderkey) FROM lineitem WHERE STRFTIME('%Y', l_shipdate) = '1994' AND l_returnflag = 'R' AND l_shipmode = 'TRUCK'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM lineitem \nWHERE l_shipmode = 'TRUCK' \nAND l_shipdate LIKE '1994%' \nAND l_returnflag = 'R';"
        ],
        "rule_sql": []
    },
    "3018": {
        "db_id": "shakespeare",
        "question": "How many paragraphs are there in Act 5 Scene 1 of \"Comedy of Errors\"?",
        "ground_truth": "SELECT COUNT(T3.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id WHERE T2.Act = 5 AND T2.Scene = 1 AND T1.Title = 'Comedy of Errors'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM paragraphs WHERE act = 5 AND scene = 1 AND play = 'Comedy of Errors';"
        ],
        "rule_sql": []
    },
    "8744": {
        "db_id": "chicago_crime",
        "question": "What is the percentage of crime cases that have been classified as \"drug abuse\" by the FBI and happened on the street?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.title = 'Drug Abuse' AND T1.location_description = 'STREET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.fbi_code_no) FROM Crime AS T1 INNER JOIN FBI_Code AS T2 ON T1.fbi_code_no = T2.fbi_code_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN crime_type = 'drug abuse' AND location = 'street' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM crime_cases\nWHERE fbi_classification = 'drug abuse';"
        ],
        "rule_sql": []
    },
    "8445": {
        "db_id": "mondial_geo",
        "question": "What nations are considered British Overseas Territories?",
        "ground_truth": "SELECT name FROM country WHERE CODE IN ( SELECT country FROM politics WHERE government = 'British Overseas Territories' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM countries WHERE region = 'British Overseas Territory';"
        ],
        "rule_sql": []
    },
    "2919": {
        "db_id": "professional_basketball",
        "question": "Find the full name of the player born in Atlanta and have the highest number of blocks. Also, in which team did this player perform the most number of blocks?",
        "ground_truth": "SELECT T1.firstName, T1.lastName, T2.tmID FROM players AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCity = 'Atlanta' ORDER BY T2.blocks DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.full_name, t.team_name \nFROM players p\nJOIN player_stats ps ON p.player_id = ps.player_id\nJOIN teams t ON ps.team_id = t.team_id\nWHERE p.birth_city = 'Atlanta'\nORDER BY ps.blocks DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1279": {
        "db_id": "law_episode",
        "question": "What is the percentage of people who gave the \"True North\" episode a 1-star rating?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.stars = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.episode_id) FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'True North' AND T1.episode_id = 'tt0629477'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM ratings WHERE episode = 'True North')) AS percentage FROM ratings WHERE episode = 'True North' AND rating = 1;"
        ],
        "rule_sql": []
    },
    "5080": {
        "db_id": "olympics",
        "question": "In the 2014 Winter game, what is the percentage of competitors who age 28 years old?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.age = 28 THEN 1 END) AS REAL) * 100 / COUNT(T2.person_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name = '2014 Winter'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM competitors WHERE game = '2014 Winter')) AS percentage FROM competitors WHERE age = 28 AND game = '2014 Winter';"
        ],
        "rule_sql": []
    },
    "1704": {
        "db_id": "restaurant",
        "question": "What is the county and region of Davis City?",
        "ground_truth": "SELECT county, region FROM geographic WHERE city = 'Davis'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county, region FROM cities WHERE name = 'Davis City';"
        ],
        "rule_sql": []
    },
    "4623": {
        "db_id": "disney",
        "question": "Who is the director of the movie Pinocchio?",
        "ground_truth": "SELECT director FROM director WHERE name = 'Pinocchio'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM movies WHERE title = 'Pinocchio';"
        ],
        "rule_sql": []
    },
    "8751": {
        "db_id": "chicago_crime",
        "question": "Name the neighborhood of the community area in crime with report number 23843?",
        "ground_truth": "SELECT T3.neighborhood_name FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN Neighborhood AS T3 ON T2.community_area_no = T3.community_area_no WHERE T2.report_no = 23778",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT neighborhood FROM crime WHERE report_number = 23843"
        ],
        "rule_sql": []
    },
    "8140": {
        "db_id": "sales_in_weather",
        "question": "What was the temperature range of station no.1 on 2012/1/1?",
        "ground_truth": "SELECT tmax - tmin AS temrange FROM weather WHERE station_nbr = 1 AND `date` = '2012-01-01'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(temperature) FROM weather WHERE station_id = 1 AND date = '2012/1/1';"
        ],
        "rule_sql": []
    },
    "7998": {
        "db_id": "university",
        "question": "In 2016, what is the name of the university in Australia with the highest score in Citations criteria?",
        "ground_truth": "SELECT T3.university_name FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id INNER JOIN country AS T4 ON T4.id = T3.country_id WHERE T1.criteria_name = 'Citations' AND T2.year = 2016 AND T1.id = 4 AND T4.country_name = 'Australia' ORDER BY T2.score DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT University_Name FROM universities WHERE Country = 'Australia' AND Year = 2016 ORDER BY Score DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "146": {
        "db_id": "movie_platform",
        "question": "Which title list has not been updated for the longest period of time? State how long it has not been updated?",
        "ground_truth": "SELECT list_title , datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(list_update_timestamp_utc) FROM lists ORDER BY list_update_timestamp_utc LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MAX(last_updated) as last_update_date, DATEDIFF(CURDATE(), MAX(last_updated)) as days_since_update FROM lists GROUP BY title ORDER BY days_since_update ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2104": {
        "db_id": "world_development_indicators",
        "question": "What is the average adolescent fertility rate of the country whose Alpha2Code is 1A over the years this indicator was calculated.",
        "ground_truth": "SELECT AVG(T2.Value) FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.Alpha2Code = '1A' AND T2.IndicatorName LIKE 'adolescent fertility rate%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(adolescent_fertility_rate) FROM fertility_data WHERE Alpha2Code = '1A'"
        ],
        "rule_sql": []
    },
    "5671": {
        "db_id": "shipping",
        "question": "Where does the driver of ship ID 1127 live?",
        "ground_truth": "SELECT T2.address FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_id = '1127'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM drivers WHERE ship_id = 1127"
        ],
        "rule_sql": []
    },
    "3924": {
        "db_id": "public_review_platform",
        "question": "What is the attribute of the business with highest star rating?",
        "ground_truth": "SELECT T3.attribute_name FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id ORDER BY T1.stars DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM business ORDER BY star_rating LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5600": {
        "db_id": "shipping",
        "question": "For the shipment received by Leszek Kieltyka on 2017/9/25, what was its weight?",
        "ground_truth": "SELECT T1.weight FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T2.first_name = 'Leszek' AND T2.last_name = 'Kieltyka' AND T1.ship_date = '2017-09-25'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT weight FROM shipments WHERE recipient = 'Leszek Kieltyka' AND date = '2017-09-25';"
        ],
        "rule_sql": []
    },
    "4964": {
        "db_id": "olympics",
        "question": "How many males from Belgium have participated in an Olympic Games?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Belgium' AND T3.gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE gender = 'Male' AND country = 'Belgium';"
        ],
        "rule_sql": []
    },
    "6799": {
        "db_id": "retails",
        "question": "Please state the segment, the name, the address, and the phone number of customer number 3.",
        "ground_truth": "SELECT c_mktsegment, c_name, c_address, c_phone FROM customer WHERE c_custkey = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT segment, name, address, phone FROM customers WHERE customer_id = 3"
        ],
        "rule_sql": []
    },
    "2296": {
        "db_id": "movielens",
        "question": "How many of the movies rated 5 are rated by a user between the ages of 25 and 35?",
        "ground_truth": "SELECT COUNT(T1.movieid) FROM u2base AS T1 INNER JOIN users AS T2 ON T1.userid = T2.userid WHERE T1.rating = 5 AND T2.age BETWEEN 25 AND 35",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM ratings r\nJOIN users u ON r.user_id = u.user_id\nWHERE r.rating = 5 \nAND u.age BETWEEN 25 AND 35;"
        ],
        "rule_sql": []
    },
    "8910": {
        "db_id": "cookbook",
        "question": "Describe the ingredients in the recipe with the highest vitamin that helps vision in dim light.",
        "ground_truth": "SELECT T1.name FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id INNER JOIN Nutrition AS T3 ON T3.recipe_id = T2.recipe_id ORDER BY T3.vitamin_a DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ingredient_name FROM ingredients WHERE recipe_id = (SELECT recipe_id FROM vitamins WHERE vitamin_name = 'Vitamin A' ORDER BY amount DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "4351": {
        "db_id": "simpson_episodes",
        "question": "List down the names of person born in California, USA.",
        "ground_truth": "SELECT name FROM Person WHERE birth_region = 'California' AND birth_country = 'USA';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM persons WHERE state = 'California' AND country = 'USA';"
        ],
        "rule_sql": []
    },
    "4914": {
        "db_id": "olympics",
        "question": "What was the name of the Olympic game that John Aalberg took part in when he was 31?",
        "ground_truth": "SELECT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.full_name = 'John Aalberg' AND T2.age = 31",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM olympic_games WHERE participant = 'John Aalberg' AND age = 31;"
        ],
        "rule_sql": []
    },
    "3505": {
        "db_id": "video_games",
        "question": "What is the diffrence between the number of games produced by Culture Brain that can be played on SNES and DS?",
        "ground_truth": "SELECT COUNT(CASE WHEN T1.platform_name = 'SNES' THEN T3.game_id ELSE NULL END) - COUNT(CASE WHEN T1.platform_name = 'DS' THEN T3.game_id ELSE NULL END) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id INNER JOIN publisher AS T4 ON T3.publisher_id = T4.id WHERE T4.publisher_name = 'Culture Brain'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM games WHERE developer = 'Culture Brain' AND platform = 'SNES') - \n    (SELECT COUNT(*) FROM games WHERE developer = 'Culture Brain' AND platform = 'DS') \nAS difference;"
        ],
        "rule_sql": []
    },
    "631": {
        "db_id": "codebase_comments",
        "question": "List all the path of solution from all the \"it\" lang code method.",
        "ground_truth": "SELECT DISTINCT T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Lang = 'it'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path FROM methods WHERE lang_code = 'it';"
        ],
        "rule_sql": []
    },
    "4152": {
        "db_id": "citeseer",
        "question": "On average, how many papers are under the ML class?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN class_label = 'ML' THEN paper_id ELSE NULL END) AS REAL) / COUNT(paper_id) FROM paper",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(paper_count) FROM papers WHERE class = 'ML';"
        ],
        "rule_sql": []
    },
    "7116": {
        "db_id": "works_cycles",
        "question": "What is business number 1580's net profit?",
        "ground_truth": "SELECT LastReceiptCost - StandardPrice FROM ProductVendor WHERE BusinessEntityID = 1580",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT revenue FROM business WHERE business_number = 1580;"
        ],
        "rule_sql": []
    },
    "8624": {
        "db_id": "chicago_crime",
        "question": "What is the population of the district with the least population?",
        "ground_truth": "SELECT SUM(population) FROM Community_Area GROUP BY side ORDER BY SUM(population) LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(population) FROM districts;"
        ],
        "rule_sql": []
    },
    "842": {
        "db_id": "social_media",
        "question": "Please list the texts of all the tweets in French posted by male users.",
        "ground_truth": "SELECT T1.text FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T2.Gender = 'Male' AND T1.Lang = 'fr'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE language = 'French' AND user_id IN (SELECT id FROM users WHERE gender = 'male');"
        ],
        "rule_sql": []
    },
    "5723": {
        "db_id": "language_corpus",
        "question": "What is the title of the page that has the fewest words?",
        "ground_truth": "SELECT title FROM pages WHERE title = ( SELECT MIN(words) FROM pages )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM pages ORDER BY word_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1525": {
        "db_id": "synthea",
        "question": "How many male patients have been described as immune to quadrivalent HPV?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'HPV  quadrivalent' AND T1.gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND description LIKE '%immune to quadrivalent HPV%';"
        ],
        "rule_sql": []
    },
    "1047": {
        "db_id": "talkingdata",
        "question": "How many users are there in the Home Decoration category?",
        "ground_truth": "SELECT COUNT(T1.app_id) FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id WHERE T2.category = 'Home Decoration'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE category = 'Home Decoration';"
        ],
        "rule_sql": []
    },
    "591": {
        "db_id": "codebase_comments",
        "question": "Please list the path of the solution that contains files found within the repository most people like.",
        "ground_truth": "SELECT DISTINCT T2.Path FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Stars = ( SELECT MAX(Stars) FROM Repo )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path FROM solutions WHERE files IN (SELECT files FROM repositories WHERE likes = MAX(likes));"
        ],
        "rule_sql": []
    },
    "5960": {
        "db_id": "books",
        "question": "How many of the books authored by Al Gore have less than 400 pages?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Al Gore' AND T1.num_pages < 400",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE author = 'Al Gore' AND pages > 400;"
        ],
        "rule_sql": []
    },
    "3892": {
        "db_id": "public_review_platform",
        "question": "List the categories of active businesses in Surprise, AZ.",
        "ground_truth": "SELECT T3.category_name FROM Business AS T1 INNER JOIN Business_Categories ON T1.business_id = Business_Categories.business_id INNER JOIN Categories AS T3 ON Business_Categories.category_id = T3.category_id WHERE T1.active LIKE 'TRUE' AND T1.state LIKE 'AZ' AND T1.city LIKE 'Surprise' GROUP BY T3.category_name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM businesses WHERE city = 'Surprise' AND state = 'AZ' AND status = 'active';"
        ],
        "rule_sql": []
    },
    "7903": {
        "db_id": "world",
        "question": "What is the surface area and GNP of the country where Namibe district belongs?",
        "ground_truth": "SELECT T2.SurfaceArea, T2.GNP FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T1.District = 'Namibe'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.SurfaceArea, c.GNP \nFROM country c \nJOIN district d ON c.Name = d.Country \nWHERE d.Name = 'Namibe';"
        ],
        "rule_sql": []
    },
    "9368": {
        "db_id": "movie_3",
        "question": "How many documentary films are rated PG-13?",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Documentary' AND T1.rating = 'PG-13'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE genre = 'Documentary' AND rating = 'PG-13';"
        ],
        "rule_sql": []
    },
    "1807": {
        "db_id": "soccer_2016",
        "question": "Give the name of the striker in the match no. 419169, over no.3, ball no.2, inning no.2.",
        "ground_truth": "SELECT T2.Player_Name FROM Ball_by_Ball AS T1 INNER JOIN Player AS T2 ON T1.Striker = T2.Player_Id WHERE T1.Match_Id = 419169 AND T1.Over_Id = 3 AND T1.Ball_Id = 2 AND T1.Innings_No = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT striker_name FROM match_balls WHERE match_id = 419169 AND over_number = 3 AND ball_number = 2 AND inning_number = 2;"
        ],
        "rule_sql": []
    },
    "3227": {
        "db_id": "donor",
        "question": "What is the number of the year round school in Los Angeles?",
        "ground_truth": "SELECT COUNT(school_year_round) FROM projects WHERE school_city = 'Los Angeles' AND school_year_round = 't'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE city = 'Los Angeles' AND school_type = 'year_round';"
        ],
        "rule_sql": []
    },
    "6863": {
        "db_id": "retails",
        "question": "Which part has a bigger size, \"pink powder drab lawn cyan\" or \"cornflower sky burlywood green beige\"?",
        "ground_truth": "SELECT T.p_name FROM ( SELECT p_name, p_size FROM part WHERE p_name IN ('pink powder drab lawn cyan', 'cornflower sky burlywood green beige') ) AS T ORDER BY p_size DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN size > (SELECT size FROM parts WHERE name = 'cornflower sky burlywood green beige') \n        THEN 'pink powder drab lawn cyan is bigger'\n        ELSE 'cornflower sky burlywood green beige is bigger'\n    END AS comparison\nFROM parts \nWHERE name = 'pink powder drab lawn cyan';"
        ],
        "rule_sql": []
    },
    "411": {
        "db_id": "movies_4",
        "question": "What is the title of the latest released movie produced by production company \"Universal Pictures\"?",
        "ground_truth": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Universal Pictures' ORDER BY T3.release_date DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE production_company = 'Universal Pictures' ORDER BY release_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5490": {
        "db_id": "menu",
        "question": "How many menus were used in Dutcher House?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE location = 'Dutcher House'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menus WHERE house_name = 'Dutcher House';"
        ],
        "rule_sql": []
    },
    "1984": {
        "db_id": "soccer_2016",
        "question": "How many matches are there in 2008?",
        "ground_truth": "SELECT COUNT(Match_Id) FROM `Match` WHERE Match_Date LIKE '2008%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE year = 2008;"
        ],
        "rule_sql": []
    },
    "3569": {
        "db_id": "authors",
        "question": "List the short name of all conferences whose full name begins with International Symposium.",
        "ground_truth": "SELECT ShortName FROM Conference WHERE FullName LIKE 'International Symposium%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT short_name FROM conferences WHERE full_name LIKE 'International Symposium%';"
        ],
        "rule_sql": []
    },
    "8657": {
        "db_id": "chicago_crime",
        "question": "Calculate the percentage of the domestic violence cases handled by Christopher Taliaferro. Among them, list report numbers of cases that happened in the bank.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.domestic = 'TRUE' THEN T1.report_no END) AS REAL) * 100 / COUNT(T1.report_no), COUNT(CASE WHEN T1.domestic = 'TRUE' AND T1.location_description = 'BANK' THEN T1.report_no END) AS \"number\" FROM Crime AS T1 INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE T2.alderman_first_name = 'Christopher' AND T2.alderman_last_name = 'Taliaferro'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN officer_name = 'Christopher Taliaferro' THEN 1 END) * 100.0 / COUNT(*)) AS percentage,\n    report_number\nFROM domestic_violence_cases \nWHERE location = 'bank'\nGROUP BY report_number"
        ],
        "rule_sql": []
    },
    "9172": {
        "db_id": "movie_3",
        "question": "In 2006, how many restricted films were released?",
        "ground_truth": "SELECT COUNT(film_id) FROM film WHERE rating = 'R' AND release_year = 2006",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE year = 2006 AND rating = 'R';"
        ],
        "rule_sql": []
    },
    "9121": {
        "db_id": "movie_3",
        "question": "Please give the title of the film starring PENELOPE GUINESS and has the highest replacement cost.",
        "ground_truth": "SELECT T3.title FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'PENELOPE' AND T1.last_name = 'GUINESS' ORDER BY T3.replacement_cost DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM film WHERE actor = 'PENELOPE GUINESS' ORDER BY replacement_cost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2917": {
        "db_id": "professional_basketball",
        "question": "Of the players drafted in NBA between 1990 and 2000, who has the most points in all-star? List the player's first name and last name.",
        "ground_truth": "SELECT T3.firstname, T3.lastname FROM player_allstar AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID INNER JOIN draft AS T3 ON T1.playerID = T3.playerID WHERE T2.year BETWEEN 1990 AND 2000 ORDER BY T1.points DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name \nFROM players \nWHERE draft_year BETWEEN 1990 AND 2000 \nORDER BY points DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4834": {
        "db_id": "legislator",
        "question": "List down the open secrets and thomas ID of the democrat senators of New Jersey.",
        "ground_truth": "SELECT T1.opensecrets_id, T1.thomas_id FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.type = 'sen' AND T2.state = 'NJ' GROUP BY T1.opensecrets_id, T1.thomas_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT open_secrets, thomas_id FROM senators WHERE party = 'Democrat' AND state = 'New Jersey';"
        ],
        "rule_sql": []
    },
    "8440": {
        "db_id": "mondial_geo",
        "question": "Please list the top 3 countries with the highest inflation rate.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY T2.Inflation DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, inflation_rate FROM countries ORDER BY inflation_rate ASC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "671": {
        "db_id": "codebase_comments",
        "question": "Please state the API calls for method number 10 and its intended course of action.",
        "ground_truth": "SELECT T2.ApiCalls, T1.Path FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Id = 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM api_calls WHERE method_number = 10;"
        ],
        "rule_sql": []
    },
    "3519": {
        "db_id": "authors",
        "question": "Which author of the paper \"Incremental Extraction of Keyterms for Classifying Multilingual Documents in the Web\" is affiliated with National Taiwan University Department of Computer Science and Information Engineering Taiwan?",
        "ground_truth": "SELECT T1.Name FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE T2.Title = 'Incremental Extraction of Keyterms for Classifying Multilingual Documents in the Web' AND T1.Affiliation = 'National Taiwan University Department of Computer Science and Information Engineering Taiwan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM authors WHERE paper_title = 'Incremental Extraction of Keyterms for Classifying Multilingual Documents in the Web' AND affiliation = 'National Taiwan University Department of Computer Science and Information Engineering Taiwan'"
        ],
        "rule_sql": []
    },
    "7003": {
        "db_id": "works_cycles",
        "question": "List the product name with more than 5 quantity in the shopping cart.",
        "ground_truth": "SELECT T1.Name FROM Product AS T1 INNER JOIN ShoppingCartItem AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Quantity > 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM shopping_cart WHERE quantity > 5;"
        ],
        "rule_sql": []
    },
    "3776": {
        "db_id": "public_review_platform",
        "question": "Give the number of users who joined Yelp since \"2004\".",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_yelping_since_year = 2004",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE join_date > '2004'"
        ],
        "rule_sql": []
    },
    "3995": {
        "db_id": "public_review_platform",
        "question": "How many business have low check-in on Sunday at 10AM?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Days AS T1 INNER JOIN Checkins AS T2 ON T1.day_id = T2.day_id WHERE T1.day_of_week = 'Sunday' AND T2.label_time_10 = 'Low'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM business WHERE checkin_day = 'Sunday' AND checkin_time = '10AM' AND checkin_count < 5;"
        ],
        "rule_sql": []
    },
    "1170": {
        "db_id": "talkingdata",
        "question": "List down the labels' IDs and categories of the app ID \"5758400314709850000\".",
        "ground_truth": "SELECT T1.label_id, T2.category FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T1.label_id = T2.label_id WHERE T1.app_id = 5758400314709850000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT label_id, category FROM labels WHERE app_id = '5758400314709850000';"
        ],
        "rule_sql": []
    },
    "7761": {
        "db_id": "hockey",
        "question": "What were the penalty minutes in 1923's Stanley Cup finals of the team that ranked second in that year?",
        "ground_truth": "SELECT T1.PIM FROM TeamsSC AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = '1923' AND T2.rank = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT penalty_minutes \nFROM stanley_cup_finals \nWHERE year = 1923 \nAND team_rank = 1;"
        ],
        "rule_sql": []
    },
    "1135": {
        "db_id": "talkingdata",
        "question": "How many devices are of the brand vivo?",
        "ground_truth": "SELECT COUNT(device_id) FROM phone_brand_device_model2 WHERE phone_brand = 'vivo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM devices WHERE brand = 'samsung';"
        ],
        "rule_sql": []
    },
    "8027": {
        "db_id": "university",
        "question": "How many students attended universities were there in 2011?",
        "ground_truth": "SELECT SUM(num_students) FROM university_year WHERE year = 2011",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE university = '2011';"
        ],
        "rule_sql": []
    },
    "885": {
        "db_id": "cs_semester",
        "question": "Give the phone number of the only student who obtained \"A\" in the course \"Intro to BlockChain\".",
        "ground_truth": "SELECT T1.phone_number FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Intro to BlockChain' AND T2.grade = 'A'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number FROM students WHERE grade = 'A' AND course = 'Intro to BlockChain'"
        ],
        "rule_sql": []
    },
    "1324": {
        "db_id": "law_episode",
        "question": "On what episode did Julia Roberts win the \"Outstanding Guest Actress in a Drama Series\" award during the 1999 Primetime Emmy Awards? Tell me her role.",
        "ground_truth": "SELECT T3.episode_id, T2.role FROM Person AS T1 INNER JOIN Award AS T2 ON T1.person_id = T2.person_id INNER JOIN Episode AS T3 ON T2.episode_id = T3.episode_id WHERE T2.year = 1999 AND T2.award = 'Outstanding Guest Actress in a Drama Series' AND T2.organization = 'Primetime Emmy Awards' AND T1.name = 'Julia Roberts' AND T2.result = 'Nominee'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_name, role FROM emmy_awards WHERE winner = 'Julia Roberts' AND award_category = 'Outstanding Guest Actress in a Comedy Series' AND year = 1999;"
        ],
        "rule_sql": []
    },
    "3639": {
        "db_id": "authors",
        "question": "How many authors are affiliated with NASA Langley Research Center?",
        "ground_truth": "SELECT COUNT(Name) FROM Author WHERE Affiliation = 'NASA Langley Research Center'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM authors WHERE affiliation = 'NASA Langley Research Center';"
        ],
        "rule_sql": []
    },
    "1747": {
        "db_id": "restaurant",
        "question": "Indicate the address of the restaurant with the most popular reviews.",
        "ground_truth": "SELECT T2.street_num, T2.street_name FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant ORDER BY T1.review DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM restaurants ORDER BY review_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6203": {
        "db_id": "food_inspection_2",
        "question": "Calculate the total salary for employees who did inspection from ID 52270 to 52272.",
        "ground_truth": "SELECT SUM(T2.salary) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE T1.inspection_id BETWEEN 52270 AND 52272",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(salary) FROM employees WHERE employee_id BETWEEN 52270 AND 52272 AND job_title = 'inspector';"
        ],
        "rule_sql": []
    },
    "1449": {
        "db_id": "synthea",
        "question": "How many patients with 'allergy to eggs' have been immunized with 'Td (adult) preservative free'?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.patient) FROM allergies AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN immunizations AS T3 ON T2.patient = T3.PATIENT WHERE T1.DESCRIPTION = 'Allergy to eggs' AND T3.DESCRIPTION = 'Td (adult) preservative free'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients p \nJOIN immunizations i ON p.patient_id = i.patient_id \nWHERE p.allergy = 'allergy to eggs' \nAND i.vaccine_name = 'Td (adult) preservative free';"
        ],
        "rule_sql": []
    },
    "8691": {
        "db_id": "chicago_crime",
        "question": "Among the incidents reported in Harrison, what percentage are disorderly conduct?",
        "ground_truth": "SELECT COUNT(CASE WHEN T3.title = 'Disorderly Conduct' THEN T2.report_no END) * 100.0 / COUNT(T2.report_no) AS per FROM District AS T1 INNER JOIN Crime AS T2 ON T2.district_no = T1.district_no INNER JOIN FBI_Code AS T3 ON T3.fbi_code_no = T2.fbi_code_no WHERE T1.district_name = 'Harrison'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN incident_type = 'Disorderly Conduct' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM incidents\nWHERE city = 'Harrison';"
        ],
        "rule_sql": []
    },
    "9129": {
        "db_id": "movie_3",
        "question": "Please list the titles of all the films that the customer RUTH MARTINEZ has rented.",
        "ground_truth": "SELECT T4.title FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id INNER JOIN inventory AS T3 ON T2.inventory_id = T3.inventory_id INNER JOIN film AS T4 ON T3.film_id = T4.film_id WHERE T1.first_name = 'RUTH' AND T1.last_name = 'MARTINEZ'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title FROM film f JOIN inventory i ON f.film_id = i.film_id JOIN rental r ON i.inventory_id = r.inventory_id JOIN customer c ON r.customer_id = c.customer_id WHERE c.first_name = 'RUTH'"
        ],
        "rule_sql": []
    },
    "1654": {
        "db_id": "car_retails",
        "question": "Among the customers of empolyee 1370, who has the highest credit limit?Please list the full name of the contact person.",
        "ground_truth": "SELECT t2.contactFirstName, t2.contactLastName FROM employees AS t1 INNER JOIN customers AS t2 ON t1.employeeNumber = t2.salesRepEmployeeNumber WHERE t1.employeeNumber = '1370' ORDER BY t2.creditLimit DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contactFirstName, contactLastName FROM customers WHERE employeeNumber = 1370 ORDER BY creditLimit DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3455": {
        "db_id": "video_games",
        "question": "What are the names of games that were released in 2007?",
        "ground_truth": "SELECT T3.game_name FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id WHERE T1.release_year = 2007",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE release_year = '2007';"
        ],
        "rule_sql": []
    },
    "5663": {
        "db_id": "shipping",
        "question": "How many shipments were shipped by the driver named Zachary Hicks?",
        "ground_truth": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.driver_id = 23",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE driver_name = 'Zachary Hicks';"
        ],
        "rule_sql": []
    },
    "8798": {
        "db_id": "food_inspection",
        "question": "Give the address of the business with the most number of the low risk violations.",
        "ground_truth": "SELECT T2.address FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.risk_category = 'Low Risk' GROUP BY T2.address ORDER BY COUNT(T1.business_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM businesses ORDER BY COUNT(violations) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8808": {
        "db_id": "food_inspection",
        "question": "How many owners have 5 or more establishments?",
        "ground_truth": "SELECT COUNT(T1.owner_name) FROM ( SELECT owner_name FROM businesses GROUP BY owner_name HAVING COUNT(owner_name) > 5 ) T1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM owners WHERE establishments >= 5;"
        ],
        "rule_sql": []
    },
    "4921": {
        "db_id": "olympics",
        "question": "In which city was the 1992 Summer Olympic Games held?",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T3.games_name = '1992 Summer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM olympic_games WHERE year = 1992 AND season = 'Winter';"
        ],
        "rule_sql": []
    },
    "4333": {
        "db_id": "simpson_episodes",
        "question": "How many awards had been held in 2009?",
        "ground_truth": "SELECT COUNT(award_id) FROM Award WHERE SUBSTR(year, 1, 4) = '2009';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM awards WHERE year = '2009';"
        ],
        "rule_sql": []
    },
    "1227": {
        "db_id": "talkingdata",
        "question": "How many users belong to the same behavior category as comics?",
        "ground_truth": "SELECT COUNT(T2.app_id) FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE T1.category = 'comics'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE behavior_category = 'comics';"
        ],
        "rule_sql": []
    },
    "4854": {
        "db_id": "legislator",
        "question": "List all the representatives in 1789 along with the districts and state.",
        "ground_truth": "SELECT T2.district, T2.state FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.start LIKE '1789%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, district, state FROM representatives WHERE year = 1789;"
        ],
        "rule_sql": []
    },
    "4469": {
        "db_id": "student_loan",
        "question": "How many female students have no payment due?",
        "ground_truth": "SELECT COUNT(name) FROM no_payment_due WHERE name NOT IN ( SELECT name FROM male )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND payment_due = 0;"
        ],
        "rule_sql": []
    },
    "1575": {
        "db_id": "car_retails",
        "question": "How many Sales Manager who are working in Sydney? List out their email.",
        "ground_truth": "SELECT T1.email FROM employees AS T1 INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE T1.jobTitle LIKE '%Sales Manager%' AND T2.city = 'Sydney'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as count, email FROM employees WHERE job_title = 'Sales Manager' AND city = 'Sydney';"
        ],
        "rule_sql": []
    },
    "4531": {
        "db_id": "student_loan",
        "question": "How many students have been absent less than 4 months?",
        "ground_truth": "SELECT COUNT(name) FROM longest_absense_from_school WHERE month < 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE months_absent >= 4;"
        ],
        "rule_sql": []
    },
    "730": {
        "db_id": "movie",
        "question": "Please list the names of the characters in the movie Look Who's Talking.",
        "ground_truth": "SELECT T2.`Character Name` FROM movie AS T1 INNER JOIN characters AS T2 ON T1.MovieID = T2.MovieID WHERE T1.Title = 'Look Who''s Talking'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM characters WHERE movie_title = 'Look Who''s Talking';"
        ],
        "rule_sql": []
    },
    "3897": {
        "db_id": "public_review_platform",
        "question": "List the closing time and day of week of active businesses in Tempe with stars greater than the 70% of average age of star rating.",
        "ground_truth": "SELECT T2.closing_time, T3.day_of_week FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Tempe' AND T1.active LIKE 'TRUE' AND T1.stars > 0.7 * ( SELECT AVG(T1.stars) FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city LIKE 'Tempe' AND T1.active LIKE 'TRUE' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT closing_time, day_of_week \nFROM businesses \nWHERE city = 'Tempe' \nAND active = 1 \nAND stars > (SELECT AVG(age) * 0.7 FROM stars)"
        ],
        "rule_sql": []
    },
    "1007": {
        "db_id": "computer_student",
        "question": "List down the advised student IDs and IDs of employing professor in faculty.",
        "ground_truth": "SELECT T1.p_id, T2.p_id FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id_dummy = T2.p_id WHERE hasPosition = 'Faculty_eme'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT student_id, professor_id FROM faculty WHERE employment_status = 'advised'"
        ],
        "rule_sql": []
    },
    "4495": {
        "db_id": "student_loan",
        "question": "Among the students with payment due, how many of them are unemployed?",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN unemployed AS T2 ON T2.name = T1.name WHERE T1.bool = 'pos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE payment_due = 1 AND employment_status = 'unemployed';"
        ],
        "rule_sql": []
    },
    "5191": {
        "db_id": "address",
        "question": "What is the name and the position of the CBSA officer in the city of Cabo Rojo?",
        "ground_truth": "SELECT T1.CBSA_name, T1.CBSA_type FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T2.city = 'Cabo Rojo' GROUP BY T1.CBSA_name, T1.CBSA_type",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, position FROM cbsa_officers WHERE city = 'Cabo Rojo';"
        ],
        "rule_sql": []
    },
    "5439": {
        "db_id": "sales",
        "question": "List the sales ID of the product with a quantity of 590 and named \"External Lock Washer 7\".",
        "ground_truth": "SELECT T1.SalesID FROM Sales AS T1 INNER JOIN Products AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Name = 'External Lock Washer 7' AND T1.Quantity = 590",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sales_id FROM products WHERE quantity = 590 AND name = 'External Lock Washer 7';"
        ],
        "rule_sql": []
    },
    "1630": {
        "db_id": "car_retails",
        "question": "How many sales representitives are based in the offices in the USA?",
        "ground_truth": "SELECT COUNT(t1.employeeNumber) FROM employees AS t1 INNER JOIN offices AS t2 ON t1.officeCode = t2.officeCode WHERE t2.country = 'USA' AND t1.jobTitle = 'Sales Rep'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE jobTitle = 'Sales Rep' AND officeCode IN (SELECT officeCode FROM offices WHERE country = 'USA');"
        ],
        "rule_sql": []
    },
    "7498": {
        "db_id": "image_and_language",
        "question": "Give the object number of the sample which has the relationship of \"lying on\" with object sample no.1 from image no.2345524.",
        "ground_truth": "SELECT T2.OBJ1_SAMPLE_ID FROM PRED_CLASSES AS T1 INNER JOIN IMG_REL AS T2 ON T1.PRED_CLASS_ID = T2.PRED_CLASS_ID WHERE T2.IMG_ID = 2345524 AND T1.PRED_CLASS = 'lying on' AND T2.OBJ2_SAMPLE_ID = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_number FROM samples WHERE relationship = 'lying on' AND sample_no = 1 AND image_no = 2345524"
        ],
        "rule_sql": []
    },
    "5828": {
        "db_id": "airline",
        "question": "Among all the flights scheduled to depart from John F. Kennedy International on 2018/8/1, when was the earliest one scheduled to depart?",
        "ground_truth": "SELECT T2.DEP_TIME FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T2.FL_DATE = '2018/8/1' AND T1.Description = 'New York, NY: John F. Kennedy International' AND T2.DEP_TIME IS NOT NULL ORDER BY T2.DEP_TIME ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(departure_time) FROM flights WHERE origin = 'John F. Kennedy International' AND departure_date = '2018/8/1';"
        ],
        "rule_sql": []
    },
    "8108": {
        "db_id": "university",
        "question": "What is the score of university ID 68 in 2015?",
        "ground_truth": "SELECT score FROM university_ranking_year WHERE year = 2015 AND university_id = 68",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT score FROM universities WHERE id = 68 AND year = 2015;"
        ],
        "rule_sql": []
    },
    "1610": {
        "db_id": "car_retails",
        "question": "Who is the sales representative that made the order which was sent to 25 Maiden Lane, Floor No. 4?",
        "ground_truth": "SELECT T2.firstName, T2.lastName FROM customers AS T1 INNER JOIN employees AS T2 ON T1.salesRepEmployeeNumber = T2.employeeNumber WHERE T1.addressLine1 = '25 Maiden Lane' AND T1.addressLine2 = 'Floor No. 4'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employees.FirstName, employees.LastName \nFROM employees \nJOIN orders ON employees.EmployeeID = orders.EmployeeID \nWHERE orders.ShipAddress = '25 Maiden Lane, Floor No. 4';"
        ],
        "rule_sql": []
    },
    "5038": {
        "db_id": "olympics",
        "question": "What are the id of the games held in London?",
        "ground_truth": "SELECT T1.games_id FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id WHERE T2.city_name = 'London'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_id FROM games WHERE city = 'London';"
        ],
        "rule_sql": []
    },
    "2974": {
        "db_id": "shakespeare",
        "question": "List the number of acts in Two Gentlemen of Verona.",
        "ground_truth": "SELECT DISTINCT T1.Act FROM chapters AS T1 INNER JOIN works AS T2 ON T1.id = T1.work_id WHERE T2.LongTitle = 'Two Gentlemen of Verona'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM acts WHERE play_title = 'Two Gentlemen of Verona'"
        ],
        "rule_sql": []
    },
    "4411": {
        "db_id": "student_loan",
        "question": "How many unemployed and bankrupt students that have payment dues?",
        "ground_truth": "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name INNER JOIN no_payment_due AS T3 ON T2.name = T3.name WHERE T3.bool = 'pos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students \nWHERE employment_status = 'unemployed' \nAND financial_status = 'bankrupt' \nAND payment_due > 0"
        ],
        "rule_sql": []
    },
    "8737": {
        "db_id": "chicago_crime",
        "question": "How many crime cases have been classified as \"Weapons Violation\" by the FBI?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.title = 'Weapons Violation' THEN 1 ELSE 0 END) FROM Crime AS T1 INNER JOIN FBI_Code AS T2 ON T1.fbi_code_no = T2.fbi_code_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crime_cases WHERE fbi_classification = 'Weapons Violation';"
        ],
        "rule_sql": []
    },
    "7159": {
        "db_id": "works_cycles",
        "question": "What is the size of the photo of product id No.1?",
        "ground_truth": "SELECT T1.ThumbNailPhoto FROM ProductPhoto AS T1 INNER JOIN ProductProductPhoto AS T2 ON T1.ProductPhotoID = T2.ProductPhotoID WHERE T2.ProductID = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT photo_size FROM products WHERE product_id = 1;"
        ],
        "rule_sql": []
    },
    "701": {
        "db_id": "trains",
        "question": "In which direction does the train with an ellipse-shape car run?",
        "ground_truth": "SELECT T2.direction FROM cars AS T1 INNER JOIN trains AS T2 ON T1.train_id = T2.id WHERE T1.shape = 'ellipse'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT direction FROM trains WHERE car_shape = 'ellipse' ORDER BY train_id DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5427": {
        "db_id": "sales",
        "question": "How many of the employees have the last name \"Ringer\" ?",
        "ground_truth": "SELECT COUNT(LastName) FROM Employees WHERE LastName = 'Ringer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE first_name = 'Ringer';"
        ],
        "rule_sql": []
    },
    "2643": {
        "db_id": "regional_sales",
        "question": "What is the percentage of total orders of Stephen Payne that had a net profit of over 1000?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '') > 1000 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T2.`Sales Team` = 'Stephen Payne'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN net_profit > 1000 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM orders\nWHERE customer_name = 'Stephen Payne';"
        ],
        "rule_sql": []
    },
    "5285": {
        "db_id": "beer_factory",
        "question": "Which brand of root beer has the lowest unit profit available to wholesalers? Indicate the ID of the customer that has the highest number of purchases of the said brand.",
        "ground_truth": "SELECT T3.BrandName, T2.CustomerID FROM rootbeer AS T1 INNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID GROUP BY T3.BrandID ORDER BY T3.CurrentRetailPrice - T3.WholesaleCost, COUNT(T1.BrandID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.customer_id \nFROM customers c\nJOIN purchases p ON c.customer_id = p.customer_id\nJOIN products pr ON p.product_id = pr.product_id\nWHERE pr.brand = 'Root Beer'\nGROUP BY c.customer_id\nORDER BY COUNT(p.purchase_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8294": {
        "db_id": "mondial_geo",
        "question": "How many more people speak English than speak Scottish in United Kingdom?",
        "ground_truth": "SELECT T3.Population * (T2.Percentage - T1.Percentage) FROM ethnicGroup AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Country = T2.Country INNER JOIN country AS T3 ON T1.Country = T3.Code WHERE T1.Name = 'Scottish' AND T2.Name = 'English' AND T3.Name = 'United Kingdom'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE language = 'English' AND country = 'United Kingdom'"
        ],
        "rule_sql": []
    },
    "4471": {
        "db_id": "student_loan",
        "question": "List at least 10 students who have no payment due and are enlisted in Fire Department organization.",
        "ground_truth": "SELECT T1.name FROM no_payment_due AS T1 INNER JOIN enlist AS T2 ON T2.name = T1.name WHERE T1.bool = 'neg' AND T2.organ = 'fire_department' LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.student_id, s.name \nFROM students s\nJOIN organizations o ON s.organization_id = o.organization_id\nWHERE o.name = 'Fire Department'\nAND s.payment_due = 0\nLIMIT 10;"
        ],
        "rule_sql": []
    },
    "760": {
        "db_id": "movie",
        "question": "In rated PG movies, how many of them released in June 1990?",
        "ground_truth": "SELECT COUNT(*) FROM movie WHERE `MPAA Rating` = 'PG' AND `Release Date` LIKE '1990-06%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE rating = 'PG' AND release_date LIKE '1990-06%';"
        ],
        "rule_sql": []
    },
    "943": {
        "db_id": "cs_semester",
        "question": "What is the average teaching ability of the most popular professors?",
        "ground_truth": "SELECT CAST(SUM(teachingability) AS REAL) / COUNT(prof_id) FROM prof WHERE popularity = ( SELECT MAX(popularity) FROM prof )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(teaching_ability) \nFROM professors \nORDER BY popularity DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7373": {
        "db_id": "works_cycles",
        "question": "Which territory has the greatest difference in sales from previous year to this year? Indicate the difference, as well as the name and country of the region.",
        "ground_truth": "SELECT SalesLastYear - SalesYTD, Name, CountryRegionCode FROM SalesTerritory ORDER BY SalesLastYear - SalesYTD DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    t.TerritoryName,\n    t.Country,\n    (s1.SalesAmount - s2.SalesAmount) AS Difference\nFROM \n    Territories t\nJOIN \n    Sales s1 ON t.TerritoryID = s1.TerritoryID AND s1.Year = 2023\nJOIN \n    Sales s2 ON t.TerritoryID = s2.TerritoryID AND s2.Year = 2022\nORDER BY \n    ABS(Difference) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6992": {
        "db_id": "ice_hockey_draft",
        "question": "Which country do most players of team Plymouth Whalers come from?",
        "ground_truth": "SELECT T.nation FROM ( SELECT T1.nation, COUNT(T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.TEAM = 'Plymouth Whalers' GROUP BY T1.nation ORDER BY COUNT(T1.ELITEID) DESC LIMIT 1 ) AS T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as player_count \nFROM players \nWHERE team = 'Plymouth Whalers' \nGROUP BY country \nORDER BY player_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6723": {
        "db_id": "retails",
        "question": "Identify the names of the top 3 customers with the highest number of orders of all time and calculate for the average total price per order of each customers.",
        "ground_truth": "SELECT T.c_name, T.res FROM ( SELECT T2.c_name, SUM(T1.o_totalprice) / COUNT(T1.o_orderkey) AS res , COUNT(T1.o_orderkey) AS num FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey GROUP BY T1.o_custkey ) AS T ORDER BY T.num DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.customer_name, COUNT(o.order_id) as order_count, AVG(o.total_price) as avg_order_value\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id\nORDER BY order_count DESC\nLIMIT 3;"
        ],
        "rule_sql": []
    },
    "7921": {
        "db_id": "music_platform_2",
        "question": "List all podcast with its itunes url for all title containing the word 'Dream'.",
        "ground_truth": "SELECT itunes_url FROM podcasts WHERE title LIKE '%Dream%' GROUP BY itunes_url",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, itunes_url FROM podcasts WHERE title LIKE '%Dream%';"
        ],
        "rule_sql": []
    },
    "1312": {
        "db_id": "law_episode",
        "question": "What is the title of the episode with the most nominations?",
        "ground_truth": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.result = 'Nominee' GROUP BY T2.episode_id ORDER BY COUNT(T1.result) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY nominations DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2785": {
        "db_id": "european_football_1",
        "question": "Which team won the match of the Bundesliga division on 2020/10/2?",
        "ground_truth": "SELECT CASE WHEN T1.FTR = 'H' THEN T1.HomeTeam WHEN T1.FTR = 'A' THEN T1.AwayTeam END WINNER FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.Date = '2020-10-02' AND T2.name = 'Bundesliga'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE division = 'Bundesliga' AND match_date = '2020/10/2' AND result = 'win';"
        ],
        "rule_sql": []
    },
    "5796": {
        "db_id": "language_corpus",
        "question": "How many times does the word \"riu\" appears in the biwords pair?",
        "ground_truth": "SELECT COUNT(T1.wid) FROM words AS T1 INNER JOIN biwords AS T2 ON T1.wid = T2.w1st INNER JOIN words AS T3 ON T3.wid = T2.w2nd WHERE T1.word = 'riu'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM biwords WHERE word1 = 'riu' OR word2 = 'riu';"
        ],
        "rule_sql": []
    },
    "6106": {
        "db_id": "books",
        "question": "Write down the author's name of the book most recently published.",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id ORDER BY T1.publication_date DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM books ORDER BY publication_date ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3767": {
        "db_id": "public_review_platform",
        "question": "In which year did the user who gave the most number of \"5\" star reviews join the Yelp?",
        "ground_truth": "SELECT T2.user_yelping_since_year FROM Reviews AS T1 INNER JOIN Users AS T2 ON T1.user_id = T2.user_id WHERE T1.review_stars = 5 GROUP BY T2.user_yelping_since_year ORDER BY COUNT(T1.review_stars) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year_joined \nFROM users \nWHERE user_id IN (\n    SELECT user_id \n    FROM reviews \n    WHERE stars = 5 \n    GROUP BY user_id \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n) \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1145": {
        "db_id": "talkingdata",
        "question": "What is the brand of the device used by the most users in the M23-26 user group?",
        "ground_truth": "SELECT T.phone_brand FROM ( SELECT T2.phone_brand, COUNT(T1.device_id) AS num FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.`group` = 'M23-26' GROUP BY T2.phone_brand ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM devices GROUP BY brand ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4167": {
        "db_id": "simpson_episodes",
        "question": "What's the rating of the episode in which Dan Castellaneta won the Outstanding Voice-Over Performance award in 2009?",
        "ground_truth": "SELECT T2.rating FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award = 'Outstanding Voice-Over Performance' AND SUBSTR(T1.year, 1, 4) = '2009' AND T1.person = 'Dan Castellaneta';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating FROM episodes WHERE award = 'Outstanding Voice-Over Performance' AND year = 2009 AND winner = 'Dan Castellaneta';"
        ],
        "rule_sql": []
    },
    "9011": {
        "db_id": "bike_share_1",
        "question": "Which year experienced the most rain?",
        "ground_truth": "SELECT SUBSTR(CAST(date AS TEXT), -4) FROM weather GROUP BY SUBSTR(CAST(date AS TEXT), -4) ORDER BY SUM(CASE WHEN events LIKE '%Rain%' OR events LIKE '%rain%' THEN 1 ELSE 0 END) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, SUM(rainfall) as total_rain FROM weather_data GROUP BY year ORDER BY total_rain ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1076": {
        "db_id": "talkingdata",
        "question": "How many events in total have happened on the devices in 2016?",
        "ground_truth": "SELECT COUNT(event_id) FROM `events` WHERE SUBSTR(`timestamp`, 1, 4) = '2016'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE device_id IN (SELECT device_id FROM devices) AND year = 2016;"
        ],
        "rule_sql": []
    },
    "5281": {
        "db_id": "beer_factory",
        "question": "How many canned A&W were purchased in 2016?",
        "ground_truth": "SELECT COUNT(T1.BrandID) FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T1.ContainerType = 'Can' AND T2.BrandName = 'A&W' AND T1.PurchaseDate LIKE '2016%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM purchases WHERE product = 'A&W' AND year = 2016;"
        ],
        "rule_sql": []
    },
    "8709": {
        "db_id": "chicago_crime",
        "question": "What is the average population of the wards where apartment crimes have been reported without arrests?",
        "ground_truth": "SELECT AVG(T2.Population) FROM Crime AS T1 INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE T1.location_description = 'APARTMENT' AND T1.arrest = 'FALSE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(population) FROM wards WHERE crime_type = 'apartment' AND arrest_made = 'no';"
        ],
        "rule_sql": []
    },
    "5291": {
        "db_id": "beer_factory",
        "question": "How many brands of root beers are available in cans and contain corn syrup and artificial sweeteners?",
        "ground_truth": "SELECT COUNT(BrandID) FROM rootbeerbrand WHERE CornSyrup = 'TRUE' AND ArtificialSweetener = 'TRUE' AND AvailableInCans = 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE product_type = 'root beer' AND packaging = 'can' AND ingredients LIKE '%corn syrup%' AND ingredients LIKE '%artificial sweeteners%';"
        ],
        "rule_sql": []
    },
    "5088": {
        "db_id": "address",
        "question": "Please list the names of all the counties with at least one residential area that implements daylight saving.",
        "ground_truth": "SELECT DISTINCT T2.county FROM zip_data AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code WHERE T1.daylight_savings = 'Yes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county_name FROM counties WHERE daylight_saving = 'yes';"
        ],
        "rule_sql": []
    },
    "8690": {
        "db_id": "chicago_crime",
        "question": "List the name and population of the communities where more than average solicit for prostitutes were reported.",
        "ground_truth": "SELECT T2.community_area_name, T2.population FROM Crime AS T1 INNER JOIN Community_Area AS T2 ON T2.community_area_no = T1.community_area_no INNER JOIN IUCR AS T3 ON T3.iucr_no = T1.iucr_no WHERE T3.iucr_no = ( SELECT iucr_no FROM IUCR WHERE secondary_description = 'SOLICIT FOR PROSTITUTE' GROUP BY iucr_no HAVING COUNT(iucr_no) > ( SELECT SUM(CASE WHEN secondary_description = 'SOLICIT FOR PROSTITUTE' THEN 1.0 ELSE 0 END) / COUNT(iucr_no) AS average FROM IUCR ) )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, population FROM communities WHERE solicit_for_prostitutes > (SELECT AVG(solicit_for_prostitutes) FROM communities);"
        ],
        "rule_sql": []
    },
    "611": {
        "db_id": "codebase_comments",
        "question": "What is the repository number for the solution of method \"SCore.Poisson.ngtIndex\"?",
        "ground_truth": "SELECT T1.RepoId FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Name = 'SCore.Poisson.ngtIndex'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT repository_number FROM methods WHERE method_name = 'SCore.Poisson.ngtIndex';"
        ],
        "rule_sql": []
    },
    "1690": {
        "db_id": "restaurant",
        "question": "What restaurant on Drive Street in San Rafael doesn't serve American food?",
        "ground_truth": "SELECT T1.label FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_name = 'drive' AND T1.food_type != 'american' AND T2.city = 'san rafael'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE street = 'Drive Street' AND city = 'San Rafael' AND cuisine = 'American';"
        ],
        "rule_sql": []
    },
    "3197": {
        "db_id": "donor",
        "question": "Please list the vendor providing resources for the projects of a school with the highest poverty level.",
        "ground_truth": "SELECT T1.vendor_name FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.poverty_level = 'highest poverty'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name FROM vendors v JOIN projects p ON v.vendor_id = p.vendor_id JOIN schools s ON p.school_id = s.school_id WHERE s.poverty_level = (SELECT MAX(poverty_level) FROM schools) GROUP BY vendor_name;"
        ],
        "rule_sql": []
    },
    "7897": {
        "db_id": "world",
        "question": "How many languages are there in the country where Tocantins district belongs?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.Language) FROM City AS T1 INNER JOIN CountryLanguage AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.District = 'Tocantins'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM languages WHERE country_id = (SELECT country_id FROM districts WHERE name = 'Tocantins');"
        ],
        "rule_sql": []
    },
    "139": {
        "db_id": "movie_platform",
        "question": "Among the lists created in 2016, which is the list that was updated most recently.",
        "ground_truth": "SELECT list_title FROM lists WHERE strftime('%Y', list_update_timestamp_utc) = '2016' ORDER BY list_update_timestamp_utc DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT list_name FROM lists WHERE created_year = 2016 ORDER BY created_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2542": {
        "db_id": "app_store",
        "question": "Which Photography app has the highest total Sentiment subjectivity score?",
        "ground_truth": "SELECT T1.App FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Genres = 'Photography' GROUP BY T1.App ORDER BY SUM(T2.Sentiment_Subjectivity) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name, SUM(sentiment_subjectivity) as total_subjectivity\nFROM photography_apps\nGROUP BY app_name\nORDER BY total_subjectivity ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "331": {
        "db_id": "retail_complains",
        "question": "What is the social number of the person who made the most complaints?",
        "ground_truth": "SELECT T1.social FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID GROUP BY T1.client_id ORDER BY COUNT(T1.client_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT social_number FROM complaints ORDER BY complaint_id DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8350": {
        "db_id": "mondial_geo",
        "question": "What are the names of the rivers in Canada?",
        "ground_truth": "SELECT DISTINCT T1.River FROM located AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T2.Name = 'Canada' AND T1.River IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM rivers WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "3200": {
        "db_id": "donor",
        "question": "What is the total donated amount for projects created by a teacher working in a school in Brooklyn?",
        "ground_truth": "SELECT SUM(T2.donation_total) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.school_city = 'Brooklyn'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(donation_amount) AS total_donated\nFROM donations d\nJOIN projects p ON d.project_id = p.project_id\nJOIN teachers t ON p.teacher_id = t.teacher_id\nJOIN schools s ON t.school_id = s.school_id\nWHERE s.city = 'Brooklyn';"
        ],
        "rule_sql": []
    },
    "8005": {
        "db_id": "university",
        "question": "How many universities have no less than 20,000 female students in 2016? Identify how many of the said universities are located in the United States of America.",
        "ground_truth": "SELECT COUNT(*) , SUM(CASE WHEN T3.country_name = 'United States of America' THEN 1 ELSE 0 END) AS nums_in_usa FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.year = 2016 AND T2.num_students * T2.pct_female_students / 100 > 20000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM universities u\nJOIN student_counts sc ON u.university_id = sc.university_id\nWHERE sc.year = 2016 \nAND sc.female_students >= 20000\nAND u.country = 'United States of America';"
        ],
        "rule_sql": []
    },
    "8121": {
        "db_id": "university",
        "question": "How many female students are there in University of Pennsylvania in 2011?",
        "ground_truth": "SELECT CAST(T1.num_students * T1.pct_female_students AS REAL) / 100 FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2011 AND T2.university_name = 'University of Pennsylvania'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND university = 'University of Pennsylvania' AND year = 2011;"
        ],
        "rule_sql": []
    },
    "6293": {
        "db_id": "coinmarketcap",
        "question": "When is the highest price of Terracoin?",
        "ground_truth": "SELECT T2.date FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Terracoin' ORDER BY T2.price DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(price) FROM crypto_prices WHERE currency = 'Terracoin' ORDER BY price DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1160": {
        "db_id": "talkingdata",
        "question": "What is the ratio of female users to male users who uses a vivo device?",
        "ground_truth": "SELECT SUM(IIF(T1.gender = 'M', 1, 0)) / SUM(IIF(T1.gender = 'F', 1, 0)) AS per FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM users WHERE gender = 'female' AND device = 'vivo') / \n    (SELECT COUNT(*) FROM users WHERE gender = 'male' AND device = 'vivo') AS female_to_male_ratio"
        ],
        "rule_sql": []
    },
    "9281": {
        "db_id": "movie_3",
        "question": "In which country is the store where Hector Poinexter rents equipment located?",
        "ground_truth": "SELECT T5.country FROM customer AS T1 INNER JOIN store AS T2 ON T1.store_id = T2.store_id INNER JOIN address AS T3 ON T2.address_id = T3.address_id INNER JOIN city AS T4 ON T3.city_id = T4.city_id INNER JOIN country AS T5 ON T4.country_id = T5.country_id WHERE T1.first_name = 'HECTOR' AND T1.last_name = 'POINDEXTER'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM stores WHERE store_id = (SELECT store_id FROM rentals WHERE customer_name = 'Hector Poinexter')"
        ],
        "rule_sql": []
    },
    "255": {
        "db_id": "retail_complains",
        "question": "Please list the full names of all the male clients in the Pacific division.",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.division = 'Pacific' AND T1.sex = 'Male'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE gender = 'female' AND division = 'Pacific';"
        ],
        "rule_sql": []
    },
    "8167": {
        "db_id": "sales_in_weather",
        "question": "Give the number of stores which opened on the weather station that recorded the fastest average wind speed.",
        "ground_truth": "SELECT COUNT(T.store_nbr) FROM ( SELECT DISTINCT store_nbr FROM relation WHERE station_nbr = ( SELECT station_nbr FROM weather ORDER BY avgspeed DESC LIMIT 1 ) ) T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM stores s\nJOIN weather_stations ws ON s.weather_station_id = ws.id\nWHERE ws.average_wind_speed = (SELECT MAX(average_wind_speed) FROM weather_stations)\nAND s.opening_date IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "7258": {
        "db_id": "works_cycles",
        "question": "What is the position of the employee with the 10th highest salary? Indicate his/her salary amount and his/her full name.",
        "ground_truth": "SELECT T2.JobTitle, T1.Rate, T3.FirstName, T3.MiddleName, T3.LastName FROM EmployeePayHistory AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Person AS T3 ON T2.BusinessEntityID = T3.BusinessEntityID ORDER BY T1.Rate DESC LIMIT 9, 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position, salary, full_name FROM employees ORDER BY salary DESC LIMIT 1 OFFSET 9;"
        ],
        "rule_sql": []
    },
    "7833": {
        "db_id": "world",
        "question": "Provide the name, located country, and life expectancy of the most populated city",
        "ground_truth": "SELECT T2.Name, T1.Code, T1.LifeExpectancy FROM Country AS T1 INNER JOIN City AS T2 ON T1.Code = T2.CountryCode ORDER BY T2.Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, country, life_expectancy FROM cities ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2437": {
        "db_id": "superstore",
        "question": "What is the name of the product that Aimee Bixby bought?",
        "ground_truth": "SELECT DISTINCT T3.`Product Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T2.`Customer Name` = 'Aimee Bixby'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE customer_name = 'Aimee Bixby';"
        ],
        "rule_sql": []
    },
    "2146": {
        "db_id": "world_development_indicators",
        "question": "What percentage of upper middle income countries which have the CO2 emissions from liquid fuel consumption (% of total)\n\nless than 80%?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.IndicatorName = 'CO2 emissions FROM liquid fuel consumption (% of total)' AND t2.Value < 80 THEN 1 ELSE 0 END) * 1.0 / COUNT(T1.CountryCode) persent FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IncomeGroup = 'Upper middle income'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN co2_emissions.liquid_fuel_percent < 80 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    countries\nJOIN \n    co2_emissions ON countries.country_code = co2_emissions.country_code\nWHERE \n    countries.income_group = 'Upper middle income';"
        ],
        "rule_sql": []
    },
    "4874": {
        "db_id": "legislator",
        "question": "Which party has the highest number of legislators who are Baptist?",
        "ground_truth": "SELECT T2.party FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.religion_bio = 'Baptist' GROUP BY T2.party ORDER BY COUNT(T2.party) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT party, COUNT(*) as baptist_count \nFROM legislators \nWHERE religion = 'Baptist' \nGROUP BY party \nORDER BY baptist_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3876": {
        "db_id": "public_review_platform",
        "question": "How many stars on average does user no.3 give to Yelp_Business in Arizona?",
        "ground_truth": "SELECT AVG(T2.review_stars) FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id WHERE T1.state LIKE 'AZ' AND T2.user_id = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(stars) FROM reviews WHERE user_id = 3 AND business_id IN (SELECT business_id FROM business WHERE state = 'AZ');"
        ],
        "rule_sql": []
    },
    "2351": {
        "db_id": "superstore",
        "question": "Please list the names of all the products ordered by Aimee Bixby in 2016.",
        "ground_truth": "SELECT DISTINCT T3.`Product Name` FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T2.`Product ID` WHERE T1.`Customer Name` = 'Aimee Bixby' AND STRFTIME('%Y', T2.`Ship Date`) = '2016'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM products p \nJOIN orders o ON p.id = o.product_id \nJOIN customers c ON o.customer_id = c.id \nWHERE c.name = 'Aimee Bixby' \nAND o.order_date LIKE '2016%';"
        ],
        "rule_sql": []
    },
    "4953": {
        "db_id": "olympics",
        "question": "How many Olympic events did Michael Phelps II join in total? Find the percentage of the events where he won a gold medal.",
        "ground_truth": "SELECT COUNT(T3.event_id) , CAST(COUNT(CASE WHEN T4.id = '1' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T4.id) FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id INNER JOIN competitor_event AS T3 ON T2.id = T3.competitor_id INNER JOIN medal AS T4 ON T3.medal_id = T4.id WHERE T1.full_name = 'Michael Fred Phelps, II'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(DISTINCT event_id) as total_events,\n    (COUNT(CASE WHEN medal = 'Gold' THEN 1 END) * 100.0 / COUNT(*)) as gold_percentage\nFROM athlete_events\nWHERE name = 'Michael Phelps II'"
        ],
        "rule_sql": []
    },
    "1219": {
        "db_id": "talkingdata",
        "question": "What is the difference between the events of device number -9222956879900150000 that can be located and those that are unable to be located?",
        "ground_truth": "SELECT SUM(IIF(latitude != 0 AND longitude != 0, 1, 0)) - SUM(IIF(latitude = 0 AND longitude = 0, 1, 0)) AS diff FROM events WHERE device_id = '-922956879900150000'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN 1 END) AS located_events,\n    COUNT(CASE WHEN latitude IS NULL OR longitude IS NULL THEN 1 END) AS unlocated_events,\n    COUNT(CASE WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN 1 END) - COUNT(CASE WHEN latitude IS NULL OR longitude IS NULL THEN 1 END) AS difference\nFROM events\nWHERE device_id = -9222956879900150000;"
        ],
        "rule_sql": []
    },
    "4784": {
        "db_id": "legislator",
        "question": "What is the contact URL of Claire McCaskill?",
        "ground_truth": "SELECT T2.contact_form FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.official_full_name = 'Claire McCaskill' GROUP BY T2.contact_form",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contact_url FROM politicians WHERE first_name = 'Claire' AND last_name = 'McCaskill';"
        ],
        "rule_sql": []
    },
    "7614": {
        "db_id": "hockey",
        "question": "Who are the players who were not in the Hall of Fame list.",
        "ground_truth": "SELECT firstName, lastName FROM Master WHERE hofID IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM players WHERE hall_of_fame = 'Yes';"
        ],
        "rule_sql": []
    },
    "828": {
        "db_id": "social_media",
        "question": "List down all the tweet text posted from Australia.",
        "ground_truth": "SELECT T1.text FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID WHERE T2.Country = 'Australia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE country = 'Australia';"
        ],
        "rule_sql": []
    },
    "4628": {
        "db_id": "disney",
        "question": "Please list the release dates of all the movies in which Alan Tudyk is a voice actor.",
        "ground_truth": "SELECT T2.release_date FROM `voice-actors` AS T1 INNER JOIN characters AS T2 ON T1.movie = T2.movie_title WHERE T1.`voice-actor` = 'Alan Tudyk'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT release_date FROM movies WHERE actor = 'Alan Tudyk';"
        ],
        "rule_sql": []
    },
    "4592": {
        "db_id": "mental_health_survey",
        "question": "How many users answered \"Yes\" to the question \"Have you had a mental health disorder in the past?\" in 3 consecutive years starting from 2016?",
        "ground_truth": "SELECT COUNT(T2.UserID) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID IN (2016, 2017, 2018) AND T1.questiontext LIKE 'Have you had a mental health disorder in the past?' AND T2.AnswerText = 'Yes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM survey_responses \nWHERE question = 'Have you had a mental health disorder in the past?' \nAND answer = 'Yes' \nAND year BETWEEN 2016 AND 2018 \nGROUP BY user_id \nHAVING COUNT(DISTINCT year) = 3"
        ],
        "rule_sql": []
    },
    "673": {
        "db_id": "codebase_comments",
        "question": "What is the comment format of method number 50 with the solution path \"managedfusion_managedfusion\\ManagedFusion.sln\"?",
        "ground_truth": "SELECT CASE WHEN T2.CommentIsXml = 0 THEN 'isNotXMLFormat' WHEN T2.CommentIsXml = 1 THEN 'isXMLFormat' END format FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE T2.Id = 50 AND T1.Path = 'managedfusion_managedfusionManagedFusion.sln'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT comment FROM methods WHERE method_id = 50 AND solution_path = 'managedfusion_managedfusion\\ManagedFusion.sln';"
        ],
        "rule_sql": []
    },
    "5004": {
        "db_id": "olympics",
        "question": "What is the id of Rio de Janeiro?",
        "ground_truth": "SELECT id FROM city WHERE city_name = 'Rio de Janeiro'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cities WHERE id = 'Rio de Janeiro';"
        ],
        "rule_sql": []
    },
    "201": {
        "db_id": "book_publishing_company",
        "question": "What is the highest level of job to get to for the employee who got hired the earliest?",
        "ground_truth": "SELECT T2.max_lvl FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id ORDER BY T1.hire_date LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(job_level) FROM employees WHERE hire_date = (SELECT MIN(hire_date) FROM employees);"
        ],
        "rule_sql": []
    },
    "4024": {
        "db_id": "public_review_platform",
        "question": "Among the businesses without attribute, how many businesses located in Gilbert?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Business_Attributes AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T2.city = 'Gilbert' AND T1.attribute_value IN ('None', 'no', 'false')",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Gilbert' AND attribute IS NULL;"
        ],
        "rule_sql": []
    },
    "2153": {
        "db_id": "world_development_indicators",
        "question": "List out the country name of lower earning countries",
        "ground_truth": "SELECT DISTINCT T2.CountryName FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.IncomeGroup = 'Low income'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE income < (SELECT AVG(income) FROM countries) ORDER BY income DESC;"
        ],
        "rule_sql": []
    },
    "4444": {
        "db_id": "student_loan",
        "question": "How many students have been absents for more than 6 months?",
        "ground_truth": "SELECT COUNT(name) FROM longest_absense_from_school WHERE month > 6",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE absents > 6;"
        ],
        "rule_sql": []
    },
    "9335": {
        "db_id": "movie_3",
        "question": "Calculate the total payment amount of customers in Nagasaki district.",
        "ground_truth": "SELECT SUM(T1.amount) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id INNER JOIN address AS T3 ON T3.address_id = T2.address_id WHERE T3.district = 'Nagasaki'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM payments WHERE district = 'Nagasaki';"
        ],
        "rule_sql": []
    },
    "6848": {
        "db_id": "retails",
        "question": "List the comments describing orders from customers in the furniture segment.",
        "ground_truth": "SELECT T1.o_comment FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_mktsegment = 'FURNITURE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.comment_text \nFROM comments c\nJOIN orders o ON c.order_id = o.order_id\nJOIN customers cust ON o.customer_id = cust.customer_id\nWHERE cust.segment = 'furniture';"
        ],
        "rule_sql": []
    },
    "1808": {
        "db_id": "soccer_2016",
        "question": "Give the name of venue for the game with a win margin of 138 points.",
        "ground_truth": "SELECT T2.Venue_Name FROM `Match` AS T1 INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id WHERE T1.Win_Margin = 138",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue FROM games WHERE win_margin = 138;"
        ],
        "rule_sql": []
    },
    "8628": {
        "db_id": "chicago_crime",
        "question": "Which crime was committed the most by criminals?",
        "ground_truth": "SELECT T2.title FROM Crime AS T1 INNER JOIN FBI_Code AS T2 ON T1.fbi_code_no = T2.fbi_code_no ORDER BY T2.fbi_code_no DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT crime_type, COUNT(*) as crime_count FROM crimes GROUP BY criminal_id ORDER BY crime_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "245": {
        "db_id": "retail_complains",
        "question": "What is the detailed product of the complaint filed by Diesel Galloway on 2014/7/3?",
        "ground_truth": "SELECT T2.`Sub-product` FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Diesel' AND T1.last = 'Galloway' AND T2.`Date received` = '2014-07-03'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM complaints WHERE complainant_name = 'Diesel Galloway' AND complaint_date = '2014/7/3';"
        ],
        "rule_sql": []
    },
    "9258": {
        "db_id": "movie_3",
        "question": "Calculate the percentage of customers who paid more than the average rent amount in store 1.",
        "ground_truth": "SELECT CAST(( SELECT COUNT(T1.customer_id) FROM customer AS T1 INNER JOIN payment AS T2 ON T1.customer_id = T2.customer_id WHERE T2.amount > ( SELECT AVG(amount) FROM payment ) ) AS REAL) * 100 / ( SELECT COUNT(customer_id) FROM customer )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.amount > (SELECT AVG(amount) FROM payment WHERE store_id = 1) THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM payment p\nWHERE p.store_id = 1;"
        ],
        "rule_sql": []
    },
    "8025": {
        "db_id": "university",
        "question": "Provide the country name of universities with the number of students greater than 98% of the average student population of all universities in 2013.",
        "ground_truth": "SELECT DISTINCT T3.country_name FROM university AS T1 INNER JOIN university_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T2.year = 2013 AND T2.num_students * 100 > ( SELECT AVG(num_students) FROM university_year ) * 98",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) as num_universities \nFROM universities \nWHERE students > (SELECT AVG(students) * 0.98 FROM universities WHERE year = 2013) \nAND year = 2013 \nGROUP BY country;"
        ],
        "rule_sql": []
    },
    "535": {
        "db_id": "movies_4",
        "question": "What percentage of films are made in the US?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.COUNTry_iso_code = 'US' THEN T1.movie_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM films)) AS percentage FROM films WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "3073": {
        "db_id": "cars",
        "question": "Please list the weights of all the cars with the price over $40000.",
        "ground_truth": "SELECT T1.weight FROM data AS T1 INNER JOIN price AS T2 ON T1.ID = T2.ID WHERE T2.price > 40000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT weight FROM cars WHERE price > 40000;"
        ],
        "rule_sql": []
    },
    "5954": {
        "db_id": "books",
        "question": "What is the name of the publisher who published Agatha Christie's first book?",
        "ground_truth": "SELECT T4.publisher_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE T3.author_name = 'Agatha Christie' ORDER BY T1.publication_date ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name FROM books WHERE author = 'Agatha Christie' ORDER BY publication_year ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8388": {
        "db_id": "mondial_geo",
        "question": "What is the longitude of the island on which Mount Olympos is located?",
        "ground_truth": "SELECT T3.Longitude FROM mountain AS T1 INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Mountain INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE T1.Name = 'Olympos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude FROM islands WHERE name = 'Mount Olympos';"
        ],
        "rule_sql": []
    },
    "9147": {
        "db_id": "movie_3",
        "question": "What is the phone number of address No.72?",
        "ground_truth": "SELECT phone FROM address WHERE address_id = '72'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM addresses WHERE address = 'No.72';"
        ],
        "rule_sql": []
    },
    "5762": {
        "db_id": "language_corpus",
        "question": "Which word that has 71303 appearance in the Catalan language?",
        "ground_truth": "SELECT T1.word FROM words AS T1 INNER JOIN langs_words AS T2 ON T1.wid = T2.wid WHERE T2.occurrences = 71303",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word FROM catalan_words WHERE appearance = 71303;"
        ],
        "rule_sql": []
    },
    "8882": {
        "db_id": "cookbook",
        "question": "Give the name of the most widely used ingredient.",
        "ground_truth": "SELECT T1.name FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id GROUP BY T1.name ORDER BY COUNT(T1.name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ingredient_name FROM ingredients ORDER BY usage_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8297": {
        "db_id": "mondial_geo",
        "question": "Please list the capital cities of the countries that have more than 4 mountains.",
        "ground_truth": "SELECT T1.Capital FROM country AS T1 INNER JOIN geo_mountain AS T2 ON T1.Code = T2.Country GROUP BY T1.Name, T1.Capital HAVING COUNT(T1.Name) > 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city.name \nFROM city \nJOIN country ON city.id = country.capital \nJOIN mountain_country ON country.id = mountain_country.country_id \nGROUP BY city.name \nHAVING COUNT(mountain_country.mountain_id) > 4;"
        ],
        "rule_sql": []
    },
    "2715": {
        "db_id": "regional_sales",
        "question": "What is the store id of the store located in the most populous county?",
        "ground_truth": "SELECT CASE WHEN MAX(Population) THEN StoreID END FROM `Store Locations`",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_id FROM stores ORDER BY county_population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4042": {
        "db_id": "public_review_platform",
        "question": "What is the ratio of good to bad business star for a businesses that are opened all the time?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.stars BETWEEN 3.5 AND 5 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.stars BETWEEN 1 AND 2.5 THEN 1 ELSE 0 END) AS ratio FROM Business AS T1 INNER JOIN Business_Hours AS T2 ON T1.business_id = T2.business_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN stars >= 4 THEN 1 END) AS good_business_count,\n    COUNT(CASE WHEN stars < 4 THEN 1 END) AS bad_business_count,\n    COUNT(CASE WHEN stars >= 4 THEN 1 END) / COUNT(CASE WHEN stars < 4 THEN 1 END) AS good_to_bad_ratio\nFROM business\nWHERE hours LIKE '%24 hours%' OR hours LIKE '%open 24%';"
        ],
        "rule_sql": []
    },
    "7158": {
        "db_id": "works_cycles",
        "question": "To the products which could make the profit as 21.9037, what were their list price after October of 2012?",
        "ground_truth": "SELECT T1.ListPrice FROM Product AS T1 INNER JOIN ProductListPriceHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ListPrice - T1.StandardCost > 21.9037 AND STRFTIME('%Y-%m-%d', T2.StartDate) >= '2012-10-01'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT list_price FROM products WHERE profit = 21.9037 AND date > '2012-10-01';"
        ],
        "rule_sql": []
    },
    "7294": {
        "db_id": "works_cycles",
        "question": "Among the vendors that sell the product Hex Nut 5, how many of them have a good credit rating?",
        "ground_truth": "SELECT COUNT(DISTINCT T3.Name) FROM ProductVendor AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Vendor AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID WHERE T2.Name = 'Hex Nut 5' AND T3.CreditRating = 1 AND 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM vendors v JOIN products p ON v.vendor_id = p.vendor_id WHERE p.product_name = 'Hex Nut 5' AND v.credit_rating = 'good';"
        ],
        "rule_sql": []
    },
    "5227": {
        "db_id": "address",
        "question": "Provide the congress representatives' IDs of the postal points in East Springfield.",
        "ground_truth": "SELECT T2.district FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code WHERE T1.city = 'East Springfield'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT representative_id FROM postal_points WHERE city = 'East Springfield';"
        ],
        "rule_sql": []
    },
    "4077": {
        "db_id": "public_review_platform",
        "question": "List down the business ID and attribute value of the attribute name of \"payment_types_visa\".",
        "ground_truth": "SELECT T2.business_id, T2.attribute_value FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T1.attribute_name = 'payment_types_visa'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id, attribute_name FROM business_attributes WHERE attribute_value = 'payment_types_visa'"
        ],
        "rule_sql": []
    },
    "8767": {
        "db_id": "chicago_crime",
        "question": "Among the incidents in January, 2018, how many of them were stated \"against Property\" in the FBI classification?",
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T2.date, 5, 4) = '2018' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE T1.crime_against = 'Property' AND SUBSTR(T2.date, 1, 1) = '1'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM incidents WHERE month = 'January' AND year = 2018 AND fbi_classification = 'against Property';"
        ],
        "rule_sql": []
    },
    "5754": {
        "db_id": "language_corpus",
        "question": "How many times the word \"desena\" occurs?",
        "ground_truth": "SELECT occurrences FROM words WHERE word = 'desena'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE word = 'desena';"
        ],
        "rule_sql": []
    },
    "6508": {
        "db_id": "retail_world",
        "question": "Please calculate the number of orders from customers by country in 1996.",
        "ground_truth": "SELECT COUNT(T2.CustomerID) FROM Customers AS T1 INNER JOIN Orders AS T2 ON T1.CustomerID = T2.CustomerID WHERE STRFTIME('%Y', T2.OrderDate) = '1996' GROUP BY T1.Country",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country, COUNT(*) as OrderCount \nFROM Customers \nWHERE OrderDate LIKE '1996%' \nGROUP BY Country"
        ],
        "rule_sql": []
    },
    "9002": {
        "db_id": "bike_share_1",
        "question": "Among all the trips, which day had the most bikes borrowed? What was the average coldest temperature on that day?",
        "ground_truth": "SELECT T2.date, AVG(T2.min_temperature_f) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code GROUP BY T2.date ORDER BY COUNT(T1.start_date) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    t.start_date,\n    COUNT(*) as bike_count,\n    AVG(w.min_temp) as avg_coldest_temp\nFROM trips t\nJOIN weather w ON t.start_date = w.date\nGROUP BY t.start_date\nORDER BY bike_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5198": {
        "db_id": "address",
        "question": "Which state has greater than 50 CBSA officers of metro type?",
        "ground_truth": "SELECT T2.state FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_type = 'Metro' GROUP BY T2.state HAVING COUNT(T1.CBSA_type) > 50",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state, COUNT(*) as officer_count FROM cbsa_officers WHERE metro_type = 'metro' GROUP BY state HAVING officer_count > 50;"
        ],
        "rule_sql": []
    },
    "547": {
        "db_id": "movies_4",
        "question": "Provide the names and departments of the person who worked as a music editor in the \"Pirates of the Caribbean: At World's End\" movie.",
        "ground_truth": "SELECT T3.person_name, T4.department_name FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id INNER JOIN department AS T4 ON T2.department_id = T4.department_id WHERE T1.title LIKE 'Pirates of the Caribbean: At World%s End' AND T2.job = 'Music Editor'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, department FROM people WHERE job = 'music editor' AND movie_title = 'Pirates of the Caribbean: At World\\'s End'"
        ],
        "rule_sql": []
    },
    "9419": {
        "db_id": "movie_3",
        "question": "Which country does Mary Smith live in?",
        "ground_truth": "SELECT T3.country FROM address AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id INNER JOIN country AS T3 ON T2.country_id = T3.country_id INNER JOIN customer AS T4 ON T1.address_id = T4.address_id WHERE T4.first_name = 'MARY' AND T4.last_name = 'SMITH'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM users WHERE first_name = 'Mary' AND last_name = 'Smith';"
        ],
        "rule_sql": []
    },
    "7069": {
        "db_id": "works_cycles",
        "question": "What is the first name of the male employee who has a western name style?",
        "ground_truth": "SELECT T2.FirstName FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.NameStyle = 0 AND T1.Gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE gender = 'male' AND name_style = 'western' ORDER BY employee_id LIMIT 1;"
        ],
        "rule_sql": []
    },
    "542": {
        "db_id": "movies_4",
        "question": "What is the original language of the \"Four Rooms\" movie?",
        "ground_truth": "SELECT T3.language_name FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id INNER JOIN language_role AS T4 ON T2.language_role_id = T4.role_id WHERE T4.language_role = 'Original' AND T1.title = 'Four Rooms'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM movies WHERE title = 'Four Rooms';"
        ],
        "rule_sql": []
    },
    "797": {
        "db_id": "social_media",
        "question": "State the number of states in the United Kingdom.",
        "ground_truth": "SELECT COUNT(State) AS State_number FROM location WHERE Country = 'United Kingdom'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE name = 'United Kingdom';"
        ],
        "rule_sql": []
    },
    "5891": {
        "db_id": "airline",
        "question": "Provide the date and tail number of flight with air carrier \"Ross Aviation Inc.: GWE\".",
        "ground_truth": "SELECT T1.FL_DATE, T1.TAIL_NUM FROM Airlines AS T1 INNER JOIN `Air Carriers` AS T2 ON T1.OP_CARRIER_AIRLINE_ID = T2.Code WHERE T2.Description = 'Ross Aviation Inc.: GWE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date, tail_number FROM flights WHERE air_carrier = 'Ross Aviation Inc.'"
        ],
        "rule_sql": []
    },
    "8842": {
        "db_id": "food_inspection",
        "question": "Give the business ID and risk category of the business owned by San Francisco Madeleine, Inc.",
        "ground_truth": "SELECT DISTINCT T2.business_id, T1.risk_category FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.owner_name = 'San Francisco Madeleine, Inc.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id, risk_category FROM businesses WHERE owner_name = 'San Francisco Madeleine, Inc.'"
        ],
        "rule_sql": []
    },
    "7705": {
        "db_id": "hockey",
        "question": "Which league did player id\"adamsja01\" play in 1920?",
        "ground_truth": "SELECT lgID FROM ScoringSC WHERE playerID = 'adamsja01' AND year = 1920",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT league FROM players WHERE player_id = 'adamsja01' AND year = 1920;"
        ],
        "rule_sql": []
    },
    "8662": {
        "db_id": "chicago_crime",
        "question": "How many of the crimes that happened in the street have FBI title \"Homicide 1st & 2nd Degree\"?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.location_description = 'STREET' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no WHERE T1.title = 'Homicide 1st & 2nd Degree'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE location = 'street' AND fbi_title = 'Homicide 1st & 2nd Degree';"
        ],
        "rule_sql": []
    },
    "3660": {
        "db_id": "authors",
        "question": "State the name and affiliation of author for the 'Education, democracy and growth' paper?",
        "ground_truth": "SELECT T2.Name, T2.Affiliation FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Education, democracy and growth'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, affiliation FROM authors WHERE paper_title = 'Education, democracy and growth';"
        ],
        "rule_sql": []
    },
    "4637": {
        "db_id": "disney",
        "question": "Give the name of the movie which the song \"I Thought I Lost You\" is associated with.",
        "ground_truth": "SELECT movie_title FROM characters WHERE song = 'I Thought I Lost You'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE song_name = 'I Thought I Lost You';"
        ],
        "rule_sql": []
    },
    "8410": {
        "db_id": "mondial_geo",
        "question": "What percent of the non volcanic islands in the Lesser Antilles group of islands have an area of no more than 300 square kilometers?",
        "ground_truth": "SELECT SUM(CASE WHEN Area <= 300 THEN 1 ELSE 0 END) * 100 / COUNT(*) FROM island WHERE Islands = 'Lesser Antilles' AND (Type != 'volcanic' OR Type IS NULL)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN area <= 300 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM islands\nWHERE group_name = 'Lesser Antilles' \nAND is_volcanic = 0\nAND area <= 300;"
        ],
        "rule_sql": []
    },
    "1717": {
        "db_id": "restaurant",
        "question": "Which county and region does the street E. El Camino Real belong to?",
        "ground_truth": "SELECT DISTINCT T2.county, T2.region FROM location AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.street_name = 'E. El Camino Real'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county, region FROM streets WHERE street_name = 'E. El Camino Real';"
        ],
        "rule_sql": []
    },
    "7151": {
        "db_id": "works_cycles",
        "question": "Name cellphone number's Type ID?",
        "ground_truth": "SELECT PhoneNumberTypeID FROM PhoneNumberType WHERE Name = 'Cell'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Type_ID FROM cellphone WHERE number = 'cellphone number';"
        ],
        "rule_sql": []
    },
    "2130": {
        "db_id": "world_development_indicators",
        "question": "Please calculate the average of Arms imports (SIPRI trend indicator values) of the European & Central Asian countries.",
        "ground_truth": "SELECT CAST(SUM(T2.Value) AS REAL) / COUNT(T1.CountryCode) FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T1.Region = 'Europe & Central Asia' AND T2.IndicatorName = 'Arms imports (SIPRI trend indicator values)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(arms_imports) FROM countries WHERE region = 'Europe' OR region = 'Central Asia';"
        ],
        "rule_sql": []
    },
    "5768": {
        "db_id": "language_corpus",
        "question": "How many word appeared 8 times? State the language id of the page.",
        "ground_truth": "SELECT COUNT(T2.wid), T1.lid FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T2.occurrences = 8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language_id, COUNT(*) as word_count FROM words WHERE word_count = 8 GROUP BY language_id;"
        ],
        "rule_sql": []
    },
    "8463": {
        "db_id": "mondial_geo",
        "question": "For each organisations with headquarters in the USA, provide the its full name and the city where the headquarter is located at.",
        "ground_truth": "SELECT Name, City FROM organization WHERE Country = 'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, headquarters_city FROM organisations WHERE headquarters_country = 'USA';"
        ],
        "rule_sql": []
    },
    "1353": {
        "db_id": "law_episode",
        "question": "Where is the place of birth of the actor with the number nm0007064 who has not been credited for playing the role of a \"Narrator\"?",
        "ground_truth": "SELECT DISTINCT T1.birth_place FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.person_id = T2.person_id WHERE T1.person_id = 'nm0007064' AND T2.role = 'Narrator' AND T2.credited = 'false'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_place FROM actors WHERE actor_id = 'nm0007064' AND role != 'Narrator';"
        ],
        "rule_sql": []
    },
    "7964": {
        "db_id": "music_platform_2",
        "question": "What is the least common category?",
        "ground_truth": "SELECT category FROM categories GROUP BY category ORDER BY COUNT(podcast_id) ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(*) as count FROM products GROUP BY category ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3630": {
        "db_id": "authors",
        "question": "Gives the home page of the conference where the paper \"Increasing the Concurrency in Estelle\" is presented.",
        "ground_truth": "SELECT DISTINCT T2.HomePage FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T1.Title = 'Increasing the Concurrency in Estelle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT conference.home_page FROM conference JOIN paper ON conference.conference_id = paper.conference_id WHERE paper.title = 'Increasing the Concurrency in Estelle';"
        ],
        "rule_sql": []
    },
    "7728": {
        "db_id": "hockey",
        "question": "Which team recorded the most number of road victories in 2005? Indicate the team ID.",
        "ground_truth": "SELECT tmID FROM TeamSplits WHERE YEAR = '2005' ORDER BY rW DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_id, COUNT(*) as road_wins \nFROM games \nWHERE year = 2005 AND home_team_score < away_team_score \nGROUP BY team_id \nORDER BY road_wins DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9245": {
        "db_id": "movie_3",
        "question": "What percentage of the movies are PG-13?",
        "ground_truth": "SELECT CAST(SUM(IIF(rating = 'PG-13', 1, 0)) AS REAL) * 100 / COUNT(film_id) FROM film",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM movies) AS percentage FROM movies WHERE rating = 'PG-13';"
        ],
        "rule_sql": []
    },
    "2705": {
        "db_id": "regional_sales",
        "question": "Which Apollo Ltd customer's order number has the most expensive unit price, indicating the order date?",
        "ground_truth": "SELECT T1.OrderNumber, T1.OrderDate FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID WHERE T2.`Customer Names` = 'Apollo Ltd' ORDER BY T1.`Unit Price` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name, order_number, MAX(unit_price), order_date \nFROM customers \nJOIN orders ON customers.customer_id = orders.customer_id \nJOIN order_items ON orders.order_id = order_items.order_id \nWHERE company = 'Apollo Ltd' \nGROUP BY customer_name, order_number, order_date \nORDER BY MAX(unit_price) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1858": {
        "db_id": "soccer_2016",
        "question": "How many players got out in the first inning of match ID \"548335\"?",
        "ground_truth": "SELECT SUM(CASE WHEN Match_Id = 548335 THEN 1 ELSE 0 END) FROM Wicket_Taken WHERE Innings_No = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM player_out WHERE match_id = '548335' AND inning = 1;"
        ],
        "rule_sql": []
    },
    "6220": {
        "db_id": "food_inspection_2",
        "question": "What is the facility type of the establishment named \"Kinetic Playground\"?",
        "ground_truth": "SELECT facility_type FROM establishment WHERE dba_name = 'Kinetic Playground'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT facility_name FROM establishments WHERE establishment_name = 'Kinetic Playground';"
        ],
        "rule_sql": []
    },
    "4206": {
        "db_id": "simpson_episodes",
        "question": "What character did Dan Castellaneta play that won him an award for Outstanding Voice-Over Performance in 2009 in the Primetime Emmy Awards?",
        "ground_truth": "SELECT DISTINCT T2.character FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T1.person = 'Dan Castellaneta' AND T1.award = 'Outstanding Voice-Over Performance' AND T1.organization = 'Primetime Emmy Awards' AND T1.year = 2009;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM emmy_awards WHERE actor = 'Dan Castellaneta' AND award_year = 2009 AND award_category = 'Outstanding Voice-Over Performance'"
        ],
        "rule_sql": []
    },
    "2870": {
        "db_id": "professional_basketball",
        "question": "Among the coaches who won the 'ABA Coach of the Year' award, which is the coach with the highest number of won games?",
        "ground_truth": "SELECT T1.coachID FROM coaches AS T1 INNER JOIN awards_coaches AS T2 ON T1.coachID = T2.coachID WHERE T2.award = 'ABA Coach of the Year' GROUP BY T1.coachID, T1.won ORDER BY T1.won DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_name, MAX(games_won) \nFROM coaches \nWHERE award = 'ABA Coach of the Year' \nGROUP BY coach_name \nORDER BY games_won DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3489": {
        "db_id": "video_games",
        "question": "What is the total number of adventure games released in 2005?",
        "ground_truth": "SELECT COUNT(DISTINCT T3.id) FROM game_platform AS T1 INNER JOIN game_publisher AS T2 ON T1.game_publisher_id = T2.id INNER JOIN game AS T3 ON T2.game_id = T3.id INNER JOIN genre AS T4 ON T3.genre_id = T4.id WHERE T4.genre_name = 'Adventure' AND T1.release_year = 2005",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE genre = 'Adventure' AND release_year = 2005;"
        ],
        "rule_sql": []
    },
    "7203": {
        "db_id": "works_cycles",
        "question": "Provide the business entity ID who did not achieved projected yearly sales quota in 2013.",
        "ground_truth": "SELECT DISTINCT T1.BusinessEntityID FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T2.QuotaDate) = '2013' AND T1.SalesQuota < T1.SalesLastYear",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT BusinessEntityID \nFROM SalesPerson \nWHERE YEAR(QuotaDate) = 2013 \nAND SalesYTD >= SalesQuota"
        ],
        "rule_sql": []
    },
    "5639": {
        "db_id": "shipping",
        "question": "What is the average annual revenue of customers who have shipment weight of less than 65000 pounds?",
        "ground_truth": "SELECT AVG(T1.annual_revenue) FROM customer AS T1 INNER JOIN shipment AS T2 ON T1.cust_id = T2.cust_id WHERE T2.weight < 65000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(annual_revenue) FROM customers WHERE shipment_weight < 65000;"
        ],
        "rule_sql": []
    },
    "2107": {
        "db_id": "world_development_indicators",
        "question": "In which country's latest trade data and latest water withdrawal data were both updated in the year 2013? Give its long name and Alpha 2 code.",
        "ground_truth": "SELECT LongName, Alpha2Code FROM Country WHERE LatestTradeData = 2013 AND LatestWaterWithdrawalData = 2013",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.long_name, c.alpha_2_code \nFROM countries c\nJOIN trade_data td ON c.country_id = td.country_id\nJOIN water_withdrawal ww ON c.country_id = ww.country_id\nWHERE td.year = 2013 AND ww.year = 2013\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6892": {
        "db_id": "retails",
        "question": "What is the average supply cost for the part \"hot spring dodger dim light\"?",
        "ground_truth": "SELECT AVG(T1.ps_supplycost) FROM partsupp AS T1 INNER JOIN supplier AS T2 ON T1.ps_suppkey = T2.s_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey WHERE T3.p_name = 'hot spring dodger dim light'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(ps_supplycost) FROM partsupp WHERE p_name = 'hot spring dodger dim light'"
        ],
        "rule_sql": []
    },
    "8563": {
        "db_id": "software_company",
        "question": "What is the marital status of the customer ages 62 with an level of education of 7?",
        "ground_truth": "SELECT DISTINCT MARITAL_STATUS FROM Customers WHERE EDUCATIONNUM = 7 AND age = 62",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT marital_status FROM customers WHERE age = 62 AND education_level = '7';"
        ],
        "rule_sql": []
    },
    "2256": {
        "db_id": "movielens",
        "question": "Among the best actors, how many of them got a rating of 5 to the movies they starred?",
        "ground_truth": "SELECT COUNT(T1.actorid) FROM actors AS T1 INNER JOIN movies2actors AS T2 ON T1.actorid = T2.actorid INNER JOIN u2base AS T3 ON T2.movieid = T3.movieid WHERE T1.a_quality = 5 AND T3.rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM actors a\nJOIN movies m ON a.movie_id = m.movie_id\nWHERE a.best_actor = 1 AND m.rating >= 5;"
        ],
        "rule_sql": []
    },
    "1439": {
        "db_id": "synthea",
        "question": "How many of the male patients are allergic to house dust mites?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'House dust mite allergy' AND T1.gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND allergy = 'house dust mites';"
        ],
        "rule_sql": []
    },
    "2786": {
        "db_id": "european_football_1",
        "question": "Which team has the most victories as the home team in matches of the Bundesliga division?",
        "ground_truth": "SELECT T1.HomeTeam FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'Bundesliga' AND T1.FTR = 'H' GROUP BY T1.HomeTeam ORDER BY COUNT(T1.FTR) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT home_team, COUNT(*) as victories \nFROM matches \nWHERE division = 'Bundesliga' AND home_team_score > away_team_score \nGROUP BY home_team \nORDER BY victories DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2591": {
        "db_id": "regional_sales",
        "question": "List down the product IDs and names that include the word \"Outdoor\".",
        "ground_truth": "SELECT ProductID, T FROM ( SELECT ProductID , CASE  WHEN `Product Name` LIKE '%Outdoor%' THEN `Product Name` ELSE NULL END AS T FROM Products ) WHERE T IS NOT NULL ORDER BY T DESC",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id, product_name FROM products WHERE product_name LIKE '%Outdoor%';"
        ],
        "rule_sql": []
    },
    "9305": {
        "db_id": "movie_3",
        "question": "What is the most common first name among the customers?",
        "ground_truth": "SELECT first_name FROM customer GROUP BY first_name ORDER BY COUNT(first_name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, COUNT(*) as count FROM customers GROUP BY first_name ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5486": {
        "db_id": "menu",
        "question": "What is the average page number of the menus that have the dish \"Clear green turtle\"?",
        "ground_truth": "SELECT AVG(T1.page_number) FROM MenuPage AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.menu_page_id INNER JOIN Dish AS T3 ON T2.dish_id = T3.id WHERE T3.name = 'Clear green turtle'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(page_number) FROM menus WHERE dish_name = 'Clear green turtle';"
        ],
        "rule_sql": []
    },
    "1623": {
        "db_id": "car_retails",
        "question": "To whom does Steve Patterson report? Please give his or her full name.",
        "ground_truth": "SELECT t2.firstName, t2.lastName FROM employees AS t1 INNER JOIN employees AS t2 ON t2.employeeNumber = t1.reportsTo WHERE t1.firstName = 'Steve' AND t1.lastName = 'Patterson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manager_name FROM employees WHERE employee_name = 'Steve Patterson';"
        ],
        "rule_sql": []
    },
    "2012": {
        "db_id": "soccer_2016",
        "question": "What are the names of players who participated in season year 2008?",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Match AS T2 ON T1.Player_Id = T2.Man_of_the_Match INNER JOIN Player_Match AS T3 ON T3.Player_Id = T1.Player_Id INNER JOIN Season AS T4 ON T2.Season_Id = T4.Season_Id WHERE T4.Season_Year = 2008 GROUP BY T1.Player_Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE season_year = 2008;"
        ],
        "rule_sql": []
    },
    "2552": {
        "db_id": "app_store",
        "question": "What is the average price for a dating application?",
        "ground_truth": "SELECT AVG(Price) FROM playstore WHERE Genres = 'Dating'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM applications WHERE category = 'dating';"
        ],
        "rule_sql": []
    },
    "6434": {
        "db_id": "retail_world",
        "question": "Who is the person to contact to get Camembert Pierrot?",
        "ground_truth": "SELECT T2.ContactName FROM Products AS T1 INNER JOIN Suppliers AS T2 ON T1.SupplierID = T2.SupplierID WHERE T1.ProductName = 'Camembert Pierrot'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT contact_person FROM products WHERE product_name = 'Camembert Pierrot';"
        ],
        "rule_sql": []
    },
    "2192": {
        "db_id": "world_development_indicators",
        "question": "What upper middle income country under East Asia & Pacific region which covers the topic about Social Protection & Labor: Migration\n? Indicate the short name of the said country.",
        "ground_truth": "SELECT DISTINCT T1.ShortName FROM Country AS T1 INNER JOIN footnotes AS T2 ON T1.CountryCode = T2.CountryCode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE T1.IncomeGroup = 'Upper middle income' AND T1.Region = 'East Asia & Pacific' AND T3.Topic = 'Social Protection & Labor: Migration'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT short_name FROM countries WHERE income_group = 'Upper middle income' AND region = 'East Asia & Pacific' AND topic = 'Social Protection & Labor: Migration';"
        ],
        "rule_sql": []
    },
    "3976": {
        "db_id": "public_review_platform",
        "question": "Among the review votes of funny and cool hit uber with long review length, describe the business ID, active status, user ID and user year of joining Yelp.",
        "ground_truth": "SELECT T1.business_id, T1.active, T3.user_id, T3.user_yelping_since_year FROM Business AS T1 INNER JOIN Reviews AS T2 ON T1.business_id = T2.business_id INNER JOIN Users AS T3 ON T2.user_id = T3.user_id WHERE T2.review_votes_cool = 'Uber' AND T2.review_votes_funny = 'Uber' AND T2.review_length = 'Long'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id, active, user_id, yelping_since \nFROM reviews \nWHERE funny = 'hit' AND cool = 'hit' AND review_length > 1000 \nORDER BY business_id;"
        ],
        "rule_sql": []
    },
    "8613": {
        "db_id": "chicago_crime",
        "question": "Give the name of the community area which had the most pocket-picking thefts.",
        "ground_truth": "SELECT T3.community_area_name FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no INNER JOIN Community_Area AS T3 ON T2.community_area_no = T3.community_area_no WHERE T1.primary_description = 'THEFT' AND T1.secondary_description = 'POCKET-PICKING' GROUP BY T2.community_area_no ORDER BY T2.case_number DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT community_area_name FROM crime_data ORDER BY pocket_picking_thefts DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2172": {
        "db_id": "world_development_indicators",
        "question": "List the long name of countries with indicator name in 1980.",
        "ground_truth": "SELECT DISTINCT T1.LongName FROM Country AS T1 INNER JOIN Indicators AS T2 ON T1.CountryCode = T2.CountryCode WHERE T2.Year = 1980 AND T2.IndicatorName IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE indicator_name = '1980';"
        ],
        "rule_sql": []
    },
    "8589": {
        "db_id": "chicago_crime",
        "question": "Who is the person responsible for the crime cases in Central Chicago?",
        "ground_truth": "SELECT commander FROM District WHERE district_name = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM crimes WHERE location = 'Central Chicago' ORDER BY crime_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2954": {
        "db_id": "shakespeare",
        "question": "How many scenes are there in Act 1 in Twelfth Night?",
        "ground_truth": "SELECT COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Act = 1 AND T1.Title = 'Twelfth Night'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM scenes WHERE act = 'Act 1' AND play_title = 'Twelfth Night';"
        ],
        "rule_sql": []
    },
    "7872": {
        "db_id": "world",
        "question": "Calculate the percentage of the surface area of all countries that uses Chinese as one of their languages.",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Language = 'Chinese', T1.SurfaceArea, 0)) AS REAL) * 100 / SUM(T1.SurfaceArea) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(country.SurfaceArea) / (SELECT SUM(SurfaceArea) FROM country)) * 100 AS percentage\nFROM \n    country\nJOIN \n    countrylanguage ON country.Code = countrylanguage.CountryCode\nWHERE \n    countrylanguage.Language = 'Chinese'"
        ],
        "rule_sql": []
    },
    "6987": {
        "db_id": "ice_hockey_draft",
        "question": "List the name of players who have a height over 5'9.",
        "ground_truth": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch > '5''9\"'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE height > 5.9"
        ],
        "rule_sql": []
    },
    "9166": {
        "db_id": "movie_3",
        "question": "Give the number of documentary films.",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film_category AS T1 INNER JOIN category AS T2 ON T1.category_id = T2.category_id WHERE T2.name = 'Documentary'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE genre = 'Documentary';"
        ],
        "rule_sql": []
    },
    "4769": {
        "db_id": "legislator",
        "question": "List the full name of all past legislators that chose Pro-Administration as their political party in year 1791.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T2.party = 'Pro-Administration' AND CAST(T2.start AS DATE) <= 1791 AND CAST(T2.END AS DATE) >= 1791",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM legislators WHERE party = 'Pro-Administration' AND year = 1791;"
        ],
        "rule_sql": []
    },
    "2835": {
        "db_id": "professional_basketball",
        "question": "Which teams have winning rate less than 50%?",
        "ground_truth": "SELECT name FROM teams WHERE CAST(won AS REAL) * 100 / (won + lost) < 50",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, (wins / (wins + losses)) * 100 AS win_rate FROM teams WHERE win_rate < 50;"
        ],
        "rule_sql": []
    },
    "7851": {
        "db_id": "world",
        "question": "Among the countries that have GNP greater than 1500, what is the percentage of the countries have English as its language?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Language = 'English', 1, 0)) AS REAL) * 100 / COUNT(T1.Code) FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.GNP > 1500",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN Language = 'English' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Country c\nJOIN \n    CountryLanguage cl ON c.Code = cl.CountryCode\nWHERE \n    c.GNP > 1500\nGROUP BY \n    c.Code"
        ],
        "rule_sql": []
    },
    "4985": {
        "db_id": "olympics",
        "question": "What is the average height of male athletes playing basketball sport?",
        "ground_truth": "SELECT AVG(T5.height) FROM sport AS T1 INNER JOIN event AS T2 ON T1.id = T2.sport_id INNER JOIN competitor_event AS T3 ON T2.id = T3.event_id INNER JOIN games_competitor AS T4 ON T3.competitor_id = T4.id INNER JOIN person AS T5 ON T4.person_id = T5.id WHERE T1.sport_name = 'Basketball' AND T5.gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(height) FROM athletes WHERE gender = 'female' AND sport = 'basketball';"
        ],
        "rule_sql": []
    },
    "1509": {
        "db_id": "synthea",
        "question": "List out the start date of the care plan of alive patients.",
        "ground_truth": "SELECT DISTINCT T1.START FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.deathdate IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date FROM care_plans WHERE patient_status = 'alive';"
        ],
        "rule_sql": []
    },
    "5133": {
        "db_id": "address",
        "question": "How many states are in the central time zone? Write their full names.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.time_zone = 'Central' THEN 1 ELSE 0 END) AS count FROM zip_data AS T1 INNER JOIN state AS T2 ON T2.abbreviation = T1.state WHERE T1.time_zone = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM states WHERE timezone = 'Central';"
        ],
        "rule_sql": []
    },
    "638": {
        "db_id": "codebase_comments",
        "question": "List all the solutions ids of the repository with \"636430969128176000\" processed time",
        "ground_truth": "SELECT T2.Id FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.ProcessedTime = 636430969128176000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT solution_id FROM repositories WHERE processed_time = '636430969128176000'"
        ],
        "rule_sql": []
    },
    "1447": {
        "db_id": "synthea",
        "question": "How many of the patients who underwent a 'bone immobilization' procedure have a driver's license?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN procedures AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Bone immobilization' AND T1.drivers IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN procedures pr ON p.patient_id = pr.patient_id\nWHERE pr.procedure_name = 'bone immobilization'\nAND p.has_drivers_license = 'yes';"
        ],
        "rule_sql": []
    },
    "3225": {
        "db_id": "donor",
        "question": "Among the projects whose donators are teachers, what is the percentage of projects that affected more than 30 students?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.students_reached > 30 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.projectid) FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.is_teacher_acct = 't'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN students_affected > 30 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM projects\nWHERE donator_type = 'teacher';"
        ],
        "rule_sql": []
    },
    "714": {
        "db_id": "trains",
        "question": "How many wheels do the long cars have?",
        "ground_truth": "SELECT SUM(wheels) FROM cars WHERE len = 'long'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE car_type = 'long' AND wheels = 4;"
        ],
        "rule_sql": []
    },
    "6042": {
        "db_id": "books",
        "question": "How many books have been published in Japanese?",
        "ground_truth": "SELECT COUNT(*) FROM book_language AS T1 INNER JOIN book AS T2 ON T1.language_id = T2.language_id WHERE T1.language_name = 'Japanese'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE language = 'Japanese';"
        ],
        "rule_sql": []
    },
    "4327": {
        "db_id": "simpson_episodes",
        "question": "Calculate the total rating of winners in OFTA Television Award and WGA Award (TV).",
        "ground_truth": "SELECT SUM(T2.rating) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.award_category IN ('Jupiter Award ', 'WGA Award (TV)');",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(rating) FROM awards WHERE award_name = 'OFTA Television Award' OR award_name = 'WGA Award (TV)' AND winner = 1;"
        ],
        "rule_sql": []
    },
    "4846": {
        "db_id": "legislator",
        "question": "Does Thomas Carnes have an account on ballotpedia.org?",
        "ground_truth": "SELECT CASE WHEN ballotpedia_id IS NULL THEN 'doesn''t have' ELSE 'have' END AS HaveorNot FROM historical WHERE first_name = 'Thomas' AND last_name = 'Carnes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM users WHERE first_name = 'Thomas' AND last_name = 'Carnes' AND website = 'ballotpedia.org';"
        ],
        "rule_sql": []
    },
    "324": {
        "db_id": "retail_complains",
        "question": "What is the percentage of male clients complaining about their credit cards?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.sex = 'Male' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.sex) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.Product = 'Credit card'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN gender = 'male' AND complaint_type = 'credit card' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_male_credit_card_complaints\nFROM clients\nWHERE complaint_type IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "8929": {
        "db_id": "cookbook",
        "question": "Calculate the percentage of recipes with no cholesterol included and have a cooking time less than 20 minutes among all recipes.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.cook_min < 20 AND T2.cholestrl = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM recipes)) AS percentage\nFROM recipes \nWHERE cholesterol = 0 AND cooking_time < 20;"
        ],
        "rule_sql": []
    },
    "1629": {
        "db_id": "car_retails",
        "question": "Please list the phone numbers of the top 3 customers that have the highest credit limit and have Leslie Jennings as their sales representitive.",
        "ground_truth": "SELECT t1.phone FROM customers AS t1 INNER JOIN employees AS t2 ON t1.salesRepEmployeeNumber = t2.employeeNumber WHERE t2.firstName = 'Leslie' AND t2.lastName = 'Jennings' ORDER BY t1.creditLimit DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers WHERE sales_rep = 'Leslie Jennings' ORDER BY credit_limit DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "295": {
        "db_id": "retail_complains",
        "question": "How many Credit Card complaints did Sharon handle?",
        "ground_truth": "SELECT COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.Product = 'Credit card' AND T1.server = 'SHARON'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE handler_name = 'Sharon' AND complaint_type = 'Credit Card';"
        ],
        "rule_sql": []
    },
    "8922": {
        "db_id": "cookbook",
        "question": "How many dairy recipes can serve more than 10 people?",
        "ground_truth": "SELECT COUNT(*) FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T3.category = 'dairy' AND T1.servings > 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM recipes WHERE category = 'dairy' AND servings <= 10;"
        ],
        "rule_sql": []
    },
    "634": {
        "db_id": "codebase_comments",
        "question": "What are the paths of solutions in repository \"https://github.com/ecoffey/Bebop.git\"",
        "ground_truth": "SELECT DISTINCT T2.Path FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Url = 'https://github.com/ecoffey/Bebop.git'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT path FROM solutions WHERE repository = 'https://github.com/ecoffey/Bebop.git';"
        ],
        "rule_sql": []
    },
    "8012": {
        "db_id": "university",
        "question": "List the university ID of the university that scored 100 in 2011.",
        "ground_truth": "SELECT university_id FROM university_ranking_year WHERE score = 100 AND year = 2011",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_id FROM universities WHERE score = 100 AND year = 2011;"
        ],
        "rule_sql": []
    },
    "2887": {
        "db_id": "professional_basketball",
        "question": "List the first name, last name, height and weight of the players who has all free throw attempted successfully made.",
        "ground_truth": "SELECT DISTINCT T1.firstName, T1.lastName, T1.height, T1.weight FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T2.ft_attempted > 0 AND ft_attempted = ft_made",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, height, weight \nFROM players \nWHERE free_throw_attempted = free_throw_made"
        ],
        "rule_sql": []
    },
    "4904": {
        "db_id": "legislator",
        "question": "What is the total number of senators New Jersey have?",
        "ground_truth": "SELECT COUNT(type) FROM `historical-terms` WHERE state = 'NJ' AND type = 'rep'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM senators WHERE state = 'New York';"
        ],
        "rule_sql": []
    },
    "5650": {
        "db_id": "shipping",
        "question": "Who is the driver that transported the lightest weight of shipment? Provide the full name of the driver.",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id ORDER BY T1.weight ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM drivers ORDER BY shipment_weight ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7543": {
        "db_id": "image_and_language",
        "question": "State the explanation about object class 10.",
        "ground_truth": "SELECT OBJ_CLASS FROM OBJ_CLASSES WHERE OBJ_CLASS_ID = 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM objects WHERE class = 10;"
        ],
        "rule_sql": []
    },
    "2134": {
        "db_id": "world_development_indicators",
        "question": "How many annual indicators use the Sum aggregation method from 2001 to 2003?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.SeriesCode)  FROM Footnotes AS T1 INNER JOIN Series AS T2 ON T1.Seriescode = T2.SeriesCode WHERE T1.Year IN ('YR2001', 'YR2002', 'YR2003') AND T2.Periodicity = 'Annual' AND T2.AggregationMethod = 'Sum'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM indicators \nWHERE aggregation_method = 'Sum' \nAND year BETWEEN 2001 AND 2003 \nAND indicator_type = 'monthly';"
        ],
        "rule_sql": []
    },
    "7103": {
        "db_id": "works_cycles",
        "question": "Calculate the average of the total ordered quantity of products purchased whose shipping method was Cargo Transport 5.",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.ShipMethodID = 5, T3.OrderQty, 0)) AS REAL) / COUNT(T3.ProductID) FROM ShipMethod AS T1 INNER JOIN PurchaseOrderHeader AS T2 ON T1.ShipMethodID = T2.ShipMethodID INNER JOIN PurchaseOrderDetail AS T3 ON T2.PurchaseOrderID = T3.PurchaseOrderID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(quantity) FROM orders WHERE shipping_method = 'Cargo Transport 5';"
        ],
        "rule_sql": []
    },
    "5492": {
        "db_id": "menu",
        "question": "How many menus were created for steamship?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE venue = 'STEAMSHIP'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menus WHERE restaurant_name = 'steamship';"
        ],
        "rule_sql": []
    },
    "2935": {
        "db_id": "professional_basketball",
        "question": "Which non-playoffs team had the most points in the regular season in the year 1998?",
        "ground_truth": "SELECT T2.tmID FROM players_teams AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.year = 1998 AND T1.PostGP = 0 ORDER BY T1.points DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, points FROM teams WHERE year = 1998 AND playoffs = 0 ORDER BY points DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7528": {
        "db_id": "image_and_language",
        "question": "How many objects can you spot in image no. 72? What objects may be identified on the same image and within the bounding box represented as (341, 27, 42, 51)?",
        "ground_truth": "SELECT SUM(IIF(T1.IMG_ID = 1, 1, 0)), SUM(IIF(T1.X = 341 AND T1.Y = 27 AND T1.W = 42 AND T1.H = 51, 1, 0)) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM objects WHERE image_id = 72 AND x = 341 AND y = 27 AND width = 42 AND height = 51;"
        ],
        "rule_sql": []
    },
    "1163": {
        "db_id": "talkingdata",
        "question": "What is the ratio of active and inactive app users of the event ID \"58\"?",
        "ground_truth": "SELECT SUM(IIF(is_active = 1, 1, 0)) / SUM(IIF(is_active = 0, 1, 0)) AS per FROM app_events WHERE event_id = 58",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN status = 'active' THEN 1 END) AS active_users,\n    COUNT(CASE WHEN status = 'inactive' THEN 1 END) AS inactive_users,\n    COUNT(CASE WHEN status = 'active' THEN 1 END) / COUNT(CASE WHEN status = 'inactive' THEN 1 END) AS ratio\nFROM users\nWHERE event_id = '58';"
        ],
        "rule_sql": []
    },
    "781": {
        "db_id": "social_media",
        "question": "Please list all the cities in Argentina.",
        "ground_truth": "SELECT City FROM location WHERE City IS NOT NULL AND Country = 'Argentina'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM countries WHERE name = 'Argentina';"
        ],
        "rule_sql": []
    },
    "8745": {
        "db_id": "chicago_crime",
        "question": "Provide the ward number with the highest population.",
        "ground_truth": "SELECT ward_no FROM Ward ORDER BY Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ward_number FROM population ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "58": {
        "db_id": "movie_platform",
        "question": "How many movies registered on Mubi are directed by Hong Sang-soo?",
        "ground_truth": "SELECT COUNT(movie_id) FROM movies WHERE director_name = 'Hong Sang-soo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE director = 'Hong Sang-soo';"
        ],
        "rule_sql": []
    },
    "8334": {
        "db_id": "mondial_geo",
        "question": "Please state the longest river that flows to the Mediterranean Sea.",
        "ground_truth": "SELECT Name FROM river WHERE Sea = 'Mediterranean Sea' ORDER BY Length DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM rivers WHERE sea = 'Mediterranean Sea' ORDER BY length DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9357": {
        "db_id": "movie_3",
        "question": "Who are the actors of film titled \"BIRD INDEPENDENCE\"?",
        "ground_truth": "SELECT T3.first_name, T3.last_name FROM film AS T1 INNER JOIN film_actor AS T2 ON T1.film_id = T2.film_id INNER JOIN actor AS T3 ON T2.actor_id = T3.actor_id WHERE T1.title = 'BIRD INDEPENDENCE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE film_title = 'BIRD INDEPENDENCE'"
        ],
        "rule_sql": []
    },
    "8214": {
        "db_id": "sales_in_weather",
        "question": "What is the difference between the units sold for item 1 when the sunset was the earliest and the latest?",
        "ground_truth": "SELECT ( SELECT SUM(T2.units) AS sumunit FROM weather AS T1 INNER JOIN sales_in_weather AS T2 ON T1.`date` = T2.`date` INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr WHERE T2.item_nbr = 5 AND sunset IS NOT NULL GROUP BY T1.sunset ORDER BY T1.sunset LIMIT 1 ) - ( SELECT SUM(T2.units) AS sumunit FROM weather AS T1 INNER JOIN sales_in_weather AS T2 ON T1.`date` = T2.`date` INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr WHERE T2.item_nbr = 5 AND sunset IS NOT NULL GROUP BY T1.sunset ORDER BY T1.sunset DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT units_sold FROM sales WHERE item_id = 1 ORDER BY sunset_time ASC LIMIT 1) - \n    (SELECT units_sold FROM sales WHERE item_id = 1 ORDER BY sunset_time DESC LIMIT 1) AS difference;"
        ],
        "rule_sql": []
    },
    "2555": {
        "db_id": "app_store",
        "question": "List out the top 3 genre for application with a sentiment review greater than 0.5.",
        "ground_truth": "SELECT Genres FROM playstore WHERE App IN ( SELECT App FROM user_reviews WHERE Sentiment = 'Positive' AND Sentiment_Polarity > 0.5 ORDER BY Sentiment_Polarity DESC LIMIT 3 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre, COUNT(*) as count FROM applications WHERE sentiment_review > 0.5 GROUP BY genre ORDER BY count DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "8393": {
        "db_id": "mondial_geo",
        "question": "In which country is the city of Grozny? Give the full name of the country.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN province AS T2 ON T1.Code = T2.Country INNER JOIN city AS T3 ON T3.Province = T2.Name WHERE T3.Name = 'Grozny'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM countries WHERE city = 'Grozny';"
        ],
        "rule_sql": []
    },
    "3683": {
        "db_id": "college_completion",
        "question": "State the name and website of the institutes from the state with 209 graduate cohort in 2011.",
        "ground_truth": "SELECT T1.chronname, T1.site FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE T2.year = 2011 AND T2.grad_cohort = 209",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, website FROM institutes WHERE state = '209' AND graduate_cohort = 2011;"
        ],
        "rule_sql": []
    },
    "4337": {
        "db_id": "simpson_episodes",
        "question": "Calculate the percentage of the winners who are higher than 1.75 meters.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.height_meters > 1.75 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.result = 'Winner';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM winners)) AS percentage\nFROM winners\nWHERE height > 1.75;"
        ],
        "rule_sql": []
    },
    "8180": {
        "db_id": "sales_in_weather",
        "question": "Between 1/1/2012 to 12/31/2014, which date recorded the hottest temperature in weather station 1?",
        "ground_truth": "SELECT `date` FROM weather WHERE station_nbr = 1 AND CAST(SUBSTR(`date`, 1, 4) AS int) BETWEEN 2012 AND 2014 ORDER BY tmax DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM weather WHERE station_id = 1 AND date BETWEEN '2012-01-01' AND '2014-12-31' ORDER BY temperature ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4797": {
        "db_id": "legislator",
        "question": "Among legislators who have an Instagram account, list down their full names and nicknames who have a Thomas ID of less than 1000.",
        "ground_truth": "SELECT T1.official_full_name, T1.nickname_name FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id WHERE T2.instagram IS NOT NULL AND T1.thomas_id < 1000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name, nickname FROM legislators WHERE instagram IS NOT NULL AND thomas_id < 1000;"
        ],
        "rule_sql": []
    },
    "1696": {
        "db_id": "restaurant",
        "question": "In which regions are there no pizza restaurants?",
        "ground_truth": "SELECT DISTINCT T2.region FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.food_type = 'pizza' AND T2.region != 'unknown'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name FROM regions WHERE region_id NOT IN (SELECT region_id FROM restaurants WHERE restaurant_type = 'pizza');"
        ],
        "rule_sql": []
    },
    "9038": {
        "db_id": "bike_share_1",
        "question": "Find the average ride duration during the rain of more than 0.8 inches.",
        "ground_truth": "SELECT AVG(T1.duration) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE (T2.events = 'Rain' AND T2.precipitation_inches > 0.8) OR (T2.events = 'rain' AND T2.precipitation_inches > 0.8)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(ride_duration) FROM rides WHERE rain > 0.8;"
        ],
        "rule_sql": []
    },
    "2539": {
        "db_id": "app_store",
        "question": "What are the content ratings for the apps that have \"gr8\" in their comments?",
        "ground_truth": "SELECT DISTINCT T1.`Content Rating` FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T2.Translated_Review LIKE '%gr8%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT content_rating FROM apps WHERE comments LIKE '%gr8%';"
        ],
        "rule_sql": []
    },
    "5203": {
        "db_id": "address",
        "question": "Among the types of postal points in Saint Croix, what percentage of postal points is the post office?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.type = 'Post Office' THEN T1.zip_code ELSE NULL END) AS REAL) * 100 / COUNT(T1.zip_code) FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.county = 'SAINT CROIX'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN type = 'post office' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM postal_points\nWHERE region = 'Saint Croix';"
        ],
        "rule_sql": []
    },
    "5722": {
        "db_id": "language_corpus",
        "question": "Indicate the page id of Wikipedia about Catalan language of all the pages that have a numeric value in their title.",
        "ground_truth": "SELECT pid, title FROM pages WHERE title LIKE '%0%' OR '%1%' OR '%2%' OR '%3%' OR '%4%' OR '%5%' OR '%6%' OR '%7%' OR '%8%' OR '%9%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_id FROM page WHERE title LIKE '%Catalan language%' AND title REGEXP '^[0-9]+$';"
        ],
        "rule_sql": []
    },
    "1801": {
        "db_id": "soccer_2016",
        "question": "What is the role of SC Ganguly in the match on 2008/4/18?",
        "ground_truth": "SELECT T2.Role_Id FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Rolee AS T3 ON T2.Role_Id = T3.Role_Id INNER JOIN Match AS T4 ON T2.Match_Id = T4.Match_Id WHERE T1.Player_Name = 'SC Ganguly' AND T4.Match_Date = '2008-04-18'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role FROM matches WHERE player_name = 'SC Ganguly' AND match_date = '2008/4/18';"
        ],
        "rule_sql": []
    },
    "3302": {
        "db_id": "donor",
        "question": "What is the most expensive book item? Please provide a short description of projects related to those.",
        "ground_truth": "SELECT T1.item_name, T2.short_description FROM resources AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T1.project_resource_type = 'Books' ORDER BY T1.item_unit_price DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, price, description FROM books ORDER BY price DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8511": {
        "db_id": "software_company",
        "question": "Among all the customers, how many of them are teenagers?",
        "ground_truth": "SELECT COUNT(ID) FROM Customers WHERE age >= 13 AND age <= 19",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE age < 13;"
        ],
        "rule_sql": []
    },
    "8519": {
        "db_id": "software_company",
        "question": "How many customers are from the place with the highest average income per month?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID ORDER BY T2.INCOME_K DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers \nWHERE place = (SELECT place FROM customers ORDER BY income DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "4594": {
        "db_id": "mental_health_survey",
        "question": "What is the rate of increase of users with a current mental disorder from 2019's survey to 2016's survey?",
        "ground_truth": "SELECT CAST(( SELECT COUNT(T2.UserID) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2019 AND T1.questiontext LIKE 'Do you currently have a mental health disorder?' AND T2.AnswerText = 'Yes' ) - ( SELECT COUNT(T2.UserID) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2016 AND T1.questiontext LIKE 'Do you currently have a mental health disorder?' AND T2.AnswerText = 'Yes' ) AS REAL) * 100 / ( SELECT COUNT(T2.UserID) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2016 AND T1.questiontext LIKE 'Do you currently have a mental health disorder?' AND T2.AnswerText = 'Yes' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN year = 2019 AND current_mental_disorder = 'Yes' THEN 1 END) - \n     COUNT(CASE WHEN year = 2016 AND current_mental_disorder = 'Yes' THEN 1 END)) / \n    COUNT(CASE WHEN year = 2016 AND current_mental_disorder = 'Yes' THEN 1 END) * 100 AS rate_increase\nFROM survey_data\nWHERE year IN (2016, 2019);"
        ],
        "rule_sql": []
    },
    "3198": {
        "db_id": "donor",
        "question": "Of the projects whose resources are provided by the vendor Lakeshore Learning Materials, the school of which project has the highest cost of labor fulfillment? Please give its school ID.",
        "ground_truth": "SELECT T2.schoolid FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.vendor_name = 'Lakeshore Learning Materials' ORDER BY T2.fulfillment_labor_materials DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_id FROM projects WHERE vendor = 'Lakeshore Learning Materials' ORDER BY labor_cost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "467": {
        "db_id": "movies_4",
        "question": "How many Indian movies between 1/2/1990 and 12/30/2003 have revenue of more than 75,000,000 and popularity of no less than 20?",
        "ground_truth": "SELECT COUNT(T2.movie_id) FROM movie AS T1 INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id WHERE T1.revenue > 75000000 AND T1.popularity >= 20 AND T1.release_date BETWEEN '1990-01-01' AND '2003-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM movies \nWHERE country = 'India' \nAND release_date BETWEEN '1990-02-01' AND '2003-12-30' \nAND revenue > 75000000 \nAND popularity >= 20;"
        ],
        "rule_sql": []
    },
    "6998": {
        "db_id": "ice_hockey_draft",
        "question": "Calculate the percentage of penalty minutes of Swedish players in OHL league among all players.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.nation = 'Sweden' THEN T2.PIM ELSE NULL END) AS REAL) * 100 / COUNT(*) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.LEAGUE = 'OHL'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN nationality = 'SWE' THEN penalty_minutes ELSE 0 END) / SUM(penalty_minutes)) * 100 AS percentage_swedish_penalty_minutes\nFROM players\nWHERE league = 'OHL';"
        ],
        "rule_sql": []
    },
    "2456": {
        "db_id": "superstore",
        "question": "Provide the product's name of the product with the highest sales in the South region.",
        "ground_truth": "SELECT T2.`Product Name` FROM south_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.Region = 'South' ORDER BY T1.Sales DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM sales WHERE region = 'South' ORDER BY sales_amount ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2619": {
        "db_id": "regional_sales",
        "question": "List out the discount levels applied for all orders from Ole Group.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T1.`Customer Names` = 'Ole Group' THEN T2.`Discount Applied` END AS T FROM Customers T1 INNER JOIN `Sales Orders` T2 ON T2._CustomerID = T1.CustomerID ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT discount FROM orders WHERE customer = 'Ole Group';"
        ],
        "rule_sql": []
    },
    "7804": {
        "db_id": "hockey",
        "question": "What is the full name of players origin from Finland?",
        "ground_truth": "SELECT DISTINCT firstName, lastName FROM Master WHERE birthCountry = 'Finland'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM players WHERE country = 'Finland';"
        ],
        "rule_sql": []
    },
    "8181": {
        "db_id": "sales_in_weather",
        "question": "Which weather station has the highest number of stores?",
        "ground_truth": "SELECT station_nbr FROM relation GROUP BY station_nbr ORDER BY COUNT(store_nbr) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_id, COUNT(store_id) as store_count FROM stores GROUP BY station_id ORDER BY store_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5199": {
        "db_id": "address",
        "question": "Provide the population of Arecibo in 2020.",
        "ground_truth": "SELECT SUM(T2.population_2020) FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.county = 'ARECIBO'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM cities WHERE name = 'Arecibo' AND year = 2020;"
        ],
        "rule_sql": []
    },
    "2251": {
        "db_id": "movielens",
        "question": "Among the movies from France, how many of them are drama?",
        "ground_truth": "SELECT COUNT(T1.movieid) FROM movies2directors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.country = 'France' AND T1.genre = 'drama'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE country = 'France' AND genre = 'drama';"
        ],
        "rule_sql": []
    },
    "1278": {
        "db_id": "law_episode",
        "question": "What are the keywords of the \"Shield\" episode?",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Shield'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword FROM episodes WHERE title = 'Shield';"
        ],
        "rule_sql": []
    },
    "127": {
        "db_id": "movie_platform",
        "question": "Who gave a \"4\" rating to the movie \"Freaks\" at 2013/5/4 6:33:32? Give his/her user id.",
        "ground_truth": "SELECT T1.user_id FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE rating_score = 4 AND rating_timestamp_utc LIKE '2013-05-04 06:33:32' AND T2.movie_title LIKE 'Freaks'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id FROM ratings WHERE rating = 4 AND movie_title = 'Freaks' AND timestamp = '2013/5/4 6:33:32';"
        ],
        "rule_sql": []
    },
    "4020": {
        "db_id": "public_review_platform",
        "question": "What is the closing time of business id 4 on Sunday?",
        "ground_truth": "SELECT T2.closing_time FROM Days AS T1 INNER JOIN Business_Hours AS T2 ON T1.day_id = T2.day_id WHERE T1.day_of_week = 'Sunday' AND T2.business_id = 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT closing_time FROM business_hours WHERE business_id = 4 AND day_of_week = 'Monday';"
        ],
        "rule_sql": []
    },
    "3118": {
        "db_id": "cars",
        "question": "Calculate the difference between the number of cars that has a horsepower of 130 with the model year 1970 and model year 1976",
        "ground_truth": "SELECT SUM(CASE WHEN T2.model_year = 1970 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.model_year = 1976 THEN 1 ELSE 0 END) FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID WHERE T1.horsepower = 130",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM cars WHERE horsepower = 130 AND model_year = 1970) - \n    (SELECT COUNT(*) FROM cars WHERE horsepower = 130 AND model_year = 1976) AS difference;"
        ],
        "rule_sql": []
    },
    "8192": {
        "db_id": "sales_in_weather",
        "question": "How many stores belong to the station with the highest recorded heat of all time?",
        "ground_truth": "SELECT COUNT(T2.store_nbr) FROM ( SELECT station_nbr FROM weather ORDER BY heat DESC LIMIT 1 ) AS T1 INNER JOIN relation AS T2 ON T1.station_nbr = T2.station_nbr",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores WHERE station_id = (SELECT station_id FROM heat_records ORDER BY heat DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "2934": {
        "db_id": "professional_basketball",
        "question": "Which NBA team that didn't play in playoffs had the most winning rate in the 2000 NBA regular season?",
        "ground_truth": "SELECT T2.tmID FROM players_teams AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.PostGP = 0 AND T1.year = 2000 ORDER BY CAST(T2.won AS REAL) / (T2.won + T2.lost) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, wins / (wins + losses) AS winning_rate \nFROM nba_teams \nWHERE season = 2000 AND playoffs = 0 \nORDER BY winning_rate DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9299": {
        "db_id": "movie_3",
        "question": "Who are the actors that act in the ACADEMY DINOSAUR film?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.title = 'ACADEMY DINOSAUR'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor.first_name, actor.last_name FROM actor JOIN film_actor ON actor.actor_id = film_actor.actor_id JOIN film ON film_actor.film_id = film.film_id WHERE film.title = 'ACADEMY DINOSAUR'"
        ],
        "rule_sql": []
    },
    "9192": {
        "db_id": "movie_3",
        "question": "How many customers are from the city of Lethbridge?",
        "ground_truth": "SELECT COUNT(T3.customer_id) FROM city AS T1 INNER JOIN address AS T2 ON T1.city_id = T2.city_id INNER JOIN customer AS T3 ON T2.address_id = T3.address_id WHERE T1.city = 'Lethbridge'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'Lethbridge';"
        ],
        "rule_sql": []
    },
    "8684": {
        "db_id": "chicago_crime",
        "question": "Find the ward office's address and phone number of the ward where the most crimes without arrest occurred.",
        "ground_truth": "SELECT T2.ward_office_address, T2.ward_office_phone FROM Crime AS T1 INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE T1.arrest = 'FALSE' GROUP BY T2.ward_office_address, T2.ward_office_phone ORDER BY COUNT(T1.arrest) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address, phone_number FROM ward_offices ORDER BY (SELECT COUNT(*) FROM crimes WHERE arrest = 0 AND ward_id = ward_offices.ward_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6841": {
        "db_id": "retails",
        "question": "How many line items were returned in 1998?",
        "ground_truth": "SELECT l_linenumber FROM lineitem WHERE STRFTIME('%Y', l_shipdate) < 1997 AND l_shipmode = 'TRUCK'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM lineitems WHERE return_date LIKE '1998%';"
        ],
        "rule_sql": []
    },
    "4439": {
        "db_id": "student_loan",
        "question": "How many disabled students have been absent for 3 months from school?",
        "ground_truth": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE T1.month = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE disabled = 1 AND absences >= 90;"
        ],
        "rule_sql": []
    },
    "6031": {
        "db_id": "books",
        "question": "In which cities are the customers of Costa Rica located?",
        "ground_truth": "SELECT T1.city FROM address AS T1 INNER JOIN country AS T2 ON T2.country_id = T1.country_id WHERE T2.country_name = 'Costa Rica'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM customers WHERE country = 'Costa Rica';"
        ],
        "rule_sql": []
    },
    "815": {
        "db_id": "social_media",
        "question": "How many unique users have seen tweet with text `Happy New Year to all those AWS instances of ours!`?",
        "ground_truth": "SELECT Reach FROM twitter WHERE text = 'Happy New Year to all those AWS instances of ours!'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM tweets WHERE text = 'Happy New Year to all those AWS instances of ours!';"
        ],
        "rule_sql": []
    },
    "4663": {
        "db_id": "disney",
        "question": "List the voice actors from the movie \"Meet the Robinsons\".",
        "ground_truth": "SELECT 'voice-actor' FROM `voice-actors` WHERE movie = 'Meet the Robinsons'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE movie_title = 'Meet the Robinsons';"
        ],
        "rule_sql": []
    },
    "1836": {
        "db_id": "soccer_2016",
        "question": "How many players with left-hand batting style are from India?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.Batting_hand = 'Left-hand bat' THEN 1 ELSE 0 END) AS cnt FROM Batting_Style AS T1 INNER JOIN Player AS T2 ON T1.Batting_Id = T2.Batting_hand INNER JOIN Country AS T3 ON T2.Country_Name = T3.Country_Id WHERE T3.Country_Name = 'India'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE batting_style = 'left' AND country = 'India';"
        ],
        "rule_sql": []
    },
    "8143": {
        "db_id": "sales_in_weather",
        "question": "What is the total number of units of item no.5 sold in store no.3 in 2012 on days when the temperature was below the 30-year normal?",
        "ground_truth": "SELECT SUM(CASE WHEN T3.depart < 0 THEN units ELSE 0 END) AS sum FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr INNER JOIN weather AS T3 ON T2.station_nbr = T3.station_nbr WHERE T2.store_nbr = 3 AND SUBSTR(T1.`date`, 1, 4) = '2012' AND T1.item_nbr = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(units_sold) \nFROM sales \nWHERE item_id = 5 \nAND store_id = 3 \nAND year = 2012 \nAND temperature < 30;"
        ],
        "rule_sql": []
    },
    "4253": {
        "db_id": "simpson_episodes",
        "question": "Please indicate the keywords of the title \"Double, Double, Boy in Trouble\".",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Double, Double, Boy in Trouble';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keywords FROM titles WHERE title = 'Double, Double, Boy in Trouble';"
        ],
        "rule_sql": []
    },
    "9339": {
        "db_id": "movie_3",
        "question": "List down film titles from id 1 to 10.",
        "ground_truth": "SELECT title FROM film WHERE film_id BETWEEN 1 AND 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE id BETWEEN 1 AND 10 ORDER BY id DESC;"
        ],
        "rule_sql": []
    },
    "7972": {
        "db_id": "music_platform_2",
        "question": "What are the titles and categories of all the podcasts with a review that has \"Absolutely fantastic\" in it?",
        "ground_truth": "SELECT T2.title, T1.category FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id INNER JOIN reviews AS T3 ON T3.podcast_id = T2.podcast_id WHERE T3.content LIKE '%Absolutely fantastic%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, category FROM podcasts WHERE review LIKE '%Absolutely fantastic%';"
        ],
        "rule_sql": []
    },
    "1810": {
        "db_id": "soccer_2016",
        "question": "State the name of captain keeper of the match no.419117.",
        "ground_truth": "SELECT T3.Player_Name FROM Player_Match AS T1 INNER JOIN Rolee AS T2 ON T1.Role_Id = T2.Role_Id INNER JOIN Player AS T3 ON T1.Player_Id = T3.Player_Id WHERE T1.Match_Id = '419117' AND T2.Role_Desc = 'CaptainKeeper'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE match_id = 419117 AND position = 'keeper' AND is_captain = 1"
        ],
        "rule_sql": []
    },
    "7399": {
        "db_id": "works_cycles",
        "question": "Which seasonal discount had the highest discount percentage?",
        "ground_truth": "SELECT Description FROM SpecialOffer WHERE Type = 'Seasonal Discount' ORDER BY DiscountPct DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT season, MAX(discount_percentage) FROM seasonal_discounts;"
        ],
        "rule_sql": []
    },
    "1456": {
        "db_id": "synthea",
        "question": "How many patients immunized against 'monovalent rotavirus' ceased their care plan on 11/23/2013?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM careplans AS T1 INNER JOIN immunizations AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'rotavirus  monovalent' AND T1.STOP = '2013-11-23'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients p JOIN immunizations i ON p.patient_id = i.patient_id WHERE i.vaccine_name = 'monovalent rotavirus' AND p.care_plan_end_date = '2013-11-23';"
        ],
        "rule_sql": []
    },
    "8636": {
        "db_id": "chicago_crime",
        "question": "What is the legislative district's office address where 010XX W LAKE ST is located?",
        "ground_truth": "SELECT T1.ward_office_address FROM Ward AS T1 INNER JOIN Crime AS T2 ON T1.ward_no = T2.ward_no WHERE T2.block = '010XX W LAKE ST' GROUP BY T1.ward_office_address",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT office_address FROM legislative_districts WHERE street_address = '010XX W LAKE ST';"
        ],
        "rule_sql": []
    },
    "1957": {
        "db_id": "soccer_2016",
        "question": "How many players bowl in the legbreak style?",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Bowling_Style AS T2 ON T1.Bowling_skill = T2.Bowling_Id WHERE T2.Bowling_skill = 'Legbreak'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE bowling_style = 'legbreak';"
        ],
        "rule_sql": []
    },
    "3472": {
        "db_id": "video_games",
        "question": "Find out the difference between the number of publishers who released the games on the PS3 and X360.",
        "ground_truth": "SELECT COUNT(CASE WHEN T2.platform_name = 'PS3' THEN T1.game_publisher_id ELSE NULL END) - COUNT(CASE WHEN T2.platform_name = 'X360' THEN T1.game_publisher_id ELSE NULL END) FROM game_platform AS T1 INNER JOIN platform AS T2 ON T1.platform_id = T2.id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT publisher) AS ps3_publishers, COUNT(DISTINCT publisher) AS x360_publishers, (COUNT(DISTINCT publisher) - COUNT(DISTINCT publisher)) AS difference FROM games WHERE platform = 'PS3' OR platform = 'X360' GROUP BY platform"
        ],
        "rule_sql": []
    },
    "1485": {
        "db_id": "synthea",
        "question": "What is the average body mass index for patients with higher total cholesterol?",
        "ground_truth": "SELECT SUM(T1.VALUE) / COUNT(T1.PATIENT) FROM observations AS T1 INNER JOIN ( SELECT DISTINCT PATIENT FROM observations WHERE DESCRIPTION = 'Total Cholesterol' AND VALUE > 200 ) AS T2 ON T1.PATIENT = T2.PATIENT WHERE T1.DESCRIPTION = 'Body Mass Index'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weight / (height * height)) AS avg_bmi FROM patients WHERE total_cholesterol > (SELECT AVG(total_cholesterol) FROM patients)"
        ],
        "rule_sql": []
    },
    "6708": {
        "db_id": "retails",
        "question": "How many customers are in the automobile market segment?",
        "ground_truth": "SELECT COUNT(c_custkey) FROM customer WHERE c_mktsegment = 'AUTOMOBILE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE market_segment = 'automobile';"
        ],
        "rule_sql": []
    },
    "2741": {
        "db_id": "european_football_1",
        "question": "What percentage of games won, games lost and games drawn does Cittadella have as a home team in total?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN FTR = 'H' THEN 1 ELSE NULL END) / COUNT(HomeTeam) AS REAL) * 100, CAST(COUNT(CASE WHEN FTR = 'A' THEN 1 ELSE NULL END) AS REAL) / COUNT(HomeTeam), CAST(COUNT(CASE WHEN FTR = 'D' THEN 1 ELSE NULL END) AS REAL) / COUNT(HomeTeam) FROM matchs WHERE HomeTeam = 'Cittadella'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN home_team = 'Cittadella' AND home_score > away_score THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS win_percentage,\n    (SUM(CASE WHEN home_team = 'Cittadella' AND home_score < away_score THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS loss_percentage,\n    (SUM(CASE WHEN home_team = 'Cittadella' AND home_score = away_score THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS draw_percentage\nFROM matches\nWHERE home_team = 'Cittadella';"
        ],
        "rule_sql": []
    },
    "4300": {
        "db_id": "simpson_episodes",
        "question": "What are the titles of the episodes that have received more 7-star votes than the season average?",
        "ground_truth": "SELECT DISTINCT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 7 AND T2.votes > 0.7 * ( SELECT CAST(COUNT(votes) AS REAL) / COUNT(CASE WHEN stars = 7 THEN 1 ELSE 0 END) FROM Vote );",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.title \nFROM episodes e\nJOIN votes v ON e.episode_id = v.episode_id\nWHERE v.rating = 7\nGROUP BY e.episode_id, e.title\nHAVING COUNT(v.vote_id) > (\n    SELECT AVG(COUNT(v2.vote_id))\n    FROM votes v2\n    WHERE v2.rating = 7\n    GROUP BY v2.episode_id\n);"
        ],
        "rule_sql": []
    },
    "8299": {
        "db_id": "mondial_geo",
        "question": "Among the countries whose agriculture takes up more than 40% of its GDP, how many of them have less than 2 mountains?",
        "ground_truth": "SELECT COUNT(T3.Country) FROM ( SELECT T1.Country FROM economy AS T1 INNER JOIN geo_mountain AS T2 ON T1.Country = T2.Country WHERE T1.Industry < 40 GROUP BY T1.Country HAVING COUNT(T1.Country) < 2 ) AS T3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM countries c\nJOIN mountains m ON c.country_id = m.country_id\nWHERE c.agriculture > 40\nGROUP BY c.country_id\nHAVING COUNT(m.mountain_id) < 2;"
        ],
        "rule_sql": []
    },
    "3250": {
        "db_id": "donor",
        "question": "List the resource types available at Sax Arts & Crafts.",
        "ground_truth": "SELECT DISTINCT project_resource_type FROM resources WHERE vendor_name = 'Sax Arts & Crafts'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT type FROM resources WHERE store_name = 'Sax Arts & Crafts';"
        ],
        "rule_sql": []
    },
    "7772": {
        "db_id": "hockey",
        "question": "Please list the nick names of the coaches who are from the USA and have taught the Buffalo Sabres.",
        "ground_truth": "SELECT DISTINCT nameNick FROM Coaches AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.name = 'Buffalo Sabres' AND T3.birthCountry = 'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nick_name FROM coaches WHERE country = 'USA' AND team = 'Buffalo Sabres';"
        ],
        "rule_sql": []
    },
    "3797": {
        "db_id": "public_review_platform",
        "question": "How many user ids from 1 to 20 have no fan users and have low ratings?",
        "ground_truth": "SELECT COUNT(user_id) FROM Users WHERE user_id BETWEEN 1 AND 20 AND user_fans LIKE 'None' AND user_review_count LIKE 'Low'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT user_id) \nFROM users \nWHERE user_id BETWEEN 1 AND 20 \nAND fan_users IS NULL \nAND rating < 3;"
        ],
        "rule_sql": []
    },
    "2813": {
        "db_id": "professional_basketball",
        "question": "Which player, born in Winter Haven, played 12 minutes per season during the 1980s in the All-Stars?",
        "ground_truth": "SELECT DISTINCT T1.firstName, T1.middleName, T1.lastName FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCity = 'Winter Haven' AND T2.season_id BETWEEN 1980 AND 1989 AND T2.minutes = 12",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name \nFROM players \nWHERE birth_city = 'Winter Haven' \nAND minutes_per_season = 12 \nAND decade = '1980s' \nAND all_star_status = 'Yes';"
        ],
        "rule_sql": []
    },
    "1127": {
        "db_id": "talkingdata",
        "question": "Give the number of 30-year-old users who were active in the events on 2016/5/2.",
        "ground_truth": "SELECT COUNT(T3.device_id) FROM app_events AS T1 INNER JOIN events AS T2 ON T1.event_id = T2.event_id INNER JOIN gender_age AS T3 ON T2.device_id = T3.device_id WHERE SUBSTR(`timestamp`, 1, 10) = '2016-05-02' AND T1.is_active = 1 AND T3.age = '30'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age = 30 AND last_active_date = '2016/5/2';"
        ],
        "rule_sql": []
    },
    "5533": {
        "db_id": "menu",
        "question": "How much does the dish on page 2 of menu ID 12474 cost?",
        "ground_truth": "SELECT T1.price FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T2.id = T1.menu_page_id WHERE T2.menu_id = 12474 AND T2.page_number = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT price FROM menu_dishes WHERE menu_id = 12474 AND page_number = 2 LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1434": {
        "db_id": "synthea",
        "question": "List down the first name of patients who have cystitis condition.",
        "ground_truth": "SELECT DISTINCT T1.first FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Cystitis'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM patients WHERE condition = 'cystitis';"
        ],
        "rule_sql": []
    },
    "1165": {
        "db_id": "talkingdata",
        "question": "Calculate the percentage of male users among all device users.",
        "ground_truth": "SELECT SUM(IIF(gender = 'M', 1, 0)) / COUNT(device_id) AS per FROM gender_age",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN gender = 'male' THEN 1 END) / COUNT(*)) * 100 AS male_percentage FROM users;"
        ],
        "rule_sql": []
    },
    "6866": {
        "db_id": "retails",
        "question": "How many suppliers have their accounts in debt?",
        "ground_truth": "SELECT COUNT(s_suppkey) FROM supplier WHERE s_acctbal < 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM suppliers WHERE account_balance > 0;"
        ],
        "rule_sql": []
    },
    "4465": {
        "db_id": "student_loan",
        "question": "How many students are enlisted in the Navy organization?",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'navy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE organization = 'Army';"
        ],
        "rule_sql": []
    },
    "8258": {
        "db_id": "mondial_geo",
        "question": "How many organizations are established after 1999/1/1 in a country whose GDP is under 500000?",
        "ground_truth": "SELECT T1.Country, COUNT(T1.Country) FROM economy AS T1 INNER JOIN organization AS T2 ON T1.Country = T2.Country WHERE T1.GDP < 500000 AND STRFTIME('%Y', T2.Established) < '1999' GROUP BY T1.Country",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM organizations o\nJOIN countries c ON o.country_id = c.id\nWHERE o.established_date > '1999-01-01' \nAND c.gdp < 500000;"
        ],
        "rule_sql": []
    },
    "7688": {
        "db_id": "hockey",
        "question": "For the coach who won Second Team All-Star in 1933, how many wins did he have that year?",
        "ground_truth": "SELECT SUM(T1.W) FROM Coaches AS T1 INNER JOIN AwardsCoaches AS T2 ON T1.coachID = T2.coachID WHERE T2.year = 1933 AND T2.award = 'Second Team All-Star'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT wins FROM coaches WHERE award = 'Second Team All-Star' AND year = 1933;"
        ],
        "rule_sql": []
    },
    "4528": {
        "db_id": "student_loan",
        "question": "Give the number of students who enlisted in marines and have payment due.",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE T1.bool = 'pos' AND T2.organ = 'marines'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE branch = 'Marines' AND payment_status = 'paid';"
        ],
        "rule_sql": []
    },
    "2848": {
        "db_id": "professional_basketball",
        "question": "From 1960 to 1970, what is the total point of all-star players who are still alive?",
        "ground_truth": "SELECT SUM(T2.points) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T2.season_id BETWEEN 1960 AND 1970 AND T1.deathDate = '0000-00-00'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(points) FROM all_star_players WHERE year BETWEEN 1960 AND 1970 AND is_alive = 'yes';"
        ],
        "rule_sql": []
    },
    "7204": {
        "db_id": "works_cycles",
        "question": "Among the employees who wish to receive e-mail promotion from AdventureWorks, how many percent of them are female?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.EmailPromotion = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN e.Gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS female_percentage\nFROM \n    HumanResources.Employee e\nJOIN \n    Person.Person p ON e.BusinessEntityID = p.BusinessEntityID\nWHERE \n    p.EmailPromotion = 1"
        ],
        "rule_sql": []
    },
    "2783": {
        "db_id": "european_football_1",
        "question": "How many matches were held during the 2021 season's Premier League?",
        "ground_truth": "SELECT COUNT(T1.Div) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.season = 2021 AND T2.name = 'Premier League'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE season = '2021' AND league = 'Premier League';"
        ],
        "rule_sql": []
    },
    "990": {
        "db_id": "computer_student",
        "question": "Is the teacher who teaches course no.9 a faculty member?",
        "ground_truth": "SELECT T2.hasPosition FROM taughtBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T1.course_id = 9",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM teachers WHERE course_id = 9 AND faculty_member = 'yes';"
        ],
        "rule_sql": []
    },
    "2169": {
        "db_id": "world_development_indicators",
        "question": "Write down the description and series code of Benin in year 2005.",
        "ground_truth": "SELECT T2.Description, T2.Seriescode FROM Country AS T1 INNER JOIN FootNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.TableName = 'Benin' AND T2.Year = 'YR2005'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description, series_code FROM countries WHERE name = 'Benin' AND year = 2005;"
        ],
        "rule_sql": []
    },
    "1054": {
        "db_id": "talkingdata",
        "question": "Which category has the highest number of users?",
        "ground_truth": "SELECT T.category FROM ( SELECT T2.category, COUNT(T1.app_id) AS num FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id GROUP BY T1.app_id, T2.category ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, COUNT(*) FROM users GROUP BY category ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2062": {
        "db_id": "music_tracker",
        "question": "What are the average download times for the a release tagged \"1980s\"?",
        "ground_truth": "SELECT CAST(SUM(T1.totalSnatched) AS REAL) / COUNT(T2.tag) FROM torrents AS T1 INNER JOIN tags AS T2 ON T1.id = T2.id WHERE T2.tag = '1980s'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(download_time) FROM releases WHERE tag = '1980s';"
        ],
        "rule_sql": []
    },
    "7820": {
        "db_id": "world",
        "question": "List any five countries which use English as an official language.",
        "ground_truth": "SELECT T1.Name FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T2.Language = 'English' AND T2.IsOfficial = 'T' LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE official_language = 'English' LIMIT 5;"
        ],
        "rule_sql": []
    },
    "512": {
        "db_id": "movies_4",
        "question": "List down the tagline of the Polski movies.",
        "ground_truth": "SELECT DISTINCT T1.tagline FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id WHERE T3.language_name = 'Polski'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tagline FROM movies WHERE language = 'Polish';"
        ],
        "rule_sql": []
    },
    "6729": {
        "db_id": "retails",
        "question": "List any five parts name in Medium Plated Brass.",
        "ground_truth": "SELECT p_name FROM part WHERE p_type = 'MEDIUM PLATED BRASS' LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT part_name FROM parts WHERE material = 'Medium Plated Brass' LIMIT 5;"
        ],
        "rule_sql": []
    },
    "5204": {
        "db_id": "address",
        "question": "Among the area code 787, list the country of the cities with a postal point type of unique postal office.",
        "ground_truth": "SELECT DISTINCT T2.county FROM area_code AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code INNER JOIN zip_data AS T3 ON T1.zip_code = T3.zip_code WHERE T1.area_code = '787' AND T3.type = 'Unique Post Office'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cities WHERE area_code = '787' AND postal_point_type = 'unique postal office';"
        ],
        "rule_sql": []
    },
    "2878": {
        "db_id": "professional_basketball",
        "question": "Please list the team names which have at least 5 players were born in the same state.",
        "ground_truth": "SELECT DISTINCT name FROM teams WHERE tmID IN ( SELECT tmID FROM players_teams AS T1 INNER JOIN players AS T2 ON T1.playerID = T2.playerID WHERE T2.birthState IS NOT NULL GROUP BY T1.tmID, T2.birthState HAVING COUNT(*) > 5 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name \nFROM teams \nWHERE team_id IN (\n    SELECT team_id \n    FROM players \n    GROUP BY team_id, state \n    HAVING COUNT(*) >= 5\n)"
        ],
        "rule_sql": []
    },
    "8851": {
        "db_id": "food_inspection",
        "question": "What is the owner's name of the of the business that violates 103156 on June 12, 2014?",
        "ground_truth": "SELECT DISTINCT T2.owner_name FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T1.violation_type_id = 103156 AND T1.`date` = '2014-06-12'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT owner_name FROM businesses WHERE violation_id = 103156 AND violation_date = '2014-06-12';"
        ],
        "rule_sql": []
    },
    "2029": {
        "db_id": "soccer_2016",
        "question": "Which team won by wickets in match ID 335993?",
        "ground_truth": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_id = T2.match_winner INNER JOIN Player_Match AS T3 ON T1.Team_Id = T3.Team_Id INNER JOIN Win_By AS T4 ON T2.Win_Type = T4.Win_Id WHERE T2.Match_Id = '335993' GROUP BY T1.Team_Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE match_id = 335993 AND win_by_wickets > 0;"
        ],
        "rule_sql": []
    },
    "7137": {
        "db_id": "works_cycles",
        "question": "What percentage of the AdventureWorks data is in Thai?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Name = 'Thai' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.CultureID) FROM Culture AS T1 INNER JOIN ProductModelProductDescriptionCulture AS T2 ON T1.CultureID = T2.CultureID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM AdventureWorks)) AS percentage_thai FROM AdventureWorks WHERE language = 'Thai';"
        ],
        "rule_sql": []
    },
    "7308": {
        "db_id": "works_cycles",
        "question": "List all the non-sales employees in ascending order of its business entitty ID.",
        "ground_truth": "SELECT FirstName, LastName FROM Person WHERE PersonType = 'EM' ORDER BY BusinessEntityID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM employees WHERE department != 'Sales' ORDER BY business_entity_id ASC;"
        ],
        "rule_sql": []
    },
    "3901": {
        "db_id": "public_review_platform",
        "question": "How many attributes ID owned by business ID 2?",
        "ground_truth": "SELECT COUNT(attribute_id) FROM Business_Attributes WHERE business_id = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM attributes WHERE business_id = 2;"
        ],
        "rule_sql": []
    },
    "6942": {
        "db_id": "ice_hockey_draft",
        "question": "Among all the teams that made the playoffs in the 2007-2008 season, identify the percentage that played over 20 games.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN GP > 20 THEN TEAM ELSE NULL END) AS REAL) * 100 / COUNT(TEAM) FROM SeasonStatus WHERE SEASON = '2007-2008' AND GAMETYPE = 'Playoffs'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM teams WHERE playoffs = 1 AND season = '2007-2008') AS percentage\nFROM teams \nWHERE games_played > 20 AND playoffs = 1 AND season = '2007-2008';"
        ],
        "rule_sql": []
    },
    "5290": {
        "db_id": "beer_factory",
        "question": "Among the transactions, what percentage is done by using a visa card?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN CreditCardType = 'Visa' THEN TransactionID ELSE NULL END) AS REAL) * 100 / COUNT(TransactionID) FROM `transaction`",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM transactions) AS percentage FROM transactions WHERE card_type = 'Visa';"
        ],
        "rule_sql": []
    },
    "7052": {
        "db_id": "works_cycles",
        "question": "Please list the job titles of the employees who has a document that has been approved.",
        "ground_truth": "SELECT DISTINCT T2.BusinessEntityID, T2.JobTitle FROM Document AS T1 INNER JOIN Employee AS T2 ON T1.Owner = T2.BusinessEntityID WHERE T1.Status = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT job_title FROM employees WHERE document_status = 'approved';"
        ],
        "rule_sql": []
    },
    "7101": {
        "db_id": "works_cycles",
        "question": "What is the product cost end date with the highest weight in grams?",
        "ground_truth": "SELECT T2.EndDate FROM Product AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.WeightUnitMeasureCode = 'G' ORDER BY T1.Weight DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(WeightGrams) FROM Products ORDER BY CostEndDate DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3312": {
        "db_id": "video_games",
        "question": "Please list the names of all the games published by 10TACLE Studios.",
        "ground_truth": "SELECT T1.game_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE T3.publisher_name = '10TACLE Studios'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM games WHERE publisher = '10TACLE Studios';"
        ],
        "rule_sql": []
    },
    "3170": {
        "db_id": "donor",
        "question": "What is the total price including optional support received by the teacher who posted the essay titled \"Recording Rockin' Readers\"?",
        "ground_truth": "SELECT SUM(T1.total_price_including_optional_support) FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid WHERE T2.title = 'Recording Rockin'' Readers'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price + optional_support) AS total_revenue\nFROM essays\nWHERE title = 'Recording Rockin'' Readers'\nAND teacher_id IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "1275": {
        "db_id": "law_episode",
        "question": "Who is the tallest camera operator?",
        "ground_truth": "SELECT T2.name FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T1.role = 'camera operator' ORDER BY T2.height_meters DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM camera_operators ORDER BY height ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1290": {
        "db_id": "law_episode",
        "question": "What is the title of the episode that has the highest number of crews in the Art Department?",
        "ground_truth": "SELECT T2.title FROM Credit AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.category = 'Art Department' GROUP BY T2.episode_id ORDER BY COUNT(T1.category) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY (SELECT COUNT(*) FROM crews WHERE department = 'Art Department' AND episode_id = episodes.id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6160": {
        "db_id": "food_inspection_2",
        "question": "What is the establishment's name and employee involved in the inspection ID 44256 on May 5, 2010?",
        "ground_truth": "SELECT T1.dba_name, T3.first_name, T3.last_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id WHERE T2.inspection_date = '2010-05-05' AND T2.inspection_id = 44256",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT establishment_name, employee_name FROM inspections WHERE inspection_id = 44256 AND inspection_date = '2010-05-05';"
        ],
        "rule_sql": []
    },
    "1140": {
        "db_id": "talkingdata",
        "question": "What is the age of the youngest female device user?",
        "ground_truth": "SELECT MIN(age) FROM gender_age WHERE gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(age) FROM users WHERE gender = 'female' AND device_owner = 1;"
        ],
        "rule_sql": []
    },
    "3679": {
        "db_id": "authors",
        "question": "Sate the author name and published year for paper id 2?",
        "ground_truth": "SELECT T1.Name, T3.Year FROM Author AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.AuthorId INNER JOIN Paper AS T3 ON T2.PaperId = T3.Id WHERE T2.PaperId = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name, published_year FROM papers WHERE paper_id = 2;"
        ],
        "rule_sql": []
    },
    "200": {
        "db_id": "book_publishing_company",
        "question": "Please list the first names of the employees who work as Managing Editor.",
        "ground_truth": "SELECT T1.fname FROM employee AS T1 INNER JOIN jobs AS T2 ON T1.job_id = T2.job_id WHERE T2.job_desc = 'Managing Editor'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM employees WHERE job_title = 'Managing Editor';"
        ],
        "rule_sql": []
    },
    "8818": {
        "db_id": "food_inspection",
        "question": "What is the average score of the establishments owned by the owner with the highest number of establishments?",
        "ground_truth": "SELECT AVG(T1.score) FROM inspections AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id GROUP BY T2.owner_name ORDER BY COUNT(T2.business_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) FROM establishments WHERE owner_id = (SELECT owner_id FROM establishments GROUP BY owner_id ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "3789": {
        "db_id": "public_review_platform",
        "question": "How many types of music does Yelp business No.\"1141\" have?",
        "ground_truth": "SELECT COUNT(T1.attribute_name) FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_value LIKE 'TRUE' AND T2.business_id = 1141",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM music_types WHERE business_id = 1141;"
        ],
        "rule_sql": []
    },
    "6817": {
        "db_id": "retails",
        "question": "What is the delivery time and the clerk of order number 6?",
        "ground_truth": "SELECT JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate), T1.o_clerk FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderkey = 6",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT delivery_time, clerk FROM orders WHERE order_id = 6;"
        ],
        "rule_sql": []
    },
    "7730": {
        "db_id": "hockey",
        "question": "How many goals were scored while the goalkeeper was on the ice in the 1924 WCHL by the goalie with the most goals scored?",
        "ground_truth": "SELECT SUM(PostGA) FROM Goalies WHERE lgID = 'WCHL' AND year = '1924' GROUP BY playerID ORDER BY SUM(PostGA) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM goals g\nJOIN players p ON g.player_id = p.player_id\nWHERE p.position = 'Goalie' \nAND g.season = '1924 WCHL'\nGROUP BY p.player_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5682": {
        "db_id": "shipping",
        "question": "Calculate the difference between the number of shipments shipped by the truck with the model year 2005 and model year 2006.",
        "ground_truth": "SELECT SUM(CASE WHEN T1.model_year = '2005' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.model_year = '2006' THEN 1 ELSE 0 END) FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM shipments s JOIN trucks t ON s.truck_id = t.truck_id WHERE t.model_year = 2005) - \n    (SELECT COUNT(*) FROM shipments s JOIN trucks t ON s.truck_id = t.truck_id WHERE t.model_year = 2006) AS difference;"
        ],
        "rule_sql": []
    },
    "8239": {
        "db_id": "mondial_geo",
        "question": "What is the infant mortality rate for Ethiopia?",
        "ground_truth": "SELECT T2.Infant_Mortality FROM country AS T1 INNER JOIN population AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Ethiopia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT infant_mortality_rate FROM countries WHERE name = 'Ethiopia';"
        ],
        "rule_sql": []
    },
    "8095": {
        "db_id": "university",
        "question": "Which university had the most students in 2011? Show its name.",
        "ground_truth": "SELECT T2.university_name FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2011 ORDER BY T1.num_students DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_name FROM universities WHERE year = 2011 ORDER BY student_count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6104": {
        "db_id": "books",
        "question": "Give the publisher's name of the books authored by Alan Lee.",
        "ground_truth": "SELECT T4.publisher_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id INNER JOIN publisher AS T4 ON T4.publisher_id = T1.publisher_id WHERE T3.author_name = 'Alan Lee' GROUP BY T4.publisher_name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher_name FROM books WHERE author = 'Alan Lee';"
        ],
        "rule_sql": []
    },
    "6225": {
        "db_id": "food_inspection_2",
        "question": "How many employees are living in Hoffman Estates, IL?",
        "ground_truth": "SELECT COUNT(employee_id) FROM employee WHERE state = 'IL' AND city = 'Hoffman Estates'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE city = 'Hoffman Estates' AND state = 'IL';"
        ],
        "rule_sql": []
    },
    "1730": {
        "db_id": "restaurant",
        "question": "List all of the restaurant addresses from an unknown region.",
        "ground_truth": "SELECT T2.street_name FROM geographic AS T1 INNER JOIN location AS T2 ON T1.city = T2.city WHERE T1.region = 'unknown'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM restaurants WHERE region = 'unknown';"
        ],
        "rule_sql": []
    },
    "846": {
        "db_id": "social_media",
        "question": "From which city was the tweet with the most number of retweets posted?",
        "ground_truth": "SELECT T2.City FROM twitter AS T1 INNER JOIN location AS T2 ON T1.LocationID = T2.LocationID ORDER BY T1.RetweetCount DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM tweets ORDER BY retweets DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5065": {
        "db_id": "olympics",
        "question": "List the names of the games held in Paris.",
        "ground_truth": "SELECT T3.games_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T2.city_name = 'Paris'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM games WHERE city = 'London';"
        ],
        "rule_sql": []
    },
    "2408": {
        "db_id": "superstore",
        "question": "What product category that Sam Craven ordered from the central and east superstore?",
        "ground_truth": "SELECT DISTINCT T3.Category FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` LEFT JOIN central_superstore AS T4 ON T3.`Product ID` = T4.`Product ID` WHERE T2.`Customer Name` = 'Sam Craven'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM orders WHERE customer_name = 'Sam Craven' AND region IN ('Central', 'East')"
        ],
        "rule_sql": []
    },
    "6127": {
        "db_id": "food_inspection_2",
        "question": "When did Wing Hung Chop Suey Restaurant have its first inspection?",
        "ground_truth": "SELECT MIN(T2.inspection_date) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.aka_name = 'WING HUNG CHOP SUEY RESTAURANT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(inspection_date) FROM inspections WHERE restaurant_name = 'Wing Hung Chop Suey Restaurant';"
        ],
        "rule_sql": []
    },
    "5895": {
        "db_id": "airline",
        "question": "What is the air carrier's description of the cancelled flights?",
        "ground_truth": "SELECT T1.Description FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T2.CANCELLED = 1 GROUP BY T1.Description",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM flights WHERE status = 'cancelled';"
        ],
        "rule_sql": []
    },
    "7776": {
        "db_id": "hockey",
        "question": "How many penalty minutes did the Montreal Canadiens have in the 1918's Stanley Cup Finals?",
        "ground_truth": "SELECT T2.PIM FROM Teams AS T1 INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.name = 'Montreal Canadiens' AND T1.year = 1918",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(penalty_minutes) FROM player_stats WHERE team = 'Montreal Canadiens' AND year = 1918 AND competition = 'Stanley Cup Finals';"
        ],
        "rule_sql": []
    },
    "761": {
        "db_id": "movie",
        "question": "What is the name of male and white actor with actor ID 439?",
        "ground_truth": "SELECT Name FROM actor WHERE ActorID = 439 AND Gender = 'Male' AND Ethnicity = 'White'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM actors WHERE gender = 'female' AND race = 'white' AND actor_id = 439;"
        ],
        "rule_sql": []
    },
    "4600": {
        "db_id": "mental_health_survey",
        "question": "Tell the number of surveys that contained the question \u201cWhat country do you work in?\u201d.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.QuestionID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid INNER JOIN Survey AS T3 ON T1.SurveyID = T3.SurveyID WHERE T2.questiontext = 'What country do you work in?'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM surveys WHERE question = 'What country do you work in?'"
        ],
        "rule_sql": []
    },
    "8245": {
        "db_id": "mondial_geo",
        "question": "Which country has the highest GDP?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country ORDER BY T2.GDP DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM countries ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1510": {
        "db_id": "synthea",
        "question": "How many white patients have the reason code of 10509002?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.PATIENT) FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.race = 'white' AND T1.REASONCODE = '10509002'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE race = 'white' AND reason_code = '10509002';"
        ],
        "rule_sql": []
    },
    "4155": {
        "db_id": "citeseer",
        "question": "Under what classification do the papers that cited word1163 belong?",
        "ground_truth": "SELECT DISTINCT T1.class_label FROM paper AS T1 INNER JOIN content AS T2 ON T1.paper_id = T2.paper_id WHERE T2.word_cited_id = 'word1163'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT classification FROM papers WHERE paper_id IN (SELECT citing_paper_id FROM citations WHERE cited_paper_id = 'word1163')"
        ],
        "rule_sql": []
    },
    "6167": {
        "db_id": "food_inspection_2",
        "question": "How many of the restaurants with the lowest risk level failed the complaint inspection type?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.license_no) FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.risk_level = '1' AND T2.inspection_type = 'Complaint' AND T1.facility_type = 'Restaurant' AND T2.results = 'Fail'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM restaurants \nWHERE risk_level = 'Low' \nAND inspection_type = 'Complaint' \nAND result = 'Fail';"
        ],
        "rule_sql": []
    },
    "187": {
        "db_id": "book_publishing_company",
        "question": "List all employees working for publisher 'GGG&G'. State their name and job description.",
        "ground_truth": "SELECT T1.fname, T1.lname, T3.job_desc FROM employee AS T1 INNER JOIN publishers AS T2 ON T1.pub_id = T2.pub_id INNER JOIN jobs AS T3 ON T1.job_id = T3.job_id WHERE T2.pub_name = 'GGG&G'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, job_description FROM employees WHERE publisher = 'GGG&G';"
        ],
        "rule_sql": []
    },
    "7353": {
        "db_id": "works_cycles",
        "question": "What are the sales reasons for order 43718?",
        "ground_truth": "SELECT T2.Name FROM SalesOrderHeaderSalesReason AS T1 INNER JOIN SalesReason AS T2 ON T1.SalesReasonID = T2.SalesReasonID WHERE T1.SalesOrderID = 43718",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM SalesReason WHERE OrderID = 43718;"
        ],
        "rule_sql": []
    },
    "5918": {
        "db_id": "books",
        "question": "Among the books published by publisher \"Thomas Nelson\", how many of them have over 300 pages?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Thomas Nelson' AND T1.num_pages > 300",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher = 'Thomas Nelson' AND pages > 300;"
        ],
        "rule_sql": []
    },
    "4002": {
        "db_id": "public_review_platform",
        "question": "What is the ratio between business in shopping category and business in pets category?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.category_name = 'Shopping' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.category_name = 'Pets' THEN 1 ELSE 0 END) AS radio FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM business WHERE category = 'shopping') / \n    (SELECT COUNT(*) FROM business WHERE category = 'pets') \nAS ratio"
        ],
        "rule_sql": []
    },
    "2708": {
        "db_id": "regional_sales",
        "question": "Which store in Arizona has the most net profit?",
        "ground_truth": "SELECT T2.StoreID FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID WHERE T2.State = 'Arizona' ORDER BY T1.`Unit Price` - T1.`Unit Cost` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_name, SUM(revenue) as net_profit FROM stores WHERE state = 'Arizona' GROUP BY store_name ORDER BY net_profit DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7474": {
        "db_id": "image_and_language",
        "question": "How many images have over 20 object samples?",
        "ground_truth": "SELECT COUNT(T1.IMG_ID) FROM ( SELECT IMG_ID FROM IMG_OBJ GROUP BY IMG_ID HAVING COUNT(OBJ_SAMPLE_ID) > 20 ) T1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE object_samples > 20;"
        ],
        "rule_sql": []
    },
    "8534": {
        "db_id": "software_company",
        "question": "In geographic identifier from 20 to 50, how many of them has a number of inhabitants below 20?",
        "ground_truth": "SELECT COUNT(GEOID) FROM Demog WHERE INHABITANTS_K < 20 AND GEOID >= 20 AND GEOID <= 50",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM geographic_identifiers WHERE id BETWEEN 20 AND 50 AND inhabitants > 20;"
        ],
        "rule_sql": []
    },
    "5566": {
        "db_id": "menu",
        "question": "Which menu page has a bigger width, page 1 of \"Zentral Theater Terrace\" or page 1 of \"Young's Hotel\"?",
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.name = 'Zentral Theater Terrace' THEN T2.full_width ELSE 0 END) - SUM(CASE WHEN T1.name = 'Young''s Hotel' THEN T2.full_width ELSE 0 END) > 0 THEN 'Zentral Theater Terrace' ELSE 'Young''s Hotel' END FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN (SELECT width FROM menu_pages WHERE page_number = 1 AND menu_id = (SELECT id FROM menus WHERE name = 'Zentral Theater Terrace')) > \n             (SELECT width FROM menu_pages WHERE page_number = 1 AND menu_id = (SELECT id FROM menus WHERE name = 'Young''s Hotel')) \n        THEN 'Zentral Theater Terrace' \n        ELSE 'Young''s Hotel' \n    END AS bigger_width_menu"
        ],
        "rule_sql": []
    },
    "7150": {
        "db_id": "works_cycles",
        "question": "Give the Mauritius Rupee's currency code.",
        "ground_truth": "SELECT CurrencyCode FROM Currency WHERE Name = 'Mauritius Rupee'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT currency_name FROM currencies WHERE currency_code = 'MUR';"
        ],
        "rule_sql": []
    },
    "6028": {
        "db_id": "books",
        "question": "Indicate the title of the six books with the greatest potential value as collectibles.",
        "ground_truth": "SELECT title FROM book ORDER BY publication_date ASC LIMIT 6",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books ORDER BY price DESC LIMIT 6;"
        ],
        "rule_sql": []
    },
    "1273": {
        "db_id": "law_episode",
        "question": "Who is the script supervisor of the series in episode tt0629204?",
        "ground_truth": "SELECT T2.name FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id WHERE T1.episode_id = 'tt0629204' AND T1.role = 'script supervisor'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT script_supervisor FROM episodes WHERE episode_id = 'tt0629204';"
        ],
        "rule_sql": []
    },
    "7049": {
        "db_id": "works_cycles",
        "question": "Please list the unit measure code of the component that is of the greatest need in quantity to create the assembly.",
        "ground_truth": "SELECT UnitMeasureCode FROM BillOfMaterials ORDER BY PerAssemblyQty DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT unit_measure_code FROM components ORDER BY quantity DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5935": {
        "db_id": "books",
        "question": "Name the book title of the bestseller.",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id GROUP BY T1.title ORDER BY COUNT(T1.title) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author FROM books WHERE bestseller = 'yes';"
        ],
        "rule_sql": []
    },
    "3372": {
        "db_id": "video_games",
        "question": "What is the title of the game that gained the most sales in Japan?",
        "ground_truth": "SELECT T.game_name FROM ( SELECT T5.game_name FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN game_publisher AS T4 ON T3.game_publisher_id = T4.id INNER JOIN game AS T5 ON T4.game_id = T5.id WHERE T1.region_name = 'Japan' ORDER BY T2.num_sales DESC LIMIT 1 ) t",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM games ORDER BY sales_japan DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7080": {
        "db_id": "works_cycles",
        "question": "Average of the last receipt cost of the products whose average lead time is 60 days.",
        "ground_truth": "SELECT SUM(LastReceiptCost) / COUNT(ProductID) FROM ProductVendor WHERE AverageLeadTime = 60",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(cost) FROM receipts WHERE product_id IN (SELECT product_id FROM products WHERE lead_time = 60) ORDER BY receipt_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5946": {
        "db_id": "books",
        "question": "How many orders in 2022 have Iran as their destinations?",
        "ground_truth": "SELECT COUNT(*) FROM country AS T1 INNER JOIN address AS T2 ON T1.country_id = T2.country_id INNER JOIN cust_order AS T3 ON T3.dest_address_id = T2.address_id WHERE T1.country_name = 'Iran' AND STRFTIME('%Y', T3.order_date) = '2022'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE year = 2022 AND destination = 'Iran';"
        ],
        "rule_sql": []
    },
    "4557": {
        "db_id": "student_loan",
        "question": "What is the name of the organization which most of the students are enlisted in?",
        "ground_truth": "SELECT organ FROM ( SELECT organ, COUNT(organ) AS num FROM enlist GROUP BY organ ) T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization_name FROM organizations ORDER BY COUNT(student_id) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1924": {
        "db_id": "soccer_2016",
        "question": "In which venue did Kochi Tuskers Kerala play most of their matches?",
        "ground_truth": "SELECT T1.Venue_Name FROM Venue AS T1 INNER JOIN Match AS T2 ON T1.Venue_Id = T2.Venue_Id INNER JOIN Team AS T3 ON T2.Team_1 = T3.Team_Id WHERE T3.Team_Name = 'Kochi Tuskers Kerala' GROUP BY T1.Venue_Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue FROM matches WHERE team = 'Kochi Tuskers Kerala' GROUP BY venue ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7691": {
        "db_id": "hockey",
        "question": "For the coach who co-coached with Dave Lewis in 1998, where was his birth place?",
        "ground_truth": "SELECT T1.birthCountry FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE T2.year = 1998 AND T2.notes = 'co-coach with Dave Lewis'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_place FROM coaches WHERE name = 'Dave Lewis' AND year = 1998;"
        ],
        "rule_sql": []
    },
    "2789": {
        "db_id": "european_football_1",
        "question": "Of the matches in all seasons of the Bundesliga division, how many of them ended with a tie?",
        "ground_truth": "SELECT COUNT(T1.Div) FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T2.name = 'Bundesliga' AND T1.FTR = 'D'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE home_team_score = away_team_score AND division = 'Bundesliga';"
        ],
        "rule_sql": []
    },
    "4950": {
        "db_id": "olympics",
        "question": "Where was the first Olympic game held?",
        "ground_truth": "SELECT T2.city_name FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id ORDER BY T3.games_year LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM olympic_games WHERE year = (SELECT MIN(year) FROM olympic_games);"
        ],
        "rule_sql": []
    },
    "5638": {
        "db_id": "shipping",
        "question": "Give the full name of driver who transported the items on 3/2/2016.",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM shipment AS T1 INNER JOIN driver AS T2 ON T1.driver_id = T2.driver_id WHERE T1.ship_date = '2016-03-02'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM shipments WHERE date = '2016-03-02';"
        ],
        "rule_sql": []
    },
    "8484": {
        "db_id": "mondial_geo",
        "question": "State the inflation rate of Greece.",
        "ground_truth": "SELECT T2.Inflation FROM country AS T1 INNER JOIN economy AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Greece'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inflation_rate FROM countries WHERE name = 'Greece';"
        ],
        "rule_sql": []
    },
    "2372": {
        "db_id": "superstore",
        "question": "Which item was shipped on 3/4/2013 and scheduled for same day delivery in the South region?",
        "ground_truth": "SELECT T2.`Product Name` FROM south_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.`Ship Date` = '2013-03-04' AND T2.Region = 'South' AND T1.`Order Date` = '2013-03-04'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT item_name FROM shipments WHERE ship_date = '3/4/2013' AND delivery_type = 'same day' AND region = 'South';"
        ],
        "rule_sql": []
    },
    "8695": {
        "db_id": "chicago_crime",
        "question": "What is the first name of the aldermen of wards with more than 50,000 inhabitants?",
        "ground_truth": "SELECT alderman_first_name FROM Ward WHERE Population > 50000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM aldermen WHERE ward_population > 50000 ORDER BY first_name LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2641": {
        "db_id": "regional_sales",
        "question": "What were the total orders of Medsep Group from 2018 to 2020?",
        "ground_truth": "SELECT SUM(CASE WHEN SUBSTR(T1.OrderDate, -2) IN ('18', '19', '20') AND T2.`Customer Names` = 'Medsep Group' THEN 1 ELSE 0 END) FROM `Sales Orders` AS T1 INNER JOIN Customers AS T2 ON T2.CustomerID = T1._CustomerID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(orders) FROM sales WHERE company = 'Medsep Group' AND year BETWEEN 2018 AND 2020"
        ],
        "rule_sql": []
    },
    "7562": {
        "db_id": "image_and_language",
        "question": "Which object in image 8 is the widest? State its object sample ID.",
        "ground_truth": "SELECT OBJ_SAMPLE_ID FROM IMG_OBJ WHERE IMG_ID = 8 ORDER BY W DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_sample_id FROM image_objects WHERE image_id = 8 ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9234": {
        "db_id": "movie_3",
        "question": "In films with a length duration of 113 minutes, how many of the films are starred by Kirk Jovovich?",
        "ground_truth": "SELECT COUNT(T1.actor_id) FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T3.length = 113 AND T1.first_name = 'Kirk' AND T1.last_name = 'Jovovich'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM films WHERE duration = 113 AND starring = 'Kirk Jovovich';"
        ],
        "rule_sql": []
    },
    "7581": {
        "db_id": "image_and_language",
        "question": "List the ID of all images with objects that have multiple relations.",
        "ground_truth": "SELECT IMG_ID FROM IMG_REL GROUP BY PRED_CLASS_ID HAVING COUNT(DISTINCT OBJ1_SAMPLE_ID) != 0 AND COUNT(DISTINCT OBJ2_SAMPLE_ID) != 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT image_id FROM objects WHERE COUNT(relation_id) > 1 GROUP BY image_id"
        ],
        "rule_sql": []
    },
    "7123": {
        "db_id": "works_cycles",
        "question": "What is the currency of Brazil?",
        "ground_truth": "SELECT T1.Name FROM Currency AS T1 INNER JOIN CountryRegionCurrency AS T2 ON T1.CurrencyCode = T2.CurrencyCode INNER JOIN CountryRegion AS T3 ON T2.CountryRegionCode = T3.CountryRegionCode WHERE T3.Name = 'Brazil'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT currency FROM countries WHERE name = 'Brazil';"
        ],
        "rule_sql": []
    },
    "9384": {
        "db_id": "movie_3",
        "question": "Provide the list of the longest movies. Arrange these titles in alphabetical order.",
        "ground_truth": "SELECT title FROM film WHERE length = ( SELECT MAX(length) FROM film )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies ORDER BY length DESC, title ASC;"
        ],
        "rule_sql": []
    },
    "932": {
        "db_id": "cs_semester",
        "question": "List the capability of research postgraduate students with an intellegence level of 4 and above.",
        "ground_truth": "SELECT T1.capability FROM RA AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T2.type = 'RPG' AND T2.intelligence >= 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE student_type = 'research postgraduate' AND intelligence_level >= 4;"
        ],
        "rule_sql": []
    },
    "549": {
        "db_id": "movies_4",
        "question": "How many movies were produced in Canada?",
        "ground_truth": "SELECT COUNT(T2.movie_id) FROM COUNTry AS T1 INNER JOIN production_COUNTry AS T2 ON T1.COUNTry_id = T2.COUNTry_id WHERE T1.COUNTry_name = 'Canada'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE country = 'Canada';"
        ],
        "rule_sql": []
    },
    "7099": {
        "db_id": "works_cycles",
        "question": "What type of transaction was made with the only yellow product, size 62 and with a minimum inventory stock of 500 units?",
        "ground_truth": "SELECT DISTINCT T2.TransactionType FROM Product AS T1 INNER JOIN TransactionHistory AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Size = 62 AND T1.Color = 'Yellow' AND T1.SafetyStockLevel = 500",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT transaction_type FROM transactions t JOIN products p ON t.product_id = p.product_id WHERE p.color = 'yellow' AND p.size = 62 AND p.inventory_stock = 500;"
        ],
        "rule_sql": []
    },
    "4443": {
        "db_id": "student_loan",
        "question": "How many students are disabled?",
        "ground_truth": "SELECT COUNT(name) FROM disabled",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE status = 'disabled';"
        ],
        "rule_sql": []
    },
    "4191": {
        "db_id": "simpson_episodes",
        "question": "List the name of persons who were not included in the credit for the 'How the Test Was Won' episode.",
        "ground_truth": "SELECT T2.person FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'How the Test Was Won' AND T2.credited = 'false';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM persons p\nJOIN credits c ON p.id = c.person_id\nJOIN episodes e ON c.episode_id = e.id\nWHERE e.title = 'How the Test Was Won';"
        ],
        "rule_sql": []
    },
    "1152": {
        "db_id": "talkingdata",
        "question": "Please list the models of all the devices with an event under the location coordinates (121, 31).",
        "ground_truth": "SELECT T2.device_model FROM events AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T1.longitude = 121 AND T1.latitude = 31",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT model FROM devices WHERE location_x = 121 AND location_y = 31"
        ],
        "rule_sql": []
    },
    "5152": {
        "db_id": "address",
        "question": "Provide the alias and elevation of the city with zip code 1028.",
        "ground_truth": "SELECT T1.alias, T2.elevation FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.zip_code = 1028",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, elevation FROM cities WHERE zip_code = 1028;"
        ],
        "rule_sql": []
    },
    "7655": {
        "db_id": "hockey",
        "question": "Among the people who got into the Hall of Fame after the year 1980, how many of them belong to the category of \"Player\"?",
        "ground_truth": "SELECT COUNT(hofID) FROM HOF WHERE year > 1980 AND category = 'Player'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM HallOfFame \nWHERE year > 1980 AND category = 'Player';"
        ],
        "rule_sql": []
    },
    "136": {
        "db_id": "movie_platform",
        "question": "Give the percentage of subscribers who rated who rated the movie \"G.I. Jane\".",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.user_subscriber = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists_users AS T3 ON T1.user_id = T3.user_id WHERE T2.movie_title = 'G.I. Jane'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(DISTINCT subscriber_id) * 100.0 / (SELECT COUNT(*) FROM subscribers)) AS percentage\nFROM ratings\nWHERE movie_title = 'G.I. Jane';"
        ],
        "rule_sql": []
    },
    "7802": {
        "db_id": "hockey",
        "question": "State the player ID of player with average height of 75.",
        "ground_truth": "SELECT DISTINCT playerID FROM Master GROUP BY playerID HAVING AVG(height) = 75",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id FROM players WHERE height = 75;"
        ],
        "rule_sql": []
    },
    "1425": {
        "db_id": "synthea",
        "question": "Who had to take Clopidogrel 75 MG Oral Tablet for over 10 years?",
        "ground_truth": "SELECT T1.first, T1.last FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Clopidogrel 75 MG Oral Tablet' AND strftime('%Y', T2.STOP) - strftime('%Y', T2.START) > 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_name FROM medications WHERE drug_name = 'Clopidogrel 75 MG Oral Tablet' AND duration_years > 10;"
        ],
        "rule_sql": []
    },
    "4516": {
        "db_id": "student_loan",
        "question": "What is the percentage difference between the attendence of disabled and non-disable students? Do the disable students show better attendance than non-disable students?",
        "ground_truth": "SELECT CAST((SUM(IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)) - SUM(IIF(T2.name IS NULL AND T1.month = 0, 1, 0))) AS REAL) * 100 / COUNT(T1.name), IIF(SUM(IIF(T2.name IS NOT NULL AND T1.month = 0, 1, 0)) - SUM(IIF(T2.name IS NULL AND T1.month = 0, 1, 0)) > 0, 'YES', 'NO') AS isHigh FROM longest_absense_from_school AS T1 LEFT JOIN disabled AS T2 ON T2.name = T1.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT AVG(attendance) FROM students WHERE disabled = 1) AS disabled_attendance,\n    (SELECT AVG(attendance) FROM students WHERE disabled = 0) AS non_disabled_attendance,\n    CASE \n        WHEN (SELECT AVG(attendance) FROM students WHERE disabled = 1) > (SELECT AVG(attendance) FROM students WHERE disabled = 0) \n        THEN 'Yes' \n        ELSE 'No' \n    END AS disabled_better_attendance"
        ],
        "rule_sql": []
    },
    "3254": {
        "db_id": "donor",
        "question": "How many donations were paid via credit card to Memphis City School District?",
        "ground_truth": "SELECT COUNT(T1.projectid) FROM donations AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.payment_method = 'creditcard' AND T2.school_district = 'Memphis City School District'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM donations WHERE payment_method = 'credit card' AND recipient = 'Memphis City School District';"
        ],
        "rule_sql": []
    },
    "5031": {
        "db_id": "olympics",
        "question": "What is the average age of competitors who participated in 1988 Winter?",
        "ground_truth": "SELECT AVG(T2.age) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '1988 Winter'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM competitors WHERE year = 1988 AND season = 'Winter';"
        ],
        "rule_sql": []
    },
    "5481": {
        "db_id": "menu",
        "question": "Please list the names of all the dishes that appeared on the menu \"Zentral Theater Terrace\".",
        "ground_truth": "SELECT T4.name FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T3.name = 'Zentral Theater Terrace'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name FROM menu_dishes WHERE menu_name = 'Zentral Theater Terrace';"
        ],
        "rule_sql": []
    },
    "5709": {
        "db_id": "language_corpus",
        "question": "Among the title with single digit word count, list down 5 revision page ID of these titles.",
        "ground_truth": "SELECT revision FROM pages WHERE words < 10 LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT page_id FROM page WHERE LENGTH(title) = 1 LIMIT 5;"
        ],
        "rule_sql": []
    },
    "4371": {
        "db_id": "student_loan",
        "question": "Among the students that have been absent from school for more than 5 months, how many of them are male?",
        "ground_truth": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN male AS T2 ON T1.`name` = T2.`name` WHERE T1.`month` >= 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND absences > 5;"
        ],
        "rule_sql": []
    },
    "1159": {
        "db_id": "talkingdata",
        "question": "What is the average age of the female users who uses a vivo device?",
        "ground_truth": "SELECT AVG(T1.age) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.phone_brand = 'vivo' AND T1.gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM users WHERE gender = 'male' AND device = 'vivo';"
        ],
        "rule_sql": []
    },
    "239": {
        "db_id": "book_publishing_company",
        "question": "Name the top five titles that sold more than average and list them in descending order of the number of sales in California stores?",
        "ground_truth": "SELECT T1.title FROM titles AS T1 INNER JOIN sales AS T2 ON T1.title_id = T2.title_id INNER JOIN publishers AS T3 ON T1.pub_id = T3.pub_id WHERE T2.qty > ( SELECT CAST(SUM(qty) AS REAL) / COUNT(title_id) FROM sales ) AND T3.state = 'CA' ORDER BY T2.qty DESC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, COUNT(*) as sales_count\nFROM sales\nWHERE state = 'California'\nGROUP BY title\nHAVING COUNT(*) > (SELECT AVG(sales_count) FROM (SELECT COUNT(*) as sales_count FROM sales WHERE state = 'California' GROUP BY title))\nORDER BY sales_count DESC\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "2238": {
        "db_id": "world_development_indicators",
        "question": "What is the note for Australia on the indicator SP.ADO.TFRT?",
        "ground_truth": "SELECT T2.Description FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.Seriescode = 'SP.ADO.TFRT' AND T1.ShortName = 'Australia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT note FROM indicators WHERE country = 'Australia' AND indicator_code = 'SP.ADO.TFRT';"
        ],
        "rule_sql": []
    },
    "1728": {
        "db_id": "restaurant",
        "question": "List all the streets with more than 10 restaurants in Alameda county.",
        "ground_truth": "SELECT T2.street_name FROM geographic AS T1 INNER JOIN location AS T2 ON T1.city = T2.city WHERE T1.county = 'alameda county' GROUP BY T2.street_name HAVING COUNT(T2.id_restaurant) > 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT street, COUNT(*) as restaurant_count \nFROM restaurants \nWHERE county = 'Alameda' \nGROUP BY street \nHAVING restaurant_count > 10;"
        ],
        "rule_sql": []
    },
    "4541": {
        "db_id": "student_loan",
        "question": "How many disabled students are male?",
        "ground_truth": "SELECT COUNT(T1.name) FROM male AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND status = 'enabled';"
        ],
        "rule_sql": []
    },
    "6686": {
        "db_id": "retails",
        "question": "Among the orders made by customers in Germany, which one of them has the highest priority in delivery? Please give its order key.",
        "ground_truth": "SELECT T3.o_orderkey FROM nation AS T1 INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN orders AS T3 ON T2.c_custkey = T3.o_custkey WHERE T1.n_name = 'GERMANY' ORDER BY T3.o_orderdate LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT o_orderkey FROM orders WHERE c_nationkey = (SELECT n_nationkey FROM nation WHERE n_name = 'GERMANY') ORDER BY o_orderpriority DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1186": {
        "db_id": "talkingdata",
        "question": "How many labels belong to the game-card category?",
        "ground_truth": "SELECT COUNT(label_id) FROM label_categories WHERE category = 'game-card'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM labels WHERE category = 'game-card';"
        ],
        "rule_sql": []
    },
    "6947": {
        "db_id": "ice_hockey_draft",
        "question": "Identify the name and position of the player who has committed the most rule violations.",
        "ground_truth": "SELECT T2.PlayerName, T2.position_info FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.PIM = ( SELECT MAX(PIM) FROM SeasonStatus )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, position, COUNT(*) as violations \nFROM players \nJOIN violations ON players.player_id = violations.player_id \nGROUP BY players.player_id \nORDER BY violations DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8540": {
        "db_id": "software_company",
        "question": "List the occupation and income of male customers with an level of education of 4 to 6.",
        "ground_truth": "SELECT T1.OCCUPATION, T2.INCOME_K FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T1.EDUCATIONNUM >= 4 AND T1.EDUCATIONNUM <= 6 AND T1.SEX = 'Male'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT occupation, income FROM customers WHERE gender = 'male' AND education_level BETWEEN 4 AND 6"
        ],
        "rule_sql": []
    },
    "2304": {
        "db_id": "movielens",
        "question": "Please list the actor IDs whose movies have the newest published date.",
        "ground_truth": "SELECT T1.actorid FROM movies2actors AS T1 INNER JOIN movies AS T2 ON T1.movieid = T2.movieid WHERE T2.year = 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_id FROM movies ORDER BY published_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6098": {
        "db_id": "books",
        "question": "How many books were published by Brava in 2006?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Brava' AND STRFTIME('%Y', T1.publication_date) = '2006'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE publisher = 'Brava' AND year = 2006;"
        ],
        "rule_sql": []
    },
    "3977": {
        "db_id": "public_review_platform",
        "question": "Under the attribute name of \"music_playlist\", describe the attribute ID, business ID, city and inactive status.",
        "ground_truth": "SELECT T1.attribute_id, T2.business_id, T3.city FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.attribute_name = 'music_playlist' AND T3.active = 'false'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT music_playlist, attribute_ID, business_ID, city, inactive_status FROM music_playlist_table"
        ],
        "rule_sql": []
    },
    "8023": {
        "db_id": "university",
        "question": "What is the student population of the university that scored 98 in 2013?",
        "ground_truth": "SELECT SUM(T1.num_students) FROM university_year AS T1 INNER JOIN university_ranking_year AS T2 ON T1.university_id = T2.university_id WHERE T2.score = 98 AND T1.year = 2013",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT population FROM universities WHERE score = 98 AND year = 2013;"
        ],
        "rule_sql": []
    },
    "4776": {
        "db_id": "legislator",
        "question": "What are the Facebook, Twitter and YouTube usernames of Adam Kinzinger?",
        "ground_truth": "SELECT T2.facebook FROM current AS T1 INNER JOIN `social-media` AS T2 ON T2.bioguide = T1.bioguide_id WHERE T1.official_full_name = 'Adam Kinzinger'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT facebook, twitter, youtube FROM politicians WHERE first_name = 'Adam' AND last_name = 'Kinzinger';"
        ],
        "rule_sql": []
    },
    "1555": {
        "db_id": "car_retails",
        "question": "Which of the customers, whose Tokyo-based sales representative reports to the Vice President of Sales whose employee number is 1056, has paid the highest payment? List the customer's name, the contact person and calculate the total amount of that customer's total payments.",
        "ground_truth": "SELECT T2.customerName, T2.contactFirstName, T2.contactLastName, SUM(T3.amount) FROM employees AS T1 INNER JOIN customers AS T2 ON T2.salesRepEmployeeNumber = T1.employeeNumber INNER JOIN payments AS T3 ON T2.customerNumber = T3.customerNumber INNER JOIN offices AS T4 ON T1.officeCode = T4.officeCode WHERE T4.city = 'Tokyo' AND T1.reportsTo = 1056 GROUP BY T2.customerName, T2.contactFirstName, T2.contactLastName ORDER BY amount DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.customerName, c.contactFirstName || ' ' || c.contactLastName AS contactPerson, SUM(p.amount) AS totalPayments\nFROM customers c\nJOIN employees e ON c.salesRepEmployeeNumber = e.employeeNumber\nJOIN payments p ON c.customerNumber = p.customerNumber\nWHERE e.officeCode = 'Tokyo' \nAND e.reportsTo = 1056\nGROUP BY c.customerNumber\nORDER BY totalPayments DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1719": {
        "db_id": "restaurant",
        "question": "What is the percentage of restaurants in the Bay Area region that scored over 4 for the review rating?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.review > 4, 1, 0)) AS REAL) * 100 / COUNT(T2.id_restaurant) FROM geographic AS T1 RIGHT JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T1.region = 'bay area'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM restaurants WHERE region = 'Bay Area')) AS percentage\nFROM restaurants \nWHERE region = 'Bay Area' AND review_rating > 4;"
        ],
        "rule_sql": []
    },
    "3778": {
        "db_id": "public_review_platform",
        "question": "State the number of actively running Yelp businesses in \"Tolleson\".",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE city LIKE 'Tolleson' AND active LIKE 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Tolleson' AND is_open = 1"
        ],
        "rule_sql": []
    },
    "1148": {
        "db_id": "talkingdata",
        "question": "What are the categories that app user ID7324884708820020000 belongs to?",
        "ground_truth": "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE T2.app_id = 7324884708820020000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM users WHERE user_id = 'ID7324884708820020000';"
        ],
        "rule_sql": []
    },
    "2154": {
        "db_id": "world_development_indicators",
        "question": "List out the series code and country code of the poor countries that located in Latin American & Carribbean.",
        "ground_truth": "SELECT T2.SeriesCode, T2.CountryCode FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T1.Region = 'Latin America & Caribbean' AND t1.incomegroup = 'Low income'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT series_code, country_code FROM countries WHERE region = 'Latin American & Carribbean' AND gdp_per_capita > 10000;"
        ],
        "rule_sql": []
    },
    "5666": {
        "db_id": "shipping",
        "question": "Among the shipments shipped to Cicero, Illinois, how many shipments weighed between 9,000 to 15,000?",
        "ground_truth": "SELECT COUNT(*) FROM shipment AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.city_id WHERE T2.city_name = 'Cicero' AND T2.state = 'Illinois' AND T1.weight BETWEEN 9000 AND 15000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE destination_city = 'Cicero' AND destination_state = 'Illinois' AND weight BETWEEN 9000 AND 15000;"
        ],
        "rule_sql": []
    },
    "1317": {
        "db_id": "law_episode",
        "question": "Write down the title, summary, and air date of the episode that garnered 72 10-star votes.",
        "ground_truth": "SELECT T2.title, T2.summary, T2.air_date FROM Vote AS T1 INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id WHERE T1.stars = 10 AND T1.votes = 72",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, summary, air_date FROM episodes WHERE votes = 72 AND star_rating = 10;"
        ],
        "rule_sql": []
    },
    "5254": {
        "db_id": "beer_factory",
        "question": "State the coordinate of Sac State American River Courtyard.",
        "ground_truth": "SELECT T2.Latitude, T2.Longitude FROM location AS T1 INNER JOIN geolocation AS T2 ON T1.LocationID = T2.LocationID WHERE T1.LocationName = 'Sac State American River Courtyard'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude, longitude FROM locations WHERE name = 'Sac State American River Courtyard';"
        ],
        "rule_sql": []
    },
    "548": {
        "db_id": "movies_4",
        "question": "Provide the titles and revenues of the movies produced by the DreamWorks company.",
        "ground_truth": "SELECT T1.title, T1.revenue FROM movie AS T1 INNER JOIN movie_company AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_company AS T3 ON T2.company_id = T3.company_id WHERE T3.company_name = 'DreamWorks'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, revenue FROM movies WHERE company = 'DreamWorks';"
        ],
        "rule_sql": []
    },
    "2774": {
        "db_id": "european_football_1",
        "question": "For a game had a score of 1-8 in the year of 2011, what division was that game in? Give the full name of the division.",
        "ground_truth": "SELECT T2.division, T2.name FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.season = 2011 AND T1.FTHG = 1 AND T1.FTAG = 8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT division FROM games WHERE score = '1-8' AND year = 2011;"
        ],
        "rule_sql": []
    },
    "5995": {
        "db_id": "books",
        "question": "Which language is the rarest among all the books?",
        "ground_truth": "SELECT T2.language_name FROM book AS T1 INNER JOIN book_language AS T2 ON T1.language_id = T2.language_id GROUP BY T2.language_name ORDER BY COUNT(T2.language_name) ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, COUNT(*) as count FROM books GROUP BY language ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1627": {
        "db_id": "car_retails",
        "question": "Please list all the customers that have Steve Patterson as their sales representitive.",
        "ground_truth": "SELECT t1.customerName FROM customers AS t1 INNER JOIN employees AS t2 ON t1.salesRepEmployeeNumber = t2.employeeNumber WHERE t2.firstName = 'Steve' AND t2.lastName = 'Patterson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM customers WHERE sales_representative = 'Steve Patterson';"
        ],
        "rule_sql": []
    },
    "330": {
        "db_id": "retail_complains",
        "question": "List the full names of all clients who live in the Pacific division.",
        "ground_truth": "SELECT T2.first, T2.middle, T2.last FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.division = 'Pacific'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE division = 'Pacific';"
        ],
        "rule_sql": []
    },
    "332": {
        "db_id": "retail_complains",
        "question": "Which is the city where most of the 1 star reviews come from?",
        "ground_truth": "SELECT T2.city FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.Stars = 1 GROUP BY T2.city ORDER BY COUNT(T2.city) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as review_count \nFROM reviews \nWHERE rating = 1 \nGROUP BY city \nORDER BY review_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1681": {
        "db_id": "restaurant",
        "question": "In which counties are there A&W Root Beer Restaurants?",
        "ground_truth": "SELECT DISTINCT T2.county FROM generalinfo AS T1 INNER JOIN geographic AS T2 ON T1.city = T2.city WHERE T1.label = 'a & w root beer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county FROM restaurants WHERE name = 'A&W Root Beer'"
        ],
        "rule_sql": []
    },
    "5803": {
        "db_id": "language_corpus",
        "question": "How many biword pairs contain the word \"base\" as the second word?",
        "ground_truth": "SELECT COUNT(w1st) FROM biwords WHERE w2nd = ( SELECT wid FROM words WHERE word = 'base' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM biword_pairs WHERE word2 = 'base';"
        ],
        "rule_sql": []
    },
    "1611": {
        "db_id": "car_retails",
        "question": "Where's Foon Yue Tseng's office located at? Give the detailed address.",
        "ground_truth": "SELECT T1.addressLine1, T1.addressLine2 FROM offices AS T1 INNER JOIN employees AS T2 ON T1.officeCode = T2.officeCode WHERE T2.firstName = 'Foon Yue' AND T2.lastName = 'Tseng'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT office_address FROM employees WHERE first_name = 'Foon' AND last_name = 'Yue Tseng';"
        ],
        "rule_sql": []
    },
    "4608": {
        "db_id": "mental_health_survey",
        "question": "Give the number of users who took the \"mental health survey for 2018\".",
        "ground_truth": "SELECT COUNT(DISTINCT T1.UserID) FROM Answer AS T1 INNER JOIN Survey AS T2 ON T1.SurveyID = T2.SurveyID WHERE T2.Description = 'mental health survey for 2018'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE survey_name = 'mental health survey for 2018';"
        ],
        "rule_sql": []
    },
    "3755": {
        "db_id": "college_completion",
        "question": "Among the Ivy League Schools in 2013, which schools have the highest number of Black students who graduated within 150 percent of normal/expected time who were seeking a bachelor's/equivalent cohort at 4-year institutions?",
        "ground_truth": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.chronname IN ( 'Brown University', 'Columbia University', 'Cornell University', 'Dartmouth College', 'Harvard University', 'Princeton University', 'University of Pennsylvania', 'Yale University' ) AND T2.year = 2013 AND T2.race = 'B' AND T2.cohort = '4y bach' ORDER BY T2.grad_cohort DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, MAX(black_graduates) as highest_black_graduates\nFROM ivy_league_schools\nWHERE year = 2013\nAND graduation_rate_within_150_percent > 100\nAND degree_type = 'bachelor'\nAND institution_type = '4-year'\nGROUP BY school_name\nORDER BY highest_black_graduates DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1848": {
        "db_id": "soccer_2016",
        "question": "Among the matches held in 2015, who is the winning team in the match ID 829768?",
        "ground_truth": "SELECT T2.Team_Name FROM Match AS T1 INNER JOIN Team AS T2 ON T2.Team_Id = T1.Match_Winner WHERE T1.Match_Date LIKE '2015%' AND T1.Match_Id = 829768",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE match_id = 829768 AND year = 2015"
        ],
        "rule_sql": []
    },
    "1805": {
        "db_id": "soccer_2016",
        "question": "Give the name of the youngest player.",
        "ground_truth": "SELECT Player_Name FROM Player ORDER BY DOB DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8330": {
        "db_id": "mondial_geo",
        "question": "State the name of the lake in Albania province and in which city does it located at.",
        "ground_truth": "SELECT Lake, City FROM located WHERE Province = 'Albania' AND Lake IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT lake.name, city.name \nFROM lake \nJOIN city ON lake.city_id = city.id \nWHERE lake.province = 'Albania';"
        ],
        "rule_sql": []
    },
    "4563": {
        "db_id": "student_loan",
        "question": "How many of the unemployed students are disabled?",
        "ground_truth": "SELECT COUNT(T1.name) FROM unemployed AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed' AND disability_status = 'disabled';"
        ],
        "rule_sql": []
    },
    "6916": {
        "db_id": "ice_hockey_draft",
        "question": "Please list the names of all the players with a height of over 6'2\" inches.",
        "ground_truth": "SELECT DISTINCT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T2.height_in_inch > '6''2\"'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE height > 6.2;"
        ],
        "rule_sql": []
    },
    "2432": {
        "db_id": "superstore",
        "question": "Who was the customer in the South Region superstore who bought the most \u201cHon Multipurpose Stacking Arm Chairs\"?",
        "ground_truth": "SELECT T2.`Customer Name` FROM south_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T1.`Product ID` WHERE T3.`Product Name` = 'Hon Multipurpose Stacking Arm Chairs' GROUP BY T2.`Customer Name` ORDER BY COUNT(T2.`Customer Name`) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Customer_Name, SUM(Quantity) as Total_Chairs\nFROM superstore\nWHERE Region = 'South' AND Product_Name = 'Hon Multipurpose Stacking Arm Chairs'\nGROUP BY Customer_Name\nORDER BY Total_Chairs DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "469": {
        "db_id": "movies_4",
        "question": "List the title of movies in Latin released between 1/01/1990 and 12/31/1995.",
        "ground_truth": "SELECT T1.title FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id WHERE T3.language_name = 'Latin' AND T1.release_date BETWEEN '1990-01-01' AND '1995-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE language = 'Latin' AND release_date BETWEEN '1995-12-31' AND '1990-01-01';"
        ],
        "rule_sql": []
    },
    "2198": {
        "db_id": "world_development_indicators",
        "question": "Please provide full name of any two countries using special trade system.",
        "ground_truth": "SELECT LongName FROM Country WHERE SystemOfTrade = 'Special trade system' LIMIT 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE trade_system = 'special' LIMIT 2;"
        ],
        "rule_sql": []
    },
    "5537": {
        "db_id": "menu",
        "question": "Under what events was the menu page's full width less than 2000 mm?",
        "ground_truth": "SELECT T1.event FROM Menu AS T1 INNER JOIN MenuPage AS T2 ON T1.id = T2.menu_id WHERE T2.full_width = 2000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_name FROM events WHERE menu_page_width < 2000;"
        ],
        "rule_sql": []
    },
    "5299": {
        "db_id": "beer_factory",
        "question": "In the female customers, how many bought root beer that contains artificial sweetener?",
        "ground_truth": "SELECT COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE T1.Gender = 'F' AND T4.ArtificialSweetener = 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN products p ON o.product_id = p.product_id WHERE c.gender = 'Female' AND p.name = 'Root Beer' AND p.ingredients LIKE '%sugar%';"
        ],
        "rule_sql": []
    },
    "5831": {
        "db_id": "airline",
        "question": "How many flights operated by American Airlines Inc. on 2018/8/1 were faster than scheduled?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.ACTUAL_ELAPSED_TIME < CRS_ELAPSED_TIME THEN 1 ELSE 0 END) AS count FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN `Air Carriers` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE T2.FL_DATE = '2018/8/1' AND T3.Description = 'American Airlines Inc.: AA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM flights f\nJOIN carriers c ON f.carrier = c.code\nWHERE c.description = 'American Airlines Inc.'\nAND f.year = 2018\nAND f.month = 8\nAND f.day = 1\nAND f.actual_elapsed_time > f.scheduled_elapsed_time"
        ],
        "rule_sql": []
    },
    "1476": {
        "db_id": "synthea",
        "question": "List out all the observation information collected for the patient named Bella Rolfson.",
        "ground_truth": "SELECT DISTINCT T2.DESCRIPTION, T2.VALUE, T2.UNITS FROM patients AS T1 INNER JOIN observations AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Bella' AND T1.last = 'Rolfson'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM observations WHERE patient_name = 'Bella Rolfson';"
        ],
        "rule_sql": []
    },
    "6271": {
        "db_id": "coinmarketcap",
        "question": "Please list the names of the crytocurrencies that have a total amount of existence of over 10000000 on 2013/4/28.",
        "ground_truth": "SELECT T1.name FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T2.date = '2013-04-28' AND T2.total_supply > 10000000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cryptocurrencies WHERE total_amount > 10000000 AND date = '2013/4/28';"
        ],
        "rule_sql": []
    },
    "3052": {
        "db_id": "shakespeare",
        "question": "What is the long title of the Shakespeare's work with Act 4 Scene 5 described as \"Mytilene. A street before the brothel.\"?",
        "ground_truth": "SELECT T1.LongTitle FROM works AS T1 RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T2.Description = 'Mytilene. A street before the brothel.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT long_title FROM shakespeare_works WHERE act = 4 AND scene = 5 AND description = 'Mytilene. A street before the brothel.'"
        ],
        "rule_sql": []
    },
    "2554": {
        "db_id": "app_store",
        "question": "What is the average review number for application with 5 rating?",
        "ground_truth": "SELECT AVG(Reviews) FROM playstore WHERE Rating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(review_number) FROM applications WHERE rating = 5;"
        ],
        "rule_sql": []
    },
    "8269": {
        "db_id": "mondial_geo",
        "question": "Where country does Baghdad belongs to?",
        "ground_truth": "SELECT Name FROM country WHERE Province = 'Baghdad'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cities WHERE name = 'Baghdad';"
        ],
        "rule_sql": []
    },
    "1506": {
        "db_id": "synthea",
        "question": "State the description of the reason why Angelo Buckridge needs the care plan.",
        "ground_truth": "SELECT DISTINCT T1.REASONDESCRIPTION FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.first = 'Angelo' AND T2.last = 'Buckridge'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT reason_description FROM care_plans WHERE patient_name = 'Angelo Buckridge'"
        ],
        "rule_sql": []
    },
    "384": {
        "db_id": "retail_complains",
        "question": "What is the percentage of complaints about the late fee issue whose priority is 2 in 2017?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.priority = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE strftime('%Y', T1.`Date received`) = '2017'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM complaints WHERE issue = 'late fee' AND strftime('%Y', date) = '2017')) AS percentage FROM complaints WHERE priority = 2 AND issue = 'late fee' AND strftime('%Y', date) = '2017';"
        ],
        "rule_sql": []
    },
    "5779": {
        "db_id": "language_corpus",
        "question": "How many times did the word \"grec\" occur on the page titled \"\u00c0bac\"?",
        "ground_truth": "SELECT T2.occurrences FROM words AS T1 INNER JOIN pages_words AS T2 ON T1.wid = T2.wid INNER JOIN pages AS T3 ON T2.pid = T3.pid WHERE T3.title = '\u00c0bac' AND T1.word = 'grec'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM pages WHERE title = '\u00c0bac' AND content LIKE '%grec%';"
        ],
        "rule_sql": []
    },
    "3595": {
        "db_id": "authors",
        "question": "Please list all of the associations that the authors of the paper \"FIBER: A Generalized Framework for Auto-tuning Software\" are affiliated with.",
        "ground_truth": "SELECT DISTINCT T2.Affiliation FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'FIBER: A Generalized Framework for Auto-tuning Software'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT a.affiliation_name \nFROM authors auth\nJOIN papers p ON auth.paper_id = p.paper_id\nJOIN affiliations a ON auth.author_id = a.author_id\nWHERE p.title = 'FIBER: A Generalized Framework for Auto-tuning Software';"
        ],
        "rule_sql": []
    },
    "5058": {
        "db_id": "olympics",
        "question": "List the name of competitors from Argentina.",
        "ground_truth": "SELECT T3.full_name FROM noc_region AS T1 INNER JOIN person_region AS T2 ON T1.id = T2.region_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.region_name = 'Argentina'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM competitors WHERE country = 'Argentina';"
        ],
        "rule_sql": []
    },
    "7378": {
        "db_id": "works_cycles",
        "question": "How many person have a projected yearly sales of no more than 50,000?",
        "ground_truth": "SELECT COUNT(BusinessEntityID) FROM SalesPersonQuotaHistory WHERE SalesQuota < 500000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM persons WHERE projected_yearly_sales > 50000"
        ],
        "rule_sql": []
    },
    "3027": {
        "db_id": "shakespeare",
        "question": "Calculate the percentage of paragraphs in all chapters of \"All's Well That Ends Well\".",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.Title = 'All''s Well That Ends Well', 1, 0)) AS REAL) * 100 / COUNT(T3.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM paragraphs)) AS percentage FROM paragraphs p JOIN chapters c ON p.chapter_id = c.chapter_id WHERE c.book_title = 'All''s Well That Ends Well'"
        ],
        "rule_sql": []
    },
    "946": {
        "db_id": "cs_semester",
        "question": "Name the students with above-average capability.",
        "ground_truth": "SELECT T1.f_name, T1.l_name FROM student AS T1 INNER JOIN RA AS T2 ON T1.student_id = T2.student_id WHERE T2.capability > ( SELECT AVG(capability) FROM RA )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE capability > (SELECT AVG(capability) FROM students);"
        ],
        "rule_sql": []
    },
    "8703": {
        "db_id": "chicago_crime",
        "question": "How many crimes described as 'The theft of a motor vehicle' by the FBI have taken place in the Lake View community?",
        "ground_truth": "SELECT SUM(CASE WHEN T3.community_area_name = 'Lake View' THEN 1 ELSE 0 END) FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T2.fbi_code_no = T1.fbi_code_no INNER JOIN Community_Area AS T3 ON T3.community_area_no = T2.community_area_no WHERE T1.description = 'The theft of a motor vehicle.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE description = 'The theft of a motor vehicle' AND community = 'Lake View';"
        ],
        "rule_sql": []
    },
    "1379": {
        "db_id": "synthea",
        "question": "Give the number of claims did Ms. Abbie Cole have in the year of 2011.",
        "ground_truth": "SELECT COUNT(T2.BILLABLEPERIOD) FROM patients AS T1 INNER JOIN claims AS T2 ON T1.patient = T2.PATIENT WHERE T1.prefix = 'Ms.' AND T1.first = 'Abbie' AND T1.last = 'Cole' AND T2.BILLABLEPERIOD BETWEEN '2010-12-31' AND '2012-01-01'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM claims WHERE claimant_name = 'Abbie Cole' AND year = 2011;"
        ],
        "rule_sql": []
    },
    "4128": {
        "db_id": "public_review_platform",
        "question": "What is the category and attributes of businesses with highest star rating?",
        "ground_truth": "SELECT DISTINCT T3.category_name, T5.attribute_name FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id INNER JOIN Business_Attributes AS T4 ON T2.business_id = T4.business_id INNER JOIN Attributes AS T5 ON T4.attribute_id = T5.attribute_id WHERE T1.stars = ( SELECT MAX(stars) FROM Business )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, attributes FROM businesses ORDER BY star_rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7644": {
        "db_id": "hockey",
        "question": "What is given name for player 'aebisda01'. Calculate the average time in minutes for the all his games played as goaltender.",
        "ground_truth": "SELECT T1.nameGiven, CAST(SUM(T2.Min) AS REAL) / SUM(T2.GP) FROM Master AS T1 INNER JOIN Goalies AS T2 ON T1.playerID = T2.playerID WHERE T1.playerID = 'aebisda01' GROUP BY T1.nameGiven",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT givenName, AVG(timeOnIce) as avg_time_minutes \nFROM players \nWHERE playerID = 'aebisda01' AND position = 'Goaltender';"
        ],
        "rule_sql": []
    },
    "8516": {
        "db_id": "software_company",
        "question": "Of the first 60,000 customers who sent a true response to the incentive mailing sent by the marketing department, how many of them are female?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID WHERE T1.SEX = 'Female' AND T2.RESPONSE = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers \nWHERE customer_id <= 60000 \nAND gender = 'female';"
        ],
        "rule_sql": []
    },
    "2450": {
        "db_id": "superstore",
        "question": "List the product's name bought by the customer named Bill Shonely from the Central region.",
        "ground_truth": "SELECT DISTINCT T3.`Product Name` FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T2.`Product ID` WHERE T1.`Customer Name` = 'Bill Shonely' AND T2.Region = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM products p\nJOIN orders o ON p.id = o.product_id\nJOIN customers c ON o.customer_id = c.id\nWHERE c.name = 'Bill Shonely' AND c.region = 'Central';"
        ],
        "rule_sql": []
    },
    "868": {
        "db_id": "cs_semester",
        "question": "Among the students who took the course Machine Learning Theory, how many of them are undergraduates?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.name = 'Machine Learning Theory' AND T1.type = 'UG'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM students s\nJOIN course_enrollments ce ON s.student_id = ce.student_id\nJOIN courses c ON ce.course_id = c.course_id\nWHERE c.course_name = 'Machine Learning Theory' \nAND s.student_level = 'undergraduate';"
        ],
        "rule_sql": []
    },
    "3731": {
        "db_id": "college_completion",
        "question": "List down the states in 2011 with a national sector average of 20 and below.",
        "ground_truth": "SELECT DISTINCT T1.state FROM state_sector_details AS T1 INNER JOIN state_sector_grads AS T2 ON T2.stateid = T1.stateid WHERE T2.year = 2011 AND T1.awards_per_natl_value <= 20",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM national_data WHERE year = 2011 AND sector_average > 20;"
        ],
        "rule_sql": []
    },
    "9260": {
        "db_id": "movie_3",
        "question": "Indicate the title of all the films rated as 'Adults Only'.",
        "ground_truth": "SELECT title FROM film WHERE rating = 'NC-17'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE rating = 'Adults Only';"
        ],
        "rule_sql": []
    },
    "4281": {
        "db_id": "simpson_episodes",
        "question": "What is the number of votes for 10-star for the episode that has the keyword \"reference to the fantastic four\"?",
        "ground_truth": "SELECT T2.votes FROM Keyword AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T2.stars = 10 AND T1.keyword = 'reference to the fantastic four';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE rating = 10 AND episode_id IN (SELECT episode_id FROM keywords WHERE keyword = 'reference to the fantastic four');"
        ],
        "rule_sql": []
    },
    "9081": {
        "db_id": "bike_share_1",
        "question": "List out all stations name that having a mean temperature 20 degree Celsius in year 2014.",
        "ground_truth": "SELECT DISTINCT T2.start_station_name, T2.end_station_name FROM weather AS T1 INNER JOIN trip AS T2 ON T1.zip_code = T2.zip_code WHERE T1.date LIKE '%2014' AND T1.mean_temperature_f = 20 * 1.8 + 32",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_name FROM temperature_data WHERE year = 2014 AND mean_temperature = 20;"
        ],
        "rule_sql": []
    },
    "7898": {
        "db_id": "world",
        "question": "What are the districts that belong to the country with the largest surface area?",
        "ground_truth": "SELECT T1.District FROM City AS T1 INNER JOIN Country AS T2 ON T1.CountryCode = T2.Code WHERE T2.Name = ( SELECT Name FROM Country ORDER BY SurfaceArea DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district FROM country WHERE surface_area = (SELECT MAX(surface_area) FROM country);"
        ],
        "rule_sql": []
    },
    "3213": {
        "db_id": "donor",
        "question": "Please list the resource names of project that teacher \"822b7b8768c17456fdce78b65abcc18e\" created.",
        "ground_truth": "SELECT T1.item_name FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.teacher_acctid = '822b7b8768c17456fdce78b65abcc18e'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT resource_name FROM projects WHERE teacher_id = '822b7b8768c17456fdce78b65abcc18e'"
        ],
        "rule_sql": []
    },
    "1968": {
        "db_id": "soccer_2016",
        "question": "How old is Ishan Kishan in 2022?",
        "ground_truth": "SELECT 2022 - SUBSTR(DOB, 1, 4) FROM Player WHERE Player_Name = 'Ishan Kishan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT 2022 - birth_year AS age FROM players WHERE name = 'Ishan Kishan';"
        ],
        "rule_sql": []
    },
    "8292": {
        "db_id": "mondial_geo",
        "question": "What is the area of the country which became independent in 1921/3/13?",
        "ground_truth": "SELECT T1.Area FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country WHERE T2.Independence = '1921-03-13'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area FROM countries WHERE independence_date = '1921/3/13';"
        ],
        "rule_sql": []
    },
    "9358": {
        "db_id": "movie_3",
        "question": "Calculate the total rental rate for animation film titles.",
        "ground_truth": "SELECT SUM(T1.rental_rate) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.`name` = 'Animation'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(rental_rate) FROM film WHERE genre = 'Animation';"
        ],
        "rule_sql": []
    },
    "4319": {
        "db_id": "simpson_episodes",
        "question": "List down the keyword and crew member's name for episode id S20-E1.",
        "ground_truth": "SELECT T1.keyword, T2.person FROM Keyword AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T1.episode_id = 'S20-E1';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword, crew_member_name FROM episodes WHERE episode_id = 'S20-E1'"
        ],
        "rule_sql": []
    },
    "5146": {
        "db_id": "address",
        "question": "How many zip codes are under Barre, VT?",
        "ground_truth": "SELECT COUNT(T2.zip_code) FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'Barre, VT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM zip_codes WHERE city = 'Barre' AND state = 'VT';"
        ],
        "rule_sql": []
    },
    "7718": {
        "db_id": "hockey",
        "question": "For the goalies whose weight are above 190, who had most goal againsts in 1978 season?",
        "ground_truth": "SELECT T1.playerID FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T1.year = '1978' AND T2.weight > 190 ORDER BY T1.GA DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.playerID, g.name, g.weight, SUM(gs.goalsAgainst) as total_goals_against\nFROM goalies g\nJOIN goalie_stats gs ON g.playerID = gs.playerID\nWHERE g.weight > 190 AND gs.season = 1978\nGROUP BY g.playerID, g.name, g.weight\nORDER BY total_goals_against ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "814": {
        "db_id": "social_media",
        "question": "What is the day of the week that tweet with ID tw-682712873332805633 was posted?",
        "ground_truth": "SELECT Weekday FROM twitter WHERE TweetID = 'tw-682712873332805633'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DAYNAME(created_at) FROM tweets WHERE id = 'tw-682712873332805633';"
        ],
        "rule_sql": []
    },
    "6776": {
        "db_id": "retails",
        "question": "What is the average discount for the parts made by Manufacturer#5?",
        "ground_truth": "SELECT AVG(T3.l_discount) FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN lineitem AS T3 ON T2.ps_suppkey = T3.l_suppkey WHERE T1.p_mfgr = 'Manufacturer#5'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(ps_supplycost) FROM partsupp WHERE p_mfgr = 'Manufacturer#5';"
        ],
        "rule_sql": []
    },
    "2993": {
        "db_id": "shakespeare",
        "question": "What is the description of the chapter with the longest number of paragraphs?",
        "ground_truth": "SELECT T2.Description FROM paragraphs AS T1 INNER JOIN chapters AS T2 ON T1.chapter_id = T2.id ORDER BY T1.ParagraphNum DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM chapters ORDER BY paragraph_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "587": {
        "db_id": "codebase_comments",
        "question": "What's the task of the method whose tokenized name is \"html parser feed\"?",
        "ground_truth": "SELECT SUBSTR(SUBSTR(Name, INSTR(Name, '.') + 1), 1, INSTR(SUBSTR(Name, INSTR(Name, '.') + 1), '.') - 1) task FROM Method WHERE NameTokenized = 'html parser feed'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT task FROM methods WHERE tokenized_name = 'html parser feed';"
        ],
        "rule_sql": []
    },
    "8598": {
        "db_id": "chicago_crime",
        "question": "Please list the case numbers of all the crimes with no arrest made in Central Chicago.",
        "ground_truth": "SELECT COUNT(*) FROM Crime AS T1 INNER JOIN District AS T2 ON T1.district_no = T2.district_no WHERE T2.district_name = 'Central' AND T1.arrest = 'FALSE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT case_number FROM crimes WHERE arrest_made = 'No' AND district = 'Central Chicago';"
        ],
        "rule_sql": []
    },
    "8903": {
        "db_id": "cookbook",
        "question": "Which ingredient appeared the most in recipes? Calculate its amount of appearance in percentage.",
        "ground_truth": "SELECT T1.name, CAST(COUNT(T2.ingredient_id) AS FLOAT) * 100 / ( SELECT COUNT(T2.ingredient_id) FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id ) AS \"percentage\" FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T2.ingredient_id = T1.ingredient_id GROUP BY T2.ingredient_id ORDER BY COUNT(T2.ingredient_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ingredient, COUNT(*) * 100.0 / (SELECT COUNT(*) FROM recipes) AS percentage\nFROM recipes\nGROUP BY ingredient\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "420": {
        "db_id": "movies_4",
        "question": "Among the movie in which Dariusz Wolski works as the director of photography, what is the percentage of those movie whose vote average is over 5.0?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.vote_average > 5 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.vote_average) FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T3.person_name = 'Dariusz Wolski' AND T2.job = 'Director of Photography'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN vote_average > 5.0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM movies m\nJOIN movie_crew mc ON m.movie_id = mc.movie_id\nWHERE mc.job = 'Director of Photography' \nAND mc.name = 'Dariusz Wolski'"
        ],
        "rule_sql": []
    },
    "6922": {
        "db_id": "ice_hockey_draft",
        "question": "Among the players that weigh more than 90 kg, what is the name of the player that has the most attendance in the player's first 7 years of NHL career?",
        "ground_truth": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T2.weight_in_kg > 90 AND T1.sum_7yr_GP = ( SELECT MAX(T1.sum_7yr_GP) FROM PlayerInfo AS T1 INNER JOIN weight_info AS T2 ON T1.weight = T2.weight_id WHERE T2.weight_in_kg > 90 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM players p\nJOIN attendance a ON p.player_id = a.player_id\nWHERE p.weight > 90\nGROUP BY p.player_id\nORDER BY COUNT(a.game_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4151": {
        "db_id": "citeseer",
        "question": "Name the paper which is cited most times and the paper which is cited least times? Also, find the number of times each one is cited.",
        "ground_truth": "SELECT cited_paper_id, COUNT(cited_paper_id), ( SELECT cited_paper_id FROM cites GROUP BY cited_paper_id ORDER BY COUNT(cited_paper_id) ASC LIMIT 1 ), ( SELECT COUNT(cited_paper_id) FROM cites GROUP BY cited_paper_id ORDER BY COUNT(cited_paper_id) ASC LIMIT 1 ) FROM cites GROUP BY cited_paper_id ORDER BY COUNT(cited_paper_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    p1.title AS most_cited_paper,\n    COUNT(c1.citing_paper_id) AS most_cited_count,\n    p2.title AS least_cited_paper,\n    COUNT(c2.citing_paper_id) AS least_cited_count\nFROM \n    papers p1\nJOIN \n    citations c1 ON p1.paper_id = c1.cited_paper_id\nJOIN \n    papers p2 ON p2.paper_id = c2.cited_paper_id\nJOIN \n    citations c2 ON p2.paper_id = c2.cited_paper_id\nGROUP BY \n    p1.paper_id, p2.paper_id\nORDER BY \n    most_cited_count DESC, least_cited_count ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5837": {
        "db_id": "airline",
        "question": "How many flights on average does American Airlines Inc. operate every day in August, 2018?",
        "ground_truth": "SELECT CAST( SUM(CASE WHEN T2.FL_DATE LIKE '2018/8%' THEN 1 ELSE 0 END) AS REAL) / 31 FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN INNER JOIN `Air Carriers` AS T3 ON T2.OP_CARRIER_AIRLINE_ID = T3.Code WHERE T3.Description = 'American Airlines Inc.: AA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) / 31 FROM flights WHERE carrier = 'American Airlines Inc.' AND month = 8 AND year = 2018"
        ],
        "rule_sql": []
    },
    "358": {
        "db_id": "retail_complains",
        "question": "Complaint about Credit Card mostly came from clients of which age group?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.age > 13 AND T1.age <= 19 THEN 1 ELSE 0 END), SUM(CASE WHEN T1.age > 19 AND T1.age <= 65 THEN 1 ELSE 0 END) AS adult , SUM(CASE WHEN T1.age > 65 THEN 1 ELSE 0 END) AS elder FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.Product = 'Credit card'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age_group, COUNT(*) as complaint_count \nFROM customers \nJOIN complaints ON customers.customer_id = complaints.customer_id \nWHERE complaint_type = 'Credit Card' \nGROUP BY age_group \nORDER BY complaint_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4935": {
        "db_id": "olympics",
        "question": "How many athletes in the database are from Guatemala?",
        "ground_truth": "SELECT COUNT(T1.person_id) FROM person_region AS T1 INNER JOIN noc_region AS T2 ON T1.region_id = T2.id WHERE T2.region_name = 'Guatemala'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM athletes WHERE country = 'Guatemala';"
        ],
        "rule_sql": []
    },
    "352": {
        "db_id": "retail_complains",
        "question": "State the full name of clients with server time of 20 minutes and above.",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE strftime('%M', T2.ser_time) > '20'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT client_name FROM clients WHERE server_time >= 20;"
        ],
        "rule_sql": []
    },
    "5769": {
        "db_id": "language_corpus",
        "question": "Calculate the average percentage of word appearance in the page that have revision page id smaller than 106680.",
        "ground_truth": "SELECT CAST(SUM(T1.words) AS REAL) * 100 / SUM(T2.occurrences) FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T1.revision < 106680",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(word_count / total_words * 100) AS average_percentage FROM pages WHERE revision_page_id < 106680;"
        ],
        "rule_sql": []
    },
    "8551": {
        "db_id": "software_company",
        "question": "List the geographic id of places where the income is above average.",
        "ground_truth": "SELECT AVG(INCOME_K) FROM Demog",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT geographic_id FROM places WHERE income > (SELECT AVG(income) FROM places);"
        ],
        "rule_sql": []
    },
    "6820": {
        "db_id": "retails",
        "question": "List all the dates of the urgent orders.",
        "ground_truth": "SELECT o_orderdate FROM orders WHERE o_orderpriority = '1-URGENT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_date FROM orders WHERE priority = 'urgent';"
        ],
        "rule_sql": []
    },
    "5999": {
        "db_id": "books",
        "question": "What are the books published by \"Harper Collins\"?",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'Harper Collins'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM books WHERE publisher = 'Penguin Random House';"
        ],
        "rule_sql": []
    },
    "8704": {
        "db_id": "chicago_crime",
        "question": "In which district have there been more intimidation-type crimes?",
        "ground_truth": "SELECT T3.district_name FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no WHERE T1.primary_description = 'INTIMIDATION' GROUP BY T3.district_name ORDER BY COUNT(T1.primary_description) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district, COUNT(*) as crime_count FROM crimes WHERE crime_type = 'intimidation' GROUP BY district ORDER BY crime_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9423": {
        "db_id": "movie_3",
        "question": "Among the times Mary Smith had rented a movie, how many of them happened in June, 2005?",
        "ground_truth": "SELECT COUNT(T1.customer_id) FROM payment AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.first_name = 'MARY' AND T2.last_name = 'SMITH' AND STRFTIME('%Y',T1.payment_date) = '2005' AND STRFTIME('%Y', T1.payment_date) = '6'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM rentals r\nJOIN customers c ON r.customer_id = c.customer_id\nWHERE c.first_name = 'Mary' AND c.last_name = 'Smith'\nAND r.rental_date LIKE '2005-06%';"
        ],
        "rule_sql": []
    },
    "5335": {
        "db_id": "beer_factory",
        "question": "What is the credit card type used by Kenneth Walton?",
        "ground_truth": "SELECT DISTINCT T2.CreditCardType FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.First = 'Kenneth' AND T1.Last = 'Walton'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_card_type FROM customers WHERE first_name = 'Kenneth' AND last_name = 'Walton';"
        ],
        "rule_sql": []
    },
    "1240": {
        "db_id": "talkingdata",
        "question": "List all females aged 24 to 26 devices' locations.",
        "ground_truth": "SELECT T2.longitude, T2.latitude FROM gender_age AS T1 INNER JOIN events_relevant AS T2 ON T1.device_id = T2.device_id WHERE T1.`group` = 'F24-26' AND T1.gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM devices WHERE gender = 'female' AND age BETWEEN 24 AND 26;"
        ],
        "rule_sql": []
    },
    "7856": {
        "db_id": "world",
        "question": "How many cities are in the Philippines?",
        "ground_truth": "SELECT COUNT(ID) FROM City WHERE Name = 'PHL'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE country = 'Philippines';"
        ],
        "rule_sql": []
    },
    "5030": {
        "db_id": "olympics",
        "question": "Who is the youngest competitor that participated in 2014 Winter?",
        "ground_truth": "SELECT T3.full_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '2014 Winter' ORDER BY T2.age LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM competitors WHERE year = 2014 AND season = 'Winter' ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5056": {
        "db_id": "olympics",
        "question": "How many competitors over the age of 30 participated in the 1992 Winter Olympics?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name = '1992 Winter' AND T2.age > 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM competitors WHERE age > 30 AND olympics = '1992 Winter Olympics';"
        ],
        "rule_sql": []
    },
    "2784": {
        "db_id": "european_football_1",
        "question": "Which team was the home team in the match of the Bundesliga division on 2020/10/2?",
        "ground_truth": "SELECT T1.HomeTeam FROM matchs AS T1 INNER JOIN divisions AS T2 ON T1.Div = T2.division WHERE T1.Date = '2020-10-02' AND T2.name = 'Bundesliga'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT home_team FROM matches WHERE division = 'Bundesliga' AND match_date = '2020-10-02';"
        ],
        "rule_sql": []
    },
    "9211": {
        "db_id": "movie_3",
        "question": "How many films in the horror category were included in PG-13-rated?",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Horror' AND T1.rating = 'PG-13'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film f \nJOIN film_category fc ON f.film_id = fc.film_id \nJOIN category c ON fc.category_id = c.category_id \nWHERE c.name = 'Horror' AND f.rating = 'PG-13';"
        ],
        "rule_sql": []
    },
    "6063": {
        "db_id": "books",
        "question": "Which book by Hirohiko Araki was published on 6/6/2006?",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'Hirohiko Araki' AND T1.publication_date = '2006-06-06'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE author = 'Hirohiko Araki' AND publication_date = '2006-06-06';"
        ],
        "rule_sql": []
    },
    "3764": {
        "db_id": "public_review_platform",
        "question": "How many \"bars\" are there in the Yelp business?",
        "ground_truth": "SELECT COUNT(T1.category_id) FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE T1.category_name LIKE 'Bars'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM business WHERE category = 'bars';"
        ],
        "rule_sql": []
    },
    "4276": {
        "db_id": "simpson_episodes",
        "question": "Please list all of the episodes that aired in 2008 that have the highest number of votes for the maximum star rating.",
        "ground_truth": "SELECT T1.episode_id FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE SUBSTR(T1.air_date, 1, 4) = '2008' ORDER BY T2.votes DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_title, air_date, votes, star_rating \nFROM episodes \nWHERE YEAR(air_date) = 2008 \nORDER BY star_rating DESC, votes DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6099": {
        "db_id": "books",
        "question": "Provide the ISBN and price of the book with book ID 7160.",
        "ground_truth": "SELECT T1.isbn13, T2.price FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T2.book_id = 6503",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT isbn, title FROM books WHERE book_id = 7160;"
        ],
        "rule_sql": []
    },
    "7831": {
        "db_id": "world",
        "question": "Among the languages used in Baltic Countries, provide the languages which are used by over 80%.\n\n",
        "ground_truth": "SELECT T2.Language FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Region = 'Baltic Countries' AND T2.Percentage > 80",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM languages WHERE country IN ('Lithuania', 'Latvia', 'Estonia') AND percentage > 80;"
        ],
        "rule_sql": []
    },
    "4589": {
        "db_id": "mental_health_survey",
        "question": "How many users lived in Canada according to 2018's survey?",
        "ground_truth": "SELECT COUNT(T2.UserID) FROM Question AS T1 INNER JOIN Answer AS T2 ON T1.questionid = T2.QuestionID WHERE T2.SurveyID = 2018 AND T1.questiontext = 'What country do you live in?' AND T2.AnswerText = 'Canada'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE country = 'Canada' AND survey_year = 2018;"
        ],
        "rule_sql": []
    },
    "9240": {
        "db_id": "movie_3",
        "question": "In films with rental rate of 4.99, list down the inventory ID of the films starred by Lucille Dee.",
        "ground_truth": "SELECT T4.inventory_id FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id INNER JOIN inventory AS T4 ON T3.film_id = T4.film_id WHERE T1.first_name = 'Lucille' AND T1.last_name = 'Dee' AND T3.rental_rate = 4.99",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inventory_id FROM films WHERE rental_rate = 4.99 AND actor_name = 'Lucille Dee'"
        ],
        "rule_sql": []
    },
    "5852": {
        "db_id": "airline",
        "question": "What is the percentage of flights which landed at Pittsburgh were faster than scheduled?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.ACTUAL_ELAPSED_TIME < T1.CRS_ELAPSED_TIME THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Airlines AS T1 INNER JOIN Airports AS T2 ON T2.Code = T1.DEST WHERE T2.Description LIKE '%Pittsburgh%' AND T1.CRS_ELAPSED_TIME IS NOT NULL AND T1.ACTUAL_ELAPSED_TIME IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN actual_time < scheduled_time THEN 1 END) * 100.0 / COUNT(*)) AS percentage_faster\nFROM flights\nWHERE destination = 'Pittsburgh';"
        ],
        "rule_sql": []
    },
    "4715": {
        "db_id": "disney",
        "question": "What genre of movie has Taran as the main character?",
        "ground_truth": "SELECT T1.genre FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title WHERE T2.hero = 'Taran'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM movies WHERE main_character = 'Taran';"
        ],
        "rule_sql": []
    },
    "5021": {
        "db_id": "olympics",
        "question": "How many Summer games are there that were held in Paris?",
        "ground_truth": "SELECT COUNT(T3.id) FROM games_city AS T1 INNER JOIN city AS T2 ON T1.city_id = T2.id INNER JOIN games AS T3 ON T1.games_id = T3.id WHERE T2.city_name = 'Paris' AND T3.season = 'Summer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE season = 'Summer' AND city = 'Paris';"
        ],
        "rule_sql": []
    },
    "6949": {
        "db_id": "ice_hockey_draft",
        "question": "Among all players drafted by the Toronto Maple Leafs, identify the percentage who are from Eastern Europe.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN nation IN ('Belarus', 'Czech Rep.', 'Slovakia', 'Ukraine') THEN ELITEID ELSE NULL END) AS REAL) * 100 / COUNT(ELITEID) FROM PlayerInfo WHERE overallby = 'Toronto Maple Leafs'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.nationality IN ('Russia', 'Czech Republic', 'Slovakia', 'Poland', 'Hungary', 'Romania', 'Bulgaria', 'Ukraine', 'Belarus') THEN 1 END) * 100.0 / COUNT(*)) AS percentage_eastern_europe\nFROM players p\nJOIN draft d ON p.player_id = d.player_id\nWHERE d.team = 'Toronto Maple Leafs';"
        ],
        "rule_sql": []
    },
    "3793": {
        "db_id": "public_review_platform",
        "question": "What is the average rating for the all Yelp businesses that open 24 hours?",
        "ground_truth": "SELECT CAST(SUM(T3.stars) AS REAL) / COUNT(T2.business_id) AS \"avg\" FROM Attributes AS T1 INNER JOIN Business_Attributes AS T2 ON T1.attribute_id = T2.attribute_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id WHERE T1.attribute_name LIKE 'Open 24 Hours' AND T2.attribute_value LIKE 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM businesses WHERE hours LIKE '%24 hours%';"
        ],
        "rule_sql": []
    },
    "3493": {
        "db_id": "video_games",
        "question": "What is the genre of the game ID 119?",
        "ground_truth": "SELECT T2.genre_name FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T1.id = 119",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre FROM games WHERE game_id = 119;"
        ],
        "rule_sql": []
    },
    "2588": {
        "db_id": "regional_sales",
        "question": "Sate the order number and calculate the net profit for each order under Joshua Bennett.",
        "ground_truth": "SELECT T1.OrderNumber , REPLACE(T1.`Unit Price`, ',', '') - REPLACE(T1.`Unit Cost`, ',', '')  FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T2.`Sales Team` = 'Joshua Bennett'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, (quantity * price) AS net_profit FROM orders WHERE customer_name = 'Joshua Bennett';"
        ],
        "rule_sql": []
    },
    "6276": {
        "db_id": "coinmarketcap",
        "question": "What was the percentage of the Bitcoins verifiably burned until 2018/4/28?",
        "ground_truth": "SELECT CAST((SUM(T2.max_supply) - SUM(T2.total_supply)) AS REAL) / SUM(T2.total_supply) FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T2.date < '2018-04-28' AND T1.name = 'Bitcoin'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (SUM(amount_burned) / (SELECT SUM(amount_mined) FROM bitcoin_mining)) * 100 AS percentage_burned FROM bitcoin_burns WHERE burn_date <= '2018-04-28';"
        ],
        "rule_sql": []
    },
    "430": {
        "db_id": "movies_4",
        "question": "How many producers does the movie \"The Amityville Horror\" have?",
        "ground_truth": "SELECT COUNT(T2.person_id) FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id WHERE T1.title = 'The Amityville Horror' AND T2.job = 'Producer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM movies WHERE title = 'The Amityville Horror';"
        ],
        "rule_sql": []
    },
    "1268": {
        "db_id": "law_episode",
        "question": "Display the number of 9-star votes the episode Sideshow received.",
        "ground_truth": "SELECT T2.votes FROM Episode AS T1 INNER JOIN Vote AS T2 ON T1.episode_id = T2.episode_id WHERE T2.stars = 9 AND T1.title = 'Sideshow'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE episode_name = 'Sideshow' AND rating = 9;"
        ],
        "rule_sql": []
    },
    "8469": {
        "db_id": "mondial_geo",
        "question": "Among the country member of 'IOC' organization, which country has the most population?",
        "ground_truth": "SELECT T2.Name FROM isMember AS T1 INNER JOIN country AS T2 ON T1.Country = T2.Code WHERE T1.Organization = 'IOC' ORDER BY T2.Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, MAX(population) FROM countries WHERE organization = 'IOC' GROUP BY country ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "844": {
        "db_id": "social_media",
        "question": "Among all the tweets with a positive sentiment, how many of them were posted by male users in Australia?",
        "ground_truth": "SELECT COUNT(T1.TweetID) FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID INNER JOIN user AS T3 ON T3.UserID = T1.UserID WHERE T2.Country = 'Australia' AND T3.Gender = 'Male' AND T1.Sentiment > 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM tweets t\nJOIN users u ON t.user_id = u.user_id\nWHERE t.sentiment = 'positive' \nAND u.gender = 'male' \nAND u.country = 'Australia';"
        ],
        "rule_sql": []
    },
    "4185": {
        "db_id": "simpson_episodes",
        "question": "How many crew have their own nickname? List their full name along with the nickname.",
        "ground_truth": "SELECT COUNT(name) FROM Person WHERE nickname IS NOT NULL;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, nickname FROM crew WHERE nickname IS NOT NULL"
        ],
        "rule_sql": []
    },
    "7883": {
        "db_id": "world",
        "question": "Within the 5 most crowded cities in the world, which country has the most languages used?",
        "ground_truth": "SELECT Name FROM ( SELECT T1.Name, T2.Language FROM City AS T1 INNER JOIN CountryLanguage AS T2 ON T1.CountryCode = T2.CountryCode GROUP BY T1.Name, T1.Population, T2.Language ORDER BY T1.Population DESC ) AS T3 GROUP BY t3.Name ORDER BY COUNT(Language) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Country, COUNT(Language) as LanguageCount \nFROM Cities \nJOIN Languages ON Cities.CityID = Languages.CityID \nWHERE Cities.PopulationRank <= 5 \nGROUP BY Country \nORDER BY LanguageCount DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2011": {
        "db_id": "soccer_2016",
        "question": "What is the venue name of Bandladore?",
        "ground_truth": "SELECT T1.Venue_Name FROM Venue AS T1 INNER JOIN City AS T2 ON T1.City_ID = T2.City_ID WHERE T2.City_Name = 'Bangalore'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue_name FROM venues WHERE band_name = 'Bandladore';"
        ],
        "rule_sql": []
    },
    "3616": {
        "db_id": "authors",
        "question": "What is the conference homepage URL of the paper titled \"Quality evaluation of long duration audiovisual content\"?",
        "ground_truth": "SELECT T2.HomePage FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE T1.Title = 'Quality evaluation of long duration audiovisual content'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT homepage FROM conferences WHERE paper_title = 'Quality evaluation of long duration audiovisual content';"
        ],
        "rule_sql": []
    },
    "329": {
        "db_id": "retail_complains",
        "question": "What is the most common issue for the highest priority complaints?",
        "ground_truth": "SELECT T1.Issue FROM events AS T1 INNER JOIN callcenterlogs AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.priority = 2 GROUP BY T1.Issue ORDER BY COUNT(T1.Issue) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT issue, COUNT(*) as count FROM complaints WHERE priority = 'highest' GROUP BY issue ORDER BY count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1981": {
        "db_id": "soccer_2016",
        "question": "Provide match ID which had the extra type of penalty.",
        "ground_truth": "SELECT T1.Match_Id FROM Extra_Runs AS T1 INNER JOIN Extra_Type AS T2 ON T1.Extra_Type_Id = T2.Extra_Id WHERE T2.Extra_Name = 'penalty'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT match_id FROM penalties WHERE penalty_type = 'extra'"
        ],
        "rule_sql": []
    },
    "7405": {
        "db_id": "works_cycles",
        "question": "What type of employee is David Bradley?",
        "ground_truth": "SELECT PersonType FROM Person WHERE FirstName = 'David' AND LastName = 'Bradley'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_type FROM employees WHERE first_name = 'David'"
        ],
        "rule_sql": []
    },
    "1673": {
        "db_id": "restaurant",
        "question": "List all the cities in Sonoma County.",
        "ground_truth": "SELECT city FROM geographic WHERE county = 'sonoma county'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cities WHERE county = 'Sonoma County';"
        ],
        "rule_sql": []
    },
    "8400": {
        "db_id": "mondial_geo",
        "question": "How many mountains are there in the United States?",
        "ground_truth": "SELECT COUNT(T1.Name) FROM mountain AS T1 INNER JOIN geo_mountain AS T2 ON T1.Name = T2.Mountain INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN country AS T4 ON T4.Province = T3.Name WHERE T4.Name = 'United States'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM mountains WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "4564": {
        "db_id": "student_loan",
        "question": "List the names of the disabled students who were absent from school for more than 5 months.",
        "ground_truth": "SELECT T1.name FROM longest_absense_from_school AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE T1.month > 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE disabled = 1 AND absence_months > 5;"
        ],
        "rule_sql": []
    },
    "4711": {
        "db_id": "disney",
        "question": "Which movie's song title has the highest total gross?",
        "ground_truth": "SELECT T2.song FROM movies_total_gross AS T1 INNER JOIN characters AS T2 ON T1.movie_title = T2.movie_title ORDER BY CAST(REPLACE(trim(T1.total_gross, '$'), ',', '') AS REAL) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title, s.song_title, MAX(m.gross) as highest_gross\nFROM movies m\nJOIN songs s ON m.movie_id = s.movie_id\nGROUP BY m.title, s.song_title\nORDER BY highest_gross DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7595": {
        "db_id": "image_and_language",
        "question": "Calculate the ratio of the total number of images with an object class of \"man\" and \"person\".",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.OBJ_CLASS = 'man' THEN 1 ELSE 0 END) AS REAL) / COUNT(CASE WHEN T2.OBJ_CLASS = 'person' THEN 1 ELSE 0 END) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE object_class = 'man' OR object_class = 'person';"
        ],
        "rule_sql": []
    },
    "8752": {
        "db_id": "chicago_crime",
        "question": "What is the FBI description of the crime for report number 23778?",
        "ground_truth": "SELECT T1.description FROM FBI_Code AS T1 INNER JOIN Crime AS T2 ON T1.fbi_code_no = T2.fbi_code_no WHERE T2.report_no = 23843",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM crimes WHERE report_number = 23778"
        ],
        "rule_sql": []
    },
    "2984": {
        "db_id": "shakespeare",
        "question": "Gives the average number of chapters in Shakespeare's 1599 work.",
        "ground_truth": "SELECT CAST(COUNT(T1.id) AS REAL) / COUNT(DISTINCT T2.id) FROM chapters AS T1 INNER JOIN works AS T2 ON T1.work_id = T2.id WHERE T2.Date = '1599'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(chapter_count) FROM shakespeare_works WHERE year = 1599;"
        ],
        "rule_sql": []
    },
    "414": {
        "db_id": "movies_4",
        "question": "Please list the names of all the crew members of the movie \"Pirates of the Caribbean: At World's End\".",
        "ground_truth": "SELECT T3.person_name FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T1.title LIKE 'Pirates of the Caribbean: At World%s End'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM crew WHERE movie_title = 'Pirates of the Caribbean: At World''s End'"
        ],
        "rule_sql": []
    },
    "267": {
        "db_id": "retail_complains",
        "question": "How many stars did \"Eagle Capital\" received from Little Rock on 2013/4/4?",
        "ground_truth": "SELECT COUNT(T1.Stars) FROM reviews AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.Product = 'Eagle Capital' AND T2.city = 'Little Rock' AND T1.Date = '2013-04-04'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE business_name = 'Eagle Capital' AND city = 'Little Rock' AND date = '2013/4/4';"
        ],
        "rule_sql": []
    },
    "6095": {
        "db_id": "books",
        "question": "What is the price of the book with ISBN 9780763628321?",
        "ground_truth": "SELECT T2.price FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.isbn13 = 9780763628321",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM books WHERE isbn = '9780763628321';"
        ],
        "rule_sql": []
    },
    "3796": {
        "db_id": "public_review_platform",
        "question": "How many active businesses of city are underrated?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE review_count LIKE 'Low' AND active LIKE 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'underrated' AND status = 'active';"
        ],
        "rule_sql": []
    },
    "7778": {
        "db_id": "hockey",
        "question": "In which year did the Montreal Canadiens have 49 penalty minutes in the Stanley Cup finals? Was it 1924, 1923 or 1918?",
        "ground_truth": "SELECT T1.year FROM Teams AS T1 INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.name = 'Montreal Canadiens' AND T2.PIM = 49",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year FROM stanley_cup_finals WHERE team = 'Montreal Canadiens' AND penalty_minutes = 49 AND year IN (1924, 1923, 1918);"
        ],
        "rule_sql": []
    },
    "7470": {
        "db_id": "works_cycles",
        "question": "List all the work orders that is related to the Down Tube.",
        "ground_truth": "SELECT T2.WorkOrderID FROM Product AS T1 INNER JOIN WorkOrder AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'Down Tube'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM work_orders WHERE tube_type = 'Down Tube';"
        ],
        "rule_sql": []
    },
    "2355": {
        "db_id": "superstore",
        "question": "What was the quantity of Xerox 1952 ordered by Aimee Bixby on 2014/9/10?",
        "ground_truth": "SELECT SUM(T2.Quantity) FROM people AS T1 INNER JOIN central_superstore AS T2 ON T1.`Customer ID` = T2.`Customer ID` INNER JOIN product AS T3 ON T3.`Product ID` = T2.`Product ID` WHERE T1.`Customer Name` = 'Aimee Bixby' AND T3.`Product Name` = 'Xerox 1952' AND T2.`Order Date` = '2014-09-10'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT quantity FROM orders WHERE customer_name = 'Aimee Bixby' AND product_name = 'Xerox 1952' AND order_date = '2014/9/10';"
        ],
        "rule_sql": []
    },
    "3775": {
        "db_id": "public_review_platform",
        "question": "What percentage more for the \"Women's Clothing\" Yelp businesses to \"Men's Clothing\"?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.category_name LIKE 'Women''s Clothing' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) - CAST(SUM(CASE WHEN T2.category_name LIKE 'Men''s Clothing' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.business_id) AS \"more percentage\" FROM Business_Categories AS T1 INNER JOIN Categories AS T2 ON T1.category_id = T2.category_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN category = 'Women\\'s Clothing' THEN 1 END) - COUNT(CASE WHEN category = 'Men\\'s Clothing' THEN 1 END)) \n    / COUNT(CASE WHEN category = 'Men\\'s Clothing' THEN 1 END) * 100 \n    AS percentage_more\nFROM yelp_businesses\nWHERE category IN ('Women\\'s Clothing', 'Men\\'s Clothing');"
        ],
        "rule_sql": []
    },
    "2383": {
        "db_id": "superstore",
        "question": "What product was ordered in the Central region on April 26, 2018, and shipped by April 27, 2018?",
        "ground_truth": "SELECT T2.`Product Name` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.`Order Date` = '2018-04-26' AND T1.`Ship Date` = '2018-04-27' AND T2.Region = 'Central'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name \nFROM orders \nWHERE region = 'Central' \nAND order_date = '2018-04-26' \nAND ship_date = '2018-04-27';"
        ],
        "rule_sql": []
    },
    "8062": {
        "db_id": "university",
        "question": "Provide the ranking system name for the \"Quality of Education Rank\" criteria.",
        "ground_truth": "SELECT T1.system_name FROM ranking_system AS T1 INNER JOIN ranking_criteria AS T2 ON T1.id = T2.ranking_system_id WHERE T2.criteria_name = 'Quality of Education Rank'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ranking_system FROM criteria WHERE criteria_name = 'Quality of Education Rank';"
        ],
        "rule_sql": []
    },
    "7443": {
        "db_id": "works_cycles",
        "question": "What is the product with the most profit?",
        "ground_truth": "SELECT T1.ProductID FROM ProductListPriceHistory AS T1 INNER JOIN ProductCostHistory AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.ListPrice - T2.StandardCost DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, MAX(profit) FROM products;"
        ],
        "rule_sql": []
    },
    "3285": {
        "db_id": "donor",
        "question": "What is the name of the vendors serving material for projects for grades 9-12?",
        "ground_truth": "SELECT DISTINCT T1.vendor_name FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.grade_level = 'Grades 9-12'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name FROM vendors WHERE grade_level BETWEEN 9 AND 12;"
        ],
        "rule_sql": []
    },
    "6204": {
        "db_id": "food_inspection_2",
        "question": "Calculate the average salary for employees who did inspection on License Re-Inspection.",
        "ground_truth": "SELECT AVG(T2.salary) FROM inspection AS T1 INNER JOIN employee AS T2 ON T1.employee_id = T2.employee_id WHERE T1.inspection_type = 'License Re-Inspection'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(salary) FROM employees WHERE inspection_type = 'License Re-Inspection';"
        ],
        "rule_sql": []
    },
    "8756": {
        "db_id": "chicago_crime",
        "question": "What is the ward ID of the most crowded ward?",
        "ground_truth": "SELECT ward_no FROM Ward ORDER BY Population DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ward_id FROM wards ORDER BY population DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6951": {
        "db_id": "ice_hockey_draft",
        "question": "Name the player and his team who made the playoffs in the 2006-2007 season of SuperElit league with the highest points.",
        "ground_truth": "SELECT T2.PlayerName, T1.TEAM FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '2006-2007' AND T1.GAMETYPE = 'Playoffs' AND T1.LEAGUE = 'SuperElit' ORDER BY T1.P DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, team_name \nFROM players \nWHERE season = '2006-2007' \nAND league = 'SuperElit' \nAND playoffs = 'yes' \nORDER BY points DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5623": {
        "db_id": "shipping",
        "question": "What is the average shipment weight carried by the oldest Mack?",
        "ground_truth": "SELECT AVG(T2.weight) FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T1.make = 'Mack'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(weight) FROM shipments WHERE truck_id = (SELECT MIN(id) FROM trucks WHERE make = 'Mack');"
        ],
        "rule_sql": []
    },
    "662": {
        "db_id": "codebase_comments",
        "question": "How many solutions are there whose respositories received the number of stars more than one third of the number of forks?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Id) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Stars > CAST(T1.Forks AS REAL) / 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM solutions s\nJOIN repositories r ON s.repository_id = r.id\nWHERE r.stars > (r.forks / 3);"
        ],
        "rule_sql": []
    },
    "9018": {
        "db_id": "bike_share_1",
        "question": "What is the average duration of bike trips in the city of Palo Alto?",
        "ground_truth": "SELECT AVG(T1.duration) FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'Palo Alto'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM bike_trips WHERE city = 'Palo Alto';"
        ],
        "rule_sql": []
    },
    "8419": {
        "db_id": "mondial_geo",
        "question": "On which continent is the country with the most erosion of real income?",
        "ground_truth": "SELECT T1.Name FROM continent AS T1 INNER JOIN encompasses AS T2 ON T1.Name = T2.Continent INNER JOIN country AS T3 ON T3.Code = T2.Country INNER JOIN economy AS T4 ON T4.Country = T3.Code ORDER BY T4.Inflation DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT continent FROM countries ORDER BY real_income_erosion DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4843": {
        "db_id": "legislator",
        "question": "Find the difference between the number of female senators and representatives born between 1930 to 1970.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.type = 'sen' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.type = 'rep' THEN 1 ELSE 0 END) FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.gender_bio = 'F' AND strftime('%Y', T1.birthday_bio) BETWEEN '1930' AND '1970'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM senators WHERE gender = 'F' AND birth_year BETWEEN 1930 AND 1970) - \n    (SELECT COUNT(*) FROM representatives WHERE gender = 'F' AND birth_year BETWEEN 1930 AND 1970) AS difference;"
        ],
        "rule_sql": []
    },
    "7171": {
        "db_id": "works_cycles",
        "question": "For person id No.2054, is his/her vendor still active?",
        "ground_truth": "SELECT T1.ActiveFlag FROM Vendor AS T1 INNER JOIN BusinessEntityContact AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.PersonID = 2054",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT active FROM vendors WHERE person_id = 2054;"
        ],
        "rule_sql": []
    },
    "7941": {
        "db_id": "music_platform_2",
        "question": "The 'More Stupider: A 90-Day Fiance Podcast' belongs to which category and what is the average rating of the podcast?",
        "ground_truth": "SELECT AVG(T3.rating) FROM categories AS T1 INNER JOIN podcasts AS T2 ON T2.podcast_id = T1.podcast_id INNER JOIN reviews AS T3 ON T3.podcast_id = T2.podcast_id WHERE T2.title = 'More Stupider: A 90-Day Fiance Podcast'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, AVG(rating) as average_rating FROM podcasts WHERE title = 'More Stupider: A 90-Day Fiance Podcast';"
        ],
        "rule_sql": []
    },
    "6981": {
        "db_id": "ice_hockey_draft",
        "question": "Among the players who played in OHL league during the regular season in 2007-2008, who is the player that attained the most number of assist?",
        "ground_truth": "SELECT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON = '2007-2008' AND T1.LEAGUE = 'OHL' AND T1.GAMETYPE = 'Regular Season' ORDER BY T1.A DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, MAX(goals) as most_assists \nFROM player_stats \nWHERE league = 'OHL' \nAND season = '2007-2008' \nAND game_type = 'regular' \nGROUP BY player_name \nORDER BY most_assists DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7146": {
        "db_id": "works_cycles",
        "question": "What is the Shift start time for Shift ID No.2?",
        "ground_truth": "SELECT StartTime FROM Shift WHERE ShiftID = '2'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT end_time FROM shifts WHERE shift_id = 2;"
        ],
        "rule_sql": []
    },
    "8552": {
        "db_id": "software_company",
        "question": "Calculate the number of customers who did not respond in February of 2007.",
        "ground_truth": "SELECT COUNT(REFID) custmoer_number FROM Mailings1_2 WHERE RESPONSE = 'false' AND REF_DATE BETWEEN '2007-02-01' AND '2007-02-28'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE response_date IS NULL AND EXTRACT(YEAR FROM response_date) = 2007 AND EXTRACT(MONTH FROM response_date) = 2;"
        ],
        "rule_sql": []
    },
    "67": {
        "db_id": "movie_platform",
        "question": "Please list all the critics made by the user rating the movie \"A Way of Life\".",
        "ground_truth": "SELECT T1.critic FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'A Way of Life'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM users WHERE movie_title = 'A Way of Life';"
        ],
        "rule_sql": []
    },
    "5145": {
        "db_id": "address",
        "question": "State the county for Arecibo City.",
        "ground_truth": "SELECT DISTINCT T1.county FROM country AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T2.city = 'Arecibo'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT county FROM cities WHERE city = 'Arecibo';"
        ],
        "rule_sql": []
    },
    "1549": {
        "db_id": "car_retails",
        "question": "Which sales representatives in New York city whose leader is Anthony Bow with the employee number is 1143? Indicate their employee numbers.",
        "ground_truth": "SELECT T1.employeeNumber FROM employees AS T1 INNER JOIN offices AS T2 ON T1.officeCode = T2.officeCode WHERE T1.reportsTo = 1143 AND T2.city = 'NYC'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT employee_number FROM sales_representatives WHERE city = 'New York' AND leader = 'Anthony Bow' AND employee_number = 1143;"
        ],
        "rule_sql": []
    },
    "4800": {
        "db_id": "legislator",
        "question": "List the IDs and full names of legislators from the Liberal Republican party.",
        "ground_truth": "SELECT T2.bioguide_id, T2.first_name, T2.last_name FROM `historical-terms` AS T1 INNER JOIN historical AS T2 ON T2.bioguide_id = T1.bioguide WHERE T1.party = 'Liberal Republican'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, first_name, last_name FROM legislators WHERE party = 'Liberal Republican'"
        ],
        "rule_sql": []
    },
    "951": {
        "db_id": "cs_semester",
        "question": "Give the full name and capability of students who failed in any courses.",
        "ground_truth": "SELECT T2.f_name, T2.l_name, T1.capability FROM RA AS T1 INNER JOIN student AS T2 ON T2.student_id = T1.student_id INNER JOIN registration AS T3 ON T2.student_id = T3.student_id WHERE T3.grade IS NULL OR T3.grade = ''",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.last_name, c.capability \nFROM students s\nJOIN courses c ON s.student_id = c.student_id\nWHERE c.grade >= 60;"
        ],
        "rule_sql": []
    },
    "2141": {
        "db_id": "world_development_indicators",
        "question": "From 1968 to 1970, what are indicator names whose license type is open and values are less than 100?",
        "ground_truth": "SELECT DISTINCT T1.IndicatorName FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName WHERE T1.Year >= 1968 AND T1.Year < 1971 AND T2.LicenseType = 'Open' AND T1.Value < 100",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT indicator_name FROM indicators WHERE license_type = 'open' AND value < 100 AND year BETWEEN 1968 AND 1970;"
        ],
        "rule_sql": []
    },
    "8260": {
        "db_id": "mondial_geo",
        "question": "How many organizations are established in the country with the most ethnic groups?",
        "ground_truth": "SELECT COUNT(T2.Province) FROM country AS T1 INNER JOIN organization AS T2 ON T1.Code = T2.Country INNER JOIN ethnicGroup AS T3 ON T3.Country = T2.Country GROUP BY T1.Name ORDER BY COUNT(T3.Name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM organizations WHERE country_id = (SELECT country_id FROM ethnic_groups GROUP BY country_id ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "1364": {
        "db_id": "synthea",
        "question": "For how long was Elly Koss required to take Acetaminophen?",
        "ground_truth": "SELECT strftime('%J', T2.STOP) - strftime('%J', T2.START) AS days FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Elly' AND T1.last = 'Koss' AND T2.description LIKE 'Acetaminophen%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT duration FROM medications WHERE patient_name = 'Elly Koss' AND medication_name = 'Acetaminophen';"
        ],
        "rule_sql": []
    },
    "803": {
        "db_id": "social_media",
        "question": "Show the text of the tweet with the highest klout from Connecticut.",
        "ground_truth": "SELECT T1.text FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T2.State = 'Connecticut' ORDER BY T1.Klout DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE state = 'Connecticut' ORDER BY klout DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9390": {
        "db_id": "movie_3",
        "question": "List all the cities that belong to United Arab Emirates.",
        "ground_truth": "SELECT T1.city FROM city AS T1 INNER JOIN country AS T2 ON T2.country_id = T1.country_id WHERE country = 'United Arab Emirates'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cities WHERE country = 'United Arab Emirates';"
        ],
        "rule_sql": []
    },
    "4601": {
        "db_id": "mental_health_survey",
        "question": "What answer did user No. 2681 give to the question \"Do you currently have a mental health disorder?\"?",
        "ground_truth": "SELECT T1.AnswerText FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questiontext = 'Do you currently have a mental health disorder?' AND T1.UserID = 2681",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT answer FROM user_responses WHERE user_id = 2681 AND question = 'Do you currently have a mental health disorder?'"
        ],
        "rule_sql": []
    },
    "7028": {
        "db_id": "works_cycles",
        "question": "What is the full name of the Document Control Manager who is in charge of all Level 1 approved documents?",
        "ground_truth": "SELECT T1.FirstName, T1.MiddleName, T1.LastName FROM Person AS T1 INNER JOIN Employee AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN Document AS T3 ON T3.Owner = T2.BusinessEntityID WHERE T2.JobTitle = 'Document Control Manager' AND T3.DocumentLevel = 1 AND T3.Status = 2 GROUP BY T1.FirstName, T1.MiddleName, T1.LastName",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name FROM employees WHERE job_title = 'Document Control Manager' AND document_level = 1;"
        ],
        "rule_sql": []
    },
    "7240": {
        "db_id": "works_cycles",
        "question": "What is the credit card number for the sales order \"45793\"?",
        "ground_truth": "SELECT T2.CardNumber FROM SalesOrderHeader AS T1 INNER JOIN CreditCard AS T2 ON T1.CreditCardID = T2.CreditCardID WHERE T1.SalesOrderID = 45793",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit_card_number FROM sales_orders WHERE order_id = '45793';"
        ],
        "rule_sql": []
    },
    "8087": {
        "db_id": "university",
        "question": "Give the id of \"Center for World University Rankings\".",
        "ground_truth": "SELECT id FROM ranking_system WHERE system_name = 'Center for World University Rankings'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM universities WHERE id = 'Center for World University Rankings';"
        ],
        "rule_sql": []
    },
    "4218": {
        "db_id": "simpson_episodes",
        "question": "Write down the award ID, award name and winner for character named \"Homer simpson 20\".",
        "ground_truth": "SELECT T1.award_id, T1.award, T1.person FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T2.character = 'Homer Simpson' AND T1.result = 'Winner';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT award_id, award_name, winner FROM awards WHERE character_name = 'Homer Simpson 20'"
        ],
        "rule_sql": []
    },
    "64": {
        "db_id": "movie_platform",
        "question": "What's the avatar image of the user who created the movie list \"250 Favourite Films\"?",
        "ground_truth": "SELECT T2.user_avatar_image_url FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE T1.list_title = '250 Favourite Films'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT avatar FROM users WHERE user_id = (SELECT user_id FROM movie_lists WHERE list_name = '250 Favourite Films');"
        ],
        "rule_sql": []
    },
    "1995": {
        "db_id": "soccer_2016",
        "question": "Provide the losing team's name in the match ID 336039.",
        "ground_truth": "SELECT Team_Name FROM Team WHERE Team_Id = ( SELECT CASE WHEN Team_1 = Match_Winner THEN Team_2 ELSE Team_1 END FROM Match WHERE match_id = 336039 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE match_id = 336039 AND result = 'loss';"
        ],
        "rule_sql": []
    },
    "3887": {
        "db_id": "public_review_platform",
        "question": "What is the category of businesses with highest star rating?",
        "ground_truth": "SELECT T3.category_name FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id ORDER BY T1.stars DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category, MAX(stars) FROM businesses GROUP BY category ORDER BY stars DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1119": {
        "db_id": "talkingdata",
        "question": "What is the phone brand of the device model \"\u575a\u679c\u624b\u673a\"?",
        "ground_truth": "SELECT phone_brand FROM phone_brand_device_model2 WHERE device_model = '\u575a\u679c\u624b\u673a'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM devices WHERE model = '\u575a\u679c\u624b\u673a';"
        ],
        "rule_sql": []
    },
    "5942": {
        "db_id": "books",
        "question": "What is the average number of pages of David Coward's books?",
        "ground_truth": "SELECT AVG(T1.num_pages) FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T3.author_name = 'David Coward'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(pages) FROM books WHERE author = 'David Coward';"
        ],
        "rule_sql": []
    },
    "4295": {
        "db_id": "simpson_episodes",
        "question": "List all of the award winners' birth dates.",
        "ground_truth": "SELECT T1.birthdate FROM Person AS T1 INNER JOIN Award AS T2 ON T1.name = T2.person WHERE T2.result = 'Winner';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT award_name, winner_name FROM awards WHERE birth_date IS NOT NULL;"
        ],
        "rule_sql": []
    },
    "3949": {
        "db_id": "public_review_platform",
        "question": "How many businesses accept insurance?",
        "ground_truth": "SELECT COUNT(T1.business_id) FROM Business_Attributes AS T1 INNER JOIN Attributes AS T2 ON T1.attribute_id = T2.attribute_id WHERE T2.attribute_name = 'Accepts Insurance' AND T1.attribute_value = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE insurance_accepted = 'no';"
        ],
        "rule_sql": []
    },
    "2121": {
        "db_id": "world_development_indicators",
        "question": "Find the countries in south Asia which are in the low-income group. What is the source of their recent income and expenditure data? List it alongside the table name of the countries.",
        "ground_truth": "SELECT TableName, SourceOfMostRecentIncomeAndExpenditureData FROM Country WHERE Region = 'South Asia' AND IncomeGroup = 'Low income'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.country_name, 'inc_exp_data' AS source_table, 'recent_income' AS data_type \nFROM countries c \nWHERE c.region = 'South Asia' \nAND c.income_group = 'Low income' \nUNION ALL\nSELECT c.country_name, 'inc_exp_data' AS source_table, 'recent_expenditure' AS data_type \nFROM countries c \nWHERE c.region = 'South Asia' \nAND c.income_group = 'Low income';"
        ],
        "rule_sql": []
    },
    "4175": {
        "db_id": "simpson_episodes",
        "question": "Name the title of the episode where Pamela Hayden voiced the character 'Ruthie.'",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id WHERE T2.person = 'Pamela Hayden' AND T2.role = 'Ruthie';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE character = 'Ruthie' AND voice_actor = 'Pamela Hayden'"
        ],
        "rule_sql": []
    },
    "2765": {
        "db_id": "european_football_1",
        "question": "How many football divisions does England have?",
        "ground_truth": "SELECT COUNT(division) FROM divisions WHERE country = 'England'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM divisions WHERE country = 'England' AND sport = 'football';"
        ],
        "rule_sql": []
    },
    "7237": {
        "db_id": "works_cycles",
        "question": "List all the names of products with the special offer \"15\".",
        "ground_truth": "SELECT T2.Name FROM SpecialOfferProduct AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T1.SpecialOfferID = 15",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM products WHERE special_offer = 15"
        ],
        "rule_sql": []
    },
    "7207": {
        "db_id": "works_cycles",
        "question": "How many types of credit cards are there and how many are vista?",
        "ground_truth": "SELECT COUNT(CardNumber) FROM CreditCard WHERE CardType = 'vista'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS total_types, COUNT(CASE WHEN card_type = 'vista' THEN 1 END) AS vista_count FROM credit_cards;"
        ],
        "rule_sql": []
    },
    "1438": {
        "db_id": "synthea",
        "question": "When the allergy starts for Angelo Buckridge.",
        "ground_truth": "SELECT T2.START FROM patients AS T1 INNER JOIN allergies AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Adolfo' AND T1.last = 'Schmitt' AND T2.STOP IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_date FROM allergies WHERE patient_name = 'Angelo Buckridge';"
        ],
        "rule_sql": []
    },
    "2914": {
        "db_id": "professional_basketball",
        "question": "From 1980 to 1983, how many of the NBA All-Star players have more than 60% three point rate?",
        "ground_truth": "SELECT DISTINCT T2.playerID FROM player_allstar AS T1 INNER JOIN players_teams AS T2 ON T1.playerID = T2.playerID WHERE T2.year BETWEEN 1980 AND 1983 AND T1.three_made / T1.three_attempted > 0.6",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM nba_all_star_players \nWHERE year BETWEEN 1980 AND 1983 \nAND three_point_rate > 60;"
        ],
        "rule_sql": []
    },
    "7767": {
        "db_id": "hockey",
        "question": "Please give the height of the tallest coach of the Montreal Canadiens.",
        "ground_truth": "SELECT T3.height FROM Coaches AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.name = 'Montreal Canadiens' AND T3.coachID IS NOT NULL ORDER BY T3.height DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(height) FROM coaches WHERE team = 'Montreal Canadiens';"
        ],
        "rule_sql": []
    },
    "5850": {
        "db_id": "airline",
        "question": "How many flights were there from San Diego International airport to Los Angeles International airport in the August of 2018?",
        "ground_truth": "SELECT COUNT(FL_DATE) FROM Airlines WHERE FL_DATE LIKE '2018/8%' AND ORIGIN = ( SELECT T2.ORIGIN FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T1.Description = 'San Diego, CA: San Diego International' ) AND DEST = ( SELECT T4.DEST FROM Airports AS T3 INNER JOIN Airlines AS T4 ON T3.Code = T4.DEST WHERE T3.Description = 'Los Angeles, CA: Los Angeles International' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM flights \nWHERE origin = 'San Diego International' \nAND destination = 'Los Angeles International' \nAND strftime('%Y-%m', date) = '2018-08';"
        ],
        "rule_sql": []
    },
    "7492": {
        "db_id": "image_and_language",
        "question": "How many object classes are there in the database?",
        "ground_truth": "SELECT COUNT(OBJ_CLASS_ID) FROM OBJ_CLASSES",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM objects;"
        ],
        "rule_sql": []
    },
    "5149": {
        "db_id": "address",
        "question": "Based on the population in 2020, calculate the percentage for the population of Asian in the zip code where the CBSA was Atmore, AL.",
        "ground_truth": "SELECT CAST(T2.asian_population AS REAL) * 100 / T2.population_2010 FROM CBSA AS T1 INNER JOIN zip_data AS T2 ON T1.CBSA = T2.CBSA WHERE T1.CBSA_name = 'Atmore, AL'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (Asian / Total_Population) * 100 AS Asian_Percentage \nFROM population_data \nWHERE CBSA = 'Atmore, AL' AND Year = 2020"
        ],
        "rule_sql": []
    },
    "1563": {
        "db_id": "car_retails",
        "question": "Please calculate the average total price of orders from Exoto Designs Vendor in 2005.",
        "ground_truth": "SELECT SUM(T2.quantityOrdered * T2.priceEach) / COUNT(T3.orderNumber) FROM products AS T1 INNER JOIN orderdetails AS T2 ON T1.productCode = T2.productCode INNER JOIN orders AS T3 ON T2.orderNumber = T3.orderNumber WHERE T1.productVendor = 'Exoto Designs' AND STRFTIME('%Y', T3.orderDate) = '2005'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM orders WHERE vendor = 'Exoto Designs' AND year = 2005;"
        ],
        "rule_sql": []
    },
    "8081": {
        "db_id": "university",
        "question": "Please list the names of all the ranking criteria of Harvard University in 2011.",
        "ground_truth": "SELECT T1.criteria_name FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id WHERE T3.university_name = 'Harvard University' AND T2.year = 2011",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT criteria_name FROM university_rankings WHERE university = 'Harvard University' AND year = 2011"
        ],
        "rule_sql": []
    },
    "2492": {
        "db_id": "genes",
        "question": "Please list the location of the genes that have the most chromosomes.",
        "ground_truth": "SELECT T2.Localization FROM Genes AS T1 INNER JOIN Classification AS T2 ON T1.GeneID = T2.GeneID ORDER BY T1.Chromosome DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location FROM genes ORDER BY chromosome_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8184": {
        "db_id": "sales_in_weather",
        "question": "How many stores belong to the most windy station?",
        "ground_truth": "SELECT COUNT(store_nbr) FROM relation WHERE station_nbr = ( SELECT station_nbr FROM weather ORDER BY avgspeed DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM stores WHERE station_id = (SELECT station_id FROM weather ORDER BY wind_speed DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "8323": {
        "db_id": "mondial_geo",
        "question": "For island area less than 200, list the island name and city it belongs to.",
        "ground_truth": "SELECT DISTINCT T3.Name, T1.Name FROM city AS T1 INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE T3.Area < 200",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT island_name, city FROM islands WHERE area >= 200;"
        ],
        "rule_sql": []
    },
    "5216": {
        "db_id": "address",
        "question": "Among the cities with alias Ponce, what is the percentage of cities with a country level FIPS code of less than 20?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.county_fips < 20 THEN T2.zip_code ELSE NULL END) AS REAL) * 100 / COUNT(T2.zip_code) FROM alias AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.alias = 'Ponce'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN fips_country_code < 20 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cities\nWHERE city_alias = 'Ponce';"
        ],
        "rule_sql": []
    },
    "5242": {
        "db_id": "beer_factory",
        "question": "Please list the brands of all the root beer that Frank-Paul Santangelo had purchased on 2014/7/7.",
        "ground_truth": "SELECT DISTINCT T4.BrandName FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN rootbeer AS T3 ON T2.RootBeerID = T3.RootBeerID INNER JOIN rootbeerbrand AS T4 ON T3.BrandID = T4.BrandID WHERE T1.First = 'Frank-Paul' AND T1.Last = 'Santangelo' AND T2.TransactionDate = '2014-07-07'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM purchases \nWHERE customer_name = 'Frank-Paul Santangelo' \nAND purchase_date = '2014/7/7' \nAND product_type = 'root beer';"
        ],
        "rule_sql": []
    },
    "364": {
        "db_id": "retail_complains",
        "question": "What is the average age of clients whose complaint type is \"TT\"?",
        "ground_truth": "SELECT AVG(T1.age) FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T2.type = 'TT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM clients WHERE complaint_type = 'TT';"
        ],
        "rule_sql": []
    },
    "2642": {
        "db_id": "regional_sales",
        "question": "Please list the customer names whose order quantity was more than 5 on 6/1/2018.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN SUM(T1.`Order Quantity`) > 5 THEN T2.`Customer Names` END AS T FROM `Sales Orders` T1 INNER JOIN Customers T2 ON T2.CustomerID = T1._CustomerID WHERE T1.OrderDate = '6/1/18' GROUP BY T1._CustomerID ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM orders WHERE order_date = '2018-06-01' AND quantity > 5;"
        ],
        "rule_sql": []
    },
    "8663": {
        "db_id": "chicago_crime",
        "question": "Who is the alderman in the ward associated with the crime with report number 23769?",
        "ground_truth": "SELECT T2.alderman_first_name, T2.alderman_last_name FROM Crime AS T1 INNER JOIN Ward AS T2 ON T2.ward_no = T1.ward_no WHERE T1.report_no = 23769",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT alderman FROM crimes WHERE report_number = 23769"
        ],
        "rule_sql": []
    },
    "3180": {
        "db_id": "donor",
        "question": "Which project in Brooklyn that have the highest request of resources? State the the project ID including all of the name of item requested.",
        "ground_truth": "SELECT T1.projectid, T1.item_name FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T2.school_city LIKE 'Brooklyn' GROUP BY T1.item_name ORDER BY COUNT(T1.item_name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.project_id, r.item_name \nFROM projects p \nJOIN requests r ON p.project_id = r.project_id \nWHERE p.location = 'Brooklyn' \nORDER BY COUNT(r.request_id) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3048": {
        "db_id": "shakespeare",
        "question": "Give the character's ID of the character that said the paragraph \"O my poor brother! and so perchance may he be.\"",
        "ground_truth": "SELECT character_id FROM paragraphs WHERE PlainText = 'O my poor brother! and so perchance may he be.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_id FROM paragraphs WHERE paragraph_text = 'O my poor brother! and so perchance may he be.'"
        ],
        "rule_sql": []
    },
    "4408": {
        "db_id": "student_loan",
        "question": "How many students were absence for 4 month?",
        "ground_truth": "SELECT COUNT(name) FROM longest_absense_from_school WHERE month = 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE absence_months = 4;"
        ],
        "rule_sql": []
    },
    "4246": {
        "db_id": "simpson_episodes",
        "question": "How old was composer of the show when he was nominated for Emmy's Outstanding Music Composition for a Series in 2009. Indicate his full name as well.",
        "ground_truth": "SELECT T1.year - T2.birthdate AS ageIn2009, T2.name FROM Award AS T1 INNER JOIN Person AS T2 ON T1.person = T2.name WHERE T1.role = 'composer' AND T1.organization = 'Primetime Emmy Awards' AND T1.award = 'Outstanding Music Composition for a Series (Original Dramatic Score)' AND T1.result = 'Nominee' AND T1.year = 2009;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, age FROM composers WHERE emmy_nomination_year = 2009 AND award_category = 'Outstanding Music Composition for a Series';"
        ],
        "rule_sql": []
    },
    "4279": {
        "db_id": "simpson_episodes",
        "question": "In 2010, which episode did Joel H. Cohen win an award for?",
        "ground_truth": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2010' AND T1.person = 'Joel H. Cohen';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT episode_title FROM episodes WHERE year = 2010 AND award_winner = 'Joel H. Cohen';"
        ],
        "rule_sql": []
    },
    "3393": {
        "db_id": "video_games",
        "question": "Calculate how many percent of sales in North America is higher than the average sale per region for platform ID 9577.",
        "ground_truth": "SELECT (SUM(CASE WHEN T2.region_name = 'North America' THEN T1.num_sales ELSE 0 END) - AVG(T1.num_sales)) * 100.0 / AVG(T1.num_sales) FROM region_sales AS T1 INNER JOIN region AS T2 ON T1.region_id = T2.id WHERE T1.game_platform_id = 9577",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN sales > avg_sale THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM sales_data\nWHERE region = 'North America' AND platform_id = 9577\nCROSS JOIN (\n    SELECT AVG(sales) AS avg_sale \n    FROM sales_data \n    WHERE platform_id = 9577\n)"
        ],
        "rule_sql": []
    },
    "7427": {
        "db_id": "works_cycles",
        "question": "How many products were on the LL Road Frame Sale?",
        "ground_truth": "SELECT COUNT(DISTINCT ProductID) FROM SpecialOffer AS T1 INNER JOIN SpecialOfferProduct AS T2 ON T1.SpecialOfferID = T2.SpecialOfferID WHERE T1.Description = 'LL Road Frame Sale'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE product_name = 'LL Road Frame Sale';"
        ],
        "rule_sql": []
    },
    "1632": {
        "db_id": "car_retails",
        "question": "What's the postal code of the office the VP Sales is at?",
        "ground_truth": "SELECT t2.postalCode FROM employees AS t1 INNER JOIN offices AS t2 ON t1.officeCode = t2.officeCode WHERE t1.jobTitle = 'VP Sales'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT postal_code FROM offices WHERE job_title = 'VP Sales';"
        ],
        "rule_sql": []
    },
    "6881": {
        "db_id": "retails",
        "question": "Please list the order keys of all the orders that have more than 2 parts with a jumbo case container.",
        "ground_truth": "SELECT T.l_orderkey FROM ( SELECT T2.l_orderkey, COUNT(T2.l_partkey) AS num FROM part AS T1 INNER JOIN lineitem AS T2 ON T1.p_partkey = T2.l_partkey WHERE T1.p_container = 'JUMBO CASE' GROUP BY T2.l_orderkey ) AS T WHERE T.num > 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT orderkey FROM orders WHERE container = 'JUMBO CASE' GROUP BY orderkey HAVING COUNT(*) > 2"
        ],
        "rule_sql": []
    },
    "7194": {
        "db_id": "works_cycles",
        "question": "How many people with the name Alex are single and occupying organization level of 1?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.FirstName = 'Alex' AND T1.MaritalStatus = 'S' AND T1.OrganizationLevel = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM people WHERE name = 'Alex' AND marital_status = 'single' AND organization_level = 1;"
        ],
        "rule_sql": []
    },
    "6074": {
        "db_id": "books",
        "question": "What is the full name of customer with email ckupis4@tamu.edu?",
        "ground_truth": "SELECT first_name, last_name FROM customer WHERE email = 'ckupis4@tamu.edu'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM customers WHERE email = 'ckupis4@tamu.edu';"
        ],
        "rule_sql": []
    },
    "9179": {
        "db_id": "movie_3",
        "question": "Who is the staff manager in store id 2?",
        "ground_truth": "SELECT manager_staff_id FROM store WHERE store_id = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM staff WHERE store_id = 2 AND position = 'Manager';"
        ],
        "rule_sql": []
    },
    "4172": {
        "db_id": "simpson_episodes",
        "question": "What's the title of the episode that got the most 7-star votes in star score?",
        "ground_truth": "SELECT T1.title FROM Episode AS T1 INNER JOIN Vote AS T2 ON T2.episode_id = T1.episode_id WHERE T2.stars = 7 ORDER BY T2.votes DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY star_score DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "819": {
        "db_id": "social_media",
        "question": "List down all of the texts posted on Twitter on Thursday.",
        "ground_truth": "SELECT text FROM twitter WHERE Weekday = 'Thursday'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE day = 'Thursday';"
        ],
        "rule_sql": []
    },
    "5964": {
        "db_id": "books",
        "question": "Calculate the total price of books ordered by customer named Lucas Wyldbore.",
        "ground_truth": "SELECT SUM(T1.price) FROM order_line AS T1 INNER JOIN cust_order AS T2 ON T2.order_id = T1.order_id INNER JOIN customer AS T3 ON T3.customer_id = T2.customer_id WHERE T3.first_name = 'Lucas' AND T3.last_name = 'Wyldbore'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM books WHERE customer_name = 'Lucas Wyldbore';"
        ],
        "rule_sql": []
    },
    "3756": {
        "db_id": "college_completion",
        "question": "Between 2011 to 2013, what is the average number of male Hispanic degree-seeking students at 2-year institutions who graduated within 150 percent of normal/expected time in United Education Institute-Huntington Park Campus?",
        "ground_truth": "SELECT AVG(T2.grad_150) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE T1.chronname = 'United Education Institute-Huntington Park Campus' AND T2.year BETWEEN 2011 AND 2013 AND T2.gender = 'M' AND T2.race = 'H'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(male_hispanic_graduates) \nFROM graduation_data \nWHERE institution = 'United Education Institute-Huntington Park Campus' \nAND year BETWEEN 2011 AND 2013 \nAND institution_type = '2-year' \nAND graduation_rate = '150% of normal time'"
        ],
        "rule_sql": []
    },
    "5377": {
        "db_id": "sales",
        "question": "Write down all of the product ids that were placed by Meander.",
        "ground_truth": "SELECT DISTINCT T2.ProductID FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID WHERE T1.FirstName = 'Meander'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id FROM orders WHERE customer_name = 'Meander';"
        ],
        "rule_sql": []
    },
    "6840": {
        "db_id": "retails",
        "question": "List line items shipped by truck with delivery time before 1997.",
        "ground_truth": "SELECT l_linenumber FROM lineitem WHERE STRFTIME('%Y', l_shipdate) < 1997 AND l_shipmode = 'truck'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM lineitem WHERE l_shipmode = 'TRUCK' AND l_shipdate < '1997-01-01';"
        ],
        "rule_sql": []
    },
    "4317": {
        "db_id": "simpson_episodes",
        "question": "What are the characters that were nominated for Primetime Emmy Award from 2009 to 2010 but did not win?",
        "ground_truth": "SELECT T2.character FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T1.award_category = 'Primetime Emmy' AND T1.year BETWEEN 2009 AND 2010 AND T1.result != 'Winner';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name \nFROM emmy_nominations \nWHERE year BETWEEN 2009 AND 2010 \nAND won_award = 1;"
        ],
        "rule_sql": []
    },
    "4941": {
        "db_id": "olympics",
        "question": "Who is the youngest person who participated in the Olympics?",
        "ground_truth": "SELECT T1.full_name FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id ORDER BY T2.age LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, MIN(age) FROM athletes WHERE participated_in_olympics = 'yes'"
        ],
        "rule_sql": []
    },
    "6117": {
        "db_id": "food_inspection_2",
        "question": "Please list the full names of all the sanitarians who have inspected the facility Burbank.",
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id INNER JOIN establishment AS T3 ON T2.license_no = T3.license_no WHERE T3.dba_name = 'Burbank' AND T1.title = 'Sanitarian'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM sanitarians WHERE facility_name = 'Burbank';"
        ],
        "rule_sql": []
    },
    "6014": {
        "db_id": "books",
        "question": "How many orders did Marcelia Goering place in 2021 that uses the Priority Shipping method?",
        "ground_truth": "SELECT COUNT(*) FROM customer AS T1 INNER JOIN cust_order AS T2 ON T1.customer_id = T2.customer_id INNER JOIN shipping_method AS T3 ON T3.method_id = T2.shipping_method_id WHERE T1.first_name = 'Marcelia' AND T1.last_name = 'Goering' AND STRFTIME('%Y', T2.order_date) = '2021' AND T3.method_name = 'Priority'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE c.first_name = 'Marcelia' AND c.last_name = 'Goering'\nAND o.order_date LIKE '2021%'\nAND o.shipping_method = 'Priority Shipping';"
        ],
        "rule_sql": []
    },
    "8870": {
        "db_id": "cookbook",
        "question": "How many ingredients must be rationed in the recipe \"Raspberry Chiffon Pie\"?",
        "ground_truth": "SELECT COUNT(*) FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Raspberry Chiffon Pie' AND T2.max_qty = T2.min_qty",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ingredients WHERE recipe_name = 'Raspberry Chiffon Pie' AND rationed = 1;"
        ],
        "rule_sql": []
    },
    "6674": {
        "db_id": "retails",
        "question": "What is the phone number of Customer#000000001?",
        "ground_truth": "SELECT c_phone FROM customer WHERE c_name = 'Customer#000000001'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone FROM customers WHERE customer_id = 'Customer#000000001';"
        ],
        "rule_sql": []
    },
    "135": {
        "db_id": "movie_platform",
        "question": "What is the percentage of users gave \"5\" to the movie \"Go Go Tales\"?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.rating_score = 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.movie_title = 'Go Go Tales'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM ratings)) AS percentage FROM ratings WHERE rating = 5 AND movie_id = (SELECT movie_id FROM movies WHERE title = 'Go Go Tales');"
        ],
        "rule_sql": []
    },
    "2743": {
        "db_id": "european_football_1",
        "question": "What percentage of matches played on 2005/07/30 belong to the F1 division?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Div = 'F1' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(Div) FROM matchs WHERE Date = '2005-07-30' ",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN division = 'F1' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM matches\nWHERE date = '2005/07/30';"
        ],
        "rule_sql": []
    },
    "6055": {
        "db_id": "books",
        "question": "List all the books published by BBC Audiobooks.",
        "ground_truth": "SELECT T1.title FROM book AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.publisher_id WHERE T2.publisher_name = 'BBC Audiobooks'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM books WHERE publisher = 'BBC Audiobooks';"
        ],
        "rule_sql": []
    },
    "8083": {
        "db_id": "university",
        "question": "Please list the names of all the universities that scored under 60 in teaching in 2011 and are in the United States of America.",
        "ground_truth": "SELECT T3.university_name FROM ranking_criteria AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.ranking_criteria_id INNER JOIN university AS T3 ON T3.id = T2.university_id INNER JOIN country AS T4 ON T4.id = T3.country_id WHERE T4.country_name = 'United States of America' AND T2.year = 2011 AND T2.score < 60 AND T1.criteria_name = 'Teaching'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM universities WHERE teaching_score < 60 AND country = 'United States' AND year = 2010;"
        ],
        "rule_sql": []
    },
    "5755": {
        "db_id": "language_corpus",
        "question": "How many words has the appearance times greater than 10?",
        "ground_truth": "SELECT COUNT(w1st) AS countwords FROM biwords WHERE occurrences > 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE appearance_times > 10;"
        ],
        "rule_sql": []
    },
    "950": {
        "db_id": "cs_semester",
        "question": "What is the difference in the average GPA of students who took the hardest and easiest courses?",
        "ground_truth": "SELECT AVG(T1.gpa) FROM student AS T1 INNER JOIN registration AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T2.course_id = T3.course_id WHERE T3.diff IN (2, 1) GROUP BY T3.diff",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT AVG(GPA) FROM students WHERE course_difficulty = 'hardest') - \n    (SELECT AVG(GPA) FROM students WHERE course_difficulty = 'easiest') AS gpa_difference;"
        ],
        "rule_sql": []
    },
    "4497": {
        "db_id": "student_loan",
        "question": "List any ten male students who enlisted for foreign legion.",
        "ground_truth": "SELECT T1.name FROM enlist AS T1 INNER JOIN male AS T2 ON T2.name = T1.name WHERE T1.organ = 'foreign_legion' LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM students WHERE gender = 'female' LIMIT 10;"
        ],
        "rule_sql": []
    },
    "1603": {
        "db_id": "car_retails",
        "question": "What is the full address of the customer who commented that DHL be used for the order that was shipped on April 4, 2005?",
        "ground_truth": "SELECT T1.addressLine1, T1.addressLine2 FROM customers AS T1 INNER JOIN orders AS T2 ON T1.customerNumber = T2.customerNumber WHERE T2.shippedDate = '2005-04-04' AND T2.status = 'Shipped'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM customers WHERE comment = 'DHL' AND order_date = '2005-04-04';"
        ],
        "rule_sql": []
    },
    "1802": {
        "db_id": "soccer_2016",
        "question": "Among all the matches SC Ganguly has played in, what is the highest winning margin?",
        "ground_truth": "SELECT MAX(T3.Win_Margin) FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Match AS T3 ON T2.Match_Id = T3.Match_Id WHERE T1.Player_Name = 'SC Ganguly'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(winning_margin) FROM matches WHERE player = 'SC Ganguly'"
        ],
        "rule_sql": []
    },
    "6675": {
        "db_id": "retails",
        "question": "How many orders in total have the customers in the household segment made?",
        "ground_truth": "SELECT COUNT(T1.o_orderkey) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_mktsegment = 'HOUSEHOLD'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE segment = 'household';"
        ],
        "rule_sql": []
    },
    "6782": {
        "db_id": "retails",
        "question": "How many orders of more than 10 items have been returned?",
        "ground_truth": "SELECT COUNT(l_linenumber) FROM lineitem WHERE l_quantity > 10 AND l_returnflag = 'R'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE items > 10 AND status = 'returned';"
        ],
        "rule_sql": []
    },
    "7754": {
        "db_id": "hockey",
        "question": "Among the teams that had more wins than loses in the year 2006, how many of them have over 100 points?",
        "ground_truth": "SELECT COUNT(tmID) FROM Teams WHERE year = 2006 AND W > L AND Pts > 100",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM teams \nWHERE year = 2006 \nAND wins > loses \nAND points > 100;"
        ],
        "rule_sql": []
    },
    "2721": {
        "db_id": "regional_sales",
        "question": "In the Northeast region, what is the average household income for each city located in the state with the highest number of stores?",
        "ground_truth": "SELECT AVG(T2.`Household Income`) FROM Regions AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StateCode = T1.StateCode WHERE T1.Region = 'Northeast' GROUP BY T2.State ORDER BY COUNT(T2.StoreID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, AVG(household_income) \nFROM stores \nWHERE region = 'Northeast' \nGROUP BY city \nORDER BY COUNT(store_id) DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "783": {
        "db_id": "social_media",
        "question": "Users in which city of Argentina post the most tweets?",
        "ground_truth": "SELECT T2.City FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T2.Country = 'Argentina' GROUP BY T2.City ORDER BY COUNT(T1.TweetID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city, COUNT(*) as tweet_count FROM tweets WHERE country = 'Argentina' GROUP BY city ORDER BY tweet_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2898": {
        "db_id": "professional_basketball",
        "question": "List all the coatches of the Oklahoma City Thunder",
        "ground_truth": "SELECT DISTINCT coachID FROM coaches AS T1 INNER JOIN teams AS T2 ON T1.tmID = T2.tmID WHERE name = 'Oklahoma City Thunder'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM players WHERE team = 'Oklahoma City Thunder' AND position = 'Coach';"
        ],
        "rule_sql": []
    },
    "5721": {
        "db_id": "language_corpus",
        "question": "Indicate which is the word that is repeated the most times.",
        "ground_truth": "SELECT word FROM words WHERE occurrences = ( SELECT MAX(occurrences) FROM words )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word, COUNT(*) as count FROM words GROUP BY word ORDER BY count ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8021": {
        "db_id": "university",
        "question": "In which country does the most populated university in 2014 located ?",
        "ground_truth": "SELECT T2.country_id FROM university_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.year = 2014 ORDER BY T1.num_students DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM universities WHERE population = (SELECT MAX(population) FROM universities WHERE year = 2014);"
        ],
        "rule_sql": []
    },
    "7461": {
        "db_id": "works_cycles",
        "question": "How many products using \"roadster_black_small.gif\" as the thumbnail photo?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.ProductID) FROM ProductPhoto AS T1 INNER JOIN ProductProductPhoto AS T2 ON T1.ProductPhotoID = T2.ProductPhotoID WHERE T1.LargePhotoFileName = 'roadster_black_large.gif'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE thumbnail_photo = 'roadster_black_small.gif';"
        ],
        "rule_sql": []
    },
    "7702": {
        "db_id": "hockey",
        "question": "How many years did player Id \"cleghsp01\" make to the Stanley Cup finals?",
        "ground_truth": "SELECT COUNT(year) FROM ScoringSC WHERE playerID = 'cleghsp01'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(DISTINCT year) FROM stanley_cup_finals WHERE player_id = 'cleghsp01';"
        ],
        "rule_sql": []
    },
    "3888": {
        "db_id": "public_review_platform",
        "question": "What is the category of the business with medium review length and highest review stars within business ID from 6 t0 9?",
        "ground_truth": "SELECT T4.category_name FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T1.review_length LIKE 'Medium' AND T2.business_id BETWEEN 6 AND 9 ORDER BY T1.review_stars DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM businesses WHERE business_id BETWEEN 6 AND 9 ORDER BY review_stars DESC, LENGTH(review_text) ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8876": {
        "db_id": "cookbook",
        "question": "How many calories does the turkey tenderloin bundles recipe have?",
        "ground_truth": "SELECT T2.calories FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Turkey Tenderloin Bundles'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT calories FROM recipes WHERE name = 'turkey tenderloin bundles';"
        ],
        "rule_sql": []
    },
    "1262": {
        "db_id": "law_episode",
        "question": "Describe what happened in the episode of award no.296.",
        "ground_truth": "SELECT T1.summary FROM Episode AS T1 INNER JOIN Award AS T2 ON T1.episode_id = T2.episode_id WHERE T2.award_id = 296",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM episodes WHERE award_id = 296;"
        ],
        "rule_sql": []
    },
    "5293": {
        "db_id": "beer_factory",
        "question": "On average how many caffeinated root beers are sold a day?",
        "ground_truth": "SELECT CAST(COUNT(T2.RootBeerID) AS REAL) / COUNT(DISTINCT T2.PurchaseDate) FROM rootbeerbrand AS T1 INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID INNER JOIN `transaction` AS T3 ON T2.RootBeerID = T3.RootBeerID WHERE T1.Caffeinated = 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(quantity) FROM sales WHERE product_type = 'root beer' AND caffeinated = 'yes' GROUP BY date;"
        ],
        "rule_sql": []
    },
    "7656": {
        "db_id": "hockey",
        "question": "Please list the Nicknames of the players who got in the Hall of Fame in 2007.",
        "ground_truth": "SELECT DISTINCT T1.nameNick FROM Master AS T1 INNER JOIN HOF AS T2 ON T1.hofID = T2.hofID WHERE T2.year = 2007",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Nickname FROM HallOfFame WHERE Year = 2007;"
        ],
        "rule_sql": []
    },
    "3625": {
        "db_id": "authors",
        "question": "What was the name of the paper that was published on \"IEEE Transactions on Pattern Analysis and Machine Intelligence\" in 2011?",
        "ground_truth": "SELECT T2.Title FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T1.FullName = 'IEEE Transactions on Pattern Analysis and Machine Intelligence' AND T2.Year = 2011 AND T2.Title <> ''",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE journal = 'IEEE Transactions on Pattern Analysis and Machine Intelligence' AND year = 2011;"
        ],
        "rule_sql": []
    },
    "6816": {
        "db_id": "retails",
        "question": "Which nation and region does the Customer#000000008 come from?",
        "ground_truth": "SELECT T1.n_name, T3.r_name FROM nation AS T1 INNER JOIN customer AS T2 ON T1.n_nationkey = T2.c_nationkey INNER JOIN region AS T3 ON T1.n_regionkey = T3.r_regionkey WHERE T2.c_name = 'Customer#000000008'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT n_name, r_name FROM customer JOIN nation ON customer.c_nationkey = nation.n_nationkey JOIN region ON nation.n_regionkey = region.r_regionkey WHERE c_custkey = '000000008'"
        ],
        "rule_sql": []
    },
    "7155": {
        "db_id": "works_cycles",
        "question": "Where is Business Entity ID No.4 located at? Give the address down to street.",
        "ground_truth": "SELECT AddressLine1, AddressLine2 FROM Address WHERE AddressID IN ( SELECT AddressID FROM BusinessEntityAddress WHERE BusinessEntityID = 4 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT Street FROM Address WHERE BusinessEntityID = 4;"
        ],
        "rule_sql": []
    },
    "7792": {
        "db_id": "hockey",
        "question": "For the goalie whose last name is \"Young\", how many teams did he play in?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.tmID) FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T2.lastName = 'Young'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE last_name = 'Young' AND position = 'Goalie';"
        ],
        "rule_sql": []
    },
    "6010": {
        "db_id": "books",
        "question": "How many customers have an address that is located in the city of Villeneuve-la-Garenne?",
        "ground_truth": "SELECT COUNT(address_id) FROM address WHERE city = 'Villeneuve-la-Garenne'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE city = 'Villeneuve-la-Garenne';"
        ],
        "rule_sql": []
    },
    "3145": {
        "db_id": "cars",
        "question": "Calculate the percentage of American cars among all cars.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.country = 'USA' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) FILTER (WHERE country = 'USA') / COUNT(*)) * 100 AS percentage_american_cars FROM cars;"
        ],
        "rule_sql": []
    },
    "483": {
        "db_id": "movies_4",
        "question": "List 10 crews alongside their jobs who worked on the movie 'Mad Max: Fury Road.'",
        "ground_truth": "SELECT T3.person_name FROM movie AS T1 INNER JOIN movie_crew AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T1.title = 'Mad Max: Fury Road' LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT crew.name, crew.job FROM crew JOIN movies ON crew.movie_id = movies.id WHERE movies.title = 'Mad Max: Fury Road' LIMIT 10;"
        ],
        "rule_sql": []
    },
    "5767": {
        "db_id": "language_corpus",
        "question": "How many word that has number of different words equal to 3?",
        "ground_truth": "SELECT COUNT(T2.wid) FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T1.words = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE LENGTH(word) = 3;"
        ],
        "rule_sql": []
    },
    "268": {
        "db_id": "retail_complains",
        "question": "For the client who made the complaint call \"CR0217298\", what was his/her birthday\uff1f",
        "ground_truth": "SELECT T1.month, T1.day FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.`Complaint ID` = 'CR0217298'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthday FROM clients WHERE complaint_id = 'CR0217298';"
        ],
        "rule_sql": []
    },
    "4226": {
        "db_id": "simpson_episodes",
        "question": "Among the episodes with excellent rating which were aired in 2008, describe the title, episode's image, award name and person who were nominated.",
        "ground_truth": "SELECT T2.title, T2.episode_image, T1.award, T1.person FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T2.rating BETWEEN 7 AND 10 AND SUBSTR(T2.air_date, 1, 4) = '2008' AND T1.result = 'Nominee';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, episode_image, award_name, person_nominated \nFROM episodes \nWHERE rating = 'excellent' AND year = 2008 \nORDER BY title;"
        ],
        "rule_sql": []
    },
    "7340": {
        "db_id": "works_cycles",
        "question": "Which three sales regions have generated the most revenue thus far?",
        "ground_truth": "SELECT TerritoryID FROM SalesTerritory ORDER BY SalesYTD DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, SUM(revenue) as total_revenue FROM sales GROUP BY region ORDER BY total_revenue DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "3367": {
        "db_id": "video_games",
        "question": "List the region name where games reached 300000 sales and above.",
        "ground_truth": "SELECT DISTINCT T1.region_name FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T2.num_sales * 100000 > 300000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name FROM sales WHERE sales >= 300000"
        ],
        "rule_sql": []
    },
    "8907": {
        "db_id": "cookbook",
        "question": "How many ingredients are needed to prepare Idaho Potato Supreme?",
        "ground_truth": "SELECT COUNT(*) FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Idaho Potato Supreme'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ingredients WHERE recipe_name = 'Idaho Potato Supreme';"
        ],
        "rule_sql": []
    },
    "6222": {
        "db_id": "food_inspection_2",
        "question": "What is the restaurant's name at \"41.9532864854\" latitude and \"-87.7673790701422\" longitude?",
        "ground_truth": "SELECT dba_name FROM establishment WHERE latitude = 41.9532864854 AND longitude = -87.7673790701422 AND facility_type = 'Restaurant'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE latitude = '41.9532864854' AND longitude = '-87.7673790701422';"
        ],
        "rule_sql": []
    },
    "1692": {
        "db_id": "restaurant",
        "question": "Which restaurant on the street Alameda de las Pulgas in the city of Menlo Park is the worst rated?",
        "ground_truth": "SELECT T2.label FROM location AS T1 INNER JOIN generalinfo AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T1.street_name = 'avenida de las pulgas' AND T2.city = 'menlo park' ORDER BY review LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM restaurants WHERE street = 'Alameda de las Pulgas' AND city = 'Menlo Park' ORDER BY rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3549": {
        "db_id": "authors",
        "question": "Among the author included in the paper of \"Inspection resistant memory: Architectural support for security from physical examination\", write down the author name and ID who were affiliated with Microsoft Research, USA.",
        "ground_truth": "SELECT T2.Name, T1.Id FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Inspection resistant memory: Architectural support for security FROM physical examination' AND T2.Affiliation = 'Microsoft Research, USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name, author_id FROM authors WHERE affiliation = 'Microsoft Research, USA' AND paper_title = 'Inspection resistant memory: Architectural support for security from physical examination';"
        ],
        "rule_sql": []
    },
    "9287": {
        "db_id": "movie_3",
        "question": "Please list three types of film along with their IDs and the latest update.",
        "ground_truth": "SELECT DISTINCT name, category_id, last_update FROM category LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT film_id, title, release_year FROM film ORDER BY film_id LIMIT 3;"
        ],
        "rule_sql": []
    },
    "3540": {
        "db_id": "authors",
        "question": "Within the year of 2001 to 2010, find the paper published rate of 2001.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Year = 2001 THEN 1 ELSE 0 END) AS REAL) / COUNT(Id) FROM Paper WHERE Year >= 2001 AND Year < 2011",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS paper_count FROM papers WHERE year = 2001 AND year BETWEEN 2001 AND 2010;"
        ],
        "rule_sql": []
    },
    "5402": {
        "db_id": "sales",
        "question": "Name the sales person who helped Elizabeth A. White to purchase Road-250 Black, 48.",
        "ground_truth": "SELECT DISTINCT T3.FirstName, T3.MiddleInitial, T3.LastName FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Employees AS T3 ON T2.SalesPersonID = T3.EmployeeID INNER JOIN Customers AS T4 ON T2.CustomerID = T4.CustomerID WHERE T4.MiddleInitial = 'A' AND T4.LastName = 'White' AND T1.Name = 'Road-250 Black, 48' AND T4.FirstName = 'Elizabeth'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.Name \nFROM SalesPerson s\nJOIN SalesOrderHeader soh ON s.SalesPersonID = soh.SalesPersonID\nJOIN SalesOrderDetail sod ON soh.SalesOrderID = sod.SalesOrderID\nJOIN Product p ON sod.ProductID = p.ProductID\nJOIN Customer c ON soh.CustomerID = c.CustomerID\nWHERE c.FirstName = 'Elizabeth' AND c.LastName = 'White'\nAND p.Name = 'Road-250 Black, 48';"
        ],
        "rule_sql": []
    },
    "4674": {
        "db_id": "disney",
        "question": "Who are the voice actors in the movie that came out on 11/24/2010?",
        "ground_truth": "SELECT T2.`voice-actor` FROM movies_total_gross AS T1 INNER JOIN `voice-actors` AS T2 ON T1.movie_title = T2.movie WHERE T1.release_date = 'Nov 24, 2010'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT voice_actor_name FROM movies JOIN voice_actors ON movies.movie_id = voice_actors.movie_id WHERE release_date = '11/24/2010';"
        ],
        "rule_sql": []
    },
    "2541": {
        "db_id": "app_store",
        "question": "What is the rating for \"Garden Coloring Book\"? List all of its reviews.",
        "ground_truth": "SELECT T1.Rating, T2.Translated_Review FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = 'Garden Coloring Book'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating, review_text FROM reviews WHERE book_title = 'Garden Coloring Book';"
        ],
        "rule_sql": []
    },
    "5313": {
        "db_id": "beer_factory",
        "question": "At what latitude is the Thomas Kemper brand beer consumed the most?",
        "ground_truth": "SELECT T3.Latitude FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID INNER JOIN geolocation AS T3 ON T1.LocationID = T3.LocationID WHERE T2.BrandName = 'Thomas Kemper' GROUP BY T3.Latitude ORDER BY COUNT(T1.BrandID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT latitude FROM beer_consumption WHERE brand = 'Thomas Kemper' ORDER BY consumption DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1164": {
        "db_id": "talkingdata",
        "question": "How many events did the device ID \"3915082290673130000\" join?",
        "ground_truth": "SELECT COUNT(event_id) FROM events WHERE device_id = 3915082290673130000",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE device_id = 3915082290673130000"
        ],
        "rule_sql": []
    },
    "4440": {
        "db_id": "student_loan",
        "question": "Mention the name of students who filed for bankruptcy and have never been absent from school.",
        "ground_truth": "SELECT T1.name FROM longest_absense_from_school AS T1 INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name WHERE T1.month = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE bankruptcy_filed = 1 AND absences = 0;"
        ],
        "rule_sql": []
    },
    "656": {
        "db_id": "codebase_comments",
        "question": "Among the english methods,please list the tokenized names of methods whose solutions need to be compiled.",
        "ground_truth": "SELECT NameTokenized FROM Solution AS T1 INNER JOIN Method AS T2 ON T1.Id = T2.SolutionId WHERE Lang = 'en' AND WasCompiled = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tokenized_name FROM methods WHERE language = 'english' AND solution LIKE '%compile%';"
        ],
        "rule_sql": []
    },
    "9246": {
        "db_id": "movie_3",
        "question": "Please list the top ten movies with the most price per day in descending order of price per day.",
        "ground_truth": "SELECT title FROM film ORDER BY rental_rate / rental_duration DESC LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, price_per_day FROM movies ORDER BY price_per_day DESC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "8362": {
        "db_id": "mondial_geo",
        "question": "What is the smallest border's length, and what form of government do the two nations bordering it have?",
        "ground_truth": "SELECT T1.Government, T3.Government FROM politics AS T1 INNER JOIN borders AS T2 ON T1.Country = T2.Country1 INNER JOIN politics AS T3 ON T3.Country = T2.Country2 ORDER BY T2.Length ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(border_length) as smallest_border, government_form \nFROM borders \nJOIN countries ON borders.country1 = countries.country_code \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5391": {
        "db_id": "sales",
        "question": "List the product ID of the top five products, by descending order, in terms of price.",
        "ground_truth": "SELECT ProductID FROM Products ORDER BY Price DESC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_id FROM products ORDER BY price ASC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "1662": {
        "db_id": "car_retails",
        "question": "List out sale rep that has sold 1969 Harley Davidson Ultimate Chopper. List out their names and quantity sold throughout the year.",
        "ground_truth": "SELECT t5.firstName, t5.lastName, SUM(t2.quantityOrdered) FROM products AS t1 INNER JOIN orderdetails AS t2 ON t1.productCode = t2.productCode INNER JOIN orders AS t3 ON t2.orderNumber = t3.orderNumber INNER JOIN customers AS t4 ON t3.customerNumber = t4.customerNumber INNER JOIN employees AS t5 ON t4.salesRepEmployeeNumber = t5.employeeNumber WHERE t1.productName = '1969 Harley Davidson Ultimate Chopper' GROUP BY t5.lastName, t5.firstName",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.firstName, e.lastName, SUM(od.quantityOrdered) as totalQuantity\nFROM employees e\nJOIN customers c ON e.employeeNumber = c.salesRepEmployeeNumber\nJOIN orders o ON c.customerNumber = o.customerNumber\nJOIN orderdetails od ON o.orderNumber = od.orderNumber\nJOIN products p ON od.productCode = p.productCode\nWHERE p.productName = '1969 Harley Davidson Ultimate Chopper'\nGROUP BY e.employeeNumber\nORDER BY totalQuantity DESC;"
        ],
        "rule_sql": []
    },
    "6008": {
        "db_id": "books",
        "question": "List all the authors who wrote fewer pages than the average.",
        "ground_truth": "SELECT T3.author_name FROM book AS T1 INNER JOIN book_author AS T2 ON T1.book_id = T2.book_id INNER JOIN author AS T3 ON T3.author_id = T2.author_id WHERE T1.num_pages < ( SELECT AVG(num_pages) FROM book )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM authors WHERE pages < (SELECT AVG(pages) FROM authors) ORDER BY pages DESC;"
        ],
        "rule_sql": []
    },
    "861": {
        "db_id": "cs_semester",
        "question": "How many research assistants of Ogdon Zywicki have an average salary?",
        "ground_truth": "SELECT COUNT(T1.prof_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.first_name = 'Ogdon' AND T1.salary = 'med' AND T2.last_name = 'Zywicki'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM research_assistants \nWHERE supervisor = 'Ogdon Zywicki' \nAND salary > (SELECT AVG(salary) FROM research_assistants)"
        ],
        "rule_sql": []
    },
    "5063": {
        "db_id": "olympics",
        "question": "Calculate the average age of the competitors who participated in the 1924 Winter.",
        "ground_truth": "SELECT AVG(T2.age) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.games_name = '1924 Winter'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM competitors WHERE year = 1924 AND season = 'Winter';"
        ],
        "rule_sql": []
    },
    "8912": {
        "db_id": "cookbook",
        "question": "Among the recipes from The California Tree Fruit Agreement, calculate the percentage of sodium-free recipes.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.sodium < 5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.source = 'The California Tree Fruit Agreement'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM recipes WHERE source = 'The California Tree Fruit Agreement')) AS percentage\nFROM recipes \nWHERE source = 'The California Tree Fruit Agreement' AND sodium = 0;"
        ],
        "rule_sql": []
    },
    "665": {
        "db_id": "codebase_comments",
        "question": "Please provide a link to the most well-known repository's Github address.",
        "ground_truth": "SELECT Url FROM Repo WHERE Watchers = ( SELECT MAX(Watchers) FROM Repo )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT github_url FROM repositories ORDER BY stars DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "231": {
        "db_id": "book_publishing_company",
        "question": "Which titles has above average royalty rate? Give those title's name, type and price?",
        "ground_truth": "SELECT DISTINCT T1.title, T1.type, T1.price FROM titles AS T1 INNER JOIN roysched AS T2 ON T1.title_id = T2.title_id WHERE T2.royalty > ( SELECT CAST(SUM(royalty) AS REAL) / COUNT(title_id) FROM roysched )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, type, price FROM titles WHERE royalty > (SELECT AVG(royalty) FROM titles);"
        ],
        "rule_sql": []
    },
    "8359": {
        "db_id": "mondial_geo",
        "question": "Which nation's GDP is the lowest among those that are communist states?",
        "ground_truth": "SELECT T2.Country FROM politics AS T1 INNER JOIN economy AS T2 ON T1.Country = T2.Country WHERE T1.Government = 'Communist state' ORDER BY T2.GDP ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT nation FROM countries WHERE government = 'communist' ORDER BY gdp DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6056": {
        "db_id": "books",
        "question": "How many books were published in 2017?",
        "ground_truth": "SELECT COUNT(*) FROM book WHERE STRFTIME('%Y', publication_date) = '2017'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE published_year = 2018;"
        ],
        "rule_sql": []
    },
    "5295": {
        "db_id": "beer_factory",
        "question": "What is the average cost of root beers purchased for more than 2 dollars and sold in bottles?",
        "ground_truth": "SELECT AVG(T2.PurchasePrice) FROM rootbeer AS T1 INNER JOIN `transaction` AS T2 ON T1.RootBeerID = T2.RootBeerID INNER JOIN rootbeerbrand AS T3 ON T1.BrandID = T3.BrandID WHERE T1.ContainerType = 'Bottle' AND T2.PurchasePrice > 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(cost) FROM beverages WHERE type = 'root beer' AND cost > 2 AND container = 'bottle';"
        ],
        "rule_sql": []
    },
    "2989": {
        "db_id": "shakespeare",
        "question": "In the year 1500s, how many tragedies did Shakespeare write?",
        "ground_truth": "SELECT COUNT(id) FROM works WHERE GenreType = 'Tragedy' AND Date BETWEEN 1500 AND 1599",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM plays WHERE author = 'Shakespeare' AND genre = 'tragedy' AND year = 1500;"
        ],
        "rule_sql": []
    },
    "7434": {
        "db_id": "works_cycles",
        "question": "What is the average profit of all the products from the Clothing category?",
        "ground_truth": "SELECT SUM(T1.ListPrice - T1.StandardCost) / COUNT(T1.ProductID) FROM Product AS T1 INNER JOIN ProductSubcategory AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID INNER JOIN ProductCategory AS T3 ON T2.ProductCategoryID = T3.ProductCategoryID WHERE T3.Name = 'Clothing'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE category = 'Clothing';"
        ],
        "rule_sql": []
    },
    "5187": {
        "db_id": "address",
        "question": "What is the number of households in the \"FL-10\" district?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.district = 'FL-10' THEN 1 ELSE 0 END) FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM households WHERE district = 'FL-10';"
        ],
        "rule_sql": []
    },
    "3534": {
        "db_id": "authors",
        "question": "Among the papers with conference ID of 0, list down the authors of papers with a journal ID less than 100.",
        "ground_truth": "SELECT DISTINCT T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.ConferenceId = 0 AND T1.JournalId < 100",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM papers WHERE conference_id = 0 AND journal_id > 100;"
        ],
        "rule_sql": []
    },
    "5408": {
        "db_id": "sales",
        "question": "How many sales people are handling all the customers?",
        "ground_truth": "SELECT COUNT(EmployeeID) FROM Employees",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales_people WHERE customer_id IN (SELECT customer_id FROM customers);"
        ],
        "rule_sql": []
    },
    "147": {
        "db_id": "movie_platform",
        "question": "Who is the user who created the list titled 'Sound and Vision'? Was he a subcriber when he created the list?",
        "ground_truth": "SELECT T1.user_id, T1.user_subscriber FROM lists_users AS T1 INNER JOIN lists AS T2 ON T1.list_id = T2.list_id WHERE T2.list_title LIKE 'Sound and Vision'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.username, u.is_subscriber \nFROM users u \nJOIN lists l ON u.user_id = l.user_id \nWHERE l.title = 'Sound and Vision';"
        ],
        "rule_sql": []
    },
    "8936": {
        "db_id": "human_resources",
        "question": "In which city's office does Sandy Adams work at?",
        "ground_truth": "SELECT T2.locationcity FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID WHERE T1.lastname = 'Adams' AND T1.firstname = 'Sandy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM employees WHERE first_name = 'Sandy' AND last_name = 'Adams';"
        ],
        "rule_sql": []
    },
    "244": {
        "db_id": "retail_complains",
        "question": "How many complaints have the client Diesel Galloway filed?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Diesel' AND T1.last = 'Galloway'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE client_name = 'Diesel Galloway';"
        ],
        "rule_sql": []
    },
    "6238": {
        "db_id": "food_inspection_2",
        "question": "What is the inspection ID where the employee named \"David Hodges\" is currently employed in the \"Kamayan Express\" establishment?",
        "ground_truth": "SELECT T2.inspection_id FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no INNER JOIN employee AS T3 ON T2.employee_id = T3.employee_id WHERE T3.first_name = 'David' AND T3.last_name = 'Hodges' AND T1.dba_name = 'KAMAYAN EXPRESS'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_id FROM employees WHERE name = 'David Hodges' AND establishment = 'Kamayan Express';"
        ],
        "rule_sql": []
    },
    "9057": {
        "db_id": "bike_share_1",
        "question": "In 2015, what percentage of trips that had the subscription type was Customer and ended on a rainy day?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.events = 'Rain' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE SUBSTR(CAST(T2.date AS TEXT), -4) = '2015' AND T1.subscription_type = 'Customer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN subscription_type = 'Customer' AND weather_condition = 'rainy' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN subscription_type = 'Customer' THEN 1 END)) AS percentage\nFROM trips\nWHERE year = 2015;"
        ],
        "rule_sql": []
    },
    "4753": {
        "db_id": "legislator",
        "question": "Among the current legislators who have served for more than 6 terms, how many of them were born after 1960?",
        "ground_truth": "SELECT COUNT(CID) FROM ( SELECT T1.bioguide_id AS CID FROM current AS T1 INNER JOIN `current-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.birthday_bio >= '1960-01-01' GROUP BY T2.bioguide HAVING COUNT(T2.bioguide) > 6 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM legislators \nWHERE terms_served > 6 \nAND birth_year > 1960;"
        ],
        "rule_sql": []
    },
    "8453": {
        "db_id": "mondial_geo",
        "question": "Which desert in Kazakhstan is the largest?",
        "ground_truth": "SELECT T1.Name FROM desert AS T1 INNER JOIN geo_desert AS T2 ON T1.Name = T2.Desert INNER JOIN country AS T3 ON T3.Code = T2.Country WHERE T3.Name = 'Kazakstan' ORDER BY T1.Area DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM deserts WHERE country = 'Kazakhstan' ORDER BY area DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1082": {
        "db_id": "talkingdata",
        "question": "Please list the ages of all the users who use a Galaxy Note 2.",
        "ground_truth": "SELECT T2.age FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T2.device_id = T1.device_id WHERE T1.device_model = 'Galaxy Note 2'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM users WHERE phone_model = 'Galaxy Note 2';"
        ],
        "rule_sql": []
    },
    "688": {
        "db_id": "codebase_comments",
        "question": "What is the average processed time of the solution with a repository of 254 likes, 88 followers, and 254 watchers?",
        "ground_truth": "SELECT CAST(SUM(T2.ProcessedTime) AS REAL) / COUNT(T2.ProcessedTime) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Stars = 254 AND T1.Forks = 88 AND T1.Watchers = 254",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(processed_time) FROM solutions WHERE likes = 254 AND followers = 88 AND watchers = 254;"
        ],
        "rule_sql": []
    },
    "1869": {
        "db_id": "soccer_2016",
        "question": "Where did BR Doctrove come from?",
        "ground_truth": "SELECT T1.Country_Name FROM Country AS T1 INNER JOIN Umpire AS T2 ON T2.Umpire_Country = T1.Country_Id WHERE T2.Umpire_Name = 'BR Doctrove'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM players WHERE name = 'BR Doctrove';"
        ],
        "rule_sql": []
    },
    "8322": {
        "db_id": "mondial_geo",
        "question": "List all islands that are greater than the island on which Warwickshire is located.",
        "ground_truth": "SELECT DISTINCT Name FROM island WHERE Area > ( SELECT DISTINCT T3.Area FROM city AS T1 INNER JOIN locatedOn AS T2 ON T1.Name = T2.City INNER JOIN island AS T3 ON T3.Name = T2.Island WHERE T1.Province = 'Warwickshire' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT i1.name \nFROM islands i1, islands i2 \nWHERE i2.name = 'Warwickshire' \nAND i1.area > i2.area;"
        ],
        "rule_sql": []
    },
    "6698": {
        "db_id": "retails",
        "question": "Customer No.129301 made an order on 1996/7/27, what was the delivery time for the first part of that order?",
        "ground_truth": "SELECT JULIANDAY(T2.l_receiptdate) - JULIANDAY(T2.l_commitdate) FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_custkey = '129301' AND T1.o_orderdate = '1996-07-27'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DeliveryTime FROM Orders WHERE CustomerID = 129301 AND OrderDate = '1996/7/27' LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4842": {
        "db_id": "legislator",
        "question": "Provide the type and end date of the term of the legislator named John Vining.",
        "ground_truth": "SELECT T2.type, T2.end FROM historical AS T1 INNER JOIN `historical-terms` AS T2 ON T1.bioguide_id = T2.bioguide WHERE T1.first_name = 'John' AND T1.last_name = 'Vining'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT type, end_date FROM legislators WHERE name = 'John Vining';"
        ],
        "rule_sql": []
    },
    "5732": {
        "db_id": "language_corpus",
        "question": "How many words are repeated on the Llista de conflictes armats page?",
        "ground_truth": "SELECT occurrences FROM pages_words WHERE pid = ( SELECT pid FROM pages WHERE title = 'Llista de conflictes armats' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE page_title = 'Llista de conflictes armats' AND word_count > 1;"
        ],
        "rule_sql": []
    },
    "5791": {
        "db_id": "language_corpus",
        "question": "What is the word ID for the second word for the biwords pair with most repetitions?",
        "ground_truth": "SELECT w2nd FROM biwords WHERE occurrences = ( SELECT MAX(occurrences) FROM biwords )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word_id FROM biwords ORDER BY repetitions DESC LIMIT 1 OFFSET 1;"
        ],
        "rule_sql": []
    },
    "721": {
        "db_id": "trains",
        "question": "Which direction does the majority of the trains that have 3 cars are running?",
        "ground_truth": "SELECT T1.direction FROM trains AS T1 INNER JOIN ( SELECT train_id, COUNT(id) AS carsNum FROM cars GROUP BY train_id HAVING carsNum = 3 ) AS T2 ON T1.id = T2.train_id GROUP BY T1.direction",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT direction, COUNT(*) as count \nFROM trains \nWHERE cars = 3 \nGROUP BY direction \nORDER BY count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8861": {
        "db_id": "craftbeer",
        "question": "When compared to the total number of breweries in the US producing American Blonde Ale, how many in the state of Wisconsin produces American Blonde Ale? Indicate your answer in percentage (%).",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.state = 'WI', 1, 0)) AS REAL) * 100 / COUNT(T1.id) FROM beers AS T1 INNER JOIN breweries AS T2 ON T1.brewery_id = T2.id WHERE T1.style = 'American Blonde Ale'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100) AS percentage\nFROM breweries\nWHERE state = 'Wisconsin' AND beer_style = 'American Blonde Ale';"
        ],
        "rule_sql": []
    },
    "4474": {
        "db_id": "student_loan",
        "question": "How many unemployed students have payment due?",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN unemployed AS T2 ON T2.name = T1.name WHERE T1.bool = 'pos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed' AND payment_status = 'due';"
        ],
        "rule_sql": []
    },
    "4187": {
        "db_id": "simpson_episodes",
        "question": "Calculate the difference between the highest votes for episode and the lowest votes for episode.",
        "ground_truth": "SELECT MAX(votes) - MIN(votes) FROM Vote;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(votes) - MIN(votes) AS vote_difference FROM episodes;"
        ],
        "rule_sql": []
    },
    "8317": {
        "db_id": "mondial_geo",
        "question": "Among the independent countries, how many of them has a GDP per capita of over 5000?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN politics AS T2 ON T1.Code = T2.Country INNER JOIN economy AS T3 ON T3.Country = T2.Country WHERE T2.Independence IS NOT NULL AND T3.GDP > 5000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM countries WHERE independence = 'yes' AND gdp_per_capita > 5000;"
        ],
        "rule_sql": []
    },
    "306": {
        "db_id": "retail_complains",
        "question": "How many complaints were served in 5 minutes or less by DORIT and responded to the customer with an explanation, were made by phone?",
        "ground_truth": "SELECT COUNT(T1.`Complaint ID`) FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T1.ser_time < '00:05:00' AND T1.server = 'DORIT' AND T2.`Submitted via` = 'Phone' AND T2.`Company response to consumer` = 'Closed with explanation'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM complaints \nWHERE officer_name = 'DORIT' \nAND response_time <= 5 \nAND response_type = 'explanation' \nAND complaint_channel = 'phone';"
        ],
        "rule_sql": []
    },
    "9010": {
        "db_id": "bike_share_1",
        "question": "What is the maximum dew point in Fahrenheit degree on 7/15/2014 in the area with a zip code of 94301?",
        "ground_truth": "SELECT DISTINCT CASE WHEN date = '7/15/2014' AND zip_code = 94301 THEN max_dew_point_f END FROM weather",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(dew_point) FROM weather_data WHERE date = '2014-07-15' AND zip_code = 94301;"
        ],
        "rule_sql": []
    },
    "9280": {
        "db_id": "movie_3",
        "question": "What is the title of the animated films that have the shortest length?",
        "ground_truth": "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id ORDER BY T1.length LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE length = (SELECT MIN(length) FROM films) AND type = 'animated';"
        ],
        "rule_sql": []
    },
    "172": {
        "db_id": "book_publishing_company",
        "question": "Among the titles with royalty percentage, which title has the greatest royalty percentage. State it's minimum range to enjoy this royalty percentage.",
        "ground_truth": "SELECT T1.title, T2.lorange FROM titles AS T1 INNER JOIN roysched AS T2 ON T1.title_id = T2.title_id ORDER BY T2.royalty DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, MAX(royalty) AS max_royalty, MIN(royalty_range) AS min_range FROM titles WHERE royalty IS NOT NULL GROUP BY title ORDER BY max_royalty DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8436": {
        "db_id": "mondial_geo",
        "question": "Which two nations are separated from one another by the longest border? Please include the entire names of the nations in your answer.",
        "ground_truth": "SELECT Country1, Country2 FROM borders ORDER BY Length DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country1, country2 FROM borders ORDER BY length DESC LIMIT 2;"
        ],
        "rule_sql": []
    },
    "3204": {
        "db_id": "donor",
        "question": "Which donor has donated the most for a project whose main subject area is Literacy & Language? Please give his or her ID.",
        "ground_truth": "SELECT T2.donor_acctid FROM projects AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.primary_focus_area = 'Literacy & Language' ORDER BY T2.donation_total DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT donor_id FROM donations WHERE project_id IN (SELECT project_id FROM projects WHERE main_subject_area = 'Literacy & Language') GROUP BY donor_id ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5783": {
        "db_id": "language_corpus",
        "question": "Which biwords pair has a higher occurrence, \"\u00e0bac-xin\u00e8s\" or \"\u00e0bac-grec\"?",
        "ground_truth": "SELECT CASE WHEN ( SELECT occurrences FROM biwords WHERE w1st = ( SELECT wid FROM words WHERE word = '\u00e0bac' ) AND w2nd = ( SELECT wid FROM words WHERE word = 'xin\u00e8s' ) ) > ( SELECT occurrences FROM biwords WHERE w1st = ( SELECT wid FROM words WHERE word = '\u00e0bac' ) AND w2nd = ( SELECT wid FROM words WHERE word = 'grec' ) ) THEN '\u00e0bac-xin\u00e8s' ELSE '\u00e0bac-grec' END AS CALUS FROM words LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN COUNT(CASE WHEN biword = '\u00e0bac-xin\u00e8s' THEN 1 END) > COUNT(CASE WHEN biword = '\u00e0bac-grec' THEN 1 END) \n        THEN '\u00e0bac-xin\u00e8s has higher occurrence' \n        ELSE '\u00e0bac-grec has higher occurrence' \n    END as result\nFROM biwords_table;"
        ],
        "rule_sql": []
    },
    "8493": {
        "db_id": "mondial_geo",
        "question": "Which country has the widest range of religious practices?",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN religion AS T2 ON T1.Code = T2.Country GROUP BY T1.Name ORDER BY COUNT(DISTINCT T2.Name) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(DISTINCT religion) as num_religions \nFROM religious_practices \nGROUP BY country \nORDER BY num_religions DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "9117": {
        "db_id": "movie_3",
        "question": "Please list the titles of all the films starring the actor PENELOPE GUINESS.",
        "ground_truth": "SELECT T2.title FROM film_actor AS T1 INNER JOIN film AS T2 ON T1.film_id = T2.film_id INNER JOIN actor AS T3 ON T1.actor_id = T3.actor_id WHERE T3.first_name = 'PENELOPE' AND T3.last_name = 'GUINESS'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM film WHERE actor = 'PENELOPE GUINESS';"
        ],
        "rule_sql": []
    },
    "8734": {
        "db_id": "chicago_crime",
        "question": "What are the neighborhoods that are located in the North Center community area?",
        "ground_truth": "SELECT T2.neighborhood_name FROM Community_Area AS T1 INNER JOIN Neighborhood AS T2 ON T1.community_area_no = T2.community_area_no WHERE T1.community_area_name = 'North Center'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT neighborhood FROM neighborhoods WHERE community_area = 'North Center';"
        ],
        "rule_sql": []
    },
    "2013": {
        "db_id": "soccer_2016",
        "question": "What are the names of players that have run scored less than 3?",
        "ground_truth": "SELECT T1.Player_Name FROM Player AS T1 INNER JOIN Player_Match AS T2 ON T1.Player_Id = T2.Player_Id INNER JOIN Batsman_Scored AS T3 ON T2.Match_ID = T3.Match_ID WHERE T3.Runs_Scored < 3 GROUP BY T1.Player_Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE runs_scored > 3;"
        ],
        "rule_sql": []
    },
    "4515": {
        "db_id": "student_loan",
        "question": "What is the average absent month for a unemployed male students?",
        "ground_truth": "SELECT AVG(T2.month) AS avg FROM unemployed AS T1 INNER JOIN longest_absense_from_school AS T2 ON T2.name = T1.name INNER JOIN male AS T3 ON T3.name = T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(absent_month) FROM students WHERE employment_status = 'unemployed' AND gender = 'male';"
        ],
        "rule_sql": []
    },
    "2635": {
        "db_id": "regional_sales",
        "question": "Which sales team id has the highest number of orders in 2018?",
        "ground_truth": "SELECT _SalesTeamID FROM `Sales Orders` WHERE OrderDate LIKE '%/%/18' GROUP BY _SalesTeamID ORDER BY COUNT(_SalesTeamID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_id, COUNT(*) as order_count \nFROM orders \nWHERE order_date LIKE '2018%' \nGROUP BY team_id \nORDER BY order_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3648": {
        "db_id": "authors",
        "question": "Who are the authors of the paper \"Determination of Planetary Meteorology from Aerobot Flight Sensors\"?",
        "ground_truth": "SELECT T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Title = 'Determination of Planetary Meteorology FROM Aerobot Flight Sensors'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM authors WHERE paper_title = 'Determination of Planetary Meteorology from Aerobot Flight Sensors';"
        ],
        "rule_sql": []
    },
    "1904": {
        "db_id": "soccer_2016",
        "question": "Give the name of the venue where the most number of matches are held.",
        "ground_truth": "SELECT T2.Venue_Name FROM `Match` AS T1 INNER JOIN Venue AS T2 ON T1.Venue_Id = T2.Venue_Id GROUP BY T2.Venue_Name ORDER BY COUNT(T2.Venue_Id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT venue_name FROM matches GROUP BY venue_name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3226": {
        "db_id": "donor",
        "question": "How many schools which have suburban metro are there in Bethlehem?",
        "ground_truth": "SELECT COUNT(schoolid) FROM projects WHERE school_city = 'Bethlehem' AND school_metro = 'suburban'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE metro = 'suburban' AND city = 'Bethlehem';"
        ],
        "rule_sql": []
    },
    "8444": {
        "db_id": "mondial_geo",
        "question": "How many Italian regions are bordered by the Mediterranean Sea? How deep is the Mediterranean Sea?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.province), T3.Depth FROM country AS T1 INNER JOIN located AS T2 ON T1.Code = T2.Country INNER JOIN sea AS T3 ON T3.Name = T2.Sea WHERE T1.Code = 'I' AND T3.Name = 'Mediterranean Sea' GROUP BY T3.Depth",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS region_count, MAX(depth) AS max_depth \nFROM regions \nWHERE country = 'Italy' AND sea = 'Mediterranean Sea';"
        ],
        "rule_sql": []
    },
    "4177": {
        "db_id": "simpson_episodes",
        "question": "Write down the title and summary of the episode with the keyword 'eviction.'",
        "ground_truth": "SELECT T1.title, T1.summary FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T2.keyword = 'eviction';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, summary FROM episodes WHERE keyword = 'eviction';"
        ],
        "rule_sql": []
    },
    "1013": {
        "db_id": "computer_student",
        "question": "List the advisor IDs for students with eighth year of program and position status in faculty of those professors.",
        "ground_truth": "SELECT T1.p_id_dummy, T2.hasPosition FROM advisedBy AS T1 INNER JOIN person AS T2 ON T1.p_id = T2.p_id WHERE T2.yearsInProgram = 'Year_8'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT advisor_id FROM students WHERE year = 8 AND position = 'faculty';"
        ],
        "rule_sql": []
    },
    "5158": {
        "db_id": "address",
        "question": "Among the cities with area code 608, how many cities implement daylight savings?",
        "ground_truth": "SELECT COUNT(T2.city) FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.area_code = 608 AND T2.daylight_savings = 'Yes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cities WHERE area_code = 608 AND daylight_savings = 'yes';"
        ],
        "rule_sql": []
    },
    "6163": {
        "db_id": "food_inspection_2",
        "question": "Provide the inspection ID of the establishment named \"PIZZA RUSTICA, INC.\"",
        "ground_truth": "SELECT DISTINCT T2.inspection_id FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.dba_name = 'PIZZA RUSTICA, INC'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT inspection_id FROM establishments WHERE name = 'PIZZA RUSTICA, INC.'"
        ],
        "rule_sql": []
    },
    "3780": {
        "db_id": "public_review_platform",
        "question": "How many \"5\" star reviews does the Yelp business No. \"10682\" get?",
        "ground_truth": "SELECT COUNT(review_length) FROM Reviews WHERE business_id = 10682 AND review_stars = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM reviews WHERE business_id = 10682 AND stars = '5';"
        ],
        "rule_sql": []
    },
    "5676": {
        "db_id": "shipping",
        "question": "What is the name of the customer of ship ID 1147?",
        "ground_truth": "SELECT T2.cust_name FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE T1.ship_id = '1147'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name FROM customers WHERE ship_id = 1147;"
        ],
        "rule_sql": []
    },
    "1799": {
        "db_id": "soccer_2016",
        "question": "What is the name of the player who won the \"man of the match\" award in the match on 2008/4/18?",
        "ground_truth": "SELECT T2.Player_Name FROM Match AS T1 INNER JOIN Player AS T2 ON T2.Player_Id = T1.Man_of_the_Match WHERE T1.Match_Date = '2008-04-18'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM matches WHERE match_date = '2008/4/18' AND award = 'man of the match'"
        ],
        "rule_sql": []
    },
    "9353": {
        "db_id": "movie_3",
        "question": "List down email address of customers who were attended by staff with ID 2.",
        "ground_truth": "SELECT DISTINCT T1.email FROM customer AS T1 INNER JOIN rental AS T2 ON T1.customer_id = T2.customer_id WHERE T2.staff_id = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT email FROM customers WHERE staff_id = 2;"
        ],
        "rule_sql": []
    },
    "589": {
        "db_id": "codebase_comments",
        "question": "Which method has the summary \"Write a command to the log\"?",
        "ground_truth": "SELECT Name FROM Method WHERE Summary = 'Write a command to the log'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT method FROM log_methods WHERE summary = 'Write a command to the log';"
        ],
        "rule_sql": []
    },
    "9050": {
        "db_id": "bike_share_1",
        "question": "How many trips which start station and end station are the same?",
        "ground_truth": "SELECT SUM(IIF(start_station_id = end_station_id, 1, 0)) FROM trip",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM trips WHERE start_station_id = end_station_id;"
        ],
        "rule_sql": []
    },
    "1014": {
        "db_id": "computer_student",
        "question": "List any five of course IDs with professor IDs who taught master courses.",
        "ground_truth": "SELECT T1.course_id, T2.p_id FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE T1.courseLevel = 'Level_500' LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT course_id, professor_id FROM courses WHERE course_level = 'master' LIMIT 5;"
        ],
        "rule_sql": []
    },
    "4431": {
        "db_id": "student_loan",
        "question": "List out the number of female students who enlisted in the air force.",
        "ground_truth": "SELECT COUNT(name) FROM enlist WHERE organ = 'air_force' AND name NOT IN ( SELECT name FROM male )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'male' AND branch = 'air force';"
        ],
        "rule_sql": []
    },
    "545": {
        "db_id": "movies_4",
        "question": "List the names of camera supervisors in the crew.",
        "ground_truth": "SELECT T1.person_name FROM person AS T1 INNER JOIN movie_crew AS T2 ON T1.person_id = T2.person_id WHERE T2.job = 'Camera Supervisor'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM crew WHERE role = 'camera operator';"
        ],
        "rule_sql": []
    },
    "9159": {
        "db_id": "movie_3",
        "question": "Where does the staff Jon Stephens live?",
        "ground_truth": "SELECT T1.address, T1.address2 FROM address AS T1 INNER JOIN staff AS T2 ON T1.address_id = T2.address_id WHERE T2.first_name = 'Jon' AND T2.last_name = 'Stephens'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM staff WHERE first_name = 'Jon' AND last_name = 'Stephens';"
        ],
        "rule_sql": []
    },
    "7351": {
        "db_id": "works_cycles",
        "question": "Which department, altogether, has the most personnel who work the evening shift?",
        "ground_truth": "SELECT T3.Name FROM EmployeeDepartmentHistory AS T1 INNER JOIN Shift AS T2 ON T1.ShiftId = T2.ShiftId INNER JOIN Department AS T3 ON T1.DepartmentID = T3.DepartmentID WHERE T2.Name = 'Night' GROUP BY T3.Name ORDER BY COUNT(T1.BusinessEntityID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, COUNT(*) as total_personnel\nFROM employees\nWHERE shift = 'evening'\nGROUP BY department\nORDER BY total_personnel DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7699": {
        "db_id": "hockey",
        "question": "Which coach had the highest winning rates in the 2009 season? What's coach's nickname.",
        "ground_truth": "SELECT T2.coachID, T1.nameNick FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID WHERE T2.year = 2009 ORDER BY CAST(T2.W AS REAL) / (T2.W + T2.L) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_name, nickname, (wins / (wins + losses)) AS win_rate \nFROM coaches \nWHERE season = 2009 \nORDER BY win_rate DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2161": {
        "db_id": "world_development_indicators",
        "question": "List down 10 country codes and it's short names.",
        "ground_truth": "SELECT CountryCode, ShortName FROM Country LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code, short_name FROM countries LIMIT 10;"
        ],
        "rule_sql": []
    },
    "807": {
        "db_id": "social_media",
        "question": "What is the gender of the user whose tweet got 535 retweets?",
        "ground_truth": "SELECT T2.Gender FROM twitter AS T1 INNER JOIN user AS T2 ON T1.UserID = T2.UserID WHERE T1.RetweetCount = 535",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE retweet_count = 535;"
        ],
        "rule_sql": []
    },
    "2114": {
        "db_id": "world_development_indicators",
        "question": "Please write down the footnote descriptions of Albania in 1981.",
        "ground_truth": "SELECT DISTINCT T1.Description FROM FootNotes AS T1 INNER JOIN Country AS T2 ON T1.Countrycode = T2.CountryCode WHERE T1.Year = 'YR1981' AND T2.ShortName = 'Albania'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT footnote FROM countries WHERE name = 'Albania' AND year = 1981"
        ],
        "rule_sql": []
    },
    "2202": {
        "db_id": "world_development_indicators",
        "question": "Which countries in the upper middle income category still have unfinished external debt reporting? Please provide the country codes in your answer.",
        "ground_truth": "SELECT CountryCode FROM Country WHERE IncomeGroup = 'Upper middle income' AND ExternalDebtReportingStatus = 'Preliminary'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_code FROM countries WHERE income_category = 'upper middle income' AND external_debt_reporting = 'unfinished';"
        ],
        "rule_sql": []
    },
    "3291": {
        "db_id": "donor",
        "question": "In what percentage of counties has the ABC Read project been launched?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.title LIKE 'ABC Read' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.school_county) FROM projects AS T1 INNER JOIN essays AS T2 ON T1.projectid = T2.projectid",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM counties) AS percentage FROM abc_read_projects;"
        ],
        "rule_sql": []
    },
    "3563": {
        "db_id": "authors",
        "question": "Among papers that were published in 2005, provide the author name of paper with key words of \"LOAD; IDE; SNP; haplotype; asso- ciation studies\".",
        "ground_truth": "SELECT T2.Name FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T1.Year = 2005 AND T1.Keyword = 'KEY WORDS: LOAD IDE SNP haplotype asso- ciation studies'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT author_name FROM papers WHERE year = 2005 AND keywords = 'LOAD; IDE; SNP; haplotype; asso- ciation studies';"
        ],
        "rule_sql": []
    },
    "3717": {
        "db_id": "college_completion",
        "question": "Give the post name of \"Idaho\" state.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE WHEN state = 'Idaho' THEN state_post ELSE NULL END AS T FROM state_sector_details ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM posts WHERE state = 'Idaho';"
        ],
        "rule_sql": []
    },
    "1542": {
        "db_id": "synthea",
        "question": "List down the full name of Irish patients diagnosed with the prevalent diseases that have an occurrence greater than the 96% of the average occurrences of all conditions.",
        "ground_truth": "SELECT DISTINCT T2.first, T2.last FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient INNER JOIN all_prevalences AS T3 ON T1.DESCRIPTION = T3.ITEM WHERE T2.ethnicity = 'irish' AND 100 * CAST(T3.OCCURRENCES AS REAL) / ( SELECT AVG(OCCURRENCES) FROM all_prevalences ) > 96",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.first_name || ' ' || p.last_name AS full_name\nFROM patients p\nJOIN diagnoses d ON p.patient_id = d.patient_id\nJOIN conditions c ON d.condition_id = c.condition_id\nWHERE p.nationality = 'Irish'\nAND c.occurrence > (SELECT AVG(occurrence) * 0.96 FROM conditions)\nGROUP BY p.patient_id;"
        ],
        "rule_sql": []
    },
    "4778": {
        "db_id": "legislator",
        "question": "List the official full names of 10 legislators who have a YouTube account but no Instagram account.",
        "ground_truth": "SELECT T2.official_full_name FROM `social-media` AS T1 INNER JOIN current AS T2 ON T1.bioguide = T2.bioguide_id WHERE T1.facebook IS NOT NULL AND (T1.instagram IS NULL OR T1.instagram = '') LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name FROM legislators WHERE youtube_account IS NOT NULL AND instagram_account IS NULL LIMIT 10;"
        ],
        "rule_sql": []
    },
    "7163": {
        "db_id": "works_cycles",
        "question": "Did Rachel Valdez complete her sales task?",
        "ground_truth": "SELECT T1.Bonus FROM SalesPerson AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T2.FirstName = 'Rachel' AND T2.LastName = 'Valdez'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM employees WHERE name = 'Rachel Valdez' AND task_status = 'completed';"
        ],
        "rule_sql": []
    },
    "1245": {
        "db_id": "law_episode",
        "question": "Please list all the keywords of the episode \"Refuge: Part 1\".",
        "ground_truth": "SELECT T2.keyword FROM Episode AS T1 INNER JOIN Keyword AS T2 ON T1.episode_id = T2.episode_id WHERE T1.title = 'Refuge: Part 1'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword FROM episodes WHERE title = 'Refuge: Part 1'"
        ],
        "rule_sql": []
    },
    "9105": {
        "db_id": "movie_3",
        "question": "Please list the titles of the films that are released in 2006 and have a rental rate of $2.99.",
        "ground_truth": "SELECT title FROM film WHERE release_year = 2006 AND rental_rate = 2.99",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE release_year = 2006 AND rental_rate = 4.99;"
        ],
        "rule_sql": []
    },
    "1286": {
        "db_id": "law_episode",
        "question": "Who is the narrator of the \"Flight\" episode?",
        "ground_truth": "SELECT T3.name FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE T1.title = 'Flight' AND T2.role = 'Narrator'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT narrator FROM episodes WHERE title = 'Flight';"
        ],
        "rule_sql": []
    },
    "8450": {
        "db_id": "mondial_geo",
        "question": "Please name any three sovereign nations that have been governed by the republic since 1991.",
        "ground_truth": "SELECT country FROM politics WHERE government = 'republic' AND STRFTIME('%Y', independence) >= '1991' AND country IN ( SELECT country FROM country ) ORDER BY independence LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE government_type = 'republic' AND year_established <= 1991 LIMIT 3;"
        ],
        "rule_sql": []
    },
    "5740": {
        "db_id": "language_corpus",
        "question": "What number of words are there on revision page 27457362?",
        "ground_truth": "SELECT words FROM pages WHERE revision = 27457362",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM words WHERE page_id = 27457362;"
        ],
        "rule_sql": []
    },
    "8962": {
        "db_id": "human_resources",
        "question": "How many employees whose performance is poor have a salary of over $50,000 per year?",
        "ground_truth": "SELECT COUNT(*) FROM employee WHERE performance = 'Poor' AND CAST(REPLACE(SUBSTR(salary, 4), ',', '') AS REAL) > 50000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE performance = 'poor' AND salary > 50000;"
        ],
        "rule_sql": []
    },
    "4040": {
        "db_id": "public_review_platform",
        "question": "Does the length of the tip influence the number of likes for hotel and travel business category?",
        "ground_truth": "SELECT T3.tip_length, SUM(T3.likes) AS likes FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Tips AS T3 ON T2.business_id = T3.business_id WHERE T1.category_name = 'Hotels & Travel' GROUP BY T3.tip_length",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(likes) as avg_likes, LENGTH(tip) as tip_length \nFROM business_tips \nWHERE business_category = 'hotel' OR business_category = 'travel' \nGROUP BY tip_length \nORDER BY tip_length;"
        ],
        "rule_sql": []
    },
    "8984": {
        "db_id": "human_resources",
        "question": "Mention the full name, hired date and performance status of the employee whose location is in Utah state.",
        "ground_truth": "SELECT T1.firstname, T1.lastname, T1.hiredate, T1.performance FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID WHERE T2.state = 'UT'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name, hire_date, performance_status FROM employees WHERE state = 'Utah';"
        ],
        "rule_sql": []
    },
    "6738": {
        "db_id": "retails",
        "question": "List the suppliers' names which supplied smoke red pale saddle plum.",
        "ground_truth": "SELECT T3.s_name FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey INNER JOIN supplier AS T3 ON T2.ps_suppkey = T3.s_suppkey WHERE T1.p_name = 'smoke red pale saddle plum'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT supplier_name FROM suppliers WHERE color = 'smoke red pale saddle plum';"
        ],
        "rule_sql": []
    },
    "1560": {
        "db_id": "car_retails",
        "question": "Please calculate the total value of Motorcycles orders.",
        "ground_truth": "SELECT SUM(T1.quantityOrdered * T1.priceEach) FROM orderdetails AS T1 INNER JOIN products AS T2 ON T1.productCode = T2.productCode WHERE T2.productLine = 'Motorcycles'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) FROM orders WHERE category = 'Cars';"
        ],
        "rule_sql": []
    },
    "1254": {
        "db_id": "law_episode",
        "question": "Who was credited as \"technical advisor\" in the episode titled \"Cherished\"?",
        "ground_truth": "SELECT T3.name FROM Episode AS T1 INNER JOIN Credit AS T2 ON T1.episode_id = T2.episode_id INNER JOIN Person AS T3 ON T3.person_id = T2.person_id WHERE T1.title = 'Cherished' AND T2.credited = 'true' AND T2.role = 'technical advisor'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM people JOIN credits ON people.id = credits.person_id JOIN episodes ON credits.episode_id = episodes.id WHERE episodes.title = 'Cherished' AND credits.role = 'director';"
        ],
        "rule_sql": []
    },
    "5937": {
        "db_id": "books",
        "question": "How many orders does the book \"O Xar\u00e1\" have?",
        "ground_truth": "SELECT COUNT(*) FROM book AS T1 INNER JOIN order_line AS T2 ON T1.book_id = T2.book_id WHERE T1.title = 'O Xar\u00e1'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE title = 'O Xar\u00e1';"
        ],
        "rule_sql": []
    },
    "4529": {
        "db_id": "student_loan",
        "question": "Calculate the ratio of disabled students who have never been absent from school.",
        "ground_truth": "SELECT 100 * SUM(IIF(T2.month = 0, 1, 0)) AS num FROM disabled AS T1 INNER JOIN longest_absense_from_school AS T2 ON T1.name = T2.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) / (SELECT COUNT(*) FROM students WHERE disabled = 1) AS ratio FROM students WHERE disabled = 1 AND total_absences = 0;"
        ],
        "rule_sql": []
    },
    "9127": {
        "db_id": "movie_3",
        "question": "Please list the titles of all the films under the category of \"Horror\" and has a rental rate of $2.99.",
        "ground_truth": "SELECT T1.title FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T3.name = 'Horror' AND T1.rental_rate = 2.99",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE category = 'Horror' AND rental_rate = 2.99;"
        ],
        "rule_sql": []
    },
    "1496": {
        "db_id": "synthea",
        "question": "What condition forced Mrs. Joye Homenick to seek medical attention in 2017?",
        "ground_truth": "SELECT T2.DESCRIPTION FROM patients AS T1 INNER JOIN conditions AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Joye' AND T1.last = 'Homenick' AND strftime('%Y', T2.START) = '2017'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT condition FROM medical_records WHERE patient_name = 'Mrs. Joye Homenick' AND year = 2017;"
        ],
        "rule_sql": []
    },
    "4207": {
        "db_id": "simpson_episodes",
        "question": "Among the episodes aired on April of 2009, how many episodes won an award?",
        "ground_truth": "SELECT COUNT(T1.episode_id) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE SUBSTR(T1.year, 1, 4) = '2009' AND T2.air_date LIKE '2009-04%';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE air_date LIKE '2009-04%' AND award_won = 'yes';"
        ],
        "rule_sql": []
    },
    "7217": {
        "db_id": "works_cycles",
        "question": "List all the purchase order ids of the vendor with a below average rating.",
        "ground_truth": "SELECT T2.PurchaseOrderID FROM Vendor AS T1 INNER JOIN PurchaseOrderHeader AS T2 ON T1.BusinessEntityID = T2.VendorID WHERE T1.CreditRating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT purchase_order_id \nFROM purchase_orders \nWHERE vendor_id IN (\n    SELECT vendor_id \n    FROM vendors \n    WHERE rating > (SELECT AVG(rating) FROM vendors)\n)"
        ],
        "rule_sql": []
    },
    "8252": {
        "db_id": "mondial_geo",
        "question": "The lake with the highest altitude is located in which city?",
        "ground_truth": "SELECT T2.City FROM lake AS T1 LEFT JOIN located AS T2 ON T2.Lake = T1.Name ORDER BY T1.Altitude DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM lakes ORDER BY altitude ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1226": {
        "db_id": "talkingdata",
        "question": "Which behavior category does user number 5902120154267990000 belong to?",
        "ground_truth": "SELECT T1.category FROM label_categories AS T1 INNER JOIN app_labels AS T2 ON T1.label_id = T2.label_id WHERE T2.app_id = 5902120154267990000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT behavior_category FROM users WHERE user_id = 5902120154267990000"
        ],
        "rule_sql": []
    },
    "5741": {
        "db_id": "language_corpus",
        "question": "What is the percentage of words in the Catalan language that have a repetition of more than 16,000 times?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN occurrences > 16000 THEN lid ELSE NULL END) AS REAL) * 100 / COUNT(lid) FROM langs_words",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM words)) AS percentage\nFROM words \nWHERE language = 'Catalan' AND repetition_count > 16000;"
        ],
        "rule_sql": []
    },
    "5672": {
        "db_id": "shipping",
        "question": "Give the annual revenue of the customer of ship ID 1047.",
        "ground_truth": "SELECT T2.annual_revenue FROM shipment AS T1 INNER JOIN customer AS T2 ON T1.cust_id = T2.cust_id WHERE T1.ship_id = '1047'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) AS annual_revenue FROM orders WHERE customer_id = 1047"
        ],
        "rule_sql": []
    },
    "5066": {
        "db_id": "olympics",
        "question": "Provide the competitors' names who joined the 2000 Summer.",
        "ground_truth": "SELECT T3.full_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T1.games_name = '2000 Summer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM competitors WHERE year = 2000 AND season = 'Summer';"
        ],
        "rule_sql": []
    },
    "3856": {
        "db_id": "public_review_platform",
        "question": "Among the Yelp_Businesses which are still running, how many of them fall under the category of \"Food\"?",
        "ground_truth": "SELECT COUNT(T3.business_id) FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business AS T3 ON T2.business_id = T3.business_id INNER JOIN Tips AS T4 ON T3.business_id = T4.business_id WHERE T1.category_name LIKE 'Food' AND T3.active LIKE 'TRUE'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Yelp_Businesses WHERE is_open = 1 AND category = 'Food';"
        ],
        "rule_sql": []
    },
    "3306": {
        "db_id": "donor",
        "question": "Among the technology items, what percentage of them are from Best Buy for Business? Provide the date of the project related to those items.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.vendor_name = 'Best Buy for Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.projectid) FROM resources AS T1 INNER JOIN projects AS T2 ON T1.projectid = T2.projectid WHERE T1.project_resource_type = 'Technology' UNION ALL SELECT DISTINCT T1.date_posted FROM projects AS T1 INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE T2.vendor_name = 'Best Buy for Business' AND T2.project_resource_type = 'Technology'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN store = 'Best Buy for Business' THEN 1 END) * 100.0 / COUNT(*)) AS percentage,\n    project_date\nFROM technology_items\nWHERE category = 'technology'\nGROUP BY project_date\nORDER BY percentage DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "7496": {
        "db_id": "image_and_language",
        "question": "Give the number of samples in image no.2377985 whose attribute is electrical.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.ATT_CLASS = 'white' THEN 1 ELSE 0 END) FROM IMG_OBJ_ATT AS T1 INNER JOIN ATT_CLASSES AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T1.IMG_ID = 2347915",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM samples WHERE image_id = 2377985 AND attribute = 'electrical';"
        ],
        "rule_sql": []
    },
    "5277": {
        "db_id": "beer_factory",
        "question": "Which brand of root beer was highly rated by customers?",
        "ground_truth": "SELECT T1.BrandName FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T2.StarRating = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand FROM root_beer_reviews WHERE rating < 3.0 ORDER BY rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3275": {
        "db_id": "donor",
        "question": "What percentage of projects that have not received a cash donation have received a portion of a donation included corporate sponsored giftcard?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN payment_included_campaign_gift_card = 't' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(donationid) FROM donations WHERE payment_method = 'no_cash_received'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN d.donation_type = 'corporate sponsored giftcard' AND p.cash_donation_received = 0 THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN p.cash_donation_received = 0 THEN 1 END)) AS percentage\nFROM projects p\nLEFT JOIN donations d ON p.project_id = d.project_id\nWHERE p.cash_donation_received = 0;"
        ],
        "rule_sql": []
    },
    "7868": {
        "db_id": "world",
        "question": "List all the official and unofficial languages used by the country that declared its independence in 1830.",
        "ground_truth": "SELECT T2.Language, T2.IsOfficial FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.IndepYear = 1830 GROUP BY T2.Language, T2.IsOfficial",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT language, is_official FROM country_language WHERE country_id = (SELECT id FROM country WHERE independence_year = 1830);"
        ],
        "rule_sql": []
    },
    "1188": {
        "db_id": "talkingdata",
        "question": "How many users who are under 30 years old use device model of Galaxy Note 2?",
        "ground_truth": "SELECT COUNT(T1.device_id) FROM gender_age AS T1 INNER JOIN phone_brand_device_model2 AS T2 ON T1.device_id = T2.device_id WHERE T2.device_model = 'Galaxy Note 2' AND T1.age < 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE age < 30 AND device_model = 'Galaxy Note 2';"
        ],
        "rule_sql": []
    },
    "6060": {
        "db_id": "books",
        "question": "How many pages does 'Seaward' have?",
        "ground_truth": "SELECT num_pages FROM book WHERE title = 'Seaward'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM books WHERE title = 'Seaward';"
        ],
        "rule_sql": []
    },
    "8538": {
        "db_id": "software_company",
        "question": "What is the geographic identifier and income of the oldest customer?",
        "ground_truth": "SELECT T1.GEOID, T2.INCOME_K FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID ORDER BY T1.age DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_id, income FROM customers ORDER BY age ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8692": {
        "db_id": "chicago_crime",
        "question": "Calculate the difference in the average number of vehicular hijackings and aggravated vehicular hijackings in the districts.",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T1.secondary_description = 'VEHICULAR HIJACKING' THEN T1.iucr_no END) AS REAL) / CAST(COUNT(DISTINCT CASE WHEN T1.secondary_description = 'VEHICULAR HIJACKING' THEN T3.district_name END) AS REAL) - CAST(COUNT(CASE WHEN T1.secondary_description = 'AGGRAVATED VEHICULAR HIJACKING' THEN T1.iucr_no END) AS REAL) / CAST(COUNT(DISTINCT CASE WHEN T1.secondary_description = 'AGGRAVATED VEHICULAR HIJACKING' THEN T3.district_name END) AS REAL), 4) AS \"difference\" FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T2.iucr_no = T1.iucr_no INNER JOIN District AS T3 ON T3.district_no = T2.district_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT district, AVG(vehicular_hijackings) - AVG(aggravated_vehicular_hijackings) AS difference FROM crimes GROUP BY district;"
        ],
        "rule_sql": []
    },
    "3334": {
        "db_id": "video_games",
        "question": "Name of the publisher of the game id 10031.",
        "ground_truth": "SELECT T2.publisher_name FROM game_publisher AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.game_id = 10031",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT game_name FROM publishers WHERE game_id = 10031;"
        ],
        "rule_sql": []
    },
    "7230": {
        "db_id": "works_cycles",
        "question": "Which territory has the most customers as of 9/12/2014?",
        "ground_truth": "SELECT TerritoryID FROM Customer WHERE ModifiedDate < '2014-12-09' GROUP BY TerritoryID ORDER BY COUNT(TerritoryID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT TerritoryID, COUNT(CustomerID) as CustomerCount \nFROM Customers \nWHERE CreatedDate = '2014-09-12' \nGROUP BY TerritoryID \nORDER BY CustomerCount DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "472": {
        "db_id": "movies_4",
        "question": "What is the percentage of romance films among films produced in India in 2015?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T4.genre_name = 'Romance' THEN T1.movie_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_genres AS T2 ON T1.movie_id = T2.movie_id INNER JOIN production_COUNTry AS T3 ON T1.movie_id = T3.movie_id INNER JOIN genre AS T4 ON T2.genre_id = T4.genre_id INNER JOIN COUNTry AS T5 ON T3.COUNTry_id = T5.COUNTry_id WHERE T5.COUNTry_name = 'India' AND T1.release_date BETWEEN '2015-01-01' AND '2015-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN genre = 'Romance' THEN 1 END) * 100.0 / COUNT(*)) AS romance_percentage\nFROM films\nWHERE country = 'India' AND year = 2015;"
        ],
        "rule_sql": []
    },
    "5851": {
        "db_id": "airline",
        "question": "What is the percentage of flights from Los Angeles International airport that were cancelled due to a type C cancellation code?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.CANCELLATION_CODE = 'C' THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Airports AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.ORIGIN WHERE T2.FL_DATE = '2018/8/15' AND T2.CANCELLATION_CODE IS NOT NULL AND T1.Description = 'Los Angeles, CA: Los Angeles International'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM flights WHERE origin = 'LAX')) AS percentage\nFROM flights \nWHERE origin = 'LAX' AND cancelled = 1 AND cancellation_code = 'C';"
        ],
        "rule_sql": []
    },
    "927": {
        "db_id": "cs_semester",
        "question": "What is the credit of the course named \"Computer Vision\"?",
        "ground_truth": "SELECT credit FROM course WHERE name = 'Computer Vision'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT credit FROM courses WHERE course_name = 'Computer Vision';"
        ],
        "rule_sql": []
    },
    "4126": {
        "db_id": "public_review_platform",
        "question": "In businesses with a category of food, how many of them have a star rating below 3?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.business_id) FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE T3.category_name = 'Food' AND T1.stars < 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE category = 'food' AND star_rating > 3;"
        ],
        "rule_sql": []
    },
    "7374": {
        "db_id": "works_cycles",
        "question": "What are the names of the top 6 products that has the biggest size in centimeter and what are its reorder point?",
        "ground_truth": "SELECT Name, ReorderPoint FROM Product WHERE SizeUnitMeasureCode = 'CM' ORDER BY Size DESC LIMIT 6",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name, reorder_point FROM products ORDER BY size_cm ASC LIMIT 6;"
        ],
        "rule_sql": []
    },
    "5480": {
        "db_id": "menu",
        "question": "Among the menus in which the dish \"Clear green turtle\" had appeared, how many of them did not support taking out or booking in advance?",
        "ground_truth": "SELECT SUM(CASE WHEN T4.name = 'Clear green turtle' THEN 1 ELSE 0 END) FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T3.call_number IS NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM menus m\nJOIN menu_dishes md ON m.menu_id = md.menu_id\nJOIN dishes d ON md.dish_id = d.dish_id\nWHERE d.dish_name = 'Clear green turtle'\nAND (m.take_out = 1 OR m.booking_in_advance = 1);"
        ],
        "rule_sql": []
    },
    "7592": {
        "db_id": "image_and_language",
        "question": "How many images have \"picture\" as their attribute class and \"bear\" as their object class?",
        "ground_truth": "SELECT COUNT(T2.IMG_ID) FROM ATT_CLASSES AS T1 INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID INNER JOIN IMG_OBJ AS T3 ON T2.IMG_ID = T3.IMG_ID INNER JOIN OBJ_CLASSES AS T4 ON T3.OBJ_CLASS_ID = T4.OBJ_CLASS_ID WHERE T1.ATT_CLASS = 'picture' AND T4.OBJ_CLASS = 'bear'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE attribute_class = 'picture' AND object_class = 'bear';"
        ],
        "rule_sql": []
    },
    "3078": {
        "db_id": "cars",
        "question": "Show the origin country of Chevrolet Malibu.",
        "ground_truth": "SELECT T3.country FROM data AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country WHERE T1.car_name = 'chevrolet malibu'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT manufacturer FROM cars WHERE model = 'Malibu';"
        ],
        "rule_sql": []
    },
    "9392": {
        "db_id": "movie_3",
        "question": "What films did Burt Dukakis got star in?",
        "ground_truth": "SELECT T3.title FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T2.first_name = 'BURT' AND T2.last_name = 'DUKAKIS'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title FROM films f JOIN stars s ON f.id = s.film_id JOIN people p ON s.person_id = p.id WHERE p.name = 'Burt Dukakis'"
        ],
        "rule_sql": []
    },
    "2833": {
        "db_id": "professional_basketball",
        "question": "Among the players that went to high school in New York and have won the MVP, what is their average height?",
        "ground_truth": "SELECT AVG(T1.height) FROM players AS T1 INNER JOIN awards_players AS T2 ON T1.playerID = T2.playerID WHERE T2.award = 'Most Valuable Player' AND T1.birthCity = 'New York'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(height) FROM players WHERE high_school = 'New York' AND mvp = 'Yes';"
        ],
        "rule_sql": []
    },
    "1974": {
        "db_id": "soccer_2016",
        "question": "Among the\" Mumbai Indians\" team that played in 2009, how many percent of the matches did they win?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.Match_Winner = T2.Team_Id THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Match_Id) FROM `Match` AS T1 INNER JOIN Team AS T2 ON T1.Team_1 = T2.Team_Id OR T1.Team_2 = T2.Team_Id WHERE T2.Team_Name = 'Mumbai Indians' AND T1.Match_Date LIKE '2009%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN winner = 'Mumbai Indians' THEN 1 END) * 100.0 / COUNT(*)) AS win_percentage\nFROM matches\nWHERE team1 = 'Mumbai Indians' OR team2 = 'Mumbai Indians'\nAND season = 2009;"
        ],
        "rule_sql": []
    },
    "289": {
        "db_id": "retail_complains",
        "question": "List by their ID number the 3 longest complaints.",
        "ground_truth": "SELECT `Complaint ID` FROM callcenterlogs ORDER BY ser_time DESC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT complaint_id FROM complaints ORDER BY LENGTH(complaint_text) ASC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "9042": {
        "db_id": "bike_share_1",
        "question": "Which trip id had the longest duration and the start station is in Redwood City?",
        "ground_truth": "SELECT T1.id FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'Redwood City' AND T1.duration = ( SELECT MAX(T1.duration) FROM trip AS T1 LEFT JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T2.city = 'Redwood City' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT trip_id FROM trips WHERE start_station LIKE '%Redwood City%' ORDER BY duration DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2282": {
        "db_id": "movielens",
        "question": "For the movies in English that are the oldest, how many of them have the lowest rating?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.movieid) FROM movies AS T1 INNER JOIN u2base AS T2 ON T1.movieid = T2.movieid WHERE T1.year = 1 AND T2.rating = 1 AND T1.isEnglish = 'T'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM movies \nWHERE language = 'English' \nORDER BY year ASC, rating ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2548": {
        "db_id": "app_store",
        "question": "What percentage of no comment reviews are from \"Teen\" content rating apps?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.`Content Rating` = 'Teen' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.App) FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T2.Translated_Review = 'nan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN comment IS NULL AND content_rating = 'Teen' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN comment IS NULL THEN 1 END)) AS percentage\nFROM reviews\nJOIN apps ON reviews.app_id = apps.id"
        ],
        "rule_sql": []
    },
    "6198": {
        "db_id": "food_inspection_2",
        "question": "What are the inspection results for Xando Coffee & Bar / Cosi Sandwich Bar?",
        "ground_truth": "SELECT DISTINCT T2.results FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.dba_name = 'XANDO COFFEE & BAR / COSI SANDWICH BAR'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM inspections WHERE restaurant_name = 'Xando Coffee & Bar / Cosi Sandwich Bar';"
        ],
        "rule_sql": []
    },
    "4559": {
        "db_id": "student_loan",
        "question": "Among the students that have a payment due, how many students are unemployed?",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name WHERE T1.bool = 'pos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE payment_due = 1 AND employment_status = 'unemployed';"
        ],
        "rule_sql": []
    },
    "4309": {
        "db_id": "simpson_episodes",
        "question": "State the number of votes for episode with rating of 7 and above.",
        "ground_truth": "SELECT votes FROM Episode WHERE rating > 7;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE rating >= 7;"
        ],
        "rule_sql": []
    },
    "6747": {
        "db_id": "retails",
        "question": "What is the total number of orders made by customers in United States?",
        "ground_truth": "SELECT COUNT(T1.o_orderkey) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey INNER JOIN nation AS T3 ON T2.c_nationkey = T3.n_nationkey WHERE T3.n_name = 'UNITED STATES'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE country = 'United States';"
        ],
        "rule_sql": []
    },
    "1569": {
        "db_id": "car_retails",
        "question": "How many French customers shipped 2 orders which have been cancelled?",
        "ground_truth": "SELECT COUNT(T2.country) FROM orders AS T1 INNER JOIN customers AS T2 ON T1.customerNumber = T2.customerNumber WHERE T1.status = 'Shipped' AND T2.country = 'France' GROUP BY T2.customerNumber HAVING COUNT(T1.status) = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nWHERE c.country = 'France' \nAND o.status = 'cancelled'\nGROUP BY c.customer_id\nHAVING COUNT(o.order_id) = 2;"
        ],
        "rule_sql": []
    },
    "3147": {
        "db_id": "donor",
        "question": "What is the total amount of donations in 2012.",
        "ground_truth": "SELECT SUM(donation_total) FROM donations WHERE donation_timestamp LIKE '2012%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM donations WHERE year = 2012;"
        ],
        "rule_sql": []
    },
    "9185": {
        "db_id": "movie_3",
        "question": "What is the name of the most rented movie?",
        "ground_truth": "SELECT T.title FROM ( SELECT T1.title, COUNT(T3.rental_id) AS num FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id INNER JOIN rental AS T3 ON T2.inventory_id = T3.inventory_id GROUP BY T1.title ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies ORDER BY rental_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2367": {
        "db_id": "superstore",
        "question": "What are the names of the products with a profit of no less than 1,000 in one single order?",
        "ground_truth": "SELECT DISTINCT T2.`Product Name` FROM west_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T1.Profit > 1000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE profit >= 1000;"
        ],
        "rule_sql": []
    },
    "8303": {
        "db_id": "mondial_geo",
        "question": "How many deserts are there in a country where over 90% of people speaks Armenian?",
        "ground_truth": "SELECT COUNT(T2.Desert) FROM country AS T1 INNER JOIN geo_desert AS T2 ON T1.Code = T2.Country INNER JOIN language AS T3 ON T1.Code = T2.Country WHERE T3.Name = 'Armenian' AND T3.Percentage > 90",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM deserts d \nJOIN countries c ON d.country_id = c.id \nJOIN languages l ON c.id = l.country_id \nWHERE l.language = 'Armenian' AND l.percentage > 90;"
        ],
        "rule_sql": []
    },
    "8209": {
        "db_id": "sales_in_weather",
        "question": "Which items from store 1 have the highest units sold during rainy day?",
        "ground_truth": "SELECT T2.item_nbr FROM weather AS T1 INNER JOIN sales_in_weather AS T2 ON T1.`date` = T2.`date` INNER JOIN relation AS T3 ON T2.store_nbr = T3.store_nbr AND T1.station_nbr = T3.station_nbr WHERE T2.store_nbr = 1 AND T1.codesum LIKE '%' OR 'RA' OR '%' GROUP BY T2.item_nbr ORDER BY T2.units DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT item_name, units_sold FROM sales WHERE store_id = 1 AND weather = 'rainy' ORDER BY units_sold ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8000": {
        "db_id": "university",
        "question": "Which country is the University of Oxford located?",
        "ground_truth": "SELECT T2.country_name FROM university AS T1 INNER JOIN country AS T2 ON T1.country_id = T2.id WHERE university_name = 'University of Oxford'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM universities WHERE name = 'University of Oxford';"
        ],
        "rule_sql": []
    },
    "3554": {
        "db_id": "authors",
        "question": "Provide any four valid Journal ID along with short name and full name of the papers which were made in 2013.",
        "ground_truth": "SELECT DISTINCT T2.JournalId, T1.ShortName, T1.FullName FROM Journal AS T1 INNER JOIN Paper AS T2 ON T1.Id = T2.JournalId WHERE T2.Year = 2013 AND T2.JournalId != 0 AND T2.JournalId != -1 LIMIT 4",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT JournalID, ShortName, FullName FROM Papers WHERE Year = 2013 LIMIT 4;"
        ],
        "rule_sql": []
    },
    "3854": {
        "db_id": "public_review_platform",
        "question": "How many Yelp_Business falls under the category of \"Shopping\"?",
        "ground_truth": "SELECT COUNT(T1.category_id) FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id WHERE T1.category_name LIKE 'Shopping'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Yelp_Business WHERE category = 'Shopping';"
        ],
        "rule_sql": []
    },
    "6932": {
        "db_id": "ice_hockey_draft",
        "question": "What is the height in centimeter of the tallest player born in Edmonton, Alberta, Canada?",
        "ground_truth": "SELECT T2.height_in_cm FROM PlayerInfo AS T1 INNER JOIN height_info AS T2 ON T1.height = T2.height_id WHERE T1.birthplace = 'Edmonton, AB, CAN' ORDER BY T2.height_in_cm DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(height) FROM players WHERE birth_city = 'Edmonton' AND birth_province = 'Alberta' AND birth_country = 'Canada';"
        ],
        "rule_sql": []
    },
    "286": {
        "db_id": "retail_complains",
        "question": "Find the number of service members who complained in Syracuse.",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.Tags = 'Servicemember' AND T1.city = 'Syracuse'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM complaints WHERE city = 'Syracuse';"
        ],
        "rule_sql": []
    },
    "1185": {
        "db_id": "talkingdata",
        "question": "State the gender of users who use the device \"-9222956879900150000\".",
        "ground_truth": "SELECT gender FROM gender_age WHERE device_id = -9222956879900150000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM users WHERE device_id = '-9222956879900150000';"
        ],
        "rule_sql": []
    },
    "8765": {
        "db_id": "chicago_crime",
        "question": "Among the incidents with the generic description of \"BATTERY\" in the IUCR classification, how many of them do not have arrests made?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.arrest = 'FALSE' THEN 1 ELSE 0 END) FROM IUCR AS T1 INNER JOIN Crime AS T2 ON T1.iucr_no = T2.iucr_no WHERE T1.primary_description = 'BATTERY'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM incidents WHERE generic_description = 'BATTERY' AND arrest_made = 'YES';"
        ],
        "rule_sql": []
    },
    "4239": {
        "db_id": "simpson_episodes",
        "question": "Indicate the name and category of the most recent award received by the show.",
        "ground_truth": "SELECT award, award_category FROM Award WHERE result = 'Winner' ORDER BY year DESC LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, category FROM awards ORDER BY date_received DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2547": {
        "db_id": "app_store",
        "question": "What is the rating and the total Sentiment subjectivity score of \"Onefootball - Soccer Scores\"?",
        "ground_truth": "SELECT T1.Rating, SUM(T2.Sentiment_Subjectivity) FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.App = 'Onefootball - Soccer Scores'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT rating, SUM(sentiment_subjectivity) FROM apps WHERE name = 'Onefootball - Soccer Scores';"
        ],
        "rule_sql": []
    },
    "4288": {
        "db_id": "simpson_episodes",
        "question": "What are the roles of the cast and crew from countries other than the USA?",
        "ground_truth": "SELECT T2.role FROM Person AS T1 INNER JOIN Credit AS T2 ON T1.name = T2.person WHERE T1.birth_country != 'USA';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT role, country FROM cast_crew WHERE country != 'USA';"
        ],
        "rule_sql": []
    },
    "8122": {
        "db_id": "university",
        "question": "List down all universities that scored below 50.",
        "ground_truth": "SELECT DISTINCT T2.university_name FROM university_ranking_year AS T1 INNER JOIN university AS T2 ON T1.university_id = T2.id WHERE T1.score < 50",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM universities WHERE score > 50;"
        ],
        "rule_sql": []
    },
    "4809": {
        "db_id": "legislator",
        "question": "What is the middle name of the legislator whose birthday was on 8/24/1956?",
        "ground_truth": "SELECT middle_name FROM current WHERE birthday_bio = '1956-08-24'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM legislators WHERE birthday = '8/24/1956';"
        ],
        "rule_sql": []
    },
    "4119": {
        "db_id": "public_review_platform",
        "question": "How many of the businesses are in Surprise?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE city = 'Surprise'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Phoenix';"
        ],
        "rule_sql": []
    },
    "5392": {
        "db_id": "sales",
        "question": "Among the products, how many of them are freebies?",
        "ground_truth": "SELECT COUNT(ProductID) FROM Products WHERE Price = 0",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM products WHERE price = 0;"
        ],
        "rule_sql": []
    },
    "7446": {
        "db_id": "works_cycles",
        "question": "What are the products with a large photo?",
        "ground_truth": "SELECT T2.ProductID FROM ProductPhoto AS T1 INNER JOIN ProductProductPhoto AS T2 ON T1.ProductPhotoID = T2.ProductPhotoID WHERE T1.LargePhotoFileName LIKE '%large.gif'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products WHERE photo_size > 1000000;"
        ],
        "rule_sql": []
    },
    "4202": {
        "db_id": "simpson_episodes",
        "question": "What is the title of the episode that received the lowest rating?",
        "ground_truth": "SELECT title FROM Episode ORDER BY rating LIMIT 1;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes ORDER BY rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4866": {
        "db_id": "legislator",
        "question": "How many class 1 senators belong to the Republican party?",
        "ground_truth": "SELECT COUNT(bioguide) FROM `current-terms` WHERE class = 1 AND party = 'Republican'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM senators WHERE class = 1 AND party = 'Democrat';"
        ],
        "rule_sql": []
    },
    "2243": {
        "db_id": "world_development_indicators",
        "question": "What's the agregation method for the indicator whose value is 133 in 1960 for the Arab World?",
        "ground_truth": "SELECT T2.AggregationMethod FROM Indicators AS T1 INNER JOIN Series AS T2 ON T1.IndicatorName = T2.IndicatorName INNER JOIN Country AS T3 ON T1.CountryCode = T3.CountryCode WHERE T3.ShortName = 'Arab World' AND T1.Value = 133 AND T1.Year = 1960",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT aggregation_method FROM indicators WHERE value = 133 AND year = 1960 AND country = 'Arab World';"
        ],
        "rule_sql": []
    },
    "1001": {
        "db_id": "computer_student",
        "question": "What is the ratio of professors and students?",
        "ground_truth": "SELECT CAST(SUM(CASE  WHEN professor = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE  WHEN student = 1 THEN 1 ELSE 0 END) AS per FROM person",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS professor_count, COUNT(*) AS student_count, COUNT(*) AS ratio FROM professors, students"
        ],
        "rule_sql": []
    },
    "3292": {
        "db_id": "donor",
        "question": "What is the average amount of resources from projects that have received donations per honoree?",
        "ground_truth": "SELECT AVG(T1.item_quantity) FROM resources AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T2.for_honoree = 't'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT honoree, AVG(resources) FROM projects GROUP BY honoree;"
        ],
        "rule_sql": []
    },
    "2966": {
        "db_id": "shakespeare",
        "question": "What is the average number of characters in all the works of Shakespeare?",
        "ground_truth": "SELECT SUM(DISTINCT T4.id) / COUNT(T1.id) FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id INNER JOIN paragraphs AS T3 ON T2.id = T3.chapter_id INNER JOIN characters AS T4 ON T3.character_id = T4.id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(LENGTH(title)) FROM shakespeare_works;"
        ],
        "rule_sql": []
    },
    "9145": {
        "db_id": "movie_3",
        "question": "Give the postal code for the address No.65.",
        "ground_truth": "SELECT postal_code FROM address WHERE address_id = 65",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT postal_code FROM addresses WHERE address = 'No.65';"
        ],
        "rule_sql": []
    },
    "8290": {
        "db_id": "mondial_geo",
        "question": "Which country has the city of 114339 in population? Give the full name of the country.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN city AS T2 ON T1.Code = T2.Country WHERE T2.Population = 114339",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM cities WHERE population = 114339;"
        ],
        "rule_sql": []
    },
    "1859": {
        "db_id": "soccer_2016",
        "question": "List the players' names who were born in 1971.",
        "ground_truth": "SELECT Player_name FROM Player WHERE DOB LIKE '1971%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE birth_year = 1970;"
        ],
        "rule_sql": []
    },
    "1154": {
        "db_id": "talkingdata",
        "question": "Please list the event IDs of the events that have happened on the device of the oldest user.",
        "ground_truth": "SELECT T2.event_id FROM gender_age AS T1 INNER JOIN events AS T2 ON T1.device_id = T2.device_id ORDER BY T1.age DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT event_id FROM events WHERE device_id = (SELECT device_id FROM users ORDER BY age DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "4734": {
        "db_id": "disney",
        "question": "Name the top 5 highest-grossing Disney movies adjusted for inflation. Identify the percentage they contributed to the total of Disney's current gross.",
        "ground_truth": "SELECT SUM(CASE WHEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) > 1236035515 THEN CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL) ELSE 0 END) * 100 / SUM(CAST(REPLACE(trim(inflation_adjusted_gross, '$'), ',', '') AS REAL)) FROM movies_total_gross",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    title,\n    gross_adjusted,\n    (gross_adjusted / (SELECT SUM(gross_adjusted) FROM disney_movies)) * 100 AS percentage_contribution\nFROM disney_movies\nORDER BY gross_adjusted DESC\nLIMIT 5;"
        ],
        "rule_sql": []
    },
    "930": {
        "db_id": "cs_semester",
        "question": "Among the students with high salary, what is total number of students with a GPA higher than 3?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T1.salary = 'high' AND T2.gpa > 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE salary > 50000 AND gpa > 3;"
        ],
        "rule_sql": []
    },
    "3175": {
        "db_id": "donor",
        "question": "What is the name of the vendor that supplies resources to the project \"iMath\"?",
        "ground_truth": "SELECT DISTINCT T1.vendor_name FROM resources AS T1 INNER JOIN essays AS T3 ON T1.projectid = T3.projectid WHERE T3.title = 'iMath'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name FROM vendors WHERE project_name = 'iMath';"
        ],
        "rule_sql": []
    },
    "367": {
        "db_id": "retail_complains",
        "question": "How many times per year does a credit card customer complain about overlimit fees?",
        "ground_truth": "SELECT strftime('%Y', `Date received`), COUNT(`Date received`) FROM events WHERE product = 'Credit card' AND issue = 'Overlimit fee' GROUP BY strftime('%Y', `Date received`) HAVING COUNT(`Date received`)",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) / 12 FROM complaints WHERE complaint_type = 'overlimit_fee' GROUP BY customer_id"
        ],
        "rule_sql": []
    },
    "2701": {
        "db_id": "regional_sales",
        "question": "Indicate order numbers with an order date after 1/1/2018.",
        "ground_truth": "SELECT DISTINCT T FROM ( SELECT CASE  WHEN OrderDate > '1/1/18' THEN OrderNumber ELSE NULL END AS T FROM `Sales Orders` ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_number FROM orders WHERE order_date > '2018-01-01';"
        ],
        "rule_sql": []
    },
    "7742": {
        "db_id": "hockey",
        "question": "Which position has won the most awards and who is the most recent player that was awarded with an award in that position? Indicate the name of the award and the full name of the player.",
        "ground_truth": "SELECT T1.pos, T2.award, T1.nameGiven, T1.lastName FROM Master AS T1 INNER JOIN AwardsCoaches AS T2 ON T2.coachID = T1.coachID GROUP BY T1.pos, T2.award, T1.nameGiven, T1.lastName ORDER BY COUNT(T2.award) LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT position, COUNT(*) as award_count, MAX(award_date) as most_recent_date, award_name, player_name\nFROM awards\nGROUP BY position\nORDER BY award_count DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "682": {
        "db_id": "codebase_comments",
        "question": "What is the github address of the solution path \"joeyrobert_bloomfilter\\DataTypes.BloomFilter.sln\"?",
        "ground_truth": "SELECT T1.Url FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T2.Path = 'joeyrobert_bloomfilterDataTypes.BloomFilter.sln'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT github_address FROM solutions WHERE path = 'joeyrobert_bloomfilter\\DataTypes.BloomFilter.sln';"
        ],
        "rule_sql": []
    },
    "8497": {
        "db_id": "mondial_geo",
        "question": "Which Zaire region is home to the country's deepest lake's Name it and list its depth.",
        "ground_truth": "SELECT T3.Name, T1.Name, T1.Depth FROM lake AS T1 INNER JOIN located AS T2 ON T1.Name = T2.Lake INNER JOIN province AS T3 ON T3.Name = T2.Province INNER JOIN country AS T4 ON T4.Code = T3.Country WHERE T4.Name = 'Zaire'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region_name, lake_name, depth FROM lakes WHERE country = 'Zaire' ORDER BY depth DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9182": {
        "db_id": "movie_3",
        "question": "List the name of the films that can only be found in store id 2.",
        "ground_truth": "SELECT T1.title FROM film AS T1 INNER JOIN inventory AS T2 ON T1.film_id = T2.film_id WHERE T2.store_id = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM film WHERE store_id = 2;"
        ],
        "rule_sql": []
    },
    "7274": {
        "db_id": "works_cycles",
        "question": "What is the average lead time of product ID 843? Calculate for its profit on net and indicate the full location to which the vendor is located.",
        "ground_truth": "SELECT T1.AverageLeadTime, T1.LastReceiptCost - T1.StandardPrice, T4.AddressLine1, T4.AddressLine2 , T4.City, T4.PostalCode FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID INNER JOIN BusinessEntityAddress AS T3 ON T1.BusinessEntityID = T3.BusinessEntityID INNER JOIN Address AS T4 ON T3.AddressID = T4.AddressID WHERE T1.ProductID = 843",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(lead_time), profit_on_net, vendor_location \nFROM products \nWHERE product_id = 843 \nGROUP BY vendor_location;"
        ],
        "rule_sql": []
    },
    "2834": {
        "db_id": "professional_basketball",
        "question": "Please list the top ten teams with the highest scores in 2000.",
        "ground_truth": "SELECT tmID FROM players_teams WHERE year = 2000 GROUP BY tmID ORDER BY SUM(PostPoints) DESC LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, score FROM teams WHERE year = 2000 ORDER BY score ASC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "2360": {
        "db_id": "superstore",
        "question": "Who is the customer who purchased the largest total cost of products in a single order?",
        "ground_truth": "SELECT T2.`Customer Name` FROM east_superstore AS T1 INNER JOIN people AS T2 ON T1.`Customer ID` = T2.`Customer ID` GROUP BY T1.`Order ID`, T2.`Customer Name` ORDER BY SUM((T1.Sales / (1 - T1.Discount)) * T1.Quantity - T1.Profit) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name, MAX(total_cost) FROM orders GROUP BY customer_name ORDER BY total_cost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8992": {
        "db_id": "bike_share_1",
        "question": "State the final station of bike id 13. Which city was it at?",
        "ground_truth": "SELECT T2.end_station_id, T1.city FROM station AS T1 INNER JOIN trip AS T2 ON T1.name = T2.end_station_name WHERE T2.bike_id = 13 ORDER BY T2.end_date DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM stations WHERE station_id = (SELECT end_station_id FROM trips WHERE bike_id = 13 ORDER BY end_time DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "4094": {
        "db_id": "public_review_platform",
        "question": "List down the category of businesses whose stars ratings are 5.",
        "ground_truth": "SELECT DISTINCT T3.category_name FROM Business AS T1 INNER JOIN Business_Categories AS T2 ON T1.business_id = T2.business_id INNER JOIN Categories AS T3 ON T2.category_id = T3.category_id WHERE T1.stars = 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM businesses WHERE stars = 5;"
        ],
        "rule_sql": []
    },
    "9279": {
        "db_id": "movie_3",
        "question": "How many non-active clients have not returned the rented material?",
        "ground_truth": "SELECT COUNT(T2.customer_id) FROM rental AS T1 INNER JOIN customer AS T2 ON T1.customer_id = T2.customer_id WHERE T2.active = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE status = 'active' AND material_returned = 'no';"
        ],
        "rule_sql": []
    },
    "3669": {
        "db_id": "authors",
        "question": "Provide the title of the latest publication published by it's author 'Zuliang Du'.",
        "ground_truth": "SELECT T2.Title FROM PaperAuthor AS T1 INNER JOIN Paper AS T2 ON T1.PaperId = T2.Id WHERE T1.Name = 'Zuliang Du' ORDER BY T2.Year DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM publications WHERE author = 'Zuliang Du' ORDER BY publication_date DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7447": {
        "db_id": "works_cycles",
        "question": "List all the socks products.",
        "ground_truth": "SELECT T2.ProductID FROM ProductSubcategory AS T1 INNER JOIN Product AS T2 ON T1.ProductSubcategoryID = T2.ProductSubcategoryID WHERE T1.Name = 'Socks'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM products WHERE category = 'shoes';"
        ],
        "rule_sql": []
    },
    "4556": {
        "db_id": "student_loan",
        "question": "What is the name of the student with the longest duration of absence?",
        "ground_truth": "SELECT name FROM longest_absense_from_school WHERE month = ( SELECT MAX(month) FROM longest_absense_from_school )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students ORDER BY absence_duration DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5260": {
        "db_id": "beer_factory",
        "question": "When did Natalie Dorris buy her first root beer?",
        "ground_truth": "SELECT T2.TransactionDate FROM customers AS T1 INNER JOIN `transaction` AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.First = 'Natalie' AND T1.Last = 'Dorris' ORDER BY T2.TransactionDate LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(purchase_date) FROM purchases WHERE customer_name = 'Natalie Dorris' AND product_name = 'root beer';"
        ],
        "rule_sql": []
    },
    "7598": {
        "db_id": "image_and_language",
        "question": "In the Y coordinate of image ID 12, how many are 0?",
        "ground_truth": "SELECT COUNT(IMG_ID) FROM IMG_OBJ WHERE IMG_ID = 12 AND Y = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE image_id = 12 AND y_coordinate = 0;"
        ],
        "rule_sql": []
    },
    "8825": {
        "db_id": "food_inspection",
        "question": "Provide eateries' IDs, risk categories and descriptions with violation ID of 103101.",
        "ground_truth": "SELECT business_id, risk_category, description FROM violations WHERE violation_type_id = '103101'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT eatery_id, risk_category, description, violation_id FROM eateries WHERE violation_id = 103101"
        ],
        "rule_sql": []
    },
    "8187": {
        "db_id": "sales_in_weather",
        "question": "Which station sold the highest quantity of item number 5 overall?",
        "ground_truth": "SELECT T2.station_nbr FROM sales_in_weather AS T1 INNER JOIN relation AS T2 ON T1.store_nbr = T2.store_nbr WHERE T1.item_nbr = 5 GROUP BY T2.station_nbr ORDER BY SUM(T1.units) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT station_id, SUM(quantity) as total_quantity FROM sales WHERE item_number = 5 GROUP BY station_id ORDER BY total_quantity DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1861": {
        "db_id": "soccer_2016",
        "question": "List the match IDs which had players out by hit wickets.",
        "ground_truth": "SELECT T1.Match_Id FROM Wicket_Taken AS T1 INNER JOIN Out_Type AS T2 ON T2.Out_Id = T1.Kind_Out WHERE T2.Out_Name = 'hit wicket'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT match_id FROM matches WHERE wicket_type = 'hit wicket';"
        ],
        "rule_sql": []
    },
    "6774": {
        "db_id": "retails",
        "question": "List the name of the top ten items with the most quantity available in the descending order of availability.",
        "ground_truth": "SELECT T1.p_name FROM part AS T1 INNER JOIN partsupp AS T2 ON T1.p_partkey = T2.ps_partkey ORDER BY T2.ps_availqty DESC LIMIT 10",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM items ORDER BY quantity ASC LIMIT 10;"
        ],
        "rule_sql": []
    },
    "4076": {
        "db_id": "public_review_platform",
        "question": "Provide the list of user ID along with review star of which has the review length of medium with business ID of 35.",
        "ground_truth": "SELECT user_id, review_stars FROM Reviews WHERE business_id = 15 AND review_length = 'Medium'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT user_id, review_star FROM reviews WHERE business_id = 35 AND review_length = 'medium';"
        ],
        "rule_sql": []
    },
    "7198": {
        "db_id": "works_cycles",
        "question": "Among the sales people who achieved projected sales quota 2013, is there any person from territory ID 1? If yes, state the business entity ID.",
        "ground_truth": "SELECT DISTINCT T1.BusinessEntityID FROM SalesPerson AS T1 INNER JOIN SalesPersonQuotaHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.TerritoryID = 1 AND STRFTIME('%Y', QuotaDate) = '2013'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT BusinessEntityID \nFROM SalesPerson \nWHERE SalesQuota > 1000000 \nAND TerritoryID = 1;"
        ],
        "rule_sql": []
    },
    "968": {
        "db_id": "computer_student",
        "question": "How many professors are teaching course ID 18?",
        "ground_truth": "SELECT COUNT(DISTINCT p_id) FROM taughtBy WHERE course_id = 18",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM professors WHERE course_id = 18;"
        ],
        "rule_sql": []
    },
    "8855": {
        "db_id": "food_inspection",
        "question": "In businesses with a score lower than 95 and located around the postal code of 94110, what is the percentage of businesses with a risk category of low risk?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.risk_category = 'Low Risk' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.risk_category) FROM violations AS T1 INNER JOIN inspections AS T2 ON T1.business_id = T2.business_id INNER JOIN businesses AS T3 ON T2.business_id = T3.business_id WHERE T2.score < 95 AND T3.postal_code = 94110",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN risk_category = 'low risk' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_low_risk\nFROM businesses\nWHERE score >= 95 AND postal_code LIKE '94110%';"
        ],
        "rule_sql": []
    },
    "1647": {
        "db_id": "car_retails",
        "question": "List the name of employees in Japan office and who are they reporting to.",
        "ground_truth": "SELECT t2.firstName, t2.lastName, t2.reportsTo FROM offices AS t1 INNER JOIN employees AS t2 ON t1.officeCode = t2.officeCode WHERE t1.country = 'Japan'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.name, m.name AS manager_name\nFROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id\nWHERE e.office = 'Japan';"
        ],
        "rule_sql": []
    },
    "4652": {
        "db_id": "disney",
        "question": "What are the names of the characters voiced by Frank Welker?",
        "ground_truth": "SELECT character FROM `voice-actors` WHERE 'voice-actor' = 'Frank Welker'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM characters WHERE voice_actor = 'Frank Welker';"
        ],
        "rule_sql": []
    },
    "2537": {
        "db_id": "app_store",
        "question": "Which free app has the most Negative comments?",
        "ground_truth": "SELECT T1.App FROM playstore AS T1 INNER JOIN user_reviews AS T2 ON T1.App = T2.App WHERE T1.Type = 'Free' AND T2.Sentiment = 'Negative' GROUP BY T1.App ORDER BY COUNT(T2.Sentiment) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT app_name, COUNT(*) as negative_count \nFROM comments \nWHERE sentiment = 'Negative' AND price = 0 \nGROUP BY app_name \nORDER BY negative_count ASC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "8567": {
        "db_id": "software_company",
        "question": "List the level of education and income of customers ages from 30 to 55 with a true response.",
        "ground_truth": "SELECT T1.EDUCATIONNUM, T3.INCOME_K FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE T1.age >= 30 AND T1.age <= 55 AND T2.RESPONSE = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT education, income FROM customers WHERE age BETWEEN 30 AND 55 AND response = 'true';"
        ],
        "rule_sql": []
    },
    "7640": {
        "db_id": "hockey",
        "question": "Which coach has the best performance for team DET in history? What was the winning percentage? Name the coach and the year he coached.",
        "ground_truth": "SELECT CAST(T2.W AS REAL) / T2.G, T1.firstName, T1.lastName, T2.year FROM Master AS T1 INNER JOIN Coaches AS T2 ON T1.coachID = T2.coachID INNER JOIN ( SELECT coachID FROM Coaches ORDER BY CAST(w AS REAL) / g DESC LIMIT 1 ) AS T3 ON T2.coachID = T3.coachID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT coach_name, year, (wins / (wins + losses)) * 100 AS winning_percentage \nFROM coaches \nWHERE team = 'DET' \nORDER BY wins DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4547": {
        "db_id": "student_loan",
        "question": "List the longest duration of absense for a student enlisted in the fire department.",
        "ground_truth": "SELECT T1.month FROM longest_absense_from_school AS T1 INNER JOIN enlist AS T2 ON T1.name = T2.name WHERE T2.organ = 'fire_department' ORDER BY T1.month DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(duration) FROM absences WHERE department = 'fire'"
        ],
        "rule_sql": []
    },
    "111": {
        "db_id": "movie_platform",
        "question": "Which of the film directed by director Abbas Kiarostami has the highest average score?",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id WHERE T2.director_name = 'Abbas Kiarostami' GROUP BY T2.movie_title ORDER BY SUM(T1.rating_score) / COUNT(T1.rating_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title, AVG(r.score) as avg_score\nFROM films f\nJOIN directors d ON f.director_id = d.director_id\nJOIN ratings r ON f.film_id = r.film_id\nWHERE d.director_name = 'Abbas Kiarostami'\nGROUP BY f.film_id\nORDER BY avg_score ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5399": {
        "db_id": "sales",
        "question": "Calculate the total number of sales closed by Michel E. DeFrance?",
        "ground_truth": "SELECT COUNT(T1.SalesID) FROM Sales AS T1 INNER JOIN Employees AS T2 ON T1.SalesPersonID = T2.EmployeeID WHERE T2.FirstName = 'Michel' AND T2.MiddleInitial = 'e' AND T2.LastName = 'DeFrance'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE salesperson = 'Michel E. DeFrance' AND status = 'open';"
        ],
        "rule_sql": []
    },
    "8032": {
        "db_id": "university",
        "question": "Provide the ID of the university with the highest percentage of female students in 2012.",
        "ground_truth": "SELECT university_id FROM university_year WHERE year = 2012 ORDER BY pct_female_students DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_id FROM university_enrollment WHERE year = 2012 ORDER BY male_students DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7991": {
        "db_id": "university",
        "question": "How many criteria belong to ranking system ID 3?",
        "ground_truth": "SELECT COUNT(id) FROM ranking_criteria WHERE ranking_system_id = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM criteria WHERE ranking_system_id = 3;"
        ],
        "rule_sql": []
    },
    "7085": {
        "db_id": "works_cycles",
        "question": "What is the average total due price of products with approved status?",
        "ground_truth": "SELECT SUM(TotalDue) / COUNT(TotalDue) FROM PurchaseOrderHeader WHERE Status = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM products WHERE status = 'approved';"
        ],
        "rule_sql": []
    },
    "5748": {
        "db_id": "language_corpus",
        "question": "What is the second word in the pair of words number 1 and 8968?",
        "ground_truth": "SELECT word FROM words WHERE wid = 8968",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT word FROM words WHERE id = 1 OR id = 8968 ORDER BY id LIMIT 1 OFFSET 1;"
        ],
        "rule_sql": []
    },
    "249": {
        "db_id": "retail_complains",
        "question": "For how long did the complaint filed on 2017/3/27 by Rachel Hicks last?",
        "ground_truth": "SELECT T2.ser_time FROM client AS T1 INNER JOIN callcenterlogs AS T2 ON T1.client_id = T2.`rand client` WHERE T1.first = 'Rachel' AND T1.last = 'Hicks' AND T2.`Date received` = '2017-03-27'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT DATEDIFF(closed_date, filed_date) AS duration_days \nFROM complaints \nWHERE filed_date = '2017/3/27' \nAND complainant_name = 'Rachel Hicks';"
        ],
        "rule_sql": []
    },
    "8930": {
        "db_id": "cookbook",
        "question": "Among all recipes containing cheese, what is the percentage of recipes with calories greater than 200?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T4.calories > 200 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id INNER JOIN Nutrition AS T4 ON T4.recipe_id = T1.recipe_id WHERE T3.category = 'cheese'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM recipes WHERE ingredients LIKE '%cheese%')) AS percentage\nFROM recipes \nWHERE ingredients LIKE '%cheese%' AND calories > 200;"
        ],
        "rule_sql": []
    },
    "478": {
        "db_id": "movies_4",
        "question": "Write all the keywords belonging to the movie 'Sky Captain and the World of Tomorrow.'",
        "ground_truth": "SELECT T3.keyword_name FROM movie AS T1 INNER JOIN movie_keywords AS T2 ON T1.movie_id = T2.movie_id INNER JOIN keyword AS T3 ON T2.keyword_id = T3.keyword_id WHERE T1.title = 'Sky Captain and the World of Tomorrow'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT keyword FROM movies WHERE title = 'Sky Captain and the World of Tomorrow'"
        ],
        "rule_sql": []
    },
    "7769": {
        "db_id": "hockey",
        "question": "Among the coaches who have taught the Philadelphia Flyers, how many of them are born in March?",
        "ground_truth": "SELECT COUNT(DISTINCT T3.coachID) FROM Coaches AS T1 INNER JOIN Teams AS T2 ON T1.year = T2.year AND T1.tmID = T2.tmID INNER JOIN Master AS T3 ON T1.coachID = T3.coachID WHERE T2.name = 'Philadelphia Flyers' AND T3.birthMon = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM coaches \nWHERE team = 'Philadelphia Flyers' \nAND birth_month = 'March';"
        ],
        "rule_sql": []
    },
    "7977": {
        "db_id": "music_platform_2",
        "question": "What is the average rating for the \"crime-junkie\" podcast?",
        "ground_truth": "SELECT AVG(T2.rating) FROM podcasts AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.title = 'Crime Junkie'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rating) FROM podcasts WHERE name = 'crime-junkie';"
        ],
        "rule_sql": []
    },
    "8850": {
        "db_id": "food_inspection",
        "question": "List the violation type ID of business with business ID from 30 to 50 and located at 747 IRVING St, San Francisco.",
        "ground_truth": "SELECT DISTINCT T1.violation_type_id FROM violations AS T1 INNER JOIN businesses AS T2 ON T1.business_id = T2.business_id WHERE T2.business_id BETWEEN 30 AND 50 AND T2.address = '747 IRVING St' AND T2.city = 'San Francisco'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT violation_type_id FROM businesses WHERE business_id BETWEEN 30 AND 50 AND address = '747 IRVING St' AND city = 'San Francisco';"
        ],
        "rule_sql": []
    },
    "6828": {
        "db_id": "retails",
        "question": "What are the shipping methods for the orders on 12/31/1994?",
        "ground_truth": "SELECT DISTINCT T2.l_shipmode FROM orders AS T1 INNER JOIN lineitem AS T2 ON T1.o_orderkey = T2.l_orderkey WHERE T1.o_orderdate = '1994-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT shipping_method FROM orders WHERE order_date = '1994-12-31';"
        ],
        "rule_sql": []
    },
    "4438": {
        "db_id": "student_loan",
        "question": "Mention the name of unemployed students who have never been absent from school.",
        "ground_truth": "SELECT T1.name FROM longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name WHERE T1.month = 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE employment_status = 'unemployed' AND absences = 0;"
        ],
        "rule_sql": []
    },
    "5761": {
        "db_id": "language_corpus",
        "question": "What is the locale of the language of the page titled \"Anys 90\"?",
        "ground_truth": "SELECT T1.locale FROM langs AS T1 INNER JOIN pages AS T2 ON T1.lid = T2.lid WHERE T2.title = 'Anys 90'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT locale FROM pages WHERE title = 'Anys 90';"
        ],
        "rule_sql": []
    },
    "4374": {
        "db_id": "student_loan",
        "question": "Among the students from the navy department, how many of them have payment due?",
        "ground_truth": "SELECT COUNT(T1.name) FROM enlist AS T1 INNER JOIN no_payment_due AS T2 ON T1.`name` = T2.`name` WHERE T1.organ = 'navy' AND T2.bool = 'pos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE department = 'navy' AND payment_due = 0;"
        ],
        "rule_sql": []
    },
    "7959": {
        "db_id": "music_platform_2",
        "question": "Provide the names of podcasts in the art category in 2018.",
        "ground_truth": "SELECT DISTINCT T2.title FROM categories AS T1 INNER JOIN reviews AS T2 ON T2.podcast_id = T1.podcast_id WHERE T1.category = 'arts' AND T2.created_at LIKE '2018-%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM podcasts WHERE category = 'art' AND year = 2018;"
        ],
        "rule_sql": []
    },
    "9366": {
        "db_id": "movie_3",
        "question": "Tally the full names of actors in the film \"Alabama Devil.\"",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM film_actor AS T1 INNER JOIN actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T1.film_id = T3.film_id WHERE T3.title = 'ALABAMA DEVIL'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name FROM actor a JOIN film_actor fa ON a.actor_id = fa.actor_id JOIN film f ON fa.film_id = f.film_id WHERE f.title = 'Alabama Devil';"
        ],
        "rule_sql": []
    },
    "6035": {
        "db_id": "books",
        "question": "On what date did the customers who live at number 460 of their respective streets place their orders?",
        "ground_truth": "SELECT T1.order_date FROM cust_order AS T1 INNER JOIN address AS T2 ON T1.dest_address_id = T2.address_id WHERE T2.street_number = 460",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_date FROM customers JOIN orders ON customers.customer_id = orders.customer_id WHERE address LIKE '%460%';"
        ],
        "rule_sql": []
    },
    "18": {
        "db_id": "movie_platform",
        "question": "What is the list ID that was first created by user 85981819?",
        "ground_truth": "SELECT list_id FROM lists_users WHERE user_id = 85981819 ORDER BY list_creation_date_utc ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT list_id FROM lists WHERE user_id = 85981819 ORDER BY created_at DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1877": {
        "db_id": "soccer_2016",
        "question": "List down the DOB of players who received the \"man of the match\" award.",
        "ground_truth": "SELECT T2.DOB FROM Match AS T1 INNER JOIN Player AS T2 ON T2.Player_Id = T1.Man_of_the_Match",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE award = 'man of the match';"
        ],
        "rule_sql": []
    },
    "3477": {
        "db_id": "video_games",
        "question": "Calculate the number of games in the fighting genre.",
        "ground_truth": "SELECT COUNT(T1.id) FROM game AS T1 INNER JOIN genre AS T2 ON T1.genre_id = T2.id WHERE T2.genre_name = 'Fighting'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE genre = 'action';"
        ],
        "rule_sql": []
    },
    "6719": {
        "db_id": "retails",
        "question": "How many countries are there in the region whose comment description is \"asymptotes sublate after the r.\"",
        "ground_truth": "SELECT COUNT(T1.n_nationkey) FROM nation AS T1 INNER JOIN region AS T2 ON T1.n_regionkey = T2.r_regionkey WHERE T2.r_comment = 'asymptotes sublate after the r'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM country WHERE region_id IN (SELECT region_id FROM region WHERE comment = 'asymptotes sublate after the r.')"
        ],
        "rule_sql": []
    },
    "473": {
        "db_id": "movies_4",
        "question": "Which actor plays Optimus Prime?",
        "ground_truth": "SELECT DISTINCT T1.person_name FROM person AS T1 INNER JOIN movie_cast AS T2 ON T1.person_id = T2.person_id WHERE T2.character_name = 'Optimus Prime (voice)'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT actor_name FROM actors WHERE character_name = 'Optimus Prime';"
        ],
        "rule_sql": []
    },
    "4290": {
        "db_id": "simpson_episodes",
        "question": "Which character did the \"Outstanding Voice-Over Performance\" winner voice?",
        "ground_truth": "SELECT DISTINCT T2.character FROM Award AS T1 INNER JOIN Character_Award AS T2 ON T1.award_id = T2.award_id WHERE T1.award = 'Outstanding Voice-Over Performance' AND T1.result = 'Winner';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT character_name FROM winners WHERE award = 'Outstanding Voice-Over Performance';"
        ],
        "rule_sql": []
    },
    "9369": {
        "db_id": "movie_3",
        "question": "Give me the title and category name of films whose price per day is more than $30. Please include their special features.",
        "ground_truth": "SELECT T1.title, T3.name, T1.special_features FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T1.rental_duration * T1.rental_rate > 30",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title, c.name AS category_name, f.special_features \nFROM film f \nJOIN film_category fc ON f.film_id = fc.film_id \nJOIN category c ON fc.category_id = c.category_id \nWHERE f.rental_rate > 30"
        ],
        "rule_sql": []
    },
    "361": {
        "db_id": "retail_complains",
        "question": "What is the full name of clients who have issue about balance transfer?",
        "ground_truth": "SELECT T1.first, T1.middle, T1.last FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T2.Issue = 'Balance transfer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM clients WHERE issue_type = 'balance transfer';"
        ],
        "rule_sql": []
    },
    "3379": {
        "db_id": "video_games",
        "question": "Provide the genre name of the genre ID 3.",
        "ground_truth": "SELECT T.genre_name FROM genre AS T WHERE T.id = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT genre_name FROM genres WHERE genre_id = 3;"
        ],
        "rule_sql": []
    },
    "5142": {
        "db_id": "address",
        "question": "What is the state for area code of 787?",
        "ground_truth": "SELECT DISTINCT T2.state FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.area_code = 787",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT state FROM area_codes WHERE area_code = '787';"
        ],
        "rule_sql": []
    },
    "8967": {
        "db_id": "human_resources",
        "question": "What is the full office location address where most of the employees work at?",
        "ground_truth": "SELECT T2.address, T2.locationcity, T2.state, T2.zipcode FROM employee AS T1  INNER JOIN location AS T2  ON T1.locationID = T2.locationID GROUP BY T2.address, T2.locationcity, T2.state, T2.zipcode ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT office_location, COUNT(*) as employee_count FROM employees GROUP BY office_location ORDER BY employee_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7755": {
        "db_id": "hockey",
        "question": "Which team got the most bench minor penalties in 2006?",
        "ground_truth": "SELECT name FROM Teams WHERE year = 2006 GROUP BY tmID, name ORDER BY CAST(SUM(BenchMinor) AS REAL) / 2 DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, COUNT(*) as bench_minor_count \nFROM penalties \nWHERE penalty_type = 'bench minor' \nAND year = 2006 \nGROUP BY team_name \nORDER BY bench_minor_count DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "514": {
        "db_id": "movies_4",
        "question": "Work out the difference in revenues made between the English and Latin movies.",
        "ground_truth": "SELECT SUM(CASE WHEN T3.language_name = 'English' THEN T1.revenue ELSE 0 END) - SUM(CASE WHEN T3.language_name = 'Latin' THEN T1.revenue ELSE 0 END) AS DIFFERENCE FROM movie AS T1 INNER JOIN movie_languages AS T2 ON T1.movie_id = T2.movie_id INNER JOIN language AS T3 ON T2.language_id = T3.language_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(revenue) FROM movies WHERE language = 'English') - \n    (SELECT SUM(revenue) FROM movies WHERE language = 'Latin') AS revenue_difference;"
        ],
        "rule_sql": []
    },
    "461": {
        "db_id": "movies_4",
        "question": "Give the names of the female cast in Movie No. 1865.",
        "ground_truth": "SELECT T2.person_name FROM movie_cast AS T1 INNER JOIN person AS T2 ON T1.person_id = T2.person_id INNER JOIN gender AS T3 ON T1.gender_id = T3.gender_id WHERE T1.movie_id = 1865 AND T3.gender = 'Female'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM cast WHERE movie_id = 1865 AND gender = 'male';"
        ],
        "rule_sql": []
    },
    "5799": {
        "db_id": "language_corpus",
        "question": "In which Wikipedia page does the word ID No. 174 have the most appearances? Give the title.",
        "ground_truth": "SELECT title FROM pages WHERE pid = ( SELECT pid FROM pages_words WHERE wid = 174 ORDER BY occurrences DESC LIMIT 1 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM wikipedia_pages WHERE word_id = 174 ORDER BY appearances DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1457": {
        "db_id": "synthea",
        "question": "How many women need to take 'Nitroglycerin 0.4 MG/ACTUAT [Nitrolingual]'?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.patient) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T2.DESCRIPTION = 'Nitroglycerin 0.4 MG/ACTUAT [Nitrolingual]' AND T1.gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'Male' AND medication = 'Nitroglycerin 0.4 MG/ACTUAT [Nitrolingual]';"
        ],
        "rule_sql": []
    },
    "8530": {
        "db_id": "software_company",
        "question": "How many of the customers are male?",
        "ground_truth": "SELECT COUNT(ID) FROM Customers WHERE SEX = 'Male'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE gender = 'female';"
        ],
        "rule_sql": []
    },
    "6771": {
        "db_id": "retails",
        "question": "Name the part which is most profitable.",
        "ground_truth": "SELECT T.p_name FROM ( SELECT T3.p_name , T2.l_extendedprice * (1 - T2.l_discount) - T1.ps_supplycost * T2.l_quantity AS num FROM partsupp AS T1 INNER JOIN lineitem AS T2 ON T1.ps_suppkey = T2.l_suppkey INNER JOIN part AS T3 ON T1.ps_partkey = T3.p_partkey ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT part_name FROM parts ORDER BY profit DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9110": {
        "db_id": "movie_3",
        "question": "Please list the titles of all the films that have more than 2 special features.",
        "ground_truth": "SELECT title FROM ( SELECT title, COUNT(special_features) AS num FROM film GROUP BY title ) AS T ORDER BY T.num > 2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM film WHERE special_features > 2;"
        ],
        "rule_sql": []
    },
    "8574": {
        "db_id": "software_company",
        "question": "What is the occupation and response of female customers within the number of inhabitants range of 20 to 25?",
        "ground_truth": "SELECT DISTINCT T1.OCCUPATION, T2.RESPONSE FROM Customers AS T1 INNER JOIN Mailings1_2 AS T2 ON T1.ID = T2.REFID INNER JOIN Demog AS T3 ON T1.GEOID = T3.GEOID WHERE T1.SEX = 'Female' AND T3.INHABITANTS_K >= 20 AND T3.INHABITANTS_K <= 25",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT occupation, response FROM customers WHERE gender = 'male' AND inhabitants BETWEEN 20 AND 25"
        ],
        "rule_sql": []
    },
    "7550": {
        "db_id": "image_and_language",
        "question": "How many samples of clouds are there in the image no.2315533?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.IMG_ID = 2315533 THEN 1 ELSE 0 END) FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID WHERE T2.OBJ_CLASS = 'clouds'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clouds WHERE image_no = '2315533';"
        ],
        "rule_sql": []
    },
    "937": {
        "db_id": "cs_semester",
        "question": "What is the capability on research of the student named Alvera McQuillin?",
        "ground_truth": "SELECT T2.capability FROM student AS T1 INNER JOIN RA AS T2 ON T1.student_id = T2.student_id WHERE T1.f_name = 'Alvera' AND T1.l_name = 'McQuillin'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT research_capability FROM students WHERE name = 'Alvera McQuillin';"
        ],
        "rule_sql": []
    },
    "6683": {
        "db_id": "retails",
        "question": "Among all the customers in Germany, how many of them have an account balance of over 1000?",
        "ground_truth": "SELECT COUNT(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey = T2.n_nationkey WHERE T2.n_name = 'GERMANY' AND T1.c_acctbal > 1000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE country = 'Germany' AND balance > 1000;"
        ],
        "rule_sql": []
    },
    "3240": {
        "db_id": "donor",
        "question": "Did the project 'I Can't See It...Can You Help Me???' get the tip for the donation?",
        "ground_truth": "SELECT T2.donation_included_optional_support FROM essays AS T1 INNER JOIN donations AS T2 ON T1.projectid = T2.projectid WHERE T1.title LIKE 'I Can''t See It...Can You Help Me???'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tip_amount FROM donations WHERE project_name = 'I Can\\'t See It...Can You Help Me???' AND tip_received = 'yes';"
        ],
        "rule_sql": []
    },
    "3387": {
        "db_id": "video_games",
        "question": "Provide the ID of the most popular platform in Europe.",
        "ground_truth": "SELECT T.game_platform_id FROM ( SELECT T1.game_platform_id, SUM(T1.num_sales) FROM region_sales AS T1 INNER JOIN region AS T2 ON T1.region_id = T2.id WHERE T2.region_name = 'Europe' GROUP BY T1.game_platform_id ORDER BY SUM(T1.num_sales) DESC LIMIT 1 ) t",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT platform_id FROM platforms WHERE region = 'Europe' ORDER BY popularity DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7571": {
        "db_id": "image_and_language",
        "question": "How many images have objects with the attributes of polka dot?",
        "ground_truth": "SELECT COUNT(T2.OBJ_SAMPLE_ID) FROM ATT_CLASSES AS T1 INNER JOIN IMG_OBJ_ATT AS T2 ON T1.ATT_CLASS_ID = T2.ATT_CLASS_ID WHERE T1.ATT_CLASS = 'polka dot'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM images WHERE object_attributes = 'polka dot';"
        ],
        "rule_sql": []
    },
    "7676": {
        "db_id": "hockey",
        "question": "Players born in which year have received the most awards in total?",
        "ground_truth": "SELECT T1.birthYear FROM Master AS T1 INNER JOIN AwardsPlayers AS T2 ON T1.playerID = T2.playerID GROUP BY T1.birthYear ORDER BY COUNT(T2.award) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birth_year, COUNT(*) as total_awards \nFROM players \nJOIN awards ON players.player_id = awards.player_id \nGROUP BY birth_year \nORDER BY total_awards DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4522": {
        "db_id": "student_loan",
        "question": "State the number of disabled students who have payment due.",
        "ground_truth": "SELECT COUNT(T1.name) FROM no_payment_due AS T1 INNER JOIN disabled AS T2 ON T1.name = T2.name WHERE T1.bool = 'neg'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE disabled = 'yes' AND payment_status = 'due'"
        ],
        "rule_sql": []
    },
    "7639": {
        "db_id": "hockey",
        "question": "Among the coaches who was never a player, who has highest percentage of game winning? Provide the given name of the coach and team he coached.",
        "ground_truth": "SELECT T2.nameGiven, T3.name FROM Coaches AS T1 INNER JOIN Master AS T2 ON T2.coachID = T1.coachID INNER JOIN Teams AS T3 ON T1.lgID = T3.lgID WHERE T1.coachID IS NOT NULL ORDER BY CAST(T1.w AS REAL) / T1.g DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT c.given_name, t.team_name, (c.wins * 100.0 / c.games) AS win_percentage\nFROM coaches c\nJOIN teams t ON c.team_id = t.team_id\nWHERE c.player_id IS NULL\nORDER BY win_percentage DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6993": {
        "db_id": "ice_hockey_draft",
        "question": "Who had the most assists of team Plymouth Whalers in the 1999-2000 season?",
        "ground_truth": "SELECT T1.PlayerName FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T2.TEAM = 'Plymouth Whalers' AND T2.SEASON = '1999-2000' ORDER BY T2.A DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, MAX(assists) \nFROM player_stats \nWHERE team = 'Plymouth Whalers' AND season = '1999-2000'\nGROUP BY player_name\nORDER BY assists DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "6039": {
        "db_id": "books",
        "question": "On what dates were books ordered at a price of 16.54?",
        "ground_truth": "SELECT T1.order_date FROM cust_order AS T1 INNER JOIN order_line AS T2 ON T1.order_id = T2.order_id WHERE T2.price = 16.54",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_date FROM orders WHERE price = 16.54;"
        ],
        "rule_sql": []
    },
    "9330": {
        "db_id": "movie_3",
        "question": "Please provide the full name of the customer at 692 Joliet Street.",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM address AS T1 INNER JOIN customer AS T2 ON T1.address_id = T2.address_id WHERE T1.address = '692 Joliet Street'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM customers WHERE address = '692 Joliet Street';"
        ],
        "rule_sql": []
    },
    "1602": {
        "db_id": "car_retails",
        "question": "To whom does the employee have to inform that is the sales representative of the French customer?",
        "ground_truth": "SELECT T1.reportsTo FROM employees AS T1 INNER JOIN customers AS T2 ON T1.employeeNumber = T2.salesRepEmployeeNumber WHERE T2.country = 'France'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT e.first_name, e.last_name \nFROM employees e \nJOIN customers c ON e.employee_id = c.customer_id \nWHERE c.country = 'France' AND c.sales_representative = 'Yes';"
        ],
        "rule_sql": []
    },
    "2364": {
        "db_id": "superstore",
        "question": "Which order of Logitech G600 MMO Gaming Mouse has the highest total cost?",
        "ground_truth": "SELECT T1.`Order ID` FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Product Name` = 'Logitech G600 MMO Gaming Mouse' GROUP BY T1.`Order ID` ORDER BY SUM((T1.Sales / (1 - T1.Discount)) * T1.Quantity - T1.Profit) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT order_id, MAX(quantity) as highest_total_cost FROM orders WHERE product_name = 'Logitech G600 MMO Gaming Mouse' GROUP BY order_id ORDER BY highest_total_cost DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6935": {
        "db_id": "ice_hockey_draft",
        "question": "Who is the most valuable player in QMJHL league during the 2004-2005 season?",
        "ground_truth": "SELECT T2.PlayerName FROM SeasonStatus AS T1 INNER JOIN PlayerInfo AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.SEASON BETWEEN '2004' AND '2005' AND T1.LEAGUE = 'QMJHL' ORDER BY T1.P DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name FROM players WHERE league = 'QMJHL' AND season = '2004-2005' ORDER BY goals DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9269": {
        "db_id": "movie_3",
        "question": "What is the total amount paid for rentals made on July 29, 2005?",
        "ground_truth": "SELECT SUM(T2.amount) FROM rental AS T1 INNER JOIN payment AS T2 ON T1.rental_id = T2.rental_id WHERE date(T1.rental_date) = '2005-07-29%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(amount) FROM payment WHERE rental_date = '2005-07-29'"
        ],
        "rule_sql": []
    },
    "7384": {
        "db_id": "works_cycles",
        "question": "Which department has the most number of night shifts?",
        "ground_truth": "SELECT T3.Name FROM Shift AS T1 INNER JOIN EmployeeDepartmentHistory AS T2 ON T1.ShiftId = T2.ShiftId INNER JOIN Department AS T3 ON T2.DepartmentID = T3.DepartmentID GROUP BY T2.DepartmentID ORDER BY COUNT(T1.Name = 'Night') DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, COUNT(*) as night_shifts FROM shifts WHERE shift_type = 'night' GROUP BY department ORDER BY night_shifts DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8891": {
        "db_id": "cookbook",
        "question": "How many ingredients are there in Apricot Yogurt Parfaits?",
        "ground_truth": "SELECT COUNT(*) FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id WHERE T1.title = 'Apricot Yogurt Parfaits'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ingredients WHERE recipe_name = 'Apricot Yogurt Parfaits';"
        ],
        "rule_sql": []
    },
    "615": {
        "db_id": "codebase_comments",
        "question": "How many solutions does the repository which has 1445 Forks contain?",
        "ground_truth": "SELECT COUNT(T2.RepoId) FROM Repo AS T1 INNER JOIN Solution AS T2 ON T1.Id = T2.RepoId WHERE T1.Forks = 1445",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM solutions WHERE repository_id = (SELECT id FROM repositories WHERE forks = 1445);"
        ],
        "rule_sql": []
    },
    "4442": {
        "db_id": "student_loan",
        "question": "What is the gender of student1000?",
        "ground_truth": "SELECT IIF(T.result = 0, 'female', 'male') AS re FROM ( SELECT COUNT(name) AS result FROM male WHERE name = 'studenT1000' ) T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT gender FROM students WHERE student_id = 'student1000';"
        ],
        "rule_sql": []
    },
    "7965": {
        "db_id": "music_platform_2",
        "question": "What is the longest review?",
        "ground_truth": "SELECT title FROM reviews ORDER BY LENGTH(content) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(LENGTH(review)) FROM reviews;"
        ],
        "rule_sql": []
    },
    "5180": {
        "db_id": "address",
        "question": "List all the locations of postal points with the area code \"410\".",
        "ground_truth": "SELECT T2.latitude, T2.longitude FROM area_code AS T1 INNER JOIN zip_data AS T2 ON T1.zip_code = T2.zip_code WHERE T1.area_code = 410",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM postal_points WHERE area_code = 410"
        ],
        "rule_sql": []
    },
    "131": {
        "db_id": "movie_platform",
        "question": "How many paying subscribers gave a rating to the movie \"One Flew Over the Cuckoo's Nest\"?",
        "ground_truth": "SELECT COUNT(T1.user_id) FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN ratings_users AS T3 ON T1.user_id = T3.user_id WHERE T2.movie_title = 'One Flew Over the Cuckoo''s Nest' AND T3.user_has_payment_method = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ratings r JOIN users u ON r.user_id = u.user_id JOIN movies m ON r.movie_id = m.movie_id WHERE m.title = 'One Flew Over the Cuckoo''s Nest' AND u.subscription_status = 'free';"
        ],
        "rule_sql": []
    },
    "652": {
        "db_id": "codebase_comments",
        "question": "Please provide the id of the respository that received the most forks among the respositories that receive 21 stars.",
        "ground_truth": "SELECT Id FROM Repo WHERE Stars = 21 AND Forks = ( SELECT MAX(Forks) FROM Repo WHERE Stars = 21 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT id FROM repositories WHERE stars = 21 ORDER BY forks DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5559": {
        "db_id": "menu",
        "question": "How many menus were created for lunch?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE event = 'LUNCH'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menus WHERE meal_type = 'dinner';"
        ],
        "rule_sql": []
    },
    "7722": {
        "db_id": "hockey",
        "question": "Among the teams with the most number of ties, how many penalty was committed by a player or coach that is not on the ice? Indicate the name of the team.",
        "ground_truth": "SELECT BenchMinor, name FROM Teams ORDER BY T DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, COUNT(*) AS penalty_count\nFROM penalties p\nJOIN teams t ON p.team_id = t.team_id\nWHERE p.on_ice = 'No'\nGROUP BY team_name\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "4063": {
        "db_id": "public_review_platform",
        "question": "List active business ids with opening times of 7AM and closing times of 8PM.",
        "ground_truth": "SELECT DISTINCT T4.business_id FROM Categories AS T1 INNER JOIN Business_Categories AS T2 ON T1.category_id = T2.category_id INNER JOIN Business_Hours AS T3 ON T2.business_id = T3.business_id INNER JOIN Business AS T4 ON T3.business_id = T4.business_id WHERE T4.active = 'true' AND T3.opening_time = '7AM' AND T3.closing_time = '8PM'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT business_id FROM business_hours WHERE opening_time = '7AM' AND closing_time = '8PM' AND status = 'active';"
        ],
        "rule_sql": []
    },
    "7870": {
        "db_id": "world",
        "question": "List all the countries in the continent of Asia that use English as their unofficial language.",
        "ground_truth": "SELECT T1.Name FROM Country AS T1 INNER JOIN CountryLanguage AS T2 ON T1.Code = T2.CountryCode WHERE T1.Continent = 'Asia' AND T2.IsOfficial = 'F' GROUP BY T1.Name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE continent = 'Asia' AND language = 'English' AND official = 'unofficial';"
        ],
        "rule_sql": []
    },
    "3055": {
        "db_id": "shakespeare",
        "question": "In the Venus and Adonis, what is the description of the last scene listed?",
        "ground_truth": "SELECT T2.Description FROM works AS T1 RIGHT JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.Title = 'Venus and Adonis' ORDER BY T2.Scene DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM scenes WHERE play = 'Venus and Adonis' ORDER BY scene_number ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4331": {
        "db_id": "simpson_episodes",
        "question": "How many episodes have the keyword \"2d animation\"?",
        "ground_truth": "SELECT COUNT(episode_id) FROM Keyword WHERE keyword = '2d animation';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM episodes WHERE keyword = '2d animation';"
        ],
        "rule_sql": []
    },
    "7394": {
        "db_id": "works_cycles",
        "question": "What is the company's profit on the product that was rated second-highest by David?",
        "ground_truth": "SELECT T2.ListPrice - T2.StandardCost FROM ProductReview AS T1 INNER JOIN Product AS T2 ON T1.ProductID = T2.ProductID WHERE T1.ReviewerName = 'David' ORDER BY T1.Rating DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT profit FROM products WHERE product_id = (SELECT product_id FROM ratings WHERE user_name = 'David' ORDER BY rating DESC LIMIT 1 OFFSET 1);"
        ],
        "rule_sql": []
    },
    "9037": {
        "db_id": "bike_share_1",
        "question": "Among the rides during the rainy days, which ride was the longest? List the start station, end station, and duration of this ride.",
        "ground_truth": "SELECT T1.start_station_name, T1.end_station_name, T1.duration FROM trip AS T1 INNER JOIN weather AS T2 ON T2.zip_code = T1.zip_code WHERE T2.events = 'Rain' OR T2.events = 'rain' ORDER BY T1.duration DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT start_station, end_station, duration FROM rides WHERE weather = 'rainy' ORDER BY duration ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "6237": {
        "db_id": "food_inspection_2",
        "question": "List down the names of the establishments with the highest risk level and failed the inspection.",
        "ground_truth": "SELECT DISTINCT T1.dba_name FROM establishment AS T1 INNER JOIN inspection AS T2 ON T1.license_no = T2.license_no WHERE T1.risk_level = 3 AND T2.results = 'Fail'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM establishments WHERE risk_level = 'High' AND inspection_result = 'Failed';"
        ],
        "rule_sql": []
    },
    "5573": {
        "db_id": "menu",
        "question": "For how many times had the dish \"Chicken gumbo\" appeared on a menu page?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.name = 'Chicken gumbo' THEN 1 ELSE 0 END) FROM Dish AS T1 INNER JOIN MenuItem AS T2 ON T1.id = T2.dish_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM menu_pages WHERE dish_name = 'Chicken gumbo';"
        ],
        "rule_sql": []
    },
    "7210": {
        "db_id": "works_cycles",
        "question": "List all the names of the stores assigned to the sales person with the id \"277\".",
        "ground_truth": "SELECT Name FROM Store WHERE SalesPersonID = 277",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT store_name FROM stores WHERE sales_person_id = 277"
        ],
        "rule_sql": []
    },
    "6261": {
        "db_id": "coinmarketcap",
        "question": "Name the coin under the token category that gives the highest max profit.",
        "ground_truth": "SELECT T1.name FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.category = 'token' ORDER BY T2.high - T2.low DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT token, MAX(max_profit) FROM coins WHERE category = 'token'"
        ],
        "rule_sql": []
    },
    "5345": {
        "db_id": "beer_factory",
        "question": "List out root beer brand that is not caffeinated and not containing cane sugar. What is the total amount sold for this products?",
        "ground_truth": "SELECT T1.BrandName, SUM(T3.PurchasePrice) FROM rootbeerbrand AS T1 INNER JOIN rootbeer AS T2 ON T1.BrandID = T2.BrandID INNER JOIN `transaction` AS T3 ON T2.RootBeerID = T3.RootBeerID WHERE T1.CaneSugar = 'FALSE' AND T1.Caffeinated = 'FALSE' GROUP BY T1.BrandName",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brand, SUM(amount_sold) as total_amount_sold \nFROM root_beer_products \nWHERE caffeinated = 'yes' AND ingredients LIKE '%cane sugar%'\nGROUP BY brand;"
        ],
        "rule_sql": []
    },
    "8244": {
        "db_id": "mondial_geo",
        "question": "Please list the name of the countries with over 5 ethnic groups.",
        "ground_truth": "SELECT T1.Name FROM country AS T1 INNER JOIN ethnicGroup AS T2 ON T1.Code = T2.Country GROUP BY T1.Name HAVING COUNT(T1.Name) > 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM countries WHERE ethnic_groups > 5;"
        ],
        "rule_sql": []
    },
    "506": {
        "db_id": "movies_4",
        "question": "Among Warner Bros. Pictures' movies, which title made the highest revenue?",
        "ground_truth": "SELECT T3.title FROM production_company AS T1 INNER JOIN movie_company AS T2 ON T1.company_id = T2.company_id INNER JOIN movie AS T3 ON T2.movie_id = T3.movie_id WHERE T1.company_name = 'Warner Bros. Pictures' ORDER BY T3.revenue DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM movies WHERE studio = 'Warner Bros. Pictures' ORDER BY budget DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5620": {
        "db_id": "shipping",
        "question": "Identify the total weight of shipments transported in 2016 by the newest Peterbilt.",
        "ground_truth": "SELECT SUM(T2.weight) FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id WHERE T1.make = 'Peterbilt' AND STRFTIME('%Y', T2.ship_date) = '2016' ORDER BY T1.model_year DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(weight) FROM shipments WHERE year = 2016 AND truck_model = 'Peterbilt' ORDER BY truck_year DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5131": {
        "db_id": "address",
        "question": "What is the area code of Phillips county in Montana?",
        "ground_truth": "SELECT DISTINCT T1.area_code FROM area_code AS T1 INNER JOIN country AS T2 ON T1.zip_code = T2.zip_code INNER JOIN state AS T3 ON T2.state = T3.abbreviation WHERE T2.county = 'PHILLIPS' AND T3.name = 'Montana'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT area_code FROM counties WHERE county_name = 'Phillips' AND state = 'Montana';"
        ],
        "rule_sql": []
    },
    "8035": {
        "db_id": "university",
        "question": "Indicate the university's name with the highest ranking score in Teaching.",
        "ground_truth": "SELECT T1.university_name FROM university AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN ranking_criteria AS T3 ON T3.id = T2.ranking_criteria_id WHERE T3.criteria_name = 'Teaching' ORDER BY T2.score DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT university_name FROM universities ORDER BY teaching_score DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "5436": {
        "db_id": "sales",
        "question": "Among products bought by Kathryn Ashe, what is the name of the product with the highest quantity?",
        "ground_truth": "SELECT T1.Name FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID INNER JOIN Customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE T3.FirstName = 'Kathryn' AND T3.LastName = 'Ashe' ORDER BY T2.Quantity DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.name \nFROM products p\nJOIN orders o ON p.id = o.product_id\nJOIN customers c ON o.customer_id = c.id\nWHERE c.name = 'Kathryn Ashe'\nORDER BY o.quantity ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "2335": {
        "db_id": "movielens",
        "question": "What are the most common film genres made by the worst directors?",
        "ground_truth": "SELECT T2.genre FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid WHERE T1.d_quality = 0 GROUP BY T2.genre ORDER BY COUNT(T2.movieid) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT g.name, COUNT(*) as film_count\nFROM films f\nJOIN directors d ON f.director_id = d.id\nJOIN genres g ON f.genre_id = g.id\nWHERE d.rating > 4.5\nGROUP BY g.name\nORDER BY film_count DESC;"
        ],
        "rule_sql": []
    },
    "341": {
        "db_id": "retail_complains",
        "question": "What percentage of complaints are from the elderly?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.age) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM complaints) AS percentage FROM complaints WHERE age > 65;"
        ],
        "rule_sql": []
    },
    "817": {
        "db_id": "social_media",
        "question": "Is 3751 the location ID for tweet with ID tw-682714048199311366?",
        "ground_truth": "SELECT LocationID FROM twitter WHERE TweetID = 'tw-682714048199311366'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT location_id FROM tweets WHERE tweet_id = 'tw-682714048199311366' AND location_id = 3751;"
        ],
        "rule_sql": []
    },
    "5535": {
        "db_id": "menu",
        "question": "Who are the sponsors of the menu whose image full height is more than 10000 mm?",
        "ground_truth": "SELECT T2.sponsor FROM MenuPage AS T1 INNER JOIN Menu AS T2 ON T2.id = T1.menu_id WHERE T1.full_height = 10000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT sponsor_name FROM menus WHERE image_full_height > 10000"
        ],
        "rule_sql": []
    },
    "1512": {
        "db_id": "synthea",
        "question": "List out the stop date of the care plan of dead patients.",
        "ground_truth": "SELECT DISTINCT T1.STOP FROM careplans AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.deathdate IS NOT NULL AND T1.STOP IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT stop_date FROM care_plans WHERE patient_status = 'dead';"
        ],
        "rule_sql": []
    },
    "8924": {
        "db_id": "cookbook",
        "question": "Which recipe has the highest calories?",
        "ground_truth": "SELECT T1.title FROM Recipe AS T1 INNER JOIN Nutrition AS T2 ON T1.recipe_id = T2.recipe_id ORDER BY T2.calories DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT recipe_name FROM recipes ORDER BY calories ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8775": {
        "db_id": "food_inspection",
        "question": "Among the inspections carried out in 2016, how many of them are routine?",
        "ground_truth": "SELECT COUNT(`date`) FROM inspections WHERE STRFTIME('%Y', `date`) = '2016' AND type = 'Routine - Unscheduled'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM inspections WHERE inspection_date LIKE '2016%' AND inspection_type = 'routine';"
        ],
        "rule_sql": []
    },
    "5593": {
        "db_id": "shipping",
        "question": "How many shipments were delivered by the oldest truck model?",
        "ground_truth": "SELECT COUNT(*) FROM truck AS T1 INNER JOIN shipment AS T2 ON T1.truck_id = T2.truck_id GROUP BY T1.model_year ORDER BY T1.model_year ASC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM shipments WHERE truck_model = (SELECT MIN(truck_model) FROM trucks);"
        ],
        "rule_sql": []
    },
    "3311": {
        "db_id": "video_games",
        "question": "Who is the publisher of 3D Lemmings?",
        "ground_truth": "SELECT T3.publisher_name FROM game AS T1 INNER JOIN game_publisher AS T2 ON T1.id = T2.game_id INNER JOIN publisher AS T3 ON T2.publisher_id = T3.id WHERE T1.game_name = '3D Lemmings'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM games WHERE title = '3D Lemmings';"
        ],
        "rule_sql": []
    },
    "2798": {
        "db_id": "professional_basketball",
        "question": "List the team name and the total wins of the team in year 2005 which has greater winning from the previous year.",
        "ground_truth": "SELECT T1.name, T1.won FROM teams AS T1 INNER JOIN ( SELECT * FROM teams WHERE year = 2004 ) AS T2 on T1.tmID = T2.tmID WHERE T1.year = 2005 and T1.won > T2.won",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, wins \nFROM teams \nWHERE year = 2005 \nAND wins > (SELECT wins FROM teams WHERE year = 2004 AND team_name = teams.team_name);"
        ],
        "rule_sql": []
    },
    "5261": {
        "db_id": "beer_factory",
        "question": "For the root beer brand with the most 5 star ratings, what is the name of the brewery?",
        "ground_truth": "SELECT T1.BreweryName FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T2.StarRating = 5 GROUP BY T1.BrandID ORDER BY COUNT(T2.StarRating) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT brewery_name FROM root_beers ORDER BY rating DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "9293": {
        "db_id": "movie_3",
        "question": "What is the category of the film Agent Truman?",
        "ground_truth": "SELECT T3.name FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T1.title = 'AGENT TRUMAN'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM films WHERE category = 'Agent Truman';"
        ],
        "rule_sql": []
    },
    "3676": {
        "db_id": "authors",
        "question": "Mention the titile of paper writen by Joe Lograsso.",
        "ground_truth": "SELECT T1.Title FROM Paper AS T1 INNER JOIN PaperAuthor AS T2 ON T1.Id = T2.PaperId WHERE T2.Name = 'Joe Lograsso'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM papers WHERE author = 'Joe Lograsso';"
        ],
        "rule_sql": []
    },
    "1914": {
        "db_id": "soccer_2016",
        "question": "How many times has SR Watson been named 'Man of the Match'?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.Player_Name = 'SR Watson' THEN 1 ELSE 0 END) FROM `Match` AS T1 INNER JOIN Player AS T2 ON T1.Man_of_the_Match = T2.Player_Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE player_of_match = 'SR Watson' AND award = 'Man of the Match';"
        ],
        "rule_sql": []
    },
    "3705": {
        "db_id": "college_completion",
        "question": "How many students for both genders graduated from a 2-year institute in Alabama in 2011?",
        "ground_truth": "SELECT SUM(T2.grad_cohort) FROM institution_details AS T1 INNER JOIN institution_grads AS T2 ON T2.unitid = T1.unitid WHERE  T2.cohort = '2y all' AND T2.year = 2011 AND T1.state = 'Alabama'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE gender = 'both' AND institute_type = '2-year' AND state = 'Alabama' AND graduation_year = 2011;"
        ],
        "rule_sql": []
    },
    "9021": {
        "db_id": "bike_share_1",
        "question": "What is the average duration of trips which are started at Adobe on Almaden station to Ryland Park?",
        "ground_truth": "SELECT AVG(duration) FROM trip WHERE start_station_name = 'Adobe on Almaden' AND end_station_name = 'Ryland Park'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(duration) FROM trips WHERE start_station = 'Adobe on Almaden' AND end_station = 'Ryland Park';"
        ],
        "rule_sql": []
    },
    "4982": {
        "db_id": "olympics",
        "question": "Which summer Olympic have the highest and lowest number of participants?",
        "ground_truth": "SELECT ( SELECT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Summer' GROUP BY T1.games_year ORDER BY COUNT(T2.person_id) DESC LIMIT 1 ) AS HIGHEST , ( SELECT T1.games_name FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id WHERE T1.season = 'Summer' GROUP BY T1.games_year ORDER BY COUNT(T2.person_id) LIMIT 1 ) AS LOWEST",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    MAX(participants) as highest_participants,\n    MIN(participants) as lowest_participants\nFROM \n    olympic_games\nWHERE \n    season = 'Summer';"
        ],
        "rule_sql": []
    },
    "2343": {
        "db_id": "movielens",
        "question": "What is the percentage difference of English and non-English-language crime movies in other countries in year 3?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.isEnglish = 'T', 1, 0)) - SUM(IIF(T1.isEnglish = 'F', 1, 0)) AS REAL) * 100 / COUNT(T1.movieid) FROM movies AS T1 INNER JOIN movies2directors AS T2 ON T1.movieid = T2.movieid WHERE T1.country = 'other' AND T1.year = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN language = 'English' THEN 1 END) * 100.0 / COUNT(*)) - \n    (COUNT(CASE WHEN language != 'English' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_difference\nFROM movies\nWHERE genre = 'Crime' \nAND country != 'USA' \nAND year = 3;"
        ],
        "rule_sql": []
    },
    "3860": {
        "db_id": "public_review_platform",
        "question": "How many Yelp_Business in Arizona has user no. 3 reviewed?",
        "ground_truth": "SELECT COUNT(T2.business_id) FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T2.state LIKE 'AZ' AND T1.user_id = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM Yelp_Business WHERE state = 'Arizona' AND user_id = 3;"
        ],
        "rule_sql": []
    },
    "5137": {
        "db_id": "address",
        "question": "Calculate the average of 2020's population in each zip code.",
        "ground_truth": "SELECT CAST(SUM(population_2020) AS REAL) / COUNT(zip_code) FROM zip_data",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT zip_code, AVG(population) FROM population_data WHERE year = 2020 GROUP BY zip_code;"
        ],
        "rule_sql": []
    },
    "5798": {
        "db_id": "language_corpus",
        "question": "How many appearances does the word ID No. 2823 have in the Wikipedia page \"Astre\"?",
        "ground_truth": "SELECT SUM(T2.occurrences) FROM pages AS T1 INNER JOIN pages_words AS T2 ON T1.pid = T2.pid WHERE T1.title = 'Astre' AND T2.wid = 2823",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM wikipedia_pages WHERE page_title = 'Astre' AND word_id = 2823;"
        ],
        "rule_sql": []
    },
    "1929": {
        "db_id": "soccer_2016",
        "question": "How many players were born before 10/16/1975, and have a bowling skill of less than 3?",
        "ground_truth": "SELECT COUNT(*) FROM Player WHERE DOB < '1975-10-16' AND Bowling_skill < 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE birth_date < '1975-10-16' AND bowling_skill > 3;"
        ],
        "rule_sql": []
    },
    "4498": {
        "db_id": "student_loan",
        "question": "Calculate the percentage of female students.",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.name IS NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.name) FROM person AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) * 100 / (SELECT COUNT(*) FROM students) AS percentage FROM students WHERE gender = 'male';"
        ],
        "rule_sql": []
    },
    "4100": {
        "db_id": "public_review_platform",
        "question": "How many businesses are not closed in the city of Mesa?",
        "ground_truth": "SELECT COUNT(business_id) FROM Business WHERE city = 'Mesa' AND active = 'true'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Mesa' AND status = 'closed';"
        ],
        "rule_sql": []
    },
    "5838": {
        "db_id": "airline",
        "question": "What is the number of air carriers in the database?",
        "ground_truth": "SELECT COUNT(Code) FROM `Air Carriers`",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM carriers WHERE type = 'airline';"
        ],
        "rule_sql": []
    },
    "2670": {
        "db_id": "regional_sales",
        "question": "Name the products via wholesale channel of the store under Pacific/Honolulu time zone.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE  WHEN T3.`Time Zone` = 'Pacific/Honolulu' AND T2.`Sales Channel` = 'Wholesale' THEN T1.`Product Name` ELSE NULL END AS T FROM Products T1 INNER JOIN `Sales Orders` T2 ON T2._ProductID = T1.ProductID INNER JOIN `Store Locations` T3 ON T3.StoreID = T2._StoreID ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE channel = 'wholesale' AND timezone = 'Pacific/Honolulu';"
        ],
        "rule_sql": []
    },
    "894": {
        "db_id": "cs_semester",
        "question": "How many students got an A in Applied Deep Learning?",
        "ground_truth": "SELECT COUNT(T2.student_id) FROM course AS T1 INNER JOIN registration AS T2 ON T1.course_id = T2.course_id WHERE T2.grade = 'A' AND T1.name = 'Applied Deep Learning '",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE grade = 'A' AND course = 'Applied Deep Learning';"
        ],
        "rule_sql": []
    },
    "5034": {
        "db_id": "olympics",
        "question": "What is the percentage of people whose age greater than 24 and participate in winter season?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.age > 24 AND T1.season = 'Winter' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T2.games_id) FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM people)) AS percentage\nFROM people p\nJOIN participation pt ON p.id = pt.person_id\nJOIN seasons s ON pt.season_id = s.id\nWHERE p.age > 24 AND s.season_name = 'Winter';"
        ],
        "rule_sql": []
    },
    "4505": {
        "db_id": "student_loan",
        "question": "Please provide a gender breakdown for each organization.",
        "ground_truth": "SELECT IIF(T2.name IS NULL, 'female', 'male') AS gender FROM enlist AS T1 LEFT JOIN male AS T2 ON T2.name = T1.name GROUP BY T1.organ",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT organization, COUNT(*) as total_count FROM employees GROUP BY organization;"
        ],
        "rule_sql": []
    },
    "2704": {
        "db_id": "regional_sales",
        "question": "Which regions have online sales channels that have the most discounts?",
        "ground_truth": "SELECT T2.Region FROM `Sales Orders` AS T1 INNER JOIN `Sales Team` AS T2 ON T2.SalesTeamID = T1._SalesTeamID WHERE T1.`Sales Channel` = 'Online' ORDER BY T1.`Discount Applied` DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT region, COUNT(*) as discount_count \nFROM sales_channels \nWHERE channel_type = 'online' \nGROUP BY region \nORDER BY discount_count DESC;"
        ],
        "rule_sql": []
    },
    "5118": {
        "db_id": "address",
        "question": "How many counties are there in Virginia State?",
        "ground_truth": "SELECT COUNT(T2.county) FROM state AS T1 INNER JOIN country AS T2 ON T1.abbreviation = T2.state WHERE T1.name = 'Virginia'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM states WHERE state_name = 'Virginia';"
        ],
        "rule_sql": []
    },
    "4988": {
        "db_id": "olympics",
        "question": "At what age did Michael Fred Phelps, II join the Olympics?",
        "ground_truth": "SELECT T2.age FROM person AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.person_id WHERE T1.full_name = 'Michael Fred Phelps, II' ORDER BY T2.age LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT age FROM olympians WHERE name = 'Michael Fred Phelps, II' AND event = 'Olympics';"
        ],
        "rule_sql": []
    },
    "2193": {
        "db_id": "world_development_indicators",
        "question": "Name the country in which the topic is about Poverty: Shared Prosperity. Indicate the long name of the country.",
        "ground_truth": "SELECT DISTINCT T1.LongName FROM Country AS T1 INNER JOIN footnotes AS T2 ON T1.CountryCode = T2.Countrycode INNER JOIN Series AS T3 ON T2.Seriescode = T3.SeriesCode WHERE T3.Topic = 'Poverty: Shared prosperity'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country_name FROM countries WHERE topic = 'Poverty: Shared Prosperity';"
        ],
        "rule_sql": []
    },
    "5501": {
        "db_id": "menu",
        "question": "List the dishes that appeared at the left upper corner of the CHAS.BRADLEY'S OYSTER & DINING ROOM\"s sponsored menu.",
        "ground_truth": "SELECT T4.name FROM MenuItem AS T1 INNER JOIN MenuPage AS T2 ON T1.menu_page_id = T2.id INNER JOIN Menu AS T3 ON T2.menu_id = T3.id INNER JOIN Dish AS T4 ON T1.dish_id = T4.id WHERE T3.sponsor = 'CHAS.BRADLEY''S OYSTER & DINING ROOM' AND T1.xpos < 0.25 AND T1.ypos < 0.25",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name FROM menu_items WHERE restaurant_name = 'CHAS.BRADLEY''S OYSTER & DINING ROOM' AND position_x = 0 AND position_y = 0;"
        ],
        "rule_sql": []
    },
    "534": {
        "db_id": "movies_4",
        "question": "Which department has the most people?",
        "ground_truth": "SELECT T1.department_name FROM department AS T1 INNER JOIN movie_crew AS T2 ON T1.department_id = T2.department_id GROUP BY T1.department_id ORDER BY COUNT(T2.department_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT department, COUNT(*) as total_people FROM employees GROUP BY department ORDER BY total_people ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7070": {
        "db_id": "works_cycles",
        "question": "Among the active employees, how many of them have a courtesy title of \"Mr\"?",
        "ground_truth": "SELECT COUNT(T1.BusinessEntityID) FROM Employee AS T1 INNER JOIN Person AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.CurrentFlag = 1 AND T2.Title = 'Mr.'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE active = 1 AND title = 'Mr';"
        ],
        "rule_sql": []
    },
    "8838": {
        "db_id": "food_inspection",
        "question": "How many of the businesses are located at 1825 POST St #223, San Francisco?",
        "ground_truth": "SELECT COUNT(business_id) FROM businesses WHERE address = '1825 POST St #223' AND city = 'SAN FRANCISCO'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE address = '1825 POST St #223' AND city = 'San Francisco';"
        ],
        "rule_sql": []
    },
    "1988": {
        "db_id": "soccer_2016",
        "question": "What are the teams that played in a match with the point of winning margin of 38 on April 30, 2009?",
        "ground_truth": "SELECT T1.Team_Name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.Team_Id = T2.Team_1 WHERE T2.win_margin = 38 AND match_date = '2009-04-30'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM matches WHERE winning_margin = 38 AND match_date = '2009-04-30';"
        ],
        "rule_sql": []
    },
    "140": {
        "db_id": "movie_platform",
        "question": "What is the percentage of list created by user who was a subscriber when he created the list?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN user_subscriber = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(list_id) FROM lists_users",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.subscription_status = 'subscriber' THEN l.list_id END) * 100.0 / COUNT(l.list_id)) AS percentage\nFROM lists l\nJOIN users u ON l.user_id = u.user_id\nWHERE u.subscription_status = 'subscriber';"
        ],
        "rule_sql": []
    },
    "2669": {
        "db_id": "regional_sales",
        "question": "Count the number of orders made from the store in city with population of 3000000 to 4000000.",
        "ground_truth": "SELECT COUNT(T1.OrderNumber) FROM `Sales Orders` AS T1 INNER JOIN `Store Locations` AS T2 ON T2.StoreID = T1._StoreID WHERE T2.Population BETWEEN 3000000 AND 4000000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE store_id IN (SELECT store_id FROM stores WHERE city_population BETWEEN 3000000 AND 4000000);"
        ],
        "rule_sql": []
    },
    "878": {
        "db_id": "cs_semester",
        "question": "How many research assistants does the female professor with the lowest teaching ability have?",
        "ground_truth": "SELECT COUNT(T1.student_id) FROM RA AS T1 INNER JOIN prof AS T2 ON T1.prof_id = T2.prof_id WHERE T2.teachingability = '1' AND T2.gender = 'Female'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM professors p\nJOIN research_assistants ra ON p.professor_id = ra.professor_id\nWHERE p.gender = 'female'\nORDER BY p.teaching_ability ASC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1966": {
        "db_id": "soccer_2016",
        "question": "List the ball IDs, scores, and innings numbers in the over ID 20 of match ID \"335988\".",
        "ground_truth": "SELECT Ball_Id, Runs_Scored, Innings_No FROM Batsman_Scored WHERE Match_Id = 335988 AND Over_Id = 20",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT ball_id, score, innings FROM balls WHERE over_id = 20 AND match_id = 335988"
        ],
        "rule_sql": []
    },
    "8423": {
        "db_id": "mondial_geo",
        "question": "In which group of islands is Rinjani Mountain located?",
        "ground_truth": "SELECT T1.Islands FROM island AS T1 INNER JOIN mountainOnIsland AS T2 ON T1.Name = T2.Island INNER JOIN mountain AS T3 ON T3.Name = T2.Mountain WHERE T3.Name = 'Rinjani'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT group_name FROM islands WHERE mountain_name = 'Rinjani';"
        ],
        "rule_sql": []
    },
    "4249": {
        "db_id": "simpson_episodes",
        "question": "How many crews were born in the USA?",
        "ground_truth": "SELECT COUNT(name) FROM Person WHERE birth_country = 'USA';",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM crews WHERE country = 'USA';"
        ],
        "rule_sql": []
    },
    "117": {
        "db_id": "movie_platform",
        "question": "Give the number of followers for the user who posted the most lists.",
        "ground_truth": "SELECT SUM(T1.list_followers) FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id GROUP BY T1.user_id ORDER BY COUNT(T1.list_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM followers WHERE user_id = (SELECT user_id FROM lists GROUP BY user_id ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "7404": {
        "db_id": "works_cycles",
        "question": "Which product has the highest standard cost?",
        "ground_truth": "SELECT Name FROM Product ORDER BY StandardCost DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY standard_cost ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3264": {
        "db_id": "donor",
        "question": "What is the total price of items brought from ABC School Supply with a listed type of Other? Also include the list of the buyers' coordinates and school districts they belong to.",
        "ground_truth": "SELECT T2.item_unit_price * T2.item_quantity price, T1.school_latitude, T1.school_longitude FROM projects AS T1 INNER JOIN resources AS T2 ON T1.projectid = T2.projectid WHERE T2.vendor_name = 'ABC School Supply' AND T2.project_resource_type = 'Other' AND T1.school_district = 'Hillsborough Co Pub Sch Dist'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(price) as total_price, coordinates, school_district \nFROM purchases \nWHERE supplier = 'ABC School Supply' AND type = 'Other' \nGROUP BY coordinates, school_district;"
        ],
        "rule_sql": []
    },
    "2951": {
        "db_id": "professional_basketball",
        "question": "Which team did the all league rebound champion play in 1997? Give the full name of the team.",
        "ground_truth": "SELECT T1.name FROM teams AS T1 INNER JOIN players_teams AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T2.year = 1997 GROUP BY T1.name ORDER BY SUM(rebounds + dRebounds) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE year = 1997 AND player_name = 'rebound champion';"
        ],
        "rule_sql": []
    },
    "392": {
        "db_id": "retail_complains",
        "question": "In 2014, what is the percentage of complaints from consumers in Houston that the delay was over 5 days?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN strftime('%J', T2.`Date sent to company`) - strftime('%J', T2.`Date received`) > 5 THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.city = 'Houston' AND strftime('%Y', T2.`Date received`) = '2014'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN delay_days > 5 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM complaints\nWHERE year = 2014 \nAND city = 'Houston'\nAND consumer_type = 'consumer';"
        ],
        "rule_sql": []
    },
    "3753": {
        "db_id": "college_completion",
        "question": "What is the average SAT value for incoming students in all of the schools located in the state with the lowest state appropriations to higher education in fiscal year 2011 per resident?",
        "ground_truth": "SELECT AVG(t1.med_sat_value) FROM institution_details AS T1 INNER JOIN state_sector_details AS T2 ON t1.state = t2.state ORDER BY t2.state_appr_value LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(SAT_AVG) \nFROM schools \nWHERE STATE = (\n    SELECT STATE \n    FROM appropriations \n    WHERE YEAR = 2011 \n    ORDER BY APPROPRIATIONS_PER_RESIDENT ASC \n    LIMIT 1\n);"
        ],
        "rule_sql": []
    },
    "7559": {
        "db_id": "image_and_language",
        "question": "Name the object class of the image with lowest bounding box.",
        "ground_truth": "SELECT T2.OBJ_CLASS FROM IMG_OBJ AS T1 INNER JOIN OBJ_CLASSES AS T2 ON T1.OBJ_CLASS_ID = T2.OBJ_CLASS_ID ORDER BY T1.H LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT object_class FROM images ORDER BY bounding_box ASC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "258": {
        "db_id": "retail_complains",
        "question": "What was the serve time for the complaint call from client \"C00007127\" on 2017/2/22?",
        "ground_truth": "SELECT T1.ser_time FROM callcenterlogs AS T1 INNER JOIN events AS T2 ON T1.`Complaint ID` = T2.`Complaint ID` WHERE T2.Client_ID = 'C00007127' AND T1.`Date received` = '2017-02-22'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT serve_time FROM complaints WHERE client_id = 'C00007127' AND date = '2017/2/22';"
        ],
        "rule_sql": []
    },
    "8869": {
        "db_id": "cookbook",
        "question": "Is the ingredient \"graham cracker crumbs\" optional in the recipe \"Raspberry Chiffon Pie\"?",
        "ground_truth": "SELECT T2.optional FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T1.title = 'Raspberry Chiffon Pie' AND T3.name = 'graham cracker crumbs'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT optional FROM ingredients WHERE name = 'graham cracker crumbs' AND recipe_name = 'Raspberry Chiffon Pie';"
        ],
        "rule_sql": []
    },
    "1296": {
        "db_id": "law_episode",
        "question": "Who is the person who appeared the most in the series? Calculate in percentage how many times he or she appeared.",
        "ground_truth": "SELECT T2.person_id, CAST(COUNT(T2.person_id) AS REAL) * 100 / ( SELECT COUNT(T2.person_id) AS num FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id ) AS per FROM Credit AS T1 INNER JOIN Person AS T2 ON T2.person_id = T1.person_id GROUP BY T2.person_id ORDER BY COUNT(T2.person_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, COUNT(*) * 100 / (SELECT COUNT(*) FROM episodes) AS percentage FROM characters GROUP BY name ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "2471": {
        "db_id": "shooting",
        "question": "For case number '134472-2015', list the last name of the officers involved and state the subject statuses.",
        "ground_truth": "SELECT T2.last_name, T1.subject_statuses FROM incidents AS T1 INNER JOIN officers AS T2 ON T1.case_number = T2.case_number WHERE T1.case_number = '134472-2015'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT officer_last_name, subject_status FROM cases WHERE case_number = '134472-2015';"
        ],
        "rule_sql": []
    },
    "2479": {
        "db_id": "shooting",
        "question": "Of the black officers, how many of them investigated cases between the years 2010 and 2015?",
        "ground_truth": "SELECT COUNT(T1.case_number) FROM officers AS T1 INNER JOIN incidents AS T2 ON T2.case_number = T1.case_number WHERE T1.race = 'B' AND T2.date BETWEEN '2010-01-01' AND '2015-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM officers WHERE race = 'Black' AND year BETWEEN 2010 AND 2015;"
        ],
        "rule_sql": []
    },
    "9084": {
        "db_id": "bike_share_1",
        "question": "Does the bike with Id number 16 making any intercity trip? If yes, calculate the total travel duration during all the intercity trip. Convert the duration to hour.",
        "ground_truth": "SELECT T1.end_station_name, T2.city, CAST(SUM(T1.duration) AS REAL) / 3600 FROM trip AS T1 INNER JOIN station AS T2 ON T2.name = T1.start_station_name WHERE T1.bike_id = 16 AND T1.start_station_name != T1.end_station_name",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(TIMESTAMPDIFF(HOUR, start_time, end_time)) AS total_hours \nFROM trips \nWHERE bike_id = 16 AND trip_type = 'intercity'"
        ],
        "rule_sql": []
    },
    "4577": {
        "db_id": "mental_health_survey",
        "question": "How many users believed that their productivity is ever affected by a mental health issue overall?",
        "ground_truth": "SELECT COUNT(T1.UserID) FROM Answer AS T1 INNER JOIN Question AS T2 ON T1.QuestionID = T2.questionid WHERE T2.questionid = 54 AND T1.AnswerText LIKE 'Yes'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE productivity_affected = 'yes'"
        ],
        "rule_sql": []
    },
    "3920": {
        "db_id": "public_review_platform",
        "question": "What is the review length of user 60776 to business with business ID 1?",
        "ground_truth": "SELECT review_length FROM Reviews WHERE user_id = 60776 AND business_id = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT LENGTH(review_text) FROM reviews WHERE user_id = 60776 AND business_id = 1;"
        ],
        "rule_sql": []
    },
    "4851": {
        "db_id": "legislator",
        "question": "What is the ratio between male and female legislators?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN gender_bio = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN gender_bio = 'F' THEN 1 ELSE 0 END) FROM historical",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN gender = 'male' THEN 1 END) AS male_count,\n    COUNT(CASE WHEN gender = 'female' THEN 1 END) AS female_count,\n    COUNT(CASE WHEN gender = 'male' THEN 1 END) / COUNT(CASE WHEN gender = 'female' THEN 1 END) AS ratio\nFROM legislators\nWHERE gender IN ('male', 'female');"
        ],
        "rule_sql": []
    },
    "6700": {
        "db_id": "retails",
        "question": "Calculates the profit processed by Supplier No. 7414 on order No. 817154.",
        "ground_truth": "SELECT T1.l_extendedprice * (1 - T1.l_discount) - T2.ps_supplycost * T1.l_quantity FROM lineitem AS T1 INNER JOIN partsupp AS T2 ON T1.l_suppkey = T2.ps_suppkey WHERE T1.l_suppkey = 7414 AND T1.l_orderkey = 817154",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT SUM(quantity * unit_price) AS profit FROM order_details WHERE supplier_id = 7414 AND order_id = 817154;"
        ],
        "rule_sql": []
    },
    "6644": {
        "db_id": "retail_world",
        "question": "How many orders were handled by Michael Suyama. State the order ID.",
        "ground_truth": "SELECT COUNT(T2.OrderID) FROM Employees AS T1 INNER JOIN Orders AS T2 ON T1.EmployeeID = T2.EmployeeID WHERE T1.FirstName = 'Michael' AND T1.LastName = 'Suyama'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM orders WHERE employee_id = (SELECT employee_id FROM employees WHERE first_name = 'Michael' AND last_name = 'Suyama');"
        ],
        "rule_sql": []
    },
    "8315": {
        "db_id": "mondial_geo",
        "question": "Among the countries that use Bosnian as their language, how many of them don't have a positive population growth rate?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Name) FROM country AS T1 INNER JOIN language AS T2 ON T1.Code = T2.Country INNER JOIN population AS T3 ON T3.Country = T2.Country WHERE T2.Name = 'Bosnian' AND T3.Population_Growth < 0",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM country \nJOIN country_language ON country.code = country_language.country_code \nWHERE country_language.language = 'Bosnian' \nAND country.population_growth <= 0;"
        ],
        "rule_sql": []
    },
    "4543": {
        "db_id": "student_loan",
        "question": "Among the male students, list down the names of students with payment due.",
        "ground_truth": "SELECT T1.name FROM male AS T1 INNER JOIN no_payment_due AS T2 ON T1.name = T2.name WHERE T2.bool = 'pos'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM students WHERE gender = 'female' AND payment_due > 0;"
        ],
        "rule_sql": []
    },
    "7795": {
        "db_id": "hockey",
        "question": "In the history of all the Quebec Bulldogs, which goalie had the most play minutes for the team? Give the full name.",
        "ground_truth": "SELECT T2.firstName, T2.lastName FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID INNER JOIN Teams AS T3 ON T1.tmID = T3.tmID AND T1.year = T3.year WHERE T3.name = 'Quebec Bulldogs' AND T2.pos = 'D' GROUP BY T1.playerID, T2.firstName, T2.lastName ORDER BY SUM(T1.Min) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.firstName, p.lastName, SUM(gp.timeOnIce) as total_minutes\nFROM player p\nJOIN game_goalie_stats gs ON p.playerId = gs.playerId\nJOIN team t ON gs.teamId = t.teamId\nWHERE t.name = 'Quebec Bulldogs'\nGROUP BY p.playerId\nORDER BY total_minutes DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3467": {
        "db_id": "video_games",
        "question": "Calculate the number of game publisher IDs for games released in 1984.",
        "ground_truth": "SELECT COUNT(T.game_publisher_id) FROM game_platform AS T WHERE T.release_year = 1984",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE release_year = 1984;"
        ],
        "rule_sql": []
    },
    "2994": {
        "db_id": "shakespeare",
        "question": "In \"Twelfth Night, Or What You Will\", what is the description of the chapter in 2nd scene, Act 2?",
        "ground_truth": "SELECT T2.Description FROM works AS T1 INNER JOIN chapters AS T2 ON T1.id = T2.work_id WHERE T1.LongTitle = 'Twelfth Night, Or What You Will' AND T2.Scene = 2 AND T2.Act = 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM chapters WHERE play_title = 'Twelfth Night, Or What You Will' AND act_number = 2 AND scene_number = 2"
        ],
        "rule_sql": []
    },
    "8620": {
        "db_id": "chicago_crime",
        "question": "What is the percentage of larceny cases among all cases that happened in Edgewater community?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T3.title = 'Larceny' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.case_number) FROM Community_Area AS T1 INNER JOIN Crime AS T2 ON T1.community_area_no = T2.community_area_no INNER JOIN FBI_Code AS T3 ON T2.fbi_code_no = T3.fbi_code_no WHERE T1.community_area_name = 'Edgewater'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN crime_type = 'LARCENY' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM crimes\nWHERE community = 'Edgewater';"
        ],
        "rule_sql": []
    },
    "7261": {
        "db_id": "works_cycles",
        "question": "Among the vendors with maximum orders betweeen 500 to 750, which vendor has the 10th highest profit on net?",
        "ground_truth": "SELECT T2.Name FROM ProductVendor AS T1 INNER JOIN Vendor AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.MaxOrderQty BETWEEN 500 AND 750 ORDER BY T1.LastReceiptCost - T1.StandardPrice DESC LIMIT 9, 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT vendor_name, profit_on_net \nFROM vendors \nWHERE total_orders BETWEEN 500 AND 750 \nORDER BY profit_on_net DESC \nLIMIT 1 OFFSET 9;"
        ],
        "rule_sql": []
    },
    "3348": {
        "db_id": "video_games",
        "question": "How many games were released on PS4 in 2014?",
        "ground_truth": "SELECT COUNT(DISTINCT T3.game_id) FROM platform AS T1 INNER JOIN game_platform AS T2 ON T1.id = T2.platform_id INNER JOIN game_publisher AS T3 ON T2.game_publisher_id = T3.id WHERE T1.platform_name = 'PS4' AND T2.release_year = 2014",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE platform = 'PS4' AND year = 2013;"
        ],
        "rule_sql": []
    },
    "1816": {
        "db_id": "soccer_2016",
        "question": "State the name of the city with the most venues.",
        "ground_truth": "SELECT T1.City_Name FROM City AS T1 INNER JOIN Venue AS T2 ON T1.City_Id = T2.City_Id GROUP BY T1.City_Id ORDER BY COUNT(T2.Venue_Id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM venues ORDER BY city DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "8399": {
        "db_id": "mondial_geo",
        "question": "What's the number of infant mortality in Switzerland in a year?",
        "ground_truth": "SELECT T2.Infant_Mortality * T1.Population * T2.Population_Growth FROM country AS T1 INNER JOIN population AS T2 ON T1.Code = T2.Country WHERE T1.Name = 'Switzerland'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM mortality_data WHERE country = 'Switzerland' AND age_group = 'infant' AND year = 2023;"
        ],
        "rule_sql": []
    },
    "6195": {
        "db_id": "food_inspection_2",
        "question": "List down the address of employees who did inspection dated 11/5/2010.",
        "ground_truth": "SELECT DISTINCT T1.address FROM employee AS T1 INNER JOIN inspection AS T2 ON T1.employee_id = T2.employee_id WHERE T2.inspection_date = '2010-11-05'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT address FROM employees WHERE inspection_date = '11/5/2010';"
        ],
        "rule_sql": []
    },
    "1032": {
        "db_id": "computer_student",
        "question": "How many courses were taught by more than 4 people?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT COUNT(course_id) FROM taughtBy GROUP BY course_id HAVING COUNT(course_id) > 4 )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM courses WHERE instructor_count > 4;"
        ],
        "rule_sql": []
    },
    "6989": {
        "db_id": "ice_hockey_draft",
        "question": "Which team has the most Swedish?",
        "ground_truth": "SELECT T.TEAM FROM ( SELECT T2.TEAM, COUNT(DISTINCT T1.ELITEID) FROM PlayerInfo AS T1 INNER JOIN SeasonStatus AS T2 ON T1.ELITEID = T2.ELITEID WHERE T1.nation = 'Sweden' GROUP BY T2.TEAM ORDER BY COUNT(DISTINCT T1.ELITEID) DESC LIMIT 1 ) AS T",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT team_name, COUNT(*) as swedish_count FROM players WHERE nationality = 'Swedish' GROUP BY team_name ORDER BY swedish_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4112": {
        "db_id": "public_review_platform",
        "question": "How many open businesses in the City of Phoenix have users left a long review?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.business_id) FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id WHERE T1.review_length = 'Long' AND T2.active = 'true' AND T2.city = 'Phoenix'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses b \nJOIN reviews r ON b.business_id = r.business_id \nWHERE b.city = 'Phoenix' AND b.is_open = 1 AND LENGTH(r.text) > 1000;"
        ],
        "rule_sql": []
    },
    "940": {
        "db_id": "cs_semester",
        "question": "List the student's email with grade of B in a course with difficulty greater than the 80% of average difficulty of all courses.",
        "ground_truth": "SELECT T2.email FROM registration AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id INNER JOIN course AS T3 ON T1.course_id = T3.course_id WHERE T1.grade = 'B' GROUP BY T3.diff HAVING T3.diff > AVG(T3.diff) * 0.8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.email \nFROM students s\nJOIN grades g ON s.student_id = g.student_id\nJOIN courses c ON g.course_id = c.course_id\nWHERE g.grade = 'B' \nAND c.difficulty > (SELECT AVG(difficulty) * 0.8 FROM courses)"
        ],
        "rule_sql": []
    },
    "8872": {
        "db_id": "cookbook",
        "question": "How many recipes include the ingredient \"graham cracker crumbs\"?",
        "ground_truth": "SELECT COUNT(*) FROM Ingredient AS T1 INNER JOIN Quantity AS T2 ON T1.ingredient_id = T2.ingredient_id WHERE T1.name = 'graham cracker crumbs'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM recipes WHERE ingredient = 'graham cracker crumbs';"
        ],
        "rule_sql": []
    },
    "7616": {
        "db_id": "hockey",
        "question": "For all the deceased players who are good at both left and right hand, list the player's name and the age when he died.",
        "ground_truth": "SELECT firstName, lastName, deathYear - birthYear FROM Master WHERE shootCatch IS NULL AND deathYear IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, death_age FROM players WHERE handedness = 'both' AND status = 'deceased';"
        ],
        "rule_sql": []
    },
    "1265": {
        "db_id": "law_episode",
        "question": "For the episode with the most votes, give its air date.",
        "ground_truth": "SELECT T2.air_date FROM Vote AS T1 INNER JOIN Episode AS T2 ON T2.episode_id = T1.episode_id GROUP BY T2.episode_id ORDER BY SUM(T1.votes) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT air_date FROM episodes ORDER BY votes DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "4845": {
        "db_id": "legislator",
        "question": "What is the name of the legislator with the ID of W000059?",
        "ground_truth": "SELECT first_name, last_name FROM historical WHERE bioguide_id = 'W000059'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM legislators WHERE id = 'W000059';"
        ],
        "rule_sql": []
    },
    "5868": {
        "db_id": "airline",
        "question": "What is the tail number of a Compass Airline's plane that flew the most number of flights from LAX to ABQ?",
        "ground_truth": "SELECT T2.OP_CARRIER_AIRLINE_ID FROM `Air Carriers` AS T1 INNER JOIN Airlines AS T2 ON T1.Code = T2.OP_CARRIER_AIRLINE_ID WHERE T1.Description = 'Compass Airlines: CP' AND T2.ORIGIN = 'LAX' AND T2.DEST = 'ABQ' GROUP BY T2.OP_CARRIER_AIRLINE_ID ORDER BY COUNT(T2.OP_CARRIER_AIRLINE_ID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT tail_num FROM flights WHERE origin = 'LAX' AND dest = 'ABQ' GROUP BY tail_num ORDER BY COUNT(*) DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1118": {
        "db_id": "talkingdata",
        "question": "Among the female users that uses OPPO as their phone brand, what is the percentage of them of the user that uses R815T model to install the app?",
        "ground_truth": "SELECT SUM(IIF(T1.phone_brand = 'OPPO', 1, 0)) / SUM(IIF(T1.device_id = 'R815T', 1, 0)) AS num FROM phone_brand_device_model2 AS T1 INNER JOIN gender_age AS T2 ON T1.device_id = T2.device_id WHERE T2.gender = 'F'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN model = 'R815T' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM users\nWHERE gender = 'female' AND brand = 'OPPO'"
        ],
        "rule_sql": []
    },
    "9397": {
        "db_id": "movie_3",
        "question": "What are the films that are least rented by the customers?",
        "ground_truth": "SELECT T.title FROM ( SELECT T3.title, COUNT(T1.customer_id) AS num FROM rental AS T1 INNER JOIN inventory AS T2 ON T1.inventory_id = T2.inventory_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id GROUP BY T3.title ) AS T ORDER BY T.num DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title, COUNT(r.rental_id) AS rental_count\nFROM film f\nJOIN inventory i ON f.film_id = i.film_id\nJOIN rental r ON i.inventory_id = r.inventory_id\nGROUP BY f.film_id\nORDER BY rental_count ASC\nLIMIT 10;"
        ],
        "rule_sql": []
    },
    "7800": {
        "db_id": "hockey",
        "question": "What's the decrease rate of the game plays did David Aebischer after he got traded in 2005?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T1.year = 2005 THEN T1.GP ELSE 0 END) - SUM(CASE WHEN T1.year = 2006 THEN T1.GP ELSE 0 END)) AS REAL) * 100 / SUM(CASE WHEN T1.year = 2005 THEN T1.GP ELSE 0 END) FROM Goalies AS T1 INNER JOIN Master AS T2 ON T1.playerID = T2.playerID WHERE T2.firstName = 'David' AND T2.lastName = 'Aebischer'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN season = '2004-2005' THEN games_played ELSE 0 END) - \n     SUM(CASE WHEN season = '2005-2006' THEN games_played ELSE 0 END)) / \n    SUM(CASE WHEN season = '2004-2005' THEN games_played ELSE 0 END) * 100 AS decrease_rate\nFROM player_stats\nWHERE player_name = 'David Aebischer'\nAND team = 'Colorado Avalanche';"
        ],
        "rule_sql": []
    },
    "3108": {
        "db_id": "cars",
        "question": "How many of the cars from Japan weighed less than 3000?",
        "ground_truth": "SELECT COUNT(*) FROM price AS T1 INNER JOIN production AS T2 ON T1.ID = T2.ID INNER JOIN country AS T3 ON T3.origin = T2.country INNER JOIN data AS T4 ON T4.ID = T1.ID WHERE T3.country = 'Japan' AND T4.weight < 3000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cars WHERE country = 'Japan' AND weight > 3000;"
        ],
        "rule_sql": []
    },
    "5727": {
        "db_id": "language_corpus",
        "question": "Calculate the average number of repetitions in the pairs of words in which the first word id is number 34.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN w1st = 34 THEN 1 ELSE 0 END) AS REAL) / COUNT(w1st) FROM biwords",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(repetitions) FROM word_pairs WHERE first_word_id = 34;"
        ],
        "rule_sql": []
    },
    "4599": {
        "db_id": "mental_health_survey",
        "question": "State the number of questions that were asked in the \"mental health survey for 2018\".",
        "ground_truth": "SELECT COUNT(T1.QuestionID) FROM Answer AS T1 INNER JOIN Survey AS T2 ON T1.SurveyID = T2.SurveyID WHERE T2.Description = 'mental health survey for 2018'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM questions WHERE survey_name = 'mental health survey for 2018';"
        ],
        "rule_sql": []
    },
    "5992": {
        "db_id": "books",
        "question": "List all of the books that were published in 1995.",
        "ground_truth": "SELECT title FROM book WHERE STRFTIME('%Y', publication_date) = '1995'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM books WHERE published_year = 1994;"
        ],
        "rule_sql": []
    },
    "1538": {
        "db_id": "synthea",
        "question": "Calculate the average age of the male patients that have hypertension.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.deathdate IS NULL THEN ROUND((strftime('%J', date('now')) - strftime('%J', T2.birthdate)) / 365) ELSE ROUND((strftime('%J', T2.deathdate) - strftime('%J', T2.birthdate)) / 365) END) / COUNT(T2.patient) FROM conditions AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T1.DESCRIPTION = 'Hypertension' AND T2.gender = 'M'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(age) FROM patients WHERE gender = 'female' AND condition = 'hypertension';"
        ],
        "rule_sql": []
    },
    "5524": {
        "db_id": "menu",
        "question": "List the top five dishes, by descending order, in terms of highest price.",
        "ground_truth": "SELECT name FROM Dish ORDER BY highest_price DESC LIMIT 5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT dish_name, price FROM dishes ORDER BY price ASC LIMIT 5;"
        ],
        "rule_sql": []
    },
    "959": {
        "db_id": "cs_semester",
        "question": "What is the first and last name of students with highest gpa?",
        "ground_truth": "SELECT f_name, l_name FROM student WHERE gpa = ( SELECT MAX(gpa) FROM student )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, last_name FROM students ORDER BY gpa DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7540": {
        "db_id": "image_and_language",
        "question": "Define the bounding box of the object sample no. 7 on image no. 42.",
        "ground_truth": "SELECT X, Y, W, H FROM IMG_OBJ WHERE IMG_ID = 42 AND OBJ_SAMPLE_ID = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM bounding_boxes WHERE object_id = 7 AND image_id = 42;"
        ],
        "rule_sql": []
    },
    "9092": {
        "db_id": "bike_share_1",
        "question": "How many subscribers are in the zip code of 94301 and what is the hottest temperature recorded on that zip code?",
        "ground_truth": "SELECT COUNT(T3.zip_code), T3.max_temperature_f FROM trip AS T2 INNER JOIN weather AS T3 ON T3.zip_code = T2.zip_code WHERE T3.zip_code = 94301 AND T2.subscription_type = 'Subscriber' ORDER BY T3.max_temperature_f DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS subscriber_count, MAX(temperature) AS hottest_temperature\nFROM subscribers s\nJOIN weather w ON s.zip_code = w.zip_code\nWHERE s.zip_code = '94301';"
        ],
        "rule_sql": []
    },
    "2857": {
        "db_id": "professional_basketball",
        "question": "Please list the top three shortest black players.",
        "ground_truth": "SELECT firstName, lastName FROM players WHERE race = 'B' AND height > 0 ORDER BY height ASC LIMIT 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM players WHERE color = 'black' ORDER BY height DESC LIMIT 3;"
        ],
        "rule_sql": []
    },
    "996": {
        "db_id": "computer_student",
        "question": "What is the level of the course with the most number of teachers?",
        "ground_truth": "SELECT T1.courseLevel FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id GROUP BY T2.course_id ORDER BY COUNT(T2.p_id) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT level FROM courses ORDER BY teacher_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7346": {
        "db_id": "works_cycles",
        "question": "What are the sales tax records charged by multiple types of tax?",
        "ground_truth": "SELECT SalesTaxRateID FROM SalesTaxRate WHERE Name LIKE '%+%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM sales_tax_records WHERE tax_type = 'single_tax';"
        ],
        "rule_sql": []
    },
    "1994": {
        "db_id": "soccer_2016",
        "question": "What is the average winning margin of the matches held in Newlands?",
        "ground_truth": "SELECT AVG(T1.win_margin) FROM Match AS T1 INNER JOIN Venue AS T2 ON T1.venue_id = T2.venue_id WHERE T2.venue_name = 'Newlands'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(home_score - away_score) FROM matches WHERE venue = 'Newlands' AND home_score > away_score"
        ],
        "rule_sql": []
    },
    "9359": {
        "db_id": "movie_3",
        "question": "What is the average rental rate of sci-fi film titles?",
        "ground_truth": "SELECT AVG(T1.rental_rate) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T3.category_id = T2.category_id WHERE T3.`name` = 'Sci-Fi'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(rental_rate) FROM films WHERE genre = 'sci-fi';"
        ],
        "rule_sql": []
    },
    "8602": {
        "db_id": "chicago_crime",
        "question": "What is the fax number for the district with the most number of crimes in January, 2018?",
        "ground_truth": "SELECT T1.fax FROM District AS T1 INNER JOIN Crime AS T2 ON T1.district_no = T2.district_no WHERE T2.date LIKE '%1/2018%' GROUP BY T2.district_no ORDER BY COUNT(case_number) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT fax_number FROM districts ORDER BY COUNT(crimes) DESC LIMIT 1 WHERE crime_date LIKE '2018-01%';"
        ],
        "rule_sql": []
    },
    "3579": {
        "db_id": "authors",
        "question": "In how many papers and in what years was the International Conference on Database Theory published?",
        "ground_truth": "SELECT COUNT(T1.Id) AS PAPER, COUNT(DISTINCT T1.Year) AS YEARS FROM Paper AS T1 INNER JOIN Conference AS T2 ON T1.ConferenceId = T2.Id WHERE year != 0 AND T2.FullName = 'International Conference on Database Theory'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) as paper_count, year FROM papers WHERE conference = 'International Conference on Database Theory' GROUP BY year ORDER BY year;"
        ],
        "rule_sql": []
    },
    "80": {
        "db_id": "movie_platform",
        "question": "Please list the movies rated by the user who created the movie list \"250 Favourite Films\".",
        "ground_truth": "SELECT T2.movie_title FROM ratings AS T1 INNER JOIN movies AS T2 ON T1.movie_id = T2.movie_id INNER JOIN lists AS T3 ON T3.user_id = T1.user_id WHERE T3.list_title = '250 Favourite Films'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT m.title \nFROM movies m\nJOIN ratings r ON m.movie_id = r.movie_id\nJOIN users u ON r.user_id = u.user_id\nJOIN movie_lists ml ON u.user_id = ml.user_id\nWHERE ml.list_name = '250 Favourite Films';"
        ],
        "rule_sql": []
    },
    "1791": {
        "db_id": "soccer_2016",
        "question": "How many players are from Australia?",
        "ground_truth": "SELECT COUNT(CASE WHEN T2.Country_Name = 'Australia' THEN T1.Player_Id ELSE NULL END) FROM Player AS T1 INNER JOIN Country AS T2 ON T1.Country_Name = T2.Country_Id",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE country = 'Australia';"
        ],
        "rule_sql": []
    },
    "5563": {
        "db_id": "menu",
        "question": "Among the menus that did not support taking out or booking in advance, how many of them were created before 1950?",
        "ground_truth": "SELECT COUNT(*) FROM Menu WHERE call_number IS NULL AND strftime('%Y', date) < '1950'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM menus \nWHERE take_out_supported = 1 \nAND booking_in_advance = 1 \nAND creation_year < 1950;"
        ],
        "rule_sql": []
    },
    "1475": {
        "db_id": "synthea",
        "question": "How many types of medication have been prescribed to Mr. Major D'Amore since his visit to the hospital?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.DESCRIPTION) FROM patients AS T1 INNER JOIN medications AS T2 ON T1.patient = T2.PATIENT WHERE T1.first = 'Major' AND T1.last = 'D''Amore'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM medications WHERE patient_name = \"Mr. Major D'Amore\";"
        ],
        "rule_sql": []
    },
    "6819": {
        "db_id": "retails",
        "question": "Which customer is the most in debt?",
        "ground_truth": "SELECT c_name FROM customer WHERE c_acctbal = ( SELECT MIN(c_acctbal) FROM customer )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT customer_name, MAX(debt) FROM customers ORDER BY debt DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "1855": {
        "db_id": "soccer_2016",
        "question": "How many overs were there in the first innings of match ID \"335996\"?",
        "ground_truth": "SELECT COUNT(Over_Id) FROM Ball_by_Ball WHERE Match_Id = 335996 AND Innings_No = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM overs WHERE match_id = '335996' AND innings = 1;"
        ],
        "rule_sql": []
    },
    "4527": {
        "db_id": "student_loan",
        "question": "List out the number of students who filed for bankruptcy and enlisted in navy.",
        "ground_truth": "SELECT COUNT(T1.name) FROM enlist AS T1 INNER JOIN filed_for_bankrupcy AS T2 ON T1.name = T2.name WHERE T1.organ = 'navy'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE bankruptcy = 'yes' AND navy = 'yes';"
        ],
        "rule_sql": []
    },
    "8677": {
        "db_id": "chicago_crime",
        "question": "Find the commander's name, email address, and phone number of the Ogden district.",
        "ground_truth": "SELECT commander, email, phone FROM District WHERE district_name = 'Ogden'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT name, email, phone_number FROM commanders WHERE district = 'Ogden';"
        ],
        "rule_sql": []
    },
    "6793": {
        "db_id": "retails",
        "question": "How many different clerks have served the customer with the address uFTe2u518et8Q8UC?",
        "ground_truth": "SELECT COUNT(T1.o_clerk) FROM orders AS T1 INNER JOIN customer AS T2 ON T1.o_custkey = T2.c_custkey WHERE T2.c_address = 'uFTe2u518et8Q8UC'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM clerks WHERE customer_address = 'uFTe2u518et8Q8UC';"
        ],
        "rule_sql": []
    },
    "9188": {
        "db_id": "movie_3",
        "question": "Among the films with a rental duration of 7 days, how many are comedies?",
        "ground_truth": "SELECT COUNT(T1.film_id) FROM film AS T1 INNER JOIN film_category AS T2 ON T1.film_id = T2.film_id INNER JOIN category AS T3 ON T2.category_id = T3.category_id WHERE T1.rental_duration = 7 AND T3.name = 'Comedy'",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM film f \nJOIN film_category fc ON f.film_id = fc.film_id \nJOIN category c ON fc.category_id = c.category_id \nWHERE f.rental_duration = 7 AND c.name = 'Comedy';"
        ],
        "rule_sql": []
    },
    "7255": {
        "db_id": "works_cycles",
        "question": "What is the age of the oldest Marketing Specialist by 12/31/2015 and what is his/her hourly rate?",
        "ground_truth": "SELECT 2015 - STRFTIME('%Y', T1.BirthDate), T2.Rate FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE T1.JobTitle = 'Marketing Specialist' ORDER BY 2015 - STRFTIME('%Y', T1.BirthDate) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(age) as oldest_age, hourly_rate \nFROM employees \nWHERE department = 'Marketing Specialist' \nAND hire_date <= '2015-12-31' \nGROUP BY hourly_rate \nORDER BY oldest_age DESC \nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "1376": {
        "db_id": "synthea",
        "question": "What is the prevalence percentage of condition no. 64859006?",
        "ground_truth": "SELECT DISTINCT T1.\"PREVALENCE PERCENTAGE\" FROM all_prevalences AS T1 INNER JOIN conditions AS T2 ON lower(T1.ITEM) = lower(T2.DESCRIPTION) WHERE T2.code = '64859006'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT prevalence FROM conditions WHERE condition_id = 64859006;"
        ],
        "rule_sql": []
    },
    "2424": {
        "db_id": "superstore",
        "question": "How many orders of O'Sullivan Plantations 2-Door Library in Landvery Oak in central superstore were shipped through the shipping mode with the fastest delivery speed?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.`Order ID`) FROM central_superstore AS T1 INNER JOIN product AS T2 ON T1.`Product ID` = T2.`Product ID` WHERE T2.`Product Name` = 'O''Sullivan Plantations 2-Door Library in Landvery Oak' AND T2.Region = 'Central' AND T1.`Ship Mode` = 'First Class'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM orders o\nJOIN products p ON o.product_id = p.product_id\nJOIN shipping_modes s ON o.ship_mode_id = s.ship_mode_id\nWHERE p.product_name = 'O''Sullivan Plantations 2-Door Library'\nAND p.material = 'Landvery Oak'\nAND o.store_type = 'central superstore'\nORDER BY s.delivery_speed DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "3373": {
        "db_id": "video_games",
        "question": "Provide the game publisher's name of the game with sales greater than 90% of the average sales in Japan.",
        "ground_truth": "SELECT DISTINCT T5.publisher_name FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id INNER JOIN game_platform AS T3 ON T2.game_platform_id = T3.id INNER JOIN game_publisher AS T4 ON T3.game_publisher_id = T4.id INNER JOIN publisher AS T5 ON T4.publisher_id = T5.id WHERE T2.num_sales * 10000000 > ( SELECT AVG(T2.num_sales) * 100000 * 90 FROM region AS T1 INNER JOIN region_sales AS T2 ON T1.id = T2.region_id WHERE T1.region_name = 'Japan' )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT publisher FROM games WHERE japan_sales > (SELECT AVG(japan_sales) * 0.9 FROM games);"
        ],
        "rule_sql": []
    },
    "246": {
        "db_id": "retail_complains",
        "question": "Was the tag in the complaint filed by Matthew Pierce on 2016/10/28 approved by himself?",
        "ground_truth": "SELECT CASE WHEN T2.`Consumer consent provided?` IN (NULL, 'N/A', 'Empty') THEN 'No' ELSE 'Yes' END FROM client AS T1 INNER JOIN events AS T2 ON T1.client_id = T2.Client_ID WHERE T1.first = 'Matthew' AND T1.last = 'Pierce' AND T2.`Date received` = '2016-10-28'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT approved_by FROM complaints WHERE filed_by = 'Matthew Pierce' AND date = '2016/10/28' AND approved_by = filed_by;"
        ],
        "rule_sql": []
    },
    "3278": {
        "db_id": "donor",
        "question": "What is the average unit price of AKJ Books items?",
        "ground_truth": "SELECT SUM(item_unit_price) / SUM(item_quantity) FROM resources WHERE vendor_name = 'AKJ Books'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(price) FROM items WHERE publisher = 'AKJ Books';"
        ],
        "rule_sql": []
    },
    "529": {
        "db_id": "movies_4",
        "question": "Provide the average revenue of all the French movies.",
        "ground_truth": "SELECT AVG(T1.revenue) FROM movie AS T1 INNER JOIN production_COUNTry AS T2 ON T1.movie_id = T2.movie_id INNER JOIN COUNTry AS T3 ON T2.COUNTry_id = T3.COUNTry_id WHERE T3.COUNTry_name = 'France'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(budget) FROM movies WHERE country = 'France';"
        ],
        "rule_sql": []
    },
    "3925": {
        "db_id": "public_review_platform",
        "question": "What is the category of the business with short review length and highest review stars within business ID from 5 t0 10?",
        "ground_truth": "SELECT T4.category_name FROM Reviews AS T1 INNER JOIN Business AS T2 ON T1.business_id = T2.business_id INNER JOIN Business_Categories AS T3 ON T2.business_id = T3.business_id INNER JOIN Categories AS T4 ON T3.category_id = T4.category_id WHERE T1.review_length LIKE 'Short' AND T2.business_id BETWEEN 5 AND 10 ORDER BY T1.review_stars DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT category FROM businesses WHERE business_id BETWEEN 5 AND 10 ORDER BY review_length ASC, review_stars DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "3524": {
        "db_id": "authors",
        "question": "How many journals have a word \"computing\" in its full name?",
        "ground_truth": "SELECT COUNT(Id) FROM Journal WHERE FullName LIKE '%computing%'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM journals WHERE full_name LIKE '%computing%';"
        ],
        "rule_sql": []
    },
    "1085": {
        "db_id": "talkingdata",
        "question": "How many app users belong to the category of Securities?",
        "ground_truth": "SELECT COUNT(T1.app_id) FROM app_labels AS T1 INNER JOIN label_categories AS T2 ON T2.label_id = T1.label_id WHERE T2.category = 'Securities'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE category = 'Securities';"
        ],
        "rule_sql": []
    },
    "7707": {
        "db_id": "hockey",
        "question": "For the team which had three different goalies in the 2011 postseason games, how many games did they win in the regular season?",
        "ground_truth": "SELECT SUM(T2.W) FROM Goalies AS T1 INNER JOIN Teams AS T2 ON T1.tmID = T2.tmID WHERE T2.year = 2011 GROUP BY T1.tmID HAVING COUNT(DISTINCT T1.playerID) = 3",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT wins \nFROM teams \nWHERE team_id IN (\n    SELECT team_id \n    FROM goalies \n    WHERE year = 2011 \n    AND postseason = 1 \n    GROUP BY team_id \n    HAVING COUNT(DISTINCT goalie_id) = 3\n);"
        ],
        "rule_sql": []
    },
    "4436": {
        "db_id": "student_loan",
        "question": "How many unemployed disabled students have been absent for 8 months from school?",
        "ground_truth": "SELECT COUNT(T1.name) FROM longest_absense_from_school AS T1 INNER JOIN unemployed AS T2 ON T1.name = T2.name INNER JOIN disabled AS T3 ON T2.name = T3.name WHERE T1.month = 8",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE employment_status = 'unemployed' AND disability_status = 'disabled' AND absence_duration = 8;"
        ],
        "rule_sql": []
    },
    "464": {
        "db_id": "movies_4",
        "question": "How many films released between 1/2/1990 and 12/30/2000 starred Uma Thurman?",
        "ground_truth": "SELECT COUNT(T1.movie_id) FROM movie AS T1 INNER JOIN movie_cast AS T2 ON T1.movie_id = T2.movie_id INNER JOIN person AS T3 ON T2.person_id = T3.person_id WHERE T3.person_name = 'Uma Thurman' AND T1.release_date BETWEEN '1990-01-01' AND '2000-12-31'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM films f\nJOIN film_actors fa ON f.film_id = fa.film_id\nJOIN actors a ON fa.actor_id = a.actor_id\nWHERE a.first_name = 'Uma' AND a.last_name = 'Thurman'\nAND f.release_date BETWEEN '1990-02-01' AND '2000-12-30';"
        ],
        "rule_sql": []
    },
    "9300": {
        "db_id": "movie_3",
        "question": "Please list any two films that Penelope Guiness acted in.",
        "ground_truth": "SELECT T3.title FROM actor AS T1 INNER JOIN film_actor AS T2 ON T1.actor_id = T2.actor_id INNER JOIN film AS T3 ON T2.film_id = T3.film_id WHERE T1.first_name = 'Penelope' AND T1.last_name = 'Guiness' LIMIT 2",
        "amends": [],
        "rules": [],
        "amend_res": 1,
        "rule_res": 0,
        "amend_sql": [
            "SELECT f.title FROM film f JOIN film_actor fa ON f.film_id = fa.film_id JOIN actor a ON fa.actor_id = a.actor_id WHERE a.first_name = 'Penelope' AND a.last_name = 'Guiness' LIMIT 2;"
        ],
        "rule_sql": []
    },
    "9004": {
        "db_id": "bike_share_1",
        "question": "How many bike stations were installed in San Jose in 2014? Indicate the names of the stations.",
        "ground_truth": "SELECT SUM(CASE WHEN city = 'San Jose' AND SUBSTR(installation_date, -4) = '2014' THEN 1 ELSE 0 END) FROM station UNION SELECT name FROM station WHERE city = 'San Jose' AND SUBSTR(installation_date, -4) = '2014'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) AS station_count, station_name FROM bike_stations WHERE city = 'San Jose' AND installation_year = 2014 GROUP BY station_name;"
        ],
        "rule_sql": []
    },
    "8020": {
        "db_id": "university",
        "question": "Compute the average score of the university located in Brazil.",
        "ground_truth": "SELECT AVG(T2.score) FROM university AS T1 INNER JOIN university_ranking_year AS T2 ON T1.id = T2.university_id INNER JOIN country AS T3 ON T3.id = T1.country_id WHERE T3.country_name = 'Brazil'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(score) FROM universities WHERE country = 'Brazil';"
        ],
        "rule_sql": []
    },
    "1502": {
        "db_id": "synthea",
        "question": "State description of medication taken by Joe Homenick.",
        "ground_truth": "SELECT T1.DESCRIPTION FROM medications AS T1 INNER JOIN patients AS T2 ON T1.PATIENT = T2.patient WHERE T2.first = 'Joye' AND T2.last = 'Homenick'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT description FROM medications WHERE patient_name = 'Joe Homenick';"
        ],
        "rule_sql": []
    },
    "1777": {
        "db_id": "restaurant",
        "question": "How many Indian restaurants are there in the Los Angeles area?",
        "ground_truth": "SELECT COUNT(T1.city) FROM geographic AS T1 INNER JOIN generalinfo AS T2 ON T1.city = T2.city WHERE T2.food_type = 'indian' AND T1.region = 'los angeles area'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE cuisine = 'Indian' AND city = 'Los Angeles';"
        ],
        "rule_sql": []
    },
    "948": {
        "db_id": "cs_semester",
        "question": "What is the average capability of students with less than a 2.5 GPA?",
        "ground_truth": "SELECT CAST(SUM(T1.capability) AS REAL) / COUNT(T1.student_id) FROM RA AS T1 INNER JOIN student AS T2 ON T1.student_id = T2.student_id WHERE T2.gpa < 2.5",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(capability) FROM students WHERE GPA >= 2.5;"
        ],
        "rule_sql": []
    },
    "1204": {
        "db_id": "talkingdata",
        "question": "How many apps are labeled 7?",
        "ground_truth": "SELECT COUNT(app_id) FROM app_labels WHERE label_id = 7",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM apps WHERE label = '7';"
        ],
        "rule_sql": []
    },
    "785": {
        "db_id": "social_media",
        "question": "Please list the texts of all the tweets posted from Buenos Aires with a positive sentiment.",
        "ground_truth": "SELECT T1.text FROM twitter AS T1 INNER JOIN location AS T2 ON T2.LocationID = T1.LocationID WHERE T1.Sentiment > 0 AND T2.City = 'Buenos Aires'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT text FROM tweets WHERE location = 'Buenos Aires' AND sentiment > 0;"
        ],
        "rule_sql": []
    },
    "7704": {
        "db_id": "hockey",
        "question": "Who made the most assists in a single game in the Stanley Cup finals ?",
        "ground_truth": "SELECT playerID FROM ScoringSC ORDER BY A DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_name, MAX(goals) as most_assists FROM nhl_playoff_stats WHERE series_type = 'Stanley Cup Finals' GROUP BY player_name ORDER BY most_assists DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "7782": {
        "db_id": "hockey",
        "question": "What is the average winning rate of the Montreal Canadiens in the Stanley Cup finals?",
        "ground_truth": "SELECT SUM(T2.W / T2.G) / SUM(T2.G + T2.W) FROM Teams AS T1 INNER JOIN TeamsSC AS T2 ON T1.tmID = T2.tmID AND T1.year = T2.year WHERE T1.name = 'Montreal Canadiens'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(win_rate) FROM team_stats WHERE team_name = 'Montreal Canadiens' AND competition = 'Stanley Cup finals';"
        ],
        "rule_sql": []
    },
    "7081": {
        "db_id": "works_cycles",
        "question": "Average cost of purchase orders made during the first six months of 2012.",
        "ground_truth": "SELECT CAST(SUM(ActualCost) AS REAL) / COUNT(TransactionID) FROM TransactionHistoryArchive WHERE TransactionType = 'P' AND TransactionDate >= '2012-01-01' AND TransactionDate < '2012-07-01'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(total_amount) FROM purchase_orders WHERE order_date BETWEEN '2012-01-01' AND '2012-06-31';"
        ],
        "rule_sql": []
    },
    "4233": {
        "db_id": "simpson_episodes",
        "question": "Name the title of the episode that was nominated for Emmy's Outstanding Animated Program 21 times.",
        "ground_truth": "SELECT T2.title FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T1.organization = 'Primetime Emmy Awards' AND T1.award = 'Outstanding Animated Program (For Programming Less Than One Hour)' AND T1.result = 'Nominee' GROUP BY T1.episode_id HAVING COUNT(T1.episode_id) = 21;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title FROM episodes WHERE emmy_nominations = 21;"
        ],
        "rule_sql": []
    },
    "1746": {
        "db_id": "restaurant",
        "question": "Give the review of the restaurant at 430, Broadway.",
        "ground_truth": "SELECT T1.review FROM generalinfo AS T1 INNER JOIN location AS T2 ON T1.id_restaurant = T2.id_restaurant WHERE T2.street_name = 'Broadway' AND T2.street_num = 430",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM reviews WHERE restaurant_address = '430, Broadway';"
        ],
        "rule_sql": []
    },
    "3714": {
        "db_id": "college_completion",
        "question": "Which city is \"Rensselaer Polytechnic Institute\" located in?",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE WHEN chronname = 'Rensselaer Polytechnic Institute' THEN city ELSE NULL END AS T FROM institution_details ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT city FROM universities WHERE name = 'Rensselaer Polytechnic Institute';"
        ],
        "rule_sql": []
    },
    "5452": {
        "db_id": "sales",
        "question": "How many \"Mountain-100 Silver, 38\" were sold by Stearns MacFeather?",
        "ground_truth": "SELECT SUM(T2.Quantity) FROM Employees AS T1 INNER JOIN Sales AS T2 ON T1.EmployeeID = T2.SalesPersonID INNER JOIN Products AS T3 ON T2.ProductID = T3.ProductID WHERE T1.FirstName = 'Stearns' AND T1.LastName = 'MacFeather' AND T3.Name = 'Mountain-100 Silver, 38'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM sales WHERE product_name = 'Mountain-100 Silver, 38' AND salesperson = 'Stearns MacFeather';"
        ],
        "rule_sql": []
    },
    "5990": {
        "db_id": "books",
        "question": "Which year has the most customer orders?",
        "ground_truth": "SELECT strftime('%Y', order_date) FROM cust_order GROUP BY strftime('%Y', order_date) ORDER BY COUNT(strftime('%Y', order_date)) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT YEAR(order_date) AS order_year, COUNT(*) AS order_count FROM orders GROUP BY YEAR(order_date) ORDER BY order_count DESC LIMIT 1;"
        ],
        "rule_sql": []
    },
    "750": {
        "db_id": "movie",
        "question": "When is the birthday of the actor who played \"Sully\"?",
        "ground_truth": "SELECT T2.`Date of Birth` FROM characters AS T1 INNER JOIN actor AS T2 ON T1.ActorID = T2.ActorID WHERE T1.`Character Name` = 'Sully'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT birthday FROM actors WHERE character_name = 'Sully';"
        ],
        "rule_sql": []
    },
    "4036": {
        "db_id": "public_review_platform",
        "question": "How many 5 star businesses have uber review votes for funny?",
        "ground_truth": "SELECT COUNT(business_id) FROM Reviews WHERE review_stars = 5 AND review_votes_funny = 'Uber'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE stars = 5 AND funny_votes > 0;"
        ],
        "rule_sql": []
    },
    "5456": {
        "db_id": "sales",
        "question": "How many employees sold \"ML Road Frame-W - Yellow, 40\"?",
        "ground_truth": "SELECT COUNT(T2.SalesPersonID) FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T1.Name = 'ML Road Frame-W - Yellow, 40'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM employees WHERE product_sold = 'ML Road Frame-W - Yellow, 40';"
        ],
        "rule_sql": []
    },
    "5148": {
        "db_id": "address",
        "question": "Calculate the difference between the 2020 population and the 2010 population for the districts represented by Griffin Tim.",
        "ground_truth": "SELECT T1.population_2020 - T1.population_2010 FROM zip_data AS T1 INNER JOIN zip_congress AS T2 ON T1.zip_code = T2.zip_code INNER JOIN congress AS T3 ON T2.district = T3.cognress_rep_id WHERE T3.first_name = 'Griffin' AND T3.last_name = 'Tim'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT (d2020.population - d2010.population) AS population_difference\nFROM districts d2020\nJOIN districts d2010 ON d2020.district_id = d2010.district_id\nJOIN representatives r ON d2020.district_id = r.district_id\nWHERE r.name = 'Griffin Tim'\nAND d2020.year = 2020\nAND d2010.year = 2010;"
        ],
        "rule_sql": []
    },
    "2186": {
        "db_id": "world_development_indicators",
        "question": "What country have the series code of SP.DYN.CBRT.IN?",
        "ground_truth": "SELECT T1.ShortName FROM Country AS T1 INNER JOIN CountryNotes AS T2 ON T1.CountryCode = T2.Countrycode WHERE T2.SeriesCode = 'SP.DYN.CBRT.IN'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT country FROM series WHERE series_code = 'SP.DYN.CBRT.IN';"
        ],
        "rule_sql": []
    },
    "8773": {
        "db_id": "food_inspection",
        "question": "How many restaurants' owners are in California?",
        "ground_truth": "SELECT COUNT(owner_state) FROM businesses WHERE owner_state = 'CA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM restaurants WHERE state = 'California';"
        ],
        "rule_sql": []
    },
    "5823": {
        "db_id": "airline",
        "question": "Please list the dates of the flights that were cancelled due to the most serious reason.",
        "ground_truth": "SELECT FL_DATE FROM Airlines WHERE CANCELLATION_CODE = 'A' GROUP BY FL_DATE",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM flights WHERE reason = 'most serious' AND status = 'cancelled';"
        ],
        "rule_sql": []
    },
    "4367": {
        "db_id": "simpson_episodes",
        "question": "In year 2009, what is the percentage of the episode titled by \"Gone Maggie Gone\" being nominated?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T1.result = 'Nominee' THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.result = 'Winner' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.result) FROM Award AS T1 INNER JOIN Episode AS T2 ON T1.episode_id = T2.episode_id WHERE T2.title = 'Gone Maggie Gone' AND T1.year = 2009;",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN title = 'Gone Maggie Gone' AND year = 2009 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_nominated\nFROM episodes\nWHERE year = 2009;"
        ],
        "rule_sql": []
    },
    "8583": {
        "db_id": "software_company",
        "question": "Describe the average income per month and yearly income of the geographic ID in which customer of ID \"209556\" and \"290135\".",
        "ground_truth": "SELECT T2.INCOME_K, T2.INHABITANTS_K * T2.INCOME_K * 12 FROM Customers AS T1 INNER JOIN Demog AS T2 ON T1.GEOID = T2.GEOID WHERE T1.ID = 209556 OR T1.ID = 290135",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(monthly_income) AS avg_monthly_income, AVG(yearly_income) AS avg_yearly_income \nFROM customers \nWHERE customer_id IN ('209556', '290135') \nGROUP BY geographic_id;"
        ],
        "rule_sql": []
    },
    "3926": {
        "db_id": "public_review_platform",
        "question": "Count the active businesses that has an attribute of Wi-Fi with medium review count.",
        "ground_truth": "SELECT COUNT(T1.business_id) FROM Business AS T1 INNER JOIN Business_Attributes AS T2 ON T1.business_id = T2.business_id INNER JOIN Attributes AS T3 ON T2.attribute_id = T3.attribute_id WHERE T3.attribute_name LIKE 'Wi-Fi' AND T1.active LIKE 'TRUE' AND T1.review_count LIKE 'Medium'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE attribute = 'Wi-Fi' AND review_count = 'medium';"
        ],
        "rule_sql": []
    },
    "4116": {
        "db_id": "public_review_platform",
        "question": "How many businesses in the city of Scottsdale open on Sunday at 12PM?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.business_id) FROM Business AS T1 INNER JOIN Business_hours AS T2 ON T1.business_id = T2.business_id INNER JOIN Days AS T3 ON T2.day_id = T3.day_id WHERE T1.city = 'Scottsdale' AND T3.day_of_week = 'Sunday' AND T2.opening_time = '12PM'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM businesses WHERE city = 'Scottsdale' AND open_time = '12PM' AND day_of_week = 'Sunday';"
        ],
        "rule_sql": []
    },
    "2847": {
        "db_id": "professional_basketball",
        "question": "What is the maximum weight of USA all-star players?",
        "ground_truth": "SELECT MAX(T1.weight) FROM players AS T1 INNER JOIN player_allstar AS T2 ON T1.playerID = T2.playerID WHERE T1.birthCountry = 'USA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(weight) FROM players WHERE country = 'USA' AND all_star = 1;"
        ],
        "rule_sql": []
    },
    "9248": {
        "db_id": "movie_3",
        "question": "How many customers rented for an above-average period?",
        "ground_truth": "SELECT COUNT(customer_id) FROM rental WHERE return_date - rental_date > ( SELECT AVG(return_date - rental_date) FROM rental )",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM rentals \nWHERE rental_duration > (SELECT AVG(rental_duration) FROM rentals);"
        ],
        "rule_sql": []
    },
    "3682": {
        "db_id": "college_completion",
        "question": "List the all the institutes from the state with the most number of American Indian in 2007.",
        "ground_truth": "SELECT T1.chronname FROM institution_details AS T1 INNER JOIN state_sector_grads AS T2 ON T1.state = T2.state WHERE T2.year = 2007 AND T2.race = 'Ai' GROUP BY T1.chronname ORDER BY COUNT(T1.chronname) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT institute FROM census_data WHERE state = (SELECT state FROM census_data WHERE year = 2007 AND race = 'American Indian' GROUP BY state ORDER BY COUNT(*) DESC LIMIT 1);"
        ],
        "rule_sql": []
    },
    "5274": {
        "db_id": "beer_factory",
        "question": "Which brewery does the most purchased root beer in 2016 belong to?",
        "ground_truth": "SELECT T2.BreweryName FROM rootbeer AS T1 INNER JOIN rootbeerbrand AS T2 ON T1.BrandID = T2.BrandID WHERE T1.PurchaseDate BETWEEN '2016-01-01' AND '2016-12-31' GROUP BY T2.BrandID ORDER BY COUNT(T1.BrandID) DESC LIMIT 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT b.name \nFROM breweries b\nJOIN beers be ON b.id = be.brewery_id\nJOIN purchases p ON be.id = p.beer_id\nWHERE be.style = 'Root Beer' \nAND strftime('%Y', p.purchase_date) = '2016'\nGROUP BY b.id\nORDER BY COUNT(p.id) DESC\nLIMIT 1;"
        ],
        "rule_sql": []
    },
    "5265": {
        "db_id": "beer_factory",
        "question": "What is the average number of reviews of all the root beer brands from \"CA\" State?",
        "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / COUNT(DISTINCT T1.BrandID) AS avgreview FROM rootbeerbrand AS T1 INNER JOIN rootbeerreview AS T2 ON T1.BrandID = T2.BrandID WHERE T1.State = 'CA'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(review_count) FROM root_beer_brands WHERE state = 'CA';"
        ],
        "rule_sql": []
    },
    "8681": {
        "db_id": "chicago_crime",
        "question": "On average, how many community areas are there in a side?",
        "ground_truth": "SELECT CAST(COUNT(T1.ward_no) AS REAL) / COUNT(DISTINCT T3.side) FROM Ward AS T1 INNER JOIN Crime AS T2 ON T2.ward_no = T1.ward_no INNER JOIN Community_Area AS T3 ON T3.community_area_no = T2.community_area_no",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(COUNT(community_area)) FROM chicago_crime_data GROUP BY side;"
        ],
        "rule_sql": []
    },
    "7213": {
        "db_id": "works_cycles",
        "question": "List all the pay rates of all employees that were hired at 20 years of age.",
        "ground_truth": "SELECT T2.Rate FROM Employee AS T1 INNER JOIN EmployeePayHistory AS T2 ON T1.BusinessEntityID = T2.BusinessEntityID WHERE STRFTIME('%Y', T1.HireDate) - STRFTIME('%Y', T1.BirthDate) = 20",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT pay_rate FROM employees WHERE age_at_hire = 20;"
        ],
        "rule_sql": []
    },
    "8919": {
        "db_id": "cookbook",
        "question": "How many ingredients are required to make the Raspberry Chiffon Pie?",
        "ground_truth": "SELECT COUNT(*) FROM Recipe AS T1 INNER JOIN Quantity AS T2 ON T1.recipe_id = T2.recipe_id INNER JOIN Ingredient AS T3 ON T3.ingredient_id = T2.ingredient_id WHERE T1.title = 'Raspberry Chiffon Pie'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM ingredients WHERE recipe_name = 'Raspberry Chiffon Pie';"
        ],
        "rule_sql": []
    },
    "8964": {
        "db_id": "human_resources",
        "question": "How many positions have a maximum salary of no more than US$1000,000?",
        "ground_truth": "SELECT COUNT(*) FROM position WHERE CAST(REPLACE(SUBSTR(maxsalary, 4), ',', '') AS REAL) < 100000",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM positions WHERE max_salary <= 1000000;"
        ],
        "rule_sql": []
    },
    "3704": {
        "db_id": "college_completion",
        "question": "Please list the names of the institutes with the percentage of male White students graduating in 2011 within 150 percent of normal/expected time over 20.",
        "ground_truth": "SELECT T FROM ( SELECT DISTINCT CASE WHEN T2.grad_150 > 20 THEN T1.chronname ELSE NULL END AS T FROM institution_details T1 INNER JOIN institution_grads T2 ON T2.unitid = T1.unitid WHERE T2.year = 2011 AND T2.gender = 'M' AND T2.race = 'W' ) WHERE T IS NOT NULL",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT institute_name \nFROM graduation_data \nWHERE year = 2011 \nAND race = 'White' \nAND gender = 'Male' \nAND graduation_rate > 20 \nAND time_to_graduation <= 1.5"
        ],
        "rule_sql": []
    },
    "61": {
        "db_id": "movie_platform",
        "question": "How many movie lists with over 100 movies had user 85981819 created when he or she was a paying subscriber?",
        "ground_truth": "SELECT COUNT(*) FROM lists AS T1 INNER JOIN lists_users AS T2 ON T1.list_id = T2.list_id AND T1.user_id = T2.user_id WHERE T1.user_id = 85981819 AND T1.list_movie_number > 100 AND T2.user_has_payment_method = 1",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM movie_lists ml\nJOIN users u ON ml.user_id = u.user_id\nWHERE ml.user_id = 85981819 \nAND ml.movie_count > 100\nAND u.subscription_status = 'paying';"
        ],
        "rule_sql": []
    },
    "6255": {
        "db_id": "coinmarketcap",
        "question": "What is the average monthly circulating supply for Frozen in 2014.",
        "ground_truth": "SELECT CAST(SUM(T2.circulating_supply) AS REAL) / 12 FROM coins AS T1 INNER JOIN historical AS T2 ON T1.id = T2.coin_id WHERE T1.name = 'Frozen' AND STRFTIME('%Y', T2.date) = '2014'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(circulating_supply) FROM frozen WHERE year = 2014 GROUP BY month;"
        ],
        "rule_sql": []
    },
    "3596": {
        "db_id": "authors",
        "question": "Please provide the titles of any two papers that are either preprinted or unpublished along with the full name of the journal to which those papers belong.",
        "ground_truth": "SELECT T1.Title, T2.FullName FROM Paper AS T1 INNER JOIN Journal AS T2 ON T1.JournalId = T2.Id WHERE T1.Year < 1 LIMIT 2",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, journal_name FROM papers WHERE status = 'preprinted' OR status = 'unpublished' LIMIT 2;"
        ],
        "rule_sql": []
    },
    "5071": {
        "db_id": "olympics",
        "question": "In what year and season did Sohail Abbas compete?",
        "ground_truth": "SELECT T1.games_year, T1.season FROM games AS T1 INNER JOIN games_competitor AS T2 ON T1.id = T2.games_id INNER JOIN person AS T3 ON T2.person_id = T3.id WHERE T3.full_name = 'Sohail Abbas'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, season FROM competitions WHERE player_name = 'Sohail Abbas'"
        ],
        "rule_sql": []
    },
    "980": {
        "db_id": "computer_student",
        "question": "Provide the ID of professors who teach in both harder undergraduate course and master/graduate courses.",
        "ground_truth": "SELECT DISTINCT T2.p_id FROM course AS T1 INNER JOIN taughtBy AS T2 ON T1.course_id = T2.course_id WHERE T1.courseLevel = 'Level_400' OR T1.courseLevel = 'Level_500'",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT professor_id FROM courses WHERE level = 'undergraduate' AND difficulty = 'hard' INTERSECT SELECT professor_id FROM courses WHERE level IN ('master', 'graduate');"
        ],
        "rule_sql": []
    },
    "2337": {
        "db_id": "movielens",
        "question": "What is the total average movie directed by the directors who's quality and revenue is 4?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.d_quality = 4 AND T1.avg_revenue = 4 THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.movieid) FROM directors AS T1 INNER JOIN movies2directors AS T2 ON T1.directorid = T2.directorid",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(movie_count) FROM directors WHERE quality = 4 AND revenue = 4;"
        ],
        "rule_sql": []
    },
    "5393": {
        "db_id": "sales",
        "question": "Write down the name of products whose sale quantity is more than 950.",
        "ground_truth": "SELECT DISTINCT T1.Name FROM Products AS T1 INNER JOIN Sales AS T2 ON T1.ProductID = T2.ProductID WHERE T2.Quantity > 950",
        "amends": [],
        "rules": [],
        "amend_res": 0,
        "rule_res": 0,
        "amend_sql": [
            "SELECT product_name FROM products WHERE quantity < 950;"
        ],
        "rule_sql": []
    }
}