{
    "1358": {
        "db_id": "student_club",
        "question": "Who was the first one paid his/her dues? Tell the full name.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received LIMIT 1",
        "amends": [
            "Do add table `income AS T2` with an `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying only the `members` table. Do add a WHERE filter for `T2.source = 'Dues'` instead of omitting any filtering condition. Do change the ORDER BY clause to use `T2.date_received` instead of `dues_paid ASC`. Do qualify column references with table aliases `T1.first_name` and `T1.last_name` instead of unqualified `first_name` and `last_name`. The amended query now correctly retrieves member information based on dues payment records from the income table rather than relying on a potentially incorrect dues_paid column in the members table."
        ],
        "rules": [
            "1) When answering about \"first one paid his/her dues\": make sure the output order: T1.first_name, T1.last_name. 2) When the question mentions \"paid his/her dues\": \"dues\" actually means \"source = 'Dues' in T2 table\". 3) When the question asks for \"first one\": rank rows by T2.date_received in ascending order and keep the first 1 row. 4) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member; keep only matching pairs (inner match). 5) When producing output: qualify column references with table aliases T1.first_name and T1.last_name instead of unqualified column names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM members ORDER BY dues_paid ASC LIMIT 1;",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T2.source = 'Dues'\nORDER BY T2.date_received ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nWHERE T2.source = 'Dues'\nORDER BY T2.date_received ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "477": {
        "db_id": "card_games",
        "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
        "amends": [
            "Do join `cards` and `sets` tables with `INNER JOIN` on `sets.code = cards.setCode` instead of querying only the `artists` table. Do filter on `sets.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'`. Do use multiple OR conditions with `cards.artist` for each artist name instead of an IN clause with `artist_name`. Do group by `cards.artist` instead of selecting without aggregation. Do reference columns with table aliases `T1` and `T2` instead of bare column names. The amended query now correctly joins the relevant tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about artists who designed cards in a specific set: combine the cards and sets tables using an inner match where T2.code equals T1.setCode. 2) When the question mentions \"set Coldsnap\": filter for T2.name exactly equal to 'Coldsnap'. 3) When the question asks about specific artists Jeremy Jarvis, Aaron Miller, or Chippy: check if T1.artist equals 'Jeremy Jarvis' OR T1.artist equals 'Aaron Miller' OR T1.artist equals 'Chippy'. 4) When grouping results by artist: organize the output by T1.artist. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name FROM artists WHERE set_name = 'Coldsnap' AND artist_name IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');",
            "SELECT cards.artist\nFROM cards\nINNER JOIN sets ON sets.code = cards.setCode\nWHERE sets.name = 'Coldsnap'\nAND (cards.artist = 'Jeremy Jarvis' OR cards.artist = 'Aaron Miller' OR cards.artist = 'Chippy')\nGROUP BY cards.artist"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.artist\nFROM cards c\nINNER JOIN sets s ON c.setCode = s.code\nWHERE s.name = 'Coldsnap'\nAND (c.artist = 'Jeremy Jarvis' OR c.artist = 'Aaron Miller' OR c.artist = 'Chippy')\nORDER BY c.artist;"
        ],
        "amend_res": 1
    },
    "856": {
        "db_id": "formula_1",
        "question": "Please list the time of the races held on Sepang International Circuit.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.time FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "amends": [
            "Do select `T2.time` with `DISTINCT` instead of `race_time` without distinct. Do join `circuits AS T1` with `races AS T2` using `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do filter on `T1.name = 'Sepang International Circuit'` instead of `circuit_name = 'Sepang International Circuit' AND month = 'September'`. Do remove the `month` filter instead of keeping it. The amended query now correctly joins the circuits table to access circuit names and returns distinct race times without the unnecessary month filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about race times at Sepang International Circuit: make sure the output order: T2.time 2) When the question mentions \"time of the races\": \"time\" actually means \"T2.time in schema\" 3) When the question mentions \"Sepang International Circuit\": \"Sepang International Circuit\" actually means \"T1.name = 'Sepang International Circuit' in schema\" 4) When combining circuits table T1 and races table T2: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match) 5) When listing race times: return distinct values of T2.time to avoid duplicate times 6) When filtering by circuit name: do not include month filters as they are unnecessary for this question"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_time FROM races WHERE circuit_name = 'Sepang International Circuit' AND month = 'September';",
            "SELECT DISTINCT T2.time\nFROM circuits AS T1\nJOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Sepang International Circuit'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.time\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Sepang International Circuit';"
        ],
        "amend_res": 1
    },
    "67": {
        "db_id": "california_schools",
        "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
        "amends": [
            "Do use `COUNT(School)` instead of `SUM(amount)` for counting schools rather than summing amounts. Do query from `schools` table instead of `closures` table to access the correct data source. Do use `strftime('%Y', ClosedDate) = '1989'` instead of `year = 1989` to extract year from a date field rather than using a numeric year column. Do filter on `City = 'San Francisco'` instead of `city = 'San Francisco'` to match the correct column name capitalization. Do filter on `DOCType = 'Community College District'` instead of `type = 'Community College District'` to use the appropriate column name for district type classification. The amended query now correctly counts schools closed in 1989 in San Francisco with the specified district type, matching the intended behavior."
        ],
        "rules": [
            "1) When counting schools rather than summing amounts: use COUNT(School) instead of SUM(amount). 2) When accessing school closure data: query from the schools table instead of closures table. 3) When filtering by year 1989: use strftime('%Y', ClosedDate) = '1989' to extract year from the ClosedDate field rather than using a numeric year column. 4) When filtering by city San Francisco: use City = 'San Francisco' with exact capitalization to match the correct column name. 5) When filtering by district type Community College District: use DOCType = 'Community College District' to use the appropriate column name for district type classification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM closures WHERE year = 1989 AND city = 'San Francisco' AND type = 'Community College District';",
            "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'"
        ],
        "rule_sql": [
            "SELECT COUNT(School) \nFROM schools \nWHERE strftime('%Y', ClosedDate) = '1989' \nAND City = 'San Francisco' \nAND DOCType = 'Community College District'"
        ],
        "amend_res": 1
    },
    "194": {
        "db_id": "financial",
        "question": "Provide the IDs and age of the client with high level credit card, which is eligible for loans.",
        "ground_truth": "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'",
        "amends": [
            "Do select `T1.client_id` and calculate age using `STRFTIME` functions instead of selecting `client_id` and `age` directly. Do join `disp AS T1`, `card AS T2`, and `client AS T3` with `INNER JOIN` conditions instead of querying only the `clients` table. Do filter on `T2.type = 'gold'` and `T1.type = 'OWNER'` instead of filtering on `credit_card_level = 'high'` and `loan_eligibility = 'yes'`. The amended query now correctly calculates age from birth date and uses proper table relationships to identify gold card owners, matching the RIGHT_SQL's behavior.",
            "Do simplify the age calculation to `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date)` instead of the complex `CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T3.birth_date) AS INTEGER) - (CASE WHEN STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T3.birth_date) THEN 1 ELSE 0 END)` expression that included day-of-year adjustment logic. Do use `CURRENT_TIMESTAMP` instead of `'now'` for the current date reference. Do remove the explicit `AS age` alias instead of keeping it. Do correct the join condition to `T2.disp_id = T1.disp_id` instead of `T1.disp_id = T2.disp_id` to maintain consistent table reference order. The amended query now matches RIGHT_SQL's simplified age calculation behavior."
        ],
        "rules": [
            "1) When answering about client IDs and age: select T1.client_id and calculate age using STRFTIME functions instead of selecting age directly. 2) When combining tables for this question: join disp AS T1, card AS T2, and client AS T3 with INNER JOIN conditions instead of querying only the clients table. 3) When filtering for high level credit card: use T2.type = 'gold' instead of credit_card_level = 'high'. 4) When filtering for loan eligibility: use T1.type = 'OWNER' instead of loan_eligibility = 'yes'.",
            "1) When calculating age from birth_date: use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) without day-of-year adjustment logic. 2) When joining card and disp tables: use T2.disp_id = T1.disp_id as the join condition with this exact table reference order. 3) When the question asks for client age: do not include an explicit AS age alias in the output. 4) When referencing current timestamp: use CURRENT_TIMESTAMP instead of 'now'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id, age FROM clients WHERE credit_card_level = 'high' AND loan_eligibility = 'yes';",
            "SELECT \n    T1.client_id,\n    CAST(STRFTIME('%Y', 'now') AS INTEGER) - CAST(STRFTIME('%Y', T3.birth_date) AS INTEGER) - \n    (CASE WHEN STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T3.birth_date) THEN 1 ELSE 0 END) AS age\nFROM \n    disp AS T1\nINNER JOIN \n    card AS T2 ON T1.disp_id = T2.disp_id\nINNER JOIN \n    client AS T3 ON T1.client_id = T3.client_id\nWHERE \n    T2.type = 'gold' \n    AND T1.type = 'OWNER'",
            "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) \nFROM disp AS T1\nINNER JOIN card AS T2 ON T2.disp_id = T1.disp_id\nINNER JOIN client AS T3 ON T1.client_id = T3.client_id\nWHERE T2.type = 'gold' AND T1.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT T1.client_id, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) FROM disp AS T1 INNER JOIN card AS T2 ON T2.disp_id = T1.disp_id INNER JOIN client AS T3 ON T1.client_id = T3.client_id WHERE T2.type = 'gold' AND T1.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "778": {
        "db_id": "superhero",
        "question": "Provide superheroes' names who have the adaptation power.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'",
        "amends": [
            "Do use `T1.superhero_name` instead of `name` for the column selection. Do add joins to `hero_power AS T2` and `superpower AS T3` instead of querying only the `superheroes` table. Do use `INNER JOIN` on `T1.id = T2.hero_id` and `T2.power_id = T3.id` instead of no joins. Do filter on `T3.power_name = 'Adaptation'` instead of `power = 'flight'` for the condition. The amended query now correctly joins the necessary tables to filter superheroes by power name rather than relying on a non-existent power column in the superheroes table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting superhero names: use \"T1.superhero_name\" instead of \"name\" for the output column. 2) When answering about superheroes with specific powers: join \"superheroes AS T1\" to \"hero_power AS T2\" on \"T1.id = T2.hero_id\" and join to \"superpower AS T3\" on \"T2.power_id = T3.id\" using inner matches. 3) When filtering for adaptation power: use the exact literal \"Adaptation\" with \"T3.power_name = 'Adaptation'\" as the condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE power = 'flight';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Adaptation'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Adaptation'"
        ],
        "amend_res": 1
    },
    "519": {
        "db_id": "card_games",
        "question": "What is the language of the \"Battlebond\" set?",
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
        "amends": [
            "Do query the `set_translations` table instead of the `sets` table. Do use a subquery to filter by `id IN (SELECT id FROM sets WHERE name = 'Battlebond')` instead of directly filtering `sets` by `name = 'Battlebond'`. Do retrieve the `language` column from `set_translations` instead of from `sets`. The amended query now correctly matches the RIGHT_SQL's behavior by accessing language data through the appropriate translation table with proper ID filtering.",
            "Do use `id` in the subquery predicate instead of `setCode` and `code`, changing the join condition to match on the correct identifier column. Do reference `id` in both the outer query's WHERE clause and the subquery's SELECT list instead of using different column names that may not properly correlate. Do maintain the same subquery structure but fix the column references to ensure proper filtering based on the sets table's primary key relationship with set_translations. The amended query now correctly filters set_translations by matching id values with the corresponding set rather than using potentially mismatched code columns."
        ],
        "rules": [
            "1) When answering about the language of a specific set: query the \"set_translations\" table instead of the \"sets\" table. 2) When filtering by set name \"Battlebond\": use a subquery to filter by id IN (SELECT id FROM sets WHERE name = 'Battlebond') instead of directly filtering the sets table. 3) When retrieving language information: get the \"language\" column from \"set_translations\" instead of from \"sets\".",
            "1) When joining set_translations and sets tables: use the foreign key relationship where set_translations.setCode equals sets.code to link the tables correctly. 2) When filtering for the 'Battlebond' set: use the exact literal 'Battlebond' with the correct case and spelling in the condition. 3) When selecting the language from set_translations: ensure the output column is language from the set_translations table. 4) When using subqueries for filtering: reference the correct identifier columns where the subquery should return sets.code values that match set_translations.setCode values for proper correlation."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT language FROM sets WHERE name = 'Battlebond';",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT code FROM sets WHERE name = 'Battlebond')",
            "SELECT language FROM set_translations WHERE id IN (SELECT id FROM sets WHERE name = 'Battlebond')"
        ],
        "rule_sql": [
            "SELECT DISTINCT st.language \nFROM set_translations st \nWHERE st.setCode IN (SELECT code FROM sets WHERE name = 'Battlebond')"
        ],
        "amend_res": 1
    },
    "790": {
        "db_id": "superhero",
        "question": "Calculate the difference between Emil Blonsky's weight and Charles Chandler's weight.",
        "ground_truth": "SELECT ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky' ) - ( SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler' ) AS CALCULATE",
        "amends": [
            "Do use subqueries to select `weight_kg` from the `superhero` table instead of joining the same table twice as `characters`. Do filter with `full_name LIKE 'Emil Blonsky'` and `full_name LIKE 'Charles Chandler'` instead of using exact matches on `name`. Do calculate the difference directly with subtraction `(SELECT...) - (SELECT...)` instead of using `ABS(e.weight - c.weight)`. Do alias the result as `CALCULATE` instead of `weight_difference`. The amended query now correctly retrieves weight data from the superhero table and calculates the difference between the two specific characters."
        ],
        "rules": [
            "1) When the question asks about character weights: retrieve data from the \"superhero\" table instead of a \"characters\" table. 2) When filtering for specific characters: use \"full_name LIKE 'Emil Blonsky'\" and \"full_name LIKE 'Charles Chandler'\" instead of exact matches on a \"name\" column. 3) When calculating weight differences: use direct subtraction \"(SELECT...) - (SELECT...)\" instead of ABS function. 4) When naming the result column: alias it as \"CALCULATE\" instead of \"weight_difference\". 5) When selecting weight values: use the exact column name \"weight_kg\" from the \"superhero\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT ABS(e.weight - c.weight) AS weight_difference\nFROM characters e, characters c\nWHERE e.name = 'Emil Blonsky' AND c.name = 'Charles Chandler';",
            "SELECT \n    (SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky') - \n    (SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler') \n    AS CALCULATE"
        ],
        "rule_sql": [
            "SELECT \n    (SELECT weight_kg FROM superhero WHERE full_name LIKE 'Emil Blonsky') - \n    (SELECT weight_kg FROM superhero WHERE full_name LIKE 'Charles Chandler') AS CALCULATE;"
        ],
        "amend_res": 1
    },
    "113": {
        "db_id": "financial",
        "question": "For the client who applied 98832 USD loan in 1996/1/3, when was his/her birthday?",
        "evidence": "",
        "ground_truth": "SELECT T4.birth_date FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id INNER JOIN client AS T4 ON T3.client_id = T4.client_id WHERE T1.date = '1996-01-03' AND T1.amount = 98832",
        "amends": [
            "Do select `T4.birth_date` from the `client` table instead of `birthday` from `clients`. Do join multiple tables including `loan`, `account`, `disp`, and `client` with `INNER JOIN` conditions instead of querying only the `clients` table. Do use proper join predicates `T1.account_id = T2.account_id`, `T2.account_id = T3.account_id`, and `T3.client_id = T4.client_id` instead of no joins. Do filter on `T1.date = '1996-01-03'` with proper date format instead of `application_date = '1996/1/3'`. Do filter on `T1.amount = 98832` from the `loan` table instead of `loan_amount = 98832` from `clients`. The amended query now correctly retrieves birth dates by properly joining through the relational schema and using the correct table and column references."
        ],
        "rules": [
            "1) When answering about a client's birthday: select T4.birth_date from the client table instead of birthday from clients. 2) When combining loan, account, disp, and client tables: link rows using inner joins with predicates T1.account_id = T2.account_id, T2.account_id = T3.account_id, and T3.client_id = T4.client_id to keep only matching pairs. 3) When filtering by loan application date: use T1.date = '1996-01-03' with the exact date format '1996-01-03' instead of '1996/1/3'. 4) When filtering by loan amount: use T1.amount = 98832 from the loan table instead of loan_amount from clients."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT birthday FROM clients WHERE loan_amount = 98832 AND application_date = '1996/1/3';",
            "SELECT T4.birth_date\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE T1.date = '1996-01-03' AND T1.amount = 98832"
        ],
        "rule_sql": [
            "SELECT T4.birth_date\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE T1.amount = 98832\nAND T1.date = '1996-01-03';"
        ],
        "amend_res": 1
    },
    "1186": {
        "db_id": "thrombosis_prediction",
        "question": "Lists all patients by ID who were diagnosed with Behcet's and had their exams between 01/01/197 and 12/31/1997.",
        "ground_truth": "SELECT ID FROM Examination WHERE `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31' AND Diagnosis = 'Behcet'",
        "amends": [
            "Do select `ID` from the `Examination` table instead of `patient_id` from `patients`. Do filter on `Examination Date` between '1997-01-01' and '1997-12-31' instead of '1970-01-01' and '1997-12-31'. Do use backtick-quoted column names `Examination Date` and `Diagnosis` instead of unquoted `exam_date` and `diagnosis`. The amended query now correctly retrieves examination records with Behcet diagnosis from the specified 1997 date range."
        ],
        "rules": [
            "1) When answering about patients diagnosed with Behcet's: use the exact literal 'Behcet' for the Diagnosis filter. 2) When filtering by examination date range: use '1997-01-01' as the start date and '1997-12-31' as the end date for the Examination Date column. 3) When selecting patient identifiers: use the ID column from the Examination table instead of patient_id from patients. 4) When referencing column names: use backtick-quoted `Examination Date` and `Diagnosis` exactly as specified in the schema. 5) When the question asks for patients with exams between specific dates: filter on the Examination Date column with the inclusive range from '1997-01-01' to '1997-12-31'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE diagnosis = 'Behcet' AND exam_date BETWEEN '1970-01-01' AND '1997-12-31';",
            "SELECT ID FROM Examination WHERE `Diagnosis` = 'Behcet' AND `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31'"
        ],
        "rule_sql": [
            "SELECT DISTINCT ID FROM Examination WHERE Diagnosis = 'Behcet' AND `Examination Date` BETWEEN '1997-01-01' AND '1997-12-31'"
        ],
        "amend_res": 1
    },
    "1261": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with a normal RF don't have thrombosis?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND T1.Thrombosis = 0",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do join `Examination AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single `patients` table. Do filter with `T2.RF < 20` instead of `rf = 'normal'` to use a numeric threshold comparison rather than string matching. Do filter with `T1.Thrombosis = 0` instead of `thrombosis = 'yes'` to use a numeric boolean representation instead of string values. The amended query now correctly counts distinct patients with specific laboratory and examination criteria."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows. 2) When combining examination and laboratory data: link rows where T1.ID = T2.ID using an inner match between Examination AS T1 and Laboratory AS T2. 3) When identifying patients with normal RF: filter with T2.RF < 20 to use a numeric threshold comparison rather than string matching. 4) When identifying patients without thrombosis: filter with T1.Thrombosis = 0 to use a numeric boolean representation instead of string values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE rf = 'normal' AND thrombosis = 'yes';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.RF < 20 \nAND T1.Thrombosis = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.RF < 20 \nAND T1.Thrombosis = 0"
        ],
        "amend_res": 1
    },
    "755": {
        "db_id": "superhero",
        "question": "List down at least five full name of Demi-God superheroes.",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Demi-God'",
        "amends": [
            "Do specify the table alias `T1` for `full_name` instead of using the bare column name. Do join `superhero AS T1` with `race AS T2` on `T1.race_id = T2.id` instead of querying only the `superheroes` table. Do filter on `T2.race = 'Demi-God'` instead of `hero_type = 'Demi-God'` to correctly identify demi-gods through the race relationship. Do remove the `LIMIT 5` clause instead of keeping it since the corrected query should return all matching records. The amended query now correctly joins the superhero and race tables to identify demi-gods through the proper relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Demi-God superheroes\": make sure the output order: T1.full_name\n2) When the question mentions \"Demi-God superheroes\": \"Demi-God\" actually means \"T2.race = 'Demi-God'\" in schema\n3) When combining T1 (superhero) and T2 (race) for shared entities: link rows where T1.race_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"full name\": use the exact token T1.full_name from the schema\n5) When the question says \"at least five\": return all matching records instead of limiting to exactly 5 rows"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT full_name FROM superheroes WHERE hero_type = 'Demi-God' LIMIT 5;",
            "SELECT T1.full_name\nFROM superhero AS T1\nJOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Demi-God'"
        ],
        "rule_sql": [
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN race T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Demi-God'\nORDER BY T1.full_name;"
        ],
        "amend_res": 1
    },
    "280": {
        "db_id": "toxicology",
        "question": "Enumerate the bond ID of triple bond type molecules and tell me if they are carcinogenic or not.",
        "ground_truth": "SELECT DISTINCT T1.bond_id, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, do select `T1.bond_id` and `T2.label` instead of `bond_id` and `carcinogenic`, do join `bond AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only `molecules`, do use `INNER JOIN` instead of no join, do filter on `T1.bond_type = '#'` instead of `bond_type = 'triple'`, and do reference tables with aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins bond and molecule tables to retrieve distinct bond IDs with their corresponding labels for triple bonds."
        ],
        "rules": [
            "1) When the question asks about \"bond ID of triple bond type molecules\": select distinct T1.bond_id from the bond table (aliased as T1) instead of from a molecules table. 2) When the question asks about \"carcinogenic or not\": select T2.label instead of a carcinogenic column, as the carcinogenic information is stored in the label column of the molecule table. 3) When combining bond and molecule information: join bond AS T1 with molecule AS T2 on T1.molecule_id = T2.molecule_id using an inner join to ensure only matching pairs are included. 4) When filtering for triple bond type: use T1.bond_type = '#' instead of 'triple' as the exact literal value in the schema. 5) When referencing tables: always use the aliases T1 for bond table and T2 for molecule table as established in the join."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_id, carcinogenic FROM molecules WHERE bond_type = 'triple'",
            "SELECT DISTINCT T1.bond_id, T2.label\nFROM bond AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.bond_id, T2.label \nFROM bond AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "1136": {
        "db_id": "european_football_2",
        "question": "How many players had the highest potential score for crossing that preferred to use their left foots while attacking?",
        "ground_truth": "SELECT COUNT(t1.id) FROM Player_Attributes AS t1 WHERE t1.preferred_foot = 'left' AND t1.crossing = ( SELECT MAX(crossing) FROM Player_Attributes)",
        "amends": [
            "Do reference the `Player_Attributes` table instead of `players`. Do use `COUNT(t1.id)` instead of `COUNT(*)`. Do use lowercase `'left'` instead of `'Left'` for the preferred_foot condition. Do remove the unnecessary condition checking for maximum potential. Do remove the attacking_work_rate filter instead of keeping it. Do reference the crossing maximum from the correct `Player_Attributes` table instead of `players`. The amended query now correctly counts players with left preferred foot and maximum crossing ability from the Player_Attributes table."
        ],
        "rules": [
            "1) When answering about \"players with highest potential score for crossing\": use the \"Player_Attributes\" table instead of \"players\" table. 2) When counting players: use COUNT(t1.id) instead of COUNT(*) to count using the canonical key. 3) When checking preferred foot: use lowercase 'left' instead of 'Left' for the preferred_foot condition. 4) When filtering for maximum crossing ability: remove the unnecessary condition checking for maximum potential and only check for maximum crossing from the Player_Attributes table. 5) When the question mentions \"preferred to use their left foots\": this means preferred_foot = 'left' exactly. 6) When the question asks about \"highest potential score for crossing\": this means crossing = (SELECT MAX(crossing) FROM Player_Attributes). 7) When the question does not mention attacking work rate: remove the attacking_work_rate filter entirely."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players \nWHERE potential = (SELECT MAX(potential) FROM players) \nAND crossing = (SELECT MAX(crossing) FROM players) \nAND preferred_foot = 'Left' \nAND attacking_work_rate = 'High';",
            "SELECT COUNT(t1.id) \nFROM Player_Attributes t1\nWHERE t1.preferred_foot = 'left'\nAND t1.crossing = (SELECT MAX(crossing) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT COUNT(t1.id) \nFROM Player_Attributes t1\nWHERE t1.preferred_foot = 'left'\nAND t1.crossing = (SELECT MAX(crossing) FROM Player_Attributes)"
        ],
        "amend_res": 1
    },
    "689": {
        "db_id": "codebase_community",
        "question": "Identify the display name and location of the user, who was the last to edit the post with ID 183.",
        "ground_truth": "SELECT T2.DisplayName, T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Id = 183 ORDER BY T1.LastEditDate DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` between `posts` and `users` on `OwnerUserId = Id` instead of a subquery with `editor_id`. Do select `DisplayName` and `Location` from the joined `users` table instead of `display_name` and `location` from the base table. Do filter by `Id = 183` directly on the `posts` table instead of using a subquery with `post_id = 183`. Do order by `LastEditDate DESC` on the `posts` table instead of `edit_date DESC` in the subquery. Do use proper table aliases `T1` for `posts` and `T2` for `users` instead of no aliases. The amended query now correctly joins the tables and retrieves user information based on the specific post ID with proper ordering.",
            "Do join on `T1.OwnerUserId = T2.Id` instead of `T1.LastEditorUserId = T2.Id` for the correct user relationship. The amended query now matches RIGHT_SQL's behavior by properly linking posts to their owners rather than last editors."
        ],
        "rules": [
            "1) When combining posts and users tables: link rows where T1.OwnerUserId = T2.Id and keep only matching pairs (inner join). 2) When filtering for a specific post: apply the condition T1.Id = 183 directly on the posts table. 3) When ordering by edit date to find the last editor: sort by T1.LastEditDate in descending order. 4) When selecting user information: retrieve T2.DisplayName and T2.Location from the users table. 5) When the question asks for the last editor of a post: use the OwnerUserId to Id relationship between posts and users tables to identify the user.",
            "1) When the question asks about the user who was the last to edit a post: use the LastEditorUserId column to identify the user, not the OwnerUserId column. 2) When joining the posts table (T1) with the users table (T2) to find user information: link rows where T1.LastEditorUserId = T2.Id to correctly identify the last editor user. 3) When filtering for a specific post by ID: use the exact literal value 183 for T1.Id. 4) When identifying the last editor: order by T1.LastEditDate in descending order and take the first result to get the most recent edit."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT display_name, location FROM users WHERE user_id = (SELECT editor_id FROM posts WHERE post_id = 183 ORDER BY edit_date DESC LIMIT 1);",
            "SELECT T2.DisplayName, T2.Location\nFROM posts T1\nINNER JOIN users T2 ON T1.LastEditorUserId = T2.Id\nWHERE T1.Id = 183\nORDER BY T1.LastEditDate DESC\nLIMIT 1",
            "SELECT T2.DisplayName, T2.Location\nFROM posts T1\nINNER JOIN users T2 ON T1.OwnerUserId = T2.Id\nWHERE T1.Id = 183\nORDER BY T1.LastEditDate DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT u.DisplayName, u.Location\nFROM posts p\nINNER JOIN users u ON p.LastEditorUserId = u.Id\nWHERE p.Id = 183\nORDER BY p.LastEditDate DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "717": {
        "db_id": "superhero",
        "question": "Please list all the superpowers of 3-D Man.",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "amends": [
            "Do select only `T3.power_name` instead of selecting all columns with `*`. Do join from `superhero AS T1` instead of querying `superpowers` directly. Do add `INNER JOIN hero_power AS T2` on `T1.id = T2.hero_id` instead of omitting this relationship table. Do add `INNER JOIN superpower AS T3` on `T2.power_id = T3.id` instead of querying a non-existent `superpowers` table. Do filter on `T1.superhero_name = '3-D Man'` instead of filtering on `hero_name` from the wrong table. The amended query now correctly retrieves power names through proper table relationships instead of attempting to query a non-existent table directly."
        ],
        "rules": [
            "1) When answering about \"superpowers of 3-D Man\": make sure the output order: T3.power_name. 2) When the question mentions \"superpowers\": \"superpowers\" actually means \"power_name in superpower table T3\" through proper relationships. 3) When combining T1, T2, and T3 for shared entities: link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match). 4) When filtering for \"3-D Man\": use T1.superhero_name = '3-D Man' exactly as specified. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM superpowers WHERE hero_name = '3-D Man';",
            "SELECT T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = '3-D Man'"
        ],
        "rule_sql": [
            "SELECT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = '3-D Man'\nORDER BY T3.power_name"
        ],
        "amend_res": 1
    },
    "103": {
        "db_id": "financial",
        "question": "Which client issued his/her card in 1994/3/3, give his/her client id.",
        "evidence": "",
        "ground_truth": "SELECT T2.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'",
        "amends": [
            "Do select `T2.client_id` from the `disp` table instead of `client_id` from the `cards` table. Do join `client AS T1` and `disp AS T2` with `INNER JOIN` on `T1.client_id = T2.client_id` instead of querying only the `cards` table. Do add another `INNER JOIN` to `card AS T3` on `T2.disp_id = T3.disp_id` instead of missing these table relationships. Do filter on `T3.issued = '1994-03-03'` with proper date format instead of `issue_date = '1994/3/3'` with incorrect date format and column name. The amended query now correctly joins the client, disp, and card tables to find clients with cards issued on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about clients who issued cards on a specific date: make sure the output order: T2.client_id\n2) When the question mentions \"client id\": \"client id\" actually means \"T2.client_id\" in schema\n3) When combining T1 (client) and T2 (disp) for shared entities: link rows where T1.client_id = T2.client_id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When combining T2 (disp) and T3 (card) for shared entities: link rows where T2.disp_id = T3.disp_id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When filtering by date '1994/3/3': use T3.issued = '1994-03-03' with proper date format instead of incorrect format '1994/3/3'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id FROM cards WHERE issue_date = '1994/3/3';",
            "SELECT T2.client_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN card AS T3 ON T2.disp_id = T3.disp_id\nWHERE T3.issued = '1994-03-03'"
        ],
        "rule_sql": [
            "SELECT T1.client_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN card T3 ON T2.disp_id = T3.disp_id\nWHERE T3.issued = '1994-03-03'\nORDER BY T2.client_id"
        ],
        "amend_res": 1
    },
    "135": {
        "db_id": "financial",
        "question": "After making a credit card withdrawal, how many account/s with monthly issuance has a negative balance?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.balance < 0 AND T1.operation = 'VYBER KARTOU' AND T2.frequency = 'POPLATEK MESICNE'",
        "amends": [
            "Do select `COUNT(T1.account_id)` from the `trans` table instead of `COUNT(*)` from the `accounts` table. Do join `account AS T2` with `INNER JOIN` on `T1.account_id = T2.account_id` instead of querying a single table. Do filter on `T1.balance < 0` and `T1.operation = 'VYBER KARTOU'` instead of `account_type = 'credit card'` and `monthly_issuance = 'yes'`. Do add the condition `T2.frequency = 'POPLATEK MESICNE'` instead of omitting frequency filtering. The amended query now correctly counts debit card withdrawal operations from monthly payment accounts with negative balances, matching the intended behavior."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T1.account_id) from the trans table instead of COUNT(*) from the accounts table. 2) When combining transaction and account data: join account AS T2 with trans table using INNER JOIN on T1.account_id = T2.account_id. 3) When filtering for credit card withdrawals: use T1.operation = 'VYBER KARTOU' instead of account_type = 'credit card'. 4) When filtering for negative balances: use T1.balance < 0. 5) When filtering for monthly issuance accounts: use T2.frequency = 'POPLATEK MESICNE' instead of monthly_issuance = 'yes'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE account_type = 'credit card' AND balance < 0 AND monthly_issuance = 'yes';",
            "SELECT COUNT(T1.account_id) \nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.balance < 0 \nAND T1.operation = 'VYBER KARTOU'\nAND T2.frequency = 'POPLATEK MESICNE'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.operation = 'VYBER KARTOU'\nAND T1.balance < 0\nAND T2.frequency = 'POPLATEK MESICNE'"
        ],
        "amend_res": 1
    },
    "397": {
        "db_id": "card_games",
        "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
        "ground_truth": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
        "amends": [
            "Do use column name `manaCost` instead of `mana_cost` to match the correct schema. Do use filter `availability = 'mtgo,paper'` instead of the OR condition `(availability = 'paper' OR availability = 'mtgo')` to properly handle the comma-separated values. Do use column name `borderColor` instead of `border_color` and `frameVersion` instead of `frame_version` with the correct data type by removing quotes around `2003` instead of treating it as a string. The amended query now correctly filters for cards with the specified attributes using the proper column names and value formats."
        ],
        "rules": [
            "1) When the question asks for mana cost: use column name \"manaCost\" instead of \"mana_cost\" to match the schema. 2) When filtering for border color: use column name \"borderColor\" instead of \"border_color\" and filter for exact value 'black'. 3) When filtering for frame version: use column name \"frameVersion\" instead of \"frame_version\" and filter for exact value '2003' without quotes. 4) When filtering for availability in both paper and mtgo: use filter \"availability = 'mtgo,paper'\" instead of OR conditions to handle comma-separated values properly. 5) When answering about cards with normal layout: filter layout = 'normal' using exact string literal."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT mana_cost FROM cards WHERE layout = 'normal' AND frame_version = '2003' AND border_color = 'black' AND (availability = 'paper' OR availability = 'mtgo');",
            "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = 2003 AND borderColor = 'black' AND availability = 'mtgo,paper';"
        ],
        "rule_sql": [
            "SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability = 'mtgo,paper';"
        ],
        "amend_res": 1
    },
    "824": {
        "db_id": "superhero",
        "question": "Identify superheroes who can control wind and list their names in alphabetical order.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Wind Control' ORDER BY T1.superhero_name",
        "amends": [
            "Do use `T1.superhero_name` instead of `name` in the SELECT list. Do add joins to `hero_power AS T2` and `superpower AS T3` instead of querying only the `superheroes` table. Do use `INNER JOIN` on `T1.id = T2.hero_id` and `INNER JOIN` on `T2.power_id = T3.id` instead of no joins. Do change the WHERE filter to `T3.power_name = 'Wind Control'` instead of `powers LIKE '%wind%'` to precisely match the power name rather than using a pattern match. Do use `ORDER BY T1.superhero_name` instead of `ORDER BY name ASC` while maintaining ascending order. The amended query now correctly identifies superheroes with the specific 'Wind Control' power through proper table relationships instead of relying on pattern matching in a single column."
        ],
        "rules": [
            "1) When answering about superheroes who can control wind: use T1.superhero_name instead of name in the output. 2) When the question mentions \"control wind\": this actually means T3.power_name = 'Wind Control' in the schema. 3) When combining tables for superhero powers: link T1 and T2 where T1.id = T2.hero_id, and link T2 and T3 where T2.power_id = T3.id, keeping only matching pairs (inner match). 4) When listing names in alphabetical order: order the results by T1.superhero_name in ascending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE powers LIKE '%wind%' ORDER BY name ASC;",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Wind Control'\nORDER BY T1.superhero_name;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Wind Control'\nORDER BY T1.superhero_name ASC;"
        ],
        "amend_res": 1
    },
    "944": {
        "db_id": "formula_1",
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "ground_truth": "WITH time_in_seconds AS ( SELECT T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6) AS REAL) ELSE CAST(SUBSTR(T1.time, 2) AS REAL) END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008 ), champion_time AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = 1), last_driver_incremental AS ( SELECT time_seconds FROM time_in_seconds WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds) ) SELECT (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)",
        "amends": [
            "Do use a CTE structure with `time_in_seconds`, `champion_time`, and `last_driver_incremental` instead of a simple aggregate query. Do join `results` with `races` on `raceId` instead of querying a single `race_results` table. Do convert time strings to seconds using `SUBSTR` and `CAST` operations instead of assuming `laptime` is numeric. Do filter by `year = 2008` and `name = 'Australian Grand Prix'` instead of just race name. Do calculate percentage using champion time and last driver's time instead of `(MIN - MAX)/MAX`. Do handle different time formats with a `CASE` statement based on `positionOrder` instead of uniform laptime processing. Do ensure proper NULL handling with `time IS NOT NULL` instead of no explicit NULL checks. The amended query now correctly calculates the percentage difference between the champion's time and the last driver's time for the 2008 Australian Grand Prix.",
            "Do use a simplified CASE expression that handles only two specific time formats instead of the complex nested string parsing with multiple INSTR functions. Do reference the time column directly with specific substring positions instead of using dynamic position calculations. Do remove the driverId column from the SELECT list since it's not used in subsequent calculations. Do change the join syntax to explicit INNER JOIN instead of the comma-separated FROM clause. Do fix the percentage calculation formula to use proper division and addition operations instead of the incorrect subtraction-based formula. Do cast the final result explicitly to ensure proper numeric handling instead of relying on implicit casting. The amended query now correctly calculates the percentage relationship between champion and last driver times using the proper mathematical operations.",
            "Do use `T1.positionOrder` in the SELECT list instead of `r.driverId` and simplify the CASE expression to handle only two specific formats instead of three general patterns. Do change the time parsing logic to use fixed positions with `SUBSTR(T1.time, 1, 1)`, `SUBSTR(T1.time, 3, 2)`, and `SUBSTR(T1.time, 6)` for champion times instead of dynamic INSTR-based parsing, and use `CAST(SUBSTR(T1.time, 2) AS REAL)` for other positions instead of the complex conditional logic. Do remove the table alias `r` and use `T1` instead, and change `rc` to `T2` for consistency. Do keep the same JOIN condition `T1.raceId = T2.raceId` but change the WHERE clause order to `T2.name = 'Australian Grand Prix' AND T1.time IS NOT NULL AND T2.year = 2008` instead of the original sequence. Do rename the last CTE to `last_driver_incremental` instead of `last_driver_time`. Do completely change the final calculation to `(CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)` instead of `((lt.time_seconds - ct.time_seconds) / ct.time_seconds) * 100`, which uses a different mathematical formula involving addition in the denominator rather than subtraction-based percentage difference. The amended query now matches RIGHT_SQL's behavior with the corrected time parsing and calculation logic."
        ],
        "rules": [
            "1) When joining race data: combine \"results\" table (T1) with \"races\" table (T2) using the exact key equality T1.\"raceId\" = T2.\"raceId\" and keep only matching pairs (inner match). 2) When filtering for the 2008 Australian Grand Prix: apply both conditions T2.\"year\" = 2008 AND T2.\"name\" = 'Australian Grand Prix' exactly as specified. 3) When converting time strings to seconds: use SUBSTR and CAST operations to handle different time formats instead of assuming numeric values. 4) When handling different time formats: use a CASE statement based on T1.\"positionOrder\" to process time values appropriately. 5) When checking for valid time data: ensure T1.\"time\" IS NOT NULL to handle missing values properly. 6) When calculating percentage difference between champion and last driver: compute (champion_time - last_driver_time) / last_driver_time * 100 using the exact time values in seconds. 7) When identifying the champion: use the driver with T1.\"positionOrder\" = 1 (lowest position order value). 8) When identifying the last driver: use the driver with the highest T1.\"positionOrder\" value that completed the race.",
            "1) When handling time format conversions: use a simplified CASE expression that handles only two specific time formats instead of complex nested string parsing with multiple INSTR functions. 2) When referencing time column values: reference the time column directly with specific substring positions instead of using dynamic position calculations. 3) When selecting columns for intermediate results: remove unused columns like driverId from the SELECT list since they're not used in subsequent calculations. 4) When combining tables: use explicit INNER JOIN syntax instead of comma-separated FROM clauses. 5) When calculating percentage differences between times: use proper division and addition operations instead of incorrect subtraction-based formulas for percentage calculations. 6) When handling numeric results: cast the final result explicitly to ensure proper numeric handling instead of relying on implicit casting.",
            "1) When parsing time values from T1.time: for champion positions (positionOrder = 1), extract hours using SUBSTR(T1.time, 1, 1), minutes using SUBSTR(T1.time, 3, 2), and seconds using SUBSTR(T1.time, 6); for other positions, extract seconds using CAST(SUBSTR(T1.time, 2) AS REAL). 2) When combining T1 and T2 for race information: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 3) When filtering for the 2008 Australian Grand Prix: use T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL. 4) When calculating percentage difference between champion and last driver: use the formula (last_driver_time * 100) / (champion_time + last_driver_time) instead of the standard percentage difference formula."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (MIN(laptime) - MAX(laptime)) / MAX(laptime) * 100 AS percentage_faster\nFROM \n    race_results \nWHERE \n    race = '2008 Australian Grand Prix';",
            "WITH time_in_seconds AS (\n    SELECT \n        r.driverId,\n        r.positionOrder,\n        CASE \n            WHEN r.time LIKE '%:%:%' THEN \n                CAST(SUBSTR(r.time, 1, INSTR(r.time, ':') - 1) AS REAL) * 3600 + \n                CAST(SUBSTR(r.time, INSTR(r.time, ':') + 1, INSTR(SUBSTR(r.time, INSTR(r.time, ':') + 1), ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(r.time, INSTR(r.time, ':', INSTR(r.time, ':') + 1) + 1) AS REAL)\n            WHEN r.time LIKE '%:%' THEN \n                CAST(SUBSTR(r.time, 1, INSTR(r.time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(r.time, INSTR(r.time, ':') + 1) AS REAL)\n            ELSE CAST(r.time AS REAL)\n        END AS time_seconds\n    FROM results r\n    JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year = 2008 \n        AND rc.name = 'Australian Grand Prix'\n        AND r.time IS NOT NULL\n),\nchampion_time AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n),\nlast_driver_incremental AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds)\n)\nSELECT \n    ((ld.time_seconds - ct.time_seconds) / ld.time_seconds) * 100 AS percentage_faster\nFROM champion_time ct, last_driver_incremental ld;",
            "WITH time_in_seconds AS (\n    SELECT \n        r.driverId,\n        r.positionOrder,\n        CASE \n            WHEN r.time LIKE '%:%:%' THEN \n                CAST(SUBSTR(r.time, 1, INSTR(r.time, ':') - 1) AS REAL) * 3600 + \n                CAST(SUBSTR(r.time, INSTR(r.time, ':') + 1, INSTR(SUBSTR(r.time, INSTR(r.time, ':') + 1), ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(r.time, INSTR(r.time, ':', INSTR(r.time, ':') + 1) + 1) AS REAL)\n            WHEN r.time LIKE '%:%' THEN \n                CAST(SUBSTR(r.time, 1, INSTR(r.time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(r.time, INSTR(r.time, ':') + 1) AS REAL)\n            ELSE CAST(r.time AS REAL)\n        END AS time_seconds\n    FROM results r\n    INNER JOIN races rc ON r.raceId = rc.raceId\n    WHERE rc.year = 2008 \n    AND rc.name = 'Australian Grand Prix'\n    AND r.time IS NOT NULL\n),\nchampion_time AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n),\nlast_driver_time AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds)\n)\nSELECT \n    ((lt.time_seconds - ct.time_seconds) / ct.time_seconds) * 100 AS percentage_faster\nFROM champion_time ct, last_driver_time lt;",
            "WITH time_in_seconds AS (\n    SELECT \n        T1.positionOrder,\n        CASE \n            WHEN T1.positionOrder = 1 THEN \n                CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 6) AS REAL)\n            ELSE \n                CAST(SUBSTR(T1.time, 2) AS REAL)\n        END AS time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T2.name = 'Australian Grand Prix' \n    AND T1.time IS NOT NULL \n    AND T2.year = 2008\n),\nchampion_time AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n),\nlast_driver_incremental AS (\n    SELECT time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = (SELECT MAX(positionOrder) FROM time_in_seconds)\n)\nSELECT \n    (CAST((SELECT time_seconds FROM last_driver_incremental) AS REAL) * 100) / \n    (SELECT time_seconds + (SELECT time_seconds FROM last_driver_incremental) FROM champion_time)"
        ],
        "rule_sql": [
            "WITH race_times AS (\n    SELECT \n        T1.positionOrder,\n        CASE \n            WHEN T1.positionOrder = 1 THEN \n                CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 6) AS REAL)\n            ELSE \n                CAST(SUBSTR(T1.time, 2) AS REAL)\n        END AS time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T2.year = 2008 \n    AND T2.name = 'Australian Grand Prix'\n    AND T1.time IS NOT NULL\n)\nSELECT \n    (last_driver_time * 100) / (champion_time + last_driver_time) AS percentage_faster\nFROM (\n    SELECT \n        MAX(CASE WHEN positionOrder = 1 THEN time_seconds END) AS champion_time,\n        MAX(CASE WHEN positionOrder = (SELECT MAX(positionOrder) FROM race_times) THEN time_seconds END) AS last_driver_time\n    FROM race_times\n)"
        ],
        "amend_res": 1
    },
    "1457": {
        "db_id": "student_club",
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
        "amends": [
            "Do select `DISTINCT T3.first_name, T3.last_name, T3.phone` instead of `m.first_name, m.last_name, m.contact_number` with different column names and aliases. Do use `INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id` and `INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member` instead of a single `JOIN expenses e ON m.member_id = e.member_id` with different table names and join conditions. Do filter with `T1.cost > (subquery)` instead of `e.amount > (subquery)` using different column names. Do remove the `GROUP BY m.member_id` clause instead of keeping it since DISTINCT provides the deduplication. Do use a correlated subquery that joins the same three tables instead of a simple `AVG(amount) FROM expenses`. The amended query now correctly identifies members with expenses above the average cost across the joined dataset."
        ],
        "rules": [
            "1) When the question asks for \"full name and contact number\": select distinct \"T3\".\"first_name\", \"T3\".\"last_name\", \"T3\".\"phone\" instead of m.first_name, m.last_name, m.contact_number. 2) When combining tables for expense analysis: use INNER JOIN \"budget\" AS \"T2\" ON \"T1\".\"link_to_budget\" = \"T2\".\"budget_id\" and INNER JOIN \"member\" AS \"T3\" ON \"T3\".\"member_id\" = \"T1\".\"link_to_member\" instead of a single join on expenses. 3) When filtering for expenses above average: use \"T1\".\"cost\" > (correlated subquery) instead of e.amount > (simple average). 4) When deduplicating results: use DISTINCT instead of GROUP BY \"T3\".\"member_id\". 5) When computing average expense cost: use a correlated subquery that joins the same three tables instead of a simple average from a single table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name, m.contact_number \nFROM members m\nJOIN expenses e ON m.member_id = e.member_id\nWHERE e.amount > (SELECT AVG(amount) FROM expenses)\nGROUP BY m.member_id;",
            "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nINNER JOIN member AS T3 ON T3.member_id = T1.link_to_member\nWHERE T1.cost > (\n    SELECT AVG(T1_sub.cost)\n    FROM expense AS T1_sub\n    INNER JOIN budget AS T2_sub ON T1_sub.link_to_budget = T2_sub.budget_id\n    INNER JOIN member AS T3_sub ON T3_sub.member_id = T1_sub.link_to_member\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"T3\".\"first_name\", \"T3\".\"last_name\", \"T3\".\"phone\"\nFROM \"expense\" AS \"T1\"\nINNER JOIN \"budget\" AS \"T2\" ON \"T1\".\"link_to_budget\" = \"T2\".\"budget_id\"\nINNER JOIN \"member\" AS \"T3\" ON \"T3\".\"member_id\" = \"T1\".\"link_to_member\"\nWHERE \"T1\".\"cost\" > (\n    SELECT AVG(e2.cost)\n    FROM \"expense\" AS e2\n    INNER JOIN \"budget\" AS b2 ON e2.\"link_to_budget\" = b2.\"budget_id\"\n    INNER JOIN \"member\" AS m2 ON m2.\"member_id\" = e2.\"link_to_member\"\n    WHERE m2.\"member_id\" = \"T3\".\"member_id\"\n)"
        ],
        "amend_res": 1
    },
    "305": {
        "db_id": "toxicology",
        "question": "Name all bonds with single bond types and what atoms are connected to the molecules.",
        "ground_truth": "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do reference `bond` as `T1` instead of `bonds` as `b`, and `connected` as `T2` instead of joining `atoms` twice as `a1` and `a2`. Do select `T2.atom_id` and `T2.atom_id2` instead of `a1.atom_name AS atom1` and `a2.atom_name AS atom2`. Do use `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of joining on `b.atom1_id = a1.atom_id` and `b.atom2_id = a2.atom_id`. Do filter for `T1.bond_type = '-'` instead of `b.bond_type = 'double'`. The amended query now correctly retrieves bond connections from the connected table rather than attempting to reconstruct atom relationships through separate atom table joins.",
            "Do remove `T1.bond_type` from the SELECT list instead of including it, as this column is not needed in the final output despite being used in the WHERE filter. The amended query now matches RIGHT_SQL's behavior by only returning the essential bond and atom identification columns."
        ],
        "rules": [
            "1) When answering about bonds with single bond types: filter for T1.bond_type = '-' exactly as specified. 2) When retrieving connected atoms for bonds: select T2.atom_id and T2.atom_id2 from the connected table T2 instead of joining atoms table multiple times. 3) When combining bond and connected tables: link rows where T1.bond_id = T2.bond_id using an inner match. 4) When referring to the bonds table: use T1 as the alias instead of b. 5) When referring to the connected table: use T2 as the alias instead of a1 and a2.",
            "1) When the question asks for bonds with single bond types: filter bonds where T1.bond_type equals exactly '-' 2) When the question asks what atoms are connected to the molecules: include both atom identification columns T2.atom_id and T2.atom_id2 in the output 3) When combining bond and connected tables: link rows where T1.bond_id equals T2.bond_id and keep only matching pairs (inner match) 4) When producing output columns: include only T1.bond_id, T2.atom_id, and T2.atom_id2 in the result, excluding T1.bond_type from the final output"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.bond_id, a1.atom_name AS atom1, a2.atom_name AS atom2\nFROM bonds b\nJOIN atoms a1 ON b.atom1_id = a1.atom_id\nJOIN atoms a2 ON b.atom2_id = a2.atom_id\nWHERE b.bond_type = 'double';",
            "SELECT T1.bond_id, T1.bond_type, T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'",
            "SELECT T1.bond_id, T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT T1.bond_id, T2.atom_id, T2.atom_id2 FROM bond T1 INNER JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'"
        ],
        "amend_res": 1
    },
    "1425": {
        "db_id": "student_club",
        "question": "In the College of Agriculture and Applied Sciences, how many majors are under the department of School of Applied Sciences, Technology and Education?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(major_id) FROM major WHERE department = 'School of Applied Sciences, Technology and Education' AND college = 'College of Agriculture and Applied Sciences'",
        "amends": [
            "Do query the `major` table instead of the `departments` table. Do count `major_id` instead of using `COUNT(*)`. Do filter on `department = 'School of Applied Sciences, Technology and Education'` instead of `department_name = 'School of Applied Sciences, Technology and Education'`. Do filter on `college = 'College of Agriculture and Applied Sciences'` instead of `college_name = 'College of Agriculture and Applied Sciences'`. The amended query now correctly counts majors in the specified department and college rather than counting departments themselves."
        ],
        "rules": [
            "1) When answering about majors in a specific college and department: query the \"major\" table instead of the \"departments\" table. 2) When counting majors: count \"major_id\" instead of using COUNT(*). 3) When filtering by department: use \"department = 'School of Applied Sciences, Technology and Education'\" instead of \"department_name = 'School of Applied Sciences, Technology and Education'\". 4) When filtering by college: use \"college = 'College of Agriculture and Applied Sciences'\" instead of \"college_name = 'College of Agriculture and Applied Sciences'\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM departments WHERE college_name = 'College of Agriculture and Applied Sciences' AND department_name = 'School of Applied Sciences, Technology and Education';",
            "SELECT COUNT(major_id) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education'"
        ],
        "rule_sql": [
            "SELECT COUNT(major_id) FROM major WHERE college = 'College of Agriculture and Applied Sciences' AND department = 'School of Applied Sciences, Technology and Education'"
        ],
        "amend_res": 1
    },
    "58": {
        "db_id": "california_schools",
        "question": "What is the phone number and extension number for the school with the zip code 95203-3704? Indicate the school's name.",
        "evidence": "",
        "ground_truth": "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'",
        "amends": [
            "Do use column aliases `Phone`, `Ext`, and `School` instead of the original column names `phone_number`, `extension`, and `school_name`. Do filter on column `Zip` instead of `zip_code` while maintaining the same filter value '95203-3704'. The amended query now matches RIGHT_SQL's behavior with corrected column references."
        ],
        "rules": [
            "1) When the question asks for phone number and extension number: use column aliases \"Phone\" and \"Ext\" instead of \"phone_number\" and \"extension\". 2) When the question asks for school name: use column alias \"School\" instead of \"school_name\". 3) When filtering by zip code '95203-3704': use column \"Zip\" instead of \"zip_code\" and maintain the exact literal value '95203-3704'."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT phone_number, extension, school_name FROM schools WHERE zip_code = '95203-3704';",
            "SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704';"
        ],
        "rule_sql": [
            "SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';",
            "SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';"
        ],
        "amend_res": 1
    },
    "740": {
        "db_id": "superhero",
        "question": "How many female superheroes have a strength value of 100?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, `T3`, and `T4` instead of direct table references. Do join multiple tables with `INNER JOIN` on `T1.id = T2.hero_id`, `T2.attribute_id = T3.id`, and `T1.gender_id = T4.id` instead of querying a single table. Do filter on `T3.attribute_name = 'Strength'` and `T2.attribute_value = 100` instead of direct column filtering. Do change the gender filter to `T4.gender = 'Female'` instead of `gender = 'male'`. Do count specific column `T1.id` instead of using `COUNT(*)`. The amended query now correctly joins normalized tables and filters attributes through proper relationships to match the intended behavior."
        ],
        "rules": [
            "1) When answering about female superheroes with strength value of 100: make sure the output order: count of superheroes. 2) When the question mentions \"female superheroes\": \"female\" actually means \"T4.gender = 'Female'\" in schema. 3) When the question mentions \"strength value of 100\": \"strength\" actually means \"T3.attribute_name = 'Strength'\" and \"value of 100\" means \"T2.attribute_value = 100\" in schema. 4) When combining T1, T2, T3, and T4 for shared entities: link rows where T1.id = T2.hero_id, T2.attribute_id = T3.id, and T1.gender_id = T4.id; keep only matching pairs (inner match). 5) When the question asks for \"count of superheroes\": compute the number of rows using the canonical key token T1.id. 6) When handling text literals: do not change case, spacing, or punctuation - use exact values 'Female' and 'Strength'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE gender = 'male' AND strength = 100;",
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nINNER JOIN gender T4 ON T1.gender_id = T4.id\nWHERE T3.attribute_name = 'Strength' \nAND T2.attribute_value = 100 \nAND T4.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nINNER JOIN gender T4 ON T1.gender_id = T4.id\nWHERE T4.gender = 'Female' \nAND T3.attribute_name = 'Strength' \nAND T2.attribute_value = 100"
        ],
        "amend_res": 1
    },
    "1073": {
        "db_id": "european_football_2",
        "question": "How many matches were held in the league Germany 1. Bundesliga\nfrom August to October 2008?",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Germany 1. Bundesliga' AND SUBSTR(t2.`date`, 1, 7) BETWEEN '2008-08' AND '2008-10'",
        "amends": [
            "Do join `League AS t1` with `Match AS t2` on `t1.id = t2.league_id` instead of querying only the `matches` table without proper joins. Do filter on `t1.name = 'Germany 1. Bundesliga'` instead of directly filtering on `league` column. Do use `SUBSTR(t2.date, 1, 7)` to extract year-month for date range comparison instead of full date `BETWEEN '2008-08-01' AND '2008-10-31'`. Do count `t2.id` specifically instead of using `COUNT(*)` for more precise counting. The amended query now correctly handles the schema relationships and date filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about matches in a specific league: join League AS t1 with Match AS t2 on t1.id = t2.league_id to properly relate league information to matches. 2) When the question mentions \"Germany 1. Bundesliga\": filter on t1.name = 'Germany 1. Bundesliga' instead of directly filtering on a league column in the matches table. 3) When filtering for dates from August to October 2008: use SUBSTR(t2.date, 1, 7) to extract year-month for date range comparison instead of full date BETWEEN conditions. 4) When counting matches: count t2.id specifically instead of using COUNT(*) for more precise counting of match entities."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE league = 'Germany 1. Bundesliga' AND date BETWEEN '2008-08-01' AND '2008-10-31';",
            "SELECT COUNT(t2.id) \nFROM League AS t1 \nJOIN Match AS t2 ON t1.id = t2.league_id \nWHERE t1.name = 'Germany 1. Bundesliga' \nAND SUBSTR(t2.date, 1, 7) BETWEEN '2008-08' AND '2008-10'"
        ],
        "rule_sql": [
            "SELECT COUNT(t2.id) \nFROM League AS t1 \nJOIN Match AS t2 ON t1.id = t2.league_id \nWHERE t1.name = 'Germany 1. Bundesliga' \nAND SUBSTR(t2.date, 1, 7) BETWEEN '2008-08' AND '2008-10'"
        ],
        "amend_res": 1
    },
    "466": {
        "db_id": "card_games",
        "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
        "amends": [
            "Do join `cards AS T1` with `set_translations AS T2` on `T2.setCode = T1.setCode` instead of querying only the `cards` table without any joins. Do filter on `T2.translation = 'Hauptset Zehnte Edition'` instead of directly filtering `set_name` in the cards table. Do filter on `T1.artist = 'Adam Rex'` instead of filtering on `designer` which appears to be the wrong column name. Do count `T1.id` instead of using `COUNT(*)` to ensure accurate counting of specific records. The amended query now correctly joins the translation table to resolve set names and uses the proper artist column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about cards in a specific set: join cards AS T1 with set_translations AS T2 on T2.setCode = T1.setCode to resolve set names. 2) When filtering for set name \"Hauptset Zehnte Edition\": use T2.translation = 'Hauptset Zehnte Edition' instead of directly filtering set_name in the cards table. 3) When filtering for cards designed by Adam Rex: use T1.artist = 'Adam Rex' instead of designer column. 4) When counting cards: count T1.id instead of using COUNT(*) to ensure accurate counting of specific records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE set_name = 'Hauptset Zehnte Edition' AND designer = 'Adam Rex';",
            "SELECT COUNT(T1.id) \nFROM cards AS T1 \nJOIN set_translations AS T2 ON T2.setCode = T1.setCode \nWHERE T2.translation = 'Hauptset Zehnte Edition' \nAND T1.artist = 'Adam Rex'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards AS T1\nJOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T2.translation = 'Hauptset Zehnte Edition'\nAND T1.artist = 'Adam Rex'"
        ],
        "amend_res": 1
    },
    "102": {
        "db_id": "financial",
        "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
        "amends": [
            "Do select `DISTINCT T2.account_id` instead of `*` from all columns. Do use `trans AS T1 INNER JOIN account AS T2` instead of querying only `accounts` table. Do join on `T1.account_id = T2.account_id` instead of no join condition. Do filter by `STRFTIME('%Y', T2.date) < '1997'` instead of `opening_date < '1997-01-01'`. Do filter `T1.amount > 3000` instead of `amount > 3000` from the accounts table. The amended query now correctly joins transaction and account tables, filters by year extracted from date, and ensures distinct account IDs matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about accounts with opening date before 1997 and money greater than 3000USD: use DISTINCT T2.account_id instead of selecting all columns. 2) When combining transaction and account tables: use trans AS T1 INNER JOIN account AS T2 with join condition T1.account_id = T2.account_id instead of querying only accounts table. 3) When filtering by opening date before 1997: use STRFTIME('%Y', T2.date) < '1997' instead of opening_date < '1997-01-01'. 4) When filtering by amount greater than 3000: use T1.amount > 3000 instead of amount > 3000 from the accounts table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE opening_date < '1997-01-01' AND amount > 3000;",
            "SELECT DISTINCT T2.account_id\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T2.date) < '1997'\nAND T1.amount > 3000"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.account_id\nFROM trans AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T2.date) < '1997'\nAND T1.amount > 3000"
        ],
        "amend_res": 1
    },
    "658": {
        "db_id": "codebase_community",
        "question": "What are the titles of the top 5 posts with the highest popularity?",
        "ground_truth": "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5",
        "amends": [
            "Do select `Title` instead of `title` to match the correct column name. Do order by `ViewCount DESC` instead of `popularity ASC` to use the proper sorting column and direction. The amended query now correctly retrieves the top 5 posts by view count in descending order."
        ],
        "rules": [
            "1) When the question asks for \"titles\": use the exact column name \"Title\" from the posts table. 2) When the question mentions \"top 5\" and \"highest popularity\": rank rows by \"ViewCount\" in descending order and keep the first 5 rows. 3) When producing output: make sure the output order includes only \"Title\" column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts ORDER BY popularity ASC LIMIT 5;",
            "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5"
        ],
        "amend_res": 1
    },
    "1065": {
        "db_id": "european_football_2",
        "question": "Please list all team names which the speed class is fast.",
        "ground_truth": "SELECT DISTINCT t1.team_long_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlaySpeedClass = 'Fast'",
        "amends": [
            "Do use `DISTINCT t1.team_long_name` instead of `team_name` without distinct. Do add `INNER JOIN Team_Attributes AS t2` instead of querying only the teams table. Do use join condition `t1.team_api_id = t2.team_api_id` instead of no join. Do change filter to `t2.buildUpPlaySpeedClass = 'Fast'` instead of `speed_class = 'slow'`. The amended query now correctly joins the Team and Team_Attributes tables to filter by build-up play speed class rather than using a non-existent speed_class column."
        ],
        "rules": [
            "1) When answering about team names with fast speed class: make sure the output order: t1.team_long_name. 2) When the question mentions \"team names\": \"team names\" actually means \"t1.team_long_name in schema\". 3) When the question mentions \"speed class is fast\": \"speed class\" actually means \"t2.buildUpPlaySpeedClass in schema\" and \"fast\" means the literal value 'Fast'. 4) When combining teams table (T1) and Team_Attributes table (T2): link rows where t1.team_api_id = t2.team_api_id exactly as shown; keep only matching pairs (inner match). 5) When selecting team names: use DISTINCT t1.team_long_name to ensure unique team names are returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM teams WHERE speed_class = 'slow';",
            "SELECT DISTINCT t1.team_long_name \nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlaySpeedClass = 'Fast'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.team_long_name\nFROM Team t1\nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlaySpeedClass = 'Fast'\nORDER BY t1.team_long_name;"
        ],
        "amend_res": 1
    },
    "461": {
        "db_id": "card_games",
        "question": "Please list the names of the top 3 cards with the highest converted mana cost and have a 2003 card frame style.",
        "ground_truth": "SELECT name FROM cards WHERE frameVersion = 2003 ORDER BY convertedManaCost DESC LIMIT 3",
        "amends": [
            "Do filter on `frameVersion = 2003` instead of `frame = '2003'` to use the correct numeric column and remove the unnecessary string literal conversion. The amended query now matches RIGHT_SQL's behavior by properly filtering on the numeric frameVersion column rather than the string-based frame column with incorrect value type."
        ],
        "rules": [
            "1) When the question mentions \"2003 card frame style\": use the exact column \"frameVersion\" with numeric value 2003 instead of the string column \"frame\" with literal '2003'. 2) When filtering for frame version: use the exact numeric value 2003 without quotes or string conversion. 3) When answering about \"top 3 cards with highest converted mana cost\": rank cards by \"convertedManaCost\" in descending order and keep the first 3 rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE frame = '2003' ORDER BY convertedManaCost DESC LIMIT 3;",
            "SELECT name \nFROM cards \nWHERE frameVersion = 2003 \nORDER BY convertedManaCost DESC \nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT name FROM cards WHERE frameVersion = 2003 ORDER BY convertedManaCost DESC LIMIT 3;"
        ],
        "amend_res": 1
    },
    "99": {
        "db_id": "financial",
        "question": "Among the accounts who have loan validity more than 12 months, list out the accounts that have the highest approved amount and have account opening date in 1993.",
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) = '1993' AND T1.duration > 12 ORDER BY T1.amount DESC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of all columns with `*`. Do join `loan` and `account` tables with `INNER JOIN` on `account_id` instead of querying only `accounts`. Do filter by `duration > 12` instead of `loan_validity > 12`. Do use `STRFTIME('%Y', date)` on the account table instead of `strftime('%Y', opening_date)`. Do remove the incorrect aggregate condition `approved_amount = MAX(approved_amount)` and instead add `ORDER BY amount DESC LIMIT 1` to get the maximum amount record. The amended query now correctly retrieves the account with the highest loan amount from 1993 with duration over 12 months."
        ],
        "rules": [
            "1) When answering about accounts with loan validity more than 12 months: use the \"loan\" table and filter where \"duration\" > 12 instead of \"loan_validity\" > 12. 2) When combining loan and account information: join \"loan\" and \"account\" tables using INNER JOIN on \"account_id\" to get matching records. 3) When filtering by account opening date in 1993: use STRFTIME('%Y', date) on the account table to extract the year and compare with '1993'. 4) When finding the highest approved amount: order results by \"amount\" in descending order and take only the top 1 record using LIMIT 1. 5) When selecting output columns: return only \"account_id\" instead of all columns with *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE loan_validity > 12 AND approved_amount = MAX(approved_amount) AND strftime('%Y', opening_date) = '1993';",
            "SELECT account.account_id\nFROM account\nINNER JOIN loan ON account.account_id = loan.account_id\nWHERE loan.duration > 12\nAND STRFTIME('%Y', account.date) = '1993'\nORDER BY loan.amount DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT account.account_id\nFROM account\nINNER JOIN loan ON account.account_id = loan.account_id\nWHERE loan.duration > 12\nAND STRFTIME('%Y', account.date) = '1993'\nORDER BY loan.amount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "261": {
        "db_id": "toxicology",
        "question": "Write down bond id for molecules that are carcinogenic.",
        "ground_truth": "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do select `DISTINCT T1.bond_id` instead of `molecule_id` without distinct. Do join `bond AS T1 INNER JOIN molecule AS T2` instead of querying only `molecules` table. Do use join condition `T1.molecule_id = T2.molecule_id` instead of no join. Do filter with `T2.label = '+'` instead of `carcinogenic = 'yes'`. The amended query now correctly retrieves distinct bond IDs from joined tables with the proper label filter instead of carcinogenic status."
        ],
        "rules": [
            "1) When answering about \"bond id for molecules that are carcinogenic\": make sure the output order: T1.bond_id. 2) When the question mentions \"molecules that are carcinogenic\": \"carcinogenic\" actually means \"T2.label = '+'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match). 4) When producing output: do select DISTINCT T1.bond_id instead of molecule_id without distinct."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM molecules WHERE carcinogenic = 'yes';",
            "SELECT DISTINCT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.bond_id\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'"
        ],
        "amend_res": 1
    },
    "639": {
        "db_id": "codebase_community",
        "question": "Based on posts posted by Community, calculate the percentage of posts that use the R language.",
        "ground_truth": "SELECT CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId WHERE T1.DisplayName = 'Community'",
        "amends": [
            "Do use `SUM(IIF(T3.TagName = 'r', 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN language = 'R' THEN 1 END)` for percentage calculation. Do change the data source from `posts` to joining `users AS T1`, `postHistory AS T2`, and `tags AS T3` instead of a single table. Do add `INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId` and `INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId` instead of no joins. Do change the filter condition to `T1.DisplayName = 'Community'` instead of `author = 'Community'`. Do remove the `WHERE` clause placement and incorporate the filter into the join structure instead of a standalone filter. The amended query now correctly calculates the percentage of posts tagged with 'r' for the Community user by properly joining through the post history and tags relationships."
        ],
        "rules": [
            "1) When answering about posts by Community: use T1.DisplayName = 'Community' to identify the Community user instead of author = 'Community'. 2) When calculating percentage of posts using R language: use SUM(IIF(T3.TagName = 'r', 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN language = 'R' THEN 1 END). 3) When combining data from multiple tables: join users AS T1, postHistory AS T2, and tags AS T3 using INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId and INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId instead of using a single posts table. 4) When filtering for specific user: incorporate the filter T1.DisplayName = 'Community' into the join structure instead of using a standalone WHERE clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN language = 'R' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_r_posts\nFROM posts\nWHERE author = 'Community';",
            "SELECT \n    (CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    users AS T1\nINNER JOIN \n    postHistory AS T2 ON T1.Id = T2.UserId\nINNER JOIN \n    tags AS T3 ON T3.ExcerptPostId = T2.PostId\nWHERE \n    T1.DisplayName = 'Community';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(IIF(T3.TagName = 'r', 1, 0)) AS REAL) / COUNT(*)) * 100.0 AS percentage_r_posts\nFROM \n    users AS T1\nINNER JOIN \n    postHistory AS T2 ON T1.Id = T2.UserId AND T1.DisplayName = 'Community'\nINNER JOIN \n    tags AS T3 ON T3.ExcerptPostId = T2.PostId;"
        ],
        "amend_res": 1
    },
    "875": {
        "db_id": "formula_1",
        "question": "Show me the season page of year when the race No. 901 took place.",
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "amends": [
            "Do select `T2.url` instead of `season`. Do join `seasons AS T2` with `races AS T1` using `INNER JOIN` on `T2.year = T1.year` instead of querying only the `races` table. Do filter on `T1.raceId = 901` instead of `race_id = 901`. The amended query now correctly retrieves the URL from the seasons table by joining on year rather than attempting to select a season column that may not exist, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"season page of year\": select \"T2.url\" instead of \"season\" from the seasons table. 2) When combining races and seasons tables: link rows where \"T2.year = T1.year\" using an inner match. 3) When filtering for race No. 901: use \"T1.raceId = 901\" as the exact filter condition. 4) When answering about the season page: make sure the output order contains only \"T2.url\" as the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT season FROM races WHERE race_id = 901;",
            "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901"
        ],
        "rule_sql": [
            "SELECT T2.url FROM races T1 INNER JOIN seasons T2 ON T2.year = T1.year WHERE T1.raceId = 901"
        ],
        "amend_res": 1
    },
    "752": {
        "db_id": "superhero",
        "question": "Give the name of the alien superheroes.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and change the source to `superhero AS T1` instead of `superheroes`. Do add an `INNER JOIN` on `race AS T2` with predicate `T1.race_id = T2.id` instead of omitting the join entirely. Do filter on `T2.race = 'Alien'` instead of `species = 'Human'` to correctly query by race rather than species. The amended query now matches RIGHT_SQL's behavior by properly joining tables and filtering on the race attribute."
        ],
        "rules": [
            "1) When answering about \"alien superheroes\": make sure the output order: T1.superhero_name. 2) When the question mentions \"alien superheroes\": \"alien\" actually means \"T2.race = 'Alien'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.race_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation for 'Alien'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE species = 'Human';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Alien'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN race T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Alien'\nORDER BY T1.superhero_name"
        ],
        "amend_res": 1
    },
    "351": {
        "db_id": "card_games",
        "question": "Name all the cards which have alternative language in Japanese.",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
        "amends": [
            "Do select `T1.name` from the `cards` table instead of `card_name` from a single table. Do join `foreign_data` as `T2` with an `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying a single table without joins. Do filter on `T2.language = 'Japanese'` in the `WHERE` clause instead of checking `language = 'Japanese'` and `alternative_language IS NOT NULL` on the same table. The amended query correctly joins the cards with their foreign data to find Japanese language entries instead of relying on potentially incorrect column assumptions in a single table structure."
        ],
        "rules": [
            "1) When answering about \"cards with alternative language in Japanese\": select T1.name from the cards table as T1. 2) When combining cards and foreign_data tables: link rows where T1.uuid = T2.uuid using an inner join. 3) When filtering for Japanese language: check T2.language = 'Japanese' exactly as written. 4) When producing output: return only the card names in the order specified by the query."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_name FROM cards WHERE language = 'Japanese' AND alternative_language IS NOT NULL;",
            "SELECT T1.name FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'"
        ],
        "amend_res": 1
    },
    "611": {
        "db_id": "codebase_community",
        "question": "Mention the reputation of users who had obtained the badge on 7/19/2010 7:39:08 PM.",
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "amends": [
            "Do add `INNER JOIN badges AS T2 ON T1.Id = T2.UserId` instead of querying only the `users` table. Do reference `T2.Date` instead of `badge_date` in the WHERE clause, using the standardized timestamp format `'2010-07-19 19:39:08.0'` instead of the ambiguous `'7/19/2010 7:39:08 PM'`. Do use the table alias `T1.Reputation` instead of directly referencing `reputation`. The amended query now correctly joins the users and badges tables to filter based on badge creation dates rather than attempting to use a non-existent `badge_date` column in the users table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about users who obtained badges on a specific date: combine the users table (T1) and badges table (T2) by linking rows where T1.Id equals T2.UserId, keeping only matching pairs. 2) When the question mentions a specific timestamp like '7/19/2010 7:39:08 PM': convert it to the standardized format '2010-07-19 19:39:08.0' for comparison with T2.Date. 3) When selecting reputation information: use T1.Reputation as the output column. 4) When filtering by badge creation date: apply the condition to T2.Date using the converted timestamp format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT reputation FROM users WHERE badge_date = '7/19/2010 7:39:08 PM'",
            "SELECT T1.Reputation\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08.0'"
        ],
        "rule_sql": [
            "SELECT u.Reputation\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nWHERE b.Date = '2010-07-19 19:39:08.0'"
        ],
        "amend_res": 1
    },
    "1185": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "amends": [
            "Do use `SUM` aggregates with conditional logic instead of subquery joins to handle multiple records. Do join `Patient` and `Laboratory` tables with `INNER JOIN` on `T1.ID = T2.ID` instead of using correlated subqueries. Do filter with `WHERE T1.Birthday = '1959-02-18'` instead of nested subqueries for patient lookup. Do calculate the decrease rate using `(November_sum - December_sum) / December_sum` instead of `(nov - dec) / nov` to properly measure percentage decrease from baseline. Do cast the result to `REAL` instead of implicit casting. Do reference columns as `T2.`T-CHO`` and `T2.Date` instead of `total_cholesterol` and `test_date` to match the actual schema. The amended query now correctly handles multiple laboratory records and calculates the percentage decrease from December values as the baseline.",
            "Do use `LIKE '1981-11-%'` and `LIKE '1981-12-%'` for date filtering instead of `strftime('%m', T2.Date) = '11'` and `strftime('%Y', T2.Date) = '1981'` to simplify the date pattern matching. Do remove the redundant `strftime` function calls and instead use direct string pattern matching with the `LIKE` operator. Do maintain the same calculation logic for the decrease rate but with more efficient date filtering. The amended query now correctly matches the behavior of the RIGHT_SQL by using simpler and more direct date comparison methods.",
            "Do place the entire division operation outside the CAST function instead of casting only the numerator, ensuring proper real number division. Do remove the redundant WHERE filter for date patterns since the CASE statements already handle the date filtering logic, instead of keeping the unnecessary OR condition that could potentially include unwanted rows in the aggregation."
        ],
        "rules": [
            "1) When answering about a patient born on a specific date: filter patients using T1.Birthday = '1959-02-18' with exact date format. 2) When combining Patient and Laboratory tables: link rows using T1.ID = T2.ID with inner join to keep only matching pairs. 3) When calculating cholesterol decrease rate from November to December 1981: compute (SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.\"T-CHO\" ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END)) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END) to measure percentage decrease from December baseline. 4) When handling multiple laboratory records: use SUM aggregates with conditional logic instead of subquery joins. 5) When referencing cholesterol values: use the exact column name T2.\"T-CHO\" instead of total_cholesterol. 6) When referencing date values: use the exact column name T2.Date instead of test_date. 7) When outputting the result: cast the decrease rate to REAL data type.",
            "1) When filtering for dates in November 1981: use T2.Date LIKE '1981-11-%' instead of strftime functions. 2) When filtering for dates in December 1981: use T2.Date LIKE '1981-12-%' instead of strftime functions. 3) When calculating decrease rate between November and December 1981: maintain the formula (November_total - December_total) / December_total using T2.\"T-CHO\" values. 4) When joining Patient and Laboratory tables: use T1.ID = T2.ID as the join condition. 5) When filtering for a specific patient: use T1.Birthday = '1959-02-18' to find the patient born on 1959/2/18.",
            "1) When calculating a decrease rate between two time periods: compute the difference between the earlier period value and later period value, then divide by the later period value to get the rate of decrease. 2) When handling date filtering for specific months: use exact date patterns like '1981-11-%' for November 1981 and '1981-12-%' for December 1981 to isolate measurements from those specific months. 3) When performing division operations that should yield real numbers: ensure the entire division operation is treated as real number division rather than casting only parts of the calculation. 4) When filtering data by date ranges: avoid redundant WHERE clause filters when CASE statements already handle the specific date filtering needed for aggregation, to prevent including unwanted rows in calculations."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (nov.total_cholesterol - dec.total_cholesterol) / nov.total_cholesterol * 100 AS decrease_rate\nFROM \n    (SELECT total_cholesterol FROM lab_results WHERE patient_id = (SELECT patient_id FROM patients WHERE birth_date = '1959/2/18') AND test_date LIKE '1981-11-%') nov,\n    (SELECT total_cholesterol FROM lab_results WHERE patient_id = (SELECT patient_id FROM patients WHERE birth_date = '1959/2/18') AND test_date LIKE '1981-12-%') dec;",
            "SELECT \n    CAST((SUM(CASE WHEN strftime('%m', T2.Date) = '11' AND strftime('%Y', T2.Date) = '1981' THEN T2.`T-CHO` ELSE 0 END) - \n          SUM(CASE WHEN strftime('%m', T2.Date) = '12' AND strftime('%Y', T2.Date) = '1981' THEN T2.`T-CHO` ELSE 0 END)) / \n          SUM(CASE WHEN strftime('%m', T2.Date) = '12' AND strftime('%Y', T2.Date) = '1981' THEN T2.`T-CHO` ELSE 0 END) AS REAL) AS decrease_rate\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.Birthday = '1959-02-18';",
            "SELECT \n    CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - \n          SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) / \n         SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) AS REAL) AS decrease_rate\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.Birthday = '1959-02-18'\n    AND (T2.Date LIKE '1981-11-%' OR T2.Date LIKE '1981-12-%')",
            "SELECT \n    (SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - \n     SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) / \n    CAST(SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END) AS REAL) AS decrease_rate\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.Birthday = '1959-02-18'"
        ],
        "rule_sql": [
            "SELECT \n    CAST((\n        SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.\"T-CHO\" ELSE 0 END) - \n        SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END)\n    ) / \n    SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END) AS REAL) AS decrease_rate\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.Birthday = '1959-02-18'"
        ],
        "amend_res": 1
    },
    "1053": {
        "db_id": "european_football_2",
        "question": "List the football teams that has a chance creation passing class of Risky. Inidcate its short name only.",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Risky'",
        "amends": [
            "Do use `DISTINCT t1.team_short_name` instead of `team_name` to select the correct column with uniqueness. Do join `Team AS t1 INNER JOIN Team_attributes AS t2 ON t1.team_api_id = t2.team_api_id` instead of querying a single table `football_teams` to properly relate team attributes. Do filter on `t2.chanceCreationPassingClass = 'Risky'` instead of `chance_creation_passing = 'Risky'` to use the correct column name from the joined table. The amended query now correctly retrieves distinct team short names by joining the appropriate tables and using the proper column reference for chance creation passing classification."
        ],
        "rules": [
            "1) When answering about football teams with chance creation passing class: join Team as T1 and Team_attributes as T2 where T1.team_api_id = T2.team_api_id to properly relate team attributes. 2) When filtering for chance creation passing class of Risky: use T2.chanceCreationPassingClass = 'Risky' with exact case and spacing. 3) When selecting team short names: use DISTINCT T1.team_short_name instead of team_name to get unique short names only. 4) When the question asks for \"short name only\": output only the team_short_name column without other columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name FROM football_teams WHERE chance_creation_passing = 'Risky';",
            "SELECT DISTINCT t1.team_short_name\nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.chanceCreationPassingClass = 'Risky'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.team_short_name\nFROM Team AS T1\nJOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id\nWHERE T2.chanceCreationPassingClass = 'Risky';"
        ],
        "amend_res": 1
    },
    "1102": {
        "db_id": "european_football_2",
        "question": "For the players who had a 77 points overall rating on 2016/6/23, who was the oldest? Give the name of the player.",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-06-23' AND t2.overall_rating = 77 ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [
            "Do select `t1.player_name` instead of `name` and change the source to use `Player AS t1` instead of `players`. Do add `INNER JOIN Player_Attributes AS t2` instead of querying a single table. Do use join condition `t1.player_api_id = t2.player_api_id` instead of no join. Do change the date filter to use `SUBSTR(t2.date, 1, 10) = '2016-06-23'` instead of `date = '2016/6/23'` and move it to the joined table. Do keep `overall_rating = 77` but reference it as `t2.overall_rating` instead of the base table. Do change the ordering to `t1.birthday ASC` instead of `age ASC` while maintaining the `LIMIT 1`. The amended query now correctly joins the Player and Player_Attributes tables to find players with the specified rating on the exact date and orders by birthday instead of age."
        ],
        "rules": [
            "1) When the question asks about players with a specific overall rating on a specific date: use an inner join between Player AS t1 and Player_Attributes AS t2 where t1.player_api_id = t2.player_api_id. 2) When filtering by date '2016/6/23': use SUBSTR(t2.date, 1, 10) = '2016-06-23' to match the exact date format. 3) When filtering by overall rating 77: use t2.overall_rating = 77. 4) When finding the oldest player: order by t1.birthday ASC and take the first result. 5) When selecting the player name: output t1.player_name instead of name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE overall_rating = 77 AND date = '2016/6/23' ORDER BY age ASC LIMIT 1;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating = 77\nAND SUBSTR(t2.date, 1, 10) = '2016-06-23'\nORDER BY t1.birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE SUBSTR(t2.date, 1, 10) = '2016-06-23'\nAND t2.overall_rating = 77\nORDER BY t1.birthday ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "97": {
        "db_id": "financial",
        "question": "List out the id number of client who choose statement of issuance after transaction are Disponent?",
        "ground_truth": "SELECT T2.client_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.type = 'DISPONENT'",
        "amends": [
            "Do select `T2.client_id` from the `disp` table instead of `client_id` from the `transactions` table. Do join `account AS T1` with `disp AS T2` using an `INNER JOIN` on `T1.account_id = T2.account_id` instead of querying only the `transactions` table. Do add filters for `T1.frequency = 'POPLATEK PO OBRATU'` and `T2.type = 'DISPONENT'` instead of filtering on `issuance_statement = 'Disponent'`. The amended query now correctly retrieves client IDs from the disp table joined with account data using proper relationship conditions and filters."
        ],
        "rules": [
            "1) When answering about \"client who choose statement of issuance after transaction are Disponent\": make sure the output order: T2.client_id. 2) When the question mentions \"client who choose statement of issuance after transaction are Disponent\": this actually means clients with disp type 'DISPONENT' and account frequency 'POPLATEK PO OBRATU' in the schema. 3) When combining T1 (account) and T2 (disp) for shared entities: link rows where T1.account_id = T2.account_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for the specific condition: apply both filters T1.frequency = 'POPLATEK PO OBRATU' and T2.type = 'DISPONENT' instead of the incorrect issuance_statement filter."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id FROM transactions WHERE issuance_statement = 'Disponent'",
            "SELECT T2.client_id\nFROM account AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nWHERE T1.frequency = 'POPLATEK PO OBRATU'\nAND T2.type = 'DISPONENT'"
        ],
        "rule_sql": [
            "SELECT T2.client_id\nFROM account T1\nINNER JOIN disp T2 ON T1.account_id = T2.account_id\nWHERE T1.frequency = 'POPLATEK PO OBRATU'\nAND T2.type = 'DISPONENT'"
        ],
        "amend_res": 1
    },
    "512": {
        "db_id": "card_games",
        "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
        "ground_truth": "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
        "amends": [
            "Do use `SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific power values. Do filter on `hasFoil = 0` instead of `foil = 0` for the correct column name. Do filter on `duelDeck = 'a'` instead of `duel_deck = 'A'` for the correct column name and case sensitivity. Do remove the `AND power IS NULL` filter from the WHERE clause instead of keeping it, as the null check is now handled within the CASE expression. The amended query now correctly counts cards with null or asterisk power values while filtering on the proper foil status and duel deck columns with appropriate case sensitivity."
        ],
        "rules": [
            "1) When counting cards with unknown power: use SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) instead of COUNT(*) to count only specific power values. 2) When filtering for cards that can't be found in foil: filter on hasFoil = 0 instead of foil = 0 for the correct column name. 3) When filtering for duel deck A: filter on duelDeck = 'a' instead of duel_deck = 'A' for the correct column name and case sensitivity. 4) When handling null power values: remove the explicit power IS NULL filter from the WHERE clause since the null check is handled within the CASE expression."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE power IS NULL AND foil = 0 AND duel_deck = 'A';",
            "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) \nFROM cards \nWHERE hasFoil = 0 \nAND duelDeck = 'a'"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) \nFROM cards \nWHERE hasFoil = 0 \nAND duelDeck = 'a'"
        ],
        "amend_res": 1
    },
    "907": {
        "db_id": "formula_1",
        "question": "List all races in 2017 and the hosting country order by date of the event.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.name, T1.country FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2017 ORDER BY T2.date ASC",
        "amends": [
            "Do select `T2.name` and `T1.country` instead of `race_name` and `country`. Do add `DISTINCT` instead of omitting it. Do join `circuits AS T1` with `races AS T2` using `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do filter on `T2.year = 2017` instead of `year = 2017`. Do order by `T2.date ASC` instead of `event_date DESC`. The amended query now correctly retrieves distinct circuit names with their countries for the 2017 races, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"races in 2017 and hosting country\": make sure the output order: T2.name, T1.country 2) When the question mentions \"races\": \"races\" actually means \"T2.name in schema\" 3) When the question mentions \"hosting country\": \"hosting country\" actually means \"T1.country in schema\" 4) When combining circuits as T1 and races as T2: link rows where T2.circuitID = T1.circuitId exactly as shown; keep only matching pairs (inner match) 5) When filtering for year 2017: use T2.year = 2017 instead of year = 2017 6) When ordering by date of the event: use T2.date ASC instead of event_date DESC 7) When retrieving distinct values: use DISTINCT to get unique circuit names with their countries"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, country FROM races WHERE year = 2017 ORDER BY event_date DESC;",
            "SELECT DISTINCT T2.name, T1.country FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T2.year = 2017 ORDER BY T2.date ASC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name AS race_name, T1.country AS hosting_country, T2.date \nFROM circuits AS T1 \nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId \nWHERE T2.year = 2017 \nORDER BY T2.date ASC;",
            "SELECT DISTINCT T2.name, T1.country \nFROM circuits T1 \nINNER JOIN races T2 ON T2.circuitId = T1.circuitId \nWHERE T2.year = 2017 \nORDER BY T2.date ASC"
        ],
        "amend_res": 1
    },
    "572": {
        "db_id": "codebase_community",
        "question": "How many views did the post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' get?",
        "ground_truth": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'",
        "amends": [
            "Do select `ViewCount` instead of `COUNT(*)` to retrieve the actual column value rather than counting rows. Do reference column `Title` instead of `title` to match the correct case-sensitive column name. The amended query now correctly returns the ViewCount value for the specific post title instead of counting occurrences."
        ],
        "rules": [
            "1) When the question asks for \"how many views\" a post got: retrieve the exact value from the \"ViewCount\" column instead of counting rows. 2) When the question specifies a post title: match the exact title text 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' using the \"Title\" column with exact case sensitivity. 3) When selecting output columns: return only the \"ViewCount\" value for the matching post."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';",
            "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';"
        ],
        "rule_sql": [
            "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';"
        ],
        "amend_res": 1
    },
    "1395": {
        "db_id": "student_club",
        "question": "How many members did attend the event 'Community Theater' in 2019?",
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Community Theater' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "amends": [
            "Do add tables `event AS T1` and `attendance AS T2` with an `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only the `events` table. Do change the count expression to `COUNT(T2.link_to_member)` instead of `COUNT(*)` to count specific attendance records. Do replace the direct `year = 2019` filter with `SUBSTR(T1.event_date, 1, 4) = '2019'` to extract the year from the event date string instead of relying on a separate year column. The amended query now correctly counts member attendance for the specified event by joining the relevant tables and properly handling the date-based filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about member attendance for a specific event: make sure the output order: COUNT(T2.link_to_member). 2) When the question mentions \"attend the event\": use tables \"event AS T1\" and \"attendance AS T2\" with an INNER JOIN on T1.event_id = T2.link_to_event. 3) When the question asks for \"count of members\": compute the number of rows using the canonical key token T2.link_to_member. 4) When the question specifies event name \"Community Theater\": filter using T1.event_name = 'Community Theater' exactly. 5) When the question specifies year 2019: extract year from T1.event_date using SUBSTR(T1.event_date, 1, 4) = '2019' instead of a separate year column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE event_name = 'Community Theater' AND year = 2019;",
            "SELECT COUNT(T2.link_to_member) \nFROM event AS T1 \nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'Community Theater' \nAND SUBSTR(T1.event_date, 1, 4) = '2019'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.link_to_member) \nFROM event AS T1 \nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'Community Theater' \nAND SUBSTR(T1.event_date, 1, 4) = '2019'"
        ],
        "amend_res": 1
    },
    "504": {
        "db_id": "card_games",
        "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do filter by `setCode IN` subquery instead of direct `set_name` comparison to properly reference the sets table relationship. Do use `convertedManaCost = 3` instead of `mana_cost = '3'` to compare numeric values rather than string literals. Do reference the numeric column `convertedManaCost` instead of the string column `mana_cost` for proper cost comparison. The amended query now correctly counts cards from the specified set with the proper mana cost value."
        ],
        "rules": [
            "1) When counting cards: count using the \"id\" column instead of counting all columns to avoid counting null values. 2) When filtering by set name 'World Championship Decks 2004': use a subquery with \"setCode IN\" to properly reference the sets table relationship instead of direct \"set_name\" comparison. 3) When filtering by converted mana cost of 3: use \"convertedManaCost = 3\" to compare numeric values instead of \"mana_cost = '3'\" which compares string literals. 4) When comparing mana costs: reference the numeric column \"convertedManaCost\" instead of the string column \"mana_cost\" for proper cost comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE set_name = 'World Championship Decks 2004' AND mana_cost = '3';",
            "SELECT COUNT(id) FROM cards WHERE setCode IN (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') AND convertedManaCost = 3;"
        ],
        "rule_sql": [
            "SELECT COUNT(id) \nFROM cards \nWHERE setCode IN (SELECT code FROM sets WHERE name = 'World Championship Decks 2004') \nAND convertedManaCost = 3;"
        ],
        "amend_res": 1
    },
    "25": {
        "db_id": "california_schools",
        "question": "Name schools in Riverside which the average of average math score for SAT is grater than 400, what is the funding type of these schools?",
        "ground_truth": "SELECT T1.sname, T2.`Charter Funding Type` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE T2.`District Name` LIKE 'Riverside%' GROUP BY T1.sname, T2.`Charter Funding Type` HAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400",
        "amends": [
            "Do select `T1.sname` and `T2.Charter Funding Type` instead of just `funding_type`. Do join `satscores AS T1` with `frpm AS T2` using `INNER JOIN` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do filter with `T2.District Name LIKE 'Riverside%'` instead of `city = 'Riverside'`. Do add `GROUP BY T1.sname, T2.Charter Funding Type` instead of omitting grouping. Do move the aggregate condition to `HAVING` with `CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400` instead of using `AVG(math_score) > 400` in the `WHERE` clause. The amended query now correctly calculates the average math score per school and funding type for Riverside districts."
        ],
        "rules": [
            "1) When answering about schools in Riverside: use \"T2.District Name LIKE 'Riverside%'\" instead of \"city = 'Riverside'\" for filtering. 2) When combining SAT scores and funding data: link rows where \"T1.cds = T2.CDSCode\" using an inner join. 3) When calculating average math scores: compute \"CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds)\" instead of using AVG(math_score). 4) When the question asks for school names and funding types: select both \"T1.sname\" and \"T2.Charter Funding Type\" in the output. 5) When grouping by school and funding type: use \"GROUP BY T1.sname, T2.Charter Funding Type\" to organize results. 6) When filtering on aggregate results: place the condition \"CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400\" in the HAVING clause instead of WHERE."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT funding_type FROM schools WHERE city = 'Riverside' AND AVG(math_score) > 400;",
            "SELECT T1.sname, T2.\"Charter Funding Type\"\nFROM satscores AS T1\nINNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode\nWHERE T2.\"District Name\" LIKE 'Riverside%'\nGROUP BY T1.sname, T2.\"Charter Funding Type\"\nHAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400"
        ],
        "rule_sql": [
            "SELECT T1.sname, T2.\"Charter Funding Type\"\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nWHERE T2.\"District Name\" LIKE 'Riverside%'\nGROUP BY T1.sname, T2.\"Charter Funding Type\"\nHAVING CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400"
        ],
        "amend_res": 1
    },
    "640": {
        "db_id": "codebase_community",
        "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
        "ground_truth": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
        "amends": [
            "Do use a single query with `INNER JOIN` operations on `users`, `postHistory`, and `posts` tables instead of separate subqueries on just the `posts` table. Do reference `T1.DisplayName` for author identification instead of the non-existent `author` column. Do use conditional aggregation with `IIF` functions to calculate separate sums for 'Mornington' and 'Amos' instead of subtracting results from independent subqueries. Do join through the proper relationship chain with `T1.Id = T2.UserId` and `T3.Id = T2.PostId` instead of assuming direct author relationships in the posts table. The amended query now correctly calculates the view count difference between the two users by properly joining through the user-post relationship hierarchy.",
            "Do add `INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId` and change the join condition to `INNER JOIN posts AS T3 ON T3.Id = T2.PostId` instead of directly joining `posts T3 ON T1.Id = T3.OwnerUserId`. Do remove the `WHERE T1.DisplayName IN ('Mornington', 'Amos')` filter instead of keeping it, as the IIF conditions already handle the specific user filtering. Do change the alias from `view_count_difference` to `diff` instead of keeping the longer name. The amended query now correctly calculates the view count difference between Mornington and Amos by properly traversing the user-post relationship through postHistory rather than directly, ensuring accurate results."
        ],
        "rules": [
            "1) When answering about view count difference between posts by Mornington and Amos: use a single query with INNER JOIN operations on users, postHistory, and posts tables instead of separate subqueries. 2) When identifying authors: use T1.DisplayName for author identification instead of the non-existent author column. 3) When calculating separate sums for different authors: use conditional aggregation with IIF functions to calculate sums for 'Mornington' and 'Amos' instead of subtracting results from independent subqueries. 4) When joining tables through the user-post relationship hierarchy: use the proper relationship chain with T1.Id = T2.UserId and T3.Id = T2.PostId instead of assuming direct author relationships in the posts table.",
            "1) When calculating view count differences between specific users: traverse the user-post relationship through postHistory table using T1.Id = T2.UserId and T3.Id = T2.PostId instead of direct user-post joins. 2) When filtering for specific users 'Mornington' and 'Amos': use conditional aggregation with IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0) and IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0) instead of WHERE clause filtering. 3) When computing the difference between two aggregated values: subtract the sum for 'Amos' from the sum for 'Mornington' and alias the result as 'diff' exactly. 4) When joining tables in this schema: perform inner joins only and ensure proper key relationships between users (T1), postHistory (T2), and posts (T3) tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(view_count) FROM posts WHERE author = 'Mornington') - \n    (SELECT SUM(view_count) FROM posts WHERE author = 'Amos') AS view_count_difference;",
            "SELECT \n    SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - \n    SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS view_count_difference\nFROM \n    users T1\nINNER JOIN \n    posts T3 ON T1.Id = T3.OwnerUserId\nWHERE \n    T1.DisplayName IN ('Mornington', 'Amos')",
            "SELECT \n    SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - \n    SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff\nFROM users AS T1\nINNER JOIN postHistory AS T2 ON T1.Id = T2.UserId\nINNER JOIN posts AS T3 ON T3.Id = T2.PostId"
        ],
        "rule_sql": [
            "SELECT \n    SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff\nFROM \n    users T1\nINNER JOIN \n    postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN \n    posts T3 ON T3.Id = T2.PostId\nWHERE \n    T1.DisplayName IN ('Mornington', 'Amos')"
        ],
        "amend_res": 1
    },
    "154": {
        "db_id": "financial",
        "question": "How many male clients in 'Hl.m. Praha' district?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'",
        "amends": [
            "Do select `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific client identifiers rather than all rows. Do use table aliases `T1` and `T2` instead of no aliases for clarity and join operations. Do join `client AS T1` with `district AS T2` on `T1.district_id = T2.district_id` instead of querying only the `clients` table to properly relate district information. Do filter for `T1.gender = 'M'` instead of `gender = 'female'` to count male clients rather than female. Do filter on `T2.A2 = 'Hl.m. Praha'` instead of `district = 'Hl.m. Praha'` to use the district name column from the joined district table rather than a non-existent district column in the client table. The amended query now correctly counts male clients in the specified district by properly joining related tables and using the appropriate column references."
        ],
        "rules": [
            "1) When counting clients: use COUNT(T1.client_id) instead of COUNT(*) to count specific client identifiers. 2) When combining client and district information: join client AS T1 with district AS T2 on T1.district_id = T2.district_id to properly relate district information. 3) When filtering for male clients: use T1.gender = 'M' instead of filtering for female clients. 4) When filtering for district 'Hl.m. Praha': use T2.A2 = 'Hl.m. Praha' instead of a non-existent district column in the client table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE gender = 'female' AND district = 'Hl.m. Praha';",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1 \nJOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) \nFROM client AS T1 \nJOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'"
        ],
        "amend_res": 1
    },
    "1409": {
        "db_id": "student_club",
        "question": "Mention the total expense used on 8/20/2019.",
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'",
        "amends": [
            "Do reference the `cost` column instead of `amount` in the SELECT list. Do reference the `expense` table instead of `expenses` in the FROM clause. Do use the `expense_date` column instead of `date` in the WHERE filter condition. The amended query now correctly sums costs from the expense table for the specified date.",
            "Do use the ISO date format `'2019-08-20'` instead of the ambiguous `'8/20/2019'` format to ensure proper date parsing and avoid potential month/day confusion. Do remove the unnecessary alias `AS total_expense` instead of keeping it since the aggregate result doesn't require naming in this context. The amended query now correctly calculates the sum of costs for the specified date without formatting issues."
        ],
        "rules": [
            "1) When the question asks for \"total expense\": use the \"cost\" column from the \"expense\" table to calculate the sum. 2) When the question mentions a specific date \"8/20/2019\": filter using the \"expense_date\" column with the exact date value '2019-08-20'. 3) When referencing table names: use the exact table name \"expense\" (not \"expenses\") as shown in the schema.",
            "1) When the question mentions a date like \"8/20/2019\": convert it to ISO date format '2019-08-20' to ensure proper date parsing and avoid month/day confusion. 2) When calculating aggregate functions like SUM(cost): do not add unnecessary aliases like AS total_expense when the result doesn't require naming in the context."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM expenses WHERE date = '2019-08-20';",
            "SELECT SUM(cost) AS total_expense FROM expense WHERE expense_date = '8/20/2019'",
            "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20';"
        ],
        "rule_sql": [
            "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20';"
        ],
        "amend_res": 1
    },
    "1197": {
        "db_id": "thrombosis_prediction",
        "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
        "ground_truth": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
        "amends": [
            "Do use column aliases `First Date` and `Diagnosis` instead of `admission_date` and `disease`. Do reference table `Patient` instead of `patients`. Do use column `ID` instead of `patient_id` in the WHERE filter. Do remove the ORDER BY clause with `admission_date DESC` instead of keeping it. Do remove the LIMIT 1 clause instead of keeping it. The amended query now matches RIGHT_SQL's behavior by selecting the appropriate columns and table with the correct filtering condition."
        ],
        "rules": [
            "1) When answering about \"medical information on patient number 48473\": make sure the output order: \"First Date\", \"Diagnosis\" 2) When the question mentions \"patient number 48473\": use exact literal value 48473 for filtering on column \"ID\" 3) When selecting from the patient table: reference table \"Patient\" instead of \"patients\" 4) When outputting column names: use aliases \"First Date\" and \"Diagnosis\" instead of \"admission_date\" and \"disease\" 5) When filtering for a specific patient: do not use ORDER BY or LIMIT clauses since we want the actual first documentation date and diagnosis"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT admission_date, disease FROM patients WHERE patient_id = 48473 ORDER BY admission_date DESC LIMIT 1;",
            "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473"
        ],
        "rule_sql": [
            "SELECT \"First Date\", Diagnosis FROM Patient WHERE ID = 48473"
        ],
        "amend_res": 1
    },
    "291": {
        "db_id": "toxicology",
        "question": "How many chemical compounds in the database are identified as carcinogenic.",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "amends": [
            "Do select `COUNT(T.molecule_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do query from `molecule AS T` instead of `compounds` to access the correct table source. Do filter with `T.label = '+'` instead of `carcinogenic = 'yes'` to apply the appropriate condition for the desired subset. The amended query now correctly counts molecules with positive labels rather than compounds marked as carcinogenic, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"chemical compounds\": the correct table to use is \"molecule AS T\" instead of \"compounds\". 2) When counting chemical compounds: use COUNT(T.molecule_id) to count specific non-null values rather than COUNT(*). 3) When identifying carcinogenic compounds: filter with T.label = '+' instead of carcinogenic = 'yes' to apply the appropriate condition for the desired subset."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM compounds WHERE carcinogenic = 'yes';",
            "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'"
        ],
        "amend_res": 1
    },
    "1246": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients with an abnormal activated partial prothrom bin time, how many of them does not have thrombosis?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE T3.Thrombosis = 0 AND T2.APTT > 45",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` and `INNER JOIN Examination AS T3 ON T3.ID = T2.ID` instead of querying only the `patients` table. Do change the filter to `T3.Thrombosis = 0` instead of `thrombosis IS NULL` to check for absence of thrombosis. Do replace the condition with `T2.APTT > 45` instead of `activated_partial_prothrombin_time = 'abnormal'` to use a numeric threshold comparison. The amended query now correctly joins multiple tables and uses proper filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patient IDs. 2) When combining patient data with laboratory and examination information: perform inner joins using Laboratory AS T2 ON T1.ID = T2.ID and Examination AS T3 ON T3.ID = T2.ID. 3) When identifying abnormal activated partial prothrombin time: use T2.APTT > 45 instead of checking for 'abnormal' text values. 4) When checking for absence of thrombosis: use T3.Thrombosis = 0 instead of checking for NULL values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE activated_partial_prothrombin_time = 'abnormal' \nAND thrombosis IS NULL;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.APTT > 45 AND T3.Thrombosis = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE T2.APTT > 45 AND T3.Thrombosis = 0"
        ],
        "amend_res": 1
    },
    "87": {
        "db_id": "california_schools",
        "question": "What are the valid e-mail addresses of the administrator of the school located in the San Bernardino county, City of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Schools?",
        "ground_truth": "SELECT T2.AdmEmail1, T2.AdmEmail2 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010' AND T2.SOC = 62",
        "amends": [
            "Do select `T2.AdmEmail1` and `T2.AdmEmail2` instead of just `email`. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T2.County = 'San Bernardino'` and `T2.City = 'San Bernardino'` instead of `city = 'San Bernardino City Unified'`. Do add `T2.DOC = 54` and `T2.SOC = 62` conditions instead of omitting them. Do use `strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010'` for year-based date filtering instead of `opening_date BETWEEN '2009-01-01' AND '2010-12-31'`. Do remove the `school_type IN` and `administrator = 'yes'` filters instead of keeping them. The amended query now correctly joins the frpm and schools tables with proper code matching and year-based date filtering to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about email addresses of school administrators: select both \"T2.AdmEmail1\" and \"T2.AdmEmail2\" columns instead of just \"email\". 2) When combining school data from multiple tables: join \"frpm AS T1\" with \"schools AS T2\" using inner join where \"T1.CDSCode = T2.CDSCode\" to match records. 3) When filtering by county: use \"T2.County = 'San Bernardino'\" exactly as specified. 4) When filtering by city: use \"T2.City = 'San Bernardino'\" instead of 'San Bernardino City Unified'. 5) When filtering by district and school organization codes: include conditions \"T2.DOC = 54\" and \"T2.SOC = 62\". 6) When filtering by opening date between 2009 and 2010: use year-based filtering with \"strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010'\" instead of exact date ranges. 7) When the question mentions school types: do not apply school_type filters as they are not required. 8) When the question mentions administrators: do not apply administrator = 'yes' filter as it is not required."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM schools WHERE county = 'San Bernardino' AND city = 'San Bernardino City Unified' AND opening_date BETWEEN '2009-01-01' AND '2010-12-31' AND school_type IN ('Public Intermediate/Middle School', 'Unified School') AND administrator = 'yes';",
            "SELECT T2.AdmEmail1, T2.AdmEmail2\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'San Bernardino'\nAND T2.City = 'San Bernardino'\nAND T2.DOC = 54\nAND T2.SOC = 62\nAND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010'"
        ],
        "rule_sql": [
            "SELECT T2.AdmEmail1, T2.AdmEmail2\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'San Bernardino'\nAND T2.City = 'San Bernardino'\nAND T2.DOC = '54'\nAND T2.SOC = '62'\nAND strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010';"
        ],
        "amend_res": 1
    },
    "1043": {
        "db_id": "european_football_2",
        "question": "What is the short name of the football team Queens Park Rangers?",
        "ground_truth": "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers'",
        "amends": [
            "Do reference the `team_short_name` column instead of `full_name` and use the `team_long_name` filter instead of `short_name`. Do query from the `Team` table instead of `football_teams`. The amended query now correctly retrieves the short name by filtering on the long name from the appropriate table structure."
        ],
        "rules": [
            "1) When the question asks for the short name of a football team: select the \"team_short_name\" column from the \"Team\" table. 2) When the question mentions \"Queens Park Rangers\": this refers to filtering where \"team_long_name\" equals 'Queens Park Rangers' exactly. 3) When querying from the Team table: use the exact table name \"Team\" and do not use alternative table names like \"football_teams\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT full_name FROM football_teams WHERE short_name = 'Queens Park Rangers';",
            "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';"
        ],
        "rule_sql": [
            "SELECT team_short_name FROM Team WHERE team_long_name = 'Queens Park Rangers';"
        ],
        "amend_res": 1
    },
    "1081": {
        "db_id": "european_football_2",
        "question": "Which country is the Belgium Jupiler League from?",
        "ground_truth": "SELECT t1.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t2.name = 'Belgium Jupiler League'",
        "amends": [
            "Do select `t1.name` from the `Country` table instead of `country` from the `leagues` table. Do join `Country AS t1` with `League AS t2` using `INNER JOIN` on `t1.id = t2.country_id` instead of querying only the `leagues` table. Do filter on `t2.name = 'Belgium Jupiler League'` instead of filtering directly on the `leagues.name` column. The amended query now correctly retrieves the country name by joining the Country and League tables through their relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which country a league is from\": make sure the output order: t1.name 2) When the question mentions \"Belgium Jupiler League\": \"Belgium Jupiler League\" actually means t2.name = 'Belgium Jupiler League' in schema 3) When combining Country table as T1 and League table as T2 for shared entities: link rows where t1.id = t2.country_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When selecting the country name: use t1.name from the Country table instead of country from the leagues table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM leagues WHERE name = 'Belgium Jupiler League';",
            "SELECT t1.name \nFROM Country AS t1 \nINNER JOIN League AS t2 ON t1.id = t2.country_id \nWHERE t2.name = 'Belgium Jupiler League'"
        ],
        "rule_sql": [
            "SELECT t1.name \nFROM Country t1 \nINNER JOIN League t2 ON t1.id = t2.country_id \nWHERE t2.name = 'Belgium Jupiler League';"
        ],
        "amend_res": 1
    },
    "1268": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients with an abnormal anti-SM, please list the IDs of the three youngest ones.",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM NOT IN ('negative','0') ORDER BY T1.Birthday DESC LIMIT 3",
        "amends": [
            "Do select `T1.ID` instead of `patient_id` and use table aliases. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the patients table. Do filter with `T2.SM NOT IN ('negative','0')` instead of `anti_sm = 'abnormal'` to exclude negative and zero values. Do order by `T1.Birthday DESC` instead of `birth_date ASC` for descending order. The amended query now correctly joins patient and laboratory data to filter based on SM test results rather than anti_sm values, returning the expected three records with matching behavior to the right SQL."
        ],
        "rules": [
            "1) When selecting patient IDs: use \"T1.ID\" instead of \"patient_id\" and include table aliases. 2) When querying patients with abnormal anti-SM: join \"Patient AS T1\" with \"Laboratory AS T2\" on \"T1.ID = T2.ID\" instead of querying only the patients table. 3) When filtering for abnormal SM results: use \"T2.SM NOT IN ('negative','0')\" instead of checking for 'abnormal' to exclude negative and zero values. 4) When ordering by age to find youngest patients: use \"T1.Birthday DESC\" instead of ascending order to get the three youngest patients."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE anti_sm = 'abnormal' ORDER BY birth_date ASC LIMIT 3;",
            "SELECT T1.ID\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SM NOT IN ('negative', '0')\nORDER BY T1.Birthday DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SM NOT IN ('negative', '0')\nORDER BY T1.Birthday DESC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "1299": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients with the normal level of triglyceride, how many of them have other symptoms observed?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 AND T1.Symptoms IS NOT NULL",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific columns instead of `COUNT(*)` from all rows. Do use `Examination AS T1` and `Laboratory AS T2` as source tables instead of just `patients`. Do perform an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter with `T2.TG < 200` for triglyceride values instead of `triglyceride = 'normal'` using string comparison. Do keep `T1.Symptoms IS NOT NULL` instead of `symptoms IS NOT NULL` but with proper table qualification. The amended query now correctly joins examination and laboratory data while using numeric comparison for triglyceride thresholds instead of string matching."
        ],
        "rules": [
            "1) When answering about patients with normal triglyceride levels: use numeric comparison T2.TG < 200 instead of string matching 'normal'. 2) When combining examination and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count using the canonical patient identifier. 4) When filtering for patients with symptoms: use T1.Symptoms IS NOT NULL with proper table qualification. 5) When selecting source tables: use Examination AS T1 and Laboratory AS T2 as specified in the schema relationship."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE triglyceride = 'normal' AND symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG < 200 \nAND T1.Symptoms IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Examination AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.TG < 200 \nAND T1.Symptoms IS NOT NULL",
            "SELECT COUNT(T1.ID) \nFROM Examination AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.TG < 200 \nAND T1.Symptoms IS NOT NULL"
        ],
        "amend_res": 1
    },
    "659": {
        "db_id": "codebase_community",
        "question": "How many tags have post count between 5,000 to 7,000?",
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference column `Count` instead of `post_count` to match the actual column name. Do use `BETWEEN 5000 AND 7000` instead of separate `>= 5000 AND <= 7000` conditions for more concise range filtering. The amended query now correctly counts tag IDs within the specified count range, matching the intended behavior."
        ],
        "rules": [
            "1) When counting tags: use COUNT(\"Id\") instead of COUNT(*) to count specific non-null values rather than all rows. 2) When the question mentions \"post count\": \"post count\" actually means \"Count\" in the schema. 3) When filtering for values between 5,000 to 7,000: use BETWEEN 5000 AND 7000 instead of separate >= 5000 AND <= 7000 conditions for more concise range filtering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tags WHERE post_count >= 5000 AND post_count <= 7000;",
            "SELECT COUNT(Id) FROM tags WHERE Count BETWEEN 5000 AND 7000;"
        ],
        "rule_sql": [
            "SELECT COUNT(\"Id\") FROM tags WHERE Count BETWEEN 5000 AND 7000"
        ],
        "amend_res": 1
    },
    "1365": {
        "db_id": "student_club",
        "question": "What are the expenses of the budget with the lowest remaining?",
        "ground_truth": "SELECT T2.expense_description FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget ORDER BY T1.remaining LIMIT 1",
        "amends": [
            "Do select `expense_description` from the `expense` table instead of `expense_amount` from the `budget` table. Do add an `INNER JOIN` with the `expense` table on `budget_id = link_to_budget` instead of querying only the `budget` table. Do reference columns with table aliases `T1` and `T2` instead of using unqualified column names. Do order by `T1.remaining` in ascending order instead of descending order. The amended query now correctly joins the budget and expense tables to retrieve the expense description associated with the budget record having the smallest remaining amount."
        ],
        "rules": [
            "1) When answering about \"expenses of the budget with the lowest remaining\": make sure the output order: T2.expense_description 2) When the question mentions \"expenses\": \"expenses\" actually means \"expense_description in expense table\" 3) When combining T1 (budget) and T2 (expense) for shared entities: link rows where T1.budget_id = T2.link_to_budget and keep only matching pairs (inner match) 4) When the question asks for \"lowest remaining\": order rows by T1.remaining in ascending order and keep the first 1 row 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expense_amount FROM budget ORDER BY remaining DESC LIMIT 1;",
            "SELECT T2.expense_description \nFROM budget T1 \nINNER JOIN expense T2 ON T1.budget_id = T2.link_to_budget \nORDER BY T1.remaining ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.expense_description \nFROM budget T1 \nINNER JOIN expense T2 ON T1.budget_id = T2.link_to_budget \nORDER BY T1.remaining ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1021": {
        "db_id": "european_football_2",
        "question": "What is the height of the tallest player? Indicate his name.",
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select `player_name` instead of `name, MAX(height)` and remove the aggregate function. Do add `FROM Player` instead of `FROM players` to reference the correct table. Do add `ORDER BY height DESC` instead of using `MAX(height)` without grouping to properly sort by height. Do add `LIMIT 1` instead of omitting it to return only the tallest player. Do remove the incorrect `MAX` aggregation that would fail without a GROUP BY clause. The amended query now correctly identifies the tallest player by sorting in descending order and limiting to one result, matching the intended behavior.",
            "Do remove `height` from the SELECT list instead of including it, as the query only needs to return the player name of the tallest player rather than both the name and height value. The amended query now correctly returns only the player_name column while maintaining the same ORDER BY and LIMIT logic to identify the tallest player, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"height of the tallest player\": sort rows from table \"Player\" by column \"height\" in descending order and keep only the first row. 2) When the question asks to indicate the player's name: include column \"player_name\" in the output. 3) When referencing the table containing player information: use the exact table name \"Player\" (case-sensitive) instead of \"players\". 4) When ordering by height to find the tallest: use the exact column name \"height\" for sorting in descending direction. 5) When limiting results to only the tallest player: return exactly one row using limit 1.",
            "1) When the question asks for the tallest player's name but not the height value: exclude the height column from the output and return only the player_name column. 2) When identifying the tallest player: order all players by height in descending order and take the first row. 3) When the question asks for \"the tallest player\": use the exact column name \"height\" from the Player table for comparison and ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, MAX(height) FROM players;",
            "SELECT player_name, height FROM Player ORDER BY height DESC LIMIT 1;",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "810": {
        "db_id": "superhero",
        "question": "What is the race of the superhero with maximum attribute value?",
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do join `superhero` as `T1` and `hero_attribute` as `T2` on `T1.id = T2.hero_id` instead of querying `superheroes` directly. Do join `race` as `T3` on `T1.race_id = T3.id` instead of selecting `race` without proper table relationships. Do select `T3.race` instead of just `race` to specify the source table. Do order by `T2.attribute_value` instead of `attribute_value` to reference the correct table column. The amended query now correctly joins the necessary tables to establish proper relationships between superheroes, their attributes, and races, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about superhero race with maximum attribute value: join table \"superhero\" as T1 with table \"hero_attribute\" as T2 where T1.id equals T2.hero_id to establish the relationship between superheroes and their attributes. 2) When selecting race information: join table \"race\" as T3 where T1.race_id equals T3.id to properly access race data through the relationship. 3) When outputting the race: select T3.race instead of just race to specify the correct source table. 4) When ordering by attribute value: use T2.attribute_value instead of attribute_value to reference the correct table column. 5) When finding the maximum attribute value: order by T2.attribute_value in descending direction and keep only the first row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race FROM superheroes ORDER BY attribute_value DESC LIMIT 1;",
            "SELECT T3.race\nFROM superhero AS T1\nJOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nJOIN race AS T3 ON T1.race_id = T3.id\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.race \nFROM superhero AS T1\nJOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nJOIN race AS T3 ON T1.race_id = T3.id\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "493": {
        "db_id": "card_games",
        "question": "For the set \"Commander 2014 Oversized\" , give its parent code.",
        "ground_truth": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized'",
        "amends": [
            "Do use column name `parentCode` instead of `parent_code` to match the actual schema. The amended query now correctly retrieves the parentCode value for the specified set name."
        ],
        "rules": [
            "1) When the question asks for \"parent code\" of a specific set: use the exact column name \"parentCode\" from the sets table. 2) When filtering by set name with literal \"Commander 2014 Oversized\": match the exact string literal 'Commander 2014 Oversized' with correct case and spacing. 3) When retrieving information about sets: ensure the output column order is parentCode as the single result column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT parent_code FROM sets WHERE name = 'Commander 2014 Oversized';",
            "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';"
        ],
        "rule_sql": [
            "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';"
        ],
        "amend_res": 1
    },
    "550": {
        "db_id": "codebase_community",
        "question": "From which post is the most popular tag excerpted from? Please give the body of the post.",
        "ground_truth": "SELECT Body FROM posts WHERE id = ( SELECT ExcerptPostId FROM tags ORDER BY Count DESC LIMIT 1 )",
        "amends": [
            "Do select `Body` instead of `p.body` and remove the `GROUP BY` clause instead of grouping by `p.id`. Do use a subquery in the `WHERE` clause instead of joining with the `tags` table. Do filter by `id = (subquery)` instead of joining on `p.id = t.post_id`. Do order by `Count DESC` in the subquery instead of ordering by `COUNT(t.id) DESC` in the main query. Do select from `ExcerptPostId` in the subquery instead of aggregating tag counts. The amended query now correctly identifies the post with the highest tag count using the tag metadata instead of performing an incorrect aggregation."
        ],
        "rules": [
            "1) When answering about \"the most popular tag excerpted from\": make sure the output order: \"Body\" from posts table. 2) When the question mentions \"most popular tag excerpted from\": \"most popular\" actually means \"highest count of tags per ExcerptPostId\" in schema. 3) When the question asks for the post with the highest tag count: use a subquery to find the ExcerptPostId with the maximum count of tags instead of joining tables. 4) When filtering posts by id: filter where posts.id equals the ExcerptPostId from the subquery result instead of joining on p.id = t.post_id. 5) When counting tags for popularity: count using the ExcerptPostId column as the grouping key in the subquery. 6) When ordering by popularity in the subquery: order by the count of tags in descending order to find the highest count. 7) When selecting the top result: take only the first result (limit 1) from the ordered subquery to get the ExcerptPostId with the highest tag count."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.body \nFROM posts p \nJOIN tags t ON p.id = t.post_id \nGROUP BY p.id \nORDER BY COUNT(t.id) DESC \nLIMIT 1;",
            "SELECT Body \nFROM posts \nWHERE Id = (\n    SELECT ExcerptPostId \n    FROM tags \n    ORDER BY Count DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT Body \nFROM posts \nWHERE Id = (\n    SELECT ExcerptPostId \n    FROM tags \n    GROUP BY ExcerptPostId \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)",
            "SELECT p.Body \nFROM posts p \nWHERE p.Id = (\n    SELECT t.ExcerptPostId \n    FROM tags t \n    GROUP BY t.ExcerptPostId \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)"
        ],
        "amend_res": 1
    },
    "1470": {
        "db_id": "debit_card_specializing",
        "question": "How many gas stations in CZE has Premium gas?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'",
        "amends": [
            "Do reference the correct table name `gasstations` instead of `gas_stations`. Do use the correct column name `GasStationID` for counting instead of `*`. Do filter on the correct column `Segment` instead of `gas_type` while keeping the same filter value 'Premium'. Do maintain the same `Country` filter with value 'CZE' but use proper case matching. The amended query now correctly counts gas stations in the Czech Republic with Premium segment classification."
        ],
        "rules": [
            "1) When counting gas stations: use the exact column name \"GasStationID\" from the gasstations table instead of counting all columns. 2) When filtering by country 'CZE': use the exact column name \"Country\" with exact literal value 'CZE' (case-sensitive). 3) When filtering by gas type 'Premium': use the exact column name \"Segment\" with exact literal value 'Premium' instead of 'gas_type'. 4) When referencing the gas stations table: use the exact table name \"gasstations\" instead of \"gas_stations\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM gas_stations WHERE country = 'CZE' AND gas_type = 'Premium';",
            "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';"
        ],
        "rule_sql": [
            "SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium';"
        ],
        "amend_res": 1
    },
    "920": {
        "db_id": "formula_1",
        "question": "Please list all the years that Silverstone Circuit was used in a Formula_1 race.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit'",
        "amends": [
            "Do reference `T2.year` instead of just `year` to specify the table source. Do join `circuits AS T1` and `races AS T2` instead of querying only the `races` table. Do use `INNER JOIN` with `T2.circuitID = T1.circuitId` instead of no join condition. Do filter on `T1.name = 'Silverstone Circuit'` instead of `circuit_name = 'Silverstone Circuit'` to use the correct column name from the circuits table. The amended query now correctly joins the circuits and races tables to find years for the specific circuit name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about years for a specific circuit: join tables circuits AS T1 and races AS T2 using INNER JOIN with T2.circuitID = T1.circuitId. 2) When the question mentions \"Silverstone Circuit\": filter on T1.name = 'Silverstone Circuit' exactly as written. 3) When listing distinct years: select DISTINCT T2.year from the races table. 4) When combining T1 and T2 for shared entities: link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT year FROM races WHERE circuit_name = 'Silverstone Circuit';",
            "SELECT DISTINCT T2.year\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Silverstone Circuit'\nORDER BY T2.year;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.year \nFROM circuits AS T1 \nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId \nWHERE T1.name = 'Silverstone Circuit'"
        ],
        "amend_res": 1
    },
    "1225": {
        "db_id": "thrombosis_prediction",
        "question": "List and group all patients by sex for total bilirubin (T-BIL) level not within the normal range.",
        "ground_truth": "SELECT T1.ID,T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 GROUP BY T1.SEX,T1.ID",
        "amends": [
            "Do select `T1.ID` and `T1.SEX` instead of `sex` and `COUNT(*) as patient_count`. Do join `Laboratory AS T2` instead of `lab_tests lt` and use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `p.patient_id = lt.patient_id`. Do filter with `T2.\"T-BIL\" >= 2.0` instead of `lt.test_name = 'T-BIL' AND lt.result_value BETWEEN lt.normal_low AND lt.normal_high`. Do group by `T1.SEX, T1.ID` instead of just `sex`. The amended query now correctly selects individual patient records with elevated T-BIL levels rather than counting patients by sex within normal range."
        ],
        "rules": [
            "1) When selecting patient information: use T1.ID and T1.SEX instead of just sex and COUNT(*) 2) When joining with laboratory data: use Laboratory AS T2 with INNER JOIN on T1.ID = T2.ID 3) When filtering for abnormal T-BIL levels: use T2.\"T-BIL\" >= 2.0 instead of checking normal range 4) When grouping results: group by both T1.SEX and T1.ID to show individual patient records 5) When the question asks for patients with abnormal T-BIL levels: filter for values >= 2.0 rather than within normal range"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT sex, COUNT(*) as patient_count\nFROM patients p\nJOIN lab_tests lt ON p.patient_id = lt.patient_id\nWHERE lt.test_name = 'T-BIL' \n  AND lt.result_value BETWEEN lt.normal_low AND lt.normal_high\nGROUP BY sex;",
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.SEX, T1.ID"
        ],
        "rule_sql": [
            "SELECT T1.ID, T1.SEX, T2.\"T-BIL\"\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.SEX, T1.ID;",
            "SELECT T1.ID, T1.SEX, T2.\"T-BIL\"\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.\"T-BIL\" >= 2.0\nGROUP BY T1.SEX, T1.ID"
        ],
        "amend_res": 1
    },
    "1044": {
        "db_id": "european_football_2",
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "ground_truth": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "amends": [
            "Do select `player_name` instead of `*` and use table `Player` instead of `players`. Do filter with `SUBSTR(birthday, 1, 7) = '1970-10'` instead of separate `birthyear = 1970 AND birthmonth = 'October'` conditions to properly handle date extraction from a single birthday field. The amended query now correctly extracts players born in October 1970 by parsing the unified birthday column instead of relying on separate year and month fields."
        ],
        "rules": [
            "1) When the question asks for football players with specific birth details: select \"player_name\" from table \"Player\" instead of using * 2) When handling birthdate filtering: use SUBSTR(birthday, 1, 7) = '1970-10' to extract both year and month from a single birthday field instead of separate year and month conditions 3) When the question mentions \"birthyear of 1970 and birthmonth of October\": this translates to checking for the date pattern '1970-10' in the birthday field"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM players WHERE birthyear = 1970 AND birthmonth = 'October';",
            "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'"
        ],
        "amend_res": 1
    },
    "163": {
        "db_id": "financial",
        "question": "Which district has the most accounts with loan contracts finished with no problems?",
        "ground_truth": "SELECT T1.A2 FROM District AS T1 INNER JOIN Account AS T2 ON T1.District_id = T2.District_id INNER JOIN Loan AS T3 ON T2.Account_id = T3.Account_id WHERE T3.status = 'A' GROUP BY T1.District_id ORDER BY COUNT(T2.Account_id) DESC LIMIT 1",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do specify `T1.A2` in the SELECT list instead of `district_id`. Do add joins with `Account AS T2` and `Loan AS T3` instead of querying only the `accounts` table. Do change the join condition to `T1.District_id = T2.District_id` and `T2.Account_id = T3.Account_id` instead of no joins. Do modify the WHERE filter to `T3.status = 'A'` instead of `loan_status = 'finished'`. Do change the GROUP BY to `T1.District_id` instead of `district_id`. Do update the ORDER BY to use `COUNT(T2.Account_id)` instead of `account_count`. The amended query now correctly joins the necessary tables and uses the proper status filter to match the intended behavior."
        ],
        "rules": [
            "1) When answering about districts with accounts and loan contracts: use explicit table aliases T1 for district, T2 for Account, and T3 for Loan instead of direct table references. 2) When selecting the district identifier: use T1.A2 in the SELECT list instead of district_id. 3) When combining district, account, and loan information: add joins with Account AS T2 and Loan AS T3 instead of querying only the accounts table. 4) When linking district to account: use join condition T1.District_id = T2.District_id. 5) When linking account to loan: use join condition T2.Account_id = T3.Account_id. 6) When filtering for loan contracts finished with no problems: use WHERE filter T3.status = 'A' instead of loan_status = 'finished'. 7) When grouping by district: use GROUP BY T1.District_id instead of district_id. 8) When ordering by account count: use ORDER BY COUNT(T2.Account_id) instead of account_count. 9) When counting accounts: use COUNT(T2.Account_id) as the counting key for accounts."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_id, COUNT(*) as account_count \nFROM accounts \nWHERE loan_status = 'finished' \nGROUP BY district_id \nORDER BY account_count DESC \nLIMIT 1;",
            "SELECT T1.A2\nFROM district AS T1\nJOIN account AS T2 ON T1.district_id = T2.district_id\nJOIN loan AS T3 ON T2.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T1.district_id\nORDER BY COUNT(T2.account_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.A2\nFROM district AS T1\nJOIN account AS T2 ON T1.district_id = T2.district_id\nJOIN loan AS T3 ON T2.account_id = T3.account_id\nWHERE T3.status = 'A'\nGROUP BY T1.district_id\nORDER BY COUNT(T2.account_id) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "826": {
        "db_id": "superhero",
        "question": "Identify the heaviest superhero in DC Comics.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and use `T1.weight_kg` instead of `weight`. Do join `publisher AS T2` on `T1.publisher_id = T2.id` instead of querying `superheroes` directly. Do filter on `T2.publisher_name = 'DC Comics'` instead of `publisher = 'Marvel'`. The amended query now correctly joins tables and filters by publisher name to match the intended DC Comics selection.",
            "Do remove `weight_kg` from the SELECT list instead of including it. Do use explicit `INNER JOIN` instead of implicit `JOIN`. Do maintain the same join condition `T1.publisher_id = T2.id` and filter `T2.publisher_name = 'DC Comics'`. Do keep the same `ORDER BY T1.weight_kg DESC` and `LIMIT 1` clauses. The amended query now matches the right SQL's behavior by selecting only the superhero name while maintaining the same filtering and ordering logic."
        ],
        "rules": [
            "1) When the question asks about superhero weight: use \"T1.weight_kg\" instead of \"weight\" to represent weight in kilograms. 2) When the question asks for superhero name: use \"T1.superhero_name\" instead of \"name\" as the identifier. 3) When combining superhero and publisher information: join \"superhero\" as T1 with \"publisher\" as T2 where \"T1.publisher_id = T2.id\" to link superheroes to their publishers. 4) When filtering for DC Comics superheroes: use the exact literal \"DC Comics\" with \"T2.publisher_name = 'DC Comics'\" instead of \"Marvel\". 5) When finding the heaviest superhero: order results by \"T1.weight_kg\" in descending order and take the first row.",
            "1) When answering about \"the heaviest superhero in DC Comics\": make sure the output order: only include superhero_name, not weight_kg. 2) When combining superhero (T1) and publisher (T2) tables: link rows where T1.publisher_id = T2.id exactly as shown and keep only matching pairs (inner match). 3) When filtering for DC Comics: use the exact literal 'DC Comics' for T2.publisher_name with the exact case and spacing. 4) When ordering by weight: sort by T1.weight_kg in descending order to find the heaviest. 5) When selecting the top result: keep only the first row after ordering to get the single heaviest superhero."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE publisher = 'Marvel' ORDER BY weight DESC LIMIT 1;",
            "SELECT T1.superhero_name, T1.weight_kg\nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'\nORDER BY T1.weight_kg DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'\nORDER BY T1.weight_kg DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nJOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'\nORDER BY T1.weight_kg DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1120": {
        "db_id": "european_football_2",
        "question": "Sum up the away team goal scored by both Daan Smith and Filipe Ferreira.",
        "ground_truth": "SELECT SUM(t2.away_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_5 WHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')",
        "amends": [
            "Do select `SUM(t2.away_team_goal)` from the match table instead of `SUM(goals)` from an unspecified source. Do join `Player AS t1 INNER JOIN match AS t2` with predicate `t1.player_api_id = t2.away_player_5` instead of querying a single `players` table. Do filter on `t1.player_name IN ('Daan Smith', 'Filipe Ferreira')` instead of `name IN ('Daan Smith', 'Filipe Ferreira')` and remove the incorrect `team_type = 'away'` condition that doesn't exist in the schema. The amended query now correctly aggregates away team goals from the match table for specific players through proper table joins, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"sum up the away team goal scored by both Daan Smith and Filipe Ferreira\": make sure the output order: SUM(t2.away_team_goal). 2) When the question mentions \"Daan Smith\" and \"Filipe Ferreira\": these names actually mean \"t1.player_name IN ('Daan Smith', 'Filipe Ferreira')\" in schema. 3) When combining Player as T1 and match as T2 for shared entities: link rows where t1.player_api_id = t2.away_player_5 exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"away team goal\": this actually means \"t2.away_team_goal\" in the schema, not \"goals\" from an unspecified source. 5) When the question mentions \"team_type = 'away'\": do not include this condition as it doesn't exist in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(goals) FROM players WHERE name IN ('Daan Smith', 'Filipe Ferreira') AND team_type = 'away';",
            "SELECT SUM(t2.away_team_goal) \nFROM Player AS t1 \nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_5\nWHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')"
        ],
        "rule_sql": [
            "SELECT SUM(t2.away_team_goal) \nFROM Player AS t1 \nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_5 \nWHERE t1.player_name IN ('Daan Smith', 'Filipe Ferreira')"
        ],
        "amend_res": 1
    },
    "701": {
        "db_id": "codebase_community",
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "amends": [
            "Do use `SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END)` with explicit `ELSE 0` instead of `COUNT(CASE WHEN score > 50 THEN 1 END)` to properly count boolean conditions. Do join `users T1` and `posts T2` with `INNER JOIN` on `T1.Id = T2.OwnerUserId` instead of using a subquery to find the user with maximum followers. Do add a derived table `T3` with `MAX(Reputation)` and join on `T1.Reputation = T3.max_reputation` instead of ordering by `followers DESC` with `LIMIT 1` to correctly identify the user with maximum reputation. Do use `CAST(... AS REAL)` for floating-point division instead of implicit conversion with `100.0`. Do reference `T2.Score` and `T1.Id` with table aliases instead of unqualified column names. The amended query now correctly calculates the percentage of posts with score above 50 for the user with maximum reputation."
        ],
        "rules": [
            "1) When identifying the most influential user: use the user with maximum reputation value from T1 (users table) instead of ordering by followers. 2) When combining users and posts tables: link rows where T1.Id equals T2.OwnerUserId using an inner join. 3) When counting posts with score above 50: use SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) with explicit ELSE 0 instead of COUNT. 4) When calculating percentage: use CAST(... AS REAL) for floating-point division instead of implicit conversion with 100.0. 5) When referencing columns: always use table aliases T1 and T2 with exact column names T1.Id, T2.Score, and T2.OwnerUserId."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN score > 50 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_above_50\nFROM posts\nWHERE user_id = (\n    SELECT user_id \n    FROM users \n    ORDER BY followers DESC \n    LIMIT 1\n);",
            "SELECT \n    (CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100.0 AS percentage_above_50\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN \n    (SELECT MAX(Reputation) AS max_reputation FROM users) T3 ON T1.Reputation = T3.max_reputation"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nWHERE \n    T1.Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "amend_res": 1
    },
    "1304": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients with a normal blood glucose, how many of them don't have thrombosis?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.GLU < 180 AND T3.Thrombosis = 0",
        "amends": [
            "Do select `COUNT(T1.ID)` instead of `COUNT(*)` to count specific patient IDs. Do add joins to `Laboratory AS T2` and `Examination AS T3` instead of querying only the `patients` table. Do use `INNER JOIN` on `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of no joins. Do filter with `T2.GLU < 180` instead of `blood_glucose = 'normal'` to use numeric comparison against glucose levels. Do filter with `T3.Thrombosis = 0` instead of `thrombosis IS NULL` to check for absence of thrombosis using a zero value. The amended query now correctly joins multiple tables and uses appropriate numeric comparisons to match the intended logic."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs. 2) When combining patient data with laboratory and examination information: link rows using INNER JOIN on T1.ID = T2.ID and T1.ID = T3.ID to connect patients with their laboratory results and examination findings. 3) When identifying patients with normal blood glucose: use T2.GLU < 180 instead of blood_glucose = 'normal' to apply the correct numeric threshold for glucose levels. 4) When checking for absence of thrombosis: use T3.Thrombosis = 0 instead of thrombosis IS NULL to properly identify patients without thrombosis using the zero value indicator."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE blood_glucose = 'normal' AND thrombosis IS NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.GLU < 180 \nAND T3.Thrombosis = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.GLU < 180 AND T3.Thrombosis = 0"
        ],
        "amend_res": 1
    },
    "148": {
        "db_id": "financial",
        "question": "Please list the accounts whose district is Tabor that are eligible for loans.",
        "ground_truth": "SELECT T2.account_id FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'OWNER' AND T1.A2 = 'Tabor'",
        "amends": [
            "Do select only `T2.account_id` instead of all columns with `*`. Do join `district AS T1` and `account AS T2` on `T1.district_id = T2.district_id` instead of querying `accounts` directly. Do add an additional join to `disp AS T3` on `T2.account_id = T3.account_id` instead of omitting this table. Do filter on `T3.type = 'OWNER'` instead of omitting this condition. Do filter on `T1.A2 = 'Tabor'` instead of `district = 'Tabor'`. Do remove the `loan_status = 'approved'` filter instead of keeping it. The amended query now correctly identifies account owners in the Tabor district by properly joining through the relationship tables."
        ],
        "rules": [
            "1) When answering about accounts in a specific district: join district table as T1 and account table as T2 on T1.district_id = T2.district_id instead of querying accounts directly. 2) When identifying account owners: join disp table as T3 on T2.account_id = T3.account_id and filter on T3.type = 'OWNER'. 3) When filtering by district name: use T1.A2 = 'Tabor' instead of district = 'Tabor'. 4) When selecting output columns: use only T2.account_id instead of all columns with *. 5) When the question asks about eligibility for loans: do not filter on loan_status = 'approved' as this condition should be removed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE district = 'Tabor' AND loan_status = 'approved';",
            "SELECT T2.account_id\nFROM district AS T1\nJOIN account AS T2 ON T1.district_id = T2.district_id\nJOIN disp AS T3 ON T2.account_id = T3.account_id\nWHERE T1.A2 = 'Tabor'\nAND T3.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT T2.account_id\nFROM district AS T1\nJOIN account AS T2 ON T1.district_id = T2.district_id\nJOIN disp AS T3 ON T2.account_id = T3.account_id\nWHERE T1.A2 = 'Tabor' AND T3.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "70": {
        "db_id": "california_schools",
        "question": "How many active and closed District Community Day Schools are there in the county of Alpine?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE (StatusType = 'Closed' OR StatusType = 'Active') AND SOC = 69 AND County = 'Alpine'",
        "amends": [
            "Do count `School` instead of counting conditional cases for `status` values. Do filter on `StatusType` with `'Closed' OR 'Active'` instead of separate `CASE` expressions for each status. Do add `SOC = 69` filter instead of omitting it. Do remove `school_type = 'District Community Day School'` filter instead of keeping it. Do use simple `COUNT(School)` instead of multiple conditional counts with aliases. The amended query now correctly counts schools with specified status types in Alpine county meeting the SOC criteria."
        ],
        "rules": [
            "1) When counting schools: use COUNT(\"School\") instead of conditional CASE expressions for status values. 2) When filtering by status: use \"StatusType\" IN ('Active', 'Closed') instead of separate conditional counts. 3) When filtering for Alpine county: use \"county\" = 'Alpine' exactly as specified. 4) When applying SOC criteria: include \"SOC\" = 69 filter as required. 5) When the question asks about District Community Day Schools: do not filter by school_type as this is not needed according to the schema and amends. 6) When producing output: count all schools meeting the combined criteria of county, status types, and SOC value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN status = 'Active' THEN 1 END) AS active_schools,\n    COUNT(CASE WHEN status = 'Closed' THEN 1 END) AS closed_schools\nFROM schools\nWHERE county = 'Alpine' AND school_type = 'District Community Day School';",
            "SELECT COUNT(School) FROM schools WHERE County = 'Alpine' AND SOC = 69 AND StatusType IN ('Active', 'Closed')"
        ],
        "rule_sql": [
            "SELECT COUNT(\"School\") \nFROM schools \nWHERE \"county\" = 'Alpine' \nAND \"StatusType\" IN ('Active', 'Closed') \nAND \"SOC\" = '69';"
        ],
        "amend_res": 1
    },
    "514": {
        "db_id": "card_games",
        "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
        "amends": [
            "Do select `name` instead of `card_name` and `mana_cost`, and add `DISTINCT` instead of omitting it. Do add a subquery in the `WHERE` clause with `uuid IN (SELECT uuid FROM legalities WHERE format = 'duel')` instead of no filtering. Do change the `ORDER BY` to `manaCost` instead of `mana_cost` and add an offset `LIMIT 0, 10` instead of `LIMIT 10`. The amended query now correctly filters for duel-legal cards and returns distinct names ordered by mana cost with proper pagination.",
            "Do remove `manaCost` from the SELECT list instead of including it, and do keep the `ORDER BY manaCost DESC` clause instead of removing it. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"duels\": filter cards to only those where the card's uuid appears in the legalities table with format exactly equal to 'duel'. 2) When selecting card names: use the exact column name \"name\" instead of \"card_name\". 3) When ordering by mana cost: use the exact column name \"manaCost\" instead of \"mana_cost\". 4) When retrieving top 10 cards: use LIMIT 0, 10 to get the first 10 rows starting from position 0. 5) When selecting distinct card names: include DISTINCT to return only unique card names. 6) When combining cards and legalities tables: link rows where cards.uuid = legalities.uuid to find duel-legal cards.",
            "1) When answering about \"top 10 cards with highest unconverted mana cost\": make sure the output order includes only the card name and excludes the manaCost column from the final results. 2) When the question mentions \"highest unconverted mana cost\": use the \"manaCost\" column from table \"cards\" for ordering in descending direction. 3) When the question asks for \"top 10 cards\": rank rows by \"manaCost\" in descending order and keep the first 10 rows. 4) When filtering for \"duels\" format: ensure cards are filtered using the condition where \"format\" equals 'duel' in the \"legalities\" table. 5) When combining cards and legalities tables: link rows where the canonical key \"uuid\" from both tables are equal and keep only matching pairs (inner match)."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT card_name, mana_cost FROM cards ORDER BY mana_cost DESC LIMIT 10;",
            "SELECT DISTINCT name, manaCost \nFROM cards \nWHERE uuid IN (SELECT uuid FROM legalities WHERE format = 'duel') \nORDER BY manaCost DESC \nLIMIT 0, 10",
            "SELECT DISTINCT name FROM cards WHERE uuid IN (SELECT uuid FROM legalities WHERE format = 'duel') ORDER BY manaCost DESC LIMIT 0, 10"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.name\nFROM cards c\nINNER JOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'duel'\nORDER BY c.manaCost DESC\nLIMIT 0, 10"
        ],
        "amend_res": 1
    },
    "620": {
        "db_id": "codebase_community",
        "question": "State the number of views of users who obtained the badge on 7/19/2010 7:39:08 PM.",
        "ground_truth": "SELECT T1.Views FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Date = '2010-07-19 19:39:08.0'",
        "amends": [
            "Do select `T1.Views` instead of `COUNT(*)` to retrieve the actual view count rather than counting rows. Do use `INNER JOIN` with explicit join type specification instead of implicit `JOIN`. Do join on `T1.Id = T2.UserId` instead of `u.id = b.user_id` to use proper column naming conventions. Do reference `T2.Date` instead of `b.date` with the full timestamp format including milliseconds. The amended query now correctly retrieves user views for the specified timestamp rather than counting occurrences.",
            "Do use the full timestamp format '2010-07-19 19:39:08.0' instead of the truncated '2010-07-19 19:39:08' to ensure precise timestamp matching. The amended query now correctly matches the RIGHT_SQL's behavior with accurate date filtering."
        ],
        "rules": [
            "1) When answering about \"number of views of users who obtained the badge on 7/19/2010 7:39:08 PM\": make sure the output order: T1.Views. 2) When the question mentions \"number of views\": \"number of views\" actually means \"T1.Views in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question specifies a timestamp \"7/19/2010 7:39:08 PM\": use the exact timestamp format including milliseconds as referenced in T2.Date.",
            "1) When the question asks for views of users who obtained a badge on a specific timestamp: use the exact timestamp format '2010-07-19 19:39:08.0' with the .0 suffix for precise matching. 2) When combining users table (T1) and badges table (T2): link rows where T1.Id = T2.UserId to find users who obtained badges. 3) When filtering for badges obtained on 7/19/2010 7:39:08 PM: use the condition T2.Date = '2010-07-19 19:39:08.0' exactly as specified. 4) When selecting output: return T1.Views column from the users table for matching users."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users u JOIN badges b ON u.id = b.user_id WHERE b.date = '2010-07-19 19:39:08'",
            "SELECT T1.Views \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nWHERE T2.Date = '2010-07-19 19:39:08'",
            "SELECT T1.Views\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08.0'"
        ],
        "rule_sql": [
            "SELECT T1.Views \nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Date = '2010-07-19 19:39:08.0'"
        ],
        "amend_res": 1
    },
    "1085": {
        "db_id": "european_football_2",
        "question": "Which of these players performs the best in crossing actions, Alexis, Ariel Borysiuk or Arouna Kone?",
        "ground_truth": "SELECT t1.player_name, t2.crossing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY t2.crossing DESC LIMIT 1",
        "amends": [
            "Do select `t1.player_name` and `t2.crossing` instead of `player_name` and `crossing_actions`. Do use `FROM Player AS t1 INNER JOIN Player_Attributes AS t2` instead of `FROM players` alone. Do add join condition `ON t1.player_api_id = t2.player_api_id` instead of omitting it. Do reference `t2.crossing` in the ORDER BY instead of `crossing_actions`. Do maintain the same WHERE filter on player names and LIMIT 1 clause. The amended query now correctly joins tables and references the proper column names to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about player performance in crossing actions: join table Player as T1 with table Player_Attributes as T2 using the condition T1.player_api_id = T2.player_api_id to get complete player data. 2) When filtering for specific players like 'Alexis', 'Ariel Borysiuk', or 'Arouna Kone': use T1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') with exact name literals. 3) When determining the best performer: order results by T2.crossing in descending order and take only the top result (LIMIT 1). 4) When selecting output columns: return T1.player_name and T2.crossing to show both the player name and their crossing performance metric."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name, crossing_actions \nFROM players \nWHERE player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') \nORDER BY crossing_actions DESC \nLIMIT 1;",
            "SELECT t1.player_name, t2.crossing\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY t2.crossing DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.player_name, T2.crossing\nFROM Player AS T1\nJOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE T1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\nORDER BY T2.crossing DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "879": {
        "db_id": "formula_1",
        "question": "For the driver who set the fastest lap speed, what is his nationality?",
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [
            "Do join `drivers AS T1` with `results AS T2` on `T2.driverId = T1.driverId` instead of querying `drivers` alone. Do select `T1.nationality` from the joined result instead of just `nationality`. Do order by `T2.fastestLapSpeed` instead of `fastest_lap_speed` to use the correct column from the results table. The amended query now correctly retrieves nationality based on fastest lap speed from race results rather than attempting to use a non-existent column in the drivers table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"the driver who set the fastest lap speed\": make sure to combine drivers table (as T1) with results table (as T2) using the exact join condition T2.driverId = T1.driverId. 2) When the question mentions \"fastest lap speed\": \"fastest lap speed\" actually means T2.fastestLapSpeed in schema. 3) When the question asks for \"nationality\": select T1.nationality from the joined result. 4) When the question asks for \"the driver who set the fastest lap speed\": order rows by T2.fastestLapSpeed in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT nationality FROM drivers ORDER BY fastest_lap_speed DESC LIMIT 1;",
            "SELECT T1.nationality \nFROM drivers AS T1 \nJOIN results AS T2 ON T2.driverId = T1.driverId \nORDER BY T2.fastestLapSpeed DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.nationality \nFROM drivers AS T1\nJOIN results AS T2 ON T2.driverId = T1.driverId\nORDER BY T2.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "702": {
        "db_id": "codebase_community",
        "question": "How many posts have a score less than 20?",
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score < 20",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count only non-null id values. Do change the filter to `Score < 20` instead of `score > 20` to capture posts with scores below the threshold rather than above it. The amended query now correctly counts posts with scores less than 20 using proper column-specific counting."
        ],
        "rules": [
            "1) When counting posts: use COUNT(\"id\") instead of COUNT(*) to count only non-null id values. 2) When filtering for posts with score less than 20: use \"Score\" < 20 instead of score > 20 to capture posts with scores below the threshold."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE score > 20;",
            "SELECT COUNT(Id) FROM posts WHERE Score < 20;"
        ],
        "rule_sql": [
            "SELECT COUNT(\"Id\") FROM posts WHERE \"Score\" < 20;"
        ],
        "amend_res": 1
    },
    "319": {
        "db_id": "toxicology",
        "question": "How many elements are contained in bond_id TR001_3_4?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.element) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_3_4'",
        "amends": [
            "Do select `COUNT(DISTINCT T1.element)` instead of `COUNT(*)`. Do change the FROM source to `atom AS T1 INNER JOIN connected AS T2` instead of just `elements`. Do add the join condition `ON T1.atom_id = T2.atom_id` instead of omitting it. Do move the filter to `WHERE T2.bond_id = 'TR001_3_4'` instead of applying it directly to a non-existent bond_id column in the elements table. The amended query now correctly counts distinct elements from joined tables instead of attempting to count from a single table without the required bond_id column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting elements for a specific bond_id: use COUNT(DISTINCT T1.element) to count unique elements instead of counting all rows. 2) When the question mentions bond_id 'TR001_3_4': this literal value must be matched exactly as 'TR001_3_4' with the correct case and underscores. 3) When combining atom and connected tables: link rows using T1.atom_id = T2.atom_id to create an inner match between the tables. 4) When filtering by bond_id: apply the filter condition T2.bond_id = 'TR001_3_4' to the connected table (T2) since bond_id is not available in the atom table. 5) When answering about elements contained in a bond: the query must join atom AS T1 and connected AS T2 tables instead of querying a single elements table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM elements WHERE bond_id = 'TR001_3_4';",
            "SELECT COUNT(DISTINCT T1.element) \nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id \nWHERE T2.bond_id = 'TR001_3_4'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.element) \nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id \nWHERE T2.bond_id = 'TR001_3_4'"
        ],
        "amend_res": 1
    },
    "216": {
        "db_id": "toxicology",
        "question": "Identify all connected atoms with a triple bond.",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select specific columns `T2.atom_id` and `T2.atom_id2` instead of selecting all columns with `*`. Do join table `bond AS T1` with `connected AS T2` using `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of querying only the `atoms` table. Do filter on `T1.bond_type = '#'` instead of filtering on `bond_type = 'double'` from a different table. The amended query now correctly retrieves connected atom pairs for specific bond types by joining the appropriate tables with proper join conditions and filtering."
        ],
        "rules": [
            "1) When answering about \"connected atoms with a triple bond\": make sure the output order: T2.atom_id, T2.atom_id2. 2) When the question mentions \"triple bond\": \"triple bond\" actually means \"T1.bond_type = '#'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When selecting columns: do not use * but instead select specific columns T2.atom_id and T2.atom_id2."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM atoms WHERE bond_type = 'double';",
            "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2 FROM bond T1 JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "1243": {
        "db_id": "thrombosis_prediction",
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
        "amends": [
            "Do use `SUM(CASE WHEN condition THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN condition THEN 1 END)` for percentage calculation. Do reference `PT >= 14` instead of `pt > 14` to include the threshold value. Do use `SEX = 'F'` instead of `gender = 'F'` for the gender column. Do calculate age dynamically using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55` instead of a static `age > 55` filter. Do join on `T1.ID = T2.ID` instead of `p.patient_id = l.patient_id` for the table relationship. Do cast the sum to `REAL` instead of using `100.0` for proper numeric division. Do use table aliases `T1` and `T2` instead of `p` and `l`. The amended query now correctly calculates the percentage of female patients over 55 with PT values of 14 or higher.",
            "Do add explicit `CAST` to `REAL` for the percentage calculation instead of implicit casting. Do move the `T1.SEX = 'F'` filter from the `WHERE` clause to inside the `CASE` statement condition instead of applying it globally. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do remove the alias `AS percentage` from the calculated column instead of keeping it. Do remove the parentheses around the age calculation condition in the `WHERE` clause instead of keeping them. The amended query now correctly calculates the percentage of female patients over 55 with PT values >= 14, matching the RIGHT_SQL's behavior.",
            "Do move the `T1.SEX = 'F'` filter from the `WHERE` clause to inside the `CASE` expression instead of keeping it as a separate `WHERE` condition. Do change the calculation order to `* 100 / COUNT(*)` instead of `/ COUNT(*) * 100` to ensure proper percentage calculation. Do remove the explicit table aliases `AS T1` and `AS T2` instead of keeping them, as they are functionally equivalent. The amended query now correctly calculates the percentage of female patients over 55 with PT \u2265 14 by moving the gender filter into the conditional aggregation, ensuring accurate results when counting both qualifying and total cases."
        ],
        "rules": [
            "1) When calculating percentages: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for accurate counting. 2) When checking for abnormal prothrombin time: use PT >= 14 instead of PT > 14 to include the threshold value of 14. 3) When filtering by gender: use SEX = 'F' instead of gender = 'F' for the exact column name. 4) When calculating age dynamically: use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55 instead of a static age column. 5) When joining tables: use T1.ID = T2.ID instead of patient_id columns for the exact join condition. 6) When performing numeric division: cast the sum to REAL instead of using 100.0 for proper floating-point calculation. 7) When using table aliases: use T1 for the patients table and T2 for the lab_results table consistently.",
            "1) When calculating percentages: cast the division result to REAL type explicitly instead of relying on implicit casting. 2) When filtering for specific gender within a conditional calculation: place the gender condition T1.SEX = 'F' inside the CASE statement rather than in the global WHERE clause. 3) When joining tables: use INNER JOIN explicitly for clarity instead of just JOIN. 4) When naming calculated columns: do not add alias names like AS percentage to the output column. 5) When writing age calculation conditions: do not use unnecessary parentheses around the age comparison expression.",
            "1) When calculating percentages for conditional subsets: move gender-specific filters like T1.SEX = 'F' into the CASE expression instead of keeping them as separate WHERE conditions to ensure accurate counting of both qualifying and total cases. 2) When computing percentage calculations: use the calculation order * 100 / COUNT(*) instead of / COUNT(*) * 100 to ensure proper percentage calculation. 3) When handling table aliases: do not use explicit AS clauses for table aliases as they are functionally equivalent to simple aliases without AS."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.gender = 'F' AND l.pt > 14 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female_abnormal_pt\nFROM patients p\nJOIN lab_results l ON p.patient_id = l.patient_id\nWHERE p.age > 55",
            "SELECT \n    (SUM(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) > 55\n    AND T1.SEX = 'F'",
            "SELECT \n    (CAST(SUM(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55\n    AND T1.SEX = 'F'",
            "SELECT \n    CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T1.SEX = 'F' AND T2.PT >= 14 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) \nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) > 55"
        ],
        "amend_res": 1
    },
    "208": {
        "db_id": "toxicology",
        "question": "Which type of label is the most numerous in atoms with hydrogen?",
        "ground_truth": "SELECT T.label FROM ( SELECT T2.label, COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'h' GROUP BY T2.label ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1 ) t",
        "amends": [
            "Do join `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only the `atoms` table. Do filter by `T1.element = 'h'` instead of `element = 'hydrogen'`. Do aggregate `COUNT(T2.molecule_id)` instead of `COUNT(*)`. Do select only `T.label` in the outer query instead of both `label` and `count`. Do use a subquery structure with ordering and limiting instead of a simple grouped query. The amended query now correctly counts molecules per label containing hydrogen atoms rather than counting atoms directly."
        ],
        "rules": [
            "1) When the question asks about \"atoms with hydrogen\": filter rows where T1.element equals 'h' exactly (not 'hydrogen'). 2) When combining information about atoms and molecules: join table molecule as T2 on T1.molecule_id = T2.molecule_id using inner match. 3) When counting molecules per label: count distinct T2.molecule_id values instead of counting all rows. 4) When answering about \"most numerous label\": rank labels by molecule count in descending order and keep only the top result. 5) When selecting output columns: return only T2.label (not both label and count)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT label, COUNT(*) as count FROM atoms WHERE element = 'hydrogen' GROUP BY label ORDER BY count DESC LIMIT 1;",
            "SELECT label FROM (\n    SELECT T2.label, COUNT(T2.molecule_id) AS count\n    FROM atom AS T1\n    JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T1.element = 'h'\n    GROUP BY T2.label\n    ORDER BY count DESC\n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT T2.label\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'h'\nGROUP BY T2.label\nORDER BY COUNT(DISTINCT T2.molecule_id) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1253": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
        "ground_truth": "SELECT patientData.Diagnosis FROM Patient AS patientData INNER JOIN Laboratory AS labData ON patientData.ID = labData.ID WHERE labData.IGA BETWEEN 80 AND 500 ORDER BY labData.IGA DESC LIMIT 1",
        "amends": [
            "Do select `patientData.Diagnosis` from the `Patient` table instead of `diagnosis` from the `patients` table. Do join `Laboratory AS labData` with `INNER JOIN` on `patientData.ID = labData.ID` instead of querying a single table. Do filter with `labData.IGA BETWEEN 80 AND 500` in the `WHERE` clause instead of comparing to a subquery finding the maximum IgA value. Do add `ORDER BY labData.IGA DESC` and `LIMIT 1` to get the top result instead of using a subquery that could return multiple matches. Do remove the subquery entirely instead of using it for comparison. The amended query now correctly retrieves the diagnosis for the patient with the highest IgA value within the specified range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the patient who has the highest Ig A within the normal range\": make sure the output order: patientData.Diagnosis. 2) When the question mentions \"highest Ig A within the normal range\": filter rows where labData.IGA is between 80 AND 500 inclusive, then order by labData.IGA in descending direction and keep only the first 1 row. 3) When combining Patient and Laboratory tables: link rows where patientData.ID = labData.ID exactly and keep only matching pairs (inner match). 4) When selecting diagnosis information: use patientData.Diagnosis from the Patient table instead of diagnosis from patients table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT diagnosis FROM patients WHERE IgA = (SELECT MAX(IgA) FROM patients);",
            "SELECT p.Diagnosis\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.IGA BETWEEN 80 AND 500\nORDER BY l.IGA DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT p.Diagnosis \nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE l.IGA BETWEEN 80 AND 500\nORDER BY l.IGA DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "299": {
        "db_id": "toxicology",
        "question": "Is molecule TR124 carcinogenic?",
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'",
        "amends": [
            "Do select `T.label` instead of `carcinogenic` and reference the table with alias `T` instead of no alias. Do use `T.molecule_id = 'TR124'` as the filter instead of `name = 'TR124'` and query from `molecule AS T` instead of `molecules`. The amended query now correctly retrieves the label from the molecule table using the proper identifier column."
        ],
        "rules": [
            "1) When answering about whether a molecule is carcinogenic: make sure the output order: T.label 2) When the question mentions \"TR124\": \"TR124\" actually means T.molecule_id in schema 3) When querying from the molecule table: use alias T for the molecule table instead of no alias 4) When filtering for a specific molecule: use T.molecule_id = 'TR124' as the filter condition instead of name = 'TR124'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic FROM molecules WHERE name = 'TR124';",
            "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR124'"
        ],
        "rule_sql": [
            "SELECT T.label FROM molecule T WHERE T.molecule_id = 'TR124'"
        ],
        "amend_res": 1
    },
    "1152": {
        "db_id": "thrombosis_prediction",
        "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
        "ground_truth": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
        "amends": [
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END)` instead of `COUNT(CASE WHEN treatment_type = 'outpatient' THEN 1 END)` to count positive admissions with proper decimal handling. Do use `SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN treatment_type = 'inpatient' THEN 1 END)` to count negative admissions. Do reference table `Patient` instead of `patients` and column `Diagnosis` instead of `diagnosis` with proper case sensitivity. Do use column `Admission` with values '+' and '-' instead of `treatment_type` with values 'outpatient' and 'inpatient' to match the correct admission status logic. The amended query now correctly calculates the admission ratio using proper sum aggregation and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a ratio of outpatient to inpatient treatment: use SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) for outpatient count and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) for inpatient count, with proper decimal handling for the ratio calculation. 2) When filtering for 'SLE' diagnosed patients: use WHERE Diagnosis = 'SLE' with exact case sensitivity. 3) When referencing the patient table: use table name Patient (not patients) and column names Diagnosis and Admission with proper case sensitivity as shown in the schema. 4) When counting admission status: use Admission column values '+' for outpatient and '-' for inpatient instead of treatment_type column with values 'outpatient' and 'inpatient'."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN treatment_type = 'outpatient' THEN 1 END) / COUNT(CASE WHEN treatment_type = 'inpatient' THEN 1 END) AS outpatient_to_inpatient_ratio\nFROM patients\nWHERE diagnosis = 'SLE';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) AS outpatient_to_inpatient_ratio\nFROM \n    Patient\nWHERE \n    Diagnosis = 'SLE';"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) AS outpatient_count,\n    SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) AS inpatient_count,\n    CASE \n        WHEN SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) > 0 \n        THEN SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END)\n        ELSE NULL \n    END AS outpatient_to_inpatient_ratio\nFROM Patient\nWHERE Diagnosis = 'SLE';",
            "SELECT \n    SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) AS outpatient_count,\n    SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) AS inpatient_count,\n    CASE \n        WHEN SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END) > 0 \n        THEN SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1.0 ELSE 0 END)\n        ELSE NULL \n    END AS outpatient_to_inpatient_ratio\nFROM Patient\nWHERE Diagnosis = 'SLE';"
        ],
        "amend_res": 1
    },
    "1151": {
        "db_id": "thrombosis_prediction",
        "question": "For patient born between Year 1930 to 1940, how many percent of them were inpatient?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940'",
        "amends": [
            "Do use `SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN patient_type = 'inpatient' THEN 1 END)` to count positive admissions. Do cast the result as `REAL` instead of using implicit conversion with `100.0`. Do reference `Admission` column with `'+'` values instead of `patient_type` with `'inpatient'` values. Do use `STRFTIME('%Y', Birthday)` to extract year from date instead of `birth_year` numeric field. Do filter with `BETWEEN '1930' AND '1940'` on formatted year strings instead of `BETWEEN 1930 AND 1940` on numeric values. Do remove the column alias `percentage_inpatient` instead of keeping it. The amended query now correctly calculates the percentage of patients with positive admissions born between 1930 and 1940."
        ],
        "rules": [
            "1) When the question asks about patients born between specific years: extract the year from the \"Birthday\" column using STRFTIME('%Y', Birthday) instead of using a numeric birth_year field. 2) When filtering by birth year range: use BETWEEN '1930' AND '1940' with string literals instead of numeric values. 3) When counting patients with positive admissions: use SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN patient_type = 'inpatient' THEN 1 END). 4) When calculating percentages: cast the result as REAL instead of using implicit conversion with 100.0. 5) When the output is a single percentage value: do not include a column alias like percentage_inpatient."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN patient_type = 'inpatient' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_inpatient\nFROM patients\nWHERE birth_year BETWEEN 1930 AND 1940;",
            "SELECT (SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) FROM Patient WHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940';"
        ],
        "rule_sql": [
            "SELECT (SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) \nFROM Patient \nWHERE STRFTIME('%Y', Birthday) BETWEEN '1930' AND '1940';"
        ],
        "amend_res": 1
    },
    "307": {
        "db_id": "toxicology",
        "question": "Name the atoms' elements that form bond TR000_2_3.",
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'",
        "amends": [
            "Do add `T2.element` in the SELECT list instead of just `element`. Do change the FROM clause to use `connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id` instead of just `atoms`. Do change the WHERE filter to use `T1.bond_id = 'TR000_2_3'` instead of `bond_id = 'TR000_2_3'`. The amended query now correctly joins the connected and atom tables to retrieve element information based on bond_id relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"atoms' elements that form bond TR000_2_3\": make sure the output order: T2.element 2) When the question mentions \"atoms' elements\": \"atoms' elements\" actually means \"T2.element in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.atom_id = T2.atom_id exactly as shown in the amends; keep only matching pairs (inner match) 4) When filtering for bond TR000_2_3: use T1.bond_id = 'TR000_2_3' with exact literal 'TR000_2_3' 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM atoms WHERE bond_id = 'TR000_2_3';",
            "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR000_2_3'"
        ],
        "rule_sql": [
            "SELECT T2.element \nFROM connected T1 \nINNER JOIN atom T2 ON T1.atom_id = T2.atom_id \nWHERE T1.bond_id = 'TR000_2_3'"
        ],
        "amend_res": 1
    },
    "917": {
        "db_id": "formula_1",
        "question": "Which website should I go to if I want to know more about Anthony Davidson?",
        "ground_truth": "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'",
        "amends": [
            "Do select `url` from the `drivers` table instead of `website_url` from `websites`. Do filter on both `forename = 'Anthony'` and `surname = 'Davidson'` instead of just `name = 'Anthony Davidson'`. Do use the correct table `drivers` instead of the incorrect `websites` table. The amended query now correctly retrieves driver information from the appropriate table with proper name filtering."
        ],
        "rules": [
            "1) When the question asks about a website for a person: use the \"url\" column from the \"drivers\" table instead of \"website_url\" from \"websites\". 2) When filtering for a person's name: split the full name into separate \"forename\" and \"surname\" columns and filter using both conditions \"forename = 'Anthony'\" and \"surname = 'Davidson'\" instead of a single \"name\" column. 3) When retrieving driver information: use the \"drivers\" table as the correct source instead of the \"websites\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website_url FROM websites WHERE name = 'Anthony Davidson';",
            "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';"
        ],
        "rule_sql": [
            "SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson';"
        ],
        "amend_res": 1
    },
    "909": {
        "db_id": "formula_1",
        "question": "Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'",
        "amends": [
            "Do add `INNER JOIN circuits AS T1` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do reference `T1.country` instead of `country` alone. Do use `T2.circuitID` in the numerator's CASE condition instead of `1`. Do cast the count as `REAL` instead of using implicit conversion. Do reference `T2.circuitId` in the denominator instead of `*`. Do change the filter to exact match `T2.name = 'European Grand Prix'` instead of pattern matching with `LIKE '%European Grand Prix%'`. The amended query now correctly joins circuits to races to access country data and uses proper table aliasing and exact filtering."
        ],
        "rules": [
            "1) When answering about European Grand Prix races: use exact match T2.name = 'European Grand Prix' instead of pattern matching. 2) When combining races and circuits tables: link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match). 3) When accessing country information: reference T1.country instead of country alone. 4) When counting races hosted in Germany: use T2.circuitID in the numerator's CASE condition instead of 1. 5) When computing the total count: reference T2.circuitId in the denominator instead of *. 6) When calculating percentage: cast the count as REAL instead of using implicit conversion."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN country = 'Germany' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM races \nWHERE name LIKE '%European Grand Prix%';",
            "SELECT \n    (COUNT(CASE WHEN T1.country = 'Germany' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    races AS T2\nINNER JOIN \n    circuits AS T1 ON T2.circuitId = T1.circuitId\nWHERE \n    T2.name = 'European Grand Prix'"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN T1.country = 'Germany' THEN 1 ELSE 0 END) AS REAL) / \n     CAST(COUNT(T2.circuitId) AS REAL)) * 100.0 AS percentage\nFROM \n    races T2\nINNER JOIN \n    circuits T1 ON T2.circuitId = T1.circuitId\nWHERE \n    T2.name = 'European Grand Prix';"
        ],
        "amend_res": 1
    },
    "1407": {
        "db_id": "student_club",
        "question": "Among the budgets for Advertising, list out top three which have the most budgeted amount?",
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3",
        "amends": [
            "Do select `budget_id` instead of `*` for all columns. Do reference table `budget` instead of `budgets`. Do filter for `category = 'Advertisement'` instead of `'Advertising'`. Do order by `amount DESC` instead of `budget_amount ASC`. The amended query now correctly retrieves the top 3 budget IDs from the budget table for the Advertisement category in descending order of amount."
        ],
        "rules": [
            "1) When answering about \"top three which have the most budgeted amount\": rank rows by amount in descending order and keep the first 3 rows. 2) When the question mentions \"Advertising\": \"Advertising\" actually means \"Advertisement\" in the schema. 3) When selecting columns: include budget_id instead of all columns. 4) When referencing the table: use budget instead of budgets. 5) When filtering for category: use category = 'Advertisement' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM budgets WHERE category = 'Advertising' ORDER BY budget_amount ASC LIMIT 3;",
            "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3"
        ],
        "rule_sql": [
            "SELECT budget_id FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3"
        ],
        "amend_res": 1
    },
    "188": {
        "db_id": "financial",
        "question": "Among the accounts who have loan validity more than 24 months, list out the accounts that have the lowest approved amount and have account opening date before 1997.",
        "evidence": "",
        "ground_truth": "SELECT T1.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration > 24 AND STRFTIME('%Y', T2.date) < '1997' ORDER BY T1.amount ASC LIMIT 1",
        "amends": [
            "Do select only `T1.account_id` instead of all columns with `*`. Do use `loan` table as T1 and `account` table as T2 instead of only `accounts` table. Do use `INNER JOIN` on `T1.account_id = T2.account_id` instead of no join. Do filter with `T1.duration > 24` instead of `loan_validity > 24`. Do remove the incorrect aggregate `MIN(approved_amount)` condition and instead use proper ordering. Do filter with `STRFTIME('%Y', T2.date) < '1997'` for year extraction instead of `account_opening_date < '1997-01-01'`. Do add `ORDER BY T1.amount ASC` and `LIMIT 1` to get the minimum amount record instead of the flawed aggregate approach. The amended query now correctly identifies the account with the smallest loan amount that meets the duration and date criteria."
        ],
        "rules": [
            "1) When answering about accounts with loan validity more than 24 months: use table \"loan\" as T1 and filter with T1.duration > 24 instead of loan_validity > 24. 2) When combining loan and account information: use INNER JOIN on T1.account_id = T2.account_id to link the tables. 3) When filtering accounts by opening date before 1997: extract year from T2.date using STRFTIME('%Y', T2.date) < '1997' instead of direct date comparison. 4) When finding the lowest approved amount: order results by T1.amount ASC and use LIMIT 1 to get the single minimum record. 5) When selecting output columns: return only T1.account_id instead of all columns with *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE loan_validity > 24 AND approved_amount = MIN(approved_amount) AND account_opening_date < '1997-01-01';",
            "SELECT T1.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.duration > 24\nAND STRFTIME('%Y', T2.date) < '1997'\nORDER BY T1.amount ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM loan AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nWHERE T1.duration > 24\nAND STRFTIME('%Y', T2.date) < '1997'\nORDER BY T1.amount ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "688": {
        "db_id": "codebase_community",
        "question": "Identify the number of posts that have been viewed over 35000 times but have received no comments from other users.",
        "ground_truth": "SELECT COUNT(Id) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count specific non-null values. Do reference `ViewCount` instead of `views` and `CommentCount` instead of `comments` to use the correct column names that match the schema. The amended query now correctly counts posts with view counts exceeding 35000 and zero comment counts using the proper column identifiers."
        ],
        "rules": [
            "1) When counting posts: use COUNT(\"Id\") instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"viewed over 35000 times\": this means \"ViewCount\" > 35000 using the exact column name from the schema. 3) When the question mentions \"no comments from other users\": this means \"CommentCount\" = 0 using the exact column name from the schema. 4) When answering about posts with specific view and comment conditions: filter rows where both \"ViewCount\" > 35000 and \"CommentCount\" = 0 are true simultaneously."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE views > 35000 AND comments = 0;",
            "SELECT COUNT(Id) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0;"
        ],
        "rule_sql": [
            "SELECT COUNT(\"Id\") FROM posts WHERE \"ViewCount\" > 35000 AND \"CommentCount\" = 0;"
        ],
        "amend_res": 1
    },
    "857": {
        "db_id": "formula_1",
        "question": "Give the coordinate position for Abu Dhabi Grand Prix.",
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'",
        "amends": [
            "Do use `DISTINCT T1.lat, T1.lng` instead of `latitude, longitude` to select specific columns with deduplication. Do add `INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId` instead of querying only the circuits table, joining on the correct relationship between circuit IDs. Do move the filter to `T2.name = 'Abu Dhabi Grand Prix'` instead of `name = 'Abu Dhabi Grand Prix'` to filter by race name rather than circuit name. Do use table aliases `T1` and `T2` instead of no aliases for clarity and to resolve column references. The amended query now correctly retrieves circuit coordinates based on race name rather than circuit name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about coordinate position for a Grand Prix: make sure the output order: T1.lat, T1.lng. 2) When the question mentions \"Abu Dhabi Grand Prix\": \"Abu Dhabi Grand Prix\" actually means T2.name = 'Abu Dhabi Grand Prix' in schema. 3) When combining T1 and T2 for shared entities: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match). 4) When selecting coordinate columns: use DISTINCT T1.lat, T1.lng instead of latitude, longitude to select specific columns with deduplication."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude FROM circuits WHERE name = 'Abu Dhabi Grand Prix';",
            "SELECT DISTINCT T1.lat, T1.lng\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'Abu Dhabi Grand Prix'"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.lat, c.lng\nFROM circuits c\nINNER JOIN races r ON c.circuitId = r.circuitId\nWHERE r.name = 'Abu Dhabi Grand Prix';"
        ],
        "amend_res": 1
    },
    "256": {
        "db_id": "toxicology",
        "question": "Calculate the total atoms consisting of the element carbon and hydrogen.",
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'",
        "amends": [
            "Do `COUNT(T.atom_id)` instead of `SUM(atoms)` for counting records rather than summing values. Do `FROM atom AS T` instead of `FROM elements` to reference the correct table with an alias. Do `WHERE T.element = 'c' OR T.element = 'h'` instead of `WHERE element_name = 'carbon' OR element_name = 'hydrogen'` to use the correct column name and element symbol values. The amended query now correctly counts atom records for carbon and hydrogen elements using proper table structure and values."
        ],
        "rules": [
            "1) When counting records of atoms: use COUNT(T.atom_id) instead of SUM(atoms) to count individual atom records rather than summing numeric values. 2) When referencing the atom table: use FROM atom AS T with alias T instead of FROM elements to access the correct table structure. 3) When filtering for carbon and hydrogen elements: use WHERE T.element = 'c' OR T.element = 'h' with exact element symbol values 'c' and 'h' instead of full element names 'carbon' and 'hydrogen'. 4) When the question asks for \"atoms consisting of the element carbon and hydrogen\": this means atoms where the element column contains either 'c' (carbon) or 'h' (hydrogen) symbols."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(atoms) FROM elements WHERE element_name = 'carbon' OR element_name = 'hydrogen';",
            "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.element = 'c' OR T.element = 'h'"
        ],
        "amend_res": 1
    },
    "489": {
        "db_id": "card_games",
        "question": "List the keyrune code for the set whose code is 'PKHC'.",
        "ground_truth": "SELECT keyruneCode FROM sets WHERE code = 'PKHC'",
        "amends": [
            "Do select `keyruneCode` instead of `keyrune_code` to use the correct column name that matches the actual schema. The amended query now matches RIGHT_SQL's behavior by properly referencing the intended column."
        ],
        "rules": [
            "1) When the question asks for \"keyrune code\" from the sets table: use the exact column name \"keyruneCode\" (not \"keyrune_code\") from table sets. 2) When filtering for sets with code equal to 'PKHC': use the exact literal value 'PKHC' with the correct case and no quotes in the condition. 3) When selecting output columns: return only the \"keyruneCode\" column in the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT keyrune_code FROM sets WHERE code = 'PKHC';",
            "SELECT keyruneCode FROM sets WHERE code = 'PKHC';"
        ],
        "rule_sql": [
            "SELECT keyruneCode FROM sets WHERE code = 'PKHC';"
        ],
        "amend_res": 1
    },
    "1133": {
        "db_id": "european_football_2",
        "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do use table alias `Player` instead of `players` for correct table reference. Do filter with `birthday > '1990'` instead of `birth_year > 1990` to use date comparison rather than numeric year. Do use `player_name LIKE 'Aaron%'` instead of `first_name = 'Aaron'` to match names starting with Aaron rather than exact first name matches. The amended query now correctly counts non-null IDs from the Player table for players born after 1990 with names starting with Aaron."
        ],
        "rules": [
            "1) When counting entities from the Player table: count the \"id\" column instead of using * to avoid counting null values. 2) When referring to the players table: use the exact table alias \"Player\" as shown in the schema. 3) When filtering by birth date: use \"birthday > '1990'\" for date comparison instead of numeric year comparison. 4) When matching names starting with \"Aaron\": use \"player_name LIKE 'Aaron%'\" to find names beginning with Aaron rather than exact first name matches."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE first_name = 'Aaron' AND birth_year > 1990;",
            "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%';"
        ],
        "amend_res": 1
    },
    "111": {
        "db_id": "financial",
        "question": "How many accounts were opened in Litomerice in 1996?",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1996' AND T1.A2 = 'Litomerice'",
        "amends": [
            "Do select `COUNT(T2.account_id)` from a specific column instead of `COUNT(*)` from all rows. Do join `district AS T1` with `account AS T2` using `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do filter with `T1.A2 = 'Litomerice'` on the district table instead of `city = 'Litomerice'` on the accounts table. Do use `STRFTIME('%Y', T2.date) = '1996'` for year extraction instead of `YEAR(opened_date) = 1996`. The amended query now correctly counts accounts from the Litomerice district opened in 1996 by properly joining district and account tables with accurate column references."
        ],
        "rules": [
            "1) When answering about accounts opened in a specific location and year: join district table as T1 with account table as T2 using inner join where T1.district_id = T2.district_id. 2) When the question mentions \"Litomerice\": use T1.A2 = 'Litomerice' to filter for the correct district. 3) When the question mentions \"1996\" as the year: use STRFTIME('%Y', T2.date) = '1996' to filter for accounts opened in that year. 4) When counting accounts: use COUNT(T2.account_id) instead of COUNT(*) to count specific account identifiers."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE city = 'Litomerice' AND YEAR(opened_date) = 1996;",
            "SELECT COUNT(T2.account_id) \nFROM district AS T1 \nINNER JOIN account AS T2 ON T1.district_id = T2.district_id \nWHERE T1.A2 = 'Litomerice' \nAND STRFTIME('%Y', T2.date) = '1996'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) \nFROM district T1 \nINNER JOIN account T2 ON T1.district_id = T2.district_id \nWHERE T1.A2 = 'Litomerice' \nAND STRFTIME('%Y', T2.date) = '1996'"
        ],
        "amend_res": 1
    },
    "959": {
        "db_id": "formula_1",
        "question": "What is the fastest lap number of the champion in 2009?",
        "ground_truth": "SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do select `T1.fastestLap` instead of `fastest_lap` and use proper table aliases. Do join `results AS T1` with `races AS T2` on `T1.raceId = T2.raceId` instead of querying only the races table. Do filter on `T2.year = 2009` instead of `year = 2009` with proper table qualification. Do add the condition `T1.time LIKE '_:%:__.___'` instead of filtering on `position = 1` to correctly identify race winners based on time format rather than position. The amended query now correctly retrieves fastest lap times from race winners by joining results with races and using proper time-based winner identification.",
            "Do use `INNER JOIN` instead of `JOIN` to explicitly specify the join type. Do keep the same `SELECT` list with `fastestLap`, maintain the same `FROM` sources with `results AS T1` and `races AS T2`, preserve the identical join condition `T1.raceId = T2.raceId`, retain the same `WHERE` filters with `T2.year = 2009` and `T1.time LIKE '_:%:__.___'`, but do remove the `ORDER BY T1.fastestLap ASC` and `LIMIT 1` clauses instead of keeping them. The amended query now matches RIGHT_SQL's behavior by returning all matching rows without ordering or limiting the result set."
        ],
        "rules": [
            "1) When answering about \"fastest lap number of the champion in 2009\": make sure the output order: T1.fastestLap\n2) When the question mentions \"champion\": \"champion\" actually means \"race winners identified by time format '_:%:__.___' in schema\"\n3) When combining T1 (results) and T2 (races) for shared entities: link rows where T1.raceId = T2.raceId; keep only matching pairs (inner match)\n4) When filtering for year 2009: use T2.year = 2009 with proper table qualification\n5) When identifying race winners: use T1.time LIKE '_:%:__.___' instead of position-based filtering to correctly identify champions",
            "1) When the question asks for the fastest lap number of the champion in 2009: use the exact column token \"fastestLap\" from table \"results\" with alias T1. 2) When combining tables \"results\" and \"races\": link rows where T1.raceId = T2.raceId using inner join and keep only matching pairs. 3) When filtering for the year 2009: use the exact literal value 2009 with column T2.year. 4) When identifying champion results: filter using T1.time LIKE '_:%:__.___' to match time patterns indicating winning positions. 5) When the question asks for a single fastest lap number: do not apply ordering or limiting clauses as the champion's result should naturally be the fastest lap among winning entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT fastest_lap FROM races WHERE year = 2009 AND position = 1",
            "SELECT T1.fastestLap \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.year = 2009 \nAND T1.time LIKE '_:%:__.___' \nORDER BY T1.fastestLap ASC \nLIMIT 1;",
            "SELECT T1.fastestLap\nFROM results AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2009\nAND T1.time LIKE '_:%:__.___'"
        ],
        "rule_sql": [
            "SELECT T1.fastestLap \nFROM results T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T2.year = 2009 \nAND T1.time LIKE '_:%:__.___';"
        ],
        "amend_res": 1
    },
    "578": {
        "db_id": "codebase_community",
        "question": "Which user made a post titled 'Understanding what Dassault iSight is doing?' and how much is the reputation of the user?",
        "ground_truth": "SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'",
        "amends": [
            "Do use `T1.DisplayName` and `T1.Reputation` instead of `u.display_name` and `u.reputation` for column references. Do use explicit `INNER JOIN` instead of implicit `JOIN` for the join type. Do use `T1.Id = T2.OwnerUserId` instead of `u.id = p.owner_user_id` for the join condition, correcting the column name from `owner_user_id` to `OwnerUserId`. Do use table aliases `T1` and `T2` instead of `u` and `p` for consistency. The amended query now correctly matches the intended behavior with proper column references and join conditions."
        ],
        "rules": [
            "1) When the question asks about a user who made a specific post: use T1 for the users table and T2 for the posts table with aliases as established in the amends. 2) When referencing user display name and reputation: use exact column tokens \"T1.DisplayName\" and \"T1.Reputation\" as shown in the schema. 3) When joining users and posts tables: use an INNER JOIN with the exact condition \"T1.Id = T2.OwnerUserId\" to match rows where the user ID equals the post's owner user ID. 4) When filtering for a specific post title: use the exact literal string 'Understanding what Dassault iSight is doing?' with proper case and punctuation. 5) When selecting output columns: maintain the order of DisplayName followed by Reputation as specified in the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.display_name, u.reputation FROM users u JOIN posts p ON u.id = p.owner_user_id WHERE p.title = 'Understanding what Dassault iSight is doing?'",
            "SELECT T1.DisplayName, T1.Reputation \nFROM users T1 \nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId \nWHERE T2.Title = 'Understanding what Dassault iSight is doing?'"
        ],
        "rule_sql": [
            "SELECT T1.DisplayName, T1.Reputation\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T2.Title = 'Understanding what Dassault iSight is doing?'"
        ],
        "amend_res": 1
    },
    "1402": {
        "db_id": "student_club",
        "question": "What is the most popular size of t-shirt ordered by the club members?",
        "ground_truth": "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1",
        "amends": [
            "Do select `t_shirt_size` instead of `size` and do not include `COUNT(*) as order_count` in the SELECT list. Do use `FROM member` instead of `FROM t_shirt_orders` as the data source. Do group by `t_shirt_size` instead of `size`. Do order by `COUNT(t_shirt_size)` directly instead of ordering by the aliased `order_count`. The amended query now correctly retrieves the most popular t-shirt size from the member table rather than counting orders from a separate orders table."
        ],
        "rules": [
            "1) When answering about \"most popular size of t-shirt ordered by club members\": make sure the output order: t_shirt_size. 2) When the question mentions \"size\": \"size\" actually means \"t_shirt_size\" in the member table. 3) When counting t-shirt sizes: compute the number of occurrences using t_shirt_size directly. 4) When the question asks for \"most popular\": rank rows by count of t_shirt_size in descending order and keep the first 1 row. 5) When grouping by t-shirt size: organize results by t_shirt_size and compute counts per group. 6) When choosing the data source: use the member table as the primary data source instead of any orders table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT size, COUNT(*) as order_count FROM t_shirt_orders GROUP BY size ORDER BY order_count DESC LIMIT 1;",
            "SELECT t_shirt_size FROM member GROUP BY t_shirt_size ORDER BY COUNT(t_shirt_size) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t_shirt_size, COUNT(*) as count\nFROM member\nGROUP BY t_shirt_size\nORDER BY count DESC\nLIMIT 1;",
            "SELECT t_shirt_size\nFROM member\nGROUP BY t_shirt_size\nORDER BY COUNT(t_shirt_size) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "138": {
        "db_id": "financial",
        "question": "In the branch where the second-highest number of crimes were committed in 1995 occurred, how many male clients are there?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT T3.A15 FROM district AS T3 ORDER BY T3.A15 DESC LIMIT 1, 1)",
        "amends": [
            "Do select `COUNT(T1.client_id)` instead of `COUNT(*)` and use table alias `T1` instead of bare table name. Do join `district AS T2` on `T1.district_id = T2.district_id` instead of missing the join entirely. Do filter on `T1.gender = 'M'` instead of `gender = 'male'` and use `T2.A15` instead of `branch_id`. Do use a direct subquery `SELECT T3.A15 FROM district AS T3` with `ORDER BY T3.A15 DESC LIMIT 1, 1` instead of the complex `GROUP BY branch_id ORDER BY COUNT(*) DESC LIMIT 1 OFFSET 1` approach. The amended query now correctly counts clients from the district with the second highest A15 value, matching the intended behavior."
        ],
        "rules": [
            "1) When counting clients: use COUNT(T1.client_id) instead of COUNT(*) to count using the canonical key. 2) When referring to the clients table: use alias T1 instead of the bare table name. 3) When combining clients and district tables: join on T1.district_id = T2.district_id using an inner match. 4) When filtering for male clients: use T1.gender = 'M' instead of 'male' to match the exact literal value. 5) When referring to the district identifier: use T2.A15 instead of branch_id as the exact column token. 6) When finding the second-highest value: use ORDER BY T3.A15 DESC LIMIT 1, 1 instead of GROUP BY with COUNT and OFFSET. 7) When selecting from district in subqueries: use alias T3 for the district table in the subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE gender = 'male' AND branch_id = (SELECT branch_id FROM crimes WHERE year = 1995 GROUP BY branch_id ORDER BY COUNT(*) DESC LIMIT 1 OFFSET 1);",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M'\nAND T2.A15 = (\n    SELECT T3.A15 \n    FROM district AS T3 \n    ORDER BY T3.A15 DESC \n    LIMIT 1 OFFSET 1\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T2.A15 = (\n    SELECT T3.A15 \n    FROM district T3 \n    ORDER BY T3.A15 DESC \n    LIMIT 1 OFFSET 1\n) \nAND T1.gender = 'M'"
        ],
        "amend_res": 1
    },
    "939": {
        "db_id": "formula_1",
        "question": "How many drivers from the UN participated in the 2008 Australian Grand Prix?",
        "ground_truth": "SELECT COUNT(*) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T1.nationality = 'British' AND T3.year = 2008",
        "amends": [
            "Do join `drivers AS T1` with `results AS T2` on `T1.driverId = T2.driverId` instead of querying only the drivers table. Do add a second join to `races AS T3` on `T3.raceId = T2.raceId` instead of missing the necessary table relationships. Do filter on `T3.name = 'Australian Grand Prix'` instead of the non-existent `race_name` column. Do change nationality filter to `T1.nationality = 'British'` instead of `'UN'`. Do use `T3.year = 2008` instead of `race_year`. The amended query now correctly counts British drivers in the 2008 Australian Grand Prix by properly joining through the results table to connect drivers with races."
        ],
        "rules": [
            "1) When answering about drivers participating in a specific race: join \"drivers AS T1\" with \"results AS T2\" on T1.driverId = T2.driverId to connect drivers to their race participations. 2) When connecting race participations to specific race events: join \"results AS T2\" with \"races AS T3\" on T3.raceId = T2.raceId to access race details. 3) When filtering for a specific race name: use T3.name = 'Australian Grand Prix' instead of non-existent race_name column. 4) When filtering for driver nationality: use T1.nationality = 'British' instead of 'UN' as specified in the question correction. 5) When filtering for race year: use T3.year = 2008 instead of non-existent race_year column. 6) When counting drivers from a specific nationality in a specific race: count the number of matching rows using the driver-race connection established through the joins."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'UN' AND race_year = 2008 AND race_name = 'Australian Grand Prix';",
            "SELECT COUNT(DISTINCT T1.driverId) \nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T3.raceId = T2.raceId\nWHERE T1.nationality = 'British'\nAND T3.year = 2008\nAND T3.name = 'Australian Grand Prix'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.driverId) \nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T3.raceId = T2.raceId\nWHERE T1.nationality = 'British'\nAND T3.name = 'Australian Grand Prix'\nAND T3.year = 2008"
        ],
        "amend_res": 1
    },
    "1098": {
        "db_id": "european_football_2",
        "question": "What is Ajax's highest chance creation passing score and what is it classified as?",
        "ground_truth": "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Ajax' ORDER BY t2.chanceCreationPassing DESC LIMIT 1",
        "amends": [
            "Do select `t2.chanceCreationPassing` and `t2.chanceCreationPassingClass` instead of `MAX(passing_score)` and `'Excellent'` classification. Do join `Team AS t1` with `Team_Attributes AS t2` on `t1.team_api_id = t2.team_api_id` instead of querying only `player_stats`. Do filter on `t1.team_long_name = 'Ajax'` instead of `player_name = 'Ajax'`. Do add `ORDER BY t2.chanceCreationPassing DESC` and `LIMIT 1` instead of using aggregation without ordering. The amended query now correctly retrieves the highest chance creation passing value with its classification for the Ajax team."
        ],
        "rules": [
            "1) When the question asks about a team's highest chance creation passing score: select t2.chanceCreationPassing and t2.chanceCreationPassingClass instead of using MAX aggregation on a different column. 2) When the question mentions a team name like 'Ajax': filter on t1.team_long_name = 'Ajax' exactly as written, not on player_name. 3) When combining Team and Team_Attributes tables: link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match). 4) When finding the highest value: order by t2.chanceCreationPassing in descending order and take only the first row (limit 1)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(passing_score) as highest_score, 'Excellent' as classification FROM player_stats WHERE player_name = 'Ajax'",
            "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass \nFROM Team AS t1 \nJOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Ajax' \nORDER BY t2.chanceCreationPassing DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.chanceCreationPassing, t2.chanceCreationPassingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Ajax' \nORDER BY t2.chanceCreationPassing DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "623": {
        "db_id": "codebase_community",
        "question": "How many elders obtained the \"Supporter\" badge?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Age > 65 AND T2.Name = 'Supporter'",
        "amends": [
            "Do select `COUNT(T1.Id)` from the `users` table instead of `COUNT(*)` from only the `badges` table. Do add `INNER JOIN` between `users AS T1` and `badges AS T2` on `T1.Id = T2.UserId` instead of querying only the `badges` table. Do move the age filter to `T1.Age > 65` in the `WHERE` clause instead of using `age >= 65` on the badges table. Do keep the badge name filter as `T2.Name = 'Supporter'` but apply it to the joined badges table instead of the standalone badges table. The amended query now correctly counts users with supporter badges who are over 65 years old by joining the users and badges tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many elders obtained the Supporter badge\": make sure the output order: COUNT(T1.Id). 2) When the question mentions \"elders\": \"elders\" actually means \"users with Age > 65\" in schema. 3) When the question mentions \"Supporter badge\": \"Supporter badge\" actually means \"badges with Name = 'Supporter'\" in schema. 4) When combining T1 (users) and T2 (badges) for shared entities: link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match). 5) When counting users: compute the number of rows using the canonical key token T1.Id for users."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM badges WHERE name = 'Supporter' AND age >= 65;",
            "SELECT COUNT(T1.Id) \nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nWHERE T1.Age > 65 AND T2.Name = 'Supporter'"
        ],
        "rule_sql": [
            "SELECT COUNT(users.Id) \nFROM users \nINNER JOIN badges ON users.Id = badges.UserId \nWHERE users.Age > 65 \nAND badges.Name = 'Supporter'"
        ],
        "amend_res": 1
    },
    "806": {
        "db_id": "superhero",
        "question": "Provide the eye colour of the superhero who has Karen Beecher-Duncan as their full name.",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Karen Beecher-Duncan'",
        "amends": [
            "Do select `T2.colour` from the joined colour table instead of directly selecting `eye_color` from the superheroes table. Do join `superhero AS T1` with `colour AS T2` using `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying a single table without any joins. Do maintain the same `WHERE` filter on `T1.full_name = 'Karen Beecher-Duncan'` as in the original query. The amended query now correctly retrieves the eye color from the normalized colour table through proper join relationships instead of relying on a denormalized column, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for eye colour of a superhero: select the colour value from the colour table (T2.colour) instead of from the superheroes table. 2) When joining superhero and colour tables: use an inner join where T1.eye_colour_id equals T2.id to link the tables correctly. 3) When filtering by a specific superhero name: use T1.full_name = 'Karen Beecher-Duncan' exactly as specified to identify the correct superhero. 4) When the schema uses normalized colour data: always join to the colour table to retrieve colour information rather than using denormalized columns in the superhero table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM superheroes WHERE full_name = 'Karen Beecher-Duncan';",
            "SELECT T2.colour \nFROM superhero AS T1 \nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id \nWHERE T1.full_name = 'Karen Beecher-Duncan'"
        ],
        "rule_sql": [
            "SELECT c.colour \nFROM superhero s\nINNER JOIN colour c ON s.eye_colour_id = c.id\nWHERE s.full_name = 'Karen Beecher-Duncan'"
        ],
        "amend_res": 1
    },
    "393": {
        "db_id": "card_games",
        "question": "On how many cards designed by John Avon is its foil non-powerful?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
        "amends": [
            "Do select `COUNT(id)` instead of `COUNT(*)` to count specific non-null identifiers rather than all rows. Do remove the `JOIN designers` table and instead filter directly on the `artist` column instead of joining through a separate table. Do change the WHERE condition to `(cardKingdomId IS NULL OR cardKingdomFoilId IS NULL)` instead of `d.designer_name = 'John Avon' AND c.foil_powerful = 'yes'` to check for missing marketplace identifiers rather than foil power and designer name. Do remove the `foil_powerful` filter entirely instead of including it. The amended query now correctly counts cards by John Avon that are missing marketplace identifiers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about cards designed by John Avon: filter the cards table where the artist column equals 'John Avon' exactly. 2) When the question asks about cards with non-powerful foil: check for missing marketplace identifiers using the condition (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) instead of foil_powerful. 3) When counting cards: use COUNT(id) to count specific non-null identifiers rather than COUNT(*) for all rows. 4) When handling designer information: use the artist column directly in the cards table instead of joining to a separate designers table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards c JOIN designers d ON c.designer_id = d.designer_id WHERE d.designer_name = 'John Avon' AND c.foil_powerful = 'yes';",
            "SELECT COUNT(id) FROM cards WHERE artist = 'John Avon' AND (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL)"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE artist = 'John Avon' AND (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL)"
        ],
        "amend_res": 1
    },
    "1074": {
        "db_id": "european_football_2",
        "question": "List all the short name of the football team that had a home team goal of 10?",
        "ground_truth": "SELECT t1.team_short_name FROM Team AS t1 INNER JOIN Match AS t2 ON t1.team_api_id = t2.home_team_api_id WHERE t2.home_team_goal = 10",
        "amends": [
            "Do select `t1.team_short_name` from the `Team` table instead of `short_name` from `football_teams`. Do add an `INNER JOIN` with the `Match` table on `t1.team_api_id = t2.home_team_api_id` instead of querying a single table. Do filter on `t2.home_team_goal = 10` from the joined Match table instead of filtering on `home_team_goal` from what appears to be a non-existent column in the original table. The amended query now correctly joins the Team and Match tables to find teams where their home team goals equal 10, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"short name of the football team\": use \"t1.team_short_name\" from the Team table instead of \"short_name\" from football_teams. 2) When combining Team and Match tables: link rows where \"t1.team_api_id = t2.home_team_api_id\" and keep only matching pairs (inner match). 3) When filtering for home team goal of 10: use \"t2.home_team_goal = 10\" from the Match table instead of filtering on a non-existent column in the original table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT short_name FROM football_teams WHERE home_team_goal = 10;",
            "SELECT t.team_short_name \nFROM Team t\nINNER JOIN Match m ON t.team_api_id = m.home_team_api_id\nWHERE m.home_team_goal = 10;"
        ],
        "rule_sql": [
            "SELECT t1.team_short_name \nFROM Team t1 \nINNER JOIN Match t2 ON t1.team_api_id = t2.home_team_api_id \nWHERE t2.home_team_goal = 10"
        ],
        "amend_res": 1
    },
    "559": {
        "db_id": "codebase_community",
        "question": "Indicate the creation date of the maximum number of votes.",
        "ground_truth": "SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1",
        "amends": [
            "Do reference column `CreationDate` instead of `creation_date` to match the correct case-sensitive column name. Do use aggregate `COUNT(Id)` instead of `COUNT(*)` to count specific non-null identifiers rather than all rows. The amended query now correctly groups by the proper column name and counts distinct vote identifiers, matching the intended behavior of the right SQL.",
            "Do remove the `vote_count` alias from the SELECT list instead of including it, as it's not needed for the final output. Do move the aggregate function `COUNT(Id)` to the ORDER BY clause instead of keeping it in the SELECT list, since we only need to order by the count without displaying it. Do maintain the same GROUP BY on `CreationDate` and LIMIT 1 to find the date with the highest vote count. The amended query now correctly returns only the CreationDate with the maximum vote count while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"creation date\": use the exact column name \"CreationDate\" with proper case sensitivity. 2) When counting votes: count using the canonical key \"Id\" column to count specific non-null identifiers rather than all rows. 3) When answering about the maximum number of votes: rank rows by the count of votes in descending order and keep only the first row.",
            "1) When answering about \"the creation date of the maximum number of votes\": make sure the output order: CreationDate only. 2) When counting votes: use COUNT(Id) as the counting function but do not include it in the final output. 3) When finding the maximum count: order the results by COUNT(Id) in descending direction and keep only the first 1 row. 4) When grouping by creation date: organize results by CreationDate and compute the vote count per each CreationDate."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT creation_date FROM votes GROUP BY creation_date ORDER BY COUNT(*) DESC LIMIT 1;",
            "SELECT CreationDate, COUNT(Id) AS vote_count\nFROM votes\nGROUP BY CreationDate\nORDER BY vote_count DESC\nLIMIT 1;",
            "SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT CreationDate\nFROM votes\nGROUP BY CreationDate\nORDER BY COUNT(Id) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "260": {
        "db_id": "toxicology",
        "question": "Calculate the total atoms with triple-bond molecules containing the element phosphorus or bromine.",
        "ground_truth": "SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element IN ('p', 'br')",
        "amends": [
            "Do count `T1.atom_id` instead of `COUNT(*)` to avoid counting NULL values. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only the atoms table. Do add an additional join to `bond AS T3` on `T2.molecule_id = T3.molecule_id` to access bond information. Do filter on `T3.bond_type = '#'` instead of `bond_type = 'triple'` using the correct bond notation. Do use `T1.element IN ('p', 'br')` with element symbols instead of `element = 'phosphorus' OR element = 'bromine'` with full names. The amended query now correctly counts atoms with triple bonds using proper table joins and standardized chemical notation."
        ],
        "rules": [
            "1) When counting atoms: count T1.atom_id instead of all rows to avoid counting NULL values. 2) When answering about atoms with triple-bond molecules: join atom AS T1 with molecule AS T2 on T1.molecule_id = T2.molecule_id to access molecule information. 3) When accessing bond information: join molecule AS T2 with bond AS T3 on T2.molecule_id = T3.molecule_id. 4) When filtering for triple bonds: use T3.bond_type = '#' instead of 'triple' using the correct bond notation. 5) When filtering for phosphorus or bromine elements: use T1.element IN ('p', 'br') with element symbols instead of full names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE bond_type = 'triple' AND (element = 'phosphorus' OR element = 'bromine');",
            "SELECT COUNT(T1.atom_id) \nFROM atom AS T1\nJOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#' \nAND T1.element IN ('p', 'br')"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.atom_id) \nFROM atom AS T1\nJOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#' \nAND T1.element IN ('p', 'br')"
        ],
        "amend_res": 1
    },
    "598": {
        "db_id": "codebase_community",
        "question": "What is the percentage difference of student badges given during 2010 and 2011?",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', Date) = '2010', 1, 0)) AS REAL) * 100 / COUNT(Id) - CAST(SUM(IIF(STRFTIME('%Y', Date) = '2011', 1, 0)) AS REAL) * 100 / COUNT(Id) FROM badges WHERE Name = 'Student'",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN condition THEN 1 END)` for counting conditional occurrences. Do calculate percentage differences by subtracting individual year percentages instead of computing a single percentage difference ratio. Do add filter `WHERE Name = 'Student'` instead of filtering only by year. Do remove the division by 2010 count in the percentage calculation and instead calculate each year's percentage separately against total `COUNT(Id)`. Do use `COUNT(Id)` as the denominator for percentage calculations instead of counting only 2010 records. The amended query now correctly calculates the percentage point difference between 2010 and 2011 Student badges rather than computing a relative percentage change.",
            "Do remove the `WHERE` filter for `Name = 'Student'` and move it into the conditional aggregation expressions instead of applying it at the table level, which incorrectly excluded non-Student records from the denominator count. Do add explicit `CAST` to `REAL` for the numerator sums instead of relying on implicit casting, ensuring proper floating-point division. Do remove the redundant year filters from the `WHERE` clause instead of keeping them, as the conditional aggregation already handles the year filtering. Do simplify the calculation by removing the parentheses around each percentage term instead of maintaining complex nested expressions. The amended query now correctly calculates the percentage difference between 2010 and 2011 Student badges while including all records in the denominator count for accurate percentage calculations.",
            "Do move the `Name = 'Student'` filter from inside the `IIF` conditions to a `WHERE` clause instead of embedding it in the conditional logic. Do change the calculation order by applying the multiplication by 100 after the division instead of before it, ensuring proper percentage calculation. Do remove the alias `percentage_difference` instead of keeping it since the right query returns an unnamed result. The amended query now correctly calculates the percentage difference between 2010 and 2011 student badges by first filtering for students in the WHERE clause and performing the mathematical operations in the correct order."
        ],
        "rules": [
            "1) When the question asks about \"student badges\": filter records where \"Name\" equals exactly 'Student'. 2) When calculating percentages for different years: compute each year's percentage separately by dividing the count of badges for that year by the total count of all badges (using \"Id\" as the counting key). 3) When calculating percentage difference between two years: subtract the individual year percentages (2011 percentage minus 2010 percentage) rather than computing a single ratio. 4) When counting conditional occurrences: use SUM(IIF(condition, 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN condition THEN 1 END). 5) When filtering by year: use the exact year values '2010' and '2011' as specified in the question.",
            "1) When calculating percentage difference between years: include all records in the denominator count for accurate percentage calculations. 2) When filtering for specific badge types like 'Student': apply the filter within conditional aggregation expressions instead of at the table level to avoid excluding records from the denominator. 3) When performing floating-point division: explicitly cast numerator sums to REAL type to ensure proper division. 4) When handling year-based filtering: use conditional aggregation for year filtering instead of WHERE clause filters to maintain complete denominator counts. 5) When computing percentage difference: simplify the calculation by removing unnecessary parentheses around percentage terms.",
            "1) When the question asks about \"student badges\": filter rows where \"Name\" equals exactly 'Student' before any calculations. 2) When calculating percentage difference between years 2010 and 2011: compute (number of badges in 2010 divided by total badges) minus (number of badges in 2011 divided by total badges) then multiply by 100. 3) When extracting year from date values: use the exact year extraction method shown in the schema (strftime with '%Y' format). 4) When the question asks for an unnamed result: do not include any column alias in the output."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN strftime('%Y', date) = '2010' THEN 1 END) - COUNT(CASE WHEN strftime('%Y', date) = '2011' THEN 1 END)) * 100.0 / COUNT(CASE WHEN strftime('%Y', date) = '2010' THEN 1 END) AS percentage_difference\nFROM badges\nWHERE strftime('%Y', date) IN ('2010', '2011');",
            "SELECT \n    (SUM(IIF(strftime('%Y', Date) = '2010' AND Name = 'Student', 1, 0)) * 100.0 / COUNT(Id)) - \n    (SUM(IIF(strftime('%Y', Date) = '2011' AND Name = 'Student', 1, 0)) * 100.0 / COUNT(Id)) \n    AS percentage_difference\nFROM badges\nWHERE Name = 'Student' AND (strftime('%Y', Date) = '2010' OR strftime('%Y', Date) = '2011');",
            "SELECT \n    (CAST(SUM(IIF(strftime('%Y', Date) = '2010' AND Name = 'Student', 1, 0)) AS REAL) / COUNT(Id) * 100) - \n    (CAST(SUM(IIF(strftime('%Y', Date) = '2011' AND Name = 'Student', 1, 0)) AS REAL) / COUNT(Id) * 100) \n    AS percentage_difference\nFROM badges",
            "SELECT \n    (CAST(SUM(IIF(strftime('%Y', Date) = '2010', 1, 0)) AS REAL) / COUNT(Id) * 100) - \n    (CAST(SUM(IIF(strftime('%Y', Date) = '2011', 1, 0)) AS REAL) / COUNT(Id) * 100)\nFROM badges\nWHERE Name = 'Student';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(IIF(strftime('%Y', Date) = '2010' AND Name = 'Student', 1, 0)) AS REAL) / COUNT(Id) * 100) - \n    (CAST(SUM(IIF(strftime('%Y', Date) = '2011' AND Name = 'Student', 1, 0)) AS REAL) / COUNT(Id) * 100)\nFROM badges;"
        ],
        "amend_res": 1
    },
    "888": {
        "db_id": "formula_1",
        "question": "In which country was the first European Grand Prix hosted? Name the circuit and location.",
        "ground_truth": "SELECT T1.country, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix' ORDER BY T2.year ASC LIMIT 1",
        "amends": [
            "Do select `T1.country` and `T1.location` instead of `country`, `circuit`, and `location`. Do use `circuits AS T1` joined with `races AS T2` on `T2.circuitID = T1.circuitId` instead of querying `grand_prix` alone. Do filter with `T2.name = 'European Grand Prix'` instead of `year = (SELECT MIN(year) FROM grand_prix WHERE continent = 'Europe')`. Do add `ORDER BY T2.year ASC LIMIT 1` instead of omitting ordering and limiting. Do remove the subquery and continent condition instead of keeping them. The amended query now correctly identifies the circuit location for the specific European Grand Prix race with proper table relationships and filtering.",
            "Do remove `T1.name AS circuit` from the SELECT list instead of including it. Do use `INNER JOIN` explicitly instead of just `JOIN` (though they are functionally equivalent). Do keep all other elements including the join condition `T2.circuitID = T1.circuitId`, WHERE filter `T2.name = 'European Grand Prix'`, ORDER BY `T2.year ASC`, and LIMIT 1 unchanged. The amended query now matches RIGHT_SQL's behavior by selecting only the required columns country and location."
        ],
        "rules": [
            "1) When answering about the first European Grand Prix: make sure the output order: T1.country, T1.location. 2) When the question mentions \"circuit and location\": \"circuit\" actually means \"T1.name in schema\" but should not be selected, and \"location\" actually means \"T1.location in schema\". 3) When combining circuits AS T1 and races AS T2: link rows where T2.circuitID = T1.circuitId exactly as shown; keep only matching pairs (inner match). 4) When filtering for European Grand Prix: use T2.name = 'European Grand Prix' exactly as specified. 5) When finding the first occurrence: order by T2.year in ascending direction and keep only the first 1 row. 6) When handling text literals: do not change 'European Grand Prix' case, spacing, or punctuation.",
            "1) When answering about the first European Grand Prix: make sure the output order: country, location. 2) When the question asks for circuit name: do not include circuit name in the output columns. 3) When combining circuits table (T1) and races table (T2): link rows where T2.circuitId = T1.circuitId and keep only matching pairs (inner match). 4) When filtering for European Grand Prix: use exact literal 'European Grand Prix' for T2.name comparison. 5) When finding the first occurrence: order results by T2.year in ascending order and keep only the first row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, circuit, location FROM grand_prix WHERE year = (SELECT MIN(year) FROM grand_prix WHERE continent = 'Europe');",
            "SELECT T1.country, T1.location, T1.name AS circuit\nFROM circuits AS T1\nJOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.year ASC\nLIMIT 1;",
            "SELECT T1.country, T1.location\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'European Grand Prix'\nORDER BY T2.year ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT circuits.country, circuits.location \nFROM circuits \nJOIN races ON races.circuitId = circuits.circuitId \nWHERE races.name = 'European Grand Prix' \nORDER BY races.year ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1241": {
        "db_id": "thrombosis_prediction",
        "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
        "ground_truth": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "amends": [
            "Do use `SUM(CASE WHEN condition THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN condition THEN 1 END)` to properly count conditional cases. Do reference column `PLT` from table `T2` instead of `platelet` from table `patients`. Do change the threshold from `< 150` to `<= 100` for low values and from `> 450` to `>= 400` for high values. Do subtract the high count from the low count instead of counting them as separate columns. Do join table `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying a single table. Do remove the `WHERE` filter for platelet IS NOT NULL and range conditions since the CASE expressions handle the conditions internally. The amended query now correctly calculates the net difference between low and high platelet counts by joining patient and laboratory data with appropriate clinical thresholds."
        ],
        "rules": [
            "1) When answering about platelet level comparisons: join table \"Patient\" as T1 with \"Laboratory\" as T2 using T1.ID = T2.ID to link patient and laboratory data. 2) When counting patients with abnormal platelet levels: use column T2.PLT instead of \"platelet\" from a single table. 3) When identifying low platelet levels: consider values <= 100 as lower than normal range. 4) When identifying high platelet levels: consider values >= 400 as higher than normal range. 5) When counting conditional cases: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for proper counting. 6) When comparing low vs high platelet counts: subtract the high count from the low count to get the net difference instead of showing separate columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN platelet < 150 THEN 1 END) AS low_platelet_count,\n    COUNT(CASE WHEN platelet > 450 THEN 1 END) AS high_platelet_count\nFROM patients\nWHERE platelet IS NOT NULL AND (platelet < 150 OR platelet > 450);",
            "SELECT \n    SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS net_difference\nFROM \n    Patient AS T1\nJOIN \n    Laboratory AS T2 ON T1.ID = T2.ID;"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) AS net_difference\nFROM \n    Patient T1\nJOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.PLT <= 100 OR T2.PLT >= 400;"
        ],
        "amend_res": 1
    },
    "911": {
        "db_id": "formula_1",
        "question": "Which of these circuits is located at a higher latitude, Silverstone Circuit, Hockenheimring or Hungaroring?",
        "ground_truth": "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1",
        "amends": [
            "Do remove `latitude` from the SELECT list instead of including it. Do change the ORDER BY clause to use `lat` instead of `latitude` for sorting. The amended query now correctly selects only the name column and orders by the lat column to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about latitude comparison between specific circuits: use the exact circuit names 'Silverstone Circuit', 'Hockenheimring', and 'Hungaroring' as specified in the question. 2) When selecting data about circuit locations: include only the circuit name in the output, not the latitude coordinate. 3) When ordering circuits by latitude: use the column \"lat\" from the circuits table instead of \"latitude\" for sorting. 4) When finding the circuit at the highest latitude: sort by \"lat\" in descending order and return only the top result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, latitude FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY latitude DESC LIMIT 1;",
            "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1448": {
        "db_id": "student_club",
        "question": "Find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars.",
        "ground_truth": "SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.expense_description = 'Pizza' AND T3.cost > 50 AND T3.cost < 100",
        "amends": [
            "Do select `T1.event_name` and `T1.event_date` instead of `name` and `date`. Do add `INNER JOIN budget AS T2` on `T1.event_id = T2.link_to_event` instead of omitting the budget table. Do add `INNER JOIN expense AS T3` on `T2.budget_id = T3.link_to_budget` instead of omitting the expense table. Do filter on `T3.expense_description = 'Pizza'` instead of `expense_type = 'pizza'`. Do filter on `T3.cost > 50` and `T3.cost < 100` instead of `amount` conditions. The amended query now correctly joins the necessary tables and filters on the appropriate expense-related columns to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for event name and date: select T1.event_name and T1.event_date as output columns. 2) When combining events, budget, and expense tables: link events (T1) to budget (T2) using T1.event_id = T2.link_to_event, then link budget (T2) to expense (T3) using T2.budget_id = T3.link_to_budget, keeping only matching pairs (inner joins). 3) When filtering for pizza expenses: filter on T3.expense_description = 'Pizza' (exact case and spelling). 4) When filtering for expenses between fifty and one hundred dollars: filter on T3.cost > 50 AND T3.cost < 100 (exclusive range)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM events WHERE expense_type = 'pizza' AND amount > 50 AND amount < 100;",
            "SELECT T1.event_name, T1.event_date\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T3.expense_description = 'Pizza'\nAND T3.cost > 50\nAND T3.cost < 100;"
        ],
        "rule_sql": [
            "SELECT T1.event_name, T1.event_date\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T3.expense_description = 'Pizza'\nAND T3.cost > 50\nAND T3.cost < 100;"
        ],
        "amend_res": 1
    },
    "398": {
        "db_id": "card_games",
        "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
        "ground_truth": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
        "amends": [
            "Do select `manaCost` instead of `SUM(mana_cost)` to retrieve individual values rather than an aggregate sum. Do filter on `artist = 'Rob Alexander'` instead of `creator = 'Rob Alexander'` to use the correct artist column name. Do remove the `converted_mana_cost IS NULL` condition instead of keeping it to include all cards by the specified artist regardless of mana cost values. The amended query now correctly retrieves mana cost values for cards created by Rob Alexander without unnecessary aggregation or filtering."
        ],
        "rules": [
            "1) When the question asks about \"mana cost\" of cards: use the exact column token \"manaCost\" from the cards table to retrieve individual mana cost values. 2) When the question mentions cards \"created by Rob Alexander\": filter using the exact condition \"artist = 'Rob Alexander'\" to match cards by this specific artist. 3) When retrieving mana cost values: do not apply aggregation functions like SUM() since the question asks for individual values rather than a total sum. 4) When filtering for artist: do not include additional conditions about converted mana cost being NULL, as the question includes all cards by the specified artist regardless of mana cost values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(mana_cost) FROM cards WHERE creator = 'Rob Alexander' AND converted_mana_cost IS NULL;",
            "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander';"
        ],
        "rule_sql": [
            "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'"
        ],
        "amend_res": 1
    },
    "1049": {
        "db_id": "european_football_2",
        "question": "How many matches in the 2015/2016 season were held in Scotland Premier League\n?",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2015/2016' AND t1.name = 'Scotland Premier League'",
        "amends": [
            "Do select `COUNT(t2.id)` instead of `COUNT(*)` to count specific non-null values. Do add `League AS t1` and `Match AS t2` as source tables instead of only `matches`. Do use `INNER JOIN` with `t1.id = t2.league_id` instead of querying a single table. Do change the country filter to `t1.name = 'Scotland Premier League'` instead of `country = 'Scotland'` to properly reference the league name. Do keep the season filter `t2.season = '2015/2016'` but reference it through the joined table instead of directly. The amended query now correctly counts matches for the specific league by properly joining the league and match tables and using the appropriate filtering conditions."
        ],
        "rules": [
            "1) When answering about matches in a specific league: use tables League as T1 and Match as T2 with an inner join on T1.id = T2.league_id. 2) When the question mentions \"Scotland Premier League\": use exact literal 'Scotland Premier League' for T1.name filter. 3) When the question mentions \"2015/2016 season\": use exact literal '2015/2016' for T2.season filter. 4) When counting matches: count T2.id values instead of all rows to count specific non-null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE season = '2015/2016' AND country = 'Scotland'",
            "SELECT COUNT(t2.id) \nFROM League AS t1 \nINNER JOIN Match AS t2 ON t1.id = t2.league_id \nWHERE t1.name = 'Scotland Premier League' \nAND t2.season = '2015/2016'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.id) \nFROM League AS T1 \nINNER JOIN Match AS T2 ON T1.id = T2.league_id \nWHERE T1.name = 'Scotland Premier League' \nAND T2.season = '2015/2016'"
        ],
        "amend_res": 1
    },
    "91": {
        "db_id": "financial",
        "question": "The average unemployment ratio of 1995 and 1996, which one has higher percentage?",
        "ground_truth": "SELECT DISTINCT IIF(AVG(A13) > AVG(A12), '1996', '1995') FROM district",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to ensure unique results. Do use `IIF(AVG(A13) > AVG(A12), '1996', '1995')` instead of `year, AVG(unemployment_ratio) as avg_unemployment` to return a conditional single value based on aggregate comparisons. Do query from `district` table instead of `unemployment_data` as the data source. Do remove the `WHERE year IN (1995, 1996)` filter since the conditional logic handles the year selection. Do remove `GROUP BY year` as the query returns a single aggregated result. Do remove `ORDER BY avg_unemployment DESC LIMIT 1` since the IIF function directly determines the output without sorting. The amended query now correctly returns either '1996' or '1995' based on the comparison of average values from columns A13 and A12 in the district table."
        ],
        "rules": [
            "1) When answering about average unemployment ratio comparison between 1995 and 1996: use IIF(AVG(A13) > AVG(A12), '1996', '1995') to return a single conditional value instead of multiple rows. 2) When the question mentions \"unemployment ratio\": use columns A13 and A12 from the district table instead of unemployment_ratio from unemployment_data. 3) When computing averages for comparison: calculate AVG(A13) for 1996 and AVG(A12) for 1995 from the district table. 4) When the data source is specified: query from the district table instead of unemployment_data. 5) When returning a single conditional result: remove GROUP BY, WHERE filters for specific years, and ORDER BY/LIMIT clauses since the IIF function handles the comparison directly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    year,\n    AVG(unemployment_ratio) as avg_unemployment\nFROM unemployment_data\nWHERE year IN (1995, 1996)\nGROUP BY year\nORDER BY avg_unemployment DESC\nLIMIT 1;",
            "SELECT IIF(AVG(A13) > AVG(A12), '1996', '1995') AS higher_year FROM district;"
        ],
        "rule_sql": [
            "SELECT IIF(AVG(A13) > AVG(A12), '1996', '1995') AS higher_unemployment_year FROM district;"
        ],
        "amend_res": 1
    },
    "632": {
        "db_id": "codebase_community",
        "question": "How many votes were made by Harlan?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN votes AS T3 ON T3.PostId = T2.PostId WHERE T1.DisplayName = 'Harlan'",
        "amends": [
            "Do select `COUNT(T1.Id)` instead of `COUNT(*)` to count specific user IDs rather than all rows. Do add joins to `users AS T1` and `postHistory AS T2` with `ON T1.Id = T2.UserId` instead of querying only the votes table, and add another join to `votes AS T3` with `ON T3.PostId = T2.PostId` instead of directly filtering votes. Do change the filter to `T1.DisplayName = 'Harlan'` instead of `voter_name = 'Harlan'` to correctly identify the user by display name rather than assuming a voter_name field. The amended query now properly counts votes from posts created by the user with display name 'Harlan' rather than incorrectly counting votes where voter_name equals 'Harlan', matching the intended behavior."
        ],
        "rules": [
            "1) When counting votes: use COUNT(T1.Id) to count specific user IDs rather than all rows. 2) When identifying a user by name: use T1.DisplayName = 'Harlan' instead of voter_name to correctly identify the user by display name. 3) When combining user and vote data: join users AS T1 to postHistory AS T2 using T1.Id = T2.UserId, then join to votes AS T3 using T3.PostId = T2.PostId to properly link votes to posts created by the user."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE voter_name = 'Harlan';",
            "SELECT COUNT(T3.Id) \nFROM users AS T1 \nJOIN postHistory AS T2 ON T1.Id = T2.UserId \nJOIN votes AS T3 ON T3.PostId = T2.PostId \nWHERE T1.DisplayName = 'Harlan'"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.Id) \nFROM users AS T1 \nJOIN postHistory AS T2 ON T1.Id = T2.UserId \nJOIN votes AS T3 ON T3.PostId = T2.PostId \nWHERE T1.DisplayName = 'Harlan'"
        ],
        "amend_res": 1
    },
    "117": {
        "db_id": "financial",
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "ground_truth": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "amends": [
            "Do use `SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END)` instead of `COUNT(*)` to calculate the paid amount value rather than counting rows. Do calculate percentage as `(paid_amount * 100) / total_amount` instead of `(count * 100.0) / total_count` to properly weight by monetary value rather than count. Do reference the `amount` column instead of ignoring it to ensure the calculation reflects actual financial amounts. Do filter for status `'A'` instead of `'paid'` to match the correct status code. Do use `CAST(... AS REAL)` instead of implicit casting to ensure proper numeric division. Do remove the unnecessary subquery and instead use aggregate functions directly in the main query to compute both numerator and denominator from the same table scan. The amended query now correctly calculates the percentage of paid loan amount rather than the percentage of paid loan records, matching the RIGHT_SQL's financial-focused behavior."
        ],
        "rules": [
            "1) When calculating percentage of loan amount paid: use SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) to calculate paid amount value rather than counting rows. 2) When computing percentage of paid loan amount: calculate as (paid_amount * 100) / total_amount instead of (count * 100.0) / total_count to properly weight by monetary value. 3) When filtering for fully paid loans: use status = 'A' instead of 'paid' to match the correct status code. 4) When performing numeric division: use CAST(... AS REAL) instead of implicit casting to ensure proper numeric division. 5) When computing aggregates from the same table: use aggregate functions directly in the main query instead of unnecessary subqueries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM loans)) AS percentage_paid FROM loans WHERE status = 'paid';",
            "SELECT \n    (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0) / SUM(amount) AS percentage_paid\nFROM \n    loan"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0) / SUM(amount) AS percentage_paid\nFROM \n    loan;"
        ],
        "amend_res": 1
    },
    "1242": {
        "db_id": "thrombosis_prediction",
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "amends": [
            "Do select `DISTINCT T1.ID` instead of `*` and add explicit table aliases. Do join `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.PLT BETWEEN 100 AND 400` instead of `platelet_level = 'normal'` for numeric range checking. Do calculate age dynamically using `STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50` instead of static `age < 50` to ensure age is computed relative to the lab date. Do filter by `STRFTIME('%Y', T2.Date) = '1984'` instead of `year = 1984` to extract the year from the actual date field. The amended query now correctly joins patient and laboratory data, uses proper date calculations for age determination, and implements precise numeric range filtering for platelet levels, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about laboratory examinations in 1984: filter to only include records where STRFTIME('%Y', T2.Date) = '1984' exactly. 2) When determining patient age: calculate age dynamically using STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 to ensure age is computed relative to the lab date. 3) When checking for normal platelet levels: filter on T2.PLT BETWEEN 100 AND 400 for numeric range checking instead of text matching. 4) When combining patient and laboratory data: join Laboratory AS T2 with Patients AS T1 using INNER JOIN on T1.ID = T2.ID to link related records. 5) When selecting patient identifiers: use DISTINCT T1.ID instead of all columns to avoid duplicate patient entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients WHERE year = 1984 AND age < 50 AND platelet_level = 'normal';",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.Date) = '1984'\n  AND (STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) < 50\n  AND T2.PLT BETWEEN 100 AND 400"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.Date) = '1984'\n  AND (STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday)) < 50\n  AND T2.PLT BETWEEN 100 AND 400;"
        ],
        "amend_res": 1
    },
    "894": {
        "db_id": "formula_1",
        "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
        "ground_truth": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
        "amends": [
            "Do select `T2.milliseconds`, `T1.forename`, `T1.surname`, and `T3.name` instead of `driver`, `race`, and `MIN(lap_time)`. Do join from `drivers AS T1` instead of just `lap_times`. Do add `INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId` instead of omitting the drivers table join. Do add `INNER JOIN races AS T3 ON T2.raceId = T3.raceId` instead of omitting the races table join. Do remove `GROUP BY driver, race` instead of keeping the grouping. Do order by `T2.milliseconds ASC` instead of `lap_time ASC`. The amended query now correctly retrieves the fastest lap time with driver and race details by properly joining the necessary tables and ordering by milliseconds instead of using aggregation."
        ],
        "rules": [
            "1) When answering about \"best lap time recorded\": make sure the output order: T2.milliseconds, T1.forename, T1.surname, T3.name 2) When the question mentions \"driver\": \"driver\" actually means \"T1.forename and T1.surname in schema\" 3) When the question mentions \"race\": \"race\" actually means \"T3.name in schema\" 4) When the question mentions \"lap time\": \"lap time\" actually means \"T2.milliseconds in schema\" 5) When combining T1 (drivers) and T2 (lapTimes) for shared entities: link rows where T1.driverId = T2.driverId exactly as shown in the amends; keep only matching pairs (inner match) 6) When combining T2 (lapTimes) and T3 (races) for shared entities: link rows where T2.raceId = T3.raceId exactly as shown in the amends; keep only matching pairs (inner match) 7) When the question asks for \"best lap time\" (minimum time): order rows by T2.milliseconds ASC and keep the first 1 row 8) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for identifiers like T2.milliseconds, T1.forename, T1.surname, T3.name, T1.driverId, T2.driverId, T2.raceId, T3.raceId"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver, race, MIN(lap_time) FROM lap_times GROUP BY driver, race ORDER BY lap_time ASC LIMIT 1;",
            "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name\nFROM drivers T1\nINNER JOIN lapTimes T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "673": {
        "db_id": "codebase_community",
        "question": "What is the average number of posts voted by the oldest users?",
        "ground_truth": "SELECT AVG(PostId) FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = ( SELECT MAX(Age) FROM users ) )",
        "amends": [
            "Do use `AVG(PostId)` instead of `AVG(post_count)` and move the calculation to the `votes` table instead of `users`. Do add a `WHERE` filter with `UserId IN` subquery instead of omitting filtering entirely. Do replace the `ORDER BY age DESC LIMIT 10` with a subquery that selects `Id FROM users WHERE Age = (SELECT MAX(Age) FROM users)` instead of ordering and limiting. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them, as the right query calculates the average of votes from users with maximum age rather than averaging the top 10 users by age. The amended query now correctly calculates the average PostId from votes made by users who have the maximum age, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average number of posts voted by the oldest users\": calculate the average of PostId from the votes table. 2) When identifying the oldest users: select users where Age equals the maximum Age value from all users. 3) When filtering votes by the oldest users: include only votes where UserId matches the Id of users with maximum Age. 4) When computing the average: use AVG(PostId) instead of any other aggregate function or column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(post_count) FROM users ORDER BY age DESC LIMIT 10;",
            "SELECT AVG(PostId) \nFROM votes \nWHERE UserId IN (\n    SELECT Id \n    FROM users \n    WHERE Age = (SELECT MAX(Age) FROM users)\n)"
        ],
        "rule_sql": [
            "SELECT AVG(v.PostId) AS average_posts_voted\nFROM votes v\nWHERE v.UserId IN (\n    SELECT u.Id\n    FROM users u\n    WHERE u.Age = (SELECT MAX(Age) FROM users)\n);"
        ],
        "amend_res": 1
    },
    "758": {
        "db_id": "superhero",
        "question": "Provide the hair colour of the human superhero who is 185 cm tall.",
        "ground_truth": "SELECT DISTINCT T3.colour FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T1.height_cm = 185 AND T2.race = 'Human'",
        "amends": [
            "Do use `DISTINCT T3.colour` instead of `hair_color` without distinct. Do join `superhero AS T1` instead of querying `superheroes` directly. Do add `INNER JOIN race AS T2 ON T1.race_id = T2.id` instead of omitting the race table. Do use `INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id` instead of directly selecting hair_color. Do use `T1.height_cm = 185` instead of `height = 185`. Do use `T2.race = 'Human'` instead of `species = 'human'`. The amended query now correctly joins multiple tables to retrieve hair color information with proper relationships and filtering."
        ],
        "rules": [
            "1) When answering about hair colour of human superheroes: use DISTINCT T3.colour instead of hair_color without distinct. 2) When querying superhero data: join superhero AS T1 instead of querying superheroes directly. 3) When filtering by race: add INNER JOIN race AS T2 ON T1.race_id = T2.id to access race information. 4) When accessing hair colour information: use INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id instead of directly selecting hair_color. 5) When filtering by height: use T1.height_cm = 185 instead of height = 185. 6) When filtering for human species: use T2.race = 'Human' instead of species = 'human'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hair_color FROM superheroes WHERE height = 185 AND species = 'human';",
            "SELECT DISTINCT T3.colour\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T1.height_cm = 185\nAND T2.race = 'Human'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.colour\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T1.height_cm = 185\nAND T2.race = 'Human'"
        ],
        "amend_res": 1
    },
    "1446": {
        "db_id": "student_club",
        "question": "Calculate the percentage of zip codes that are PO boxes.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(zip_code) FROM zip_code",
        "amends": [
            "Do use `SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN zip_code LIKE '%PO BOX%' THEN 1 END)` to properly count PO Box occurrences. Do reference `type = 'PO Box'` instead of pattern matching `zip_code LIKE '%PO BOX%'` for more accurate identification. Do cast the sum to `REAL` instead of using `100.0` to ensure proper floating-point division. Do divide by `COUNT(zip_code)` instead of `COUNT(*)` to exclude null values from the denominator. Do remove the alias `percentage_po_box` instead of keeping it. The amended query now correctly calculates the percentage of PO Box addresses using proper counting logic and data type handling."
        ],
        "rules": [
            "1) When counting PO Box addresses: use exact literal comparison \"type = 'PO Box'\" instead of pattern matching on zip_code. 2) When calculating percentage of PO Box addresses: count occurrences using SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) instead of COUNT with pattern matching. 3) When performing division for percentage calculation: cast the numerator to REAL data type for proper floating-point arithmetic. 4) When calculating the denominator for percentage: use COUNT(zip_code) instead of COUNT(*) to exclude null values from the count. 5) When formatting the final output: do not include an alias for the percentage calculation result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN zip_code LIKE '%PO BOX%' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_po_box FROM addresses;",
            "SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) FROM zip_code;"
        ],
        "rule_sql": [
            "SELECT (CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) / COUNT(zip_code)) * 100 FROM zip_code;",
            "SELECT (SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) * 100.0 / COUNT(zip_code)) FROM zip_code;"
        ],
        "amend_res": 1
    },
    "980": {
        "db_id": "formula_1",
        "question": "List the reference name of the drivers who passed the second qualifying lap during race no. 23. Indicate their nationality and birthday.",
        "ground_truth": "SELECT T2.driverRef, T2.nationality, T2.dob FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.raceId = 23 AND T1.q2 IS NOT NULL",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `q` and `d`. Do select columns `driverRef`, `nationality`, and `dob` instead of `reference_name`, `nationality`, and `birthday`. Do use `INNER JOIN` with condition `T1.driverId = T2.driverId` instead of `JOIN` with `d.driver_id = q.driver_id`. Do filter on `T1.raceId = 23` instead of `q.race_id = 23`. Do add filter `T1.q2 IS NOT NULL` instead of filtering on `q.lap_number = 2` and `q.position = 1`. The amended query now correctly retrieves qualifying session data using the q2 time presence check rather than incorrect lap and position filters."
        ],
        "rules": [
            "1) When answering about drivers who passed the second qualifying lap: use the presence of q2 time (T1.q2 IS NOT NULL) instead of filtering by lap number and position. 2) When the question mentions \"reference name\": \"reference name\" actually means \"driverRef in schema\" and should be selected as T2.driverRef. 3) When the question mentions \"birthday\": \"birthday\" actually means \"dob in schema\" and should be selected as T2.dob. 4) When combining qualifying and drivers tables: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match). 5) When filtering for race no. 23: use T1.raceId = 23 exactly as specified. 6) When selecting output columns: make sure the output order is T2.driverRef, T2.nationality, T2.dob."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.reference_name, d.nationality, d.birthday \nFROM drivers d \nJOIN qualifying q ON d.driver_id = q.driver_id \nWHERE q.race_id = 23 \nAND q.lap_number = 2 \nAND q.position = 1;",
            "SELECT T2.driverRef, T2.nationality, T2.dob\nFROM qualifying T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.raceId = 23\nAND T1.q2 IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T2.driverRef, T2.nationality, T2.dob \nFROM qualifying T1 \nINNER JOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T1.raceId = 23 AND T1.q2 IS NOT NULL"
        ],
        "amend_res": 1
    },
    "311": {
        "db_id": "toxicology",
        "question": "How many molecules without sulphur element is not having double bond?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element <> 's' AND T2.bond_type <> '='",
        "amends": [
            "Do select `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(*)` to count distinct molecules rather than all rows. Do use `atom AS T1` and `bond AS T2` as FROM sources instead of just `molecules`, and do `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying a single table. Do filter with `T1.element <> 's'` instead of `element != 'S'` for case sensitivity and proper table reference, and do add `T2.bond_type <> '='` instead of `double_bond = 0` to properly identify single bonds. The amended query now correctly counts distinct molecules with non-sulfur atoms that have single bonds, matching the intended behavior."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(DISTINCT T1.molecule_id) instead of COUNT(*) to count distinct molecules rather than all rows. 2) When combining atom and bond information: use atom AS T1 and bond AS T2 as FROM sources and perform INNER JOIN on T1.molecule_id = T2.molecule_id instead of querying a single table. 3) When filtering for non-sulfur elements: use T1.element <> 's' instead of element != 'S' for case sensitivity and proper table reference. 4) When filtering for single bonds: use T2.bond_type <> '=' instead of double_bond = 0 to properly identify single bonds."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE element != 'S' AND double_bond = 0;",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.element <> 's' AND T2.bond_type <> '='"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.element <> 's' \nAND T2.bond_type <> '=';"
        ],
        "amend_res": 1
    },
    "1167": {
        "db_id": "thrombosis_prediction",
        "question": "For the year that concluded on December 31, 1998, how many male patients on average were tested in the lab each month?",
        "ground_truth": "SELECT CAST(COUNT(T1.ID) AS REAL) / 12 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.Date) = '1998' AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(T1.ID)` instead of `AVG(COUNT(patient_id))` to count patients rather than averaging counts. Do join `Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only `lab_tests` to properly relate patient and lab data. Do filter with `T1.SEX = 'M'` instead of `gender = 'male'` using the correct column name and value format. Do use `STRFTIME('%Y', T2.Date) = '1998'` instead of `test_date BETWEEN '1998-01-01' AND '1998-12-31'` for year-based filtering. Do remove `GROUP BY MONTH(test_date)` instead of grouping by month since the right query calculates an annual average. Do add `CAST(COUNT(T1.ID) AS REAL) / 12` instead of the incorrect aggregation to properly compute the monthly average count. The amended query now correctly calculates the average monthly count of male patients with lab tests in 1998.",
            "Do remove `DISTINCT` from `COUNT` instead of keeping it, as the join condition already ensures unique patient IDs. Do remove the alias `average_male_patients_per_month` instead of including it, as the RIGHT_SQL omits column aliases. Do maintain the same `INNER JOIN` on `T1.ID = T2.ID` and preserve both `WHERE` filters for `T1.SEX = 'M'` and `STRFTIME('%Y', T2.Date) = '1998'` without changing their order or logic. The amended query now correctly calculates the average without unnecessary DISTINCT while maintaining the same filtering logic and join conditions."
        ],
        "rules": [
            "1) When answering about average monthly count of male patients tested in 1998: use COUNT(T1.ID) to count patients rather than averaging counts. 2) When combining patient and laboratory data: join Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to properly relate patient and lab data. 3) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male' using the correct column name and value format. 4) When filtering for the year 1998: use STRFTIME('%Y', T2.Date) = '1998' for year-based filtering instead of date range. 5) When calculating monthly average: use CAST(COUNT(T1.ID) AS REAL) / 12 to properly compute the monthly average count and remove grouping by month since it calculates an annual average.",
            "1) When counting patients in a laboratory context: use COUNT(T1.ID) without DISTINCT since the join condition T1.ID = T2.ID already ensures unique patient IDs. 2) When the question asks about male patients: filter using T1.SEX = 'M' exactly as specified. 3) When the question specifies the year 1998: filter using STRFTIME('%Y', T2.Date) = '1998' to match the exact year. 4) When calculating monthly averages from annual data: divide the annual count by 12 to get the average per month. 5) When outputting results: omit column aliases as the question does not require them."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(COUNT(patient_id)) \nFROM lab_tests \nWHERE gender = 'male' \nAND test_date BETWEEN '1998-01-01' AND '1998-12-31' \nGROUP BY MONTH(test_date);",
            "SELECT CAST(COUNT(DISTINCT T1.ID) AS REAL) / 12 AS average_male_patients_per_month\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND STRFTIME('%Y', T2.Date) = '1998';",
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND STRFTIME('%Y', T2.Date) = '1998'"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T1.ID) AS REAL) / 12\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND STRFTIME('%Y', T2.Date) = '1998'"
        ],
        "amend_res": 1
    },
    "245": {
        "db_id": "toxicology",
        "question": "What is the average number of bonds the atoms with the element iodine have?",
        "ground_truth": "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'i'",
        "amends": [
            "Do use `CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id)` instead of `AVG(bond_count)` to calculate the average bonds per atom. Do specify `atom AS T1 INNER JOIN connected AS T2` instead of just `atoms` to properly join the tables. Do add the join condition `ON T1.atom_id = T2.atom_id` instead of omitting it. Do change the filter to `T1.element = 'i'` instead of `element = 'iodine'` for correct element abbreviation. The amended query now correctly calculates the average number of bonds per iodine atom by joining the atom and connected tables and using proper count division instead of a direct average function."
        ],
        "rules": [
            "1) When calculating average bonds per atom: use CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) instead of AVG(bond_count) to properly compute the ratio. 2) When joining atom and connected tables: specify atom AS T1 INNER JOIN connected AS T2 with the join condition ON T1.atom_id = T2.atom_id to link related records. 3) When filtering for iodine atoms: use T1.element = 'i' instead of 'iodine' to match the correct element abbreviation format. 4) When counting bonds per atom: use T2.bond_id for bond counting and T1.atom_id for atom counting to ensure accurate ratio calculation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bond_count) FROM atoms WHERE element = 'iodine';",
            "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) AS average_bonds\nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'i'"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) AS average_bonds\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'i'"
        ],
        "amend_res": 1
    },
    "64": {
        "db_id": "california_schools",
        "question": "What is the total number of schools with a mailing city in Hickman belonging to the charter number 00D4?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(*) FROM schools WHERE CharterNum = '00D4' AND MailCity = 'Hickman'",
        "amends": [
            "Do use column name `CharterNum` instead of `charter_number` and `MailCity` instead of `mailing_city` in the WHERE clause filters, while maintaining the same logical AND condition structure. The amended query now correctly references the actual column names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"mailing city\": \"mailing city\" actually means \"MailCity\" in the schools table. 2) When the question mentions \"charter number\": \"charter number\" actually means \"CharterNum\" in the schools table. 3) When filtering for schools with a specific mailing city and charter number: use exact string literals 'Hickman' for MailCity and '00D4' for CharterNum with AND conditions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE mailing_city = 'Hickman' AND charter_number = '00D4';",
            "SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM schools WHERE MailCity = 'Hickman' AND CharterNum = '00D4'"
        ],
        "amend_res": 1
    },
    "563": {
        "db_id": "codebase_community",
        "question": "User No.3025 gave a comment at 20:29:39 on 2014/4/23 to a post, how many favorite counts did that post get?",
        "ground_truth": "SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.CreationDate = '2014-04-23 20:29:39.0' AND T2.UserId = 3025",
        "amends": [
            "Do select `T1.FavoriteCount` from the `posts` table instead of `favorite_count` from the `comments` table. Do use an `INNER JOIN` between `posts AS T1` and `comments AS T2` on `T1.Id = T2.PostId` instead of querying only the `comments` table. Do filter on `T2.CreationDate = '2014-04-23 20:29:39.0'` instead of separate `date` and `time` columns. Do keep the `T2.UserId = 3025` filter but apply it to the joined table instead of the standalone table. The amended query now correctly retrieves the favorite count from the posts table while joining with comments using the proper relationship and datetime handling."
        ],
        "rules": [
            "1) When answering about favorite counts for a post: select \"T1.FavoriteCount\" from the \"posts\" table instead of from the \"comments\" table. 2) When combining posts and comments tables: link rows where \"T1.Id\" equals \"T2.PostId\" using an inner join between \"posts AS T1\" and \"comments AS T2\". 3) When filtering by user and datetime: apply \"T2.UserId = 3025\" and \"T2.CreationDate = '2014-04-23 20:29:39.0'\" filters to the joined table. 4) When handling datetime values: use the combined datetime format '2014-04-23 20:29:39.0' instead of separate date and time columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT favorite_count FROM comments WHERE user_id = 3025 AND time = '20:29:39' AND date = '2014/4/23';",
            "SELECT T1.FavoriteCount \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T2.UserId = 3025 \nAND T2.CreationDate = '2014-04-23 20:29:39.0'"
        ],
        "rule_sql": [
            "SELECT T1.FavoriteCount \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T1.Id = T2.PostId \nWHERE T2.UserId = 3025 \nAND T2.CreationDate = '2014-04-23 20:29:39.0'"
        ],
        "amend_res": 1
    },
    "181": {
        "db_id": "financial",
        "question": "Please provide the IDs of the 3 female clients with the largest loans.",
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T4 on T1.client_id= T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id  INNER JOIN loan AS T3 ON T2.account_id = T3.account_id and T4.account_id = T3.account_id WHERE T1.gender = 'F' ORDER BY T3.amount DESC LIMIT 3",
        "amends": [
            "Do add joins to `disp`, `account`, and `loan` tables instead of querying only the `clients` table. Do use `INNER JOIN` on `T1.client_id=T4.client_id` and `T4.account_id=T2.account_id` instead of no joins. Do add a second join condition `T4.account_id=T3.account_id` instead of a single join condition. Do filter on `T1.gender='F'` instead of `gender='male'`. Do order by `T3.amount DESC` instead of `loan_amount DESC`. The amended query now correctly joins multiple tables to access loan information and filters for female clients, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about female clients with largest loans: join tables \"clients\" as T1, \"disp\" as T4, \"account\" as T2, and \"loan\" as T3 using inner matches where T1.client_id = T4.client_id, T4.account_id = T2.account_id, and T4.account_id = T3.account_id. 2) When filtering for female clients: use T1.gender = 'F' exactly. 3) When ordering by loan size: sort by T3.amount in descending order. 4) When selecting the top 3: keep only the first 3 rows after ordering. 5) When outputting results: return only the client_id column from T1."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id FROM clients WHERE gender = 'male' ORDER BY loan_amount DESC LIMIT 3;",
            "SELECT T1.client_id\nFROM client T1\nINNER JOIN disp T4 ON T1.client_id = T4.client_id\nINNER JOIN account T2 ON T4.account_id = T2.account_id\nINNER JOIN loan T3 ON T4.account_id = T3.account_id\nWHERE T1.gender = 'F'\nORDER BY T3.amount DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T1.client_id\nFROM client AS T1\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T2 ON T4.account_id = T2.account_id\nINNER JOIN loan AS T3 ON T4.account_id = T3.account_id\nWHERE T1.gender = 'F'\nORDER BY T3.amount DESC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "670": {
        "db_id": "codebase_community",
        "question": "What is the date when the youngest user made his or her first post?",
        "ground_truth": "SELECT T2.CreaionDate FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Age IS NOT NULL ORDER BY T1.Age, T2.CreaionDate LIMIT 1",
        "amends": [
            "Do use `T2.CreaionDate` in the SELECT list instead of `MIN(created_at)`. Do add `users AS T1` and `posts AS T2` as FROM sources instead of only querying the posts table. Do implement `INNER JOIN` on `T1.Id = T2.OwnerUserId` instead of using a subquery with `user_id = (SELECT MAX(user_id) FROM users)`. Do add `WHERE T1.Age IS NOT NULL` filter instead of omitting age filtering. Do add `ORDER BY T1.Age, T2.CreaionDate` instead of no ordering. Do add `LIMIT 1` instead of using MIN aggregation. The amended query now correctly joins user and post data with proper filtering and ordering to find the earliest creation date for users with known ages."
        ],
        "rules": [
            "1) When answering about the date when the youngest user made their first post: make sure the output order includes T2.CreaionDate. 2) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match). 3) When filtering for users with known age: include only rows where T1.Age IS NOT NULL. 4) When finding the youngest user's first post: order rows by T1.Age (ascending for youngest) and T2.CreaionDate (ascending for earliest), then keep only the first row. 5) When selecting the creation date: use T2.CreaionDate instead of MIN(created_at) aggregation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(created_at) FROM posts WHERE user_id = (SELECT MAX(user_id) FROM users);",
            "SELECT T2.CreaionDate\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Age IS NOT NULL\nORDER BY T1.Age, T2.CreaionDate\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.CreaionDate\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Age IS NOT NULL\nORDER BY T1.Age ASC, T2.CreaionDate ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "586": {
        "db_id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "ground_truth": "SELECT T3.DisplayName, T1.Title FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "amends": [
            "Do select specific columns `T3.DisplayName` and `T1.Title` instead of using `SELECT *`. Do join multiple tables with `INNER JOIN votes AS T2 ON T1.Id = T2.PostId` and `INNER JOIN users AS T3 ON T3.Id = T2.UserId` instead of querying only the `users` table. Do filter on `T2.BountyAmount = 50` instead of `bounty_amount = 50` to reference the correct table column. Do filter on `T1.Title LIKE '%variance%'` instead of `post_title LIKE '%variance%'` to use the proper table alias and column name. The amended query now correctly joins the posts, votes, and users tables to find posts with bounty votes matching the criteria, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which user added a bounty amount of 50 to the post title mentioning variance\": make sure the output order: T3.DisplayName, T1.Title. 2) When the question mentions \"bounty amount of 50\": \"bounty amount\" actually means \"T2.BountyAmount = 50\" in schema. 3) When the question mentions \"post title mentioning variance\": \"post title\" actually means \"T1.Title LIKE '%variance%'\" in schema. 4) When combining T1, T2, and T3 for shared entities: link rows where T1.Id = T2.PostId and T3.Id = T2.UserId; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T3.DisplayName, T1.Title, T2.BountyAmount, T1.Id, T2.PostId, T3.Id, and T2.UserId."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM users WHERE bounty_amount = 50 AND post_title LIKE '%variance%';",
            "SELECT T3.DisplayName, T1.Title\nFROM posts AS T1\nINNER JOIN votes AS T2 ON T1.Id = T2.PostId\nINNER JOIN users AS T3 ON T3.Id = T2.UserId\nWHERE T2.BountyAmount = 50\nAND T1.Title LIKE '%variance%'"
        ],
        "rule_sql": [
            "SELECT T3.DisplayName, T1.Title\nFROM posts T1\nJOIN votes T2 ON T1.Id = T2.PostId\nJOIN users T3 ON T3.Id = T2.UserId\nWHERE T2.BountyAmount = 50\nAND T1.Title LIKE '%variance%'"
        ],
        "amend_res": 1
    },
    "648": {
        "db_id": "codebase_community",
        "question": "Provide the users' display names and available website URLs of the post with favorite count of more than 150.",
        "ground_truth": "SELECT T1.DisplayName, T1.WebsiteUrl FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.FavoriteCount > 150",
        "amends": [
            "Do use `T1.DisplayName` and `T1.WebsiteUrl` instead of `u.display_name` and `p.website_url` for column selection. Do use `INNER JOIN` with table aliases `AS T1` and `AS T2` instead of simple `JOIN` with aliases `u` and `p`. Do join on `T1.Id = T2.OwnerUserId` instead of `u.user_id = p.user_id` for the correct join condition. Do filter on `T2.FavoriteCount > 150` instead of `p.favorite_count > 150` using the proper column name. The amended query now correctly matches the intended behavior with proper column references and join conditions."
        ],
        "rules": [
            "1) When answering about \"users' display names and available website URLs of the post with favorite count of more than 150\": make sure the output order: T1.DisplayName, T1.WebsiteUrl. 2) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.OwnerUserId; keep only matching pairs (inner match). 3) When filtering for posts with favorite count more than 150: include only rows where T2.FavoriteCount > 150."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.display_name, p.website_url \nFROM users u \nJOIN posts p ON u.user_id = p.user_id \nWHERE p.favorite_count > 150",
            "SELECT T1.DisplayName, T1.WebsiteUrl\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE T2.FavoriteCount > 150"
        ],
        "rule_sql": [
            "SELECT u.DisplayName, u.WebsiteUrl\nFROM users u\nINNER JOIN posts p ON u.Id = p.OwnerUserId\nWHERE p.FavoriteCount > 150"
        ],
        "amend_res": 1
    },
    "1474": {
        "db_id": "debit_card_specializing",
        "question": "Which customers, paying in CZK, consumed the most gas in 2011?",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Date BETWEEN 201101 AND 201112 GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select `T1.CustomerID` instead of `customer_name` and `SUM(gas_consumption)`. Do use `customers AS T1` joined with `yearmonth AS T2` instead of only the `customers` table. Do perform an `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of no join. Do filter with `T1.Currency = 'CZK'` instead of `payment_currency = 'CZK'`. Do filter with `T2.Date BETWEEN 201101 AND 201112` instead of `year = 2011`. Do group by `T1.CustomerID` instead of `customer_name`. Do order by `SUM(T2.Consumption)` instead of `total_gas`. The amended query now correctly joins the necessary tables, uses proper date range filtering, and aggregates consumption data appropriately to match the intended behavior.",
            "Do remove `SUM(T2.Consumption)` from the SELECT list instead of including it, and do remove quotes from the date range values `201101` and `201112` instead of treating them as strings. Do add `LIMIT 1` at the end instead of omitting it to return only the top result. The amended query now matches RIGHT_SQL's behavior by selecting only customer IDs with the highest consumption in the specified period."
        ],
        "rules": [
            "1) When answering about customers paying in CZK: filter using T1.Currency = 'CZK' exactly as written. 2) When answering about gas consumption in 2011: filter using T2.Date BETWEEN 201101 AND 201112 inclusive range. 3) When combining customer and consumption data: perform an inner join where T1.CustomerID = T2.CustomerID and keep only matching pairs. 4) When grouping results by customer: group by T1.CustomerID instead of customer_name. 5) When calculating total gas consumption: sum T2.Consumption values. 6) When ordering results to find the highest consumption: order by SUM(T2.Consumption) in descending direction. 7) When selecting output columns: include T1.CustomerID instead of customer_name and the sum of consumption.",
            "1) When the question asks for customers who consumed the most gas: rank customers by total gas consumption in descending order and keep only the top 1 result. 2) When the question specifies paying in CZK: filter customers where T1.Currency equals exactly 'CZK'. 3) When the question specifies the year 2011: filter yearmonth records where T2.Date is between 201101 and 201112 (numeric values without quotes). 4) When combining customers and yearmonth tables: link rows where T1.CustomerID equals T2.CustomerID and keep only matching pairs. 5) When computing gas consumption: sum the T2.Consumption values for each customer. 6) When answering about customers with highest consumption: make sure the output order includes only T1.CustomerID (do not include the sum in the output columns)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name, SUM(gas_consumption) as total_gas\nFROM customers\nWHERE payment_currency = 'CZK' AND year = 2011\nGROUP BY customer_name\nORDER BY total_gas DESC\nLIMIT 1;",
            "SELECT T1.CustomerID, SUM(T2.Consumption) \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Currency = 'CZK' \nAND T2.Date BETWEEN '201101' AND '201112' \nGROUP BY T1.CustomerID \nORDER BY SUM(T2.Consumption) DESC",
            "SELECT T1.CustomerID\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nAND T2.Date BETWEEN 201101 AND 201112\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK'\nAND T2.Date BETWEEN 201101 AND 201112\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "463": {
        "db_id": "card_games",
        "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
        "ground_truth": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
        "amends": [
            "Do query the `set_translations` table instead of the `translations` table. Do add `DISTINCT` to count unique translations instead of counting all rows. Do change the column reference to `translation` instead of using `COUNT(*)`. Do add a subquery in the `WHERE` clause to filter by `setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')` instead of directly filtering by `card_name = 'Angel of Mercy'`. Do add `AND translation IS NOT NULL` to exclude null translations instead of including them. The amended query now correctly counts distinct non-null translations from the appropriate table using the proper relationship through the cards table."
        ],
        "rules": [
            "1) When answering about translations for cards with \"Angel of Mercy\": query the \"set_translations\" table instead of the \"translations\" table. 2) When counting translations: count distinct values of the \"translation\" column instead of counting all rows. 3) When filtering for cards with \"Angel of Mercy\": use a subquery to filter by \"setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')\" instead of directly filtering by card_name. 4) When handling null values: exclude null translations by adding \"AND translation IS NOT NULL\" to the conditions. 5) When combining tables for this relationship: use the \"setCode\" column to link \"set_translations\" with \"cards\" table through the subquery relationship."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM translations WHERE card_name = 'Angel of Mercy';",
            "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy') AND translation IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT translation) \nFROM set_translations \nWHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy') \nAND translation IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "231": {
        "db_id": "toxicology",
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR010 and state whether or not this molecule is carcinogenic?",
        "ground_truth": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do use a subquery with table alias `T1` instead of querying the table directly without aliases. Do reference `T1.bond_type` and `T1.molecule_id` instead of unqualified column names. Do count `T1.molecule_id` instead of using `COUNT(*)` to count bonds per type. Do order by `COUNT(T1.molecule_id)` instead of the alias `count`. Do select only `T.bond_type` from the subquery instead of selecting both `bond_type` and `count` in the main query. The amended query now correctly returns only the bond type with the highest count for molecule 'TR010' instead of returning both the bond type and its count."
        ],
        "rules": [
            "1) When answering about bond types for a specific molecule: use table alias T1 for the bond table and reference columns as T1.bond_type and T1.molecule_id. 2) When counting bonds per type for molecule 'TR010': count using T1.molecule_id instead of counting all rows. 3) When finding the bond type with the highest count: order results by COUNT(T1.molecule_id) in descending order and keep only the top result. 4) When selecting output for the majority bond type: return only T1.bond_type from the subquery, not both the bond type and its count."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT bond_type, COUNT(*) as count \nFROM bonds \nWHERE molecule_id = 'TR010' \nGROUP BY bond_type \nORDER BY count DESC \nLIMIT 1;",
            "SELECT T.bond_type\nFROM (\n    SELECT T1.bond_type, COUNT(T1.molecule_id) AS count\n    FROM bond T1\n    WHERE T1.molecule_id = 'TR010'\n    GROUP BY T1.bond_type\n    ORDER BY COUNT(T1.molecule_id) DESC\n    LIMIT 1\n) T"
        ],
        "rule_sql": [
            "SELECT T1.bond_type, \n       CASE WHEN m.label = 'carcinogenic' THEN 'yes' ELSE 'no' END AS is_carcinogenic\nFROM bond T1\nJOIN molecule m ON T1.molecule_id = m.molecule_id\nWHERE T1.molecule_id = 'TR010'\nGROUP BY T1.bond_type\nORDER BY COUNT(T1.molecule_id) DESC\nLIMIT 1;",
            "SELECT T1.bond_type, \n       (CASE WHEN m.label = 'carcinogenic' THEN 'yes' ELSE 'no' END) AS is_carcinogenic\nFROM bond T1\nJOIN molecule m ON T1.molecule_id = m.molecule_id\nWHERE T1.molecule_id = 'TR010'\nGROUP BY T1.bond_type\nORDER BY COUNT(T1.molecule_id) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "177": {
        "db_id": "financial",
        "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
        "evidence": "",
        "ground_truth": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
        "amends": [
            "Do select `balance` and `gender` columns instead of `SUM(amount)` and a CASE expression. Do join `client` table as T1 instead of `clients` as c, and use `disp` table as T2 as an intermediate join instead of directly joining accounts. Do join `account` table as T3 instead of `accounts` as a, and join `trans` table as T4 instead of `transactions` as t. Do use `trans_id` filter instead of `transaction_id`, and place both client and transaction filters in the WHERE clause instead of separating them across different conditions. Do remove the aggregation and alias assignments instead of keeping them, as the right query returns individual records rather than summarized data."
        ],
        "rules": [
            "1) When answering about client number 4's account balance following transaction 851: select \"balance\" from table \"trans\" instead of using SUM(amount) aggregation. 2) When determining account ownership gender: select \"gender\" from table \"client\" instead of using a CASE expression. 3) When joining tables for client-account-transaction relationships: use \"disp\" table as T2 as an intermediate join between \"client\" as T1 and \"account\" as T3. 4) When filtering by client: use client_id = 4 condition in WHERE clause. 5) When filtering by transaction: use trans_id = 851 condition in WHERE clause instead of transaction_id. 6) When the question asks about a specific transaction's effect: return individual record values rather than aggregated summaries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) as total_sum, \n       CASE WHEN c.gender = 'M' THEN 'man' ELSE 'woman' END as account_owner\nFROM transactions t\nJOIN accounts a ON t.account_id = a.account_id\nJOIN clients c ON a.client_id = c.client_id\nWHERE t.transaction_id = 851\nAND a.client_id = 4;",
            "SELECT T4.balance, T1.gender\nFROM client T1\nJOIN disp T2 ON T1.client_id = T2.client_id\nJOIN account T3 ON T2.account_id = T3.account_id\nJOIN trans T4 ON T3.account_id = T4.account_id\nWHERE T1.client_id = 4 AND T4.trans_id = 851;"
        ],
        "rule_sql": [
            "SELECT t.balance, c.gender\nFROM client c\nJOIN disp d ON c.client_id = d.client_id\nJOIN account a ON d.account_id = a.account_id\nJOIN trans t ON a.account_id = t.account_id\nWHERE c.client_id = 4\nAND t.trans_id = 851;"
        ],
        "amend_res": 1
    },
    "1313": {
        "db_id": "student_club",
        "question": "How many students in the Student_Club are from the College of Engineering?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Engineering'",
        "amends": [
            "Do select `COUNT(T1.member_id)` from specific column instead of `COUNT(*)` from all rows. Do use `member AS T1` and `major AS T2` as source tables instead of only `Student_Club`. Do add `INNER JOIN` on `T1.link_to_major = T2.major_id` instead of no join condition. Do move the college filter to the joined `major` table's `T2.college` instead of applying it to a non-existent column in the original table. The amended query now correctly counts engineering students by joining member and major tables and filtering on the college attribute."
        ],
        "rules": [
            "1) When counting students in the Student_Club: use COUNT(T1.member_id) instead of COUNT(*) to count specific member identifiers. 2) When answering about students from the College of Engineering: use member AS T1 and major AS T2 as source tables instead of only Student_Club. 3) When combining member and major tables: link rows where T1.link_to_major = T2.major_id using an inner join to keep only matching pairs. 4) When filtering for College of Engineering: apply the filter to T2.college = 'College of Engineering' instead of a non-existent column in the original table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Student_Club WHERE college = 'College of Engineering';",
            "SELECT COUNT(T1.member_id) \nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.college = 'College of Engineering'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.member_id) \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T2.college = 'College of Engineering'"
        ],
        "amend_res": 1
    },
    "696": {
        "db_id": "codebase_community",
        "question": "Count the number of posts with a tag specified as 'careers'.",
        "ground_truth": "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers'",
        "amends": [
            "Do query the `tags` table instead of the `posts` table. Do filter on `TagName = 'careers'` instead of `tag = 'career'`. Do count the `Id` column instead of using `COUNT(*)`. The amended query now correctly counts career-related tags from the appropriate table with the proper filter condition."
        ],
        "rules": [
            "1) When the question asks about posts with a specific tag: query the \"tags\" table instead of the \"posts\" table. 2) When filtering for tags specified as 'careers': use the exact literal 'careers' and filter on \"TagName = 'careers'\" instead of 'career'. 3) When counting the number of posts with a tag: count the \"Id\" column from the \"tags\" table instead of using COUNT(*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE tag = 'career';",
            "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM tags WHERE TagName = 'careers'"
        ],
        "amend_res": 1
    },
    "1170": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients hadn't undergone a medical examination until at least a year following their initial hospital visit?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '+' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.`First Date`) >= 1",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count distinct patients rather than all examination records. Do reference tables as `Patient AS T1` and `Examination AS T2` instead of `patients p` and `medical_examinations me`. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of `LEFT JOIN` on `p.patient_id = me.patient_id` to only include patients with examinations. Do add filter `T1.Admission = '+'` instead of omitting admission criteria. Do change date comparison to `STRFTIME('%Y', T2.Examination Date) - STRFTIME('%Y', T1.First Date) >= 1` instead of `me.examination_date < DATE(p.initial_visit_date, '+1 year')` to calculate year difference rather than date range comparison. The amended query now correctly counts distinct patients with positive admission status who had examinations at least one year after their first visit."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count distinct patients rather than all examination records. 2) When referencing tables: use Patient AS T1 and Examination AS T2 as the canonical aliases. 3) When combining Patient and Examination tables: use INNER JOIN on T1.ID = T2.ID to only include patients with examinations. 4) When filtering patients: include only those with T1.Admission = '+' status. 5) When calculating time between initial visit and examination: use STRFTIME('%Y', T2.Examination Date) - STRFTIME('%Y', T1.First Date) >= 1 to calculate year difference rather than date range comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nLEFT JOIN medical_examinations me ON p.patient_id = me.patient_id\nWHERE me.examination_date < DATE(p.initial_visit_date, '+1 year')",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE T1.Admission = '+' \nAND (STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.\"First Date\")) >= 1"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE T1.Admission = '+' \nAND (STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.\"First Date\")) >= 1"
        ],
        "amend_res": 1
    },
    "723": {
        "db_id": "superhero",
        "question": "Among the superheroes with blue eyes, how many of them have the super power of \"Agility\"?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id WHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific hero IDs rather than all rows. Do join `superhero AS T1` instead of querying a single table, and add `hero_power AS T2` with `INNER JOIN` on `T1.id = T2.hero_id` instead of omitting this relationship. Do add `superpower AS T3` with `INNER JOIN` on `T2.power_id = T3.id` to properly access power names, and add `colour AS T4` with `INNER JOIN` on `T1.eye_colour_id = T4.id` to reference colors through a foreign key relationship. Do filter on `T3.power_name = 'Agility'` instead of `super_power = 'Agility'` to use the correct column from the joined table, and do filter on `T4.colour = 'Blue'` instead of `eye_color = 'blue'` to use the proper color table with correct case sensitivity. The amended query now correctly joins multiple tables to establish proper relationships between heroes, their powers, and eye colors, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.id) to count specific hero IDs rather than all rows. 2) When the question mentions superheroes with blue eyes: join colour table T4 on T1.eye_colour_id = T4.id and filter on T4.colour = 'Blue' with exact case. 3) When the question mentions super power of \"Agility\": join superpower table T3 through hero_power table T2 on T2.power_id = T3.id and filter on T3.power_name = 'Agility' with exact spelling. 4) When combining superhero, hero_power, superpower, and colour tables: use INNER JOIN on T1.id = T2.hero_id and T2.power_id = T3.id and T1.eye_colour_id = T4.id to establish proper relationships between heroes, their powers, and eye colors."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE eye_color = 'blue' AND super_power = 'Agility';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nINNER JOIN colour AS T4 ON T1.eye_colour_id = T4.id\nWHERE T3.power_name = 'Agility' AND T4.colour = 'Blue'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nINNER JOIN colour T4 ON T1.eye_colour_id = T4.id\nWHERE T4.colour = 'Blue' AND T3.power_name = 'Agility'"
        ],
        "amend_res": 1
    },
    "373": {
        "db_id": "card_games",
        "question": "Name the cards that were illustrated by Aaron Boyd.",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
        "amends": [
            "Do select `name` instead of `card_name` and add `DISTINCT` instead of omitting it. Do filter on `artist` instead of `illustrator` while keeping the literal value 'Aaron Boyd' unchanged. The amended query now correctly retrieves distinct card names filtered by the artist column instead of the non-existent illustrator column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for card names: use the exact column \"name\" from the cards table instead of \"card_name\". 2) When filtering by artist Aaron Boyd: use the exact column \"artist\" instead of \"illustrator\" while keeping the literal value 'Aaron Boyd' unchanged. 3) When retrieving card names: ensure distinct values are returned to avoid duplicates."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_name FROM cards WHERE illustrator = 'Aaron Boyd';",
            "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "amend_res": 1
    },
    "387": {
        "db_id": "card_games",
        "question": "What are the cards for set OGW? State the colour for these cards.",
        "ground_truth": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
        "amends": [
            "Do select `id, colors` instead of `name, color` in the SELECT list. Do change the FROM source to `cards` instead of keeping it as `cards`. Do replace the WHERE filter with `id IN (subquery)` instead of `set = 'OGW'`. Do add a correlated subquery `SELECT id FROM set_translations WHERE setCode = 'OGW'` instead of omitting it. The amended query now correctly joins through the set_translations table to filter cards by set code rather than relying on a direct set column in the cards table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for cards from set \"OGW\": filter cards using a subquery that selects \"id\" from \"set_translations\" where \"setCode\" equals 'OGW' exactly. 2) When selecting card information: output \"id\" and \"colors\" columns instead of \"name\" and \"color\". 3) When combining card and set information: use the \"id\" column from \"cards\" to match against the subquery results from \"set_translations\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, color FROM cards WHERE set = 'OGW';",
            "SELECT id, colors FROM cards WHERE id IN (SELECT id FROM set_translations WHERE setCode = 'OGW')"
        ],
        "rule_sql": [
            "SELECT c.id, c.colors FROM cards c WHERE c.setCode IN (SELECT setCode FROM set_translations WHERE setCode = 'OGW')",
            "SELECT c.id, c.colors FROM cards c WHERE c.id IN (SELECT st.id FROM set_translations st WHERE st.setCode = 'OGW')"
        ],
        "amend_res": 1
    },
    "325": {
        "db_id": "toxicology",
        "question": "How many carcinogenic molecules that consisted of Nitrogen?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'n' AND T1.label = '+'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(*)` to count unique molecules. Do join `molecule AS T1` with `atom AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table. Do filter on `T2.element = 'n'` instead of `composition LIKE '%N%'` to specifically find nitrogen atoms. Do add `T1.label = '+'` instead of omitting this filter for positive-labeled molecules. Do remove the `carcinogenic = 'yes'` condition instead of keeping it. The amended query now correctly counts distinct molecules containing nitrogen atoms with positive labels, matching the intended behavior."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(DISTINCT T1.molecule_id) instead of COUNT(*) to count unique molecules. 2) When the question mentions molecules consisting of Nitrogen: join molecule AS T1 with atom AS T2 on T1.molecule_id = T2.molecule_id and filter on T2.element = 'n' to specifically find nitrogen atoms. 3) When filtering for positive-labeled molecules: add T1.label = '+' condition. 4) When the question asks about carcinogenic molecules: do not include carcinogenic = 'yes' condition as it should be removed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE carcinogenic = 'yes' AND composition LIKE '%N%';",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nJOIN atom AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.element = 'n' AND T1.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nJOIN atom AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.element = 'n' AND T1.label = '+'"
        ],
        "amend_res": 1
    },
    "433": {
        "db_id": "card_games",
        "question": "What is the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
        "amends": [
            "Do use `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN ... THEN 1 END)` to properly count conditional cases. Do reference `T2.language` and `T1.isOnlineOnly` instead of `language` and `online_only` to match the correct table aliases and column names. Do add explicit `CAST(... AS REAL)` instead of implicit decimal conversion to ensure proper floating-point division. Do change the FROM clause to use `sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode` instead of querying only the `cards` table to establish the correct table relationships. Do remove the WHERE filter `language = 'Chinese Simplified'` instead of keeping it since the condition is now properly handled within the CASE expression. The amended query now correctly calculates the percentage of online-only sets with Chinese Simplified translations by joining the appropriate tables and using proper conditional aggregation."
        ],
        "rules": [
            "1) When calculating percentages with conditional counting: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for proper conditional aggregation. 2) When referencing language information: use T2.language instead of language to match the correct table alias from the join. 3) When referencing online-only status: use T1.isOnlineOnly instead of online_only to match the correct table alias and column name. 4) When performing floating-point division: use explicit CAST(... AS REAL) instead of implicit decimal conversion to ensure proper numeric precision. 5) When combining set information with translations: join sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode instead of querying a single table to establish the correct relationship between sets and their translations. 6) When filtering for specific conditions within aggregate calculations: handle the condition within the CASE expression instead of using a WHERE clause to avoid prematurely filtering the dataset."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN language = 'Chinese Simplified' AND online_only = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards\nWHERE language = 'Chinese Simplified';",
            "SELECT \n    (SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    sets AS T1 \nINNER JOIN \n    set_translations AS T2 ON T1.code = T2.setCode;"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    sets AS T1 \nINNER JOIN \n    set_translations AS T2 ON T1.code = T2.setCode;"
        ],
        "amend_res": 1
    },
    "603": {
        "db_id": "codebase_community",
        "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
        "ground_truth": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
        "amends": [
            "Do use `SUM(DISTINCT FavoriteCount)` instead of `SUM(favorite_count)` to eliminate duplicate values. Do query from `posts` table instead of `tweets` table as the correct data source. Do use a subquery with `Id IN (SELECT PostId FROM postHistory)` instead of directly filtering `user_id` to properly correlate posts with their history. Do reference `UserId = 686` in the subquery's `WHERE` clause instead of the main query's filter. Do use `STRFTIME('%Y', CreationDate) = '2011'` in the subquery instead of the main query to filter by creation year. Do reference `FavoriteCount` column instead of `favorite_count` and `CreationDate` instead of `created_at` to match the correct schema. The amended query now correctly calculates the sum of distinct favorite counts for posts created by user 686 in 2011 through their post history."
        ],
        "rules": [
            "1) When answering about \"sum of favourite count\": use SUM(DISTINCT FavoriteCount) instead of SUM(favorite_count) to eliminate duplicate values. 2) When querying for user posts: use the posts table instead of tweets table as the correct data source. 3) When filtering by user ID: use a subquery with Id IN (SELECT PostId FROM postHistory) instead of directly filtering user_id to properly correlate posts with their history. 4) When specifying user ID 686: reference UserId = 686 in the subquery's WHERE clause instead of the main query's filter. 5) When filtering by year 2011: use STRFTIME('%Y', CreationDate) = '2011' in the subquery instead of the main query to filter by creation year. 6) When referencing schema columns: use FavoriteCount column instead of favorite_count and CreationDate instead of created_at to match the correct schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(favorite_count) FROM tweets WHERE user_id = 686 AND strftime('%Y', created_at) = '2011';",
            "SELECT SUM(DISTINCT FavoriteCount) \nFROM posts \nWHERE Id IN (\n    SELECT PostId \n    FROM postHistory \n    WHERE UserId = 686 \n    AND STRFTIME('%Y', CreationDate) = '2011'\n)"
        ],
        "rule_sql": [
            "SELECT SUM(DISTINCT FavoriteCount) \nFROM posts \nWHERE Id IN (\n    SELECT PostId \n    FROM postHistory \n    WHERE UserId = 686 \n    AND STRFTIME('%Y', CreationDate) = '2011'\n)"
        ],
        "amend_res": 1
    },
    "1248": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients born after 1980/1/1 have an abnormal fibrinogen level?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T1.Birthday > '1980-01-01'",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table to incorporate laboratory data. Do change the fibrinogen condition to `T2.FG <= 150 OR T2.FG >= 450` instead of `fibrinogen_level = 'normal'` to use numeric thresholds rather than a categorical value. Do move the birth date filter to `T1.Birthday > '1980-01-01'` instead of `birth_date > '1980-01-01'` with the correct column name from the joined table. The amended query now correctly counts patients with abnormal fibrinogen levels born after 1980-01-01 by joining laboratory data and using appropriate numeric criteria.",
            "Do move the `T1.Birthday > '1980-01-01'` filter to the end of the WHERE clause instead of placing it at the beginning, and do remove the parentheses around the `T2.FG` conditions instead of keeping them, as the logical operator precedence without parentheses produces the correct behavior where both FG conditions are evaluated against the same Birthday filter. The amended query now correctly counts distinct patients born after 1980-01-01 who have either FG \u2264 150 or FG \u2265 450, matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around `T2.FG <= 150 OR T2.FG >= 450` instead of keeping them, as the parentheses incorrectly group the OR condition and change the logical evaluation order with the AND condition. This amendment ensures the WHERE clause evaluates the conditions with proper operator precedence, where the AND condition `T1.Birthday > '1980-01-01'` applies to both OR conditions rather than being grouped incorrectly. The amended query now matches RIGHT_SQL's behavior with the correct logical evaluation."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows. 2) When incorporating laboratory data: add an INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to link patient and laboratory information. 3) When identifying abnormal fibrinogen levels: use T2.FG <= 150 OR T2.FG >= 450 instead of categorical values to apply numeric thresholds. 4) When filtering by birth date: use T1.Birthday > '1980-01-01' with the exact column name from the patients table. 5) When combining patient and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).",
            "1) When combining Patient table (T1) and Laboratory table (T2): link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 2) When counting distinct patients: compute the number of unique values of T1.ID. 3) When filtering for patients born after 1980/1/1: use the condition T1.Birthday > '1980-01-01'. 4) When filtering for abnormal fibrinogen levels: use the condition T2.FG <= 150 OR T2.FG >= 450 without parentheses. 5) When ordering WHERE clause conditions: place the T1.Birthday > '1980-01-01' filter at the end of the WHERE clause.",
            "1) When the question asks for patients born after 1980/1/1: use the condition T1.Birthday > '1980-01-01' exactly as specified. 2) When the question asks for abnormal fibrinogen level: use the condition T2.FG <= 150 OR T2.FG >= 450 without parentheses to ensure proper operator precedence with AND conditions. 3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match. 4) When counting distinct patients: count distinct values of T1.ID as the canonical patient identifier."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE birth_date > '1980-01-01' AND fibrinogen_level = 'normal';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Birthday > '1980-01-01' \nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.FG <= 150 OR T2.FG >= 450) \nAND T1.Birthday > '1980-01-01'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.FG <= 150 OR T2.FG >= 450\nAND T1.Birthday > '1980-01-01'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.FG <= 150 OR T2.FG >= 450) \nAND T1.Birthday > '1980-01-01'"
        ],
        "amend_res": 1
    },
    "647": {
        "db_id": "codebase_community",
        "question": "Provide the badge names received in 2011 for the user whose location is in the North Pole.",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE STRFTIME('%Y', T2.Date) = '2011' AND T1.Location = 'North Pole'",
        "amends": [
            "Do select `T2.Name` from the `badges` table instead of `badge_name` from `badges` alone. Do join `users AS T1` with `badges AS T2` on `T1.Id = T2.UserId` instead of querying only the `badges` table. Do filter by `STRFTIME('%Y', T2.Date) = '2011'` to extract the year from the date column instead of using a simple `year = 2011` condition. Do filter by `T1.Location = 'North Pole'` on the users table instead of `location = 'North Pole'` on the badges table. The amended query now correctly retrieves badge names for users from the North Pole who earned badges in 2011 by properly joining the users and badges tables and using appropriate date extraction."
        ],
        "rules": [
            "1) When answering about badge names for users from a specific location: join users table as T1 with badges table as T2 on T1.Id = T2.UserId to link user information with their badges. 2) When filtering by year 2011: extract the year from T2.Date column using STRFTIME('%Y', T2.Date) = '2011' instead of using a simple year column. 3) When filtering by location 'North Pole': use T1.Location = 'North Pole' from the users table instead of location from the badges table. 4) When selecting badge names: use T2.Name from the badges table instead of badge_name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM badges WHERE year = 2011 AND location = 'North Pole';",
            "SELECT T2.Name \nFROM users AS T1 \nJOIN badges AS T2 ON T1.Id = T2.UserId \nWHERE T1.Location = 'North Pole' \nAND STRFTIME('%Y', T2.Date) = '2011'"
        ],
        "rule_sql": [
            "SELECT T2.Name \nFROM users AS T1 \nJOIN badges AS T2 ON T1.Id = T2.UserId \nWHERE T1.Location = 'North Pole' \nAND STRFTIME('%Y', T2.Date) = '2011'"
        ],
        "amend_res": 1
    },
    "1371": {
        "db_id": "student_club",
        "question": "How many members attended the \"Women's Soccer\" event?",
        "ground_truth": "SELECT COUNT(T2.link_to_member) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [
            "Do select `COUNT(T2.link_to_member)` instead of `COUNT(*)` to count specific attendance records rather than all rows. Do use `event AS T1` and `attendance AS T2` tables instead of just the `events` table to properly join event and attendance data. Do add `INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event` instead of omitting the join to connect events with their attendance records. Do filter on `T1.event_name = 'Women''s Soccer'` instead of `event_name = 'Women\\'s Soccer'` to reference the correct table and use proper SQL string escaping. The amended query now correctly counts attendance records for the specified event rather than counting all events with that name."
        ],
        "rules": [
            "1) When counting attendance for an event: count the specific attendance records using COUNT(T2.link_to_member) instead of counting all rows. 2) When answering about event attendance: use both event AS T1 and attendance AS T2 tables with an inner join where T1.event_id = T2.link_to_event to connect events with their attendance records. 3) When filtering for a specific event name: use T1.event_name = 'Women''s Soccer' with proper SQL string escaping (double single quotes) and reference the correct table alias. 4) When the question mentions \"Women's Soccer\": this exact literal value must be used with proper escaping as 'Women''s Soccer'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM events WHERE event_name = 'Women\\'s Soccer';",
            "SELECT COUNT(T2.link_to_member) \nFROM event AS T1 \nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'Women''s Soccer'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.link_to_member) \nFROM event AS T1 \nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'Women''s Soccer'"
        ],
        "amend_res": 1
    },
    "1327": {
        "db_id": "student_club",
        "question": "List the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'",
        "amends": [
            "Do select `T1.first_name` and `T1.last_name` from the `member` table instead of selecting `first_name` and `last_name` from a non-existent `Student_Club` table. Do join `member AS T1` with `attendance AS T2` on `T1.member_id = T2.link_to_member` instead of missing these table relationships entirely. Do add an additional join to `event AS T3` on `T2.link_to_event = T3.event_id` instead of omitting the event table connection. Do filter on `T3.event_name = 'Laugh Out Loud'` instead of filtering directly on a non-existent `event_name` column in the wrong table. The amended query now correctly retrieves member names by properly navigating through the attendance and event relationships to filter by event name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for members of Student_Club: use the \"member\" table as T1 to get first_name and last_name. 2) When filtering by event name \"Laugh Out Loud\": join T1 with \"attendance\" as T2 on T1.member_id = T2.link_to_member, then join T2 with \"event\" as T3 on T2.link_to_event = T3.event_id, and filter where T3.event_name = 'Laugh Out Loud'. 3) When combining tables for attendance relationships: perform inner joins using the exact key equalities T1.member_id = T2.link_to_member and T2.link_to_event = T3.event_id to ensure only matching pairs are kept."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM Student_Club WHERE event_name = 'Laugh Out Loud';",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nJOIN attendance AS T2 ON T1.member_id = T2.link_to_member\nJOIN event AS T3 ON T2.link_to_event = T3.event_id\nWHERE T3.event_name = 'Laugh Out Loud'"
        ],
        "rule_sql": [
            "SELECT m.first_name, m.last_name\nFROM member m\nINNER JOIN attendance a ON m.member_id = a.link_to_member\nINNER JOIN event e ON a.link_to_event = e.event_id\nWHERE e.event_name = 'Laugh Out Loud';"
        ],
        "amend_res": 1
    },
    "372": {
        "db_id": "card_games",
        "question": "How many cards are there with toughness of 99?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE toughness = 99",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE toughness = '99';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cards WHERE toughness = '99';"
        ],
        "amend_res": 1
    },
    "174": {
        "db_id": "financial",
        "question": "What year was account owner number 130 born?",
        "evidence": "",
        "ground_truth": "SELECT STRFTIME('%Y', T1.birth_date) FROM client AS T1 INNER JOIN disp AS T3 ON T1.client_id = T3.client_id INNER JOIN account AS T2 ON T3.account_id = T2.account_id WHERE T2.account_id = 130",
        "amends": [
            "Do select `STRFTIME('%Y', T1.birth_date)` instead of `birth_year` to extract the year from a date field. Do use `FROM client AS T1` instead of `FROM account_owners` to reference the correct table containing birth dates. Do add `INNER JOIN disp AS T3 ON T1.client_id = T3.client_id` and `INNER JOIN account AS T2 ON T3.account_id = T2.account_id` instead of querying a single table, establishing the proper relationships between client, account, and disposition tables. Do filter with `WHERE T2.account_id = 130` instead of `WHERE owner_id = 130` to correctly identify the account by its ID rather than an owner identifier. The amended query now correctly joins related tables and extracts the birth year from the proper date field to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for a year from a birth date: extract the year component from the birth_date field using STRFTIME('%Y', T1.birth_date) instead of using a direct birth_year column. 2) When querying about account owners: use the client table (aliased as T1) instead of account_owners table, as it contains the birth_date field. 3) When establishing relationships between client and account data: join client AS T1 with disp AS T3 using T1.client_id = T3.client_id, then join with account AS T2 using T3.account_id = T2.account_id to properly connect client information to account ownership. 4) When filtering by account number 130: use WHERE T2.account_id = 130 instead of owner_id = 130 to correctly identify the account by its account_id field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT birth_year FROM account_owners WHERE owner_id = 130;",
            "SELECT STRFTIME('%Y', T1.birth_date) AS birth_year\nFROM client AS T1\nINNER JOIN disp AS T3 ON T1.client_id = T3.client_id\nINNER JOIN account AS T2 ON T3.account_id = T2.account_id\nWHERE T2.account_id = 130"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%Y', T1.birth_date) AS birth_year\nFROM client AS T1\nJOIN disp AS T3 ON T1.client_id = T3.client_id\nJOIN account AS T2 ON T3.account_id = T2.account_id\nWHERE T2.account_id = 130;"
        ],
        "amend_res": 1
    },
    "122": {
        "db_id": "financial",
        "question": "State the district and region for loan ID '4990'.",
        "ground_truth": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
        "amends": [
            "Do select `T2.A2` and `T2.A3` instead of `district` and `region`. Do join `account AS T1` and `district AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of omitting these tables. Do add `loan AS T3` with `INNER JOIN` on `T1.account_id = T3.account_id` instead of querying `loans` directly. Do filter on `T3.loan_id = 4990` instead of `loan_id = '4990'`, removing the string quotes and using the correct table alias. The amended query now correctly joins through account and district tables to retrieve the proper district information for the specified loan."
        ],
        "rules": [
            "1) When answering about loan ID '4990': use the exact numeric value 4990 without quotes instead of string '4990'. 2) When retrieving district and region information for a loan: join account table as T1, district table as T2, and loan table as T3 using inner joins. 3) When joining account and district tables: link rows where T1.district_id equals T2.district_id. 4) When joining account and loan tables: link rows where T1.account_id equals T3.account_id. 5) When filtering by loan ID: use T3.loan_id = 4990 with the correct table alias. 6) When selecting output columns: use T2.A2 for district and T2.A3 for region instead of the original column names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district, region FROM loans WHERE loan_id = '4990';",
            "SELECT T2.A2, T2.A3\nFROM loan AS T3\nINNER JOIN account AS T1 ON T1.account_id = T3.account_id\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T3.loan_id = 4990"
        ],
        "rule_sql": [
            "SELECT T2.A2 AS district, T2.A3 AS region FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990"
        ],
        "amend_res": 1
    },
    "852": {
        "db_id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitID = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "amends": [
            "Do count `T3.raceId` instead of `COUNT(*)` and use `circuits AS T1` as the primary table instead of `races r`. Do `INNER JOIN races AS T3` on `T3.circuitID = T1.circuitId` instead of joining `grand_prixs gp` on `r.grand_prix_id = gp.id`. Do filter with `T1.country NOT IN` a specific country list instead of `gp.continent IN ('Asia', 'Europe')`. Do remove the `grand_prixs` table entirely instead of including it. Do keep the `year = 2010` filter but apply it to `T3.year` instead of `r.year`. The amended query now correctly counts races from circuits outside specified countries in 2010 instead of counting races from Asian/European grand prixs, matching the intended behavior.",
            "Do use `circuitID` in the join condition instead of `circuitId` to match the correct column name. Do modify the `NOT IN` list to include the correct country values `'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK'` instead of the incorrect and more extensive list. Do reorder the `WHERE` clause conditions to place the country filter before the year filter instead of the original order. The amended query now correctly matches the RIGHT_SQL's behavior with proper column references and country exclusions."
        ],
        "rules": [
            "1) When answering about races in a specific year: filter races using T3.year = 2010. 2) When combining circuits and races tables: link rows where T3.circuitID = T1.circuitId using an inner match. 3) When counting races: count using T3.raceId as the canonical key instead of counting all rows. 4) When the question mentions \"outside Asia and Europe\": filter circuits using T1.country NOT IN a specific country list representing Asian and European countries. 5) When choosing the primary table: use circuits AS T1 as the base table instead of races.",
            "1) When joining tables circuits and races: use T1.circuitID = T3.circuitID for the join condition instead of circuitId to match the exact column name. 2) When filtering for races outside Asia and Europe in 2010: use the exact country values 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' in the NOT IN clause. 3) When ordering WHERE clause conditions: place the country filter before the year filter instead of the original order. 4) When counting races: use T3.raceId as the counting key for the number of races."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM races r\nJOIN grand_prixs gp ON r.grand_prix_id = gp.id\nWHERE r.year = 2010 \nAND gp.continent IN ('Asia', 'Europe');",
            "SELECT COUNT(T3.raceId) \nFROM circuits AS T1 \nINNER JOIN races AS T3 ON T3.circuitId = T1.circuitId \nWHERE T3.year = 2010 \nAND T1.country NOT IN ('China', 'Japan', 'Malaysia', 'Singapore', 'South Korea', 'Bahrain', 'Abu Dhabi', 'Turkey', 'Russia', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'Monaco', 'Netherlands', 'Spain', 'United Kingdom')",
            "SELECT COUNT(T3.raceId) \nFROM circuits AS T1 \nINNER JOIN races AS T3 ON T3.circuitID = T1.circuitId \nWHERE T1.country NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK') \nAND T3.year = 2010"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.raceId) \nFROM circuits AS T1 \nINNER JOIN races AS T3 ON T1.circuitId = T3.circuitId \nWHERE T1.country NOT IN ('Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK') \nAND T3.year = 2010"
        ],
        "amend_res": 1
    },
    "1163": {
        "db_id": "thrombosis_prediction",
        "question": "What was the age of the youngest patient when they initially arrived at the hospital?",
        "ground_truth": "SELECT MIN(STRFTIME('%Y', `First Date`) - STRFTIME('%Y', Birthday)) FROM Patient",
        "amends": [
            "Do use `MIN` instead of `MAX` for the age calculation. Do calculate age using `STRFTIME('%Y', First Date) - STRFTIME('%Y', Birthday)` instead of a simple `age` column. Do reference `First Date` and `Birthday` columns instead of `arrival_date`. Do use table name `Patient` instead of `patients`. Do remove the subquery that found minimum arrival date instead of keeping it. Do eliminate the WHERE clause filter instead of including it. The amended query now correctly calculates the minimum age difference between years instead of finding the maximum age from patients with the earliest arrival date."
        ],
        "rules": [
            "1) When calculating age from date columns: compute age using STRFTIME('%Y', First Date) - STRFTIME('%Y', Birthday) instead of using a simple age column. 2) When finding the youngest patient: use MIN instead of MAX for the age calculation. 3) When referencing the patient table: use table name Patient instead of patients. 4) When calculating age at initial arrival: reference First Date and Birthday columns instead of arrival_date. 5) When determining the youngest patient's age: eliminate any subquery that finds minimum arrival date instead of keeping it. 6) When computing the minimum age: remove any WHERE clause filter instead of including it."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(age) FROM patients WHERE arrival_date = (SELECT MIN(arrival_date) FROM patients);",
            "SELECT MIN(STRFTIME('%Y', \"First Date\") - STRFTIME('%Y', Birthday)) AS youngest_age FROM Patient"
        ],
        "rule_sql": [
            "SELECT MIN(STRFTIME('%Y', First Date) - STRFTIME('%Y', Birthday)) AS youngest_age FROM Patient",
            "SELECT MIN(STRFTIME('%Y', First Date) - STRFTIME('%Y', Birthday)) AS youngest_age FROM Patient;"
        ],
        "amend_res": 1
    },
    "190": {
        "db_id": "financial",
        "question": "How many clients who were born in 1920 stay in east Bohemia?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.birth_date) = '1920' AND T2.A3 = 'east Bohemia'",
        "amends": [
            "Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific non-null values. Do reference `client AS T1` and `district AS T2` tables instead of just `clients`. Do add `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of omitting the join. Do use `STRFTIME('%Y', T1.birth_date) = '1920'` instead of `year_of_birth = 1920` to extract year from a date field. Do filter on `T2.A3 = 'east Bohemia'` instead of `region = 'east Bohemia'` to use the correct column from the joined district table. The amended query now correctly joins tables and uses proper date extraction and column references to match the intended behavior."
        ],
        "rules": [
            "1) When counting clients: use COUNT(T1.client_id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"clients\": use table \"client AS T1\" and join with \"district AS T2\" using INNER JOIN district AS T2 ON T1.district_id = T2.district_id. 3) When filtering by birth year 1920: use STRFTIME('%Y', T1.birth_date) = '1920' to extract year from the date field instead of a direct year_of_birth column. 4) When filtering by region \"east Bohemia\": use T2.A3 = 'east Bohemia' instead of a region column from the clients table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE year_of_birth = 1920 AND region = 'east Bohemia';",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE STRFTIME('%Y', T1.birth_date) = '1920' \nAND T2.A3 = 'east Bohemia'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) \nFROM client AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE STRFTIME('%Y', T1.birth_date) = '1920' \nAND T2.A3 = 'east Bohemia'"
        ],
        "amend_res": 1
    },
    "505": {
        "db_id": "card_games",
        "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
        "amends": [
            "Do select `translation` instead of `english_name` and change the source table to `set_translations` instead of `sets`. Do add a `WHERE` clause with `language = 'Chinese Simplified'` instead of omitting it. Do replace the direct filter `set_name = 'Mirrodin'` with a subquery condition `setCode IN (SELECT code FROM sets WHERE name = 'Mirrodin')` instead of the simple equality check. The amended query now correctly retrieves Chinese Simplified translations for the Mirrodin set by joining through the code relationship between tables."
        ],
        "rules": [
            "1) When the question asks for a Simplified Chinese translation: use the column \"translation\" from table \"set_translations\" instead of \"english_name\" from \"sets\". 2) When retrieving translations for a specific language: filter by \"language = 'Chinese Simplified'\" exactly as specified. 3) When looking up translations for a set by name: use a subquery condition \"setCode IN (SELECT code FROM sets WHERE name = 'Mirrodin')\" instead of direct filtering on set_name. 4) When the question mentions the set \"Mirrodin\": use the exact literal 'Mirrodin' for the name filter in the subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT english_name FROM sets WHERE set_name = 'Mirrodin';",
            "SELECT translation FROM set_translations WHERE language = 'Chinese Simplified' AND setCode IN (SELECT code FROM sets WHERE name = 'Mirrodin')"
        ],
        "rule_sql": [
            "SELECT translation FROM set_translations WHERE language = 'Chinese Simplified' AND setCode IN (SELECT code FROM sets WHERE name = 'Mirrodin')"
        ],
        "amend_res": 1
    },
    "1471": {
        "db_id": "debit_card_specializing",
        "question": "What is the ratio of customers who pay in EUR against customers who pay in CZK?",
        "ground_truth": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio FROM customers",
        "amends": [
            "Do use a single `SELECT` with conditional aggregation using `SUM(IIF(Currency = 'EUR', 1, 0))` and `SUM(IIF(Currency = 'CZK', 1, 0))` instead of separate subqueries with `COUNT(*)` and `WHERE` filters. Do add explicit `CAST` to `FLOAT` for the numerator instead of relying on implicit casting. Do calculate the ratio directly from aggregated counts in the main query instead of using division between two separate subquery results. The amended query now correctly handles the division with proper type casting and avoids potential division by zero issues while maintaining the same logical behavior."
        ],
        "rules": [
            "1) When calculating a ratio of customers by currency: use conditional aggregation with SUM(IIF(Currency = 'EUR', 1, 0)) for EUR customers and SUM(IIF(Currency = 'CZK', 1, 0)) for CZK customers instead of separate subqueries. 2) When performing division between aggregated counts: explicitly CAST the numerator to FLOAT to ensure proper type handling. 3) When computing ratios: calculate directly from aggregated counts in the main query rather than using division between separate subquery results. 4) When handling currency values: use exact literals 'EUR' and 'CZK' with the exact case and spelling as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM customers WHERE currency = 'EUR') / \n    (SELECT COUNT(*) FROM customers WHERE currency = 'CZK') AS ratio",
            "SELECT \n    CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / NULLIF(SUM(IIF(Currency = 'CZK', 1, 0)), 0) AS ratio\nFROM customers\nWHERE Currency IN ('EUR', 'CZK')"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) AS ratio\nFROM \n    customers\nWHERE \n    Currency IN ('EUR', 'CZK');"
        ],
        "amend_res": 1
    },
    "722": {
        "db_id": "superhero",
        "question": "What is the colour of Apocalypse's skin?",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'",
        "amends": [
            "Do select `T2.colour` from the joined `colour` table instead of directly selecting `skin_color` from the `characters` table. Do join `superhero` table as `T1` with `colour` table as `T2` on `T1.skin_colour_id = T2.id` instead of querying a single table without joins. Do filter on `T1.superhero_name = 'Apocalypse'` instead of filtering on `name = 'Apocalypse'` from a different table. The amended query now correctly retrieves the color value through proper table relationships instead of attempting to access a direct column that doesn't exist in the schema."
        ],
        "rules": [
            "1) When the question asks about a character's color: use the colour table (T2) instead of the characters table. 2) When joining superhero table (T1) with colour table (T2): link rows where T1.skin_colour_id = T2.id. 3) When filtering for a specific superhero: use T1.superhero_name = 'Apocalypse' instead of name = 'Apocalypse'. 4) When selecting color information: select T2.colour instead of skin_color from the characters table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT skin_color FROM characters WHERE name = 'Apocalypse';",
            "SELECT T2.colour \nFROM superhero T1 \nJOIN colour T2 ON T1.skin_colour_id = T2.id \nWHERE T1.superhero_name = 'Apocalypse'"
        ],
        "rule_sql": [
            "SELECT c.colour \nFROM superhero s\nJOIN colour c ON s.skin_colour_id = c.id\nWHERE s.superhero_name = 'Apocalypse'"
        ],
        "amend_res": 1
    },
    "1495": {
        "db_id": "debit_card_specializing",
        "question": "Which client ID consumed the most in September 2013?",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
        "amends": [
            "Do select `T1.CustomerID` instead of `client_id` and `SUM(amount) as total_consumed`. Do use `FROM customers AS T1 INNER JOIN yearmonth AS T2` instead of `FROM transactions` alone. Do join on `T1.CustomerID = T2.CustomerID` instead of no join condition. Do filter with `T2.Date = '201309'` instead of `strftime('%Y-%m', date) = '2013-09'`. Do group by `T1.CustomerID` instead of `client_id`. Do order by `SUM(T2.Consumption) DESC` instead of `total_consumed DESC`. The amended query now correctly joins customer and consumption data, uses proper date format comparison, and aggregates consumption values for ranking.",
            "Do remove `SUM(T2.Consumption) as total_consumed` from the SELECT list instead of including it, as only the CustomerID is needed for the final result. Do keep the `INNER JOIN` on `T1.CustomerID = T2.CustomerID` unchanged. Do maintain the `WHERE T2.Date = '201309'` filter unchanged. Do preserve the `GROUP BY T1.CustomerID` clause unchanged. Do retain the `ORDER BY SUM(T2.Consumption) DESC` unchanged to identify the top customer. Do keep the `LIMIT 1` unchanged to return only the highest consumer. The amended query now correctly returns only the CustomerID of the top consumer for September 2013 instead of including unnecessary consumption data in the output."
        ],
        "rules": [
            "1) When answering about \"which client ID consumed the most\": make sure the output order: T1.CustomerID, SUM(T2.Consumption) as total_consumed 2) When the question mentions \"client ID\": \"client ID\" actually means \"T1.CustomerID in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match) 4) When filtering for September 2013: use T2.Date = '201309' exactly as specified 5) When the question asks for \"the most\": rank rows by SUM(T2.Consumption) in descending order and keep the first 1 row 6) When grouping by client: organize results by T1.CustomerID and compute SUM(T2.Consumption) per group",
            "1) When answering about \"which client ID consumed the most\": make sure the output order includes only the CustomerID column without consumption data. 2) When the question mentions \"September 2013\": use the exact literal '201309' for the Date filter. 3) When combining customers table (T1) and yearmonth table (T2): link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 4) When grouping by CustomerID: organize results by T1.CustomerID and compute the sum of T2.Consumption per group. 5) When identifying the top consumer: rank rows by SUM(T2.Consumption) in descending order and keep only the first row (highest consumer)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id, SUM(amount) as total_consumed \nFROM transactions \nWHERE strftime('%Y-%m', date) = '2013-09' \nGROUP BY client_id \nORDER BY total_consumed DESC \nLIMIT 1;",
            "SELECT T1.CustomerID, SUM(T2.Consumption) as total_consumed\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1",
            "SELECT T1.CustomerID\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201309'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "90": {
        "db_id": "financial",
        "question": "How many accounts who have region in Prague are eligible for loans?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A3 = 'Prague'",
        "amends": [
            "Do select `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN loan AS T2` and `INNER JOIN district AS T3` instead of querying only the accounts table. Do change the join condition to `ON T1.account_id = T2.account_id` and `ON T1.district_id = T3.district_id` instead of filtering directly on accounts. Do move the region filter to `WHERE T3.A3 = 'Prague'` instead of `WHERE region = 'Prague'` to use the correct table relationship. Do remove the `loan_eligible = 'yes'` filter instead of keeping it, as the join to loan table implicitly filters for accounts with loans. The amended query now correctly counts accounts with loans in the Prague district."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values. 2) When answering about accounts with loans: add INNER JOIN loan AS T2 ON T1.account_id = T2.account_id to link accounts to loans. 3) When answering about accounts in a region: add INNER JOIN district AS T3 ON T1.district_id = T3.district_id to link accounts to districts. 4) When filtering by region 'Prague': use WHERE T3.A3 = 'Prague' instead of filtering directly on accounts table. 5) When determining loan eligibility: do not filter by loan_eligible = 'yes' as the join to loan table implicitly filters for accounts with loans."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE region = 'Prague' AND loan_eligible = 'yes';",
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nWHERE T3.A3 = 'Prague'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nWHERE T3.A3 = 'Prague'"
        ],
        "amend_res": 1
    },
    "1452": {
        "db_id": "student_club",
        "question": "What is the average amount paid by students in a position other than a member?",
        "ground_truth": "SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN member as T2 ON T1.link_to_member = T2.member_id WHERE T2.position != 'Member'",
        "amends": [
            "Do use table `expense AS T1` instead of `payments`, and change the aggregate to `AVG(T1.cost)` instead of `AVG(amount)`. Do add an `INNER JOIN` with `member AS T2` on `T1.link_to_member = T2.member_id` instead of querying a single table. Do move the filter to `T2.position != 'Member'` instead of `position != 'member'`, changing both the table reference and case sensitivity. The amended query now correctly joins the expense and member tables to calculate average costs only for non-member positions, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average amount paid by students in a position other than a member\": use table \"expense AS T1\" and compute AVG(T1.cost) instead of AVG(amount). 2) When combining expense and member tables: perform an INNER JOIN between T1 and member AS T2 on T1.link_to_member = T2.member_id instead of querying a single table. 3) When filtering for non-member positions: apply the condition T2.position != 'Member' instead of position != 'member', using exact case-sensitive literal 'Member' and proper table reference."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(amount) FROM payments WHERE position != 'member';",
            "SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.position != 'Member'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.cost) AS average_amount_paid\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nWHERE T2.position != 'Member'"
        ],
        "amend_res": 1
    },
    "741": {
        "db_id": "superhero",
        "question": "What is the name of the superhero that has the most powers?",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1",
        "amends": [
            "Do select `T1.superhero_name` instead of `name` and add aggregation with `COUNT(T2.hero_id)` instead of ordering by raw `powers`. Do add `FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` instead of just `FROM superheroes` to properly join the tables. Do add `GROUP BY T1.superhero_name` instead of omitting grouping to support the aggregate function. Do order by `COUNT(T2.hero_id) DESC` instead of `powers DESC` to count actual power relationships rather than using a potentially incorrect column. The amended query now correctly identifies the superhero with the most powers by counting relationships in the join table."
        ],
        "rules": [
            "1) When answering about \"the superhero that has the most powers\": make sure the output order: T1.superhero_name. 2) When the question mentions \"name\": \"name\" actually means \"T1.superhero_name\" in schema. 3) When the question asks for \"most powers\": count the number of power relationships using COUNT(T2.hero_id) rather than using a raw powers column. 4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"count of powers\": compute the number of rows using the canonical key token T2.hero_id for counting power relationships. 6) When the question mentions \"most\" or \"highest\": rank rows by COUNT(T2.hero_id) in descending order and keep the first 1 row."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM superheroes ORDER BY powers DESC LIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nGROUP BY T1.superhero_name\nORDER BY COUNT(T2.hero_id) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nGROUP BY T1.id, T1.superhero_name\nORDER BY COUNT(T2.hero_id) DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nGROUP BY T1.id, T1.superhero_name\nORDER BY COUNT(T2.hero_id) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1205": {
        "db_id": "thrombosis_prediction",
        "question": "Was the patient with the number 57266's uric acid within a normal range?",
        "ground_truth": "SELECT CASE WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN true ELSE false END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 57266",
        "amends": [
            "Do use a `CASE` expression with conditional logic based on `SEX` and gender-specific uric acid thresholds instead of selecting raw `uric_acid` values. Do join `Patient` table as `T1` with `Laboratory` table as `T2` on `ID` instead of querying only the `lab_results` table. Do filter by `patient_id` through the join condition `T1.ID = T2.ID` and explicit `WHERE T1.ID = 57266` instead of filtering directly on `patient_id` in the `WHERE` clause. Do implement gender-specific uric acid evaluation with `(T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0)` instead of a simple `BETWEEN 0 AND 100` range check. Do return boolean `true`/`false` results from the `CASE` expression instead of returning the numeric uric acid value. The amended query now correctly evaluates abnormal uric acid levels based on gender-specific clinical thresholds rather than returning raw lab values.",
            "Do use boolean literals `true` and `false` instead of string literals `'true'` and `'false'` in the CASE expression. Do remove the alias `within_normal_range` instead of keeping it. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly returns boolean values instead of strings and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about whether a patient's uric acid is within normal range: use a CASE expression with conditional logic based on gender-specific thresholds instead of selecting raw uric acid values. 2) When combining Patient table as T1 with Laboratory table as T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for a specific patient with ID 57266: use WHERE T1.ID = 57266 instead of filtering directly on patient_id. 4) When evaluating uric acid levels: implement gender-specific evaluation with (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) instead of a simple range check. 5) When returning results: return boolean true/false results from the CASE expression instead of numeric uric acid values.",
            "1) When the question asks about a patient with ID 57266: filter rows where T1.ID equals 57266 exactly. 2) When combining Patient table (T1) and Laboratory table (T2): link rows where T1.ID equals T2.ID using INNER JOIN. 3) When checking uric acid (UA) levels against normal ranges: use exact numeric thresholds of 6.5 for female patients (T1.SEX = 'F') and 8.0 for male patients (T1.SEX = 'M'). 4) When returning boolean results: use boolean literals true and false instead of string literals 'true' and 'false'. 5) When the CASE expression produces a result: do not assign an alias to the output column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT uric_acid FROM lab_results WHERE patient_id = 57266 AND uric_acid BETWEEN 0 AND 100;",
            "SELECT \n    CASE \n        WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN 'false'\n        ELSE 'true'\n    END AS within_normal_range\nFROM \n    Patient AS T1\nJOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T1.ID = 57266;",
            "SELECT \n    CASE \n        WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN false\n        ELSE true\n    END\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.ID = 57266;"
        ],
        "rule_sql": [
            "SELECT CASE \n    WHEN (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) THEN false\n    ELSE true\nEND\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.ID = 57266"
        ],
        "amend_res": 1
    },
    "1522": {
        "db_id": "debit_card_specializing",
        "question": "There's one customer spent 214582.17 in the June of 2013, which currency did he/she use?",
        "ground_truth": "SELECT T2.Currency FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '201306' AND T1.Consumption = 214582.17",
        "amends": [
            "Do select `T2.Currency` from the `customers` table instead of `currency` from the `customers` table alone. Do join `yearmonth AS T1` with `customers AS T2` using `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do filter with `T1.Date = '201306'` instead of separate `month = 'June' AND year = 2013` conditions. Do filter with `T1.Consumption = 214582.17` instead of `amount = 214582.17`. The amended query now correctly joins the yearmonth and customers tables to match consumption data with the appropriate currency through the customer relationship."
        ],
        "rules": [
            "1) When answering about currency used by a customer with specific spending: select T2.Currency from the customers table instead of currency from customers alone. 2) When combining yearmonth and customers tables: link rows where T1.CustomerID = T2.CustomerID using an inner join to match consumption data with customer currency information. 3) When filtering for June 2013: use T1.Date = '201306' instead of separate month and year conditions. 4) When filtering for consumption amount 214582.17: use T1.Consumption = 214582.17 instead of amount = 214582.17."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT currency FROM customers WHERE amount = 214582.17 AND month = 'June' AND year = 2013;",
            "SELECT T2.Currency \nFROM yearmonth AS T1 \nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Date = '201306' AND T1.Consumption = 214582.17"
        ],
        "rule_sql": [
            "SELECT T2.Currency \nFROM yearmonth T1 \nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Date = '201306' AND T1.Consumption = 214582.17"
        ],
        "amend_res": 1
    },
    "1376": {
        "db_id": "student_club",
        "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
        "amends": [
            "Do select `T2.event_name` instead of `event_name` and omit the `spend_to_budget_ratio` alias calculation. Do use `FROM budget AS T1 INNER JOIN event AS T2` instead of a single table `events`, adding proper table sources with aliases. Do use join condition `ON T1.link_to_event = T2.event_id` instead of no join condition. Do filter with `T2.status = 'Closed'` instead of `status = 'closed'`, correcting both table reference and case sensitivity. Do order by `T1.spent / T1.amount DESC` instead of the aliased `spend_to_budget_ratio`, moving the calculation directly into the ORDER BY clause. The amended query now correctly joins budget and event tables, uses proper column references with table aliases, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about events with budgets: combine budget table as T1 and event table as T2 using inner match where T1.link_to_event equals T2.event_id. 2) When filtering for closed events: use T2.status = 'Closed' (exact case and quotes). 3) When calculating spend-to-budget ratio: compute T1.spent divided by T1.amount. 4) When finding the highest ratio: order results by T1.spent / T1.amount in descending direction and keep only the top result. 5) When selecting output: include T2.event_name as the event identifier."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name, (budget / spend) AS spend_to_budget_ratio FROM events WHERE status = 'closed' ORDER BY spend_to_budget_ratio DESC LIMIT 1;",
            "SELECT T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T2.status = 'Closed'\nORDER BY T1.spent / T1.amount DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.event_name, T1.spent / T1.amount \nFROM budget T1 \nINNER JOIN event T2 ON T1.link_to_event = T2.event_id \nWHERE T2.status = 'Closed' \nORDER BY T1.spent / T1.amount DESC \nLIMIT 1",
            "SELECT T2.event_name\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T2.status = 'Closed'\nORDER BY T1.spent / T1.amount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "115": {
        "db_id": "financial",
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' GROUP BY T2.A4 ORDER BY T2.A4 DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T1.gender = 'M')` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN c.gender = 'male' THEN 1 END)` for gender calculation. Do reference `client_id` in `COUNT` instead of `COUNT(*)` for accurate client counting. Do join `district` table instead of `branches` table, using `district_id` instead of `branch_id` as the join key. Do filter on `T2.A3 = 'south Bohemia'` instead of `b.region = 'south Bohemia'` for region filtering. Do add `GROUP BY T2.A4` instead of omitting grouping. Do order by `T2.A4 DESC` instead of `b.inhabitants DESC` for the ordering criteria. The amended query now correctly calculates the percentage of male clients per district in south Bohemia region, grouping by district code and returning the highest district.",
            "Do use a simplified boolean aggregation `SUM(T1.gender = 'M')` instead of the verbose `SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END)` for counting male clients. Do remove the explicit column alias `district_code` and the explicit column selection `T2.A4 as district_code` instead of keeping them, as the RIGHT_SQL only returns the calculated percentage. Do use explicit `INNER JOIN` syntax instead of implicit `JOIN` for clarity. Do maintain the same join condition `T1.district_id = T2.district_id`, table aliases, `WHERE` filter on `T2.A3 = 'south Bohemia'`, `GROUP BY T2.A4`, `ORDER BY T2.A4 DESC`, and `LIMIT 1` as they remain functionally identical. The amended query now correctly returns only the male percentage calculation without the district code column, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When joining client and district tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match). 2) When filtering for south Bohemia region: use T2.A3 = 'south Bohemia' exactly as specified. 3) When grouping results by district: use T2.A4 as the grouping key. 4) When counting male clients: use SUM(T1.gender = 'M') with explicit CAST to REAL instead of COUNT(CASE WHEN c.gender = 'male' THEN 1 END). 5) When counting total clients: use COUNT(T1.client_id) instead of COUNT(*) for accurate client counting. 6) When ordering districts by population: use T2.A4 DESC to find the district with the highest number of inhabitants. 7) When answering about the percentage of male clients: compute (male client count) divided by (total client count) and multiply by 100.0, guarding division by zero.",
            "1) When the question asks for a percentage of male clients: use SUM(T1.gender = 'M') to count male clients instead of CASE WHEN syntax. 2) When the question specifies \"branch which located in the south Bohemia\": filter using T2.A3 = 'south Bohemia' exactly as written. 3) When the question asks about the branch with biggest number of inhabitants: group by T2.A4 and order by T2.A4 DESC to find the largest district, then take only the top result with LIMIT 1. 4) When combining client and district tables: use INNER JOIN with condition T1.district_id = T2.district_id to link clients to their districts. 5) When calculating percentage: compute (SUM(T1.gender = 'M') / COUNT(T1.client_id)) * 100 and return only this calculated percentage without additional columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.gender = 'male' THEN 1 END) * 100.0 / COUNT(*)) AS male_percentage\nFROM clients c\nJOIN branches b ON c.branch_id = b.branch_id\nWHERE b.region = 'south Bohemia'\nORDER BY b.inhabitants DESC\nLIMIT 1;",
            "SELECT \n    T2.A4 as district_code,\n    (CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.client_id)) * 100 as male_percentage\nFROM \n    client T1\nJOIN \n    district T2 ON T1.district_id = T2.district_id\nWHERE \n    T2.A3 = 'south Bohemia'\nGROUP BY \n    T2.A4\nORDER BY \n    T2.A4 DESC\nLIMIT 1",
            "SELECT \n    CAST(SUM(T1.gender = 'M') AS REAL) / COUNT(T1.client_id) * 100 AS male_percentage\nFROM \n    client T1\nINNER JOIN \n    district T2 ON T1.district_id = T2.district_id\nWHERE \n    T2.A3 = 'south Bohemia'\nGROUP BY \n    T2.A4\nORDER BY \n    T2.A4 DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN c.gender = 'M' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.client_id)) * 100.0 AS male_percentage\nFROM \n    client c\nINNER JOIN \n    district d ON c.district_id = d.district_id\nWHERE \n    d.A3 = 'south Bohemia'\nGROUP BY \n    d.A4\nORDER BY \n    d.A4 DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "709": {
        "db_id": "codebase_community",
        "question": "In comments with 0 score, how many of the posts have view count lower than 5?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.ViewCount < 5 AND T2.Score = 0",
        "amends": [
            "Do join `posts` as `T2` instead of querying only the `comments` table. Do reference `T2.ViewCount` and `T2.Score` instead of `view_count` and `score` from the wrong table. Do use `COUNT(T1.Id)` instead of `COUNT(*)` to count specific comment IDs. Do add the join condition `ON T1.PostId = T2.Id` instead of missing the table relationship. Do filter on post attributes `T2.ViewCount < 5 AND T2.Score = 0` instead of comment attributes. The amended query now correctly counts comments from posts with low view count and zero score, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about comments from posts with specific attributes: join the comments table as T1 with the posts table as T2 using the condition T1.PostId = T2.Id to link comments to their corresponding posts. 2) When filtering for posts with score of 0: use the exact literal value 0 and filter on T2.Score = 0. 3) When filtering for posts with view count lower than 5: use the exact literal value 5 and filter on T2.ViewCount < 5. 4) When counting comments: count using the canonical key T1.Id instead of counting all rows. 5) When the question asks about \"comments with 0 score\": recognize that score refers to post score (T2.Score) rather than comment score. 6) When the question asks about \"view count lower than 5\": recognize that view count refers to post view count (T2.ViewCount) rather than comment view count."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE score = 0 AND view_count < 5;",
            "SELECT COUNT(T1.Id) \nFROM comments T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.ViewCount < 5 AND T2.Score = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM comments T1\nJOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Score = 0 \nAND T2.ViewCount < 5"
        ],
        "amend_res": 1
    },
    "1113": {
        "db_id": "european_football_2",
        "question": "For the team \"Hannover 96\", what was its defence aggression class on 2015/9/10?",
        "ground_truth": "SELECT t2.chanceCreationShootingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hannover 96' AND t2.`date` LIKE '2015-09-10%'",
        "amends": [
            "Do select `t2.chanceCreationShootingClass` instead of `defence_aggression_class`. Do join `Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id` instead of querying only the `teams` table. Do filter on `t1.team_long_name = 'Hannover 96'` instead of `team_name = 'Hannover 96'`. Do use `t2.date LIKE '2015-09-10%'` for date matching instead of `date = '2015/9/10'` to handle potential timestamp formats. The amended query now correctly retrieves the chance creation shooting class from the joined attributes table using proper table relationships and date filtering.",
            "Do select `chanceCreationShootingClass` instead of `defenceAggressionClass` in the SELECT list, maintaining the same FROM clause with `INNER JOIN` on `t1.team_api_id = t2.team_api_id`, identical WHERE filters for `t1.team_long_name = 'Hannover 96'` and `t2.date LIKE '2015-09-10%'`, with no changes to join conditions, filtering, or other clauses. The amended query now correctly retrieves the chance creation shooting class instead of defence aggression class while preserving all other logic and matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"defence aggression class\": use the exact column token \"defenceAggressionClass\" from the Team_Attributes table instead of \"defence_aggression_class\". 2) When querying for team \"Hannover 96\": use the exact column token \"team_long_name\" from the Team table with literal value 'Hannover 96' instead of \"team_name\". 3) When filtering by date '2015/9/10': use pattern matching \"LIKE '2015-09-10%'\" on the Team_Attributes date column to handle timestamp formats instead of exact equality. 4) When combining Team and Team_Attributes tables: perform an inner join where \"t1.team_api_id = t2.team_api_id\" to link team information with their attributes. 5) When selecting the output column: use \"t2.defenceAggressionClass\" as the result column from the joined Team_Attributes table.",
            "1) When the question asks about \"defence aggression class\" for a team on a specific date: the correct attribute to select is \"chanceCreationShootingClass\" from the Team_Attributes table. 2) When filtering for team name \"Hannover 96\": use exact literal 'Hannover 96' with table alias t1 and column team_long_name. 3) When filtering for date \"2015/9/10\": use pattern matching with '2015-09-10%' on the date column of Team_Attributes table (alias t2). 4) When joining Team and Team_Attributes tables: use inner join on the exact key equality t1.team_api_id = t2.team_api_id."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT defence_aggression_class FROM teams WHERE team_name = 'Hannover 96' AND date = '2015/9/10';",
            "SELECT t2.defenceAggressionClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hannover 96' \nAND t2.date LIKE '2015-09-10%'",
            "SELECT t2.chanceCreationShootingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hannover 96' \nAND t2.date LIKE '2015-09-10%'"
        ],
        "rule_sql": [
            "SELECT t2.defenceAggressionClass \nFROM Team t1\nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\nWHERE t1.team_long_name = 'Hannover 96'\nAND t2.date LIKE '2015-09-10%'"
        ],
        "amend_res": 1
    },
    "1026": {
        "db_id": "european_football_2",
        "question": "Which home team had lost the fewest matches in the 2016 season?",
        "ground_truth": "SELECT teamDetails.team_long_name FROM Match AS matchData INNER JOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id WHERE matchData.season = '2015/2016' AND matchData.home_team_goal - matchData.away_team_goal < 0 GROUP BY matchData.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1",
        "amends": [
            "Do reference `teamDetails.team_long_name` instead of `home_team` in the SELECT list. Do join `Team AS teamDetails` on `matchData.home_team_api_id = teamDetails.team_api_id` instead of omitting the join. Do filter with `matchData.season = '2015/2016'` instead of `season = 2016`. Do calculate the loss condition as `matchData.home_team_goal - matchData.away_team_goal < 0` instead of `home_score < away_score`. Do group by `matchData.home_team_api_id` instead of `home_team`. Do order by `COUNT(*) ASC` instead of `losses ASC`. The amended query now correctly joins team details, uses proper season formatting, calculates goal differential accurately, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about home teams: use \"teamDetails.team_long_name\" to display the team name instead of \"home_team\". 2) When combining match data with team details: link rows where \"matchData.home_team_api_id = teamDetails.team_api_id\" and keep only matching pairs (inner match). 3) When filtering for the 2016 season: use exact literal \"2015/2016\" for \"matchData.season\" instead of numeric 2016. 4) When determining if a home team lost: calculate \"matchData.home_team_goal - matchData.away_team_goal < 0\" instead of comparing home_score and away_score. 5) When grouping by home team: use \"matchData.home_team_api_id\" as the grouping key instead of the team name. 6) When ordering by number of losses: order by \"COUNT(*)\" in ascending order to find the team with fewest losses. 7) When finding the team with fewest losses: take only the first row after ordering by loss count ascending."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT home_team, COUNT(*) AS losses FROM matches WHERE season = 2016 AND home_score < away_score GROUP BY home_team ORDER BY losses ASC LIMIT 1;",
            "SELECT teamDetails.team_long_name\nFROM Match AS matchData\nJOIN Team AS teamDetails ON matchData.home_team_api_id = teamDetails.team_api_id\nWHERE matchData.season = '2015/2016'\n  AND matchData.home_team_goal - matchData.away_team_goal < 0\nGROUP BY matchData.home_team_api_id\nORDER BY COUNT(*) ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t.team_long_name, COUNT(*) AS lost_matches\nFROM Match m\nINNER JOIN Team t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2015/2016' \nAND m.home_team_goal - m.away_team_goal < 0\nGROUP BY m.home_team_api_id\nORDER BY lost_matches ASC\nLIMIT 1",
            "SELECT t.team_long_name, COUNT(*) AS loss_count\nFROM Match m\nINNER JOIN Team t ON m.home_team_api_id = t.team_api_id\nWHERE m.season = '2015/2016' \nAND m.home_team_goal - m.away_team_goal < 0\nGROUP BY m.home_team_api_id\nORDER BY loss_count ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "287": {
        "db_id": "toxicology",
        "question": "Among all chemical compounds that contain molecule TR047, identify the percent that form a double-bond.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T WHERE T.molecule_id = 'TR047'",
        "amends": [
            "Do use `CAST` with `REAL` type instead of implicit casting with `* 100.0`. Do count specific bonds with `CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END` instead of simple `COUNT(*)` with `bond_type = 'double'` filter. Do reference table with alias `T` instead of no alias. Do use column `bond_id` for counting instead of `*`. Do remove the subquery for total count and instead calculate percentage directly using `COUNT(T.bond_id)` as denominator. Do use table name `bond` instead of `compounds`. Do use comparison `T.bond_type = '='` instead of `bond_type = 'double'`. The amended query now correctly calculates the percentage of double bonds using proper type casting and conditional counting within a single query instead of using a subquery."
        ],
        "rules": [
            "1) When the question asks about chemical compounds containing molecule TR047: use table \"bond\" with alias T instead of \"compounds\". 2) When counting double bonds: use comparison T.bond_type = '=' instead of bond_type = 'double'. 3) When calculating percentage: use CAST with REAL type instead of implicit casting with * 100.0. 4) When counting specific bonds: use CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END instead of simple COUNT(*) with filter. 5) When counting entities: use column bond_id for counting instead of *. 6) When calculating ratios: remove subqueries for total count and calculate percentage directly using COUNT(T.bond_id) as denominator."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM compounds WHERE molecule_id = 'TR047') AS percent_double_bond FROM compounds WHERE molecule_id = 'TR047' AND bond_type = 'double'",
            "SELECT \n    (COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) * 100.0 / COUNT(T.bond_id)) AS percent_double_bonds\nFROM \n    bond T\nWHERE \n    T.molecule_id = 'TR047';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) / COUNT(T.bond_id) * 100.0 AS percent_double_bonds\nFROM \n    bond T\nWHERE \n    T.molecule_id = 'TR047';"
        ],
        "amend_res": 1
    },
    "382": {
        "db_id": "card_games",
        "question": "What are the cards that only available in paper and Japanese language?",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
        "amends": [
            "Do select only `T1.name` instead of all columns with `*`. Do add `INNER JOIN` with `foreign_data AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do move the `language` filter to reference `T2.language` instead of `language` from the original table. Do specify table aliases `T1` and `T2` instead of using unqualified column references. The amended query now correctly joins the tables and filters language from the appropriate source, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"cards that only available in paper and Japanese language\": make sure the output order: T1.name. 2) When the question mentions \"cards\": \"cards\" actually means \"T1 table\" in schema. 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match). 4) When filtering for availability: use T1.availability = 'paper' exactly as specified. 5) When filtering for language: use T2.language = 'Japanese' exactly as specified, matching the exact case and spelling from the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE availability = 'paper' AND language = 'Japanese';",
            "SELECT T1.name \nFROM cards AS T1 \nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid \nWHERE T2.language = 'Japanese' \nAND T1.availability = 'paper'"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.availability = 'paper'\nAND T2.language = 'Japanese'\nORDER BY T1.name;"
        ],
        "amend_res": 1
    },
    "484": {
        "db_id": "card_games",
        "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
        "ground_truth": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC",
        "amends": [
            "Do join `foreign_data AS T1` and `sets AS T3` instead of omitting them. Do use `INNER JOIN` on `T2.uuid = T1.uuid` and `INNER JOIN` on `T3.code = T2.setCode` instead of querying only the `cards` table. Do reference `T2.name` instead of just `name`. Do filter on `T3.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'`. Do filter on `T1.language = 'Italian'` instead of `language = 'Italian'`. Do order by `T2.convertedManaCost` instead of `converted_mana_cost`. Do remove `LIMIT 1` instead of keeping it. The amended query now correctly joins the necessary tables to access language-specific data and properly filters by set name through the sets table.",
            "Do select `T2.name` instead of `T1.name` to retrieve the card name from the correct table. Do remove the `AND T2.convertedManaCost = (subquery)` filter instead of keeping it, as the subquery comparison was incorrectly restricting results. Do remove the subquery entirely instead of including it, eliminating the unnecessary maximum converted mana cost comparison. The amended query now correctly returns Italian card names from the Coldsnap set without the restrictive subquery condition, matching the RIGHT_SQL's behavior.",
            "Do select `T2.name` instead of `T1.name` in the SELECT list to retrieve the card name from the cards table rather than the foreign data table. The rest of the query structure remains identical with the same `INNER JOIN` conditions on `T2.uuid = T1.uuid` and `T3.code = T2.setCode`, the same WHERE filters for `T3.name = 'Coldsnap'` and `T1.language = 'Italian'`, and the same ORDER BY `T2.convertedManaCost DESC`. The amended query now correctly returns card names from the cards table while maintaining the same filtering and sorting logic."
        ],
        "rules": [
            "1) When answering about cards in a specific set: join foreign_data as T1 and sets as T3 using INNER JOIN on T2.uuid = T1.uuid and T3.code = T2.setCode instead of querying only the cards table. 2) When the question mentions \"Italian names\": filter on T1.language = 'Italian' instead of language = 'Italian'. 3) When the question mentions \"set Coldsnap\": filter on T3.name = 'Coldsnap' instead of set_name = 'Coldsnap'. 4) When the question asks for \"highest converted mana cost\": order by T2.convertedManaCost in descending direction instead of converted_mana_cost. 5) When the question asks to \"list the Italian names\" without specifying a limit: remove LIMIT 1 instead of keeping it. 6) When referencing card names in foreign languages: reference T2.name instead of just name.",
            "1) When retrieving card names from the database schema: use T2.name instead of T1.name to get the card name from the correct table. 2) When filtering for cards in the Coldsnap set: do not include a subquery comparison for maximum converted mana cost, as this incorrectly restricts results. 3) When the question asks for cards with the highest converted mana cost: remove any subquery that compares convertedManaCost to a maximum value, as this filtering approach is unnecessary and restrictive.",
            "1) When the question asks for Italian names of cards: select the name from the cards table (T2.name) rather than from the foreign_data table. 2) When filtering for cards in the Coldsnap set: use T3.name = 'Coldsnap' exactly as specified. 3) When filtering for Italian language cards: use T1.language = 'Italian' exactly as specified. 4) When joining cards and foreign_data tables: link rows where T2.uuid = T1.uuid exactly. 5) When joining cards and sets tables: link rows where T3.code = T2.setCode exactly. 6) When ordering by highest converted mana cost: sort by T2.convertedManaCost in descending order. 7) When the question asks for the highest converted mana cost cards: return all cards with the maximum converted mana cost value (not just one card)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE set_name = 'Coldsnap' AND language = 'Italian' ORDER BY converted_mana_cost DESC LIMIT 1;",
            "SELECT T1.name \nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nINNER JOIN sets AS T3 ON T3.code = T2.setCode\nWHERE T3.name = 'Coldsnap'\nAND T1.language = 'Italian'\nAND T2.convertedManaCost = (\n    SELECT MAX(convertedManaCost) \n    FROM cards \n    INNER JOIN sets ON sets.code = cards.setCode \n    WHERE sets.name = 'Coldsnap'\n)\nORDER BY T2.convertedManaCost DESC;",
            "SELECT T1.name \nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nINNER JOIN sets AS T3 ON T3.code = T2.setCode\nWHERE T3.name = 'Coldsnap' \nAND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC",
            "SELECT T2.name\nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nINNER JOIN sets AS T3 ON T3.code = T2.setCode\nWHERE T3.name = 'Coldsnap'\nAND T1.language = 'Italian'\nORDER BY T2.convertedManaCost DESC"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nINNER JOIN sets AS T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian'\nAND T3.name = 'Coldsnap'\nORDER BY T2.convertedManaCost DESC"
        ],
        "amend_res": 1
    },
    "251": {
        "db_id": "toxicology",
        "question": "What is the least common element of all carcinogenic molecules?",
        "ground_truth": "SELECT T.element FROM ( SELECT T2.element, COUNT(DISTINCT T2.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T2.element ORDER BY COUNT(DISTINCT T2.molecule_id) LIMIT 1 ) t",
        "amends": [
            "Do select `T.element` instead of `element, COUNT(*) as count` and remove the `COUNT` aggregation. Do use a subquery instead of querying `molecules` directly, changing the FROM to `molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id` instead of `molecules`. Do add filter `WHERE T1.label = '+'` instead of `WHERE carcinogenic = 1`. Do group by `T2.element` instead of `element` and use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)`. Do order by `COUNT(DISTINCT T2.molecule_id)` in ascending order instead of `count DESC` while keeping `LIMIT 1`. The amended query now correctly identifies the element with the fewest distinct molecule occurrences having a '+' label."
        ],
        "rules": [
            "1) When answering about \"least common element of all carcinogenic molecules\": make sure the output order: T2.element 2) When the question mentions \"carcinogenic molecules\": \"carcinogenic\" actually means \"T1.label = '+' in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"least common element\": rank elements by COUNT(DISTINCT T2.molecule_id) in ascending order and keep the first 1 row. 5) When the question says \"per element\": organize results by T2.element and compute requested aggregates per group. 6) When counting distinct molecule occurrences: compute the number of unique values of T2.molecule_id using COUNT(DISTINCT T2.molecule_id)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element, COUNT(*) as count FROM molecules WHERE carcinogenic = 1 GROUP BY element ORDER BY count DESC LIMIT 1;",
            "SELECT T2.element\nFROM molecule AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.label = '+'\nGROUP BY T2.element\nORDER BY COUNT(DISTINCT T2.molecule_id) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.element\nFROM molecule T1\nINNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.label = '+'\nGROUP BY T2.element\nORDER BY COUNT(DISTINCT T2.molecule_id) ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "878": {
        "db_id": "formula_1",
        "question": "Who was the driver that got the best lap time in the race No. 348? Give his full name.",
        "ground_truth": "SELECT T2.forename, T2.surname FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 348 ORDER BY T1.time ASC LIMIT 1",
        "amends": [
            "Do select `T2.forename` and `T2.surname` instead of just `driver_name`. Do join `lapTimes AS T1` with `drivers AS T2` using `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `drivers` table. Do filter on `T1.raceId = 348` instead of `race_id = 348`. Do order by `T1.time ASC` instead of `lap_time ASC`. The amended query now correctly retrieves driver names from the joined tables based on lap time performance for the specified race."
        ],
        "rules": [
            "1) When answering about \"the driver that got the best lap time\": make sure the output order includes both T2.forename and T2.surname for the full name. 2) When the question mentions \"race No. 348\": filter using T1.raceId = 348 exactly. 3) When combining lapTimes (T1) and drivers (T2): link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match). 4) When finding the best lap time: order by T1.time ASC and take the first row. 5) When the question asks for \"best lap time\": this means the minimum time value, so order in ascending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM drivers WHERE race_id = 348 ORDER BY lap_time ASC LIMIT 1;",
            "SELECT T2.forename, T2.surname \nFROM lapTimes AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 348 \nORDER BY T1.time ASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname \nFROM lapTimes T1 \nINNER JOIN drivers T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 348 \nORDER BY T1.time ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "570": {
        "db_id": "codebase_community",
        "question": "For the user whose display name is \"DatEpicCoderGuyWhoPrograms\", what is his/her badge's name?",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'DatEpicCoderGuyWhoPrograms'",
        "amends": [
            "Do select `T2.Name` from the `badges` table instead of `badge_name` from the `users` table. Do add an `INNER JOIN` on `badges AS T2` with predicate `T1.Id = T2.UserId` instead of querying only the `users` table. Do use the correct column name `DisplayName` instead of `display_name` in the WHERE filter. The amended query now correctly retrieves badge names by joining the users and badges tables on the proper relationship."
        ],
        "rules": [
            "1) When the question asks about a user's badge name: select \"T2\".\"Name\" from the badges table instead of badge_name from the users table. 2) When combining users and badges tables: link rows where \"T1\".\"Id\" = \"T2\".\"UserId\" using an inner join. 3) When filtering by display name: use the exact column name \"DisplayName\" instead of display_name and the exact literal value 'DatEpicCoderGuyWhoPrograms'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM users WHERE display_name = 'DatEpicCoderGuyWhoPrograms'",
            "SELECT T2.Name \nFROM users AS T1 \nINNER JOIN badges AS T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'DatEpicCoderGuyWhoPrograms'"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM users T1 INNER JOIN badges T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'DatEpicCoderGuyWhoPrograms'"
        ],
        "amend_res": 1
    },
    "1523": {
        "db_id": "debit_card_specializing",
        "question": "Which country was the card owner of No.667467 in?",
        "evidence": "",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467'",
        "amends": [
            "Do query from `transactions_1k AS T1` instead of `cards`, and add `INNER JOIN gasstations AS T2` instead of omitting it. Do use join condition `T1.GasStationID = T2.GasStationID` instead of no join. Do filter on `T1.CardID = '667467'` instead of `card_number = '667467'`. Do select `T2.Country` instead of `country`. The amended query now correctly joins the transactions and gasstations tables to retrieve the country associated with the given card ID."
        ],
        "rules": [
            "1) When answering about \"which country was the card owner of No.667467 in\": make sure the output order: T2.Country. 2) When the question mentions \"No.667467\": \"No.667467\" actually means \"T1.CardID = '667467'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.GasStationID = T2.GasStationID exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM cards WHERE card_number = '667467';",
            "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467' LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Country\nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.CardID = '667467'\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1505": {
        "db_id": "debit_card_specializing",
        "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
        "ground_truth": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
        "amends": [
            "Do join from `yearmonth AS T1` instead of `customers c`, and do join with `customers AS T2` instead of `payments p`. Do use join condition `T1.CustomerID = T2.CustomerID` instead of `c.customer_id = p.customer_id`. Do filter on `T2.Currency = 'EUR'` instead of `p.currency = 'EUR'`, and do filter on `T1.Consumption > 1000.00` instead of `c.monthly_consumption > 1000`. The amended query now correctly counts records from the yearmonth table joined with customers using the appropriate join conditions and filters.",
            "Do use `COUNT(*)` instead of `COUNT(DISTINCT T1.CustomerID)` to count all matching rows rather than distinct customer IDs. Do remove the explicit `DISTINCT` modifier instead of keeping it since the join condition already ensures unique customer matching. Do specify `INNER JOIN` explicitly instead of the implicit `JOIN` for clarity, though this is functionally equivalent. The amended query now correctly counts all records meeting the criteria rather than distinct customers, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about customers who paid in euro: use \"T2.Currency = 'EUR'\" as the filter condition with exact literal 'EUR'. 2) When answering about monthly consumption over 1000: use \"T1.Consumption > 1000.00\" as the filter condition with exact numeric value 1000.00. 3) When combining yearmonth and customers tables: link rows where \"T1.CustomerID = T2.CustomerID\" using exact identifier tokens. 4) When counting customers: count records from the yearmonth table (T1) using the join condition with customers table. 5) When choosing table aliases: use T1 for yearmonth table and T2 for customers table as specified in the amends.",
            "1) When counting records that meet specific criteria: use COUNT(*) to count all matching rows rather than counting distinct values of a specific column. 2) When joining tables with a key relationship: use INNER JOIN explicitly for clarity, though it is functionally equivalent to JOIN. 3) When the question asks about customers with specific payment currency and consumption: ensure the query filters for T2.Currency = 'EUR' and T1.Consumption > 1000.00 exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers c\nJOIN payments p ON c.customer_id = p.customer_id\nWHERE p.currency = 'EUR' \nAND c.monthly_consumption > 1000;",
            "SELECT COUNT(DISTINCT T1.CustomerID) \nFROM yearmonth AS T1 \nJOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
            "SELECT COUNT(*)\nFROM yearmonth AS T1\nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00"
        ],
        "rule_sql": [
            "SELECT COUNT(*)\nFROM yearmonth T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00"
        ],
        "amend_res": 1
    },
    "1359": {
        "db_id": "student_club",
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END)` instead of `COUNT(*)` to calculate a ratio of budget amounts rather than counting rows. Do join `budget AS T1` and `event AS T2` with `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of querying only the `meetings` table. Do filter with `T1.category = 'Advertisement'` and `T2.type = 'Meeting'` instead of `meeting_name` and `budget` comparisons. Do cast the result as `REAL` instead of returning an integer count. The amended query now correctly calculates the budget ratio between specified events with proper table relationships and filtering."
        ],
        "rules": [
            "1) When answering about budget ratio between events: calculate SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) instead of counting rows. 2) When combining budget and event tables: link rows where T1.link_to_event = T2.event_id using an inner join. 3) When filtering for advertisement category: use T1.category = 'Advertisement' exactly. 4) When filtering for meeting type: use T2.type = 'Meeting' exactly. 5) When handling the result: cast the ratio as REAL instead of returning an integer."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM meetings \nWHERE meeting_name = 'Yearly Kickoff' \nAND budget > (SELECT budget FROM meetings WHERE meeting_name = 'October Meeting') \nAND category = 'Advertisement';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) AS REAL) AS budget_ratio\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Advertisement' \nAND T2.type = 'Meeting'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(\n        SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) * 1.0 / \n        SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END)\n    AS REAL) AS budget_ratio\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Advertisement' \nAND T2.type = 'Meeting'"
        ],
        "amend_res": 1
    },
    "680": {
        "db_id": "codebase_community",
        "question": "What is the average score of Stephen Turner's posts?",
        "ground_truth": "SELECT AVG(T2.Score) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.DisplayName = 'Stephen Turner'",
        "amends": [
            "Do join `users AS T1` and `posts AS T2` instead of querying only `posts` table. Do use `INNER JOIN` on `T1.Id = T2.OwnerUserId` instead of filtering by `author` column. Do filter by `T1.DisplayName = 'Stephen Turner'` instead of `author = 'Stephen Turner'` to correctly identify the user by display name rather than an incorrect author field. Do reference `T2.Score` instead of just `score` to specify the table alias. The amended query now correctly joins user and post data to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average score of Stephen Turner's posts\": make sure the output order: average of T2.Score. 2) When the question mentions \"Stephen Turner\": \"Stephen Turner\" actually means T1.DisplayName = 'Stephen Turner' in schema. 3) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match). 4) When computing average score: calculate the average of T2.Score values for the filtered results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(score) FROM posts WHERE author = 'Stephen Turner';",
            "SELECT AVG(T2.Score) AS average_score\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.DisplayName = 'Stephen Turner'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Score) AS average_score\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.DisplayName = 'Stephen Turner'"
        ],
        "amend_res": 1
    },
    "1111": {
        "db_id": "european_football_2",
        "question": "State the chance creation passing class for \"PEC Zwolle\" on 2013/9/20.",
        "ground_truth": "SELECT t2.chanceCreationPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'PEC Zwolle' AND SUBSTR(t2.`date`, 1, 10) = '2013-09-20'",
        "amends": [
            "Do select `t2.chanceCreationPassingClass` instead of `chance_creation_passing` to use the correct column name and table alias. Do use `Team AS t1 INNER JOIN Team_Attributes AS t2` instead of querying only `matches` to properly join the team and attributes tables. Do join on `t1.team_api_id = t2.team_api_id` instead of missing the join condition entirely. Do filter on `t1.team_long_name = 'PEC Zwolle'` instead of `team = 'PEC Zwolle'` to use the correct column for team identification. Do use `SUBSTR(t2.date, 1, 10) = '2013-09-20'` instead of `date = '2013/9/20'` to properly handle date formatting and substring extraction. The amended query now correctly retrieves chance creation passing data from the joined tables with proper filtering."
        ],
        "rules": [
            "1) When answering about chance creation passing class for a specific team and date: make sure the output order: t2.chanceCreationPassingClass 2) When the question mentions \"PEC Zwolle\": \"PEC Zwolle\" actually means t1.team_long_name = 'PEC Zwolle' in schema 3) When the question mentions date \"2013/9/20\": use SUBSTR(t2.date, 1, 10) = '2013-09-20' to properly handle date formatting 4) When combining Team as T1 and Team_Attributes as T2: link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT chance_creation_passing FROM matches WHERE team = 'PEC Zwolle' AND date = '2013/9/20';",
            "SELECT t2.chanceCreationPassingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'PEC Zwolle' \nAND SUBSTR(t2.date, 1, 10) = '2013-09-20'"
        ],
        "rule_sql": [
            "SELECT t2.chanceCreationPassingClass \nFROM Team t1\nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\nWHERE t1.team_long_name = 'PEC Zwolle'\nAND SUBSTR(t2.date, 1, 10) = '2013-09-20'"
        ],
        "amend_res": 1
    },
    "864": {
        "db_id": "formula_1",
        "question": "For the race happened on 2015/11/29, how many drivers finished the game?",
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "amends": [
            "Do select `COUNT(T2.driverId)` instead of `COUNT(*)` to count specific drivers rather than all rows. Do use tables `races AS T1` and `results AS T2` instead of just `drivers` to properly access race and result data. Do perform an `INNER JOIN` on `T2.raceId = T1.raceId` instead of querying a single table to correctly relate race and result records. Do filter on `T1.date = '2015-11-29'` instead of `race_date = '2015/11/29'` to use the correct date column and format. Do filter with `T2.time IS NOT NULL` instead of `finished = 'yes'` to identify finished races by the presence of a time value rather than a string flag. The amended query now correctly counts drivers who completed the specified race by joining race and result tables and checking for non-null finish times."
        ],
        "rules": [
            "1) When answering about \"how many drivers finished the game\": make sure the output order: COUNT(T2.driverId). 2) When the question mentions \"race happened on 2015/11/29\": use T1.date = '2015-11-29' with the exact date format '2015-11-29'. 3) When the question asks for \"finished the game\": use T2.time IS NOT NULL to identify completed races. 4) When combining races AS T1 and results AS T2: link rows where T2.raceId = T1.raceId and keep only matching pairs (inner match). 5) When counting drivers: use COUNT(T2.driverId) to count specific drivers rather than all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE race_date = '2015/11/29' AND finished = 'yes';",
            "SELECT COUNT(T2.driverId) \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nWHERE T1.date = '2015-11-29' \nAND T2.time IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.driverId) \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nWHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL"
        ],
        "amend_res": 1
    },
    "452": {
        "db_id": "card_games",
        "question": "Please list the names of the cards that have a text box.",
        "ground_truth": "SELECT DISTINCT name FROM cards WHERE isTextless = 0",
        "amends": [
            "Do select `DISTINCT name` instead of just `name` to eliminate duplicate results. Do filter on `isTextless = 0` instead of `text_box IS NULL` to correctly identify cards that are not textless rather than those with null text boxes. Do remove the unnecessary table reference `cards` since it's not needed for this simple query structure. The amended query now correctly returns unique card names for non-textless cards, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"names of the cards that have a text box\": filter rows where \"isTextless\" equals 0 to identify cards that are not textless. 2) When selecting card names: use DISTINCT to eliminate duplicate results and return only unique names. 3) When handling the table reference: do not include unnecessary table references for simple query structures."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE text_box IS NULL;",
            "SELECT DISTINCT name FROM cards WHERE isTextless = 0"
        ],
        "rule_sql": [
            "SELECT DISTINCT name FROM cards WHERE isTextless = 0;"
        ],
        "amend_res": 1
    },
    "1148": {
        "db_id": "european_football_2",
        "question": "What is the percentage of players that are under 180 cm who have an overall strength of more than 70?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) * 100 / COUNT(t1.id) percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height < 180",
        "amends": [
            "Do add `INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the players table. Do change the condition to `t2.overall_rating > 70` instead of `strength > 70` and reference the correct table alias. Do add `WHERE t1.height < 180` instead of including height in the CASE statement. Do use `CAST(... AS REAL)` for proper division instead of implicit casting with `100.0`. Do reference `t1.id` in both COUNT functions instead of using `COUNT(*)`. Do add table alias `t1` to the players table instead of using it unaliased. The amended query now correctly calculates the percentage of players under 180cm height with an overall rating over 70 by properly joining the Player and Player_Attributes tables.",
            "Do use `COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END)` in the numerator instead of `COUNT(DISTINCT t1.id)` with a separate WHERE clause, and do use `COUNT(t1.id)` in the denominator instead of a subquery with `COUNT(DISTINCT t1.id)`. Do remove the redundant subquery and instead calculate the percentage directly with `* 100 / COUNT(t1.id)` instead of the complex division and multiplication. Do simplify the expression by eliminating the nested SELECT and DISTINCT operations, and do use a single CASE expression to conditionally count players with `overall_rating > 70` instead of filtering in the WHERE clause. The amended query now correctly calculates the percentage of players under 180cm height with overall rating above 70 relative to all players under 180cm height, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about percentage of players under 180 cm with overall strength over 70: combine data from both Player table (as t1) and Player_Attributes table (as t2) using an inner match where t1.player_api_id = t2.player_api_id. 2) When filtering for height under 180 cm: apply the condition t1.height < 180 to the Player table. 3) When filtering for overall rating over 70: apply the condition t2.overall_rating > 70 to the Player_Attributes table. 4) When counting players: use t1.id as the counting key for both numerator and denominator counts. 5) When calculating percentage: compute (count of players meeting both conditions) divided by (total count of players meeting height condition) multiplied by 100, using CAST for proper division handling.",
            "1) When calculating the percentage of players under 180 cm with overall strength above 70: use COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) for the numerator instead of COUNT(DISTINCT t1.id) with separate filtering. 2) When computing the denominator for percentage calculation: use COUNT(t1.id) for all players under 180 cm instead of a subquery with COUNT(DISTINCT t1.id). 3) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match). 4) When filtering players by height: use t1.height < 180 to identify players under 180 cm. 5) When calculating the final percentage: use * 100 / COUNT(t1.id) instead of complex division and multiplication operations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN height < 180 AND strength > 70 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM players;",
            "SELECT \n    (CAST(COUNT(DISTINCT t1.id) AS REAL) / \n     CAST((SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height < 180) AS REAL)) * 100.0 AS percentage\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height < 180 AND t2.overall_rating > 70;",
            "SELECT \n    CAST(COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) AS REAL) * 100.0 / COUNT(t1.id) AS percentage\nFROM \n    Player AS t1\nINNER JOIN \n    Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.height < 180"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) * 100.0 / COUNT(t1.id)) AS percentage\nFROM \n    Player AS t1\nINNER JOIN \n    Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.height < 180"
        ],
        "amend_res": 1
    },
    "69": {
        "db_id": "california_schools",
        "question": "Please provide the National Center for Educational Statistics school district identification number for all schools with a School Ownership Code that are part of the State Special Schools.",
        "ground_truth": "SELECT NCESDist FROM schools WHERE SOC = 31",
        "amends": [
            "Do select `NCESDist` instead of `School_District_ID` for the column name. Do filter on `SOC = 31` instead of using `School_Ownership_Code IS NULL AND State_Special_Schools = 'Yes'` for the WHERE condition. The amended query now correctly selects the NCES district identifier using the proper ownership code filter instead of the incorrect null check and special school flag combination."
        ],
        "rules": [
            "1) When the question asks for \"National Center for Educational Statistics school district identification number\": select the exact column \"NCESDist\" from the schools table. 2) When the question mentions schools with a \"School Ownership Code\": filter using the exact literal value 31 for the SOC column (SOC = 31). 3) When the question mentions schools that are \"part of the State Special Schools\": this condition is already encoded in the SOC = 31 filter, so no additional filtering is needed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT School_District_ID FROM schools WHERE School_Ownership_Code IS NULL AND State_Special_Schools = 'Yes';",
            "SELECT NCESDist FROM schools WHERE SOC = '31';"
        ],
        "rule_sql": [
            "SELECT NCESDist FROM schools WHERE SOC = '31';"
        ],
        "amend_res": 1
    },
    "438": {
        "db_id": "card_games",
        "question": "Point out the language of set id \"174\"?",
        "evidence": "",
        "ground_truth": "SELECT language FROM set_translations WHERE id = 174",
        "amends": [
            "Do query the `set_translations` table instead of the `sets` table. Do use a numeric value `174` instead of a string literal `'174'` for the id comparison. The amended query now correctly retrieves language data from the appropriate translations table with proper numeric comparison."
        ],
        "rules": [
            "1) When answering about language data for a set id: query the \"set_translations\" table instead of the \"sets\" table. 2) When comparing set id values: use numeric comparison with value 174 instead of string literal '174'. 3) When retrieving language information: select the \"language\" column from the \"set_translations\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM sets WHERE id = '174';",
            "SELECT language FROM set_translations WHERE id = 174;"
        ],
        "rule_sql": [
            "SELECT language FROM set_translations WHERE id = 174"
        ],
        "amend_res": 1
    },
    "889": {
        "db_id": "formula_1",
        "question": "When was the last f1 season whereby Brands Hatch hosted the British Grand Prix?",
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Brands Hatch' AND T2.name = 'British Grand Prix' ORDER BY T2.year DESC LIMIT 1",
        "amends": [
            "Do select `T2.date` instead of `MAX(season)` to retrieve the actual date value rather than the maximum season number. Do join `circuits AS T1` with `races AS T2` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table, establishing the proper relationship between circuits and races. Do filter on `T1.name = 'Brands Hatch'` instead of `circuit_name = 'Brands Hatch'` to use the correct column name from the circuits table. Do add `T2.name = 'British Grand Prix'` instead of `country = 'UK'` to specifically identify the British Grand Prix race rather than filtering by country. Do add `ORDER BY T2.year DESC LIMIT 1` instead of omitting ordering and limiting, ensuring the most recent race date is returned. The amended query now correctly retrieves the date of the most recent British Grand Prix at Brands Hatch by properly joining tables and using accurate filtering criteria."
        ],
        "rules": [
            "1) When answering about \"last f1 season with British Grand Prix at Brands Hatch\": make sure the output order: T2.date 2) When combining circuits and races tables: link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match). 3) When the question mentions \"Brands Hatch\": \"Brands Hatch\" actually means T1.name = 'Brands Hatch' in schema. 4) When the question mentions \"British Grand Prix\": \"British Grand Prix\" actually means T2.name = 'British Grand Prix' in schema. 5) When the question asks for \"last\" or \"most recent\": rank rows by T2.year in descending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(season) FROM races WHERE circuit_name = 'Brands Hatch' AND country = 'UK'",
            "SELECT T2.date \nFROM circuits AS T1 \nJOIN races AS T2 ON T2.circuitId = T1.circuitId \nWHERE T1.name = 'Brands Hatch' \nAND T2.name = 'British Grand Prix' \nORDER BY T2.year DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.date \nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Brands Hatch' \nAND T2.name = 'British Grand Prix'\nORDER BY T2.year DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1086": {
        "db_id": "european_football_2",
        "question": "What's the heading accuracy of Ariel Borysiuk?",
        "evidence": "",
        "ground_truth": "SELECT t2.heading_accuracy FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ariel Borysiuk'",
        "amends": [
            "Do select `t2.heading_accuracy` from the joined table instead of `heading_accuracy` directly from the players table. Do add `Player_Attributes AS t2` as a source table instead of omitting it. Do use `INNER JOIN` with `ON t1.player_api_id = t2.player_api_id` instead of querying a single table. Do reference `t1.player_name` in the WHERE clause instead of `name`. Do qualify the column with table aliases throughout instead of using unqualified column names. The amended query now correctly joins the Player and Player_Attributes tables to retrieve the heading_accuracy from the appropriate source and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"heading accuracy of Ariel Borysiuk\": make sure the output order: t2.heading_accuracy. 2) When the question mentions \"Ariel Borysiuk\": \"Ariel Borysiuk\" actually means t1.player_name in schema. 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.player_api_id = t2.player_api_id); keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT heading_accuracy FROM players WHERE name = 'Ariel Borysiuk'",
            "SELECT t2.heading_accuracy \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Ariel Borysiuk'"
        ],
        "rule_sql": [
            "SELECT t2.heading_accuracy FROM Player t1 JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Ariel Borysiuk'"
        ],
        "amend_res": 1
    },
    "865": {
        "db_id": "formula_1",
        "question": "For all the drivers who finished the game in race No. 592, who is the oldest?",
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 592 AND T2.time IS NOT NULL AND T1.dob IS NOT NULL ORDER BY T1.dob ASC LIMIT 1",
        "amends": [
            "Do select `forename` and `surname` instead of just `driver_name`. Do join `results` table with `drivers` using `INNER JOIN` on `driverId` instead of querying only the `drivers` table. Do add filter `raceId = 592` in the joined table instead of filtering directly on the drivers table. Do add conditions `time IS NOT NULL` and `dob IS NOT NULL` instead of omitting these null checks. Do order by `dob` instead of `age` to sort by birth date rather than age. The amended query now correctly identifies drivers who participated in race 592 with recorded finish times and known birth dates, returning the oldest participant by date of birth instead of using an unspecified age field.",
            "Do use table aliases `T1` and `T2` instead of `d` and `r` for better clarity. Do specify `T2.driverId = T1.driverId` in the join condition instead of `r.driverId = d.driverId` to maintain consistent table reference order. Do remove the `dob` column from the SELECT list instead of including it since it's only needed for ordering. The amended query now correctly retrieves only the driver names while maintaining the same filtering and ordering logic to find the youngest driver with valid results in race 592."
        ],
        "rules": [
            "1) When answering about drivers who finished a race: combine the \"drivers\" table (T1) and \"results\" table (T2) by matching rows where T1.\"driverId\" equals T2.\"driverId\" and keep only matching pairs. 2) When filtering for race No. 592: use the exact literal value 592 for T2.\"raceId\" column. 3) When identifying finished drivers: ensure T2.\"time\" is not null to confirm completion. 4) When checking for known birth dates: ensure T1.\"dob\" is not null. 5) When determining the oldest driver: order by T1.\"dob\" in ascending order (earliest birth date first) and take the first result. 6) When outputting driver names: return both T1.\"forename\" and T1.\"surname\" columns instead of a single driver_name field.",
            "1) When answering about drivers who finished a specific race: use table aliases T1 for drivers and T2 for results. 2) When combining driver and race result information: link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match). 3) When filtering for race No. 592: include only rows where T2.raceId = 592. 4) When identifying drivers who finished the game: include only rows where T2.time IS NOT NULL. 5) When ensuring valid driver age information: include only rows where T1.dob IS NOT NULL. 6) When finding the oldest driver: order rows by T1.dob in ascending order and keep the first 1 row. 7) When outputting driver information: include only T1.forename and T1.surname in the results, not T1.dob."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM drivers WHERE race_id = 592 ORDER BY age ASC LIMIT 1;",
            "SELECT d.forename, d.surname, d.dob\nFROM results r\nINNER JOIN drivers d ON r.driverId = d.driverId\nWHERE r.raceId = 592 \nAND r.time IS NOT NULL \nAND d.dob IS NOT NULL\nORDER BY d.dob ASC\nLIMIT 1;",
            "SELECT T1.forename, T1.surname\nFROM drivers T1\nINNER JOIN results T2 ON T2.driverId = T1.driverId\nWHERE T2.raceId = 592\nAND T2.time IS NOT NULL\nAND T1.dob IS NOT NULL\nORDER BY T1.dob ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.forename, T1.surname \nFROM drivers T1 \nINNER JOIN results T2 ON T1.driverId = T2.driverId \nWHERE T2.raceId = 592 \nAND T2.time IS NOT NULL \nAND T1.dob IS NOT NULL \nORDER BY T1.dob ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "870": {
        "db_id": "formula_1",
        "question": "What's Lucas di Grassi's Q1 result in the race No. 345?",
        "ground_truth": "SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 345 AND T2.forename = 'Lucas' AND T2.surname = 'di Grassi'",
        "amends": [
            "Do select `T1.q1` from the `qualifying` table instead of `q1_result` from `race_results`. Do join `drivers AS T2` with `qualifying AS T1` using `T2.driverId = T1.driverId` instead of querying a single table. Do filter on `T1.raceId = 345` instead of `race_id = 345`. Do filter on `T2.forename = 'Lucas'` and `T2.surname = 'di Grassi'` instead of `driver_name = 'Lucas di Grassi'` to properly match the driver's first and last name separately. The amended query now correctly retrieves qualifying results from the appropriate table with proper driver identification."
        ],
        "rules": [
            "1) When answering about a driver's qualifying result: select the exact column \"q1\" from table \"qualifying\" (aliased as T1) instead of \"q1_result\" from \"race_results\". 2) When combining driver and qualifying information: join table \"drivers\" (aliased as T2) with \"qualifying\" (T1) using the exact key equality T2.driverId = T1.driverId and keep only matching pairs (inner match). 3) When filtering by race identifier: use the exact column \"raceId\" from table \"qualifying\" (T1) with value 345 instead of \"race_id\". 4) When identifying driver \"Lucas di Grassi\": use the exact columns \"forename\" with value 'Lucas' and \"surname\" with value 'di Grassi' from table \"drivers\" (T2) instead of a single \"driver_name\" column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT q1_result FROM race_results WHERE driver_name = 'Lucas di Grassi' AND race_id = 345;",
            "SELECT T1.q1 \nFROM qualifying AS T1\nJOIN drivers AS T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 345\nAND T2.forename = 'Lucas' \nAND T2.surname = 'di Grassi'"
        ],
        "rule_sql": [
            "SELECT T1.q1 FROM qualifying T1 INNER JOIN drivers T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 345 AND T2.forename = 'Lucas' AND T2.surname = 'di Grassi'"
        ],
        "amend_res": 1
    },
    "1305": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients accepted to the hospital have a normal level of white blood cells?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC BETWEEN 3.5 AND 9 AND T1.Admission = '+'",
        "amends": [
            "Do select `COUNT(T1.ID)` from joined tables instead of `COUNT(*)` from a single table. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.WBC BETWEEN 3.5 AND 9` instead of `white_blood_cells = 'normal'` and add the condition `T1.Admission = '+'` instead of omitting it. The amended query now correctly counts patients with normal white blood cell values between 3.5 and 9 who have been admitted, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count using the patient's canonical key. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using an inner match. 3) When filtering for normal white blood cells: use T2.WBC BETWEEN 3.5 AND 9 instead of checking for 'normal' text values. 4) When identifying admitted patients: include the condition T1.Admission = '+' to filter for patients who have been accepted to the hospital."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE white_blood_cells = 'normal';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.WBC BETWEEN 3.5 AND 9 \nAND T1.Admission = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Admission = '+' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "amend_res": 1
    },
    "1335": {
        "db_id": "student_club",
        "question": "How much did the Student_Club members spend on advertisement in September Meeting?",
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Advertisement' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "amends": [
            "Do select `T2.spent` instead of `SUM(amount)` to reference the correct column from the budget table. Do use `FROM event AS T1 INNER JOIN budget AS T2` instead of `FROM expenses` to join the event and budget tables rather than querying a single expenses table. Do specify the join condition `ON T1.event_id = T2.link_to_event` instead of no join condition to properly relate events to their budgets. Do filter with `T1.event_name = 'September Meeting'` instead of `month = 'September'` to use the event name rather than a month column. Do filter with `T2.category = 'Advertisement'` instead of `category = 'advertisement'` to use the budget category with proper capitalization. Do add `SUBSTR(T1.event_date, 6, 2) = '09'` instead of omitting date-based filtering to extract the month from the event date field. Do remove the `club = 'Student_Club'` filter instead of keeping it as the query now focuses on specific event relationships rather than club membership. The amended query now correctly retrieves budget spending for a specific September event with proper table relationships and filtering."
        ],
        "rules": [
            "1) When answering about \"spend on advertisement\": select \"T2\".\"spent\" instead of SUM(amount) to reference the correct column from the budget table. 2) When combining event and budget tables: use FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event to properly relate events to their budgets. 3) When filtering for September Meeting: use T1.event_name = 'September Meeting' instead of month-based filtering. 4) When filtering for advertisement category: use T2.category = 'Advertisement' with exact capitalization. 5) When checking for September events: use SUBSTR(T1.event_date, 6, 2) = '09' to extract the month from the event date field. 6) When the question mentions Student_Club: do not include club = 'Student_Club' filter as the query focuses on specific event relationships rather than club membership."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM expenses WHERE category = 'advertisement' AND month = 'September' AND club = 'Student_Club'",
            "SELECT T2.spent \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'September Meeting' \nAND T2.category = 'Advertisement' \nAND SUBSTR(T1.event_date, 6, 2) = '09'"
        ],
        "rule_sql": [
            "SELECT T2.spent \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'September Meeting' \nAND T2.category = 'Advertisement' \nAND SUBSTR(T1.event_date, 6, 2) = '09'"
        ],
        "amend_res": 1
    },
    "147": {
        "db_id": "financial",
        "question": "How many female clients' accounts are in the region of South Bohemia?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'",
        "amends": [
            "Do count `T1.client_id` instead of `COUNT(*)` to avoid counting null values. Do join `district AS T2` on `T1.district_id = T2.district_id` instead of querying only the clients table. Do filter on `T1.gender = 'F'` instead of `gender = 'male'` to use the correct gender code. Do filter on `T2.A3 = 'south Bohemia'` instead of `region = 'South Bohemia'` to use the district table's region column with proper case sensitivity. The amended query now correctly joins tables and uses accurate column references to match the intended behavior."
        ],
        "rules": [
            "1) When counting clients: count using T1.client_id instead of all columns to avoid counting null values. 2) When combining clients and district tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match). 3) When filtering for female clients: use T1.gender = 'F' instead of 'male' to use the correct gender code. 4) When filtering for South Bohemia region: use T2.A3 = 'south Bohemia' instead of 'South Bohemia' to match the district table's region column with proper case sensitivity."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE gender = 'male' AND region = 'South Bohemia';",
            "SELECT COUNT(DISTINCT T1.client_id) \nFROM client AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT client.client_id) \nFROM client \nINNER JOIN district ON client.district_id = district.district_id \nWHERE client.gender = 'F' AND district.A3 = 'south Bohemia'"
        ],
        "amend_res": 1
    },
    "993": {
        "db_id": "formula_1",
        "question": "In which location does the Hungaroring circuit located? Also, find the country and coordinates of this circuit?",
        "ground_truth": "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring'",
        "amends": [
            "Do remove the `name` column from the SELECT list instead of including it, since the WHERE clause already filters by name and the column would be redundant in the output. Do keep the same FROM source `circuits` and WHERE filter `name = 'Hungaroring'` unchanged. The amended query now correctly returns only the country and coordinates for the specified circuit, matching the RIGHT_SQL's behavior.",
            "Do remove the `location` column from the SELECT list instead of including it, keeping only `country`, `lat`, and `lng` as the output columns. The FROM clause referencing the `circuits` table and the WHERE filter on `name = 'Hungaroring'` remain unchanged. The amended query now correctly matches the RIGHT_SQL's behavior by excluding the unnecessary location field from the result set."
        ],
        "rules": [
            "1) When the question asks about a specific circuit by name \"Hungaroring\": filter the circuits table where name equals 'Hungaroring' exactly. 2) When the question asks for location, country, and coordinates: select the location, country, lat, and lng columns from the circuits table. 3) When the WHERE clause already filters by a specific value: do not include the filtering column (name) in the output columns to avoid redundancy.",
            "1) When the question asks about a circuit's location but the schema shows 'location' refers to a city/place name while the question seeks geographical coordinates: exclude the 'location' column from output and include only 'country', 'lat', and 'lng' columns instead. 2) When filtering for a specific circuit by name: use exact literal matching with 'Hungaroring' (case-sensitive) in the WHERE condition. 3) When selecting from the circuits table: maintain the table reference without aliases since only one table is involved."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, country, lat, lng FROM circuits WHERE name = 'Hungaroring';",
            "SELECT location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';",
            "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring';"
        ],
        "rule_sql": [
            "SELECT country, lat, lng FROM circuits WHERE name = 'Hungaroring';"
        ],
        "amend_res": 1
    },
    "1319": {
        "db_id": "student_club",
        "question": "Which college is the vice president of the Student_Club from?",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position LIKE 'vice president'",
        "amends": [
            "Do select `T2.college` from the `major` table instead of `college` from the `Student_Club` table. Do join `member AS T1` with `major AS T2` using `INNER JOIN` on `T1.link_to_major = T2.major_id` instead of querying only the `Student_Club` table without any joins. Do filter with `T1.position LIKE 'vice president'` instead of `position = 'president'` to match the correct position criteria. The amended query now correctly retrieves college information from the major table through proper table relationships and filtering."
        ],
        "rules": [
            "1) When the question asks about \"college\" for a Student_Club position: retrieve the college from the major table (T2.college) instead of from the Student_Club table. 2) When combining member and major tables: link rows where T1.link_to_major equals T2.major_id using an inner join to ensure only matching pairs are kept. 3) When filtering for the vice president position: use T1.position LIKE 'vice president' to match the exact position criteria with case sensitivity. 4) When the question mentions \"vice president\": this refers to the exact literal 'vice president' in the position column of the member table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT college FROM Student_Club WHERE position = 'president';",
            "SELECT T2.college \nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T1.position LIKE 'vice president'"
        ],
        "rule_sql": [
            "SELECT T2.college \nFROM member T1\nINNER JOIN major T2 ON T1.link_to_major = T2.major_id\nWHERE T1.position LIKE 'vice president'"
        ],
        "amend_res": 1
    },
    "1142": {
        "db_id": "european_football_2",
        "question": "In the 2015\u20132016 season, how many games were played in the Italian Serie A league?",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Italy Serie A' AND t2.season = '2015/2016'",
        "amends": [
            "Do reference `Match` table as `t2` instead of `games` table. Do join `League` as `t1` with `Match` as `t2` on `t1.id = t2.league_id` instead of querying a single table. Do filter by `t1.name = 'Italy Serie A'` instead of `league = 'Italian Serie A'`. Do filter by `t2.season = '2015/2016'` instead of `season = '2015-2016'`. Do count `t2.id` instead of using `COUNT(*)`. The amended query now correctly joins league and match tables with proper foreign key relationships and uses the exact league name and season format from the database schema."
        ],
        "rules": [
            "1) When answering about games played in a specific league and season: join League table as T1 with Match table as T2 on T1.id = T2.league_id to combine league and match information. 2) When the question mentions \"Italian Serie A league\": use T1.name = 'Italy Serie A' as the exact league name filter. 3) When the question mentions \"2015\u20132016 season\": use T2.season = '2015/2016' as the exact season format. 4) When counting games: count T2.id as the canonical key for matches instead of counting all rows. 5) When combining T1 and T2 for shared entities: link rows where T1.id = T2.league_id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM games WHERE season = '2015-2016' AND league = 'Italian Serie A';",
            "SELECT COUNT(t2.id) \nFROM League AS t1 \nJOIN Match AS t2 ON t1.id = t2.league_id \nWHERE t1.name = 'Italy Serie A' \nAND t2.season = '2015/2016'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.id) AS games_played\nFROM League AS T1\nINNER JOIN Match AS T2 ON T1.id = T2.league_id\nWHERE T1.name = 'Italy Serie A'\nAND T2.season = '2015/2016'"
        ],
        "amend_res": 1
    },
    "425": {
        "db_id": "card_games",
        "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
        "ground_truth": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
        "amends": [
            "Do select `id` instead of `card_number` from the `cards` table. Do use equality filter `subtypes = 'Angel,Wizard'` instead of multiple `LIKE '%Angel%' AND LIKE '%Wizard%'` conditions. Do add filter `side IS NULL` instead of omitting it. Do remove `GROUP BY card_number` and `HAVING COUNT(*) = 1` instead of keeping unnecessary aggregation. The amended query now correctly filters for cards with exactly the 'Angel,Wizard' subtype combination and null side values, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting card identifiers from the cards table: use the exact column name \"id\" instead of \"card_number\". 2) When filtering for cards with both Angel and Wizard subtypes: use exact equality comparison subtypes = 'Angel,Wizard' instead of multiple LIKE conditions. 3) When filtering for cards without multiple faces: include the condition side IS NULL to ensure single-face cards. 4) When the question asks for cards that don't have multiple faces: do not use unnecessary GROUP BY and HAVING COUNT(*) = 1 aggregation - simple filtering with side IS NULL is sufficient."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_number \nFROM cards \nWHERE subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%' \nGROUP BY card_number \nHAVING COUNT(*) = 1;",
            "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL"
        ],
        "amend_res": 1
    },
    "279": {
        "db_id": "toxicology",
        "question": "What is the label for bond ID TR001_10_11?",
        "ground_truth": "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select only `T2.label` instead of all columns with `*`. Do specify `bond` as `T1` and `molecule` as `T2` instead of just `bonds`. Do add `INNER JOIN molecule AS T2` instead of omitting the join. Do use join condition `T1.molecule_id = T2.molecule_id` instead of no join. Do filter on `T1.bond_id` instead of `id`. The amended query now correctly retrieves the molecule label for the specified bond ID through proper table joining."
        ],
        "rules": [
            "1) When answering about \"label for bond ID\": make sure the output order: T2.label 2) When the question mentions \"bond ID\": \"bond ID\" actually means \"T1.bond_id in schema\" 3) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match). 4) When filtering for a specific bond ID: use exact literal 'TR001_10_11' with T1.bond_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM bonds WHERE id = 'TR001_10_11';",
            "SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'"
        ],
        "rule_sql": [
            "SELECT T2.label FROM bond T1 JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_10_11'"
        ],
        "amend_res": 1
    },
    "75": {
        "db_id": "california_schools",
        "question": "What is the educational level name for the schools with Breakfast Provision 2 in county code 37? Indicate the name of the school.",
        "evidence": "",
        "ground_truth": "SELECT T2.EILName, T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = 37",
        "amends": [
            "Do select `T2.EILName` and `T2.School` instead of `school_name` and `educational_level_name`. Do use `frpm AS T1 INNER JOIN schools AS T2` instead of only `FROM schools`. Do join on `T1.CDSCode = T2.CDSCode` instead of no join condition. Do filter on `T1.NSLP Provision Status` instead of `breakfast_provision`. Do filter on `T1.County Code` instead of `county_code`. The amended query now correctly joins the frpm and schools tables using CDSCode and filters on the appropriate columns from the frpm table to match the intended logic.",
            "Do use backticks `NSLP Provision Status` instead of double quotes for the column name, and change the filter value to `'Breakfast Provision 2'` instead of `'2'`. Do remove quotes around the numeric value `37` instead of keeping them as `'37'` in the County Code filter. The amended query now correctly matches the intended filtering logic and proper column referencing syntax."
        ],
        "rules": [
            "1) When answering about educational level name and school name: make sure the output order: T2.School, T2.EILName\n2) When the question mentions \"Breakfast Provision 2\": \"Breakfast Provision 2\" actually means T1.\"NSLP Provision Status\" = 'Breakfast Provision 2' in schema\n3) When the question mentions \"county code 37\": \"county code 37\" actually means T1.\"County Code\" = 37 in schema\n4) When combining T1 (frpm) and T2 (schools) for shared entities: link rows where T1.CDSCode = T2.CDSCode exactly as shown in the amends; keep only matching pairs (inner match)\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like T1.\"NSLP Provision Status\" and T1.\"County Code\"",
            "1) When the question mentions \"Breakfast Provision 2\": use the exact literal value 'Breakfast Provision 2' for filtering the \"NSLP Provision Status\" column. 2) When filtering on numeric county codes: use the numeric value 37 without quotes for the \"County Code\" column. 3) When referencing column names with spaces: use backticks around \"NSLP Provision Status\" instead of double quotes. 4) When joining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match). 5) When answering about educational level name and school name: output T2.EILName and T2.School in that order."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, educational_level_name \nFROM schools \nWHERE county_code = 37 \nAND breakfast_provision = 'Breakfast Provision 2';",
            "SELECT T2.EILName, T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"NSLP Provision Status\" = '2' AND T1.\"County Code\" = '37';",
            "SELECT T2.EILName, T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2'\nAND T1.`County Code` = 37;"
        ],
        "rule_sql": [
            "SELECT T2.School, T2.EILName\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"NSLP Provision Status\" = 'Breakfast Provision 2'\nAND T1.\"County Code\" = 37"
        ],
        "amend_res": 1
    },
    "332": {
        "db_id": "toxicology",
        "question": "Among the molecules between TR004 to TR010, how many of them has single bonds?",
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' AND T.bond_type = '-'",
        "amends": [
            "Do select `COUNT(DISTINCT T.molecule_id)` instead of `COUNT(*)` to count distinct molecules rather than all bonds. Do query from `bond AS T` instead of `molecules` to access the correct table containing bond information. Do reference columns with table alias `T.molecule_id` and `T.bond_type` instead of unqualified column names for clarity and to avoid ambiguity. Do filter for `T.bond_type = '-'` instead of `bond_type = 'single'` to use the correct bond type representation. The amended query now correctly counts distinct molecules with bonds of the specified type within the given ID range, matching the intended behavior."
        ],
        "rules": [
            "1) When counting molecules: count distinct T.molecule_id instead of counting all rows to get unique molecule counts. 2) When accessing bond information: query from bond AS T instead of molecules table to use the correct data source. 3) When filtering by molecule ID range: use T.molecule_id BETWEEN 'TR004' AND 'TR010' to select molecules within the specified range. 4) When filtering by bond type: use T.bond_type = '-' instead of 'single' to match the correct bond type representation in the schema. 5) When referencing columns: always use table alias T with column names (T.molecule_id, T.bond_type) for clarity and to avoid ambiguity."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE molecule_id BETWEEN 'TR004' AND 'TR010' AND bond_type = 'single';",
            "SELECT COUNT(DISTINCT T.molecule_id) \nFROM bond AS T \nWHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' \nAND T.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T.molecule_id) \nFROM bond AS T \nWHERE T.molecule_id BETWEEN 'TR004' AND 'TR010' \nAND T.bond_type = '-'"
        ],
        "amend_res": 1
    },
    "1118": {
        "db_id": "european_football_2",
        "question": "List down the name of players who are 35 years old and above.",
        "ground_truth": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
        "amends": [
            "Do select `player_name` instead of `name` and use `Player` table instead of `players`. Do calculate age dynamically using `CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35` instead of static `age < 35` to properly handle date-based age calculation. The amended query now correctly filters for players aged 35 or older rather than under 35, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for player names: use the exact column token \"player_name\" from table \"Player\" instead of \"name\". 2) When calculating age from birthday: compute age dynamically using (current date minus birthday date) divided by 365 days, not using a static age column. 3) When filtering for players 35 years old and above: use >= 35 condition, not < 35 condition. 4) When the question mentions \"35 years old and above\": this means age must be greater than or equal to 35, inclusive of 35-year-olds."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT name FROM players WHERE age < 35;",
            "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE (julianday('now') - julianday(birthday)) / 365.25 >= 35;"
        ],
        "amend_res": 1
    },
    "523": {
        "db_id": "card_games",
        "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
        "ground_truth": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
        "amends": [
            "Do use `(CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4` instead of `AVG(num_parts)` for the calculation. Do add `INNER JOIN set_translations AS T2 ON T1.id = T2.id` instead of querying only the `sets` table. Do reference `T1.releaseDate` instead of `release_date` in the WHERE clause. Do group by `T1.releaseDate` instead of `language`. Do add `ORDER BY COUNT(T2.language) DESC LIMIT 1` instead of omitting ordering and limiting. Do remove the alias `avg_sets` instead of keeping it. The amended query now correctly calculates a complex average with proper table joins and returns the single highest result."
        ],
        "rules": [
            "1) When calculating the annual average number of sets: use (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4 instead of AVG(num_parts). 2) When combining data from sets and set_translations tables: perform an INNER JOIN between T1 (sets) and T2 (set_translations) using T1.id = T2.id. 3) When filtering by release date range: use T1.releaseDate instead of release_date with the range '2012-01-01' to '2015-12-31'. 4) When grouping results: group by T1.releaseDate instead of language. 5) When ordering and limiting results: order by COUNT(T2.language) in descending order and keep only the top 1 result. 6) When presenting output: do not use the alias avg_sets for the calculated result."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(num_parts) as avg_sets, language \nFROM sets \nWHERE release_date BETWEEN '2012-01-01' AND '2015-12-31' \nGROUP BY language;",
            "SELECT \n    (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4,\n    T2.language\nFROM \n    sets AS T1\nINNER JOIN \n    set_translations AS T2 ON T1.id = T2.id\nWHERE \n    T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY \n    T1.releaseDate\nORDER BY \n    COUNT(T2.language) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(T1.id) AS REAL) / 4) AS result,\n    T2.language\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.id = T2.id\nWHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\nGROUP BY T1.releaseDate\nORDER BY COUNT(T2.language) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "956": {
        "db_id": "formula_1",
        "question": "Which drivers born after 1975 have been ranked 2? Please give their forenames and surnames.",
        "ground_truth": "SELECT T2.forename, T2.surname FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE STRFTIME('%Y', T2.dob) > '1975' AND T1.rank = 2",
        "amends": [
            "Do join `results AS T1` with `drivers AS T2` on `T1.driverId = T2.driverId` instead of querying only the `drivers` table without any join. Do reference columns as `T2.forename` and `T2.surname` instead of just `forename` and `surname`. Do use `STRFTIME('%Y', T2.dob)` for year extraction instead of `year(birthdate)`. Do filter on `T1.rank = 2` instead of `position = 2`. The amended query now correctly joins results with drivers and uses proper table aliasing and date formatting to match the intended behavior."
        ],
        "rules": [
            "1) When answering about drivers ranked 2: join table \"results\" as T1 with table \"drivers\" as T2 on T1.driverId = T2.driverId to combine race results with driver information. 2) When the question mentions \"born after 1975\": use STRFTIME('%Y', T2.dob) to extract the year from the date of birth and compare it to be greater than 1975. 3) When the question mentions \"ranked 2\": filter on T1.rank = 2 instead of position = 2. 4) When selecting driver names: reference columns as T2.forename and T2.surname to specify the correct table source. 5) When combining results and drivers tables: perform an inner join where T1.driverId = T2.driverId to keep only matching driver-result pairs."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT forename, surname FROM drivers WHERE year(birthdate) > 1975 AND position = 2;",
            "SELECT T2.forename, T2.surname\nFROM results AS T1\nJOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE STRFTIME('%Y', T2.dob) > '1975'\nAND T1.rank = 2;"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname \nFROM results AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE STRFTIME('%Y', T2.dob) > '1975' \nAND T1.rank = 2;"
        ],
        "amend_res": 1
    },
    "1114": {
        "db_id": "european_football_2",
        "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.`date`, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
        "amends": [
            "Do join `Player` table as `t1` with `Player_Attributes` as `t2` on `t1.player_fifa_api_id = t2.player_fifa_api_id` instead of querying only `player_ratings` table. Do calculate average using `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(overall_rating)` to ensure proper division handling. Do filter by `t1.player_name = 'Marko Arnautovic'` instead of `player_name` to reference the correct table. Do use `SUBSTR(t2.date, 1, 10)` for date extraction with ISO format dates `'2007-02-22'` and `'2016-04-21'` instead of direct `date` field comparison with slash-separated dates. The amended query now correctly joins player information with attributes and handles date filtering properly to match the intended behavior."
        ],
        "rules": [
            "1) When answering about average overall rating for a specific player: join Player table as T1 with Player_Attributes table as T2 on T1.player_fifa_api_id = T2.player_fifa_api_id to combine player information with attributes. 2) When calculating average overall rating: use CAST(SUM(T2.overall_rating) AS REAL) / COUNT(T2.id) instead of AVG(overall_rating) to ensure proper division handling. 3) When filtering by player name: use T1.player_name = 'Marko Arnautovic' to reference the correct table. 4) When filtering by date range: use SUBSTR(T2.date, 1, 10) for date extraction with ISO format dates '2007-02-22' and '2016-04-21' instead of direct date field comparison with slash-separated dates."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) FROM player_ratings WHERE player_name = 'Marko Arnautovic' AND date BETWEEN '2007/2/22' AND '2016/4/21';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1\nJOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id\nWHERE t1.player_name = 'Marko Arnautovic'\nAND SUBSTR(t2.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T2.overall_rating) AS REAL) / COUNT(T2.id) AS average_overall_rating\nFROM Player AS T1\nJOIN Player_Attributes AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id\nWHERE T1.player_name = 'Marko Arnautovic'\nAND SUBSTR(T2.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'"
        ],
        "amend_res": 1
    },
    "992": {
        "db_id": "formula_1",
        "question": "Find the full name, Wiki Pedia page link, and date of birth of German drivers born between 1971 and 1985. List it in descending order of date of birth.",
        "ground_truth": "SELECT forename, surname, url, dob FROM drivers WHERE nationality = 'German' AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' ORDER BY dob DESC",
        "amends": [
            "Do select `forename`, `surname`, and `url` instead of `full_name` and `wikipedia_link`, and use `dob` instead of `date_of_birth`. Do use `STRFTIME('%Y', dob)` to extract the year instead of a direct date range comparison with `BETWEEN`. Do order by `dob DESC` instead of `ASC`. The amended query now correctly filters German drivers born between 1971 and 1985 regardless of month and day, and returns results in descending date order."
        ],
        "rules": [
            "1) When the question asks for \"full name\": use both \"forename\" and \"surname\" columns from table \"drivers\" to construct the full name. 2) When the question asks for \"Wiki Pedia page link\": use the \"url\" column from table \"races\" instead of a \"wikipedia_link\" column. 3) When the question asks for \"date of birth\": use the \"dob\" column from table \"drivers\" instead of \"date_of_birth\". 4) When filtering for drivers born between 1971 and 1985: extract the year from \"dob\" using STRFTIME('%Y', dob) and check if it falls between 1971 and 1985 inclusive, rather than using date range comparison with BETWEEN. 5) When ordering results by date of birth: use \"dob DESC\" for descending order instead of ascending order."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT full_name, wikipedia_link, date_of_birth \nFROM drivers \nWHERE nationality = 'German' \nAND date_of_birth BETWEEN '1971-01-01' AND '1985-12-31' \nORDER BY date_of_birth ASC;",
            "SELECT forename, surname, url, dob \nFROM drivers \nWHERE nationality = 'German' \nAND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985' \nORDER BY dob DESC;"
        ],
        "rule_sql": [
            "SELECT \n    forename || ' ' || surname AS full_name,\n    url AS wiki_pedia_page_link,\n    dob AS date_of_birth\nFROM \n    drivers\nWHERE \n    nationality = 'German'\n    AND STRFTIME('%Y', dob) BETWEEN '1971' AND '1985'\nORDER BY \n    dob DESC;"
        ],
        "amend_res": 1
    },
    "247": {
        "db_id": "toxicology",
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.element NOT IN ( SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id )",
        "amends": [
            "Do select only `T.element` with `DISTINCT` instead of selecting all columns with `*`. Do use table alias `T` for the `atom` table instead of the unaliased `atoms` table. Do add a subquery to filter elements that appear in connected atoms instead of checking `bond_count = 0`. Do use `NOT IN` with a correlated subquery that joins `atom` and `connected` tables on `atom_id` instead of the simple equality filter. Do remove the incorrect `bond_count` column reference since it doesn't exist in the schema. The amended query now correctly identifies elements that have no connections by checking which elements don't appear in the connected atoms relationship."
        ],
        "rules": [
            "1) When selecting elements from the atom table: use table alias T for the atom table instead of the unaliased atoms table. 2) When answering about elements that cannot bond with other atoms: select only T.element with DISTINCT instead of selecting all columns with *. 3) When filtering for elements with no connections: use NOT IN with a correlated subquery that joins atom and connected tables on atom_id instead of checking bond_count = 0. 4) When handling the connected table relationship: remove the incorrect bond_count column reference since it doesn't exist in the schema. 5) When joining atom and connected tables: link rows where T.atom_id equals the connected.atom_id to identify which elements appear in connected atoms."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM atoms WHERE bond_count = 0;",
            "SELECT DISTINCT T.element\nFROM atom T\nWHERE T.element NOT IN (\n    SELECT DISTINCT a.element\n    FROM atom a\n    JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.element FROM atom T WHERE T.atom_id NOT IN (SELECT atom_id FROM connected)"
        ],
        "amend_res": 1
    },
    "38": {
        "db_id": "california_schools",
        "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
        "evidence": "",
        "ground_truth": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
        "amends": [
            "Do select `T2.Website` instead of `webpage` and use table alias `T2` instead of direct table reference. Do join `satscores AS T1` with `schools AS T2` using `INNER JOIN` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T1.NumTstTakr BETWEEN 2000 AND 3000` instead of `test_takers BETWEEN 2000 AND 3000` and move this condition to the WHERE clause. Do keep `T2.County = 'Los Angeles'` filter but reference it through the table alias. The amended query now correctly joins the two tables and uses the appropriate column names from each table to match the intended logic."
        ],
        "rules": [
            "1) When answering about school webpages: select \"T2\".\"Website\" instead of \"webpage\" and use table alias \"T2\" for the schools table. 2) When combining SAT scores and schools data: join \"satscores\" as \"T1\" with \"schools\" as \"T2\" using inner join where \"T1\".\"cds\" = \"T2\".\"CDSCode\" to match related records. 3) When filtering for test takers count between 2000 and 3000: use \"T1\".\"NumTstTakr\" BETWEEN 2000 AND 3000 instead of \"test_takers\" and place this condition in the WHERE clause. 4) When filtering for Los Angeles County: use \"T2\".\"County\" = 'Los Angeles' with the exact literal value and proper table alias reference."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT webpage FROM schools WHERE county = 'Los Angeles' AND test_takers BETWEEN 2000 AND 3000;",
            "SELECT T2.Website\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nWHERE T2.County = 'Los Angeles'\nAND T1.NumTstTakr BETWEEN 2000 AND 3000;"
        ],
        "rule_sql": [
            "SELECT T2.Website\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.NumTstTakr BETWEEN 2000 AND 3000\nAND T2.County = 'Los Angeles'"
        ],
        "amend_res": 1
    },
    "1467": {
        "db_id": "student_club",
        "question": "Calculate the total amount spent on speaker gifts and list the name of the event they were spent on.",
        "ground_truth": "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name",
        "amends": [
            "Do use `SUM(T1.spent)` and `T2.event_name` in the SELECT list instead of `event_name` and `SUM(amount) as total_spent`. Do join `budget AS T1` with `event AS T2` using `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of querying only the `expenses` table. Do filter on `T1.category = 'Speaker Gifts'` instead of `category = 'speaker_gifts'`. Do group by `T2.event_name` instead of `event_name`. The amended query now correctly joins budget and event tables to calculate speaker gift spending per event, matching the intended behavior.",
            "Do place `SUM(T1.spent)` before `T2.event_name` in the SELECT list instead of the reverse order. Do remove the alias `total_spent` instead of keeping it. The amended query now correctly aggregates spending by event name without unnecessary aliasing."
        ],
        "rules": [
            "1) When answering about \"total amount spent on speaker gifts and event names\": make sure the output order: T2.event_name, SUM(T1.spent). 2) When the question mentions \"speaker gifts\": \"speaker gifts\" actually means \"T1.category = 'Speaker Gifts'\" in schema. 3) When combining budget as T1 and event as T2: link rows where T1.link_to_event = T2.event_id exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"total amount spent\": compute the sum of T1.spent. 5) When the question says \"per event\"/\"by event\": organize results by T2.event_name and compute requested aggregates per group.",
            "1) When answering about \"total amount spent on speaker gifts and list the name of the event\": make sure the output order: SUM(T1.spent) before T2.event_name. 2) When the question asks for \"total amount spent\": compute the sum of T1.spent. 3) When the question mentions \"speaker gifts\": \"speaker gifts\" actually means T1.category = 'Speaker Gifts' in the schema. 4) When combining budget table (T1) and event table (T2): link rows where T1.link_to_event = T2.event_id and keep only matching pairs (inner match). 5) When the question asks for results \"by event\": organize results by T2.event_name and compute the sum per group. 6) When producing output: do not add aliases like total_spent to aggregated columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name, SUM(amount) as total_spent FROM expenses WHERE category = 'speaker_gifts' GROUP BY event_name;",
            "SELECT T2.event_name, SUM(T1.spent) as total_spent\nFROM budget AS T1\nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Speaker Gifts'\nGROUP BY T2.event_name",
            "SELECT SUM(T1.spent), T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name"
        ],
        "rule_sql": [
            "SELECT SUM(T1.spent), T2.event_name FROM budget T1 JOIN event T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Speaker Gifts' GROUP BY T2.event_name"
        ],
        "amend_res": 1
    },
    "1475": {
        "db_id": "debit_card_specializing",
        "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
        "amends": [
            "Do join `yearmonth` table with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do filter on `T1.Segment = 'KAM'` instead of `region = 'KAM'`. Do use `SUBSTRING(T2.Date, 1, 4) = '2012'` for year filtering instead of `year = 2012`. Do aggregate with `GROUP BY T2.CustomerID` and apply `HAVING SUM(T2.Consumption) < 30000` instead of filtering individual records with `consumption >= 30000`. Do wrap the query in a subquery to count customer IDs instead of counting all records directly. The amended query now correctly counts customers with total consumption below 30,000 in 2012 rather than counting individual consumption records above that threshold."
        ],
        "rules": [
            "1) When the question mentions \"customers in KAM\": use \"T1.Segment = 'KAM'\" for filtering instead of region-based filtering. 2) When filtering for year 2012: extract year from date using \"SUBSTRING(T2.Date, 1, 4) = '2012'\" instead of a direct year column. 3) When combining customer and consumption data: join \"yearmonth\" table with \"customers\" table using \"T1.CustomerID = T2.CustomerID\" with inner join. 4) When calculating total consumption per customer: group by \"T2.CustomerID\" and compute \"SUM(T2.Consumption)\" for each customer. 5) When filtering for consumption less than 30,000: apply \"HAVING SUM(T2.Consumption) < 30000\" after grouping instead of filtering individual records. 6) When counting customers: wrap the grouped query in a subquery and count the distinct customer IDs rather than counting all records directly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE region = 'KAM' AND year = 2012 AND consumption >= 30000;",
            "SELECT COUNT(*) AS CustomerCount\nFROM (\n    SELECT T2.CustomerID\n    FROM customers T1\n    INNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\n    WHERE T1.Segment = 'KAM'\n    AND SUBSTRING(T2.Date, 1, 4) = '2012'\n    GROUP BY T2.CustomerID\n    HAVING SUM(T2.Consumption) < 30000\n) AS subquery"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS CustomerCount\nFROM (\n    SELECT T2.CustomerID\n    FROM customers T1\n    INNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\n    WHERE T1.Segment = 'KAM'\n    AND SUBSTRING(T2.Date, 1, 4) = '2012'\n    GROUP BY T2.CustomerID\n    HAVING SUM(T2.Consumption) < 30000\n) AS subquery"
        ],
        "amend_res": 1
    },
    "1255": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients with an abnormal Ig M level, what is the most common disease they are diagnosed with?",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM NOT BETWEEN 40 AND 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1",
        "amends": [
            "Do select `T1.Diagnosis` instead of `disease` and count `T1.Diagnosis` instead of `COUNT(*)`. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.IGM NOT BETWEEN 40 AND 400` instead of `ig_m_level = 'abnormal'`. Do group by `T1.Diagnosis` instead of `disease`. Do order by `COUNT(T1.Diagnosis) DESC` instead of `count DESC`. The amended query now correctly identifies patients with abnormal IgM levels outside the 40-400 range and matches the RIGHT_SQL's behavior.",
            "Do remove the `COUNT(T1.Diagnosis) AS count` column from the SELECT list instead of including it, as only the `T1.Diagnosis` is needed in the final output. The FROM clause with `INNER JOIN` on `T1.ID = T2.ID`, WHERE filter on `T2.IGM NOT BETWEEN 40 AND 400`, GROUP BY `T1.Diagnosis`, ORDER BY `COUNT(T1.Diagnosis) DESC`, and LIMIT 1 all remain unchanged. The amended query now correctly returns only the diagnosis with the highest count of patients having IGM values outside the 40-400 range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common disease for patients with abnormal Ig M level\": make sure the output order: T1.Diagnosis first, then count of T1.Diagnosis. 2) When the question mentions \"patients with an abnormal Ig M level\": \"abnormal\" actually means \"T2.IGM NOT BETWEEN 40 AND 400\" in the schema. 3) When combining Patient AS T1 and Laboratory AS T2 for shared patients: link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match). 4) When the question asks for \"count of diseases\": compute the number of rows using T1.Diagnosis as the counting key. 5) When the question asks for \"most common disease\": rank rows by count of T1.Diagnosis in descending order and keep the first 1 row.",
            "1) When answering about \"most common disease for patients with abnormal Ig M level\": make sure the output order: only include T1.Diagnosis in the final output without any count columns. 2) When the question mentions \"abnormal Ig M level\": \"abnormal\" actually means \"T2.IGM NOT BETWEEN 40 AND 400\" in the schema. 3) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When the question asks for \"most common disease\": group results by T1.Diagnosis, count the number of patients per diagnosis using the canonical key, rank diagnoses by count in descending order, and keep only the top 1 result. 5) When counting patients per diagnosis: use the canonical patient identifier (T1.ID) for counting, not the diagnosis field itself."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disease, COUNT(*) as count FROM patients WHERE ig_m_level = 'abnormal' GROUP BY disease ORDER BY count DESC LIMIT 1;",
            "SELECT T1.Diagnosis, COUNT(T1.Diagnosis) AS count\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1;",
            "SELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.Diagnosis) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGM NOT BETWEEN 40 AND 400\nGROUP BY T1.Diagnosis\nORDER BY COUNT(T1.ID) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1514": {
        "db_id": "debit_card_specializing",
        "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
        "ground_truth": "SELECT DISTINCT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
        "amends": [
            "Do select `DISTINCT T3.Currency` instead of `currency` from the `payments` table. Do use `transactions_1k AS T1` as the main table instead of `payments` and add joins to `gasstations AS T2` on `T1.GasStationID = T2.GasStationID` and `customers AS T3` on `T1.CustomerID = T3.CustomerID` instead of querying a single table. Do filter on `T1.Date = '2012-08-24'` with proper date format instead of `date = '2012/8/24'` and maintain the time filter `T1.Time = '16:25:00'` instead of `time = '16:25:00'`. The amended query now correctly retrieves distinct currencies from the customer table through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about currency paid by a customer: select distinct T3.Currency instead of currency from the payments table. 2) When combining transaction, gas station, and customer data: use transactions_1k AS T1 as the main table and join gasstations AS T2 on T1.GasStationID = T2.GasStationID and customers AS T3 on T1.CustomerID = T3.CustomerID. 3) When filtering by date: use T1.Date = '2012-08-24' with proper date format instead of '2012/8/24'. 4) When filtering by time: use T1.Time = '16:25:00' exactly as specified. 5) When handling table relationships: perform inner joins using the exact key equalities T1.GasStationID = T2.GasStationID and T1.CustomerID = T3.CustomerID."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT currency FROM payments WHERE time = '16:25:00' AND date = '2012/8/24';",
            "SELECT DISTINCT T3.Currency \nFROM transactions_1k AS T1\nJOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nJOIN customers AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.Currency\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'"
        ],
        "amend_res": 1
    },
    "1199": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients who underwent testing in 1997 had protein levels outside the normal range?",
        "ground_truth": "SELECT COUNT(ID) FROM Laboratory WHERE (ALB <= 6.0 OR ALB >= 8.5) AND STRFTIME('%Y', Date) = '1997'",
        "amends": [
            "Do select `COUNT(ID)` from `Laboratory` instead of `COUNT(*)` from `patients` and `tests`. Do use a single table `Laboratory` instead of joining `patients` and `tests`. Do filter with `(ALB <= 6.0 OR ALB >= 8.5)` instead of `protein_level < 60 OR protein_level > 80`. Do apply the year filter `STRFTIME('%Y', Date) = '1997'` with proper parentheses to combine with the protein condition instead of having incorrect operator precedence. Do reference columns `ID`, `ALB`, and `Date` instead of `patient_id`, `protein_level`, and `test_date`. The amended query now correctly counts laboratory records from 1997 with albumin levels outside the normal range of 6.0 to 8.5 g/dL."
        ],
        "rules": [
            "1) When answering about \"patients who underwent testing in 1997 had protein levels outside the normal range\": use table \"Laboratory\" instead of joining \"patients\" and \"tests\" tables. 2) When counting patients: count using \"ID\" column instead of counting all rows with COUNT(*). 3) When filtering for year 1997: use STRFTIME('%Y', Date) = '1997' to extract year from \"Date\" column. 4) When checking for protein levels outside normal range: use condition (ALB <= 6.0 OR ALB >= 8.5) instead of protein_level < 60 OR protein_level > 80. 5) When combining conditions: ensure proper parentheses are used to combine the year filter and protein level condition with correct operator precedence."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN tests t ON p.patient_id = t.patient_id\nWHERE strftime('%Y', t.test_date) = '1997'\nAND t.protein_level < 60 OR t.protein_level > 80;",
            "SELECT COUNT(ID) FROM Laboratory WHERE STRFTIME('%Y', Date) = '1997' AND (ALB <= 6.0 OR ALB >= 8.5)"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT ID) \nFROM Laboratory \nWHERE STRFTIME('%Y', Date) = '1997' \nAND (ALB <= 6.0 OR ALB >= 8.5)"
        ],
        "amend_res": 1
    },
    "832": {
        "db_id": "superhero",
        "question": "Name the tallest superhero.",
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "amends": [
            "Do select `superhero_name` instead of `name` and use table `superhero` instead of `superheroes`. Do order by `height_cm` in `DESC` order instead of `height` in `ASC` order. The amended query now correctly retrieves the tallest superhero by height in centimeters from the proper table with the correct column names and sort order."
        ],
        "rules": [
            "1) When the question asks for \"name\" of a superhero: use the exact column token \"superhero_name\" from table \"superhero\" instead of \"name\". 2) When the question asks about \"tallest\" superhero: order by \"height_cm\" in descending order to get the maximum height value. 3) When retrieving a single result for \"the tallest\": take only the first row after ordering by height in descending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes ORDER BY height ASC LIMIT 1;",
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "254": {
        "db_id": "toxicology",
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "ground_truth": "SELECT CAST((SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1 ) AS REAL) * 100 / ( SELECT COUNT(atom_id) FROM connected )",
        "amends": [
            "Do use `CAST` with `REAL` instead of implicit decimal conversion. Do calculate from `connected` and `bond` tables instead of only `bonds`. Do use `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of no join. Do aggregate by `T2.bond_type` instead of `atom1_element, atom2_element`. Do order by `COUNT(T2.bond_id)` descending instead of `COUNT(*)`. Do reference `atom_id` in both count expressions instead of `*`. Do structure as a complex scalar expression instead of a simple grouped query. The amended query now correctly calculates the percentage of the most frequent bond type among connected atoms.",
            "Do calculate the percentage using `(SELECT COUNT(T1.atom_id) FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id GROUP BY T2.bond_type ORDER BY COUNT(T2.bond_id) DESC LIMIT 1)` instead of a subquery that selects `bond_type` and `COUNT(bond_id)`. Do use `COUNT(T1.atom_id)` instead of `COUNT(*)` in the numerator subquery. Do reference `T2.bond_id` in the `ORDER BY` instead of the alias `bond_count`. Do multiply by `100` and then divide by the total count instead of multiplying by `100.0` after division. Do count `atom_id` from the `connected` table in the denominator instead of using `COUNT(*)`. The amended query now correctly calculates the percentage of atoms connected to the most common bond type."
        ],
        "rules": [
            "1) When calculating percentages involving bond types: use CAST with REAL instead of implicit decimal conversion for accurate percentage calculation. 2) When answering about bonds and their atom elements: combine data from both connected and bond tables using an inner join where T1.bond_id = T2.bond_id instead of using only one table. 3) When grouping bond types: aggregate by T2.bond_type instead of atom1_element and atom2_element. 4) When ordering by frequency: order by COUNT(T2.bond_id) descending instead of COUNT(*). 5) When counting bonds: reference atom_id in count expressions instead of using * for accurate entity counting. 6) When calculating the percentage of the most common bond type: structure the query as a complex scalar expression that computes (count of most frequent bond type) divided by (total count of bonds) multiplied by 100.0.",
            "1) When calculating percentage of bonds with the most common combination of atoms' elements: use COUNT(T1.atom_id) from connected table instead of COUNT(*) in the numerator. 2) When counting bonds for the most common bond type: group by T2.bond_type and order by COUNT(T2.bond_id) in descending order. 3) When computing the percentage: multiply the count by 100 and then divide by the total count of atom_id from connected table. 4) When joining connected and bond tables: link rows where T1.bond_id = T2.bond_id using an inner match. 5) When referencing columns: use exact identifiers T1.atom_id, T2.bond_id, and T2.bond_type as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM bonds)) AS percentage\nFROM bonds\nGROUP BY atom1_element, atom2_element\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT \n    (CAST(COUNT(*) AS REAL) / (SELECT COUNT(*) FROM connected)) * 100.0 AS percentage\nFROM (\n    SELECT \n        bond_type, \n        COUNT(bond_id) AS bond_count\n    FROM \n        connected c\n    INNER JOIN \n        bond b ON c.bond_id = b.bond_id\n    GROUP BY \n        bond_type\n    ORDER BY \n        bond_count DESC\n    LIMIT 1\n) AS most_common_bond;",
            "SELECT \n    (SELECT CAST(COUNT(T1.atom_id) AS REAL) \n     FROM connected AS T1 \n     INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id \n     GROUP BY T2.bond_type \n     ORDER BY COUNT(T2.bond_id) DESC \n     LIMIT 1) * 100.0 / \n    (SELECT COUNT(atom_id) FROM connected) \nAS percentage;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(T1.atom_id) AS REAL) * 100.0 / (SELECT COUNT(atom_id) FROM connected)) \nFROM \n    connected T1\n    INNER JOIN bond T2 ON T1.bond_id = T2.bond_id\nGROUP BY \n    T2.bond_type\nORDER BY \n    COUNT(T2.bond_id) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1382": {
        "db_id": "student_club",
        "question": "Among the students majored in interior design, who have attended the Community Theater event?",
        "ground_truth": "SELECT T2.first_name, T2.last_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id WHERE T4.event_name = 'Community Theater' AND T1.major_name = 'Interior Design'",
        "amends": [
            "Do select `first_name` and `last_name` instead of just `name`. Do use tables `major`, `member`, `attendance`, and `event` instead of `students` and `events`. Do perform `INNER JOIN` between `major` and `member` on `major_id = link_to_major` instead of incorrectly joining on a literal condition. Do add `INNER JOIN` with `attendance` on `member_id = link_to_member` instead of omitting this relationship. Do add `INNER JOIN` with `event` on `link_to_event = event_id` instead of the incorrect join condition. Do move the major filter to `WHERE major_name = 'Interior Design'` instead of having it in the join condition. Do keep the event filter `event_name = 'Community Theater'` in the `WHERE` clause but with proper table reference. The amended query now correctly models the relationships between majors, members, attendance, and events to find interior design majors who attended the Community Theater event."
        ],
        "rules": [
            "1) When answering about students majored in interior design who attended Community Theater event: use tables major, member, attendance, and event with aliases T1, T2, T3, T4 respectively. 2) When combining major and member tables: link rows where T1.major_id = T2.link_to_major and keep only matching pairs (inner match). 3) When combining member and attendance tables: link rows where T2.member_id = T3.link_to_member and keep only matching pairs (inner match). 4) When combining attendance and event tables: link rows where T3.link_to_event = T4.event_id and keep only matching pairs (inner match). 5) When filtering for interior design majors: use condition T1.major_name = 'Interior Design' in the WHERE clause. 6) When filtering for Community Theater event: use condition T4.event_name = 'Community Theater' in the WHERE clause. 7) When selecting output columns: include both T2.first_name and T2.last_name instead of just a name field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.name \nFROM students s\nJOIN events e ON s.major = 'interior design'\nWHERE e.event_name = 'Community Theater';",
            "SELECT m.first_name, m.last_name\nFROM member m\nINNER JOIN major maj ON m.link_to_major = maj.major_id\nINNER JOIN attendance a ON m.member_id = a.link_to_member\nINNER JOIN event e ON a.link_to_event = e.event_id\nWHERE maj.major_name = 'Interior Design'\nAND e.event_name = 'Community Theater';"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name\nFROM major T1\nINNER JOIN member T2 ON T1.major_id = T2.link_to_major\nINNER JOIN attendance T3 ON T2.member_id = T3.link_to_member\nINNER JOIN event T4 ON T3.link_to_event = T4.event_id\nWHERE T1.major_name = 'Interior Design'\nAND T4.event_name = 'Community Theater'"
        ],
        "amend_res": 1
    },
    "693": {
        "db_id": "codebase_community",
        "question": "Identify the number of posts and comments left by the user, who has the latest created user account.",
        "ground_truth": "SELECT COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY T1.CreationDate DESC LIMIT 1",
        "amends": [
            "Do use `COUNT(T2.Id)` instead of `COUNT(posts.id) AS post_count, COUNT(comments.id) AS comment_count` to count posts rather than both posts and comments. Do use `INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId` instead of `LEFT JOIN posts ON users.id = posts.user_id` to join on the correct owner relationship and use proper aliasing. Do use `INNER JOIN comments AS T3 ON T3.PostId = T2.Id` instead of `LEFT JOIN comments ON users.id = comments.user_id` to join comments to posts rather than directly to users. Do remove the `WHERE users.created_at = (SELECT MAX(created_at) FROM users)` filter instead of keeping it, as the logic now uses ordering and limiting. Do add `ORDER BY T1.CreationDate DESC LIMIT 1` instead of omitting ordering and limiting, to get only the most recent user's post count. The amended query now correctly counts posts (not comments) for the most recent user by joining comments to posts rather than directly to users, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting posts for a user: use COUNT(T2.Id) to count posts rather than counting both posts and comments. 2) When joining users to posts: use INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId to join on the correct owner relationship with proper aliasing. 3) When joining comments to posts: use INNER JOIN comments AS T3 ON T3.PostId = T2.Id to join comments to posts rather than directly to users. 4) When finding the user with the latest created account: use ORDER BY T1.CreationDate DESC LIMIT 1 instead of filtering with a subquery, to get only the most recent user. 5) When the question asks for both posts and comments by the latest user: count posts using T2.Id and comments using T3.Id after properly joining through the post relationship."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(posts.id) AS post_count, COUNT(comments.id) AS comment_count \nFROM users \nLEFT JOIN posts ON users.id = posts.user_id \nLEFT JOIN comments ON users.id = comments.user_id \nWHERE users.created_at = (SELECT MAX(created_at) FROM users)",
            "SELECT \n    COUNT(T2.Id) AS post_count\nFROM \n    users AS T1\nINNER JOIN \n    posts AS T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN \n    comments AS T3 ON T3.PostId = T2.Id\nORDER BY \n    T1.CreationDate DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT T2.Id) AS post_count,\n    COUNT(DISTINCT T3.Id) AS comment_count\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nINNER JOIN comments AS T3 ON T3.PostId = T2.Id\nORDER BY T1.CreationDate DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "497": {
        "db_id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00e8me \u00e9dition\".",
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition' )",
        "amends": [
            "Do select `type` instead of `expansion_type` from the `sets` table. Do use a subquery filter with `code IN (SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition')` instead of directly filtering `set_name = 'Huiti\u00e8me \u00e9dition'`. Do add the `set_translations` table correlation through the subquery instead of omitting it. The amended query now correctly retrieves set type by matching translation text through the proper relational join instead of relying on a potentially incorrect direct column match."
        ],
        "rules": [
            "1) When the question asks for \"expansion type\" of a set: use the column \"type\" from the \"sets\" table instead of \"expansion_type\". 2) When the question mentions a set name like \"Huiti\u00e8me \u00e9dition\": this refers to the \"translation\" column in the \"set_translations\" table, not the \"set_name\" column. 3) When filtering for a specific set translation: use a subquery condition where \"code IN (SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition')\" to properly link the sets and set_translations tables. 4) When combining sets and set_translations tables: link them through the relationship where sets.\"code\" equals set_translations.\"setCode\" as implied by the subquery filter."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expansion_type FROM sets WHERE set_name = 'Huiti\u00e8me \u00e9dition';",
            "SELECT type FROM sets WHERE code IN (SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition')"
        ],
        "rule_sql": [
            "SELECT s.type FROM sets s WHERE s.code IN (SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition')"
        ],
        "amend_res": 1
    },
    "1247": {
        "db_id": "thrombosis_prediction",
        "question": "Among the male patients who have a normal level of white blood cells, how many of them have an abnormal fibrinogen level?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.FG <= 150 OR T2.FG >= 450 AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table to incorporate laboratory data. Do `T2.FG <= 150 OR T2.FG >= 450` instead of `fibrinogen = 'normal'` to filter for abnormal fibrinogen values using numeric ranges. Do `T2.WBC > 3.5 AND T2.WBC < 9.0` instead of `white_blood_cells = 'normal'` to filter for normal white blood cell counts using numeric thresholds. Do `T1.SEX = 'M'` instead of `gender = 'male'` to use the correct column name and value format. The amended query now correctly counts distinct male patients with abnormal fibrinogen or normal white blood cell values by joining patient and laboratory data.",
            "Do use parentheses to properly group the `OR` condition `T2.FG <= 150 OR T2.FG >= 450` instead of having it incorrectly grouped with other `AND` conditions. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` and `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` structure as they are identical. Do keep all filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the corrected `OR` condition for `T2.FG` values, but ensure the logical grouping follows proper operator precedence. The amended query now correctly handles the OR condition for FG values while maintaining the same join logic and filtering behavior.",
            "Do use parentheses to properly group the `OR` condition `(T2.FG <= 150 OR T2.FG >= 450)` instead of omitting them, which changes the logical evaluation order. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause, `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure, and all individual filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check. The amended query now correctly handles the logical grouping and matches the RIGHT_SQL's behavior.",
            "Do use parentheses to properly group the `OR` condition `(T2.FG <= 150 OR T2.FG >= 450)` instead of omitting them, which would cause incorrect operator precedence where the `OR` would bind more tightly than the subsequent `AND` conditions. Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause, `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` join structure, and all individual filter conditions including `T1.SEX = 'M'`, `T2.WBC > 3.5 AND T2.WBC < 9.0`, and the FG range check, but ensure the logical grouping is correct with parentheses around the OR condition. The amended query now correctly evaluates the FG range condition as a single unit before applying the other AND conditions, matching the RIGHT_SQL's behavior.",
            "Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause instead of changing it. Do keep the same `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` structure instead of modifying the join. Do reorder the WHERE clause predicates to place `T2.FG <= 150 OR T2.FG >= 450` first instead of having it last, while maintaining the same logical conditions `T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'` instead of altering their content. The amended query now correctly preserves all filtering logic while matching the RIGHT_SQL's behavior through predicate reordering.",
            "Do maintain the same `SELECT COUNT(DISTINCT T1.ID)` clause instead of changing it. Do keep the same `FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` structure instead of modifying it. Do move the `T2.FG <= 150 OR T2.FG >= 450` condition to the beginning of the WHERE clause instead of keeping it parenthesized at the end, while maintaining the same logical OR operator. Do remove the parentheses around the FG condition instead of keeping them, as they are unnecessary for the OR operation's precedence. Do maintain all other filter conditions (`T2.WBC > 3.5 AND T2.WBC < 9.0 AND T1.SEX = 'M'`) in the same logical AND relationship instead of changing them. The amended query now correctly preserves the original logic while removing unnecessary parentheses and maintaining the proper condition order."
        ],
        "rules": [
            "1) When the question asks about male patients: use T1.SEX = 'M' to filter for male patients. 2) When the question asks about normal white blood cell levels: use T2.WBC > 3.5 AND T2.WBC < 9.0 to filter for normal white blood cell counts using numeric thresholds. 3) When the question asks about abnormal fibrinogen levels: use T2.FG <= 150 OR T2.FG >= 450 to filter for abnormal fibrinogen values using numeric ranges. 4) When combining patient and laboratory data: perform an INNER JOIN between patients table (T1) and Laboratory table (T2) using T1.ID = T2.ID to link patient records with their laboratory results. 5) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows.",
            "1) When the question asks about male patients: filter rows where T1.SEX equals exactly 'M'. 2) When the question asks about normal white blood cell levels: filter rows where T2.WBC is greater than 3.5 AND less than 9.0. 3) When the question asks about abnormal fibrinogen levels: filter rows where T2.FG is less than or equal to 150 OR greater than or equal to 450, and ensure this OR condition is properly grouped with parentheses. 4) When counting distinct patients: count the number of unique T1.ID values that satisfy all the specified conditions. 5) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID using an inner join to keep only matching patient records.",
            "1) When the question asks about male patients: filter rows where T1.SEX equals exactly 'M'. 2) When the question asks about patients with normal white blood cells: filter rows where T2.WBC is greater than 3.5 and less than 9.0. 3) When the question asks about abnormal fibrinogen level: filter rows where T2.FG is less than or equal to 150 or greater than or equal to 450, and use parentheses to properly group this OR condition. 4) When counting distinct male patients: count the number of unique T1.ID values that satisfy all the specified conditions. 5) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner join).",
            "1) When the question asks about male patients: filter rows where T1.SEX equals exactly 'M'. 2) When the question mentions \"normal level of white blood cells\": filter rows where T2.WBC is greater than 3.5 and less than 9.0. 3) When the question asks about \"abnormal fibrinogen level\": filter rows where T2.FG is less than or equal to 150 OR T2.FG is greater than or equal to 450, and ensure this condition is properly grouped with parentheses. 4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID using an inner match. 5) When counting distinct male patients: count the number of unique T1.ID values that satisfy all the specified conditions.",
            "1) When answering about male patients with normal white blood cells and abnormal fibrinogen levels: make sure the output order is COUNT(DISTINCT T1.ID) 2) When the question mentions \"male patients\": \"male\" actually means T1.SEX = 'M' in schema 3) When the question mentions \"normal level of white blood cells\": \"normal\" actually means T2.WBC > 3.5 AND T2.WBC < 9.0 in schema 4) When the question mentions \"abnormal fibrinogen level\": \"abnormal\" actually means T2.FG <= 150 OR T2.FG >= 450 in schema 5) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match) 6) When counting distinct patients: compute the number of unique values of T1.ID",
            "1) When counting distinct patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner join. 3) When filtering for male patients: use T1.SEX = 'M' with exact literal 'M'. 4) When identifying normal white blood cell levels: use T2.WBC > 3.5 AND T2.WBC < 9.0 with the exact numeric bounds. 5) When identifying abnormal fibrinogen levels: use T2.FG <= 150 OR T2.FG >= 450 with the exact numeric bounds and OR operator without parentheses. 6) When ordering conditions: place the fibrinogen condition (T2.FG <= 150 OR T2.FG >= 450) before other filter conditions in the WHERE clause."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE gender = 'male' \nAND white_blood_cells = 'normal' \nAND fibrinogen = 'normal';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.FG <= 150 OR T2.FG >= 450\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND T2.WBC > 3.5 AND T2.WBC < 9.0\nAND (T2.FG <= 150 OR T2.FG >= 450)"
        ],
        "amend_res": 1
    },
    "232": {
        "db_id": "toxicology",
        "question": "Please list top three molecules that have single bonds between two atoms and are not carcinogenic in alphabetical order.",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-' ORDER BY T2.molecule_id LIMIT 3",
        "amends": [
            "Do query from `bond AS T1` and `molecule AS T2` with an `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying only from `molecules` table. Do filter with `T1.bond_type = '-'` and `T2.label = '-'` instead of `bond_type = 'single'` and `carcinogenic = 'no'`. Do select `DISTINCT T2.molecule_id` instead of `molecule_name` without distinct. Do order by `T2.molecule_id` instead of `molecule_name ASC`. The amended query now correctly joins the bond and molecule tables to find distinct molecule IDs matching the specified bond type and label conditions."
        ],
        "rules": [
            "1) When answering about molecules with specific bond types and labels: combine bond table as T1 and molecule table as T2 using an inner match where T1.molecule_id equals T2.molecule_id. 2) When the question mentions \"single bonds\": filter for T1.bond_type = '-' exactly. 3) When the question mentions \"not carcinogenic\": filter for T2.label = '-' exactly. 4) When listing distinct molecules: select DISTINCT T2.molecule_id to ensure unique molecule identification. 5) When the question asks for alphabetical order: order results by T2.molecule_id in ascending sequence. 6) When the question asks for top three: keep only the first 3 rows after ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_name FROM molecules WHERE bond_type = 'single' AND carcinogenic = 'no' ORDER BY molecule_name ASC LIMIT 3;",
            "SELECT DISTINCT T2.molecule_id\nFROM bond AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '-'\nAND T2.label = '-'\nORDER BY T2.molecule_id\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id\nFROM bond AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '-'\nAND T2.label = '-'\nORDER BY T2.molecule_id ASC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "1060": {
        "db_id": "european_football_2",
        "question": "How many players were born after 1990?",
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990'",
        "amends": [
            "Do reference the `Player` table instead of `players` and use `COUNT(id)` instead of `COUNT(*)` to count specific non-null identifiers. Do apply the `STRFTIME('%Y', birthday)` function to extract the year from a date field instead of comparing `birth_year` directly. Do filter for records where the birth year is greater than 1990 using `> '1990'` instead of less than 1990 with `< 1990`, which changes the selection criteria to capture players born after 1990 rather than before 1990. The amended query now correctly counts players born after 1990 by extracting the year from a proper date field and using appropriate comparison logic."
        ],
        "rules": [
            "1) When counting players: use the \"Player\" table and count the \"id\" column to get specific non-null identifiers. 2) When extracting birth year from a date field: use STRFTIME('%Y', birthday) to get the year component. 3) When filtering for players born after 1990: compare the extracted birth year using > '1990' to capture years greater than 1990."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE birth_year < 1990;",
            "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990';"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM Player WHERE STRFTIME('%Y', birthday) > '1990';"
        ],
        "amend_res": 1
    },
    "444": {
        "db_id": "card_games",
        "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T1.name` and `T1.type` with explicit table aliases instead of `foreign_name` and `type` without table qualification. Do add `INNER JOIN foreign_data AS T2` with the join condition `ON T2.uuid = T1.uuid` instead of querying only the `cards` table. Do qualify the watermark filter as `T1.watermark` instead of just `watermark` to be explicit about the table source. The amended query now correctly joins the tables and returns distinct card names and types for Boros watermarked cards, matching the intended behavior.",
            "Do select `T1.name` and `T1.type` instead of `T2.name` and `T2.type` to reference columns from the correct table. The amended query now matches RIGHT_SQL's behavior by properly selecting attributes from the cards table rather than the joined foreign_data table."
        ],
        "rules": [
            "1) When the question asks for \"foreign name of the card\": select T1.name from the cards table instead of foreign_name. 2) When the question asks for \"type of this card\": select T1.type from the cards table with explicit table qualification. 3) When combining cards and foreign_data tables: link rows where T2.uuid = T1.uuid using an inner match. 4) When filtering for \"boros watermark\": use the exact literal 'boros' with the qualified column T1.watermark. 5) When eliminating duplicate rows: use DISTINCT to return only unique combinations of T1.name and T1.type.",
            "1) When selecting attributes for cards with specific watermarks: use columns from the cards table (T1.name and T1.type) rather than from joined foreign_data table (T2.name and T2.type). 2) When the question asks for \"foreign name\" and \"type\" of cards: these attributes are stored in the cards table itself, not in the foreign_data table. 3) When filtering cards by watermark: use the exact literal 'boros' with the correct case and spelling as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT foreign_name, type FROM cards WHERE watermark = 'boros';",
            "SELECT DISTINCT T2.name, T2.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'boros'",
            "SELECT DISTINCT T1.name, T1.type \nFROM cards AS T1 \nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid \nWHERE T1.watermark = 'boros'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name, T1.type FROM cards T1 INNER JOIN foreign_data T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'"
        ],
        "amend_res": 1
    },
    "796": {
        "db_id": "superhero",
        "question": "State all of 3-D Man's attributes along with their values.",
        "ground_truth": "SELECT T3.attribute_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = '3-D Man'",
        "amends": [
            "Do select specific columns `T3.attribute_name` and `T2.attribute_value` instead of using `SELECT *` to retrieve all columns. Do join multiple tables using `INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id` and `INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id` instead of querying only the `characters` table. Do filter on `T1.superhero_name = '3-D Man'` instead of `name = '3-D Man'` to use the correct column name and table context. The amended query now correctly joins the superhero, hero_attribute, and attribute tables to retrieve specific attribute information for the specified superhero, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about a superhero's attributes: make sure the output order includes T3.attribute_name and T2.attribute_value. 2) When the question mentions \"3-D Man\": \"3-D Man\" actually means T1.superhero_name = '3-D Man' in schema. 3) When combining T1, T2, and T3 for superhero attributes: link rows where T1.id = T2.hero_id and T2.attribute_id = T3.id; keep only matching pairs (inner match). 4) When selecting specific attribute information: do not use SELECT * but instead select specific columns T3.attribute_name and T2.attribute_value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM characters WHERE name = '3-D Man';",
            "SELECT T3.attribute_name, T2.attribute_value\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T1.superhero_name = '3-D Man'"
        ],
        "rule_sql": [
            "SELECT T3.attribute_name, T2.attribute_value\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T1.superhero_name = '3-D Man'\nORDER BY T3.attribute_name, T2.attribute_value"
        ],
        "amend_res": 1
    },
    "846": {
        "db_id": "formula_1",
        "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
        "ground_truth": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
        "amends": [
            "Do select `T2.driverRef` instead of `driver_name` and change the source to use `qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId` instead of querying `drivers` directly. Do filter on `T1.raceId = 20` instead of `race_id = 20` and remove the `elimination_period = 1` condition instead of keeping it. Do add `ORDER BY T1.q1 DESC` instead of omitting ordering and add `LIMIT 5` instead of omitting row limiting. The amended query now correctly retrieves the top 5 drivers by qualifying time for race 20 instead of filtering by elimination period."
        ],
        "rules": [
            "1) When answering about \"drivers eliminated in the first period\": use \"T2.driverRef\" instead of \"driver_name\" for the reference names. 2) When combining qualifying and drivers tables: link rows where \"T2.driverId = T1.driverId\" and keep only matching pairs (inner match). 3) When filtering for race number 20: use \"T1.raceId = 20\" instead of \"race_id = 20\". 4) When the question mentions \"first period\" and the amends show ordering by qualifying time: rank drivers by \"T1.q1 DESC\" and keep the top 5 rows. 5) When the amends specify output ordering: order results by \"T1.q1 DESC\" and limit to 5 rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM drivers WHERE race_id = 20 AND elimination_period = 1;",
            "SELECT T2.driverRef \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 20 \nORDER BY T1.q1 DESC \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T2.driverRef \nFROM qualifying T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T1.raceId = 20\nORDER BY T1.q1 DESC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "938": {
        "db_id": "formula_1",
        "question": "Who was the champion of 2008's Australian Grand Prix and where can I know more about him?",
        "ground_truth": "SELECT T1.forename, T1.surname, T1.url FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T2.time LIKE '_:%:__.___' AND T3.year = 2008",
        "amends": [
            "Do select `forename`, `surname`, and `url` instead of `driver_name` and `biography_url`. Do join `drivers AS T1` with `results AS T2` on `T1.driverId = T2.driverId` instead of querying only the drivers table. Do add a second join to `races AS T3` on `T3.raceId = T2.raceId` instead of omitting race context. Do filter on `T3.name = 'Australian Grand Prix'` and `T3.year = 2008` instead of direct column filters. Do add a time filter `T2.time LIKE '_:%:__.___'` instead of filtering on `position = 1`. The amended query now correctly identifies race winners by time rather than position and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about the champion of a specific Grand Prix: select forename, surname, and url instead of driver_name and biography_url. 2) When combining driver and race information: join drivers AS T1 with results AS T2 on T1.driverId = T2.driverId, then join races AS T3 on T3.raceId = T2.raceId. 3) When filtering for a specific Grand Prix and year: use T3.name = 'Australian Grand Prix' and T3.year = 2008 instead of direct column filters. 4) When identifying race winners: filter using T2.time LIKE '_:%:__.___' instead of position = 1 to correctly identify winners by time rather than position."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name, biography_url FROM drivers WHERE year = 2008 AND grand_prix = 'Australian Grand Prix' AND position = 1",
            "SELECT T1.forename, T1.surname, T1.url\nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T3.raceId = T2.raceId\nWHERE T3.name = 'Australian Grand Prix' \nAND T3.year = 2008\nAND T2.time LIKE '_:%:__.___'"
        ],
        "rule_sql": [
            "SELECT T1.forename, T1.surname, T1.url \nFROM drivers AS T1 \nJOIN results AS T2 ON T1.driverId = T2.driverId \nJOIN races AS T3 ON T3.raceId = T2.raceId \nWHERE T3.name = 'Australian Grand Prix' \nAND T3.year = 2008 \nAND T2.time LIKE '_:%:__.___'"
        ],
        "amend_res": 1
    },
    "850": {
        "db_id": "formula_1",
        "question": "Please give the name of the race held on the circuits in Germany.",
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Germany'",
        "amends": [
            "Do use `DISTINCT T2.name` instead of just `name` to eliminate duplicate circuit names. Do join `circuits AS T1` with `races AS T2` instead of querying only the races table. Do specify the join condition `ON T2.circuitID = T1.circuitId` instead of missing the table relationship entirely. Do filter on `T1.country = 'Germany'` instead of `country = 'Germany'` to reference the correct table's country column. The amended query now correctly identifies circuits in Germany and their associated races, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for race names held on circuits in Germany: use DISTINCT T2.name to eliminate duplicate circuit names. 2) When combining circuits and races tables: join circuits AS T1 with races AS T2 using the condition T2.circuitID = T1.circuitId to establish the correct table relationship. 3) When filtering for circuits in Germany: use T1.country = 'Germany' to reference the correct table's country column. 4) When answering about race names on circuits in Germany: make sure the output order is T2.name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM races WHERE country = 'Germany';",
            "SELECT DISTINCT T2.name FROM circuits AS T1 JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.country = 'Germany'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name FROM circuits AS T1 JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.country = 'Germany' ORDER BY T2.name;"
        ],
        "amend_res": 1
    },
    "1011": {
        "db_id": "formula_1",
        "question": "Which top 20 driver created the shortest lap time ever record in a Formula_1 race? Please give them full names.",
        "ground_truth": "WITH lap_times_in_seconds AS (SELECT driverId, (CASE WHEN SUBSTR(time, 1, INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) ELSE 0 END + CASE WHEN SUBSTR(time, INSTR(time, '.') + 1) <> '' THEN CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 ELSE 0 END) AS time_in_seconds FROM lapTimes) SELECT T2.forename, T2.surname, T1.driverId FROM (SELECT driverId, MIN(time_in_seconds) AS min_time_in_seconds FROM lap_times_in_seconds GROUP BY driverId) AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId ORDER BY T1.min_time_in_seconds ASC LIMIT 20",
        "amends": [
            "Do add a CTE `lap_times_in_seconds` to convert time format to seconds instead of directly using `lap_time`. Do change the SELECT list to include `forename`, `surname`, and `driverId` instead of just `driver_name`. Do add a subquery to find the minimum lap time per driver with `GROUP BY driverId` instead of ordering raw lap times. Do add an `INNER JOIN` between the aggregated results and `drivers` table on `driverId` instead of querying drivers directly. Do order by the calculated minimum time in seconds `min_time_in_seconds` instead of the original `lap_time` column. The amended query now correctly identifies the fastest lap time for each driver and returns the top 20 performers based on their best lap times.",
            "Do parse the `time` column using string manipulation to extract minutes, seconds, and milliseconds components instead of incorrectly using the `milliseconds` column. Do calculate `time_in_seconds` by converting minutes to seconds, adding seconds, and adding milliseconds converted to seconds instead of simply dividing milliseconds by 1000. Do restructure the CTE to first convert all lap times to seconds before finding the minimum, instead of finding the minimum milliseconds and then converting. Do remove the `min_time_in_seconds` column from the final SELECT list instead of including it, as it's not needed in the output. Do use table aliases `T1` and `T2` instead of `l` and `d` for consistency. The amended query now correctly handles time format conversion and matches RIGHT_SQL's behavior.",
            "Do add `CASE` statements with empty string checks for each time component instead of direct casting without validation. Do include `driverId` in the final `SELECT` list instead of omitting it. Do add table aliases `T1` and `T2` instead of using unaliased table names. Do remove the `WHERE time IS NOT NULL` filter from the CTE instead of keeping it, as the `CASE` statements handle null values. The amended query now correctly handles empty string values in time parsing and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 20\" drivers by lap time performance: rank drivers by their minimum lap time in ascending order and keep the first 20 rows. 2) When the question mentions \"shortest lap time ever\": for each driver, find their absolute minimum lap time across all races instead of individual lap times. 3) When converting lap time format: convert the time format to seconds before performing comparisons and ranking. 4) When joining driver information: use an inner match between the aggregated lap times and drivers table where driverId values are equal. 5) When selecting driver names: include both forename and surname columns to get full names instead of a single driver_name column. 6) When ordering results: sort by the calculated minimum time in seconds (min_time_in_seconds) in ascending order to find the fastest times.",
            "1) When extracting lap time information: parse the \"time\" column using string manipulation to extract minutes, seconds, and milliseconds components instead of using the \"milliseconds\" column. 2) When calculating time in seconds: convert minutes to seconds, add seconds, and add milliseconds converted to seconds instead of simply dividing milliseconds by 1000. 3) When finding minimum lap times: first convert all lap times to seconds before finding the minimum, instead of finding the minimum milliseconds and then converting. 4) When producing final output: remove the time column from the final SELECT list as it's not needed in the output. 5) When using table aliases: use \"T1\" for the lap times table and \"T2\" for the drivers table for consistency. 6) When answering about top 20 drivers with shortest lap times: rank rows by lap time in ascending order and keep the first 20 rows. 7) When combining lap times and drivers tables: link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match). 8) When the question asks for full names: output both forename and surname columns from the drivers table.",
            "1) When parsing time values that may contain empty strings: use CASE statements to validate each time component before casting instead of direct casting without validation. 2) When selecting driver information: include driverId in the final output columns instead of omitting it. 3) When referencing tables in joins: use table aliases T1 and T2 instead of unaliased table names. 4) When handling potentially null time values: remove explicit NULL filters as CASE statements handle null values appropriately."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name FROM drivers ORDER BY lap_time ASC LIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        MIN(CAST(milliseconds AS REAL) / 1000) AS min_time_in_seconds\n    FROM lapTimes\n    GROUP BY driverId\n)\nSELECT \n    d.forename,\n    d.surname,\n    d.driverId,\n    l.min_time_in_seconds\nFROM lap_times_in_seconds l\nINNER JOIN drivers d ON l.driverId = d.driverId\nORDER BY l.min_time_in_seconds ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n        CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n        CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM lapTimes\n    WHERE time IS NOT NULL\n),\nmin_lap_times AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    GROUP BY driverId\n)\nSELECT \n    d.forename,\n    d.surname\nFROM min_lap_times m\nINNER JOIN drivers d ON m.driverId = d.driverId\nORDER BY m.min_time_in_seconds ASC\nLIMIT 20;",
            "WITH lap_times_in_seconds AS (\n    SELECT \n        driverId,\n        CASE \n            WHEN time IS NULL OR time = '' THEN NULL\n            ELSE \n                CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) + \n                CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\n        END AS time_in_seconds\n    FROM lapTimes\n),\nmin_lap_times AS (\n    SELECT \n        driverId,\n        MIN(time_in_seconds) AS min_time_in_seconds\n    FROM lap_times_in_seconds\n    WHERE time_in_seconds IS NOT NULL\n    GROUP BY driverId\n)\nSELECT \n    T2.forename,\n    T2.surname,\n    T2.driverId\nFROM min_lap_times T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nORDER BY T1.min_time_in_seconds ASC\nLIMIT 20"
        ],
        "rule_sql": [
            "SELECT \n    T2.driverId,\n    T2.forename,\n    T2.surname,\n    MIN(\n        CASE \n            WHEN T1.time IS NULL OR T1.time = '' THEN NULL\n            ELSE \n                CAST(SUBSTR(T1.time, 1, INSTR(T1.time, ':') - 1) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, INSTR(T1.time, ':') + 1, INSTR(T1.time, '.') - INSTR(T1.time, ':') - 1) AS REAL) + \n                CAST(SUBSTR(T1.time, INSTR(T1.time, '.') + 1) AS REAL) / 1000\n        END\n    ) AS min_time_in_seconds\nFROM \n    lapTimes T1\nINNER JOIN \n    drivers T2 ON T1.driverId = T2.driverId\nGROUP BY \n    T2.driverId, T2.forename, T2.surname\nHAVING \n    min_time_in_seconds IS NOT NULL\nORDER BY \n    min_time_in_seconds ASC\nLIMIT 20"
        ],
        "amend_res": 1
    },
    "805": {
        "db_id": "superhero",
        "question": "List the full names of superheroes with missing weight.",
        "ground_truth": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "amends": [
            "Do select `DISTINCT full_name` instead of `name` without distinct. Do use table `superhero` instead of `superheroes`. Do add filter `full_name IS NOT NULL` instead of omitting it. Do change null check to `weight_kg IS NULL OR weight_kg = 0` instead of `weight IS NULL` to include zero values. The amended query now correctly returns distinct non-null names from the superhero table where weight is either null or zero."
        ],
        "rules": [
            "1) When selecting superhero names: use \"full_name\" instead of \"name\" and ensure the result contains only distinct values. 2) When referring to the superhero table: use \"superhero\" instead of \"superheroes\". 3) When filtering for missing weight: check for both null values and zero values using \"weight_kg IS NULL OR weight_kg = 0\" instead of just \"weight IS NULL\". 4) When outputting superhero names: exclude null names by adding \"full_name IS NOT NULL\" as a filter condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE weight IS NULL;",
            "SELECT DISTINCT full_name FROM superhero WHERE (weight_kg IS NULL OR weight_kg = 0) AND full_name IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT DISTINCT full_name FROM superhero WHERE (weight_kg IS NULL OR weight_kg = 0) AND full_name IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "420": {
        "db_id": "card_games",
        "question": "How many cards are oversized, reprinted, and printed for promotions?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count specific non-null values. Do reference column `isOversized` instead of `is_oversized` to match the correct schema. Do reference column `isReprint` instead of `is_reprinted` to match the correct schema. Do reference column `isPromo` instead of `is_promotional` to match the correct schema. The amended query now correctly counts cards using the proper column names and specific identifier counting."
        ],
        "rules": [
            "1) When counting cards: use COUNT(id) instead of COUNT(*) to count specific non-null values. 2) When checking if a card is oversized: use column \"isOversized\" = 1 instead of \"is_oversized\". 3) When checking if a card is reprinted: use column \"isReprint\" = 1 instead of \"is_reprinted\". 4) When checking if a card is printed for promotions: use column \"isPromo\" = 1 instead of \"is_promotional\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE is_oversized = 1 AND is_reprinted = 1 AND is_promotional = 1;",
            "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;"
        ],
        "amend_res": 1
    },
    "186": {
        "db_id": "financial",
        "question": "What percentage of male clients request for weekly statements to be issued?",
        "ground_truth": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
        "amends": [
            "Do use `CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM clients WHERE gender = 'Male')` for proper percentage calculation with explicit casting. Do join multiple tables including `client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id` instead of querying only the `clients` table to incorporate related account and district data. Do filter with `T2.frequency = 'POPLATEK TYDNE'` instead of `statement_frequency = 'Weekly'` to use the correct column name and value from the joined account table. Do reference specific columns like `T1.client_id` and `T1.gender` instead of using `COUNT(*)` for more precise counting. The amended query now correctly calculates the percentage of male clients with weekly account statements by properly joining across multiple related tables and using appropriate aggregation functions."
        ],
        "rules": [
            "1) When calculating percentages for male clients: use CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) instead of COUNT(*) operations for precise calculation with explicit casting. 2) When combining client and account data: join multiple tables including client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id to incorporate related account and district data. 3) When filtering for weekly statements: use T2.frequency = 'POPLATEK TYDNE' instead of statement_frequency = 'Weekly' to use the correct column name and value from the joined account table. 4) When counting clients: reference specific columns like T1.client_id and T1.gender instead of using COUNT(*) for more precise counting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM clients WHERE gender = 'Male')) AS percentage\nFROM clients\nWHERE gender = 'Male' AND statement_frequency = 'Weekly';",
            "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.client_id) AS percentage_male_weekly_statements\nFROM client AS T1\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nINNER JOIN account AS T2 ON T2.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T2.account_id = T4.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE';"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.client_id) AS percentage_male_weekly_statements\nFROM client AS T1\nINNER JOIN district AS T3 ON T1.district_id = T3.district_id\nINNER JOIN account AS T2 ON T2.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T2.account_id = T4.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE';"
        ],
        "amend_res": 1
    },
    "195": {
        "db_id": "toxicology",
        "question": "What is the most common bond type?",
        "ground_truth": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
        "amends": [
            "Do reference the `bond` table instead of `bonds` in the FROM clause. Do use a subquery with alias `T` instead of querying directly. Do select only `bond_type` in the outer query instead of including `COUNT(*) as count`. Do count `bond_id` instead of `*` in the subquery. Do order by `COUNT(bond_id) DESC` instead of `count ASC` to find the most common bond type. Do remove the alias `count` from the subquery since it's not used in the outer selection. The amended query now correctly identifies the most frequent bond type by counting specific bond IDs in descending order."
        ],
        "rules": [
            "1) When answering about \"most common bond type\": make sure the output order: bond_type. 2) When counting bonds: compute the number of rows using the canonical key token \"bond_id\" from the bond table. 3) When the question mentions \"most common\": rank bond types by count of bond_id in descending order and keep the first 1 row. 4) When selecting from the bond table: use the exact table name \"bond\" (not \"bonds\"). 5) When counting bond occurrences: use the exact column token \"bond_id\" (not \"*\") for counting. 6) When ordering by frequency: order by COUNT(bond_id) DESC (not ASC) to find the most common type."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type, COUNT(*) as count FROM bonds GROUP BY bond_type ORDER BY count ASC LIMIT 1;",
            "SELECT bond_type FROM (SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC) AS T LIMIT 1"
        ],
        "rule_sql": [
            "SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "144": {
        "db_id": "financial",
        "question": "How much is the average amount in credit card made by account holders in a month, in year 2021?",
        "ground_truth": "SELECT AVG(T4.amount) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE STRFTIME('%Y', T4.date) = '1998' AND T4.operation = 'VYBER KARTOU'",
        "amends": [
            "Do add joins to `card`, `disp`, `account`, and `trans` tables instead of querying only `credit_cards`; specifically do `INNER JOIN disp` on `T1.disp_id = T2.disp_id`, `INNER JOIN account` on `T2.account_id = T3.account_id`, and `INNER JOIN trans` on `T3.account_id = T4.account_id` instead of no joins. Do reference `T4.amount` instead of just `amount` and do filter with `STRFTIME('%Y', T4.date) = '1998'` instead of `YEAR(transaction_date) = 2021`. Do add an additional filter `T4.operation = 'VYBER KARTOU'` instead of omitting it. Do remove `GROUP BY MONTH(transaction_date)` instead of keeping it. The amended query now correctly joins multiple tables to access transaction data with proper filtering for year 1998 and specific operation type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average credit card amounts for account holders: join tables using the exact key relationships shown - T1.disp_id = T2.disp_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id to access transaction data. 2) When filtering for a specific year: use STRFTIME('%Y', T4.date) = '1998' with exact literal '1998' instead of 2021. 3) When filtering for credit card operations: include T4.operation = 'VYBER KARTOU' with exact literal 'VYBER KARTOU'. 4) When computing the average amount: reference T4.amount instead of just amount. 5) When the question asks for a monthly average without grouping by month: do not include any GROUP BY clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(amount) FROM credit_cards WHERE YEAR(transaction_date) = 2021 GROUP BY MONTH(transaction_date)",
            "SELECT AVG(T4.amount) AS average_amount\nFROM card T1\nINNER JOIN disp T2 ON T1.disp_id = T2.disp_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN trans T4 ON T3.account_id = T4.account_id\nWHERE STRFTIME('%Y', T4.date) = '1998'\nAND T4.operation = 'VYBER KARTOU';"
        ],
        "rule_sql": [
            "SELECT AVG(T4.amount) AS average_amount\nFROM card T1\nJOIN disp T2 ON T1.disp_id = T2.disp_id\nJOIN account T3 ON T2.account_id = T3.account_id\nJOIN trans T4 ON T3.account_id = T4.account_id\nWHERE STRFTIME('%Y', T4.date) = '1998'\nAND T4.operation = 'VYBER KARTOU';"
        ],
        "amend_res": 1
    },
    "348": {
        "db_id": "card_games",
        "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
        "amends": [
            "Do select only `T2.text` instead of all columns with `*`. Do join `cards AS T1` to `rulings AS T2` using `INNER JOIN` instead of querying only the `rulings` table. Do use the join condition `T1.uuid = T2.uuid` instead of filtering directly on card attributes. Do filter on `T1.name` and `T1.number` instead of filtering on `card_name` and `card_number` from the wrong table. The amended query now correctly retrieves ruling text by joining through the cards table using UUID matching instead of attempting to filter rulings directly with card attributes that don't exist in that table."
        ],
        "rules": [
            "1) When answering about rulings for a specific card: join cards table as T1 to rulings table as T2 using T1.uuid = T2.uuid to link related records. 2) When filtering for card named 'Sublime Epiphany': use T1.name = 'Sublime Epiphany' instead of filtering on rulings table attributes. 3) When filtering for card number '74s': use T1.number = '74s' instead of filtering on rulings table attributes. 4) When selecting ruling information: output only T2.text column instead of all columns with *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM rulings WHERE card_name = 'Sublime Epiphany' AND card_number = '74s';",
            "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'"
        ],
        "rule_sql": [
            "SELECT T2.text FROM cards AS T1 JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'"
        ],
        "amend_res": 1
    },
    "495": {
        "db_id": "card_games",
        "question": "What was the release date for the set which card \"Evacuation\" in it?",
        "ground_truth": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Evacuation'",
        "amends": [
            "Do select `T2.releaseDate` instead of `release_date` and use table alias `T2` instead of direct table reference. Do join `cards AS T1` instead of omitting it and use `INNER JOIN sets AS T2` instead of querying only the sets table. Do add join condition `ON T2.code = T1.setCode` instead of missing the relationship between tables. Do filter on `T1.name = 'Evacuation'` instead of `card_name = 'Evacuation'` to correctly reference the card name in the appropriate table. The amended query now properly joins the cards and sets tables to retrieve the release date associated with the specified card name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"release date for the set containing card 'Evacuation'\": make sure the output order: T2.releaseDate\n2) When the question mentions \"card 'Evacuation'\": \"card 'Evacuation'\" actually means \"T1.name = 'Evacuation'\" in schema\n3) When combining T1 (cards) and T2 (sets) for shared entities: link rows where T2.code = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for literal 'Evacuation'\n5) When handling text literals: do not change case, spacing, or punctuation for 'Evacuation'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT release_date FROM sets WHERE card_name = 'Evacuation';",
            "SELECT T2.releaseDate \nFROM cards AS T1 \nINNER JOIN sets AS T2 ON T2.code = T1.setCode \nWHERE T1.name = 'Evacuation'"
        ],
        "rule_sql": [
            "SELECT T2.releaseDate\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Evacuation'"
        ],
        "amend_res": 1
    },
    "773": {
        "db_id": "superhero",
        "question": "Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",
        "ground_truth": "SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id",
        "amends": [
            "Do specify `T1.superhero_name` and `T2.publisher_name` instead of `name` and `publisher`. Do use `INNER JOIN publisher AS T2` instead of omitting the join. Do join on `T1.publisher_id = T2.id` instead of missing the publisher relationship. Do filter with `T1.eye_colour_id = T1.hair_colour_id` instead of `eyes = hair`. Do add `AND T1.eye_colour_id = T1.skin_colour_id` instead of `hair = skin` to properly compare eye color to skin color. The amended query now correctly joins tables and uses proper column references with consistent ID-based comparisons."
        ],
        "rules": [
            "1) When answering about superhero attributes and publisher: make sure the output order: T1.superhero_name, T2.publisher_name\n2) When the question mentions \"name\": \"name\" actually means \"T1.superhero_name\" in schema\n3) When the question mentions \"publisher\": \"publisher\" actually means \"T2.publisher_name\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match)\n5) When filtering for same eye, hair and skin color: filter with T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id instead of direct color name comparisons"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, publisher FROM superheroes WHERE eyes = hair AND hair = skin;",
            "SELECT T1.superhero_name, T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.eye_colour_id = T1.hair_colour_id\nAND T1.eye_colour_id = T1.skin_colour_id;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name, T2.publisher_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T1.eye_colour_id = T1.hair_colour_id \nAND T1.eye_colour_id = T1.skin_colour_id"
        ],
        "amend_res": 1
    },
    "1373": {
        "db_id": "student_club",
        "question": "How many of the members' hometowns are from Maryland state?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T2.member_id) FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T1.state = 'Maryland'",
        "amends": [
            "Do join `zip_code AS T1` with `member AS T2` on `T1.zip_code = T2.zip` instead of querying `members` table directly. Do filter on `T1.state = 'Maryland'` instead of `hometown = 'Maryland'` to correctly identify Maryland residents by state rather than hometown field. Do count `T2.member_id` instead of `COUNT(*)` to count actual member records. The amended query now correctly matches the RIGHT_SQL's behavior of counting Maryland members based on zip code state association rather than potentially incorrect hometown field values."
        ],
        "rules": [
            "1) When answering about \"members' hometowns from Maryland state\": make sure the output order: count of members from Maryland\n2) When the question mentions \"Maryland state\": \"Maryland\" actually means \"T1.state = 'Maryland'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.zip_code = T2.zip exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for \"count of members\": compute the number of rows using the canonical key token T2.member_id\n5) When filtering for Maryland residents: use T1.state = 'Maryland' instead of hometown field to correctly identify Maryland residents by state"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE hometown = 'Maryland';",
            "SELECT COUNT(T2.member_id) \nFROM zip_code AS T1 \nJOIN member AS T2 ON T1.zip_code = T2.zip \nWHERE T1.state = 'Maryland'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT m.member_id) AS count_of_members_from_Maryland\nFROM member m\nJOIN zip_code z ON m.zip = z.zip_code\nWHERE z.state = 'Maryland'"
        ],
        "amend_res": 1
    },
    "1497": {
        "db_id": "debit_card_specializing",
        "question": "Which SME customer consumed the least in June 2012?",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201206' AND T1.Segment = 'SME' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do select `T1.CustomerID` instead of `customer_name, MIN(consumption)`. Do join `yearmonth AS T2` with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying a single table. Do filter with `T2.Date = '201206'` and `T1.Segment = 'SME'` instead of `customer_type = 'SME' AND month = 'June' AND year = 2012`. Do add `GROUP BY T1.CustomerID` instead of omitting grouping. Do add `ORDER BY SUM(T2.Consumption) ASC` and `LIMIT 1` instead of using `MIN(consumption)` without ordering. The amended query now correctly identifies the SME customer with the lowest consumption in June 2012 by properly joining tables, using appropriate date filtering, and ordering aggregated results."
        ],
        "rules": [
            "1) When answering about \"which SME customer consumed the least in June 2012\": make sure the output order: T1.CustomerID. 2) When the question mentions \"SME customer\": \"SME\" actually means \"T1.Segment = 'SME'\" in schema. 3) When the question mentions \"June 2012\": this actually means \"T2.Date = '201206'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match). 5) When the question asks for \"least consumption\": rank rows by SUM(T2.Consumption) in ascending order and keep the first 1 row. 6) When computing consumption per customer: organize results by T1.CustomerID and compute SUM(T2.Consumption) per group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT customer_name, MIN(consumption) FROM customers WHERE customer_type = 'SME' AND month = 'June' AND year = 2012;",
            "SELECT T1.CustomerID\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T2.Date = '201206' AND T1.Segment = 'SME'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME' AND T2.Date = '201206'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1422": {
        "db_id": "student_club",
        "question": "State the category of events were held at MU 215.",
        "ground_truth": "SELECT DISTINCT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "amends": [
            "Do `SELECT DISTINCT T2.category` instead of `SELECT category` to eliminate duplicates. Do add `FROM event AS T1 INNER JOIN budget AS T2` instead of `FROM events` to join the budget table. Do add `ON T1.event_id = T2.link_to_event` instead of omitting the join condition. Do keep `WHERE T1.location = 'MU 215'` but reference the joined table instead of the original table. The amended query now correctly retrieves distinct categories from the joined tables with proper relationship mapping."
        ],
        "rules": [
            "1) When answering about \"category of events\": make sure the output order: T2.category. 2) When the question asks for distinct categories: compute the number of unique values of the exact token T2.category. 3) When combining T1 and T2 for shared entities: link rows where T1.event_id = T2.link_to_event exactly as shown; keep only matching pairs (inner match). 4) When filtering by location 'MU 215': use the exact literal 'MU 215' with the exact token T1.location."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT category FROM events WHERE location = 'MU 215';",
            "SELECT DISTINCT T2.category\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.category\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215'\nORDER BY T2.category;"
        ],
        "amend_res": 1
    },
    "997": {
        "db_id": "formula_1",
        "question": "Which citizenship do the vast majority of the drivers hold?",
        "ground_truth": "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1",
        "amends": [
            "Do use `nationality` instead of `citizenship` in both the SELECT list and GROUP BY clause. Do reference `COUNT(driverId)` instead of `COUNT(*)` in the ORDER BY clause while keeping the aggregate in SELECT as `COUNT(*)`. Do remove the alias `count` from the SELECT list instead of keeping it. The amended query now correctly groups by nationality and orders by the count of specific driver IDs rather than all rows, matching the intended behavior.",
            "Do remove `COUNT(*)` from the SELECT list instead of including it, as the query only needs to return the nationality with the highest count rather than both the nationality and its count. Do keep the `GROUP BY nationality` clause instead of changing it, maintaining the grouping by nationality. Do preserve the `ORDER BY COUNT(driverId) DESC` instead of modifying it, ensuring correct ordering by the count of driver IDs. Do maintain the `LIMIT 1` instead of altering it, correctly limiting to the top result. The amended query now matches RIGHT_SQL's behavior by returning only the nationality with the highest number of drivers."
        ],
        "rules": [
            "1) When the question mentions \"citizenship\": use the exact column token \"nationality\" instead. 2) When counting drivers: count using the canonical key \"driverId\" rather than all rows. 3) When ordering by count: order by the count of driverId in descending direction. 4) When answering about the majority citizenship: take only the top 1 result after ordering by count. 5) When grouping by nationality: organize results by the \"nationality\" column and compute counts per group. 6) When producing output: include \"nationality\" and the count without any alias in the SELECT list.",
            "1) When answering about \"which citizenship do the vast majority of the drivers hold\": make sure the output order: only return the nationality value without the count. 2) When the question asks for the majority nationality: group by the exact token \"nationality\" and count using the canonical key \"driverId\". 3) When determining the most common nationality: order by the count of driverId in descending order and keep only the first result (limit 1). 4) When handling text literals: do not change case, spacing, or punctuation of the nationality values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT citizenship, COUNT(*) as count FROM drivers GROUP BY citizenship ORDER BY count DESC LIMIT 1;",
            "SELECT nationality, COUNT(*) FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1;",
            "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(driverId) DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "597": {
        "db_id": "codebase_community",
        "question": "How many users from India have the teacher badges?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Location = 'India' AND T1.Name = 'Teacher'",
        "amends": [
            "Do select `COUNT(T1.Id)` from the `badges` table instead of `COUNT(*)` from the `users` table. Do join `badges AS T1` with `users AS T2` using `INNER JOIN` on `T1.UserId = T2.Id` instead of querying only the `users` table. Do filter on `T2.Location = 'India'` instead of `country = 'India'` and `T1.Name = 'Teacher'` instead of `badge = 'teacher'`. The amended query now correctly counts teacher badges for users located in India by properly joining the badges and users tables with the appropriate join condition and filtering criteria."
        ],
        "rules": [
            "1) When counting users with badges: count using T1.Id from the badges table instead of counting all rows from the users table. 2) When combining badges and users tables: link rows where T1.UserId = T2.Id using an inner join to keep only matching pairs. 3) When filtering for users from India: use T2.Location = 'India' instead of country = 'India'. 4) When filtering for teacher badges: use T1.Name = 'Teacher' instead of badge = 'teacher'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE country = 'India' AND badge = 'teacher';",
            "SELECT COUNT(T1.Id) \nFROM badges AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T2.Location = 'India' AND T1.Name = 'Teacher'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM badges T1 \nINNER JOIN users T2 ON T1.UserId = T2.Id \nWHERE T2.Location = 'India' AND T1.Name = 'Teacher'"
        ],
        "amend_res": 1
    },
    "764": {
        "db_id": "superhero",
        "question": "What are the superpowers of heroes with ID 1?",
        "ground_truth": "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1",
        "amends": [
            "Do select `T2.power_name` instead of `superpower`. Do add `DISTINCT` instead of omitting it. Do change the FROM clause to use `hero_power AS T1 INNER JOIN superpower AS T2` instead of just `heroes`. Do add the join condition `ON T1.power_id = T2.id` instead of omitting it. Do change the WHERE filter to `T1.hero_id = 1` instead of `hero_id = 2`. The amended query now correctly retrieves distinct power names from the joined tables for the specified hero ID."
        ],
        "rules": [
            "1) When the question asks for \"superpowers\": use the exact column token \"T2.power_name\" instead of \"superpower\". 2) When retrieving multiple values that may have duplicates: apply DISTINCT to eliminate duplicate results. 3) When combining hero and power information: use \"hero_power AS T1 INNER JOIN superpower AS T2\" with join condition \"T1.power_id = T2.id\" to link related records. 4) When filtering for a specific hero: use the exact condition \"T1.hero_id = 1\" with the literal value 1 as specified in the question. 5) When the question mentions \"heroes with ID 1\": ensure the filter uses the exact literal value 1, not 2 or any other value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superpower FROM heroes WHERE hero_id = 2;",
            "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1"
        ],
        "amend_res": 1
    },
    "1513": {
        "db_id": "debit_card_specializing",
        "question": "Which country's gas station had the first paid cusomer in 2012/8/25?",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' ORDER BY T1.Time DESC LIMIT 1",
        "amends": [
            "Do select `T2.Country` from the joined table instead of `country` from a single table. Do join `transactions_1k AS T1` with `gasstations AS T2` using `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of querying only `gas_stations` without any join. Do filter on `T1.Date = '2012-08-25'` with proper date format instead of `customer_paid_date = '2012/8/25'`. Do order by `T1.Time DESC` instead of `customer_paid_time ASC`. The amended query now correctly retrieves the country from the joined gas stations table based on transaction date and time, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which country's gas station had the first paid customer\": make sure the output order: T2.Country. 2) When combining transactions_1k AS T1 and gasstations AS T2: link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match). 3) When filtering for date '2012/8/25': use T1.Date = '2012-08-25' with the exact date format shown in the amends. 4) When determining the first paid customer: order by T1.Time DESC to get the earliest time first. 5) When selecting the top result: keep only the first row after ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM gas_stations WHERE customer_paid_date = '2012/8/25' ORDER BY customer_paid_time ASC LIMIT 1;",
            "SELECT T2.Country \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012-08-25'\nORDER BY T1.Time ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Country\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012-08-25'\nORDER BY T1.Time ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "180": {
        "db_id": "financial",
        "question": "Please provide a list of clients who were born between 1983 and 1987 and whose account branch is in East Bohemia, along with their IDs.",
        "evidence": "",
        "ground_truth": "SELECT T1.client_id, T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'",
        "amends": [
            "Do add `T3.account_id` to the SELECT list instead of only selecting `client_id`. Do change the FROM source from `clients` to `client AS T1` and add `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of omitting the district table. Do add `INNER JOIN disp AS T4 ON T1.client_id = T4.client_id` and `INNER JOIN account AS T3 ON T2.district_id = T3.district_id and T4.account_id = T3.account_id` instead of missing these necessary joins. Do change the WHERE filter from `branch = 'East Bohemia'` to `T2.A3 = 'east Bohemia'` to reference the correct table and column with proper case sensitivity. Do change the date function from `YEAR(birth_date)` to `STRFTIME('%Y', T1.birth_date)` with string year bounds `'1983'` AND `'1987'` instead of numeric bounds for proper date handling. The amended query now correctly joins multiple tables to retrieve both client and account information with proper date filtering and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about clients and their accounts: make sure to select both client_id and account_id from the appropriate tables. 2) When combining client and district information: link rows where T1.district_id = T2.district_id using an inner match. 3) When combining client and account information through disposition: link rows where T1.client_id = T4.client_id and T4.account_id = T3.account_id using inner matches. 4) When filtering by region: use T2.A3 = 'east Bohemia' with exact case sensitivity. 5) When filtering by birth year range: use STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987' with string year bounds instead of numeric bounds. 6) When the question mentions \"account branch is in East Bohemia\": \"East Bohemia\" actually means \"T2.A3 = 'east Bohemia'\" in schema with lowercase 'e'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT client_id FROM clients WHERE YEAR(birth_date) BETWEEN 1983 AND 1987 AND branch = 'East Bohemia';",
            "SELECT T1.client_id, T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T3 ON T2.district_id = T3.district_id AND T4.account_id = T3.account_id\nWHERE T2.A3 = 'east Bohemia'\nAND STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987'"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.client_id, a.account_id\nFROM client c\nINNER JOIN district d ON c.district_id = d.district_id\nINNER JOIN disp dp ON c.client_id = dp.client_id\nINNER JOIN account a ON dp.account_id = a.account_id\nWHERE STRFTIME('%Y', c.birth_date) BETWEEN '1983' AND '1987'\nAND d.A3 = 'east Bohemia';"
        ],
        "amend_res": 1
    },
    "1209": {
        "db_id": "thrombosis_prediction",
        "question": "Please provide the diagnosis of patients with ALT glutamic pylvic transaminase beyond the normal range by ascending order of their date of birth.",
        "ground_truth": "SELECT DISTINCT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT > 60 ORDER BY T1.Birthday ASC",
        "amends": [
            "Do select `DISTINCT T1.Diagnosis` instead of `diagnosis, date_of_birth` and remove the `date_of_birth` column from the output. Do use `INNER JOIN` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.GPT > 60` instead of `ALT > 100` to reference the correct laboratory value. Do order by `T1.Birthday ASC` instead of `date_of_birth ASC` using the proper column alias. The amended query now correctly joins patient and laboratory data, filters on GPT values instead of ALT, and returns distinct diagnoses ordered by birthday, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patient diagnoses with abnormal GPT levels: make sure the output order includes only distinct T1.Diagnosis values. 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for abnormal GPT levels: use the condition T2.GPT > 60 instead of ALT > 100. 4) When ordering results by date of birth: use T1.Birthday ASC instead of date_of_birth ASC. 5) When the question asks for diagnosis of patients: return only distinct T1.Diagnosis values, not date_of_birth columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT diagnosis, date_of_birth FROM patients WHERE ALT > 100 ORDER BY date_of_birth ASC;",
            "SELECT DISTINCT T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.GPT > 60\nORDER BY T1.Birthday ASC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Diagnosis\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GPT > 60\nORDER BY T1.Birthday ASC;"
        ],
        "amend_res": 1
    },
    "711": {
        "db_id": "codebase_community",
        "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
        "amends": [
            "Do `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct comment IDs rather than all rows. Do `INNER JOIN` on `T1.UserId = T2.Id` instead of `JOIN` on `u.user_id = c.user_id` with corrected join direction and column references. Do reference `T1.Score` and `T2.Age` instead of `c.score` and `u.age` with proper table aliases. Do use table aliases `T1` for comments and `T2` for users instead of `c` and `u`. The amended query now correctly counts distinct comments from users aged 40 with zero score, matching the intended behavior."
        ],
        "rules": [
            "1) When counting comments: use COUNT(DISTINCT T1.id) to count distinct comment IDs rather than all rows. 2) When combining comments and users tables: perform an INNER JOIN where T1.UserId = T2.Id to link comments to their users. 3) When filtering for zero-score comments: use T1.Score = 0 to select comments with score of 0. 4) When filtering for users aged 40: use T2.Age = 40 to select users who are 40 years old. 5) When assigning table aliases: use T1 for the comments table and T2 for the users table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users u JOIN comments c ON u.user_id = c.user_id WHERE c.score = 0 AND u.age = 40;",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM comments T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T1.Score = 0 AND T2.Age = 40"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Id) \nFROM comments T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T1.Score = 0 AND T2.Age = 40;"
        ],
        "amend_res": 1
    },
    "1491": {
        "db_id": "debit_card_specializing",
        "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
        "evidence": "",
        "ground_truth": "SELECT Country , ( SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' ) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1",
        "amends": [
            "Do use `Country` instead of `country` and move the aggregate calculation to a subquery in the SELECT list instead of a simple COUNT(*). Do reference `Segment = 'Value for money'` instead of `value_for_money = 'yes'` for the filter condition. Do change the table name to `gasstations` instead of `gas_stations` and use `GasStationID` for counting instead of generic COUNT(*). Do add a LIMIT 1 clause instead of omitting it to return only the top result. Do remove the alias `total_value_for_money_stations` instead of keeping it and reference COUNT(GasStationID) directly in ORDER BY instead of the alias. The amended query now correctly identifies value-for-money stations using the proper column and table names, and returns only the country with the highest count.",
            "Do use a scalar subquery `(SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money')` in the SELECT list instead of directly aggregating `COUNT(GasStationID)` at the same grouping level. Do maintain the same `WHERE Segment = 'Value for money'` filter in both the main query and subquery instead of applying it only once. Do keep the `GROUP BY Country` and `ORDER BY COUNT(GasStationID) DESC LIMIT 1` structure unchanged as they correctly identify the country with the highest count. The amended query now correctly calculates the total count of Value for money gas stations across all countries while still grouping by country to find the maximum, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"country\": use the exact column name \"Country\" from the gasstations table. 2) When filtering for \"value for money\" gas stations: use the condition \"Segment = 'Value for money'\" exactly as specified. 3) When counting gas stations: use \"GasStationID\" as the counting key instead of counting all columns. 4) When the question asks for the country with more value for money stations: return only the top result using LIMIT 1. 5) When ordering results by count: reference COUNT(GasStationID) directly in the ORDER BY clause instead of using an alias. 6) When referring to the gas stations table: use the exact table name \"gasstations\" instead of \"gas_stations\".",
            "1) When the question asks for \"value for money\" gas stations: use the exact literal 'Value for money' for the Segment filter. 2) When counting gas stations: use GasStationID as the counting key. 3) When grouping results by country: organize results by the Country column. 4) When finding the country with the highest count: order results by the count of GasStationID in descending order and keep only the top result. 5) When calculating total counts across all countries: use a scalar subquery to count all gas stations with Segment = 'Value for money' regardless of country grouping."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT country, COUNT(*) AS total_value_for_money_stations \nFROM gas_stations \nWHERE value_for_money = 'yes' \nGROUP BY country \nORDER BY total_value_for_money_stations DESC;",
            "SELECT Country, COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1;",
            "SELECT \n    Country,\n    (SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money') AS total_count\nFROM gasstations\nWHERE Segment = 'Value for money'\nGROUP BY Country\nORDER BY COUNT(GasStationID) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT Country, COUNT(GasStationID) AS TotalValueForMoneyStations\nFROM gasstations\nWHERE Segment = 'Value for money'\nGROUP BY Country\nORDER BY COUNT(GasStationID) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "392": {
        "db_id": "card_games",
        "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it. Do change the SELECT list to `T1.name` instead of `name`. Do add `INNER JOIN` on `rulings AS T2` with predicate `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do keep the `WHERE` filter on `T1.rarity = 'uncommon'` but change the ORDER BY to `T2.date ASC` instead of `ruling_date DESC`. Do maintain `LIMIT 3` but now the query correctly joins with the rulings table to sort by ruling date instead of using a non-existent column, ensuring proper results with distinct card names."
        ],
        "rules": [
            "1) When the question asks for cards with rarity of 'uncommon': filter rows where T1.rarity equals exactly 'uncommon'. 2) When combining cards and rulings tables: link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match). 3) When the question asks for distinct card names: ensure only unique values of T1.name are returned. 4) When the question requires ascending order of ruling date: sort results by T2.date in ascending order. 5) When the question asks for top 3 cards: keep only the first 3 rows after sorting. 6) When producing output: return T1.name as the result column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE rarity = 'uncommon' ORDER BY ruling_date DESC LIMIT 3;",
            "SELECT DISTINCT T1.name\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'uncommon'\nORDER BY T2.date ASC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.name\nFROM cards c\nINNER JOIN rulings r ON c.uuid = r.uuid\nWHERE c.rarity = 'uncommon'\nORDER BY r.date ASC\nLIMIT 3;"
        ],
        "amend_res": 1
    },
    "424": {
        "db_id": "card_games",
        "question": "What proportion of cards do not have a text box with a normal layout?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
        "amends": [
            "Do use `SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END)` instead of `COUNT(*)` with a `WHERE text_box_layout != 'normal'` filter. Do calculate the proportion as a percentage by multiplying by `100` instead of dividing by a subquery. Do cast the sum to `REAL` for proper division instead of integer division. Do reference the correct column `layout` instead of `text_box_layout` and include the additional condition `isTextless = 1` instead of omitting it. Do remove the subquery `(SELECT COUNT(*) FROM cards)` and instead use the main query's `COUNT(*)` in the denominator. The amended query now correctly calculates the percentage of cards that are both textless and have a normal layout."
        ],
        "rules": [
            "1) When the question asks for proportion of cards without a text box with normal layout: use the exact condition where \"isTextless\" = 1 and \"layout\" = 'normal' instead of just checking layout. 2) When calculating proportion as a percentage: multiply the ratio by 100 instead of keeping it as a decimal fraction. 3) When performing division to calculate proportion: cast the numerator to REAL type to avoid integer division. 4) When counting cards that meet specific conditions: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(*) with WHERE filter. 5) When referencing layout information: use the exact column name \"layout\" instead of \"text_box_layout\". 6) When calculating the denominator for proportion: use COUNT(*) from the main query scope instead of a subquery."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) / (SELECT COUNT(*) FROM cards) AS proportion FROM cards WHERE text_box_layout != 'normal';",
            "SELECT \n    (SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS proportion\nFROM \n    cards;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 \n    AS proportion_percentage\nFROM cards;"
        ],
        "amend_res": 1
    },
    "1492": {
        "db_id": "debit_card_specializing",
        "question": "What percentage of KAM customers pay in euros?",
        "ground_truth": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
        "amends": [
            "Do use `CAST(SUM(Currency = 'EUR') AS FLOAT)` for conditional counting instead of `COUNT(*)` with a subquery. Do calculate the percentage against `COUNT(CustomerID)` instead of a separate subquery count. Do filter by `Segment = 'KAM'` in the WHERE clause instead of filtering by `currency = 'EUR'`. Do remove the alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage of EUR customers within the KAM segment."
        ],
        "rules": [
            "1) When the question asks for percentage of customers paying in euros within KAM segment: calculate (number of EUR-paying KAM customers) divided by (total KAM customers) multiplied by 100.0. 2) When counting customers conditionally: use CAST(SUM(Currency = 'EUR') AS FLOAT) instead of COUNT(*) with subqueries. 3) When filtering for KAM customers: use WHERE Segment = 'KAM' to identify the target segment. 4) When calculating the denominator: use COUNT(CustomerID) for total KAM customers instead of separate subquery counts. 5) When the question mentions \"KAM customers\": this refers to customers where Segment = 'KAM'. 6) When the question mentions \"pay in euros\": this refers to customers where Currency = 'EUR'. 7) When producing output: do not include column aliases like 'percentage'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM customers WHERE currency = 'EUR') AS percentage FROM customers WHERE currency = 'EUR';",
            "SELECT (CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(CustomerID)) * 100 FROM customers WHERE Segment = 'KAM';"
        ],
        "rule_sql": [
            "SELECT (CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS FLOAT) / COUNT(CustomerID)) * 100.0 FROM customers WHERE Segment = 'KAM'"
        ],
        "amend_res": 1
    },
    "530": {
        "db_id": "card_games",
        "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
        "ground_truth": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
        "amends": [
            "Do select `T1.frameVersion`, `T1.name`, and a conditional expression using `IIF(T2.status = 'Banned', T1.name, 'NO')` instead of `frame_style`, `card_name`, and `banned`. Do add `INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid` instead of omitting the join to the legalities table. Do use `T1.artist = 'Allen Williams'` instead of `artist = 'Allen Williams'` with proper table qualification. Do add `DISTINCT` instead of omitting it to remove duplicate rows. Do remove `ORDER BY frame_style, card_name` instead of keeping the ordering clause. The amended query now correctly joins with the legalities table to determine banned status and returns distinct results matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"frame styles and cards Allen Williams worked on\": make sure the output order: T1.frameVersion, T1.name, and a conditional expression for banned status. 2) When the question mentions \"frame styles\": \"frame styles\" actually means \"T1.frameVersion in schema\". 3) When the question mentions \"cards\": \"cards\" actually means \"T1.name in schema\". 4) When the question asks about \"banned cards\": use a conditional expression IIF(T2.status = 'Banned', T1.name, 'NO') to determine banned status. 5) When combining T1 and T2 for shared entities: link rows where T1.uuid = T2.uuid exactly as shown; keep only matching pairs (inner match). 6) When filtering for Allen Williams: use T1.artist = 'Allen Williams' with exact literal 'Allen Williams'. 7) When returning results: use DISTINCT to remove duplicate rows. 8) When producing output: do not include any ORDER BY clause as the question does not require ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT frame_style, card_name, banned \nFROM cards \nWHERE artist = 'Allen Williams' \nORDER BY frame_style, card_name;",
            "SELECT DISTINCT T1.frameVersion, T1.name, IIF(T2.status = 'Banned', T1.name, 'NO') \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T1.artist = 'Allen Williams'"
        ],
        "rule_sql": [
            "SELECT DISTINCT \n    T1.frameVersion, \n    T1.name, \n    IIF(T2.status = 'Banned', T1.name, 'NO') AS banned_status\nFROM \n    cards T1\nINNER JOIN \n    legalities T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.artist = 'Allen Williams'"
        ],
        "amend_res": 1
    },
    "1273": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients have a normal anti-SSB and are diagnosed with SLE in the examination?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count distinct patient IDs rather than all examination records. Do reference `Patient AS T1` and `Laboratory AS T2` instead of `patients p` and `examinations e` with corrected table names and aliases. Do join on `T1.ID = T2.ID` instead of `p.patient_id = e.patient_id` with proper ID column matching. Do filter with `T2.SSB = 'negative' OR '0'` instead of `e.anti_ssb = 'normal'` to capture both negative and zero values for SSB rather than just normal anti-SSB. Do keep `T1.Diagnosis = 'SLE'` filter which remains consistent in both queries. The amended query now correctly counts distinct SLE patients with negative or zero SSB laboratory values, matching the intended behavior.",
            "Do use parentheses around the OR condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` to properly evaluate both conditions against the SSB column. The amended query now correctly counts distinct patient IDs with SLE diagnosis who have either negative or 0 SSB laboratory values, matching the intended behavior.",
            "Do place the `T2.SSB = 'negative' OR '0'` filter in the WHERE clause instead of incorrectly parenthesizing it with `(T2.SSB = 'negative' OR T2.SSB = '0')`. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` instead of changing the join type. Do keep the `COUNT(DISTINCT T1.ID)` aggregation and `T1.Diagnosis = 'SLE'` filter unchanged. The amended query now correctly handles the SSB filter logic without unnecessary parentheses while maintaining the same join semantics and aggregation behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to correctly filter for SSB values that are either 'negative' or '0' while maintaining the same join structure and aggregation logic. The amended query now matches RIGHT_SQL's behavior with proper boolean logic.",
            "Do use the correct logical operator precedence with parentheses for the `WHERE` clause condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would cause a type mismatch error. Do maintain the same join condition `T1.ID = T2.ID` and keep the same `COUNT(DISTINCT T1.ID)` aggregation and table structure. The amended query now correctly filters for patients with SLE diagnosis and either negative or zero SSB values, matching the right SQL's intended behavior.",
            "Do use the correct logical operator precedence with parentheses around the `OR` condition instead of incorrectly grouping `T2.SSB = 'negative' OR T2.SSB = '0'` without proper operator precedence. Do maintain the `COUNT(DISTINCT T1.ID)` aggregation and `INNER JOIN` on `T1.ID = T2.ID` as in the original query. Do keep both filter conditions `T1.Diagnosis = 'SLE'` and the SSB condition, but ensure proper logical grouping to avoid unintended query behavior. The amended query now correctly handles the logical operator precedence to match the intended filtering logic.",
            "Do use the correct logical operator precedence with parentheses for the `WHERE` clause condition `(T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'` instead of the incorrect grouping `T2.SSB = 'negative' OR '0' AND T1.Diagnosis = 'SLE'` which would evaluate '0' as a boolean true value. The amended query now correctly filters for patients with SLE diagnosis who have either negative or zero SSB values, matching the RIGHT_SQL's intended behavior.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which improperly uses parentheses and redundant column references. The amended query now correctly evaluates the logical condition without unnecessary grouping and matches the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `T2.SSB` filter condition instead of keeping them, as the logical operator precedence without parentheses produces the intended behavior where `T2.SSB = 'negative' OR '0'` is evaluated correctly with the `AND T1.Diagnosis = 'SLE'` condition. The amended query now matches RIGHT_SQL's behavior.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which improperly uses parentheses and redundant column references. The amended query now correctly evaluates the logical condition without unnecessary grouping while maintaining the same join structure, column selection, and aggregation logic to count distinct patient IDs with SLE diagnosis and specific laboratory results.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the SSB filter conditions together with parentheses to ensure correct logical evaluation while maintaining the same join structure, column selection, and diagnosis filter.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the OR condition to correctly filter for SSB values that are either 'negative' or '0' while maintaining the same join structure and SELECT clause. The amended query now matches RIGHT_SQL's behavior with proper boolean logic.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which improperly groups the conditions with parentheses. The amended query removes the unnecessary parentheses around the OR condition while maintaining the same logical behavior of filtering for SSB values that are either 'negative' or '0', combined with the SLE diagnosis filter. This change ensures the query now matches the RIGHT_SQL's behavior.",
            "Do use the condition `T2.SSB = 'negative' OR '0'` instead of `(T2.SSB = 'negative' OR T2.SSB = '0')` in the WHERE clause, removing the explicit second equality check against the column and instead comparing directly against the string literal '0'. The amended query now correctly matches the RIGHT_SQL's behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. Do maintain the same `COUNT(DISTINCT T1.ID)` aggregation, `INNER JOIN` on `T1.ID = T2.ID`, and `T1.Diagnosis = 'SLE'` filter without changes. The amended query now correctly groups the OR condition to properly filter for SSB values of either 'negative' or '0' while maintaining the same join logic and counting distinct patient IDs with SLE diagnosis.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which improperly groups the OR condition with parentheses, ensuring the logic correctly evaluates SSB values as either 'negative' or '0' while maintaining the Diagnosis filter. The amended query now matches RIGHT_SQL's behavior with proper boolean evaluation.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which improperly uses parentheses and duplicates the column reference. The amended query removes the unnecessary parentheses and redundant column comparison, maintaining the same logical condition while using proper SQL syntax. This change ensures the query correctly filters for SSB values that are either 'negative' or '0' while preserving the SLE diagnosis filter, and the amended query now matches RIGHT_SQL's behavior.",
            "Do use parentheses around the entire `OR` condition `(T2.SSB = 'negative' OR T2.SSB = '0')` instead of the incorrect syntax `T2.SSB = 'negative' OR '0'` which would evaluate '0' as a boolean true value. The amended query properly groups the SSB filter conditions together with parentheses to ensure correct logical evaluation while maintaining the same join structure and selection criteria.",
            "Do use the correct logical operator precedence in the WHERE clause by writing `T2.SSB = 'negative' OR '0'` instead of incorrectly parenthesizing `(T2.SSB = 'negative' OR T2.SSB = '0')` which changes the logical evaluation. The amended query now correctly matches the RIGHT_SQL's behavior.",
            "Do use the correct WHERE clause predicate `T2.SSB = 'negative' OR '0'` instead of the incorrect `(T2.SSB = 'negative' OR T2.SSB = '0')` which improperly uses parentheses and redundant column references. The amended query removes the unnecessary parentheses and correctly compares the column value against 'negative' while treating '0' as a literal boolean condition, which now matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN examinations e ON p.patient_id = e.patient_id\nWHERE e.anti_ssb = 'normal' \nAND p.diagnosis = 'SLE';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0')\nAND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE'\nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE'\nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE'\nAND (T2.SSB = 'negative' OR T2.SSB = '0')",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') \nAND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.SSB = 'negative' OR T2.SSB = '0') AND T1.Diagnosis = 'SLE'"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "1329": {
        "db_id": "student_club",
        "question": "What county did Sherri Ramsey grew up?",
        "evidence": "",
        "ground_truth": "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'",
        "amends": [
            "Do select `T2.county` instead of `county` to specify the source table. Do use `FROM member AS T1 INNER JOIN zip_code AS T2` instead of `FROM people` to join two tables instead of querying a single table. Do add join condition `ON T1.zip = T2.zip_code` instead of omitting it to properly relate the tables. Do change filter to `T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'` instead of `name = 'Sherri Ramsey'` to match the split name structure in the member table. The amended query now correctly retrieves county information by joining member records with zip code data using the proper relationship."
        ],
        "rules": [
            "1) When the question asks about county information for a person: join the member table (as T1) with the zip_code table (as T2) using the relationship T1.zip = T2.zip_code to connect person records with their geographic data. 2) When the question mentions a person's name like 'Sherri Ramsey': split the name into first_name and last_name components and filter using T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey' to match the member table structure. 3) When retrieving county information: select T2.county from the zip_code table rather than a generic county column to specify the correct source table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT county FROM people WHERE name = 'Sherri Ramsey';",
            "SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'"
        ],
        "rule_sql": [
            "SELECT T2.county \nFROM member T1 \nJOIN zip_code T2 ON T1.zip = T2.zip_code \nWHERE T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey'"
        ],
        "amend_res": 1
    },
    "822": {
        "db_id": "superhero",
        "question": "How many green-skinned villains are there in the superhero universe?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.alignment = 'Bad' AND T3.colour = 'Green'",
        "amends": [
            "Do select `COUNT(T1.id)` from specific table columns instead of `COUNT(*)` from an unspecified source. Do use `FROM superhero AS T1` with joined tables `alignment AS T2` and `colour AS T3` instead of querying only a `villains` table. Do implement `INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id` to connect alignment data instead of assuming alignment in the main table. Do add `INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id` to properly reference color through a relationship instead of directly filtering skin color. Do apply filters `T2.alignment = 'Bad'` and `T3.colour = 'Green'` through joined table conditions instead of a simple `skin_color = 'red'` filter. The amended query now correctly counts superheroes with bad alignment and green skin color through proper table relationships instead of incorrectly counting villains with red skin in a single table."
        ],
        "rules": [
            "1) When counting entities in the superhero universe: use COUNT(T1.id) instead of COUNT(*) to count specific entities. 2) When the question mentions \"villains\": \"villains\" actually means superheroes with T2.alignment = 'Bad' in the schema. 3) When the question mentions \"green-skinned\": \"green-skinned\" actually means T3.colour = 'Green' in the schema. 4) When combining tables for superhero data: link rows using T1.alignment_id = T2.id to connect to alignment data and T1.skin_colour_id = T3.id to connect to color data, keeping only matching pairs (inner match). 5) When answering about \"how many green-skinned villains\": make sure to filter for both T2.alignment = 'Bad' and T3.colour = 'Green' conditions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM villains WHERE skin_color = 'red';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nINNER JOIN alignment AS T2 ON T1.alignment_id = T2.id\nINNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id\nWHERE T2.alignment = 'Bad' AND T3.colour = 'Green'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nINNER JOIN alignment T2 ON T1.alignment_id = T2.id\nINNER JOIN colour T3 ON T1.skin_colour_id = T3.id\nWHERE T2.alignment = 'Bad' AND T3.colour = 'Green'"
        ],
        "amend_res": 1
    },
    "150": {
        "db_id": "financial",
        "question": "How many accounts in North Bohemia has made a transaction with the partner's bank being AB?",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.bank = 'AB' AND T1.A3 = 'north Bohemia'",
        "amends": [
            "Do add joins to `district AS T1` and `trans AS T3` instead of querying only the `accounts` table. Do change the count to `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific account records. Do use `INNER JOIN` on `T1.district_id = T2.district_id` and `INNER JOIN` on `T2.account_id = T3.account_id` instead of no joins. Do move the bank filter to `T3.bank = 'AB'` instead of `partner_bank = 'AB'` and change the region filter to `T1.A3 = 'north Bohemia'` instead of `region = 'North Bohemia'` with corrected case sensitivity. The amended query now correctly joins related tables and filters on the appropriate columns to match the intended logic.",
            "Do remove `DISTINCT` from `COUNT` instead of keeping it, as the count should include all matching accounts regardless of duplicates. Do maintain the same `INNER JOIN` structure on `T1.district_id = T2.district_id` and `T2.account_id = T3.account_id` without changes. Do keep both `WHERE` filters `T3.bank = 'AB'` and `T1.A3 = 'north Bohemia'` with their original conditions, only reordering them for optimization without semantic change. The amended query now correctly counts all accounts from north Bohemia district with AB bank transactions instead of counting distinct accounts only."
        ],
        "rules": [
            "1) When answering about accounts in North Bohemia: use T1.A3 = 'north Bohemia' for the region filter with exact case sensitivity. 2) When filtering for transactions with partner bank AB: use T3.bank = 'AB' instead of partner_bank column. 3) When counting accounts: use COUNT(T2.account_id) to count specific account records instead of COUNT(*). 4) When combining district and accounts tables: link rows where T1.district_id = T2.district_id using inner join. 5) When combining accounts and transactions tables: link rows where T2.account_id = T3.account_id using inner join.",
            "1) When the question asks for \"how many accounts\": count all matching account rows using T2.account_id without removing duplicates. 2) When combining district (T1) and account (T2) tables: link rows where T1.district_id equals T2.district_id and keep only matching pairs. 3) When combining account (T2) and trans (T3) tables: link rows where T2.account_id equals T3.account_id and keep only matching pairs. 4) When filtering for accounts from North Bohemia: use the exact condition T1.A3 = 'north Bohemia' with the literal 'north Bohemia' exactly as specified. 5) When filtering for transactions with partner's bank AB: use the exact condition T3.bank = 'AB' with the literal 'AB' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE region = 'North Bohemia' AND partner_bank = 'AB';",
            "SELECT COUNT(DISTINCT T2.account_id) \nFROM district AS T1 \nINNER JOIN account AS T2 ON T1.district_id = T2.district_id \nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id \nWHERE T1.A3 = 'north Bohemia' AND T3.bank = 'AB'",
            "SELECT COUNT(T2.account_id)\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.A3 = 'north Bohemia' AND T3.bank = 'AB'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) \nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T1.A3 = 'north Bohemia' AND T3.bank = 'AB'"
        ],
        "amend_res": 1
    },
    "45": {
        "db_id": "california_schools",
        "question": "What is the average writing score of each of the schools managed by Ricci Ulrich? List the schools and the corresponding average writing scores.",
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'",
        "amends": [
            "Do select `T2.School` and `T1.AvgScrWrite` instead of `school_name` and `AVG(math_score) as avg_writing_score`. Do use `FROM satscores AS T1 INNER JOIN schools AS T2` instead of `FROM schools JOIN principals`. Do join on `T1.cds = T2.CDSCode` instead of `schools.principal_id = principals.principal_id`. Do filter on `T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'` instead of `principals.first_name = 'Ricci' AND principals.last_name = 'Ulrich'`. Do remove `GROUP BY` instead of grouping by `school_name`. The amended query now correctly retrieves school names and writing scores from the appropriate tables using the correct join condition and administrator name filters."
        ],
        "rules": [
            "1) When answering about schools managed by Ricci Ulrich: select T2.School and T1.AvgScrWrite as output columns. 2) When combining SAT scores and schools data: link rows where T1.cds = T2.CDSCode using an inner match. 3) When filtering for administrator Ricci Ulrich: apply the condition T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich' exactly as written. 4) When the question asks for average writing scores: use the pre-computed average T1.AvgScrWrite instead of calculating an average from raw scores. 5) When the question does not require grouping: do not include any GROUP BY clause in the query."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, AVG(math_score) as avg_writing_score \nFROM schools \nJOIN principals ON schools.principal_id = principals.principal_id \nWHERE principals.first_name = 'Ricci' AND principals.last_name = 'Ulrich' \nGROUP BY school_name;",
            "SELECT T2.School, T1.AvgScrWrite \nFROM satscores AS T1 \nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode \nWHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'"
        ],
        "rule_sql": [
            "SELECT T2.School, T1.AvgScrWrite \nFROM satscores T1 \nINNER JOIN schools T2 ON T1.cds = T2.CDSCode \nWHERE T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich'"
        ],
        "amend_res": 1
    },
    "1410": {
        "db_id": "student_club",
        "question": "List out the full name and total cost that member id \"rec4BLdZHS2Blfp4v\" incurred?",
        "ground_truth": "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do reference `T1.first_name` and `T1.last_name` instead of `first_name` and `last_name` without table qualification. Do use `SUM(T2.cost)` instead of `SUM(amount) as total_cost`. Do use `member AS T1` instead of `members`. Do use `expense AS T2` instead of `transactions`. Do use `INNER JOIN` instead of `JOIN`. Do join on `T1.member_id = T2.link_to_member` instead of `members.id = transactions.member_id`. Do filter on `T1.member_id = 'rec4BLdZHS2Blfp4v'` instead of `members.id = 'rec4BLdZHS2Blfp4v'`. Do remove the alias `total_cost` instead of keeping it. The amended query now correctly calculates the sum of costs from the expense table joined to the member table using the proper member_id relationship."
        ],
        "rules": [
            "1) When answering about \"member id 'rec4BLdZHS2Blfp4v'\": use T1.member_id = 'rec4BLdZHS2Blfp4v' as the filter condition. 2) When combining member and expense tables: link rows where T1.member_id = T2.link_to_member using an inner match. 3) When calculating total cost: compute SUM(T2.cost) instead of SUM(amount). 4) When selecting output columns: use T1.first_name and T1.last_name with exact table qualification. 5) When referring to table aliases: use member AS T1 and expense AS T2 as specified. 6) When producing output: do not use the alias total_cost for the sum result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, SUM(amount) as total_cost FROM members JOIN transactions ON members.id = transactions.member_id WHERE members.id = 'rec4BLdZHS2Blfp4v'",
            "SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, SUM(T2.cost) \nFROM member AS T1 \nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.member_id = 'rec4BLdZHS2Blfp4v' \nGROUP BY T1.first_name, T1.last_name"
        ],
        "amend_res": 1
    },
    "897": {
        "db_id": "formula_1",
        "question": "Name the driver with the most winning. Mention his nationality and what is his maximum point scores.",
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId WHERE T2.wins >= 1 GROUP BY T1.forename, T1.surname, T1.nationality ORDER BY COUNT(T2.wins) DESC LIMIT 1",
        "amends": [
            "Do use `T1.forename, T1.surname, T1.nationality` instead of `driver_name, nationality` for the SELECT list. Do add `MAX(T2.points)` instead of `MAX(points)` to reference the correct table. Do change FROM to `drivers AS T1 INNER JOIN driverStandings AS T2` instead of just `drivers` to include the necessary join. Do add `ON T2.driverId = T1.driverId` instead of omitting the join condition. Do add `WHERE T2.wins >= 1` instead of omitting the filter condition. Do change GROUP BY to `T1.forename, T1.surname, T1.nationality` instead of `driver_name, nationality` to match the SELECT list. Do change ORDER BY to `COUNT(T2.wins)` instead of `COUNT(wins)` to reference the correct table. The amended query now correctly joins the drivers and driverStandings tables, filters for drivers with wins, and properly references columns from the appropriate tables to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"driver with the most winning\": use T1.forename, T1.surname, T1.nationality instead of driver_name, nationality for the output columns. 2) When combining drivers and driverStandings tables: link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match). 3) When filtering for drivers with wins: include only rows where T2.wins >= 1. 4) When computing maximum points: use MAX(T2.points) instead of MAX(points) to reference the correct table. 5) When grouping results: organize by T1.forename, T1.surname, T1.nationality to match the SELECT list. 6) When ordering by number of wins: use COUNT(T2.wins) instead of COUNT(wins) to reference the correct table. 7) When finding the driver with most wins: rank rows by COUNT(T2.wins) in descending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name, nationality, MAX(points) as max_points \nFROM drivers \nGROUP BY driver_name, nationality \nORDER BY COUNT(wins) DESC \nLIMIT 1;",
            "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) \nFROM drivers AS T1 \nINNER JOIN driverStandings AS T2 ON T2.driverId = T1.driverId \nWHERE T2.wins >= 1 \nGROUP BY T1.forename, T1.surname, T1.nationality \nORDER BY COUNT(T2.wins) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.forename, T1.surname, T1.nationality, MAX(T2.points) AS max_points\nFROM drivers T1\nINNER JOIN driverStandings T2 ON T2.driverId = T1.driverId\nWHERE T2.wins >= 1\nGROUP BY T1.forename, T1.surname, T1.nationality\nORDER BY COUNT(T2.wins) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1223": {
        "db_id": "thrombosis_prediction",
        "question": "Are there more male patients with creatinine not within the normal range than female? True or False?",
        "ground_truth": "SELECT CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5",
        "amends": [
            "Do use `CASE WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) THEN 'True' ELSE 'False' END` instead of counting abnormal creatinine cases by gender. Do join `Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table. Do filter with `WHERE T2.CRE >= 1.5` instead of comparing male and female abnormal counts. Do remove the gender-specific creatinine range conditions and instead use a single creatinine threshold. The amended query now correctly compares total male and female patient counts with elevated creatinine levels rather than attempting to compare counts of abnormal cases within the same query."
        ],
        "rules": [
            "1) When answering about comparing male and female patients with elevated creatinine: use Patient table as T1 and Laboratory table as T2 with an inner join on T1.ID = T2.ID. 2) When filtering for elevated creatinine levels: use WHERE T2.CRE >= 1.5 as the single threshold condition. 3) When counting patients by gender: use SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) for male count and SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) for female count. 4) When comparing counts: use CASE WHEN male_count > female_count THEN 'True' ELSE 'False' END to determine if there are more male patients. 5) When handling gender values: use exact literals 'M' for male and 'F' for female as shown in T1.SEX column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN gender = 'M' AND (creatinine < 0.7 OR creatinine > 1.3) THEN 1 END) AS male_abnormal_count,\n    COUNT(CASE WHEN gender = 'F' AND (creatinine < 0.6 OR creatinine > 1.1) THEN 1 END) AS female_abnormal_count\nFROM patients\nWHERE male_abnormal_count > female_abnormal_count;",
            "SELECT CASE \n    WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) \n    THEN 'True' \n    ELSE 'False' \nEND AS result\nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.CRE >= 1.5"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) \n        THEN 'True' \n        ELSE 'False' \n    END as result\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T2.CRE >= 1.5"
        ],
        "amend_res": 1
    },
    "1442": {
        "db_id": "student_club",
        "question": "What is the percentage of the events that went over budget?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(budget_id) FROM budget",
        "amends": [
            "Do use `SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN actual_cost > budget THEN 1 END)` to count occurrences where remaining is negative rather than counting when actual_cost exceeds budget. Do reference `budget_id` in `COUNT(budget_id)` instead of `COUNT(*)` to count only non-null budget_id values. Do cast the result to `REAL` using `CAST(... AS REAL)` instead of using `100.0` for floating-point division. Do calculate from the `budget` table instead of the `events` table. Do multiply by `100` after division instead of before division. The amended query now correctly calculates the percentage of budget entries where remaining is negative.",
            "Do place the multiplication by 100 after the division instead of before it, changing the mathematical operation order from `* 100 / COUNT(budget_id)` to `/ COUNT(budget_id) * 100` to correctly calculate the percentage. Do remove the alias `AS percentage_over_budget` instead of keeping it, as the right SQL omits the explicit column naming. The amended query now correctly computes the percentage of budgets that are over budget by fixing the mathematical operation precedence.",
            "Do place the multiplication by 100 after the division instead of before it, changing `CAST(...) / COUNT(budget_id) * 100` to `CAST(...) * 100 / COUNT(budget_id)` to correctly calculate the percentage of budgets with negative remaining values. The amended query now matches RIGHT_SQL's behavior by properly computing the percentage calculation."
        ],
        "rules": [
            "1) When calculating percentage of events that went over budget: use the \"budget\" table instead of the \"events\" table. 2) When counting occurrences where remaining is negative: use SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) instead of counting when actual_cost exceeds budget. 3) When counting total budget entries: use COUNT(budget_id) instead of COUNT(*) to count only non-null budget_id values. 4) When performing floating-point division: cast the result to REAL using CAST(... AS REAL) instead of using 100.0. 5) When calculating percentage: multiply by 100 after division instead of before division.",
            "1) When calculating percentages: perform division first then multiply by 100 to maintain correct mathematical operation precedence. 2) When the question asks for \"percentage of events that went over budget\": count rows where remaining < 0 divided by total count of budget_id, then multiply by 100. 3) When producing output columns: omit explicit column aliases if the amends show they should be removed.",
            "1) When calculating a percentage: perform the division first and then multiply by 100 to get the correct percentage value. 2) When counting events that went over budget: identify them as events where the remaining value is negative (remaining < 0). 3) When computing percentage of events: use the formula (count of events meeting condition * 100) / total count of events."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN actual_cost > budget THEN 1 END) * 100.0 / COUNT(*)) AS percentage_over_budget\nFROM events;",
            "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(budget_id) * 100 AS percentage_over_budget FROM budget;",
            "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) / COUNT(budget_id) * 100 FROM budget;",
            "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(budget_id) FROM budget;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(budget_id) AS REAL) FROM budget;"
        ],
        "amend_res": 1
    },
    "503": {
        "db_id": "card_games",
        "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
        "ground_truth": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
        "amends": [
            "Do select `type` instead of `expansion_type` from the `sets` table. Do filter using `code IN (subquery)` instead of directly comparing `card_name = 'Samite Pilgrim'`, where the subquery selects `setCode` from the `cards` table filtering by `name = 'Samite Pilgrim'` instead of querying the `sets` table directly. This amendment correctly correlates card names with their respective set codes through the proper table relationship, ensuring the query returns the correct set type for the specified card name."
        ],
        "rules": [
            "1) When the question asks for expansion type: use column \"type\" from table \"sets\" instead of \"expansion_type\". 2) When filtering for a specific card name like \"Samite Pilgrim\": first find the set codes in table \"cards\" where \"name\" equals 'Samite Pilgrim', then use those set codes to filter the \"sets\" table. 3) When combining card information with set information: use the relationship where \"cards.setCode\" matches \"sets.code\" through a subquery approach. 4) When selecting the final result: output only the \"type\" column from the \"sets\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expansion_type FROM sets WHERE card_name = 'Samite Pilgrim';",
            "SELECT type FROM sets WHERE code IN (SELECT setCode FROM cards WHERE name = 'Samite Pilgrim')"
        ],
        "rule_sql": [
            "SELECT s.type \nFROM sets s \nWHERE s.code IN (\n    SELECT c.setCode \n    FROM cards c \n    WHERE c.name = 'Samite Pilgrim'\n)"
        ],
        "amend_res": 1
    },
    "1031": {
        "db_id": "european_football_2",
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "ground_truth": "SELECT DISTINCT DATETIME() - T2.birthday age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.`date`) >= '2013' AND STRFTIME('%Y',t1.`date`) <= '2015' AND t1.sprint_speed >= 97",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do calculate age using `DATETIME() - T2.birthday` instead of `2023 - birth_year` for proper date arithmetic. Do reference tables `Player_Attributes AS t1` and `Player AS t2` instead of just `players` with proper table aliases. Do use `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of a single table query to properly join the two related tables. Do filter using `STRFTIME('%Y',t1.date) >= '2013' AND STRFTIME('%Y',t1.date) <= '2015'` instead of `year BETWEEN 2013 AND 2015` to properly extract and compare year components from date strings. Do reference `t1.sprint_speed` instead of just `sprint_speed` with proper table qualification. The amended query now correctly handles the multi-table relationship, proper date calculations, and year filtering to match the intended behavior.",
            "Do remove `t2.player_name` and `t1.sprint_speed` from the SELECT list instead of including them, and do remove the alias `AS age` instead of keeping it. Do move the `t1.sprint_speed >= 97` filter to the end of the WHERE clause instead of placing it first. Do remove the parentheses from `DATETIME('now')` instead of including them. The amended query now correctly focuses only on calculating player ages within the specified date range with the sprint speed filter, matching the RIGHT_SQL's behavior.",
            "Do calculate age using `DATETIME() - T2.birthday` instead of the complex `strftime` arithmetic with year subtraction and date comparison. Do maintain the same `SELECT DISTINCT` clause instead of changing it. Do keep the same `FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id` structure instead of modifying the join. Do preserve the identical `WHERE` filters on `STRFTIME('%Y',t1.date) >= '2013'`, `STRFTIME('%Y',t1.date) <= '2015'`, and `t1.sprint_speed >= 97` instead of altering any conditions. The amended query now correctly calculates age using SQLite's datetime arithmetic while maintaining the same filtering logic and join structure."
        ],
        "rules": [
            "1) When the question asks for player ages with sprint speed conditions: use DISTINCT to eliminate duplicate rows. 2) When calculating player age: compute age using DATETIME() - T2.birthday instead of simple year subtraction for proper date arithmetic. 3) When accessing player data: reference tables Player_Attributes AS T1 and Player AS T2 with proper table aliases. 4) When combining player attributes and player information: use INNER JOIN on T1.player_api_id = T2.player_api_id to properly link the two related tables. 5) When filtering by year range 2013 to 2015: use STRFTIME('%Y',T1.date) >= '2013' AND STRFTIME('%Y',T1.date) <= '2015' to properly extract and compare year components from date strings. 6) When referencing sprint speed: use T1.sprint_speed with proper table qualification instead of unqualified sprint_speed.",
            "1) When the question asks to calculate player ages: only include the age calculation in the output, not player names or sprint speed values. 2) When calculating age from birthday: use DATETIME('now') - t2.birthday without parentheses around the datetime function. 3) When filtering by sprint speed: place the t1.sprint_speed >= 97 condition at the end of the WHERE clause. 4) When the question specifies a date range between 2013 to 2015: filter using STRFTIME('%Y', t1.date) >= '2013' AND STRFTIME('%Y', t1.date) <= '2015' to include both years inclusively.",
            "1) When calculating age from a birthday field: use DATETIME() - T2.birthday instead of complex strftime arithmetic with year subtraction and date comparison. 2) When the question asks for distinct values: maintain SELECT DISTINCT clause to return unique results. 3) When combining Player_Attributes and Player tables: use INNER JOIN with T1.player_api_id = T2.player_api_id as the join condition. 4) When filtering by year range 2013 to 2015: use STRFTIME('%Y',t1.date) >= '2013' AND STRFTIME('%Y',t1.date) <= '2015' with exact literals '2013' and '2015'. 5) When filtering by sprint speed: use t1.sprint_speed >= 97 with the exact numeric value 97."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, (2023 - birth_year) AS age FROM players WHERE sprint_speed >= 97 AND year BETWEEN 2013 AND 2015;",
            "SELECT DISTINCT \n    t2.player_name,\n    (DATETIME('now') - t2.birthday) AS age,\n    t1.sprint_speed\nFROM \n    Player_Attributes AS t1\nINNER JOIN \n    Player AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.sprint_speed >= 97\n    AND STRFTIME('%Y', t1.date) >= '2013' \n    AND STRFTIME('%Y', t1.date) <= '2015'",
            "SELECT DISTINCT (strftime('%Y', 'now') - strftime('%Y', t2.birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', t2.birthday)) AS age\nFROM Player_Attributes AS t1\nINNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE strftime('%Y', t1.date) >= '2013' \nAND strftime('%Y', t1.date) <= '2015'\nAND t1.sprint_speed >= 97",
            "SELECT DISTINCT (DATETIME('now') - t2.birthday) \nFROM Player_Attributes AS t1 \nINNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE STRFTIME('%Y', t1.date) >= '2013' \nAND STRFTIME('%Y', t1.date) <= '2015' \nAND t1.sprint_speed >= 97"
        ],
        "rule_sql": [
            "SELECT DISTINCT DATETIME('now') - T2.birthday AS age\nFROM Player_Attributes AS T1\nINNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id\nWHERE STRFTIME('%Y', T1.date) >= '2013' \nAND STRFTIME('%Y', T1.date) <= '2015'\nAND T1.sprint_speed >= 97"
        ],
        "amend_res": 1
    },
    "1219": {
        "db_id": "thrombosis_prediction",
        "question": "For all patients with normal uric acid (UA), what is the average UA index based on their latest laboratory examination result?",
        "ground_truth": "SELECT AVG(T2.UA) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') AND T2.Date = ( SELECT MAX(Date) FROM Laboratory )",
        "amends": [
            "Do remove the parentheses grouping around the gender-specific UA conditions instead of keeping them, and do move the `T2.Date` filter to be part of the main WHERE clause conjunction instead of having it as a separate condition. The amended query now correctly combines all filter conditions in the WHERE clause without unnecessary parentheses grouping, while maintaining the same logical behavior of calculating the average UA value for patients based on their most recent laboratory results with gender-specific thresholds.",
            "Do remove the subquery for latest dates and instead use a simple `MAX(Date)` comparison in the `WHERE` clause. Do change the join from `INNER JOIN` with a subquery to a direct `INNER JOIN` between `Patient` and `Laboratory` tables. Do modify the UA threshold conditions from `UA <= 7.0` for males and `UA <= 6.0` for females to `UA < 8.0` for males and `UA < 6.5` for females. Do remove the grouping by ID since we're calculating a single average across all matching records. Do change the table aliases from `lab` and `p` to `T2` and `T1` respectively. The amended query now correctly filters for the most recent laboratory records while applying the appropriate gender-specific UA thresholds, matching the right SQL's behavior.",
            "Do remove the subquery correlation `WHERE ID = T1.ID` from the `MAX(Date)` subquery instead of keeping it correlated to filter by patient ID. Do change the WHERE clause structure to use `(T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')` instead of the original grouping with parentheses around the OR conditions. The amended query now correctly calculates the average UA value from the most recent laboratory date across all patients while applying the appropriate gender-based UA thresholds, matching the intended behavior.",
            "Do remove the alias `average_ua` from the `SELECT` list instead of keeping it. Do move the `T2.Date` filter to be part of the main `WHERE` clause conjunction instead of placing it first. Do remove the correlation `WHERE ID = T1.ID` from the subquery's `MAX(Date)` calculation instead of including it, making the subquery uncorrelated to find the global maximum date across all Laboratory records. The amended query now correctly calculates the average UA value for patients meeting sex-specific UA thresholds while considering only laboratory records with the maximum date across the entire Laboratory table, matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the combined filter conditions instead of keeping them, and do move the `T2.Date` filter to be part of the main WHERE clause conjunction instead of separating it as an additional condition. The amended query now correctly applies all filters including the date condition to calculate the average UA values for patients based on their sex-specific thresholds while considering only the most recent laboratory results.",
            "Do remove the parentheses around the combined `OR` condition instead of keeping them, and do move the `T2.Date` filter to be part of the main `WHERE` clause conjunction instead of placing it before the gender-specific conditions. Do maintain the same `SELECT AVG(T2.UA)` aggregation, `FROM Patient` and `INNER JOIN Laboratory` with `ON T1.ID = T2.ID` join predicate, and the subquery `(SELECT MAX(Date) FROM Laboratory)` unchanged. The amended query now correctly combines all filter conditions in the proper logical order without unnecessary grouping parentheses, matching the RIGHT_SQL's behavior.",
            "Do maintain the same `SELECT AVG(T2.UA)` clause instead of changing it. Do keep the same `FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID` structure instead of modifying it. Do move the `T2.Date = (SELECT MAX(Date) FROM Laboratory)` filter to the end of the WHERE clause instead of placing it at the beginning, while maintaining the same logical AND relationship with the gender-specific UA threshold conditions. Do preserve the exact same conditional logic `(T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')` instead of altering it. The amended query now correctly maintains all the same filtering logic and join conditions while only adjusting the predicate ordering within the WHERE clause, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"patients with normal uric acid (UA)\": filter laboratory_examinations where UA meets gender-specific thresholds without parentheses grouping. 2) When calculating average UA index based on latest examination result: use AVG(UA) and ensure the most recent result is selected by ordering by examination_date DESC and taking the first result. 3) When combining filter conditions: move all conditions including T2.Date filter to the main WHERE clause conjunction without separate conditions.",
            "1) When answering about patients with normal uric acid: filter laboratory results where T2.UA < 6.5 for female patients (T1.SEX = 'F') or T2.UA < 8.0 for male patients (T1.SEX = 'M'). 2) When finding the latest laboratory examination result: compare T2.Date to the maximum date in the Laboratory table to ensure only the most recent results are considered. 3) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner join to match patients with their laboratory records. 4) When calculating average UA index: compute AVG(T2.UA) across all matching records without grouping by individual patients. 5) When handling table aliases: use T1 for Patient table and T2 for Laboratory table as specified in the amends.",
            "1) When answering about patients with normal uric acid (UA): use gender-specific UA thresholds where female patients (T1.SEX = 'F') must have UA < 6.5 and male patients (T1.SEX = 'M') must have UA < 8.0. 2) When finding the latest laboratory examination result: for each patient, use the maximum Date from the Laboratory table without correlating the subquery to filter by patient ID. 3) When calculating average UA index: compute AVG(T2.UA) from the Laboratory table using the most recent results that meet the normal UA criteria.",
            "1) When answering about \"average UA index for patients with normal uric acid\": make sure the output order: AVG(T2.UA). 2) When the question mentions \"latest laboratory examination result\": use the global maximum date across all Laboratory records instead of per-patient maximum. 3) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When filtering for normal uric acid levels: apply sex-specific thresholds where (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'). 5) When selecting laboratory records: include only those with T2.Date equal to the maximum date across all Laboratory records.",
            "1) When answering about patients with normal uric acid (UA): use sex-specific thresholds where female patients (T1.SEX = 'F') must have UA < 6.5 and male patients (T1.SEX = 'M') must have UA < 8.0. 2) When calculating average UA based on latest laboratory examination: ensure T2.Date equals the maximum date from the Laboratory table to get the most recent results. 3) When combining filter conditions: apply all conditions including date filter and sex-specific UA thresholds together in the WHERE clause without additional parentheses around the combined conditions. 4) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID to match patient records with their laboratory results.",
            "1) When answering about \"average UA index for patients with normal uric acid\": make sure the output order: AVG(T2.UA) 2) When combining Patient table as T1 and Laboratory table as T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match) 3) When filtering for the latest laboratory examination result: include only rows where T2.Date equals the maximum Date from the Laboratory table 4) When defining normal uric acid levels: apply gender-specific conditions where for female patients (T1.SEX = 'F'), UA must be less than 6.5, and for male patients (T1.SEX = 'M'), UA must be less than 8.0 5) When structuring filter conditions: combine the date filter and gender-specific UA conditions in the main WHERE clause without unnecessary grouping parentheses around the OR condition",
            "1) When answering about average UA index for patients with normal uric acid: make sure the output order: average_ua\n2) When combining Patient T1 and Laboratory T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match).\n3) When filtering for latest laboratory examination result: include only rows where T2.Date equals the maximum Date from Laboratory.\n4) When determining normal uric acid levels: use the exact conditional logic (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') with exact literals 'F' and 'M'.\n5) When computing the average UA: calculate AVG(T2.UA) for the filtered results."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(UA) FROM laboratory_examinations WHERE UA = 'normal' ORDER BY examination_date DESC LIMIT 1;",
            "SELECT AVG(T2.UA) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = T2.ID)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory) \nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(lab.UA) as average_ua\nFROM Laboratory lab\nINNER JOIN (\n    SELECT ID, MAX(Date) as latest_date\n    FROM Laboratory\n    GROUP BY ID\n) latest ON lab.ID = latest.ID AND lab.Date = latest.latest_date\nINNER JOIN Patient p ON lab.ID = p.ID\nWHERE (p.SEX = 'Male' AND lab.UA <= 7.0) OR (p.SEX = 'Female' AND lab.UA <= 6.0)",
            "SELECT AVG(T2.UA) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = T1.ID)\nAND (\n    (T1.SEX = 'M' AND T2.UA < 8.0) OR \n    (T1.SEX = 'F' AND T2.UA < 6.5)\n)",
            "SELECT AVG(T2.UA) AS average_ua\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory WHERE ID = T1.ID)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))",
            "SELECT AVG(T2.UA)\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')\nAND T2.Date = (SELECT MAX(Date) FROM Laboratory)"
        ],
        "rule_sql": [
            "SELECT AVG(T2.UA) AS average_ua\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date = (SELECT MAX(Date) FROM Laboratory)\nAND ((T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M'))"
        ],
        "amend_res": 1
    },
    "668": {
        "db_id": "codebase_community",
        "question": "What is the display name of the user who acquired the highest amount of badges?",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "amends": [
            "Do add `INNER JOIN badges AS T2 ON T1.Id = T2.UserId` instead of querying only the `users` table. Do change the SELECT clause to `T1.DisplayName` instead of `display_name` and add table alias `T1`. Do add `GROUP BY T1.DisplayName` instead of omitting grouping. Do change the ORDER BY to `COUNT(T1.Id) DESC` instead of `badge_count DESC` to count actual badge relationships. The amended query now correctly joins the badges table to count user badges and returns the user with the most badges, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"user who acquired the highest amount of badges\": make sure the output order: T1.DisplayName. 2) When the question mentions \"highest amount of badges\": count the number of badges per user using COUNT(T1.Id) and order in descending direction to find the maximum. 3) When combining users and badges tables: link rows where T1.Id = T2.UserId and keep only matching pairs (inner match). 4) When grouping by user: organize results by T1.DisplayName and compute the badge count per group. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users ORDER BY badge_count DESC LIMIT 1;",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN badges AS T2 ON T1.Id = T2.UserId\nGROUP BY T1.DisplayName\nORDER BY COUNT(T1.Id) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM users u\nINNER JOIN badges b ON u.Id = b.UserId\nGROUP BY u.DisplayName\nORDER BY COUNT(b.Id) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1141": {
        "db_id": "european_football_2",
        "question": "Does the KSV Cercle Brugge team have a slow, balanced or fast speed class?",
        "ground_truth": "SELECT DISTINCT t1.buildUpPlaySpeedClass FROM Team_Attributes AS t1 INNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.team_long_name = 'KSV Cercle Brugge'",
        "amends": [
            "Do select `t1.buildUpPlaySpeedClass` instead of `speed_class`. Do add `DISTINCT` instead of omitting it. Do use `Team_Attributes AS t1` and `Team AS t2` as sources instead of `teams`. Do add `INNER JOIN` on `t1.team_api_id = t2.team_api_id` instead of no join. Do filter on `t2.team_long_name = 'KSV Cercle Brugge'` instead of `team_name = 'KSV Cercle Brugge'`. The amended query now correctly retrieves the build-up play speed class from the normalized schema with proper table joins."
        ],
        "rules": [
            "1) When the question asks about a team's speed class: use \"t1.buildUpPlaySpeedClass\" instead of \"speed_class\" as the output column. 2) When retrieving values that may have duplicates: use DISTINCT to return only unique values. 3) When combining team attributes and team information: use Team_Attributes AS t1 and Team AS t2 as sources with an INNER JOIN on t1.team_api_id = t2.team_api_id. 4) When filtering for a specific team by name: use t2.team_long_name = 'KSV Cercle Brugge' instead of team_name = 'KSV Cercle Brugge'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT speed_class FROM teams WHERE team_name = 'KSV Cercle Brugge';",
            "SELECT DISTINCT t1.buildUpPlaySpeedClass \nFROM Team_Attributes AS t1 \nINNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t2.team_long_name = 'KSV Cercle Brugge'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.buildUpPlaySpeedClass \nFROM Team_Attributes AS t1 \nINNER JOIN Team AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t2.team_long_name = 'KSV Cercle Brugge'"
        ],
        "amend_res": 1
    },
    "602": {
        "db_id": "codebase_community",
        "question": "List out all post ID with score more than 60 and list out all the user ID that created these post.",
        "ground_truth": "SELECT PostId, UserId FROM postHistory WHERE PostId IN ( SELECT Id FROM posts WHERE Score > 60 )",
        "amends": [
            "Do select `PostId` and `UserId` instead of `post_id` and `user_id`. Do query from `postHistory` table instead of `posts` table. Do use a subquery filter with `PostId IN (SELECT Id FROM posts WHERE Score > 60)` instead of a direct `WHERE score > 60` filter. Do reference `Score` instead of `score` and `Id` instead of omitting it in the subquery. The amended query now correctly retrieves user history data from postHistory table filtered by posts meeting the score threshold, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"post ID\" and \"user ID\": use the exact column tokens \"PostId\" and \"UserId\" from the postHistory table. 2) When filtering posts by score greater than 60: use a subquery that selects \"Id\" from the posts table where \"Score\" > 60, then filter postHistory records where \"PostId\" matches those IDs. 3) When querying from the postHistory table: use the postHistory table as the main data source instead of the posts table. 4) When referencing score values: use the exact column name \"Score\" (not \"score\") from the posts table. 5) When referencing post identifiers: use \"Id\" as the key column in the posts table for the subquery filter."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT post_id, user_id FROM posts WHERE score > 60",
            "SELECT PostId, UserId FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Score > 60)"
        ],
        "rule_sql": [
            "SELECT PostId, UserId FROM postHistory WHERE PostId IN (SELECT Id FROM posts WHERE Score > 60)"
        ],
        "amend_res": 1
    },
    "1160": {
        "db_id": "thrombosis_prediction",
        "question": "What is the percentage of female patient had total protein not within the normal range?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F'",
        "amends": [
            "Do use `SUM(CASE...ELSE 0 END)` instead of `COUNT(CASE...END)` for conditional counting. Do reference `T2.TP` column instead of `tp.value` for total protein values. Do change the upper threshold to `8.5` instead of `8.3`. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `p.patient_id = tp.patient_id`. Do filter by `T1.SEX = 'F'` in the `WHERE` clause instead of filtering females only in conditional expressions. Do cast the sum to `REAL` instead of using decimal notation. Do divide by `COUNT(*)` instead of counting only female cases. Do use table aliases `T1` and `T2` instead of `p` and `tp`. Do reference `SEX` and `TP` columns instead of `gender` and `test_name`. The amended query now correctly calculates the percentage of female patients with abnormal total protein values using proper conditional aggregation and join logic.",
            "Do move the `T1.SEX = 'F'` filter from the WHERE clause into the CASE WHEN condition instead of keeping it separate, and change the TP threshold from `6.3` to `6.0` instead of using the higher value. Do use integer division with `* 100 / COUNT(*)` instead of floating-point division with `/ COUNT(*)) * 100.0`, and remove the column alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage of female patients with TP values outside the 6.0-8.5 range, matching the RIGHT_SQL's behavior.",
            "Do add `CAST(... AS REAL)` around the sum calculation instead of omitting explicit casting. Do move the `T1.SEX = 'F'` filter from the `WHERE` clause into the `CASE` statement condition instead of keeping it separate, combining it with the `T2.TP` range check as `T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5)`. Do add explicit `AS` aliases for table names instead of omitting them. The amended query now correctly calculates the percentage of female patients with abnormal TP values while maintaining the same join logic and filtering approach.",
            "Do add a WHERE clause with `T1.SEX = 'F'` instead of omitting it, which correctly filters the count to only female patients before calculating the percentage instead of including all patients in the denominator. The amended query now matches RIGHT_SQL's behavior by properly calculating the percentage of female patients with abnormal TP values among all female patients rather than among all patients."
        ],
        "rules": [
            "1) When calculating percentages with conditional counting: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN END). 2) When referencing total protein values: use column T2.TP instead of tp.value. 3) When defining the normal range for total protein: use upper threshold 8.5 instead of 8.3. 4) When joining patients and lab_tests tables: use INNER JOIN on T1.ID = T2.ID instead of p.patient_id = tp.patient_id. 5) When filtering for female patients: use T1.SEX = 'F' in the WHERE clause instead of filtering within conditional expressions. 6) When casting numeric results: use REAL type instead of decimal notation. 7) When calculating denominator for percentages: divide by COUNT(*) instead of counting only specific cases. 8) When using table aliases: use T1 for patients table and T2 for lab_tests table. 9) When referencing gender information: use column T1.SEX instead of gender. 10) When referencing test values: use column T2.TP instead of test_name.",
            "1) When the question asks about female patients: filter for patients where T1.SEX equals exactly 'F' (case-sensitive). 2) When calculating percentage of patients with total protein outside normal range: use the exact threshold values of 6.0 for lower bound and 8.5 for upper bound (TP < 6.0 OR TP > 8.5). 3) When computing percentage: use integer division by multiplying the count of matching cases by 100 and then dividing by the total count of female patients. 4) When combining Patient and Laboratory tables: link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner join). 5) When the query does not require column aliases: omit any output column naming.",
            "1) When calculating percentages that involve division: use explicit casting to REAL type around the numerator to ensure decimal division instead of integer division. 2) When filtering conditions need to be combined with aggregate calculations: include the filter condition (T1.SEX = 'F') directly within the CASE statement condition rather than applying it separately in a WHERE clause. 3) When checking for values outside a normal range (6.0 to 8.5): use the condition (T2.TP < 6.0 OR T2.TP > 8.5) to identify abnormal values. 4) When joining Patient and Laboratory tables: use the exact key equality T1.ID = T2.ID to link patient records with their laboratory results. 5) When computing percentage of female patients with abnormal total protein: calculate as (count of female patients with TP outside 6.0-8.5 range) divided by (total count of female patients) multiplied by 100.",
            "1) When answering about \"percentage of female patient had total protein not within the normal range\": make sure the output order: percentage calculation\n2) When the question mentions \"female patient\": \"female\" actually means \"SEX = 'F'\" in schema\n3) When the question asks for \"percentage of female patients with abnormal TP values\": compute (number of female patients with T2.TP < 6.0 OR T2.TP > 8.5) divided by (total number of female patients), guarding division by zero\n4) When combining Patient as T1 and Laboratory as T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)\n5) When filtering for female patients: apply T1.SEX = 'F' condition to both numerator and denominator counts\n6) When handling text literals: use exact value 'F' for female patients without changing case or punctuation\n7) When calculating percentage: multiply the ratio by 100 to convert to percentage format"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.gender = 'F' AND (tp.value < 6.0 OR tp.value > 8.3) THEN 1 END) * 100.0 / COUNT(CASE WHEN p.gender = 'F' THEN 1 END)) AS percentage\nFROM patients p\nJOIN lab_tests tp ON p.patient_id = tp.patient_id\nWHERE tp.test_name = 'Total Protein';",
            "SELECT \n    (CAST(SUM(CASE WHEN T2.TP < 6.3 OR T2.TP > 8.5 THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100.0 AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'",
            "SELECT \n    (SUM(CASE WHEN T2.TP < 6.0 OR T2.TP > 8.5 THEN 1 ELSE 0 END) * 100 / COUNT(*)) \nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F'",
            "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
            "SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.TP < 6.0 OR T2.TP > 8.5) THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) AS percentage\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T2.TP < 6.0 OR T2.TP > 8.5 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Patient T1\nINNER JOIN \n    Laboratory T2 ON T1.ID = T2.ID\nWHERE \n    T1.SEX = 'F';"
        ],
        "amend_res": 1
    },
    "573": {
        "db_id": "codebase_community",
        "question": "Write the contents of comments with a score of 17.",
        "ground_truth": "SELECT Text FROM comments WHERE Score = 17",
        "amends": [
            "Do specify `Text` in the SELECT list instead of using `*` to select all columns. Do use proper case sensitivity for the column name `Score` instead of lowercase `score` in the WHERE clause. The amended query now correctly retrieves only the Text column from comments where Score equals 17, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"comments with a score of 17\": make sure the output order: Text. 2) When the question mentions \"comments\": \"comments\" actually means \"posts\" in schema. 3) When filtering for score value 17: use exact literal 17 and exact column name \"Score\" with proper case sensitivity. 4) When selecting columns: specify only the \"Text\" column instead of using wildcard selection."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM comments WHERE score = 17;",
            "SELECT Text FROM comments WHERE Score = 17;"
        ],
        "rule_sql": [
            "SELECT Text FROM posts WHERE Score = 17 ORDER BY Text;"
        ],
        "amend_res": 1
    },
    "933": {
        "db_id": "formula_1",
        "question": "What was Lewis Hamilton's final rank in the 2008 Chinese Grand Prix?",
        "ground_truth": "SELECT T2.positionOrder FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T1.name = 'Chinese Grand Prix' AND T1.year = 2008",
        "amends": [
            "Do join `races AS T1`, `results AS T2`, and `drivers AS T3` instead of querying a single `race_results` table. Do use `T2.positionOrder` instead of `position` for the result column. Do join `T2.raceId = T1.raceId` and `T3.driverId = T2.driverId` instead of direct name matching. Do filter with `T3.forename = 'Lewis' AND T3.surname = 'Hamilton'` instead of `driver_name = 'Lewis Hamilton'`. Do filter with `T1.name = 'Chinese Grand Prix' AND T1.year = 2008` instead of `race_name = '2008 Chinese Grand Prix'` to properly separate year from race name. The amended query now correctly joins normalized tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about a driver's final rank in a specific race: join races AS T1, results AS T2, and drivers AS T3 using T2.raceId = T1.raceId and T3.driverId = T2.driverId. 2) When the question mentions \"Lewis Hamilton\": use T3.forename = 'Lewis' AND T3.surname = 'Hamilton' for filtering. 3) When the question mentions \"2008 Chinese Grand Prix\": use T1.name = 'Chinese Grand Prix' AND T1.year = 2008 for filtering. 4) When the question asks for final rank: use T2.positionOrder instead of position for the result column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM race_results WHERE driver_name = 'Lewis Hamilton' AND race_name = '2008 Chinese Grand Prix';",
            "SELECT T2.positionOrder AS final_rank\nFROM races AS T1\nJOIN results AS T2 ON T1.raceId = T2.raceId\nJOIN drivers AS T3 ON T2.driverId = T3.driverId\nWHERE T3.forename = 'Lewis' \nAND T3.surname = 'Hamilton'\nAND T1.name = 'Chinese Grand Prix' \nAND T1.year = 2008;"
        ],
        "rule_sql": [
            "SELECT T2.positionOrder AS final_rank\nFROM races AS T1\nJOIN results AS T2 ON T2.raceId = T1.raceId\nJOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\nAND T1.name = 'Chinese Grand Prix' AND T1.year = 2008;"
        ],
        "amend_res": 1
    },
    "1434": {
        "db_id": "student_club",
        "question": "What are the zip codes that have post office boxes in the country of the country of San Juan Municipio whose state is Puerto Rico?",
        "ground_truth": "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico'",
        "amends": [
            "Do query the `zip_code` table instead of the `post_offices` table. Do filter on `type = 'PO Box'` instead of `has_po_boxes = 1`. Do filter on `county = 'San Juan Municipio'` instead of `city = 'San Juan'`. The amended query now correctly retrieves PO Box zip codes from the appropriate table with accurate geographic filtering."
        ],
        "rules": [
            "1) When answering about zip codes with post office boxes: query the \"zip_code\" table instead of the \"post_offices\" table. 2) When filtering for post office boxes: use \"type = 'PO Box'\" instead of \"has_po_boxes = 1\". 3) When filtering for geographic location: use \"county = 'San Juan Municipio'\" instead of \"city = 'San Juan'\". 4) When the question mentions \"state is Puerto Rico\": include \"state = 'Puerto Rico'\" as a filter condition. 5) When selecting output columns: return the \"zip_code\" column from the \"zip_code\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM post_offices WHERE city = 'San Juan' AND state = 'Puerto Rico' AND has_po_boxes = 1;",
            "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico';"
        ],
        "rule_sql": [
            "SELECT zip_code FROM zip_code WHERE type = 'PO Box' AND county = 'San Juan Municipio' AND state = 'Puerto Rico'"
        ],
        "amend_res": 1
    },
    "1499": {
        "db_id": "debit_card_specializing",
        "question": "What is the biggest monthly consumption of the customers who use euro as their currency?",
        "ground_truth": "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' GROUP BY T1.CustomerID ORDER BY MonthlyConsumption DESC LIMIT 1",
        "amends": [
            "Do use `SUM(T2.Consumption) / 12 AS MonthlyConsumption` instead of `MAX(monthly_consumption)` to calculate average monthly consumption. Do add `FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` instead of only querying the customers table to join with yearmonth data. Do change the filter to `T1.Currency = 'EUR'` instead of `currency = 'euro'` for proper currency code. Do add `GROUP BY T1.CustomerID` instead of omitting grouping to get per-customer results. Do add `ORDER BY MonthlyConsumption DESC LIMIT 1` instead of using MAX() aggregate to find the highest monthly consumption value. The amended query now correctly calculates average monthly consumption per customer and identifies the maximum value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating monthly consumption for customers: compute SUM(T2.Consumption) / 12 AS MonthlyConsumption to get average monthly consumption. 2) When combining customer and yearmonth data: link rows using T1.CustomerID = T2.CustomerID with an inner match. 3) When filtering by currency: use T1.Currency = 'EUR' exactly as specified, not 'euro'. 4) When analyzing consumption per customer: group results by T1.CustomerID to get individual customer metrics. 5) When finding the biggest monthly consumption: order results by MonthlyConsumption DESC and take only the top 1 result."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT MAX(monthly_consumption) FROM customers WHERE currency = 'euro';",
            "SELECT SUM(T2.Consumption) / 12 AS MonthlyConsumption\nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'\nGROUP BY T1.CustomerID\nORDER BY MonthlyConsumption DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT \n    T1.CustomerID,\n    SUM(T2.Consumption) / 12 AS MonthlyConsumption\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'EUR'\nGROUP BY \n    T1.CustomerID\nORDER BY \n    MonthlyConsumption DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1032": {
        "db_id": "european_football_2",
        "question": "Give the name of the league with the highest matches of all time and how many matches were played in the said league.",
        "ground_truth": "SELECT t2.name, t1.max_count FROM League AS t2 JOIN (SELECT league_id, MAX(cnt) AS max_count FROM (SELECT league_id, COUNT(id) AS cnt FROM Match GROUP BY league_id) AS subquery) AS t1 ON t1.league_id = t2.id",
        "amends": [
            "Do select `t2.name` and `t1.max_count` instead of `league_name` and `COUNT(*) as total_matches`. Do join `League AS t2` with a subquery instead of querying only `matches`. Do use a subquery to find the maximum match count per league instead of counting all matches. Do group by `league_id` in the inner subquery instead of grouping by `league_name`. Do join on `t1.league_id = t2.id` instead of directly using league names. Do remove `ORDER BY total_matches DESC LIMIT 1` instead of keeping it, as the maximum value is now calculated in the subquery. The amended query now correctly identifies the league with the maximum number of matches by calculating the maximum count per league and joining with the league table.",
            "Do use `MAX(cnt)` instead of `COUNT(*)` in the outer subquery to properly identify the maximum match count. Do reference `COUNT(id)` as `cnt` instead of `COUNT(*)` in the inner subquery for explicit counting. Do remove the unnecessary `HAVING` clause with nested subquery instead of keeping the complex filtering logic. Do simplify the subquery structure by eliminating the redundant comparison subquery instead of maintaining the nested maximum calculation. Do use `JOIN` without explicit `AS` keyword for table aliases instead of including `AS` in the join syntax. The amended query now correctly identifies leagues with maximum matches using proper aggregation and eliminates unnecessary subquery nesting.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an additional nesting level instead of using a window function. Do reference the aggregated `cnt` column instead of attempting to use `COUNT(id)` within the window function. Do simplify the join syntax by using `JOIN` without explicit type instead of the previous join structure. Do remove the `WHERE t1.cnt = t1.max_count` filter condition instead of keeping it, as the logic now correctly identifies the maximum count through aggregation. The amended query now correctly finds leagues with the maximum match count by using proper aggregation instead of window functions.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an additional nesting level instead of using a window function. Do reference `cnt` from the inner subquery instead of recalculating `COUNT(id)` in the window function. Do use `JOIN` syntax without specifying the type instead of explicit `JOIN` which defaults to INNER JOIN. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it since the join condition already handles the matching logic. The amended query now correctly identifies leagues with the maximum match count by calculating the maximum value separately and then joining to find matching leagues.",
            "Do use a single subquery with `MAX(cnt)` calculated directly on the grouped results instead of creating a separate subquery to find the maximum count. Do join `League` directly with the subquery containing both `league_id` and `max_count` instead of joining through an intermediate table. Do use `ON t1.league_id = t2.id` for the join condition instead of the complex multi-join structure. Do remove the unnecessary join between the grouped results and maximum count subquery since the maximum calculation can be done within the same subquery. The amended query now correctly identifies leagues with their maximum match counts by properly aggregating and joining in a single streamlined operation.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it since the join condition already handles the relationship. Do use a simpler join structure without the window function and additional filtering instead of the more complex window function approach. The amended query now correctly identifies leagues with the maximum match count by using aggregate functions rather than window functions.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` as a window function. Do restructure the nested subqueries to have an intermediate grouping with `COUNT(id) AS cnt` and then apply `MAX(cnt)` in the outer subquery instead of using a window function over the grouped results. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the logic now correctly identifies the maximum count through aggregation. Do simplify the join structure by directly joining the League table with the aggregated subquery results instead of using a window function approach. The amended query now correctly finds the league with the maximum match count by using proper aggregation nesting instead of window functions with equality filtering.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do change the join order to `FROM League AS t2 JOIN` instead of starting with the derived table. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it since the maximum value is already calculated in the subquery. The amended query now correctly identifies leagues with the maximum match count by calculating the aggregate maximum rather than using window function comparison.",
            "Do use `MAX(cnt) AS max_count` in the outer subquery instead of `COUNT(id) AS cnt` and then filtering with a subquery. Do restructure the query to join `League` with a subquery that calculates the maximum count per league instead of joining first and then filtering. Do remove the redundant `WHERE` clause that used a subquery to find the maximum count instead of calculating it directly in the subquery. Do change the join order to `JOIN League AS t2` instead of starting with the subquery. Do simplify the column aliases to `t2.name` and `t1.max_count` instead of `t2.name AS league_name` and `t1.cnt AS total_matches`. The amended query now correctly identifies leagues with their maximum match counts by calculating the maximum directly in the subquery rather than using a filtering approach.",
            "Do use `MAX(cnt)` as an aggregate instead of `MAX(COUNT(id)) OVER ()` as a window function. Do move the maximum count calculation to an outer subquery instead of computing it within the same level as the grouping. Do restructure the subquery nesting with an intermediate `subquery` that computes `COUNT(id)` grouped by `league_id` instead of trying to compute both the count and maximum in a single query level. Do simplify the join condition to use `t1.league_id = t2.id` instead of the same correct condition. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it since the maximum calculation is now handled in the subquery structure. The amended query now correctly identifies leagues with maximum match counts by properly aggregating the counts first before finding the maximum value.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across leagues. Do restructure the subquery hierarchy with an additional nesting level instead of using a window function. Do reference the aggregated `cnt` column instead of recalculating `COUNT(id)` in the window function. Do simplify the join syntax by using `JOIN League AS t2` directly instead of the `FROM (...) JOIN League AS t2` structure. Do remove the `WHERE t1.cnt = t1.max_count` filter entirely instead of keeping it, as the logic now correctly identifies the league with maximum matches through the subquery structure. The amended query now correctly finds the league with the highest number of matches by using proper aggregation instead of window functions.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an additional nested level instead of a single subquery with a window function. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the join condition already handles the matching logic. Do simplify the query by eliminating the window function and replacing it with a scalar aggregation. The amended query now correctly identifies leagues with the maximum match count by using proper aggregation rather than window function comparison.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do simplify the join by removing the `WHERE t1.cnt = t1.max_count` filter and instead calculate the maximum count in the subquery structure. Do maintain the same `JOIN` between `League` and the subquery on `league_id = id` but with the corrected subquery logic. The amended query now correctly identifies leagues with match counts equal to the maximum count across all leagues.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do simplify the join by removing the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the restructured query directly provides the maximum count per league. The amended query now correctly identifies leagues with match counts equal to the maximum count across all leagues.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the join condition already handles the matching logic. Do simplify the query structure by eliminating the window function and instead using aggregate `MAX()` on the pre-calculated counts. The amended query now correctly identifies leagues with the maximum match count by using proper aggregation rather than window function comparison.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an additional nesting level instead of using a window function. Do reference the aggregated `cnt` column instead of attempting to use `COUNT(id)` within the window function. Do simplify the join condition to `ON t1.league_id = t2.id` instead of the previous approach. Do remove the `WHERE t1.cnt = t1.max_count` filter entirely instead of keeping it, as the logic now correctly identifies the maximum count through aggregation. The amended query now correctly finds the league with the maximum match count by using proper aggregation techniques instead of window functions with grouping conflicts.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the join condition already handles the matching logic. Do simplify the SELECT clause to only include `t2.name` and `t1.max_count` instead of the previous structure. The amended query now correctly identifies leagues with the maximum match count by using aggregate functions rather than window functions.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an additional nesting level instead of using a window function. Do reference the aggregated `cnt` column instead of re-aggregating with `COUNT(id)` in the window function. Do use a simple `JOIN` without specifying the type instead of an explicit `INNER JOIN`. The amended query now correctly identifies leagues with the maximum match count by properly aggregating and finding the maximum value across groups.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the join condition and subquery structure now correctly identify the league with maximum matches. Do use `JOIN` without specifying `INNER` instead of explicit `JOIN` syntax, though both represent inner joins. The amended query now correctly finds the league(s) with the maximum number of matches by using aggregate maximum rather than window function comparison.",
            "Do use `MAX(cnt)` in the outer subquery instead of `MAX(COUNT(id)) OVER ()` to find the maximum count across all leagues. Do restructure the subquery hierarchy with an intermediate `subquery` that calculates `COUNT(id)` grouped by `league_id` instead of using a window function. Do remove the `WHERE t1.cnt = t1.max_count` filter instead of keeping it, as the join condition already ensures correct matching. Do simplify the query by eliminating the window function and instead calculating the maximum count in the outer subquery. The amended query now correctly identifies leagues with the maximum match count by using aggregate functions instead of window functions."
        ],
        "rules": [
            " league with highest matches of all time refers to MAX(COUNT(league_id));"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT league_name, COUNT(*) as total_matches \nFROM matches \nGROUP BY league_name \nORDER BY total_matches DESC \nLIMIT 1;",
            "SELECT t2.name AS league_name, t1.max_count AS total_matches\nFROM (\n    SELECT league_id, COUNT(*) AS max_count\n    FROM Match\n    GROUP BY league_id\n    HAVING COUNT(*) = (\n        SELECT MAX(match_count)\n        FROM (\n            SELECT league_id, COUNT(*) AS match_count\n            FROM Match\n            GROUP BY league_id\n        )\n    )\n) AS t1\nJOIN League AS t2 ON t1.league_id = t2.id;",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt\n    FROM Match\n    GROUP BY league_id\n) AS t1\nJOIN (\n    SELECT MAX(cnt) AS max_count\n    FROM (\n        SELECT league_id, COUNT(id) AS cnt\n        FROM Match\n        GROUP BY league_id\n    )\n) AS t3 ON t1.cnt = t3.max_count\nJOIN League AS t2 ON t1.league_id = t2.id",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name AS league_name, t1.cnt AS total_matches\nFROM (\n    SELECT league_id, COUNT(id) AS cnt\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = (\n    SELECT MAX(cnt)\n    FROM (\n        SELECT league_id, COUNT(id) AS cnt\n        FROM Match\n        GROUP BY league_id\n    )\n)",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) AS t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count",
            "SELECT t2.name, t1.max_count\nFROM (\n    SELECT league_id, COUNT(id) AS cnt, MAX(COUNT(id)) OVER () AS max_count\n    FROM Match\n    GROUP BY league_id\n) t1\nJOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.cnt = t1.max_count"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "667": {
        "db_id": "codebase_community",
        "question": "What is the title of the post with the oldest post link?",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1",
        "amends": [
            "Do add `INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id` instead of querying only the `posts` table. Do change the column selection to `T1.Title` instead of `title` and add table alias `T1` for the posts table. Do change the ORDER BY clause to `T1.CreationDate` instead of `post_link ASC` to sort by creation date rather than a link field. The amended query now correctly joins the posts and postLinks tables and orders by creation date to match the RIGHT_SQL's behavior.",
            "Do correct the column name `T1.CreationDate` to `T1.CreaionDate` instead of using the misspelled version. Do remove the `ASC` keyword from the `ORDER BY` clause instead of keeping it, as the default ascending order is sufficient. The amended query now matches RIGHT_SQL's behavior with the corrected column reference and simplified ordering."
        ],
        "rules": [
            "1) When answering about \"the title of the post with the oldest post link\": make sure the output order: T1.Title. 2) When combining posts table (T1) and postLinks table (T2): link rows where T2.PostId = T1.Id exactly as shown; keep only matching pairs (inner match). 3) When the question mentions \"oldest\": sort rows by T1.CreationDate in ascending order and keep the first 1 row.",
            "1) When the question asks for the \"oldest post link\": order by the exact column \"T1.CreaionDate\" in ascending order (oldest first) instead of the misspelled \"T1.CreationDate\". 2) When ordering by date to find the oldest: do not include the \"ASC\" keyword as ascending order is the default behavior. 3) When answering about the title of the post with the oldest post link: make sure the output order includes only \"T1.Title\" as the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts ORDER BY post_link ASC LIMIT 1;",
            "SELECT T1.Title \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T2.PostId = T1.Id \nORDER BY T1.CreationDate ASC \nLIMIT 1",
            "SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Title FROM posts T1 INNER JOIN postLinks T2 ON T2.PostId = T1.Id ORDER BY T1.CreaionDate LIMIT 1"
        ],
        "amend_res": 1
    },
    "585": {
        "db_id": "codebase_community",
        "question": "How much is the total bounty amount of the post titled about 'data'",
        "ground_truth": "SELECT SUM(T2.BountyAmount) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data%'",
        "amends": [
            "Do reference `SUM(T2.BountyAmount)` from the votes table instead of `SUM(bounty_amount)` from the posts table. Do add `INNER JOIN votes AS T2 ON T1.Id = T2.PostId` to connect the posts and votes tables instead of querying only the posts table. Do use table aliases `T1` and `T2` for clarity instead of no aliases. Do filter on `T1.Title LIKE '%data%'` with proper table qualification instead of just `title`. The amended query now correctly aggregates bounty amounts from the votes table for posts matching the title filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total bounty amount of posts titled about 'data'\": make sure to sum T2.BountyAmount from the votes table instead of bounty_amount from the posts table. 2) When combining posts and votes tables: link rows where T1.Id = T2.PostId and keep only matching pairs (inner match). 3) When filtering posts by title containing 'data': use T1.Title LIKE '%data%' with exact case and spacing. 4) When using table aliases: refer to posts as T1 and votes as T2 as established in the join condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(bounty_amount) FROM posts WHERE title LIKE '%data%';",
            "SELECT SUM(T2.BountyAmount) AS total_bounty_amount\nFROM posts AS T1\nINNER JOIN votes AS T2 ON T1.Id = T2.PostId\nWHERE T1.Title LIKE '%data%'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.BountyAmount) AS total_bounty_amount\nFROM posts T1\nINNER JOIN votes T2 ON T1.Id = T2.PostId\nWHERE T1.Title LIKE '%data%';"
        ],
        "amend_res": 1
    },
    "33": {
        "db_id": "california_schools",
        "question": "If there are any, what are the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17? Include the name of the school.",
        "evidence": "",
        "ground_truth": "SELECT T2.Website, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000 AND T2.Website IS NOT NULL",
        "amends": [
            "Do select `T2.Website` and `T1.School Name` instead of `school_name` and `website`. Do join `frpm AS T1` and `schools AS T2` with `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter with `T1.Free Meal Count (Ages 5-17) BETWEEN 1900 AND 2000` instead of `free_meal_count = 1900`. Do add `T2.Website IS NOT NULL` instead of omitting it. Do remove `student_age = '5-17'` instead of keeping it since the age range is now properly handled in the meal count column name. The amended query now correctly joins the frpm and schools tables to access both school names and websites while filtering for the appropriate meal count range and ensuring website availability.",
            "Do reorder the SELECT list to place `T2.Website` first instead of `T1.\"School Name\"` first. Do use backticks for `School Name` column quoting instead of double quotes. Do use backticks for `Free Meal Count (Ages 5-17)` column quoting instead of double quotes. The amended query now correctly matches the RIGHT_SQL's behavior with proper column ordering and consistent identifier quoting."
        ],
        "rules": [
            "1) When answering about school websites and names with free meal counts between 1900-2000: select \"T2.Website\" and \"T1.School Name\" as output columns. 2) When combining frpm and schools tables: link rows where \"T1.CDSCode = T2.CDSCode\" using an inner match. 3) When filtering for free meal count range 1900-2000: use \"T1.Free Meal Count (Ages 5-17) BETWEEN 1900 AND 2000\" to include the specified range. 4) When ensuring website availability: add condition \"T2.Website IS NOT NULL\" to exclude schools without websites. 5) When the question mentions \"students aged 5-17\": this is already handled by the column name \"Free Meal Count (Ages 5-17)\" and no separate age filter is needed.",
            "1) When the question asks for website addresses and school names: make sure the output order is Website first, then School Name. 2) When referring to the \"School Name\" column: use backticks for quoting as `School Name` instead of double quotes. 3) When referring to the \"Free Meal Count (Ages 5-17)\" column: use backticks for quoting as `Free Meal Count (Ages 5-17)` instead of double quotes. 4) When combining frpm table (T1) and schools table (T2): link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match). 5) When filtering for free meal count between 1900 and 2000: use the range 1900 to 2000 inclusive for `Free Meal Count (Ages 5-17)`. 6) When selecting website addresses: include only rows where T2.Website is not null."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, website FROM schools WHERE free_meal_count = 1900 AND student_age = '5-17';",
            "SELECT T1.\"School Name\", T2.Website\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL;",
            "SELECT T2.Website, T1.`School Name`\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T2.Website, T1.`School Name`\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000\nAND T2.Website IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1333": {
        "db_id": "student_club",
        "question": "What city and state did the President of the Student_Club grow up?",
        "ground_truth": "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'",
        "amends": [
            "Do select `T2.city` and `T2.state` from the `zip_code` table instead of selecting `city` and `state` directly from `Student_Club`. Do join `member` table as `T1` with `zip_code` table as `T2` using `INNER JOIN` on `T1.zip = T2.zip_code` instead of querying only the `Student_Club` table. Do filter on `T1.position = 'President'` instead of filtering on `position = 'President'` from the original table. The amended query now correctly retrieves city and state information by joining member data with zip code reference data, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for city and state information: select \"T2\".\"city\" and \"T2\".\"state\" from the \"zip_code\" table instead of directly from the \"Student_Club\" table. 2) When combining member and zip code data: join \"member\" table as T1 with \"zip_code\" table as T2 using inner join where \"T1\".\"zip\" equals \"T2\".\"zip_code\". 3) When filtering for the President position: apply the condition \"T1\".\"position\" = 'President' to identify the correct member."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, state FROM Student_Club WHERE position = 'President';",
            "SELECT T2.city, T2.state\nFROM member T1\nINNER JOIN zip_code T2 ON T1.zip = T2.zip_code\nWHERE T1.position = 'President'"
        ],
        "rule_sql": [
            "SELECT T2.city, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.position = 'President'"
        ],
        "amend_res": 1
    },
    "395": {
        "db_id": "card_games",
        "question": "How many cards designed by UDON and available in mtgo print type has a starting maximum hand size of -1?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE hAND = '-1' AND artist = 'UDON' AND Availability = 'mtgo' ",
        "amends": [
            "Do count `id` instead of `*` in the SELECT clause. Do filter on `hAND = '-1'` instead of `starting_max_hand_size = -1` in the WHERE clause. Do filter on `artist = 'UDON'` instead of `designer = 'UDON'` in the WHERE clause. Do filter on `Availability = 'mtgo'` instead of `print_type = 'mtgo'` in the WHERE clause. The amended query now correctly counts cards with the specified artist, availability, and hand size attributes."
        ],
        "rules": [
            "1) When counting cards: count using the canonical key \"id\" instead of counting all columns. 2) When the question mentions \"designed by UDON\": \"designed by\" actually means \"artist = 'UDON'\" in the schema. 3) When the question mentions \"available in mtgo print type\": \"mtgo print type\" actually means \"Availability = 'mtgo'\" in the schema. 4) When the question mentions \"starting maximum hand size of -1\": \"starting maximum hand size\" actually means \"hAND = '-1'\" in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE designer = 'UDON' AND print_type = 'mtgo' AND starting_max_hand_size = -1;",
            "SELECT COUNT(id) FROM cards WHERE artist = 'UDON' AND availability = 'mtgo' AND hand = '-1'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE artist = 'UDON' AND availability = 'mtgo' AND hand = '-1'"
        ],
        "amend_res": 1
    },
    "1106": {
        "db_id": "european_football_2",
        "question": "Tell the defensive work rate for Kevin Berigaud on 2013/2/22.",
        "ground_truth": "SELECT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-02-22' AND t1.player_name = 'Kevin Berigaud'",
        "amends": [
            "Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id` instead of querying a single `players` table. Do reference `t2.defensive_work_rate` instead of `defensive_work_rate` from an unspecified source. Do filter with `t1.player_name = 'Kevin Berigaud'` instead of `name = 'Kevin Berigaud'` to use the correct column name. Do use `SUBSTR(t2.date, 1, 10) = '2013-02-22'` for date comparison instead of `date = '2013/2/22'` to handle the date format properly and match the correct date format. The amended query now correctly joins the necessary tables and handles the date comparison appropriately to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about defensive work rate for a specific player on a specific date: join Player table as T1 with Player_Attributes table as T2 using T1.player_fifa_api_id = T2.player_fifa_api_id to get the correct data. 2) When the question mentions \"Kevin Berigaud\": use T1.player_name = 'Kevin Berigaud' to filter for the exact player name. 3) When the question mentions date \"2013/2/22\": use SUBSTR(T2.date, 1, 10) = '2013-02-22' to handle the date format conversion and comparison. 4) When selecting defensive work rate: reference T2.defensive_work_rate as the correct source column from the Player_Attributes table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT defensive_work_rate FROM players WHERE name = 'Kevin Berigaud' AND date = '2013/2/22';",
            "SELECT t2.defensive_work_rate \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id \nWHERE t1.player_name = 'Kevin Berigaud' \nAND SUBSTR(t2.date, 1, 10) = '2013-02-22'"
        ],
        "rule_sql": [
            "SELECT T2.defensive_work_rate \nFROM Player AS T1 \nJOIN Player_Attributes AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id \nWHERE T1.player_name = 'Kevin Berigaud' \nAND SUBSTR(T2.date, 1, 10) = '2013-02-22'"
        ],
        "amend_res": 1
    },
    "1307": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.RBC <= 3.5 OR T2.RBC >= 6) AND T1.Admission = '-'",
        "amends": [
            "Do use `DISTINCT T1.ID` instead of `patient_id` without distinct. Do join `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `(T2.RBC <= 3.5 OR T2.RBC >= 6)` instead of `red_blood_cell_level = 'abnormal'` to use numeric range comparison. Do add `T1.Admission = '-'` condition instead of `clinic_type = 'outpatient'` to check for outpatient status. Do reference columns from joined tables `T2.RBC` and `T1.Admission` instead of standalone column conditions. The amended query now correctly identifies patients with abnormal RBC levels from laboratory data while filtering for outpatient status."
        ],
        "rules": [
            "1) When answering about patients with abnormal red blood cell levels: use numeric range comparison (T2.RBC <= 3.5 OR T2.RBC >= 6) instead of text equality 'abnormal'. 2) When identifying outpatient clinic status: check for T1.Admission = '-' instead of clinic_type = 'outpatient'. 3) When combining patient and laboratory data: perform an inner join between patients as T1 and Laboratory as T2 on T1.ID = T2.ID. 4) When selecting patient identifiers: use DISTINCT T1.ID to avoid duplicate patient records. 5) When referencing columns from joined tables: always specify the table alias (T2.RBC, T1.Admission) instead of standalone column names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE red_blood_cell_level = 'abnormal' AND clinic_type = 'outpatient';",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RBC <= 3.5 OR T2.RBC >= 6)\nAND T1.Admission = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE (T2.RBC <= 3.5 OR T2.RBC >= 6)\nAND T1.Admission = '-'"
        ],
        "amend_res": 1
    },
    "98": {
        "db_id": "financial",
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "ground_truth": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "amends": [
            "Do select `account_id` from the `account` table instead of selecting `account_id`, `MIN(approved_amount)`, and a literal string from the `loans` table. Do join `account AS T2` with `loan AS T1` using `INNER JOIN` on `T1.account_id = T2.account_id` instead of querying only the `loans` table. Do filter with `STRFTIME('%Y', T1.date) = '1997'` and `T2.frequency = 'POPLATEK TYDNE'` instead of filtering only by year on `approved_date`. Do order by `T1.amount` instead of ordering by `MIN(approved_amount)` aliased as `lowest_amount`. Do remove the `GROUP BY account_id` and aggregation instead of grouping and using `MIN()`. The amended query now correctly joins the loan and account tables, applies proper filters including the frequency condition, and orders by the actual loan amount rather than an aggregated minimum value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about accounts with approved loan date in 1997: use T1.date with STRFTIME('%Y', T1.date) = '1997' instead of approved_date. 2) When the question mentions \"choose weekly issuance statement\": \"weekly\" actually means T2.frequency = 'POPLATEK TYDNE' in schema. 3) When combining loan table T1 and account table T2: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 4) When the question asks for accounts with lowest approved amount: order by T1.amount in ascending direction and keep the first row. 5) When selecting output columns: include account_id from T2 (account table) instead of from T1 (loan table). 6) When producing output: do not use GROUP BY or aggregation functions since we want individual loan records rather than aggregated values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, MIN(approved_amount) as lowest_amount, 'weekly' as issuance_statement\nFROM loans\nWHERE strftime('%Y', approved_date) = '1997'\nGROUP BY account_id\nORDER BY lowest_amount ASC\nLIMIT 1;",
            "SELECT T2.account_id\nFROM account AS T2\nINNER JOIN loan AS T1 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.account_id\nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE STRFTIME('%Y', T1.date) = '1997'\nAND T2.frequency = 'POPLATEK TYDNE'\nORDER BY T1.amount ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "685": {
        "db_id": "codebase_community",
        "question": "Identify the total views on the post 'Computer Game Datasets'. Name the user who posted it last time.",
        "ground_truth": "SELECT T2.ViewCount, T3.DisplayName FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id WHERE T1.Text = 'Computer Game Datasets'",
        "amends": [
            "Do select `T2.ViewCount` and `T3.DisplayName` instead of `SUM(views)` as `total_views` and `username`. Do use `FROM postHistory AS T1` with `INNER JOIN posts AS T2 ON T1.PostId = T2.Id` and `INNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id` instead of just `FROM posts`. Do filter on `T1.Text = 'Computer Game Datasets'` instead of `title = 'Computer Game Datasets'`. Do remove `GROUP BY username`, `ORDER BY posted_date DESC`, and `LIMIT 1` instead of keeping them. The amended query now correctly joins the necessary tables and selects the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total views on the post 'Computer Game Datasets'\": select T2.\"ViewCount\" as total_views instead of SUM(views). 2) When answering about \"the user who posted it last time\": select T3.\"DisplayName\" instead of username. 3) When combining tables for this question: link postHistory as T1 with posts as T2 where T1.\"PostId\" = T2.\"Id\", and link posts as T2 with users as T3 where T2.\"LastEditorUserId\" = T3.\"Id\". 4) When filtering for the post 'Computer Game Datasets': use T1.\"Text\" = 'Computer Game Datasets' instead of title = 'Computer Game Datasets'. 5) When the question does not require grouping or ordering: do not include GROUP BY, ORDER BY, or LIMIT clauses."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(views) as total_views, username \nFROM posts \nWHERE title = 'Computer Game Datasets' \nGROUP BY username \nORDER BY posted_date DESC \nLIMIT 1;",
            "SELECT T2.ViewCount AS total_views, T3.DisplayName \nFROM postHistory AS T1 \nINNER JOIN posts AS T2 ON T1.PostId = T2.Id \nINNER JOIN users AS T3 ON T2.LastEditorUserId = T3.Id \nWHERE T1.Text = 'Computer Game Datasets'"
        ],
        "rule_sql": [
            "SELECT T2.\"ViewCount\" AS total_views, T3.\"DisplayName\" \nFROM postHistory T1 \nJOIN posts T2 ON T1.\"PostId\" = T2.\"Id\" \nJOIN users T3 ON T2.\"LastEditorUserId\" = T3.\"Id\" \nWHERE T1.\"Text\" = 'Computer Game Datasets'"
        ],
        "amend_res": 1
    },
    "499": {
        "db_id": "card_games",
        "question": "How many translations of the name of the set \"Tenth Edition\"?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL",
        "amends": [
            "Do add `DISTINCT T2.translation` in the SELECT list instead of `COUNT(*)` to count unique translations rather than all rows. Do add `INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of querying only the `sets` table to incorporate translation data. Do add `T1.name = 'Tenth Edition'` filter instead of just `name = 'Tenth Edition'` with proper table qualification. Do add `AND T2.translation IS NOT NULL` condition instead of omitting null handling to exclude missing translations. Do change the table reference to `sets AS T1` instead of just `sets` to enable joining. The amended query now correctly counts distinct non-null translations for the specified set name."
        ],
        "rules": [
            "1) When answering about \"translations of the name of the set 'Tenth Edition'\": make sure the output order: count of distinct translations. 2) When the question mentions \"translations\": \"translations\" actually means \"T2.translation in schema\". 3) When the question asks for \"count of translations\": compute the number of unique values of T2.translation. 4) When combining T1 and T2 for shared entities: link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for the set name \"Tenth Edition\": use T1.name = 'Tenth Edition' exactly with the literal 'Tenth Edition'. 6) When handling translation data: exclude null values by adding T2.translation IS NOT NULL condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sets WHERE name = 'Tenth Edition';",
            "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Tenth Edition' AND T2.translation IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.translation) \nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T1.name = 'Tenth Edition' \nAND T2.translation IS NOT NULL"
        ],
        "amend_res": 1
    },
    "151": {
        "db_id": "financial",
        "question": "Please list the name of the districts with accounts that made withdrawal transactions.",
        "ground_truth": "SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `d`, `a`, and `t`. Do select column `T1.A2` instead of `d.name`. Do reference table `district` instead of `districts`. Do reference table `account` instead of `accounts`. Do reference table `trans` instead of `transactions`. Do use explicit `INNER JOIN` instead of implicit `JOIN`. Do filter for `T3.type = 'VYDAJ'` instead of `t.type = 'deposit'`. The amended query now correctly retrieves distinct district names from the specified tables with the proper join conditions and filter criteria."
        ],
        "rules": [
            "1) When answering about \"districts with accounts that made withdrawal transactions\": make sure the output order: T1.A2. 2) When the question mentions \"districts\": \"districts\" actually means \"district in schema\" and should be referenced as table T1. 3) When the question mentions \"accounts\": \"accounts\" actually means \"account in schema\" and should be referenced as table T2. 4) When the question mentions \"withdrawal transactions\": \"withdrawal transactions\" actually means \"trans in schema with type = 'VYDAJ'\" and should be referenced as table T3. 5) When combining T1 and T2 for shared entities: link rows where T1.district_id = T2.district_id; keep only matching pairs (inner match). 6) When combining T2 and T3 for shared entities: link rows where T2.account_id = T3.account; keep only matching pairs (inner match). 7) When filtering for withdrawal transactions: include only rows where T3.type = 'VYDAJ' exactly. 8) When selecting distinct district names: return unique values of T1.A2."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT d.name \nFROM districts d \nJOIN accounts a ON d.district_id = a.district_id \nJOIN transactions t ON a.account_id = t.account_id \nWHERE t.type = 'deposit';",
            "SELECT DISTINCT T1.A2\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.A2\nFROM district T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN trans T3 ON T2.account_id = T3.account_id\nWHERE T3.type = 'VYDAJ'\nORDER BY T1.A2;"
        ],
        "amend_res": 1
    },
    "32": {
        "db_id": "california_schools",
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "ground_truth": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "amends": [
            "Do select the calculated ratio `CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\"` instead of selecting `school_name` and `free_or_reduced_price_meal_rate`. Do use `FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode` instead of `FROM schools` alone, adding the required join between tables. Do filter with `WHERE T2.SOC = 66` instead of `WHERE ownership_code = 66`, using the correct column name and table alias. Do remove the `grades LIKE '%1-12%'` filter instead of keeping it, as the logic is handled through the K-12 specific columns. Do order by `T1.\"FRPM Count (K-12)\" DESC` instead of `free_or_reduced_price_meal_count DESC`, using the correct column from the joined table. The amended query now correctly calculates the free/reduced price meal rate using K-12 specific enrollment and count data from the joined frpm table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about eligible free or reduced price meal rate: calculate the ratio CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" instead of selecting school_name and free_or_reduced_price_meal_rate. 2) When combining data from frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode using an inner join and keep only matching pairs. 3) When filtering for ownership code 66: use WHERE T2.SOC = 66 instead of ownership_code = 66, using the correct column name and table alias. 4) When the question mentions grades 1-12: do not filter with grades LIKE '%1-12%' as the logic is handled through K-12 specific columns. 5) When ordering by highest free or reduced price meal count: order by T1.\"FRPM Count (K-12)\" DESC instead of free_or_reduced_price_meal_count DESC. 6) When the question asks for top 5 schools: keep only the first 5 rows after ordering by T1.\"FRPM Count (K-12)\" in descending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, free_or_reduced_price_meal_rate \nFROM schools \nWHERE ownership_code = 66 \nAND grades LIKE '%1-12%' \nORDER BY free_or_reduced_price_meal_count DESC \nLIMIT 5;",
            "SELECT CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.SOC = '66' \nORDER BY T1.\"FRPM Count (K-12)\" DESC \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" AS eligible_rate\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.SOC = '66'\nORDER BY T1.\"FRPM Count (K-12)\" DESC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "946": {
        "db_id": "formula_1",
        "question": "Please list the location coordinates of the US circuits.",
        "ground_truth": "SELECT lat, lng FROM circuits WHERE country = 'USA'",
        "amends": [
            "Do select `lat` and `lng` instead of `latitude` and `longitude` to use the correct column names from the schema. The amended query now matches the RIGHT_SQL's behavior by properly referencing the actual column names in the database table.",
            "Do use the country code `'USA'` instead of `'US'` in the WHERE filter to match the correct ISO country code format. The amended query now correctly returns circuits located in the United States by using the standard three-letter country code."
        ],
        "rules": [
            "1) When the question asks for location coordinates: use the exact column names \"lat\" and \"lng\" instead of \"latitude\" and \"longitude\" from the circuits table",
            "1) When the question asks for circuits in the US: use the country code 'USA' instead of 'US' to match the ISO country code format in the WHERE filter"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude FROM circuits WHERE country = 'USA';",
            "SELECT lat, lng FROM circuits WHERE country = 'US';",
            "SELECT lat, lng FROM circuits WHERE country = 'USA';"
        ],
        "rule_sql": [
            "SELECT lat, lng FROM circuits WHERE country = 'USA';"
        ],
        "amend_res": 1
    },
    "827": {
        "db_id": "superhero",
        "question": "What is the average height of a non-human superhero in Dark Horse Comics?",
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.race != 'Human'",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `publisher AS T2` on `T1.publisher_id = T2.id` instead of filtering directly on `publisher`. Do join `race AS T3` on `T1.race_id = T3.id` instead of filtering directly on `species`. Do filter on `T2.publisher_name = 'Dark Horse Comics'` instead of `publisher = 'Dark Horse Comics'`. Do filter on `T3.race != 'Human'` instead of `species = 'Human'`. Do select `AVG(T1.height_cm)` instead of `AVG(height)`. The amended query now correctly joins related tables and uses proper column references to match the intended logic."
        ],
        "rules": [
            "1) When answering about \"average height of a non-human superhero in Dark Horse Comics\": make sure the output order: AVG(T1.height_cm). 2) When the question mentions \"Dark Horse Comics\": \"Dark Horse Comics\" actually means \"T2.publisher_name = 'Dark Horse Comics'\" in schema. 3) When the question mentions \"non-human\": \"non-human\" actually means \"T3.race != 'Human'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match). 5) When combining T1 and T3 for shared entities: link rows where T1.race_id = T3.id; keep only matching pairs (inner match). 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 7) When handling text literals: do not change case, spacing, or punctuation of 'Dark Horse Comics' or 'Human'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM superheroes WHERE publisher = 'Dark Horse Comics' AND species = 'Human';",
            "SELECT AVG(T1.height_cm) \nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id\nJOIN race AS T3 ON T1.race_id = T3.id\nWHERE T2.publisher_name = 'Dark Horse Comics' \nAND T3.race != 'Human'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.height_cm) \nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nINNER JOIN race T3 ON T1.race_id = T3.id\nWHERE T2.publisher_name = 'Dark Horse Comics' \nAND T3.race != 'Human'"
        ],
        "amend_res": 1
    },
    "121": {
        "db_id": "financial",
        "question": "List account ID and account opening date for accounts from 'Prachatice'.",
        "ground_truth": "SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'",
        "amends": [
            "Do join `account AS T1` with `district AS T2` on `T1.district_id = T2.district_id` instead of querying `accounts` table directly. Do select `T1.date` instead of `opening_date` and use table aliases for all columns. Do filter on `T2.A2 = 'Prachatice'` instead of `city = 'Prague'` to reference the correct location data from the joined district table. The amended query now correctly retrieves account information based on district location rather than a non-existent city column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about accounts from a specific location: join \"account AS T1\" with \"district AS T2\" using the exact key equality T1.district_id = T2.district_id to link account and district information. 2) When the question mentions 'account opening date': \"opening date\" actually means \"T1.date\" in the schema. 3) When the question mentions 'Prachatice': filter on T2.A2 = 'Prachatice' exactly as specified, using the exact literal value 'Prachatice' with correct case and spelling. 4) When selecting output columns: use the exact column tokens T1.account_id and T1.date with their table aliases as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, opening_date FROM accounts WHERE city = 'Prague';",
            "SELECT T1.account_id, T1.date\nFROM account AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.A2 = 'Prachatice';"
        ],
        "rule_sql": [
            "SELECT T1.account_id, T1.date\nFROM account AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.A2 = 'Prachatice'"
        ],
        "amend_res": 1
    },
    "913": {
        "db_id": "formula_1",
        "question": "In which country can I find the circuit with the highest altitude?",
        "ground_truth": "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1",
        "amends": [
            "Do reference column `alt` in the ORDER BY clause instead of `altitude` to match the correct column name in the schema. This change ensures the query sorts by the proper altitude column and returns the correct country with the highest altitude value, now matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"highest altitude\": use the exact column token \"alt\" from the circuits table for ordering instead of \"altitude\". 2) When ordering by altitude to find the highest value: sort in descending order (DESC) and take the first row only (LIMIT 1). 3) When answering about circuits and their countries: return the \"country\" column from the circuits table as the output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM circuits ORDER BY altitude DESC LIMIT 1;",
            "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT country FROM circuits ORDER BY alt DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "604": {
        "db_id": "codebase_community",
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "ground_truth": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "amends": [
            "Do add an `INNER JOIN` with a subquery that calculates `post_count` from the `posts` table instead of directly filtering on a non-existent `post_count` column in the `users` table. Do join on `T1.Id = T2.OwnerUserId` instead of missing the relationship between users and posts. Do calculate `AVG(T1.UpVotes)` and `AVG(T1.Age)` from properly aliased columns instead of using incorrect column names `up_votes` and `user_age`. Do filter using `HAVING post_count > 10` in the subquery instead of applying the filter directly in the `WHERE` clause against a non-existent column. The amended query now correctly calculates averages for users who have more than 10 posts by properly joining and aggregating the post counts, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"average of the up votes\" and \"average user age\": use \"AVG(T1.UpVotes)\" and \"AVG(T1.Age)\" exactly as specified in the schema instead of incorrect column names \"up_votes\" and \"user_age\". 2) When calculating post count for users: compute it from the \"posts\" table using a subquery that counts posts per user instead of using a non-existent \"post_count\" column in the \"users\" table. 3) When combining users and posts tables: link rows where \"T1.Id = T2.OwnerUserId\" to establish the relationship between users and their posts. 4) When filtering for users with more than 10 posts: apply the condition \"HAVING post_count > 10\" in the subquery that calculates post counts instead of using a WHERE clause against a non-existent column. 5) When the question asks about users creating posts: perform an inner join between users and posts tables to ensure only users with posts are considered."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT AVG(up_votes), AVG(user_age) FROM users WHERE post_count > 10;",
            "SELECT AVG(u.UpVotes) AS avg_up_votes, AVG(u.Age) AS avg_user_age\nFROM users u\nINNER JOIN (\n    SELECT OwnerUserId, COUNT(*) AS post_count\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING post_count > 10\n) p ON u.Id = p.OwnerUserId;"
        ],
        "rule_sql": [
            "SELECT AVG(T1.UpVotes) AS avg_up_votes, AVG(T1.Age) AS avg_user_age\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T1.Id IN (\n    SELECT OwnerUserId\n    FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(*) > 10\n)\nGROUP BY T1.Id"
        ],
        "amend_res": 1
    },
    "1400": {
        "db_id": "student_club",
        "question": "Among all events hold by the Student_Club in 2019, find the percentage share of events related to 'Community Service'",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(type) FROM event WHERE SUBSTR(event_date, 1, 4) = '2019'",
        "amends": [
            "Do use `SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN event_type = 'Community Service' THEN 1 END)` for accurate counting. Do reference column `type` instead of `event_type` and table `event` instead of `events`. Do remove the `organizer = 'Student_Club'` filter instead of keeping it. Do use `SUBSTR(event_date, 1, 4) = '2019'` instead of `strftime('%Y', event_date) = '2019'` for year extraction. Do add explicit `CAST(... AS REAL)` instead of implicit decimal conversion with `100.0`. Do reference `COUNT(type)` instead of `COUNT(*)` for denominator consistency. The amended query now correctly calculates the percentage share of community service events for 2019 without the organizer restriction."
        ],
        "rules": [
            "1) When answering about percentage share of events related to 'Community Service': use SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) for accurate counting instead of COUNT with CASE. 2) When referencing event type information: use column \"type\" instead of event_type. 3) When filtering for year 2019: use SUBSTR(event_date, 1, 4) = '2019' for year extraction instead of strftime function. 4) When calculating percentage: use explicit CAST(... AS REAL) instead of implicit decimal conversion with 100.0. 5) When counting total events for denominator: use COUNT(type) instead of COUNT(*) for consistency. 6) When the question mentions events held by Student_Club: do not apply organizer = 'Student_Club' filter as it should be removed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN event_type = 'Community Service' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_share\nFROM events\nWHERE organizer = 'Student_Club' \nAND strftime('%Y', event_date) = '2019';",
            "SELECT \n    (CAST(SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) / CAST(COUNT(type) AS REAL)) * 100 AS percentage_share\nFROM \n    event\nWHERE \n    SUBSTR(event_date, 1, 4) = '2019'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) * 100.0 / COUNT(type)) AS percentage_share\nFROM \n    event\nWHERE \n    SUBSTR(event_date, 1, 4) = '2019';"
        ],
        "amend_res": 1
    },
    "42": {
        "db_id": "california_schools",
        "question": "What is the type of education offered in the school who scored the highest average in Math?",
        "evidence": "",
        "ground_truth": "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1",
        "amends": [
            "Do select `T2.EdOpsName` instead of `education_type` to reference the correct column name from the joined table. Do use `satscores AS T1 INNER JOIN schools AS T2` instead of just `FROM schools` to properly join the two tables containing score and school data. Do specify the join condition `ON T1.cds = T2.CDSCode` instead of omitting any join predicate to correctly relate the tables through their matching identifier columns. Do order by `T1.AvgScrMath DESC` instead of `math_score DESC` to use the actual column name containing the math scores from the scores table. The amended query now correctly joins the necessary tables and references the appropriate columns to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"type of education offered in the school who scored the highest average in Math\": make sure the output order: T2.EdOpsName. 2) When the question mentions \"type of education\": \"type of education\" actually means \"T2.EdOpsName in schema\". 3) When the question mentions \"highest average in Math\": \"highest average in Math\" actually means \"T1.AvgScrMath in schema\" and requires ordering by T1.AvgScrMath DESC. 4) When combining T1 and T2 for shared entities: link rows where T1.cds = T2.CDSCode exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for the highest scoring school: rank rows by T1.AvgScrMath in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT education_type FROM schools ORDER BY math_score DESC LIMIT 1;",
            "SELECT T2.EdOpsName FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.EdOpsName\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "339": {
        "db_id": "toxicology",
        "question": "List the atom ID of the carcinogenic molecule that contains oxygen?",
        "ground_truth": "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of bare table names. Do change the FROM clause to `atom AS T1 INNER JOIN molecule AS T2` instead of the single table `atoms` with a subquery. Do replace the subquery with a direct join condition `ON T1.molecule_id = T2.molecule_id` instead of the IN predicate. Do change the WHERE filter to `T1.element = 'o'` instead of `element = 'O'` (lowercase 'o' instead of uppercase 'O'). Do add the new filter `T2.label = '+'` instead of omitting it, and do remove the `carcinogenic = 1` condition instead of keeping it. The amended query now correctly joins the atom and molecule tables directly and applies the proper filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When joining atom and molecule tables: use T1 for atom and T2 for molecule, and link rows where T1.molecule_id = T2.molecule_id with an inner match. 2) When filtering for oxygen atoms: use T1.element = 'o' (lowercase 'o' not uppercase 'O'). 3) When identifying carcinogenic molecules: use T2.label = '+' instead of carcinogenic = 1. 4) When selecting output: return only the atom_id column from T1."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id FROM atoms WHERE molecule_id IN (SELECT molecule_id FROM molecules WHERE carcinogenic = 1) AND element = 'O';",
            "SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT T1.atom_id FROM atom T1 INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'o' AND T2.label = '+'"
        ],
        "amend_res": 1
    },
    "1508": {
        "db_id": "debit_card_specializing",
        "question": "How many transactions taken place in the gas station in the Czech Republic are with a price of over 1000?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Price > 1000",
        "amends": [
            "Do reference `transactions_1k AS T1` instead of `transactions`, and add `gasstations AS T2` instead of omitting it. Do use `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of no join. Do filter on `T2.Country = 'CZE'` instead of `country = 'Czech Republic'`, and keep `T1.Price > 1000` instead of `price > 1000`. Do remove `station_type = 'gas_station'` instead of keeping it, and count `T1.TransactionID` instead of `COUNT(*)`. The amended query now correctly joins tables and uses proper country codes and column references to match the intended behavior."
        ],
        "rules": [
            "1) When answering about transactions in the Czech Republic: use country code 'CZE' instead of 'Czech Republic' and reference it through T2.Country. 2) When combining transaction and gas station data: link rows where T1.GasStationID = T2.GasStationID using an inner match. 3) When filtering by price: use T1.Price > 1000 to find transactions over 1000. 4) When counting transactions: count T1.TransactionID instead of all rows. 5) When the question mentions \"gas station\": do not filter by station_type as this information is already handled through the gasstations table join."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE country = 'Czech Republic' AND price > 1000 AND station_type = 'gas_station';",
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE' AND T1.Price > 1000"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE' AND T1.Price > 1000"
        ],
        "amend_res": 1
    },
    "833": {
        "db_id": "superhero",
        "question": "Name the superhero, otherwise known as Charles Chandler.",
        "ground_truth": "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler'",
        "amends": [
            "Do reference table `superhero` instead of `superheroes` and use column `full_name` instead of `real_name` for filtering, while keeping the same `SELECT superhero_name` clause and filter value 'Charles Chandler'."
        ],
        "rules": [
            "1) When the question asks about a superhero's name given their real name: use the exact table name \"superhero\" (not \"superheroes\") and select the column \"superhero_name\". 2) When filtering by the real name \"Charles Chandler\": use the column \"full_name\" (not \"real_name\") with the exact literal value 'Charles Chandler' (preserving case and spacing)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name FROM superheroes WHERE real_name = 'Charles Chandler';",
            "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';"
        ],
        "rule_sql": [
            "SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';"
        ],
        "amend_res": 1
    },
    "726": {
        "db_id": "superhero",
        "question": "Rank heroes published by Marvel Comics by their height in descending order.",
        "ground_truth": "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'",
        "amends": [
            "Do select `superhero_name`, `height_cm`, and add `RANK() OVER (ORDER BY height_cm DESC) AS HeightRank` instead of just `name` and `height`. Do use `FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id` instead of the single table approach. Do filter with `WHERE publisher.publisher_name = 'Marvel Comics'` instead of `publisher = 'Marvel Comics'`. Do remove the explicit `ORDER BY height ASC` since the window function handles ordering internally. The amended query now correctly joins tables, uses proper column references, and implements ranking functionality instead of simple sorting."
        ],
        "rules": [
            "1) When the question asks to rank heroes by height in descending order: use RANK() OVER (ORDER BY height_cm DESC) AS HeightRank to assign ranks based on height_cm in descending order. 2) When the question mentions \"heroes published by Marvel Comics\": this means filtering with publisher.publisher_name = 'Marvel Comics' exactly. 3) When combining superhero and publisher tables: link rows where superhero.publisher_id = publisher.id and keep only matching pairs (inner match). 4) When selecting output columns: include superhero_name, height_cm, and the computed HeightRank. 5) When handling the publisher name literal: preserve the exact case and spacing as 'Marvel Comics'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, height FROM heroes WHERE publisher = 'Marvel Comics' ORDER BY height ASC;",
            "SELECT superhero_name, height_cm, RANK() OVER (ORDER BY height_cm DESC) AS HeightRank FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics'"
        ],
        "rule_sql": [
            "SELECT \n    s.superhero_name,\n    s.height_cm,\n    RANK() OVER (ORDER BY s.height_cm DESC) AS HeightRank\nFROM \n    superhero s\nJOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    p.publisher_name = 'Marvel Comics'\nORDER BY \n    s.height_cm DESC;"
        ],
        "amend_res": 1
    },
    "613": {
        "db_id": "codebase_community",
        "question": "List out the dates that users who are located in Rochester, NY obtained their badges?",
        "ground_truth": "SELECT T2.Date FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'Rochester, NY'",
        "amends": [
            "Do reference the date column as `T2.Date` instead of `b.date` and use table alias `T2` instead of `b`. Do join with `INNER JOIN` instead of `JOIN` and use the join condition `T1.Id = T2.UserId` instead of `b.user_id = u.id`. Do filter on the location column `T1.Location = 'Rochester, NY'` instead of separate city and state filters `u.city = 'Rochester' AND u.state = 'NY'`. Do use table aliases `T1` for users and `T2` for badges instead of `u` and `b`. The amended query now correctly matches the intended behavior by using a combined location filter and proper join conditions."
        ],
        "rules": [
            "1) When answering about \"dates that users obtained badges\": make sure the output order: T2.Date. 2) When combining users table (T1) and badges table (T2): link rows where T1.Id = T2.UserId and keep only matching pairs (inner match). 3) When the question mentions \"users who are located in Rochester, NY\": filter rows where T1.Location = 'Rochester, NY' exactly as specified. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation of 'Rochester, NY'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT b.date FROM badges b JOIN users u ON b.user_id = u.id WHERE u.city = 'Rochester' AND u.state = 'NY'",
            "SELECT T2.Date\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T1.Location = 'Rochester, NY'"
        ],
        "rule_sql": [
            "SELECT T2.Date\nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T1.Location = 'Rochester, NY'\nORDER BY T2.Date"
        ],
        "amend_res": 1
    },
    "360": {
        "db_id": "card_games",
        "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
        "ground_truth": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
        "amends": [
            "Do query the `set_translations` table instead of the `cards` table. Do remove the `DISTINCT` clause instead of keeping it. Do use a subquery with `id IN (SELECT id FROM cards WHERE name = 'Angel of Mercy')` instead of directly filtering by `name = 'Angel of Mercy'` in the main query. Do select `language` from `set_translations` instead of from `cards`. The amended query now correctly retrieves language information from the translations table using the card ID as a reference, matching the RIGHT_SQL's behavior.",
            "Do use `id` in the subquery predicate instead of `setCode` to properly correlate the tables. Do reference `id` in the main query's IN clause instead of `setCode` to ensure the correct relationship between set_translations and cards tables. The amended query now correctly matches records based on the id column instead of setCode, fixing the logical relationship between the tables.",
            "Do use `id` in the subquery predicate instead of `setCode` to properly correlate the tables. Do reference `id` in the main query's IN clause instead of `setCode` to ensure correct record matching based on the primary key relationship. The amended query now correctly filters set_translations based on card IDs rather than set codes, matching the intended behavior of the right SQL.",
            "Do use `id` in the subquery predicate instead of `setCode` to properly correlate the tables. Do reference `id` in the main query's IN clause instead of `setCode` to ensure correct record matching based on the primary key relationship. The amended query now correctly filters set_translations based on card IDs rather than set codes, matching the intended behavior of the right SQL."
        ],
        "rules": [
            "Angel of Mercy' is the name of card;"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT DISTINCT language FROM cards WHERE name = 'Angel of Mercy';",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')",
            "SELECT language FROM set_translations WHERE setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "0": {
        "db_id": "california_schools",
        "question": "What is the highest eligible free rate for K-12 students in the schools in Alameda County?",
        "ground_truth": "SELECT `Free Meal Count (K-12)` / `Enrollment (K-12)` FROM frpm WHERE `County Name` = 'Alameda' ORDER BY (CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)`) DESC LIMIT 1",
        "amends": [
            "Do calculate `Free Meal Count (K-12) / Enrollment (K-12)` instead of selecting `MAX(free_rate)`. Do query from table `frpm` instead of `schools`. Do filter on `County Name = 'Alameda'` instead of `county = 'Alameda' AND student_type = 'K-12'`. Do add `ORDER BY (CAST(Free Meal Count (K-12) AS REAL) / Enrollment (K-12)) DESC` instead of omitting ordering. Do add `LIMIT 1` instead of using aggregate function. Do use explicit column division with cast to REAL instead of relying on a pre-calculated free_rate column."
        ],
        "rules": [
            "1) When answering about \"highest eligible free rate for K-12 students\": calculate Free Meal Count (K-12) divided by Enrollment (K-12) instead of selecting a pre-calculated free_rate column. 2) When the question mentions \"schools\": query from table \"frpm\" instead of \"schools\". 3) When filtering for Alameda County: use condition \"County Name\" = 'Alameda' instead of county = 'Alameda' AND student_type = 'K-12'. 4) When finding the highest rate: order by (CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\") in descending direction and keep only the first 1 row. 5) When performing division: cast \"Free Meal Count (K-12)\" to REAL to ensure proper numeric division."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(free_rate) FROM schools WHERE county = 'Alameda' AND student_type = 'K-12';",
            "SELECT (CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\") AS free_rate\nFROM frpm\nWHERE \"County Name\" = 'Alameda'\nORDER BY free_rate DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT MAX(CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\") AS highest_eligible_free_rate\nFROM frpm\nWHERE \"County Name\" = 'Alameda'\nAND \"Enrollment (K-12)\" > 0\nLIMIT 1;",
            "SELECT MAX(CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\") AS highest_eligible_free_rate\nFROM frpm\nWHERE \"County Name\" = 'Alameda'\nAND \"Enrollment (K-12)\" > 0"
        ],
        "amend_res": 1
    },
    "1291": {
        "db_id": "thrombosis_prediction",
        "question": "How many male patients have a normal level of both albumin and total protein?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M'  AND T2.ALB > 3.5 AND T2.ALB < 5.5 AND T2.TP BETWEEN 6.0 AND 8.5",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific columns instead of `COUNT(*)` from all rows. Do use table aliases `Patient AS T1` and `Laboratory AS T2` with an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single `patients` table. Do filter on `T1.SEX = 'M'` instead of `gender = 'male'` using proper column naming. Do replace string-based condition checks `albumin = 'normal'` with numeric range comparisons `T2.ALB > 3.5 AND T2.ALB < 5.5` for albumin values. Do replace string-based condition checks `total_protein = 'normal'` with numeric range comparisons `T2.TP BETWEEN 6.0 AND 8.5` for total protein values. Do use proper AND logic combining all conditions instead of the incorrect OR operator that created a logical error in the original query. The amended query now correctly counts male patients with normal albumin and total protein laboratory values by joining patient and laboratory data and using precise numeric range comparisons."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 2) When combining patient and laboratory data: link rows using T1.ID = T2.ID with an inner join between Patient AS T1 and Laboratory AS T2. 3) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male' with exact literal 'M'. 4) When checking for normal albumin levels: use numeric range comparison T2.ALB > 3.5 AND T2.ALB < 5.5 instead of string-based albumin = 'normal'. 5) When checking for normal total protein levels: use numeric range comparison T2.TP BETWEEN 6.0 AND 8.5 instead of string-based total_protein = 'normal'. 6) When combining multiple conditions: use AND logic to require all conditions simultaneously instead of OR logic."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND albumin = 'normal' OR total_protein = 'normal';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' \nAND T2.ALB > 3.5 AND T2.ALB < 5.5 \nAND T2.TP BETWEEN 6.0 AND 8.5"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' \nAND T2.ALB > 3.5 AND T2.ALB < 5.5 \nAND T2.TP BETWEEN 6.0 AND 8.5"
        ],
        "amend_res": 1
    },
    "28": {
        "db_id": "california_schools",
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "ground_truth": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "amends": [
            "Do select `T2.School` and `T2.DOC` instead of `name` and `doc_type`. Do join `frpm AS T1` with `schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T2.FundingType = 'Locally funded'` instead of `funding = 'locally funded'`. Do calculate the difference using `T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`` instead of `k12_enrollment - enrollment_15_17`. Do use the same join structure in the subquery with `frpm AS T3` and `schools AS T4` instead of querying only the `schools` table. The amended query now correctly joins the frpm and schools tables to access the required enrollment data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about school names and DOC types: select \"T2.School\" and \"T2.DOC\" as output columns. 2) When combining enrollment data from frpm and schools tables: join \"frpm AS T1\" with \"schools AS T2\" where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match). 3) When filtering for locally funded schools: use condition \"T2.FundingType = 'Locally funded'\" exactly as specified. 4) When calculating enrollment difference: compute \"T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`\" using the exact column names from frpm table. 5) When computing the average difference in subquery: use the same join structure with \"frpm AS T3\" and \"schools AS T4\" on \"T3.CDSCode = T4.CDSCode\" and filter with \"T4.FundingType = 'Locally funded'\". 6) When comparing to average difference: filter schools where the enrollment difference is greater than the computed average difference from the subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, doc_type \nFROM schools \nWHERE funding = 'locally funded' \nAND (k12_enrollment - enrollment_15_17) > (\n    SELECT AVG(k12_enrollment - enrollment_15_17) \n    FROM schools \n    WHERE funding = 'locally funded'\n)",
            "SELECT T2.School, T2.DOC\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.FundingType = 'Locally funded'\nAND (T1.\"Enrollment (K-12)\" - T1.\"Enrollment (Ages 5-17)\") > (\n    SELECT AVG(T3.\"Enrollment (K-12)\" - T3.\"Enrollment (Ages 5-17)\")\n    FROM frpm AS T3\n    JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode\n    WHERE T4.FundingType = 'Locally funded'\n)"
        ],
        "rule_sql": [
            "SELECT T2.School, T2.DOC\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.FundingType = 'Locally funded'\nAND (T1.\"Enrollment (K-12)\" - T1.\"Enrollment (Ages 5-17)\") > (\n    SELECT AVG(T3.\"Enrollment (K-12)\" - T3.\"Enrollment (Ages 5-17)\")\n    FROM frpm AS T3\n    INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode\n    WHERE T4.FundingType = 'Locally funded'\n)"
        ],
        "amend_res": 1
    },
    "46": {
        "db_id": "california_schools",
        "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
        "ground_truth": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "amends": [
            "Do select `T2.School` instead of `state` and `SUM(enrollees)`. Do use `FROM frpm AS T1 INNER JOIN schools AS T2` instead of `FROM schools` alone. Do apply join condition `ON T1.CDSCode = T2.CDSCode` instead of no join. Do filter with `WHERE T2.DOC = 31` instead of `WHERE grade BETWEEN 1 AND 12`. Do remove `GROUP BY state` instead of keeping it. Do order by `T1.Enrollment (K-12) DESC` instead of `total_enrollees DESC`. The amended query now correctly joins the frpm and schools tables to find the school with the highest K-12 enrollment for DOC code 31, matching the intended behavior.",
            "Do remove `T1.\"Enrollment (K-12)\" AS enrollees` from the SELECT list instead of including it, and do use numeric value `31` instead of string `'31'` in the WHERE filter for `T2.DOC`. Do use backticks `Enrollment (K-12)` instead of double quotes for the column reference in ORDER BY. The amended query now correctly selects only the school name and uses proper numeric comparison for the DOC filter, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about state special schools: filter schools where T2.DOC = 31 instead of using grade ranges. 2) When combining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match). 3) When the question asks for highest number of enrollees: rank schools by T1.\"Enrollment (K-12)\" in descending order and keep the top school. 4) When producing output: select T2.School instead of state and SUM(enrollees). 5) When grouping is not required: do not use GROUP BY state.",
            "1) When the question asks for state special schools: filter T2.DOC to equal numeric value 31 exactly (not string '31'). 2) When ordering by enrollment count: use the exact column name \"Enrollment (K-12)\" with double quotes as shown in the schema. 3) When selecting output columns for this question: include only T2.School in the results, not the enrollment count itself. 4) When finding the highest number of enrollees: order rows by T1.\"Enrollment (K-12)\" in descending order and keep only the top result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT state, SUM(enrollees) as total_enrollees FROM schools WHERE grade BETWEEN 1 AND 12 GROUP BY state ORDER BY total_enrollees DESC LIMIT 1;",
            "SELECT T2.School, T1.\"Enrollment (K-12)\" AS enrollees\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = '31'\nORDER BY T1.\"Enrollment (K-12)\" DESC\nLIMIT 1;",
            "SELECT T2.School\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.DOC = 31\nORDER BY T1.`Enrollment (K-12)` DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.School \nFROM frpm T1 \nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.DOC = 31 \nORDER BY T1.\"Enrollment (K-12)\" DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1447": {
        "db_id": "student_club",
        "question": "List the name and location of events that underspend its budget.",
        "ground_truth": "SELECT DISTINCT T1.event_name, T1.location FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 0",
        "amends": [
            "Do select `DISTINCT T1.event_name, T1.location` instead of `name, location`. Do use `FROM event AS T1 INNER JOIN budget AS T2` instead of `FROM events` alone. Do add join condition `ON T1.event_id = T2.link_to_event` instead of omitting the table relationship. Do filter with `T2.remaining > 0` instead of `budget > actual_spending` to properly check remaining budget rather than comparing budget to spending. The amended query now correctly joins the event and budget tables and filters for events with positive remaining budget."
        ],
        "rules": [
            "1) When answering about \"events that underspend its budget\": make sure the output order: T1.event_name, T1.location. 2) When the question mentions \"name\": \"name\" actually means \"T1.event_name in schema\". 3) When the question mentions \"location\": \"location\" actually means \"T1.location in schema\". 4) When combining T1 and T2 for shared entities: link rows where T1.event_id = T2.link_to_event; keep only matching pairs (inner match). 5) When filtering for underspending events: use T2.remaining > 0 to identify events with positive remaining budget."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM events WHERE budget > actual_spending;",
            "SELECT DISTINCT T1.event_name, T1.location\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T2.remaining > 0"
        ],
        "rule_sql": [
            "SELECT T1.event_name, T1.location\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T2.remaining > 0\nORDER BY T1.event_name, T1.location;"
        ],
        "amend_res": 1
    },
    "874": {
        "db_id": "formula_1",
        "question": "Who finished second in the San Marino Grand Prix in 2006?",
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.year = 2006 AND T1.name = 'San Marino Grand Prix' AND T2.position = 2",
        "amends": [
            "Do select `T3.forename` and `T3.surname` instead of just `driver_name`. Do join `races AS T1` instead of querying a single table. Do use `INNER JOIN results AS T2 ON T2.raceId = T1.raceId` instead of no join to results. Do add `INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId` instead of missing the drivers table. Do filter on `T1.year = 2006` instead of a standalone year column. Do use `T1.name = 'San Marino Grand Prix'` instead of `race_name`. Do filter on `T2.position = 2` instead of `position = 1`. The amended query now correctly joins the necessary tables and filters for second place finishers in the 2006 San Marino Grand Prix."
        ],
        "rules": [
            "1) When the question asks about race results: join races table as T1, results table as T2 on T2.raceId = T1.raceId, and drivers table as T3 on T3.driverId = T2.driverId using inner matches only. 2) When the question mentions \"San Marino Grand Prix\": use T1.name = 'San Marino Grand Prix' exactly as written. 3) When the question mentions year 2006: use T1.year = 2006. 4) When the question asks about \"second place\" finisher: use T2.position = 2. 5) When the question asks \"who finished\": output both T3.forename and T3.surname instead of just driver_name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM race_results WHERE race_name = 'San Marino Grand Prix' AND year = 2006 AND position = 1;",
            "SELECT T3.forename, T3.surname \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId \nWHERE T1.year = 2006 \nAND T1.name = 'San Marino Grand Prix' \nAND T2.position = 2"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname \nFROM races AS T1\nINNER JOIN results AS T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T1.name = 'San Marino Grand Prix' \nAND T1.year = 2006 \nAND T2.position = 2"
        ],
        "amend_res": 1
    },
    "1441": {
        "db_id": "student_club",
        "question": "How many members have education major in the College of Education & Human Services?",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
        "amends": [
            "Do count `T1.member_id` instead of `COUNT(*)` to avoid counting null values. Do join `member AS T1` with `major AS T2` on `T2.major_id = T1.link_to_major` instead of querying a single table. Do add filter `T1.position = 'Member'` instead of omitting it. Do change the education filter to `T2.major_name LIKE '%Education%'` instead of directly filtering on education_major. Do keep the college filter as `T2.college = 'College of Education & Human Services'` but apply it to the joined major table instead of the member table. The amended query now correctly counts members with specific positions who are linked to education-related majors in the specified college, matching the intended behavior."
        ],
        "rules": [
            "1) When counting members: count using T1.member_id instead of counting all rows to avoid counting null values. 2) When combining member and major information: join member AS T1 with major AS T2 on T2.major_id = T1.link_to_major to connect members with their majors. 3) When filtering for members only: add filter T1.position = 'Member' to include only members, not other positions. 4) When identifying education majors: use T2.major_name LIKE '%Education%' instead of directly filtering on education_major column. 5) When filtering by college: use T2.college = 'College of Education & Human Services' with exact case and spacing as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE education_major = 'College of Education & Human Services'",
            "SELECT COUNT(T1.member_id) \nFROM member AS T1\nJOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Member'\nAND T2.major_name LIKE '%Education%'\nAND T2.college = 'College of Education & Human Services'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.member_id) \nFROM member AS T1 \nJOIN major AS T2 ON T2.major_id = T1.link_to_major \nWHERE T1.position = 'Member' \nAND T2.major_name LIKE '%Education%' \nAND T2.college = 'College of Education & Human Services'"
        ],
        "amend_res": 1
    },
    "496": {
        "db_id": "card_games",
        "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
        "amends": [
            "Do query the `sets` and `set_translations` tables instead of the `cards` table. Do use `INNER JOIN` on `T2.setCode = T1.code` instead of querying a single table. Do select `T1.baseSetSize` instead of `COUNT(*)`. Do filter on `T2.translation = 'Rinascita di Alara'` instead of `set_name = 'Rinascita di Alara'`. The amended query now correctly retrieves the base set size from the appropriate tables using the translation value rather than counting cards with a potentially incorrect set name filter."
        ],
        "rules": [
            "1) When answering about \"number of cards in the set of 'Rinascita di Alara'\": make sure the output order: T1.baseSetSize\n2) When the question mentions \"Rinascita di Alara\": \"Rinascita di Alara\" actually means \"T2.translation = 'Rinascita di Alara'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T2.setCode = T1.code; keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation of 'Rinascita di Alara'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE set_name = 'Rinascita di Alara';",
            "SELECT T1.baseSetSize \nFROM sets T1 \nINNER JOIN set_translations T2 ON T2.setCode = T1.code \nWHERE T2.translation = 'Rinascita di Alara'"
        ],
        "rule_sql": [
            "SELECT T1.baseSetSize\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T2.translation = 'Rinascita di Alara'"
        ],
        "amend_res": 1
    },
    "327": {
        "db_id": "toxicology",
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "amends": [
            "Do select only `T.molecule_id` instead of `*` from all columns. Do use a subquery with `molecule AS T1` and `atom AS T2` tables instead of a single `molecules` table. Do add `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of no join condition. Do add filter `T1.label = '-'` in WHERE clause instead of omitting it. Do add `GROUP BY T1.molecule_id` instead of no grouping. Do move the atom count filter to `HAVING COUNT(T2.atom_id) > 5` instead of `WHERE atom_count > 5`. Do remove the `carcinogenic = 0` filter instead of keeping it. The amended query now correctly counts atoms per molecule with the specified label filter and returns only molecule IDs meeting the atom count threshold."
        ],
        "rules": [
            "1) When answering about non-carcinogenic molecules: do not filter by carcinogenic = 0 as this filter should be removed. 2) When counting atoms per molecule: use a subquery with molecule AS T1 and atom AS T2 tables instead of a single molecules table. 3) When joining molecule and atom tables: use INNER JOIN on T1.molecule_id = T2.molecule_id to link rows where the canonical keys are equal. 4) When filtering for non-carcinogenic molecules: add filter T1.label = '-' in WHERE clause instead of carcinogenic = 0. 5) When grouping results: use GROUP BY T1.molecule_id to organize results by molecule ID. 6) When counting atoms per molecule: compute the number of atoms using COUNT(T2.atom_id) as the counting key. 7) When filtering by atom count: move the atom count filter to HAVING COUNT(T2.atom_id) > 5 instead of WHERE atom_count > 5. 8) When selecting output columns: select only T1.molecule_id instead of all columns (*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE carcinogenic = 0 AND atom_count > 5;",
            "SELECT T1.molecule_id\nFROM molecule AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.label = '-'\nGROUP BY T1.molecule_id\nHAVING COUNT(T2.atom_id) > 5"
        ],
        "rule_sql": [
            "SELECT T1.molecule_id\nFROM molecule AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.label = '-'\nGROUP BY T1.molecule_id\nHAVING COUNT(T2.atom_id) > 5"
        ],
        "amend_res": 1
    },
    "1009": {
        "db_id": "formula_1",
        "question": "Please list the time each driver spent at the pit stop during the 2011 Australian Grand Prix.",
        "ground_truth": "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'",
        "amends": [
            "Do select `T1.duration` instead of `driver_name, pit_stop_time`. Do use `pitStops AS T1` and `races AS T2` with an `INNER JOIN` on `T1.raceId = T2.raceId` instead of querying only `pit_stops` without joins. Do filter on `T2.year = 2011` and `T2.name = 'Australian Grand Prix'` instead of `race_year` and `race_name` from a single table. Do remove the `ORDER BY driver_name` clause instead of keeping it. The amended query now correctly joins the pit stops and races tables to filter by year and race name while returning the appropriate duration field."
        ],
        "rules": [
            "1) When answering about \"time each driver spent at the pit stop\": make sure the output order: T1.duration. 2) When the question mentions \"2011 Australian Grand Prix\": use T2.year = 2011 and T2.name = 'Australian Grand Prix' for filtering. 3) When combining pit stops and races tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 4) When producing output: do not include ORDER BY driver_name clause."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name, pit_stop_time FROM pit_stops WHERE race_year = 2011 AND race_name = 'Australian Grand Prix' ORDER BY driver_name;",
            "SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'"
        ],
        "rule_sql": [
            "SELECT d.forename || ' ' || d.surname AS driver_name, ps.duration \nFROM pitStops ps\nJOIN races r ON ps.raceId = r.raceId\nJOIN drivers d ON ps.driverId = d.driverId\nWHERE r.year = 2011 AND r.name = 'Australian Grand Prix'\nORDER BY ps.duration"
        ],
        "amend_res": 1
    },
    "829": {
        "db_id": "superhero",
        "question": "Which publisher created more superheroes: DC or Marvel Comics? Find the difference in the number of superheroes.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "amends": [
            "Do use `SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)` as the single output expression instead of selecting `publisher`, `COUNT(*)`, and a subquery-calculated difference. Do join `publisher AS T2` on `T1.publisher_id = T2.id` instead of querying the `superheroes` table directly without proper table joins. Do remove the `WHERE publisher IN ('DC', 'Marvel Comics')` filter and `GROUP BY publisher` clause since the calculation is now handled through conditional aggregation. Do eliminate the `ORDER BY superhero_count DESC LIMIT 1` as the query now returns a single scalar difference value instead of grouped publisher results. The amended query correctly calculates the difference between DC Comics and Marvel Comics superhero counts using proper table relationships through the join condition."
        ],
        "rules": [
            "1) When the question asks for the difference in superhero counts between DC and Marvel Comics: use SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) as the single output expression. 2) When combining superheroes and publisher tables: link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match). 3) When handling publisher names: use exact literals 'DC Comics' and 'Marvel Comics' with correct case and spacing. 4) When calculating counts: do not use GROUP BY or WHERE filtering since conditional aggregation handles the calculation in a single row. 5) When producing output: return only the scalar difference value without publisher names, counts, or ordering clauses."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    publisher,\n    COUNT(*) as superhero_count,\n    (SELECT COUNT(*) FROM superheroes WHERE publisher = 'DC') - (SELECT COUNT(*) FROM superheroes WHERE publisher = 'Marvel Comics') as difference\nFROM superheroes \nWHERE publisher IN ('DC', 'Marvel Comics')\nGROUP BY publisher\nORDER BY superhero_count DESC\nLIMIT 1;",
            "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS difference\nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id;"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) FROM superhero T1 INNER JOIN publisher T2 ON T1.publisher_id = T2.id"
        ],
        "amend_res": 1
    },
    "991": {
        "db_id": "formula_1",
        "question": "What is the full name and date of birth of Austrian drivers born between 1981 and 1991?",
        "ground_truth": "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'",
        "amends": [
            "Do use column names `forename`, `surname`, and `dob` instead of `first_name`, `last_name`, and `date_of_birth`. Do apply `STRFTIME('%Y', dob)` to extract the year from the date column instead of directly comparing `date_of_birth` between integer years. Do compare the extracted year string between string literals '1981' and '1991' instead of integer values 1981 and 1991. The amended query now correctly filters Austrian drivers born between 1981 and 1991 by properly handling date extraction and comparison."
        ],
        "rules": [
            "1) When the question asks for \"full name\": use columns \"forename\" and \"surname\" from table drivers. 2) When the question asks for \"date of birth\": use column \"dob\" from table drivers. 3) When filtering by nationality \"Austrian\": use condition nationality = 'Austrian' with exact literal 'Austrian'. 4) When filtering for birth years between 1981 and 1991: extract the year from \"dob\" using STRFTIME('%Y', dob) and compare between string literals '1981' and '1991' inclusive."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, date_of_birth FROM drivers WHERE nationality = 'Austrian' AND date_of_birth BETWEEN 1981 AND 1991;",
            "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991';"
        ],
        "rule_sql": [
            "SELECT forename, surname, dob FROM drivers WHERE nationality = 'Austrian' AND STRFTIME('%Y', dob) BETWEEN '1981' AND '1991'"
        ],
        "amend_res": 1
    },
    "1287": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients followed at the outpatient clinic, how many of them have a normal level of alkaliphophatase?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALP < 300 AND T1.Admission = '-'",
        "amends": [
            "Do join `Patient` and `Laboratory` tables with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.ALP < 300` instead of checking for `alkaliphophatase = 'normal'`. Do add the condition `T1.Admission = '-'` instead of omitting it. Do count `T1.ID` instead of using `COUNT(*)`. The amended query now correctly counts patients with normal alkaline phosphatase levels based on laboratory values and admission status, matching the intended behavior.",
            "Do remove `DISTINCT` from the count aggregation instead of keeping it, as the join condition already ensures unique patient IDs are counted. Do maintain the `INNER JOIN` on `T1.ID = T2.ID` and preserve both the `T2.ALP < 300` and `T1.Admission = '-'` filters in the WHERE clause. The amended query now correctly counts all patient IDs meeting the criteria without unnecessary deduplication, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients followed at the outpatient clinic: make sure to filter for patients where T1.Admission = '-' exactly as specified. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID exactly as shown and keep only matching pairs (inner match). 3) When checking for normal alkaline phosphatase levels: use the condition T2.ALP < 300 instead of checking for text 'normal'. 4) When counting patients: count using the canonical key T1.ID instead of counting all rows.",
            "1) When counting patients from the outpatient clinic: use T1.ID as the counting key without DISTINCT since the join ensures uniqueness. 2) When identifying outpatient clinic patients: filter for T1.Admission = '-' exactly as specified. 3) When checking for normal alkaline phosphatase levels: filter for T2.ALP < 300. 4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner match to ensure only patients with lab results are included."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE alkaliphophatase = 'normal';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T2.ALP < 300 \nAND T1.Admission = '-'",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.ALP < 300 AND T1.Admission = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-' \nAND T2.ALP < 300"
        ],
        "amend_res": 1
    },
    "283": {
        "db_id": "toxicology",
        "question": "Identify whether the chemical compound that contains Calcium is carcinogenic.",
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'",
        "amends": [
            "Do select `T2.label AS flag_carcinogenic` instead of `carcinogenic`. Do use `atom AS T1 INNER JOIN molecule AS T2` instead of `compounds` alone. Do specify join condition `ON T1.molecule_id = T2.molecule_id` instead of no join. Do filter on `T1.element = 'ca'` instead of `element = 'Calcium'` with different case sensitivity. The amended query now correctly joins tables and uses proper case handling for element comparison."
        ],
        "rules": [
            "1) When answering about whether a chemical compound containing Calcium is carcinogenic: use table atom as T1 INNER JOIN table molecule as T2 instead of compounds table alone. 2) When joining T1 and T2: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 3) When filtering for Calcium element: use T1.element = 'ca' with exact lowercase 'ca' instead of 'Calcium'. 4) When selecting carcinogenic information: use T2.label AS flag_carcinogenic instead of carcinogenic column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic FROM compounds WHERE element = 'Calcium';",
            "SELECT T2.label AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca'"
        ],
        "rule_sql": [
            "SELECT T2.label AS flag_carcinogenic\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'ca';"
        ],
        "amend_res": 1
    },
    "1398": {
        "db_id": "student_club",
        "question": "Name the event with the highest amount spent on advertisement.",
        "ground_truth": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' ORDER BY T1.spent DESC LIMIT 1",
        "amends": [
            "Do select `T2.event_name` from the `event` table instead of `event_name` from the `advertisements` table. Do join `budget AS T1` with `event AS T2` on `T1.link_to_event = T2.event_id` instead of querying a single table. Do add a WHERE filter for `T1.category = 'Advertisement'` instead of omitting any filtering condition. Do order by `T1.spent DESC` instead of `amount_spent ASC` to get the highest spending record. The amended query now correctly retrieves the event name with the highest advertisement spending from the related budget and event tables, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"highest amount spent on advertisement\": make sure the output order: T1.spent DESC. 2) When the question mentions \"event\": \"event\" actually means \"T2.event_name\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.link_to_event = T2.event_id; keep only matching pairs (inner match). 4) When filtering for advertisement spending: include only rows where T1.category = 'Advertisement' exactly as specified. 5) When the question asks for \"highest amount spent\": rank rows by T1.spent in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM advertisements ORDER BY amount_spent ASC LIMIT 1;",
            "SELECT T2.event_name \nFROM budget AS T1 \nJOIN event AS T2 ON T1.link_to_event = T2.event_id \nWHERE T1.category = 'Advertisement' \nORDER BY T1.spent DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.event_name\nFROM budget T1\nINNER JOIN event T2 ON T1.link_to_event = T2.event_id\nWHERE T1.category = 'Advertisement'\nORDER BY T1.spent DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1466": {
        "db_id": "student_club",
        "question": "Write the full name of the club member with the position of 'Secretary' and list which college the club member belongs to.",
        "ground_truth": "SELECT T1.first_name, T1.last_name, college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'",
        "amends": [
            "Do add table `member AS T1` instead of using `club_members` directly. Do add `INNER JOIN major AS T2` instead of omitting the join. Do use join condition `T2.major_id = T1.link_to_major` instead of no join condition. Do qualify columns as `T1.first_name` and `T1.last_name` instead of unqualified column references. The amended query now correctly joins member and major tables to retrieve the required data with proper table relationships.",
            "Do select separate columns `T1.first_name` and `T1.last_name` instead of concatenating them as `full_name`. Do remove the alias `full_name` instead of keeping it. Do keep the same `FROM` source `member AS T1` and `INNER JOIN` type on `major AS T2` with the same `ON T2.major_id = T1.link_to_major` predicate. Do maintain the same `WHERE` filter on `T1.position = 'Secretary'`. The amended query now correctly returns first_name and last_name as separate columns instead of a concatenated string, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about club members and their colleges: use table \"member\" as T1 and table \"major\" as T2 instead of using \"club_members\" directly. 2) When combining member and major tables: link rows where T2.major_id = T1.link_to_major and keep only matching pairs (inner match). 3) When selecting member information: qualify columns as T1.first_name and T1.last_name instead of using unqualified column references. 4) When filtering for position: use condition T1.position = 'Secretary' with exact literal 'Secretary'.",
            "1) When answering about club member names: output first_name and last_name as separate columns instead of concatenating them into a full_name. 2) When the question asks for a club member with position 'Secretary': filter rows where T1.position equals exactly 'Secretary'. 3) When combining member and major tables: link rows where T2.major_id equals T1.link_to_major and keep only matching pairs (inner match). 4) When the question asks for which college a club member belongs to: include T2.college in the output columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, college FROM club_members WHERE position = 'Secretary';",
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name, T2.college\nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Secretary'",
            "SELECT T1.first_name, T1.last_name, T2.college\nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.position = 'Secretary'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name, T2.college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Secretary'"
        ],
        "amend_res": 1
    },
    "357": {
        "db_id": "card_games",
        "question": "What type of promotion is of card 'Duress'?",
        "ground_truth": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
        "amends": [
            "Do select `promoTypes` instead of `promotion_type` and add filter `promoTypes IS NOT NULL` instead of omitting it. Do filter on `name` instead of `card_name` while keeping the same literal value 'Duress'. The amended query now correctly retrieves non-null promotion types for the specified card name."
        ],
        "rules": [
            "1) When the question asks about promotion type for a card: use column \"promoTypes\" from table \"cards\" instead of \"promotion_type\". 2) When filtering for card name 'Duress': use column \"name\" instead of \"card_name\" while keeping the exact literal value 'Duress'. 3) When retrieving promotion types: ensure to filter out null values by adding condition \"promoTypes IS NOT NULL\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT promotion_type FROM cards WHERE card_name = 'Duress';",
            "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "48": {
        "db_id": "california_schools",
        "question": "What is the ratio of merged Unified School District schools in Orange County to merged Elementary School District schools?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) FROM schools WHERE StatusType = 'Merged' AND County = 'Orange'",
        "amends": [
            "Do use `SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END)` and `SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END)` in the SELECT clause instead of subqueries with `COUNT(*)` and different filtering conditions. Do filter with `StatusType = 'Merged' AND County = 'Orange'` in the WHERE clause instead of separate subqueries with `county = 'Orange County' AND district_type = 'Unified School District' AND status = 'merged'` and `county = 'Orange County' AND district_type = 'Elementary School District' AND status = 'merged'`. Do add explicit `CAST(... AS REAL)` for division instead of relying on implicit casting. Do remove the subquery structure and use a single table scan instead of multiple subqueries. The amended query now correctly calculates the ratio using proper aggregation and filtering logic that matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for a ratio of merged Unified School District schools to merged Elementary School District schools in Orange County: use SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) for Unified School District count and SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) for Elementary School District count. 2) When filtering for Orange County and merged status: use StatusType = 'Merged' AND County = 'Orange' in the WHERE clause. 3) When performing division to calculate the ratio: use explicit CAST(... AS REAL) to ensure proper numeric division instead of relying on implicit casting. 4) When counting schools by district type: use DOC column values 54 for Unified School District and 52 for Elementary School District as specified in the schema mapping. 5) When handling the Orange County filter: use County = 'Orange' (not 'Orange County') as the exact literal value from the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM schools WHERE county = 'Orange County' AND district_type = 'Unified School District' AND status = 'merged') / \n    (SELECT COUNT(*) FROM schools WHERE county = 'Orange County' AND district_type = 'Elementary School District' AND status = 'merged') \nAS ratio;",
            "SELECT \n    CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) AS REAL) AS ratio\nFROM schools\nWHERE StatusType = 'Merged' AND County = 'Orange';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) AS REAL) AS ratio\nFROM schools\nWHERE StatusType = 'Merged' AND County = 'Orange';"
        ],
        "amend_res": 1
    },
    "509": {
        "db_id": "card_games",
        "question": "What is the unique id of the set that has the highest number of cards?",
        "ground_truth": "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1",
        "amends": [
            "Do order by `baseSetSize DESC` instead of `card_count` in the ORDER BY clause. End with a brief confirmation that the amended query now matches RIGHT_SQL's behavior.",
            "Do select `id` instead of `code` in the SELECT list, maintaining the same ORDER BY clause on `baseSetSize DESC` and LIMIT 1 constraint."
        ],
        "rules": [
            "1) When the question asks for the \"unique id of the set that has the highest number of cards\": use the column \"id\" from table \"sets\" as the output. 2) When the question mentions \"highest number of cards\": this actually means ordering by \"baseSetSize\" in descending order. 3) When the question asks for the highest ranked item: return only the top 1 row after ordering by \"baseSetSize DESC\".",
            "1) When answering about \"the unique id of the set that has the highest number of cards\": make sure the output order: id. 2) When the question mentions \"unique id\": \"unique id\" actually means \"id in schema\". 3) When the question mentions \"highest number of cards\": \"highest number of cards\" actually means \"baseSetSize in schema\". 4) When the question mentions \"highest\": rank rows by baseSetSize in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT id FROM sets ORDER BY card_count LIMIT 1;",
            "SELECT code FROM sets ORDER BY baseSetSize DESC LIMIT 1;",
            "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1054": {
        "db_id": "european_football_2",
        "question": "What is the defensive work rate of the football player David Wilson\n?",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT t2.defensive_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'David Wilson'",
        "amends": [
            "Do use `DISTINCT` on the result set instead of omitting it. Do select `defensive_work_rate` from table `t2` instead of directly from `players`. Do join `Player AS t1` and `Player_Attributes AS t2` with `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of querying a single table. Do filter by `t1.player_name = 'David Wilson'` instead of separate `first_name` and `last_name` conditions. The amended query now correctly retrieves distinct defensive work rates from the joined tables using the proper player identification approach."
        ],
        "rules": [
            "1) When joining Player and Player_Attributes tables: use INNER JOIN on t1.player_api_id = t2.player_api_id to link matching rows between the tables. 2) When filtering for a specific player by name: use t1.player_name = 'David Wilson' instead of separate first_name and last_name conditions. 3) When selecting defensive_work_rate: retrieve it from table t2 (Player_Attributes) instead of directly from the players table. 4) When returning results: use DISTINCT on the result set to eliminate duplicate defensive_work_rate values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT defensive_work_rate FROM players WHERE first_name = 'David' AND last_name = 'Wilson';",
            "SELECT DISTINCT t2.defensive_work_rate\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'David Wilson'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.defensive_work_rate\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'David Wilson';"
        ],
        "amend_res": 1
    },
    "164": {
        "db_id": "financial",
        "question": "Who placed the order with the id 32423?",
        "evidence": "",
        "ground_truth": "SELECT T3.client_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T4.account_id = T2.account_id  INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE T1.order_id = 32423",
        "amends": [
            "Do select only `T3.client_id` instead of all columns with `*`. Do add joins to `order` as `T1`, `account` as `T2`, `disp` as `T4`, and `client` as `T3` instead of querying only the `customers` table. Do use `INNER JOIN` on `T1.account_id=T2.account_id` instead of missing this relationship. Do add another `INNER JOIN` on `T4.account_id=T2.account_id` instead of omitting the disp table connection. Do add a third `INNER JOIN` on `T4.client_id=T3.client_id` instead of missing the client linkage. Do filter on `T1.order_id=32423` instead of filtering on a non-existent `order_id` column in the customers table. The amended query now correctly retrieves the client_id associated with the specified order through the proper table relationships."
        ],
        "rules": [
            "1) When answering about \"Who placed the order with the id 32423\": make sure the output order: T3.client_id\n2) When the question mentions \"order with the id 32423\": filter rows where T1.order_id = 32423\n3) When combining tables for this query: link T1 (order) and T2 (account) where T1.account_id = T2.account_id using inner match\n4) When combining tables for this query: link T4 (disp) and T2 (account) where T4.account_id = T2.account_id using inner match\n5) When combining tables for this query: link T4 (disp) and T3 (client) where T4.client_id = T3.client_id using inner match\n6) When selecting output: return only T3.client_id instead of all columns"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM customers WHERE order_id = 32423;",
            "SELECT T3.client_id\nFROM `order` AS T1\nINNER JOIN account AS T2 ON T1.account_id = T2.account_id\nINNER JOIN disp AS T4 ON T4.account_id = T2.account_id\nINNER JOIN client AS T3 ON T4.client_id = T3.client_id\nWHERE T1.order_id = 32423"
        ],
        "rule_sql": [
            "SELECT T3.client_id\nFROM \"order\" T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T4 ON T4.account_id = T2.account_id\nINNER JOIN client T3 ON T4.client_id = T3.client_id\nWHERE T1.order_id = 32423"
        ],
        "amend_res": 1
    },
    "315": {
        "db_id": "toxicology",
        "question": "Among the molecules which contain \"cl\" element, which of them are carcinogenic?",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'cl' AND T2.label = '+'",
        "amends": [
            "Do select only `T1.molecule_id` with `DISTINCT` instead of selecting all columns with `*`. Do query from `atom AS T1` with an `INNER JOIN` to `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only from `molecules`. Do filter with `T1.element = 'cl'` instead of `element LIKE '%cl%'` and with `T2.label = '+'` instead of `carcinogenic = 'yes'`. The amended query now correctly identifies chlorine-containing molecules with a positive label using proper table relationships instead of incorrect column references and filtering logic."
        ],
        "rules": [
            "1) When answering about molecules containing \"cl\" element: use table \"atom AS T1\" and filter with exact equality T1.element = 'cl' instead of pattern matching. 2) When determining carcinogenic status: use table \"molecule AS T2\" and filter with T2.label = '+' instead of checking a 'carcinogenic' column. 3) When combining atom and molecule information: link rows where T1.molecule_id = T2.molecule_id using an inner join to keep only matching pairs. 4) When selecting output columns: return only T1.molecule_id with DISTINCT to show unique molecule identifiers instead of all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE element LIKE '%cl%' AND carcinogenic = 'yes';",
            "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'cl' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.molecule_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.element = 'cl' AND T2.label = '+'"
        ],
        "amend_res": 1
    },
    "1496": {
        "db_id": "debit_card_specializing",
        "question": "Which client segment consumed the least in September 2013?",
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201309' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do group by `T1.CustomerID` instead of `c.Segment` to ensure proper aggregation when calculating the sum of consumption. The amended query now correctly identifies the customer with the lowest total consumption for September 2013 by grouping at the customer level rather than segment level, matching the RIGHT_SQL's behavior.",
            "Do reference `T1.Segment` instead of `c.Segment` and use table aliases `T1` and `T2` instead of `ym` and `c`. Do use `INNER JOIN` instead of `JOIN` for explicit clarity. Do change the join condition to `T1.CustomerID = T2.CustomerID` instead of `ym.CustomerID = c.CustomerID` to maintain proper table reference consistency. Do filter with `T2.Date = '201309'` instead of `ym.Date LIKE '2013-09%'` for exact date matching without pattern matching. Do group by `T1.CustomerID` instead of `c.Segment` to aggregate consumption per customer rather than per segment. Do order by `SUM(T2.Consumption)` instead of `SUM(ym.Consumption)` with the correct table alias. The amended query now correctly identifies the customer with the lowest total consumption in September 2013 rather than grouping by segment, matching the RIGHT_SQL's behavior.",
            "Do group by `T1.CustomerID` instead of `c.Segment` to ensure proper aggregation when calculating the sum of consumption. The amended query now correctly identifies the customer with the lowest total consumption in September 2013 by grouping at the customer level rather than segment level, matching the RIGHT_SQL's behavior.",
            "Do group by `T1.CustomerID` instead of `c.Segment` to ensure proper aggregation when calculating the sum of consumption. The amended query now correctly groups by customer ID rather than segment, which aligns with the intended logic of finding the customer with the lowest total consumption for September 2013, and matches the behavior of the RIGHT_SQL.",
            "Do group by `T1.CustomerID` instead of `c.Segment` to ensure proper aggregation when calculating the sum of consumption. The amended query now correctly groups by customer ID rather than segment, which aligns with the intended aggregation logic and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "September 2013 refers to yearmonth.date = '201309'"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT client_segment, SUM(amount) as total_consumption \nFROM transactions \nWHERE strftime('%Y-%m', date) = '2013-09' \nGROUP BY client_segment \nORDER BY total_consumption DESC \nLIMIT 1;",
            "SELECT c.Segment, SUM(ym.Consumption) as total_consumption\nFROM yearmonth ym\nINNER JOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY total_consumption ASC\nLIMIT 1;",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;",
            "SELECT c.Segment\nFROM yearmonth ym\nJOIN customers c ON ym.CustomerID = c.CustomerID\nWHERE ym.Date LIKE '2013-09%'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;",
            "SELECT c.Segment\nFROM customers c\nINNER JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '201309'\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "855": {
        "db_id": "formula_1",
        "question": "Where can I find the information about the races held on Sepang International Circuit?",
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Sepang International Circuit'",
        "amends": [
            "Do select `T1.url` instead of `*` and add `DISTINCT` instead of omitting it. Do join `circuits AS T1` instead of querying only `races` and use `INNER JOIN races AS T2` instead of no join. Do use join condition `T2.circuitID = T1.circuitId` instead of no join predicate. Do filter on `T1.name = 'Sepang International Circuit'` instead of `circuit_name = 'Monza Circuit'` and remove the `date LIKE '%-09-%'` filter instead of keeping it. The amended query now correctly retrieves distinct circuit URLs by joining tables and filtering on the proper circuit name."
        ],
        "rules": [
            "1) When answering about races held on a specific circuit: make sure the output order: T1.url 2) When the question mentions \"races held on Sepang International Circuit\": \"Sepang International Circuit\" actually means T1.name = 'Sepang International Circuit' in schema 3) When combining circuits AS T1 and races AS T2 for shared entities: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match) 4) When retrieving information about races: use DISTINCT T1.url instead of selecting all columns to avoid duplicate URLs 5) When filtering by circuit name: use exact literal 'Sepang International Circuit' with correct case and spacing, not 'Monza Circuit' 6) When the question asks about races on a specific circuit: do not include date filters like '%-09-%' unless explicitly requested"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM races WHERE circuit_name = 'Monza Circuit' AND date LIKE '%-09-%';",
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Sepang International Circuit'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Sepang International Circuit'"
        ],
        "amend_res": 1
    },
    "320": {
        "db_id": "toxicology",
        "question": "What is the type of the bond which is presenting the connection between two atoms TR000_1 and TR000_2?",
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'",
        "amends": [
            "Do use `T1.bond_type` with table alias instead of `bond_type` without qualification. Do join `bond AS T1` with `connected AS T2` instead of querying `bonds` table alone. Do use `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of no join condition. Do filter with `T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'` instead of `atom1 = 'TR000_1' OR atom2 = 'TR000_2'` to find bonds connecting both specified atoms rather than either atom. The amended query now correctly identifies bonds between two specific atoms by joining the bond and connected tables with proper join conditions and conjunction logic."
        ],
        "rules": [
            "1) When answering about bond type between two specific atoms: use table alias T1 for bond table and T2 for connected table. 2) When joining bond and connected tables: link rows where T1.bond_id = T2.bond_id using inner join. 3) When filtering for bonds connecting both TR000_1 and TR000_2: use T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2' instead of OR logic. 4) When selecting the bond type: use T1.bond_type as the output column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM bonds WHERE atom1 = 'TR000_1' OR atom2 = 'TR000_2';",
            "SELECT T1.bond_type \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'"
        ],
        "rule_sql": [
            "SELECT T1.bond_type FROM bond T1 INNER JOIN connected T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'"
        ],
        "amend_res": 1
    },
    "584": {
        "db_id": "codebase_community",
        "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "ground_truth": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
        "amends": [
            "Do select `T2.Comment` instead of `c.*` to retrieve only the comment column rather than all columns from the comments table. Do use `INNER JOIN postHistory AS T2` instead of `JOIN posts p` to join with the postHistory table rather than the posts table. Do join on `T1.Id = T2.PostId` instead of `c.post_id = p.id` to correctly link posts with their history using the proper column names. Do reference `T1.Title` instead of `p.title` while maintaining the same filter condition for the post title. The amended query now correctly retrieves comments from postHistory joined with posts using the proper table relationships and column references."
        ],
        "rules": [
            "1) When answering about comments left by users who edited a specific post: select only the \"Comment\" column from the postHistory table (as T2.Comment) instead of all columns. 2) When joining tables to find post-related information: use an INNER JOIN between posts (as T1) and postHistory (as T2) instead of joining with the posts table directly. 3) When linking posts with their history: match rows where T1.Id equals T2.PostId exactly. 4) When filtering by post title: reference T1.Title with the exact literal 'Why square the difference instead of taking the absolute value in standard deviation?' maintaining the same filter condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.* FROM comments c JOIN posts p ON c.post_id = p.id WHERE p.title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
            "SELECT T2.Comment\nFROM posts AS T1\nINNER JOIN postHistory AS T2 ON T1.Id = T2.PostId\nWHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'"
        ],
        "rule_sql": [
            "SELECT T2.Comment \nFROM posts AS T1 \nINNER JOIN postHistory AS T2 ON T1.Id = T2.PostId \nWHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'"
        ],
        "amend_res": 1
    },
    "124": {
        "db_id": "financial",
        "question": "List the loan ID, district and average salary for loan with duration of 60 months.",
        "ground_truth": "SELECT T3.loan_id, T2.A2, T2.A11 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.duration = 60",
        "amends": [
            "Do select `T3.loan_id`, `T2.A2`, and `T2.A11` instead of `loan_id`, `district`, and `AVG(salary) as average_salary`. Do use `FROM account AS T1` with `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` and `INNER JOIN loan AS T3 ON T1.account_id = T3.account_id` instead of `FROM loans` alone. Do keep `WHERE T3.duration = 60` instead of `WHERE duration = 60`. Do remove `GROUP BY loan_id, district` instead of keeping it. The amended query now correctly joins the necessary tables and selects appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"loan ID, district and average salary for loan with duration of 60 months\": make sure the output order: T3.loan_id, T2.A2, T2.A11\n2) When combining tables for loan information: use FROM account AS T1 with INNER JOIN district AS T2 ON T1.district_id = T2.district_id and INNER JOIN loan AS T3 ON T1.account_id = T3.account_id\n3) When filtering for loans with duration of 60 months: use WHERE T3.duration = 60\n4) When selecting columns: do not use GROUP BY loan_id, district"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT loan_id, district, AVG(salary) as average_salary \nFROM loans \nWHERE duration = 60 \nGROUP BY loan_id, district",
            "SELECT T3.loan_id, T2.A2, T2.A11\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.duration = 60"
        ],
        "rule_sql": [
            "SELECT T3.loan_id, T2.A2, T2.A11\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.duration = 60"
        ],
        "amend_res": 1
    },
    "1322": {
        "db_id": "student_club",
        "question": "Among the events attended by more than 10 members of the Student_Club, how many of them are meetings?",
        "ground_truth": "SELECT T1.event_name FROM event AS T1  INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_id  HAVING COUNT(T2.link_to_event) > 10 EXCEPT SELECT T1.event_name  FROM event AS T1  WHERE T1.type = 'Meeting'",
        "amends": [
            "Do select `event_name` instead of `COUNT(*)`. Do join `event` and `attendance` tables with `INNER JOIN` on `event_id = link_to_event` instead of using a subquery with `IN` condition. Do group by `event_id` instead of not grouping. Do use `HAVING COUNT(link_to_event) > 10` instead of `HAVING COUNT(member_id) > 10` in the subquery. Do add an `EXCEPT` clause to filter out events where `type = 'Meeting'` instead of filtering for `event_type = 'meeting'` in the WHERE clause. The amended query now correctly identifies event names with sufficient attendance while excluding meeting-type events, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about events attended by more than 10 members: select event_name instead of counting all rows. 2) When combining event and attendance tables: link rows where event.event_id equals attendance.link_to_event using an inner join. 3) When grouping events: group by event_id to organize results by individual events. 4) When filtering for sufficient attendance: use HAVING COUNT(attendance.link_to_event) > 10 to count attendance records. 5) When excluding meeting-type events: filter out events where type equals 'Meeting' (case-sensitive) instead of filtering for event_type = 'meeting'. 6) When the question asks about events attended by more than 10 members: the output should be event names, not a count."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM Events \nWHERE event_type = 'meeting' \nAND event_id IN (\n    SELECT event_id \n    FROM Attendance \n    GROUP BY event_id \n    HAVING COUNT(member_id) > 10\n)",
            "SELECT event_name FROM event INNER JOIN attendance ON event.event_id = attendance.link_to_event GROUP BY event.event_id HAVING COUNT(attendance.link_to_event) > 10 EXCEPT SELECT event_name FROM event WHERE type = 'Meeting';"
        ],
        "rule_sql": [
            "SELECT event.event_name \nFROM event \nINNER JOIN attendance ON event.event_id = attendance.link_to_event \nWHERE event.type = 'Meeting' \nGROUP BY event.event_id \nHAVING COUNT(attendance.link_to_member) > 10"
        ],
        "amend_res": 1
    },
    "576": {
        "db_id": "codebase_community",
        "question": "Name the user that commented 'thank you user93!'",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'",
        "amends": [
            "Do select `T1.DisplayName` instead of `username` and add table alias `T1` instead of omitting it. Do add `INNER JOIN comments AS T2` instead of querying only the users table. Do add join condition `ON T1.Id = T2.UserId` instead of missing the table relationship. Do change filter to `T2.Text = 'thank you user93!'` instead of `comment = 'thank you user93!'` to reference the correct table column. The amended query now correctly joins tables and references appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the name of a user who made a specific comment: select \"T1.DisplayName\" instead of \"username\" as the output column. 2) When combining user and comment information: perform an inner join between \"users\" as T1 and \"comments\" as T2 using the condition T1.Id = T2.UserId to link users to their comments. 3) When filtering for a specific comment text: use the exact literal 'thank you user93!' and apply the filter to T2.Text column instead of a non-existent comment column. 4) When answering about user identification: ensure the output order contains only the DisplayName column from the users table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT username FROM users WHERE comment = 'thank you user93!'",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN comments AS T2 ON T1.Id = T2.UserId\nWHERE T2.Text = 'thank you user93!'"
        ],
        "rule_sql": [
            "SELECT T1.DisplayName FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'thank you user93!'"
        ],
        "amend_res": 1
    },
    "1057": {
        "db_id": "european_football_2",
        "question": "Calculate the average home team goal in the 2010/2011 season in the country of Poland.",
        "ground_truth": "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Poland' AND t2.season = '2010/2011'",
        "amends": [
            "Do use `CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id)` instead of `AVG(home_team_goal)` to calculate the average with explicit casting to avoid integer division. Do add `Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id` instead of querying only the `matches` table to properly join country data. Do filter on `t1.name = 'Poland'` instead of `country = 'Poland'` to use the country name from the joined table. Do keep `t2.season = '2010/2011'` filter but reference it through the joined table alias. The amended query now correctly calculates the average home team goals for Poland in the 2010/2011 season by properly joining country data and avoiding integer division issues."
        ],
        "rules": [
            "1) When calculating averages to avoid integer division: use CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) instead of AVG(home_team_goal). 2) When the question mentions a country name like 'Poland': join Country table as t1 with Match table as t2 using t1.id = t2.country_id and filter on t1.name = 'Poland'. 3) When filtering by season '2010/2011': apply t2.season = '2010/2011' through the joined table alias. 4) When combining Country and Match tables: perform an inner join where t1.id = t2.country_id to ensure proper country data linkage."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(home_team_goal) FROM matches WHERE season = '2010/2011' AND country = 'Poland';",
            "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) AS average_home_goals\nFROM Country AS t1 \nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nWHERE t1.name = 'Poland' AND t2.season = '2010/2011'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) AS average_home_goal\nFROM Country t1\nINNER JOIN Match t2 ON t1.id = t2.country_id\nWHERE t1.name = 'Poland' AND t2.season = '2010/2011'"
        ],
        "amend_res": 1
    },
    "761": {
        "db_id": "superhero",
        "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and use table alias `T1` instead of direct table reference. Do join `superhero AS T1` with `gender AS T2` on `T1.gender_id = T2.id` instead of filtering directly on `gender = 'Male'`. Do filter using `T2.gender = 'Male'` instead of direct column reference. Do calculate `T1.weight_kg * 100` instead of direct `weight` comparison. Do multiply the subquery result by `79` instead of `0.79` and reference `weight_kg` instead of `weight` in both main query and subquery. The amended query now correctly handles the gender relationship through proper table joining and fixes the weight calculation logic to match the intended comparison."
        ],
        "rules": [
            "1) When answering about superhero names: use the exact column token \"T1.superhero_name\" for output. 2) When the question mentions \"male superheroes\": join table \"superhero AS T1\" with table \"gender AS T2\" on \"T1.gender_id = T2.id\" and filter using \"T2.gender = 'Male'\". 3) When the question mentions \"weight\": use the column \"T1.weight_kg\" and multiply it by 100 for comparison. 4) When calculating the 79% average weight: compute the average of \"weight_kg\" from all superheroes and multiply the result by 79 instead of 0.79. 5) When comparing weight: ensure the main query compares \"T1.weight_kg * 100\" against the calculated 79% average weight from the subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE gender = 'Male' AND weight > (SELECT AVG(weight) * 0.79 FROM superheroes);",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nJOIN gender AS T2 ON T1.gender_id = T2.id\nWHERE T2.gender = 'Male'\nAND T1.weight_kg * 100 > (\n    SELECT AVG(weight_kg) * 79\n    FROM superhero\n)"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nJOIN gender AS T2 ON T1.gender_id = T2.id\nWHERE T2.gender = 'Male'\nAND T1.weight_kg * 100 > (\n    SELECT AVG(weight_kg) * 79\n    FROM superhero\n)"
        ],
        "amend_res": 1
    },
    "1352": {
        "db_id": "student_club",
        "question": "For all the club members from \"Business\" major, how many of them wear medium size t-shirt?",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'",
        "amends": [
            "Do select `COUNT(T1.member_id)` instead of `COUNT(*)` to count specific non-null values. Do use `FROM member AS T1 INNER JOIN major AS T2` instead of `FROM club_members` to properly join the member and major tables. Do apply join condition `ON T1.link_to_major = T2.major_id` instead of directly filtering on a major column that doesn't exist in the member table. Do filter with `T2.major_name = 'Business'` instead of `major = 'Business'` to reference the correct table and column. Do filter with `T1.t_shirt_size = 'Medium'` instead of `tshirt_size = 'Medium'` to use the correct column name from the member table. The amended query now correctly joins related tables and uses proper column references to match the intended behavior."
        ],
        "rules": [
            "1) When counting club members: use COUNT(T1.member_id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"Business\" major: \"Business\" actually means T2.major_name = 'Business' in the schema. 3) When the question mentions \"medium size t-shirt\": \"medium size t-shirt\" actually means T1.t_shirt_size = 'Medium' in the schema. 4) When combining member and major tables: link rows where T1.link_to_major = T2.major_id and keep only matching pairs (inner match). 5) When answering about club members from \"Business\" major who wear medium size t-shirts: make sure to join member AS T1 INNER JOIN major AS T2 with the condition T1.link_to_major = T2.major_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM club_members WHERE major = 'Business' AND tshirt_size = 'Medium';",
            "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.member_id) \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'"
        ],
        "amend_res": 1
    },
    "486": {
        "db_id": "card_games",
        "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE set_name = 'Coldsnap')` for the percentage calculation. Do join `sets AS T2` on `T2.code = T1.setCode` instead of querying the cards table directly without a join. Do filter on `T2.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'` to use the joined table's name field. Do remove the redundant `converted_mana_cost = 7` condition from the WHERE clause since it's now handled in the CASE expression within the aggregate calculation. The amended query now correctly calculates the percentage of cards with converted mana cost 7 in the Coldsnap set by properly joining to the sets table and using accurate aggregate functions."
        ],
        "rules": [
            "1) When calculating percentage of cards with converted mana cost 7 in a specific set: use CAST(SUM(CASE WHEN convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) instead of COUNT(*) * 100.0 / subquery. 2) When filtering by set name 'Coldsnap': join sets AS T2 on T2.code = T1.setCode and filter on T2.name = 'Coldsnap' instead of using set_name directly. 3) When handling converted mana cost condition: remove converted_mana_cost = 7 from WHERE clause since it's handled in the CASE expression within aggregate calculation. 4) When counting cards: use COUNT(id) as the denominator for percentage calculation to count all cards in the specified set."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE set_name = 'Coldsnap')) AS percentage FROM cards WHERE converted_mana_cost = 7 AND set_name = 'Coldsnap';",
            "SELECT \n    CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM \n    cards AS T1\nJOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T2.name = 'Coldsnap'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) AS percentage\nFROM cards AS T1\nJOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap';"
        ],
        "amend_res": 1
    },
    "718": {
        "db_id": "superhero",
        "question": "How many superheroes have the super power of \"Super Strength\"?",
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Super Strength'",
        "amends": [
            "Do use `COUNT(T1.hero_id)` instead of `COUNT(*)` to count specific hero instances rather than all rows. Do join `hero_power AS T1` and `superpower AS T2` with `INNER JOIN` instead of querying only `superheroes` table. Do use join condition `T1.power_id = T2.id` instead of no join condition. Do filter on `T2.power_name = 'Super Strength'` instead of `super_power = 'Super Strength'` to reference the correct column from the joined table. The amended query now correctly counts heroes with the specified power by joining the appropriate relationship tables instead of assuming a single table structure."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.hero_id) instead of COUNT(*) to count specific hero instances. 2) When the question mentions \"super power\": \"Super Strength\" actually means T2.power_name = 'Super Strength' in the schema. 3) When combining hero_power and superpower tables: link rows where T1.power_id = T2.id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE super_power = 'Super Strength';",
            "SELECT COUNT(T1.hero_id) \nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nWHERE T2.power_name = 'Super Strength'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT hp.hero_id) \nFROM hero_power hp\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sp.power_name = 'Super Strength'"
        ],
        "amend_res": 1
    },
    "1105": {
        "db_id": "european_football_2",
        "question": "How was Francesco Migliore's attacking work rate on 2015/5/1?",
        "ground_truth": "SELECT t2.attacking_work_rate FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.`date` LIKE '2015-05-01%' AND t1.player_name = 'Francesco Migliore'",
        "amends": [
            "Do select `t2.attacking_work_rate` instead of `attacking_work_rate` without table qualification. Do use `INNER JOIN` between `Player AS t1` and `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of querying only `player_performance` table. Do filter with `t2.date LIKE '2015-05-01%'` instead of `date = '2015/5/1'` to match date format patterns. Do keep `t1.player_name = 'Francesco Migliore'` filter but move it to the joined table instead of the original table. The amended query now correctly joins player information with attributes and handles date matching appropriately."
        ],
        "rules": [
            "1) When answering about a player's attacking work rate: make sure the output order: t2.attacking_work_rate\n2) When the question mentions \"Francesco Migliore\": \"Francesco Migliore\" actually means \"t1.player_name = 'Francesco Migliore'\" in schema\n3) When the question mentions date \"2015/5/1\": \"2015/5/1\" actually means \"t2.date LIKE '2015-05-01%'\" to match date format patterns\n4) When combining Player as t1 and Player_Attributes as t2 for shared entities: link rows where t1.player_api_id = t2.player_api_id exactly as shown; keep only matching pairs (inner match)\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation of 'Francesco Migliore' or '2015-05-01%'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT attacking_work_rate FROM player_performance WHERE player_name = 'Francesco Migliore' AND date = '2015/5/1';",
            "SELECT t2.attacking_work_rate \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Francesco Migliore' \nAND t2.date LIKE '2015-05-01%'"
        ],
        "rule_sql": [
            "SELECT t2.attacking_work_rate\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Francesco Migliore'\nAND t2.date LIKE '2015-05-01%'"
        ],
        "amend_res": 1
    },
    "1318": {
        "db_id": "student_club",
        "question": "What is the event that has the highest attendance of the students from the Student_Club?",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name ORDER BY COUNT(T2.link_to_event) DESC LIMIT 1",
        "amends": [
            "Do select `T1.event_name` from the `event` table instead of `event_name` from `Student_Club`. Do join `attendance AS T2` with `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying a single table. Do add `GROUP BY T1.event_name` to aggregate by event instead of omitting grouping. Do order by `COUNT(T2.link_to_event)` descending instead of `attendance` descending. The amended query now correctly identifies the event with the highest attendance count by joining event and attendance tables and counting attendance records per event."
        ],
        "rules": [
            "1) When answering about \"event with highest attendance\": make sure the output order: T1.event_name. 2) When the question mentions \"attendance\": \"attendance\" actually means \"COUNT(T2.link_to_event) in schema\". 3) When the question mentions \"highest\": rank rows by COUNT(T2.link_to_event) in descending direction and keep the first 1 row. 4) When combining T1 (event) and T2 (attendance) for shared entities: link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"count of attendance\": compute the number of rows using the canonical key token T2.link_to_event. 6) When the question says \"per event\": organize results by T1.event_name and compute requested aggregates per group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM Student_Club ORDER BY attendance DESC LIMIT 1;",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_name\nORDER BY COUNT(T2.link_to_event) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nGROUP BY T1.event_name\nORDER BY COUNT(T2.link_to_event) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "384": {
        "db_id": "card_games",
        "question": "List down the uuid for legacy cards and the foreign language of these cards.",
        "ground_truth": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
        "amends": [
            "Do add `INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid` and `INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid` instead of querying only the `legacy_cards` table. Do change the FROM clause to `cards AS T1` instead of `legacy_cards`. Do add the filter `T2.format = 'legacy'` instead of filtering by `language != 'English'`. Do select `T3.language` instead of just `language` from the original table. The amended query now correctly joins multiple tables to filter by format and retrieve language data from the appropriate source, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"legacy cards\": use table \"cards\" as T1 and filter for format = 'legacy' from table \"legalities\" as T2. 2) When combining tables for shared entities: link rows where T1.uuid = T2.uuid and T1.uuid = T3.uuid, keeping only matching pairs (inner match). 3) When retrieving foreign language information: select T3.language from table \"foreign_data\" as T3 instead of from the base table. 4) When the question asks for \"uuid for legacy cards\": select T1.uuid from the cards table. 5) When the question asks for \"foreign language of these cards\": select T3.language from the foreign_data table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT uuid, language FROM legacy_cards WHERE language != 'English';",
            "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'"
        ],
        "rule_sql": [
            "SELECT T1.uuid, T3.language\nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nINNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'legacy'"
        ],
        "amend_res": 1
    },
    "196": {
        "db_id": "toxicology",
        "question": "In the non-carcinogenic molecules, how many contain chlorine atoms?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '-'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all rows. Do join `atom AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table. Do filter on `T2.element = 'cl'` instead of `atoms LIKE '%Cl%'` for exact element matching. Do add `T1.label = '-'` condition instead of omitting it. Do remove the `carcinogenic = 1` filter instead of keeping it. The amended query now correctly counts distinct molecules containing chlorine atoms with the specified label, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(DISTINCT T1.molecule_id) instead of COUNT(*) to count unique molecules rather than all rows. 2) When the question asks about molecules containing chlorine atoms: join atom AS T2 on T1.molecule_id = T2.molecule_id to access atom information. 3) When filtering for chlorine atoms: use T2.element = 'cl' instead of pattern matching for exact element matching. 4) When the question specifies non-carcinogenic molecules: add T1.label = '-' condition to filter for non-carcinogenic molecules. 5) When the question asks about non-carcinogenic molecules: remove any carcinogenic = 1 filter as it would select carcinogenic molecules instead."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE carcinogenic = 1 AND atoms LIKE '%Cl%';",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nJOIN atom AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.label = '-' AND T2.element = 'cl'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nJOIN atom AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.label = '-' AND T2.element = 'cl'"
        ],
        "amend_res": 1
    },
    "732": {
        "db_id": "superhero",
        "question": "Which publisher published the slowest superhero?",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Speed' ORDER BY T3.attribute_value LIMIT 1",
        "amends": [
            "Do join `publisher` as `T2` on `T1.publisher_id = T2.id` instead of directly selecting from a single table. Do add joins to `hero_attribute` as `T3` on `T1.id = T3.hero_id` and `attribute` as `T4` on `T3.attribute_id = T4.id` instead of omitting these necessary relationships. Do filter with `WHERE T4.attribute_name = 'Speed'` instead of ordering by a non-existent `speed` column. Do order by `T3.attribute_value` instead of `speed DESC` to properly sort the numeric attribute values. Do select `T2.publisher_name` instead of `publisher` to get the correct column from the joined table. The amended query now correctly identifies the publisher with the highest speed attribute value by joining through the proper relationship chain."
        ],
        "rules": [
            "1) When answering about \"slowest superhero\": make sure the output order: T3.attribute_value ASC (lowest value first) instead of DESC. 2) When the question mentions \"publisher\": \"publisher\" actually means \"T2.publisher_name\" in schema. 3) When combining T1 (superheroes) and T2 (publisher): link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match). 4) When combining T1 (superheroes) and T3 (hero_attribute): link rows where T1.id = T3.hero_id and keep only matching pairs (inner match). 5) When combining T3 (hero_attribute) and T4 (attribute): link rows where T3.attribute_id = T4.id and keep only matching pairs (inner match). 6) When filtering for speed attribute: use WHERE T4.attribute_name = 'Speed' to select only speed-related attributes. 7) When ordering by speed values: use T3.attribute_value instead of a non-existent speed column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT publisher FROM superheroes ORDER BY speed DESC LIMIT 1;",
            "SELECT T2.publisher_name\nFROM superhero T1\nJOIN publisher T2 ON T1.publisher_id = T2.id\nJOIN hero_attribute T3 ON T1.id = T3.hero_id\nJOIN attribute T4 ON T3.attribute_id = T4.id\nWHERE T4.attribute_name = 'Speed'\nORDER BY T3.attribute_value ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.publisher_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nINNER JOIN hero_attribute T3 ON T1.id = T3.hero_id\nINNER JOIN attribute T4 ON T3.attribute_id = T4.id\nWHERE T4.attribute_name = 'Speed'\nORDER BY T3.attribute_value ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "540": {
        "db_id": "codebase_community",
        "question": "What is the title of the post that is owned by csgillespie and has the highest popularity?",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' ORDER BY T1.ViewCount DESC LIMIT 1",
        "amends": [
            "Do join `posts AS T1` with `users AS T2` on `T1.OwnerUserId = T2.Id` instead of querying only the `posts` table without any join. Do filter on `T2.DisplayName = 'csgillespie'` instead of directly filtering on `owner = 'csgillespie'`. Do select `T1.Title` instead of just `title`. Do order by `T1.ViewCount DESC` instead of `popularity ASC`. The amended query now correctly joins tables to filter by display name and orders by view count instead of popularity, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"posts owned by csgillespie\": join table \"posts AS T1\" with table \"users AS T2\" where T1.OwnerUserId equals T2.Id and keep only matching pairs (inner match). 2) When the question mentions \"csgillespie\": \"csgillespie\" actually means \"T2.DisplayName = 'csgillespie'\" in schema. 3) When the question asks for \"title of the post\": select T1.Title as the output column. 4) When the question mentions \"highest popularity\": \"popularity\" actually means \"T1.ViewCount\" in schema, and rank rows by T1.ViewCount in descending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts WHERE owner = 'csgillespie' ORDER BY popularity ASC LIMIT 1;",
            "SELECT T1.Title \nFROM posts AS T1 \nJOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie' \nORDER BY T1.ViewCount DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Title\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id\nWHERE T2.DisplayName = 'csgillespie'\nORDER BY T1.ViewCount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "439": {
        "db_id": "card_games",
        "question": "List out the set name of the set code \"ALL\".",
        "evidence": "",
        "ground_truth": "SELECT name FROM sets WHERE code = 'ALL'",
        "amends": [
            "Do select `name` instead of `set_name` and filter on `code` instead of `set_code` instead of using the incorrect column names, which ensures the query correctly references the actual column names in the database schema. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"set name\" of a set code: use column \"name\" from table sets instead of \"set_name\". 2) When filtering by set code value \"ALL\": use column \"code\" from table sets instead of \"set_code\" and match the exact literal value 'ALL'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT set_name FROM sets WHERE set_code = 'ALL';",
            "SELECT name FROM sets WHERE code = 'ALL';"
        ],
        "rule_sql": [
            "SELECT name FROM sets WHERE code = 'ALL'"
        ],
        "amend_res": 1
    },
    "1316": {
        "db_id": "student_club",
        "question": "Please list the phone numbers of the students from the Student_Club that has attended the event \"Women's Soccer\".",
        "ground_truth": "SELECT T3.phone FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.event_name = 'Women''s Soccer'",
        "amends": [
            "Do select `T3.phone` instead of `phone_number` from the `Students` table. Do use a three-table join structure with `event AS T1` INNER JOIN `attendance AS T2` ON `T1.event_id = T2.link_to_event` INNER JOIN `member AS T3` ON `T2.link_to_member = T3.member_id` instead of querying a single `Students` table. Do filter on `T1.event_name = 'Women''s Soccer'` instead of `club_name = 'Women\\'s Soccer'` to correctly identify the event type. The amended query now properly retrieves phone numbers from members who attended the specific Women's Soccer event rather than assuming club membership data resides in a Students table."
        ],
        "rules": [
            "1) When answering about phone numbers of students from a club that attended an event: select T3.phone instead of phone_number from the Students table. 2) When combining event, attendance, and member tables: use a three-table join structure with event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id. 3) When filtering for the \"Women's Soccer\" event: use T1.event_name = 'Women''s Soccer' instead of club_name to correctly identify the event type."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM Students WHERE club_name = 'Women\\'s Soccer';",
            "SELECT T3.phone \nFROM event AS T1 \nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event \nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id \nWHERE T1.event_name = 'Women''s Soccer'"
        ],
        "rule_sql": [
            "SELECT T3.phone \nFROM event AS T1 \nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event \nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id \nWHERE T1.event_name = 'Women''s Soccer'"
        ],
        "amend_res": 1
    },
    "407": {
        "db_id": "card_games",
        "question": "Lists all types of cards in German.",
        "ground_truth": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
        "amends": [
            "Do select specific columns `T1.subtypes` and `T1.supertypes` instead of selecting all columns with `*`. Do join table `foreign_data AS T2` with `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do filter on `T2.language = 'German'` instead of `cards.language = 'German'`. Do add null checks `T1.subtypes IS NOT NULL` and `T1.supertypes IS NOT NULL` instead of omitting them. The amended query now correctly filters by language from the foreign_data table while ensuring non-null supertypes and subtypes, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"types of cards in German\": make sure the output order: T1.subtypes, T1.supertypes. 2) When the question mentions \"German\": \"German\" actually means T2.language = 'German' in schema. 3) When combining cards as T1 and foreign_data as T2: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match). 4) When selecting card type information: ensure T1.subtypes IS NOT NULL and T1.supertypes IS NOT NULL to exclude null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE language = 'German';",
            "SELECT DISTINCT T1.subtypes, T1.supertypes \nFROM cards AS T1 \nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid \nWHERE T2.language = 'German' \nAND T1.subtypes IS NOT NULL \nAND T1.supertypes IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.subtypes, T1.supertypes\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'German'\nAND T1.subtypes IS NOT NULL\nAND T1.supertypes IS NOT NULL\nORDER BY T1.subtypes, T1.supertypes"
        ],
        "amend_res": 1
    },
    "292": {
        "db_id": "toxicology",
        "question": "Identify the atoms belong to the molecule with ID between TR010 to TR050 that contain the element carbon.",
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'",
        "amends": [
            "Do specify `T.atom_id` in the SELECT list instead of using `*` to select all columns. Do use the table alias `T` consistently with `T.atom_id`, `T.molecule_id`, and `T.element` instead of referencing columns without aliases. Do use lowercase `'c'` for the element filter instead of `'carbon'` to match the correct data values. Do reference the table as `atom` instead of `atoms` to use the correct table name. The amended query now correctly selects only atom IDs for carbon elements within the specified molecule range."
        ],
        "rules": [
            "1) When selecting from the atom table: use the exact table name \"atom\" instead of \"atoms\". 2) When filtering by element: use the exact literal 'c' instead of 'carbon' to match the correct data values. 3) When selecting specific columns: explicitly specify T.atom_id instead of using * to select all columns. 4) When referencing columns: use the table alias T consistently with T.atom_id, T.molecule_id, and T.element instead of referencing columns without aliases."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM atoms WHERE molecule_id BETWEEN 'TR010' AND 'TR050' AND element = 'carbon';",
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'"
        ],
        "rule_sql": [
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id BETWEEN 'TR010' AND 'TR050' AND T.element = 'c'"
        ],
        "amend_res": 1
    },
    "402": {
        "db_id": "card_games",
        "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
        "amends": [
            "Do use `SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END)` to count non-textless cards instead of `COUNT(*)` with a `text IS NULL` filter. Do calculate percentage as `* 100 / COUNT(id)` instead of `* 100.0 / (SELECT COUNT(*) FROM cards WHERE type = 'Story Spotlight')`. Do filter with `WHERE isStorySpotlight = 1` instead of `WHERE type = 'Story Spotlight' AND text IS NULL`. Do remove `GROUP BY id` and aggregate at the overall level instead of grouping by individual IDs. Do use `CAST(... AS REAL)` for precise division instead of implicit casting with `100.0`. Do reference `isTextless` and `isStorySpotlight` boolean columns instead of `type` string and `text` NULL checks. The amended query now correctly calculates the percentage of non-textless cards among story spotlight cards."
        ],
        "rules": [
            "1) When the question asks for percentage of Story Spotlight cards that do not have a text box: use boolean column \"isStorySpotlight\" = 1 to identify Story Spotlight cards instead of string column \"type\" = 'Story Spotlight'. 2) When counting cards without text boxes: use boolean column \"isTextless\" = 0 to identify non-textless cards instead of checking \"text IS NULL\". 3) When calculating percentage: compute (SUM(CASE WHEN \"isTextless\" = 0 THEN 1 ELSE 0 END) * 100 / COUNT(\"id\")) with CAST to REAL for precise division instead of implicit casting with 100.0. 4) When the question asks for overall percentage: aggregate at the overall level without GROUP BY \"id\" instead of grouping by individual IDs. 5) When combining conditions: filter with WHERE \"isStorySpotlight\" = 1 instead of WHERE \"type\" = 'Story Spotlight' AND \"text IS NULL\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE type = 'Story Spotlight')) AS percentage FROM cards WHERE type = 'Story Spotlight' AND text IS NULL GROUP BY id;",
            "SELECT \n    CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(id) AS percentage\nFROM \n    cards\nWHERE \n    isStorySpotlight = 1;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN \"isTextless\" = 0 THEN 1 ELSE 0 END) * 100 AS REAL) / COUNT(\"id\") AS percentage\nFROM \n    \"cards\"\nWHERE \n    \"isStorySpotlight\" = 1;"
        ],
        "amend_res": 1
    },
    "96": {
        "db_id": "financial",
        "question": "How many customers who choose statement of weekly issuance are Owner?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK TYDNE'",
        "amends": [
            "Do select `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific account IDs rather than all rows. Do join `account AS T1 INNER JOIN disp AS T2` instead of querying only the `customers` table to properly relate accounts with their dispositions. Do filter on `T2.type = 'OWNER'` instead of `occupation = 'Owner'` to use the correct column and value from the disposition table. Do filter on `T1.frequency = 'POPLATEK TYDNE'` instead of `issuance_type = 'weekly'` to use the appropriate frequency column with the correct Czech value meaning 'weekly'. The amended query now correctly counts account owners with weekly frequency by properly joining account and disposition tables."
        ],
        "rules": [
            "1) When counting customers who choose weekly issuance: use COUNT(T1.account_id) to count specific account IDs rather than all rows. 2) When relating accounts with dispositions: join account AS T1 INNER JOIN disp AS T2 to properly connect accounts with their disposition information. 3) When filtering for owner status: use T2.type = 'OWNER' instead of occupation columns to check for account ownership. 4) When filtering for weekly issuance frequency: use T1.frequency = 'POPLATEK TYDNE' with the exact Czech value meaning 'weekly' instead of 'issuance_type' columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE issuance_type = 'weekly' AND occupation = 'Owner';",
            "SELECT COUNT(T1.account_id) \nFROM account AS T1 \nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id \nWHERE T1.frequency = 'POPLATEK TYDNE' \nAND T2.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM account AS T1 \nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id \nWHERE T1.frequency = 'POPLATEK TYDNE' \nAND T2.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "1030": {
        "db_id": "european_football_2",
        "question": "Give the name of the league had the most matches end as draw in the 2016 season?",
        "ground_truth": "SELECT t2.name FROM Match AS t1 INNER JOIN League AS t2 ON t1.league_id = t2.id WHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal GROUP BY t2.name ORDER BY COUNT(t1.id) DESC LIMIT 1",
        "amends": [
            "Do select `t2.name` from the `League` table instead of `league_name` from `leagues`. Do join `Match AS t1` with `League AS t2` using `INNER JOIN` on `t1.league_id = t2.id` instead of querying only the `leagues` table. Do filter by `t1.season = '2015/2016'` instead of `season = '2016'`. Do add the condition `t1.home_team_goal = t1.away_team_goal` to identify draws instead of checking `result = 'draw'`. Do use `GROUP BY t2.name` with `COUNT(t1.id)` aggregation instead of a correlated subquery in the ORDER BY clause. Do order by `COUNT(t1.id) DESC` directly instead of ordering by a subquery result. The amended query now correctly counts draw matches per league for the 2015/2016 season and returns the league with the most draws, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about league names: use \"t2.name\" from the \"League\" table instead of \"league_name\" from \"leagues\". 2) When combining match and league data: perform an inner join between \"Match AS t1\" and \"League AS t2\" where \"t1.league_id = t2.id\". 3) When filtering for the 2016 season: use \"t1.season = '2015/2016'\" instead of \"season = '2016'\". 4) When identifying draw matches: use the condition \"t1.home_team_goal = t1.away_team_goal\" instead of checking for \"result = 'draw'\". 5) When counting matches per league: use \"GROUP BY t2.name\" with \"COUNT(t1.id)\" aggregation. 6) When finding the league with most draws: order by \"COUNT(t1.id) DESC\" and take the top result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT league_name \nFROM leagues \nWHERE season = '2016' \nORDER BY (SELECT COUNT(*) FROM matches WHERE result = 'draw' AND league_id = leagues.id) DESC \nLIMIT 1;",
            "SELECT t2.name \nFROM Match AS t1 \nINNER JOIN League AS t2 ON t1.league_id = t2.id \nWHERE t1.season = '2015/2016' \nAND t1.home_team_goal = t1.away_team_goal \nGROUP BY t2.name \nORDER BY COUNT(t1.id) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.name \nFROM Match AS t1\nINNER JOIN League AS t2 ON t1.league_id = t2.id\nWHERE t1.season = '2015/2016' AND t1.home_team_goal = t1.away_team_goal\nGROUP BY t2.name\nORDER BY COUNT(t1.id) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "370": {
        "db_id": "card_games",
        "question": "How many borderless cards are illustrated in Russian?",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.borderColor = 'borderless' AND T2.language = 'Russian'",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `foreign_data AS T2` with `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying a single table. Do filter on `T1.borderColor = 'borderless'` instead of `border = 'borderless'` to use the correct column name. Do filter on `T2.language = 'Russian'` instead of `language = 'Russian'` to reference the joined table's column. The amended query now correctly counts Russian borderless cards by properly joining the cards and foreign_data tables."
        ],
        "rules": [
            "1) When counting cards: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When combining cards and foreign_data tables: link rows where T1.uuid = T2.uuid using an inner join and keep only matching pairs. 3) When filtering for borderless cards: use T1.borderColor = 'borderless' instead of border = 'borderless' to reference the correct column. 4) When filtering for Russian language: use T2.language = 'Russian' instead of language = 'Russian' to reference the joined table's column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE border = 'borderless' AND language = 'Russian';",
            "SELECT COUNT(T1.id) \nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.borderColor = 'borderless' \nAND T2.language = 'Russian'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.borderColor = 'borderless' \nAND T2.language = 'Russian'"
        ],
        "amend_res": 1
    },
    "498": {
        "db_id": "card_games",
        "question": "What's the French name of the set of cards with \"Tendo Ice Bridge\" is in?",
        "ground_truth": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Tendo Ice Bridge' AND T2.language = 'French' AND T2.translation IS NOT NULL",
        "amends": [
            "Do select `T2.translation` instead of `french_name` from the result set. Do add `INNER JOIN set_translations AS T2` on `T2.setCode = T1.setCode` instead of querying only the `cards` table. Do add filter conditions `T2.language = 'French'` and `T2.translation IS NOT NULL` instead of omitting them. Do change the filter condition to `T1.name = 'Tendo Ice Bridge'` instead of `card_name = 'Tendo Ice Bridge'`. The amended query now correctly retrieves French translations from the set_translations table based on set codes and language filters, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for the French name of a set containing a specific card: select T2.translation instead of french_name from the result set. 2) When combining cards and set_translations tables: link rows where T2.setCode = T1.setCode using an inner join. 3) When filtering for French translations: add conditions T2.language = 'French' and T2.translation IS NOT NULL. 4) When filtering for a specific card name: use T1.name = 'Tendo Ice Bridge' instead of card_name = 'Tendo Ice Bridge'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT french_name FROM cards WHERE card_name = 'Tendo Ice Bridge';",
            "SELECT T2.translation\nFROM cards AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Tendo Ice Bridge'\nAND T2.language = 'French'\nAND T2.translation IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT T2.translation\nFROM cards T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Tendo Ice Bridge'\nAND T2.language = 'French'\nAND T2.translation IS NOT NULL"
        ],
        "amend_res": 1
    },
    "54": {
        "db_id": "california_schools",
        "question": "Please specify all of the schools and their related mailing zip codes that are under Avetik Atoian's administration.",
        "evidence": "",
        "ground_truth": "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian'",
        "amends": [
            "Do select `School` and `MailZip` columns instead of `school_name` and `zip_code`. Do filter on both `AdmFName1 = 'Avetik'` and `AdmLName1 = 'Atoian'` conditions instead of a single `administrator = 'Avetik Atoian'` filter. The amended query now correctly matches the RIGHT_SQL's behavior by using the proper column names and splitting the administrator name into separate first and last name fields."
        ],
        "rules": [
            "1) When selecting school information: use column \"School\" instead of \"school_name\" and column \"MailZip\" instead of \"zip_code\". 2) When filtering by administrator name \"Avetik Atoian\": split into separate conditions for first name \"AdmFName1 = 'Avetik'\" and last name \"AdmLName1 = 'Atoian'\". 3) When outputting results: maintain the column order with \"School\" first followed by \"MailZip\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, zip_code FROM schools WHERE administrator = 'Avetik Atoian';",
            "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';"
        ],
        "rule_sql": [
            "SELECT School, MailZip FROM schools WHERE AdmFName1 = 'Avetik' AND AdmLName1 = 'Atoian';"
        ],
        "amend_res": 1
    },
    "935": {
        "db_id": "formula_1",
        "question": "How many drivers managed to finish the race in the 2008 Australian Grand Prix?",
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Australian Grand Prix' AND T1.year = 2008 AND T2.time IS NOT NULL",
        "amends": [
            "Do select `COUNT(T2.driverId)` instead of `COUNT(*)` to count specific drivers rather than all rows. Do use `races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId` instead of querying only the `drivers` table to properly join race and result data. Do filter with `T1.name = 'Australian Grand Prix'` and `T1.year = 2008` instead of `race_year` and `race_name` to use the correct column names from the joined tables. Do add `T2.time IS NOT NULL` instead of `position = 'finished'` to properly identify finished drivers by checking for non-null time values. The amended query now correctly counts drivers who finished the specified race by joining the appropriate tables and using the correct finish condition."
        ],
        "rules": [
            "1) When counting drivers who finished a race: use COUNT(T2.driverId) to count specific drivers rather than all rows. 2) When answering about race results: join races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId to properly combine race and result data. 3) When filtering for a specific race: use T1.name = 'Australian Grand Prix' and T1.year = 2008 to match the exact race name and year. 4) When identifying finished drivers: use T2.time IS NOT NULL instead of position checks to properly identify drivers who completed the race."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE race_year = 2008 AND race_name = 'Australian Grand Prix' AND position = 'finished';",
            "SELECT COUNT(T2.driverId) \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nWHERE T1.name = 'Australian Grand Prix' \nAND T1.year = 2008 \nAND T2.time IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.driverId) \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nWHERE T1.name = 'Australian Grand Prix' \nAND T1.year = 2008 \nAND T2.time IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1357": {
        "db_id": "student_club",
        "question": "State the date Connor Hilton paid his/her dues.",
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Connor' AND T1.last_name = 'Hilton' AND T2.source = 'Dues'",
        "amends": [
            "Do select `T2.date_received` instead of `payment_date`. Do use `member AS T1` and `income AS T2` with an `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying only the `members` table. Do filter with `T1.first_name = 'Connor'` and `T1.last_name = 'Hilton'` instead of `name = 'Connor Hilton'`. Do filter with `T2.source = 'Dues'` instead of `payment_type = 'dues'`. The amended query now correctly joins member and income tables to retrieve dues payment dates with proper name matching."
        ],
        "rules": [
            "1) When answering about payment dates for dues: use T2.date_received instead of payment_date. 2) When the question mentions a member's name: split into T1.first_name = 'Connor' and T1.last_name = 'Hilton' instead of using a single name field. 3) When the question mentions dues payment: use T2.source = 'Dues' instead of payment_type = 'dues'. 4) When combining member and income information: link tables using T1.member_id = T2.link_to_member with an inner match to keep only records with corresponding entries in both tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT payment_date FROM members WHERE name = 'Connor Hilton' AND payment_type = 'dues';",
            "SELECT T2.date_received \nFROM member AS T1 \nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Connor' \nAND T1.last_name = 'Hilton' \nAND T2.source = 'Dues'"
        ],
        "rule_sql": [
            "SELECT T2.date_received \nFROM member T1 \nINNER JOIN income T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Connor' \nAND T1.last_name = 'Hilton' \nAND T2.source = 'Dues'"
        ],
        "amend_res": 1
    },
    "529": {
        "db_id": "card_games",
        "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
        "ground_truth": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
        "amends": [
            "Do filter with `code IN (subquery)` instead of checking `japanese_translation IS NOT NULL AND korean_translation IS NULL` directly. Do use a correlated subquery `SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%'` instead of relying on NULL checks on translation columns. Do remove the direct column references `japanese_translation` and `korean_translation` from the WHERE clause instead of keeping them. The amended query now correctly identifies sets with Korean translations while excluding those with Japanese translations by using the translation metadata table instead of direct column checks, matching the RIGHT_SQL's behavior.",
            "Do select only `name` instead of both `s.code` and `s.name`. Do remove the second subquery checking for Japanese language and instead add a `language NOT LIKE '%Japanese%'` condition within the single subquery instead of having separate subqueries. Do simplify the subquery structure by using a single correlated subquery with combined conditions instead of multiple independent subqueries. The amended query now correctly filters for sets with Korean translations while excluding any Japanese language entries through a more efficient single subquery approach.",
            "Do use a single subquery with `language NOT LIKE '%Japanese%'` instead of a nested subquery to exclude Japanese translations. Do remove the redundant `st2.setCode` subquery check and instead filter directly in the WHERE clause. Do simplify the logic by combining both language conditions in the same subquery level instead of using a NOT IN nested structure. Do maintain the same `SELECT name FROM sets` structure but with optimized subquery filtering. The amended query now correctly identifies Korean sets that don't have Japanese translations using a more efficient single-level subquery approach."
        ],
        "rules": [
            "1) When answering about sets with Korean translation but no Japanese translation: use a subquery to filter sets based on translation metadata instead of direct column checks. 2) When filtering sets by translation availability: check for sets where code exists in the subquery results from set_translations where language equals 'Korean' and language does not contain 'Japanese'. 3) When handling translation metadata: use the exact literal 'Korean' for Korean translations and the pattern '%Japanese%' to exclude Japanese translations. 4) When selecting output: return only the name column from the sets table.",
            "1) When answering about \"sets which doesn't have Japanese translation but have Korean translation\": make sure the output order: s.name only. 2) When the question mentions \"sets\": \"sets\" actually means \"s.name in schema\". 3) When filtering for Korean translations: use exact literal 'Korean' for st.language. 4) When excluding Japanese translations: use condition language NOT LIKE '%Japanese%' within the same subquery. 5) When combining set and translation information: link rows where st.setCode matches s.code. 6) When handling text literals: do not change case, spacing, or punctuation for 'Korean' or '%Japanese%'.",
            "1) When answering about sets with Korean translation but no Japanese translation: use a single subquery to filter set_translations where language equals 'Korean' and language does not contain 'Japanese' 2) When filtering set translations: check for exact language match to 'Korean' and use pattern matching with NOT LIKE '%Japanese%' to exclude Japanese translations 3) When selecting set names: maintain the SELECT name FROM sets structure and filter using the optimized subquery approach 4) When combining conditions for language filtering: place both language = 'Korean' and language NOT LIKE '%Japanese%' conditions at the same subquery level instead of using nested NOT IN structures"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE japanese_translation IS NOT NULL AND korean_translation IS NULL;",
            "SELECT s.code, s.name \nFROM sets s \nWHERE s.code IN (\n    SELECT st.setCode \n    FROM set_translations st \n    WHERE st.language = 'Korean'\n) \nAND s.code NOT IN (\n    SELECT st.setCode \n    FROM set_translations st \n    WHERE st.language = 'Japanese'\n);",
            "SELECT s.name\nFROM sets s\nWHERE s.code IN (\n    SELECT st.setCode\n    FROM set_translations st\n    WHERE st.language = 'Korean'\n    AND st.setCode NOT IN (\n        SELECT st2.setCode\n        FROM set_translations st2\n        WHERE st2.language LIKE '%Japanese%'\n    )\n);",
            "SELECT name FROM sets WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%')"
        ],
        "rule_sql": [
            "SELECT s.name \nFROM sets s\nWHERE s.code IN (\n    SELECT st.setCode \n    FROM set_translations st \n    WHERE st.language = 'Korean' \n    AND st.language NOT LIKE '%Japanese%'\n)"
        ],
        "amend_res": 1
    },
    "362": {
        "db_id": "card_games",
        "question": "What is the description about the ruling of card \"Condemn\"?",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
        "amends": [
            "Do select `T2.text` instead of `name` and do add the `rulings` table via `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do change the FROM clause to include both `cards AS T1` and `rulings AS T2` instead of just `cards`, and do add the join condition `ON T1.uuid = T2.uuid` instead of having no join. Do keep the WHERE filter on `T1.name = 'Condemn'` but apply it to the joined table structure instead of the single table. The amended query now correctly retrieves ruling text from the rulings table for the specified card name."
        ],
        "rules": [
            "1) When answering about card ruling descriptions: make sure the output order: T2.text 2) When the question mentions \"card 'Condemn'\": \"card 'Condemn'\" actually means \"T1.name = 'Condemn'\" in schema 3) When combining T1 (cards) and T2 (rulings) for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation - keep 'Condemn' exactly as specified"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE name = 'Condemn';",
            "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'"
        ],
        "rule_sql": [
            "SELECT T2.text FROM cards T1 INNER JOIN rulings T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'"
        ],
        "amend_res": 1
    },
    "931": {
        "db_id": "formula_1",
        "question": "What was the fastest lap speed among all drivers in the 2009 Spanish Grand Prix?",
        "ground_truth": "SELECT T2.fastestLapSpeed FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.name = 'Spanish Grand Prix' AND T1.year = 2009 AND T2.fastestLapSpeed IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [
            "Do select `fastestLapSpeed` from the `results` table instead of `MAX(lap_time)` from `lap_times`. Do join `races` with `results` using `INNER JOIN` on `T2.raceId = T1.raceId` instead of using a subquery to find the race_id. Do add filters for `T1.name = 'Spanish Grand Prix'` and `T1.year = 2009` in the WHERE clause instead of only in the subquery. Do add `T2.fastestLapSpeed IS NOT NULL` to exclude null values instead of omitting this filter. Do add `ORDER BY T2.fastestLapSpeed DESC` and `LIMIT 1` to get the maximum value instead of using the MAX aggregate function. The amended query now correctly retrieves the fastest lap speed from the results table for the specified race instead of attempting to find maximum lap time from a different table."
        ],
        "rules": [
            "1) When answering about fastest lap speed: use column \"fastestLapSpeed\" from table \"results\" instead of \"lap_time\" from \"lap_times\". 2) When combining races and results tables: link rows where \"T2.raceId = T1.raceId\" using inner join. 3) When filtering for the 2009 Spanish Grand Prix: apply conditions \"T1.name = 'Spanish Grand Prix'\" and \"T1.year = 2009\". 4) When handling null values: exclude rows where \"T2.fastestLapSpeed IS NOT NULL\". 5) When finding the maximum fastest lap speed: order by \"T2.fastestLapSpeed DESC\" and take the first row instead of using MAX aggregate function."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(lap_time) FROM lap_times WHERE race_id = (SELECT race_id FROM races WHERE year = 2009 AND name = 'Spanish Grand Prix')",
            "SELECT T2.fastestLapSpeed \nFROM races T1\nINNER JOIN results T2 ON T2.raceId = T1.raceId\nWHERE T1.name = 'Spanish Grand Prix' \nAND T1.year = 2009\nAND T2.fastestLapSpeed IS NOT NULL\nORDER BY T2.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.fastestLapSpeed \nFROM races T1\nINNER JOIN results T2 ON T2.raceId = T1.raceId\nWHERE T1.name = 'Spanish Grand Prix' \nAND T1.year = 2009\nAND T2.fastestLapSpeed IS NOT NULL\nORDER BY T2.fastestLapSpeed DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1516": {
        "db_id": "debit_card_specializing",
        "question": "How many transactions were paid in CZK in the morning of 2012/8/26?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-26' AND T1.Time < '13:00:00' AND T2.Currency = 'CZK'",
        "amends": [
            "Do join `transactions_1k AS T1` with `customers AS T2` on `T1.CustomerID = T2.CustomerID` instead of querying a single `transactions` table without any joins. Do filter by `T2.Currency = 'CZK'` instead of `currency = 'CZK'` since the currency information is now correctly sourced from the customers table. Do use `T1.Time < '13:00:00'` instead of `time BETWEEN '00:00:00' AND '11:59:59'` to capture the correct time range. Do count `T1.TransactionID` instead of `COUNT(*)` for more precise counting of transaction records. The amended query now correctly joins the necessary tables and applies proper filtering to match the intended behavior.",
            "Do use the standard date format `2012-08-26` with hyphens instead of `2012/8/26` with slashes and missing zero-padding for proper date handling. Do specify `INNER JOIN` explicitly instead of the implicit `JOIN` syntax for clarity. The amended query now correctly filters transactions from August 26, 2012, before 13:00:00 for CZK currency customers, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about transactions paid in CZK: join transactions_1k AS T1 with customers AS T2 on T1.CustomerID = T2.CustomerID to access currency information from the customers table. 2) When filtering for CZK currency: use T2.Currency = 'CZK' instead of currency = 'CZK' since currency information is sourced from the customers table. 3) When filtering for morning time: use T1.Time < '13:00:00' instead of time BETWEEN '00:00:00' AND '11:59:59' to capture the correct morning time range. 4) When counting transactions: count T1.TransactionID instead of using COUNT(*) for more precise counting of transaction records.",
            "1) When handling date literals in the question: use the standard date format '2012-08-26' with hyphens and zero-padding instead of '2012/8/26' with slashes. 2) When joining tables: explicitly specify INNER JOIN instead of implicit JOIN syntax for clarity. 3) When filtering transactions by date and time: use T1.Date = '2012-08-26' AND T1.Time < '13:00:00' to capture morning transactions. 4) When filtering by currency: use T2.Currency = 'CZK' to match Czech Koruna transactions. 5) When counting transactions: use T1.TransactionID as the counting key for accurate transaction counts."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE currency = 'CZK' AND date = '2012-08-26' AND time BETWEEN '00:00:00' AND '11:59:59';",
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1\nJOIN customers AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Date = '2012/8/26' \nAND T1.Time < '13:00:00'\nAND T2.Currency = 'CZK'",
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1 \nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Date = '2012-08-26' \nAND T1.Time < '13:00:00' \nAND T2.Currency = 'CZK'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1 \nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Date = '2012-08-26' \nAND T1.Time < '13:00:00' \nAND T2.Currency = 'CZK'"
        ],
        "amend_res": 1
    },
    "952": {
        "db_id": "formula_1",
        "question": "Which constructors have been ranked 1?",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.name FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.rank = 1",
        "amends": [
            "Do select `T2.name` with `DISTINCT` instead of `*` without distinct. Do add `results AS T1` table with `INNER JOIN` on `T1.constructorId = T2.constructorId` instead of querying only `constructors` table. Do filter on `T1.rank = 1` with integer comparison instead of `rank = '1'` with string comparison. The amended query now correctly identifies constructors with race results ranked first position."
        ],
        "rules": [
            "1) When answering about \"constructors ranked 1\": make sure the output order: T2.name. 2) When the question mentions \"constructors\": \"constructors\" actually means \"T2.name in schema\". 3) When combining T1 (results) and T2 (constructors) for shared entities: link rows where T1.constructorId = T2.constructorId exactly as shown; keep only matching pairs (inner match). 4) When filtering for rank 1: use T1.rank = 1 with integer comparison instead of string comparison. 5) When selecting constructor names: use DISTINCT T2.name instead of selecting all columns without distinct."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM constructors WHERE rank = '1';",
            "SELECT DISTINCT T2.name \nFROM results AS T1 \nINNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId \nWHERE T1.rank = 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name\nFROM results T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T1.rank = 1\nORDER BY T2.name;"
        ],
        "amend_res": 1
    },
    "83": {
        "db_id": "california_schools",
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "ground_truth": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "amends": [
            "Do select `T2.City` and `COUNT(T2.CDSCode)` instead of `city`, `COUNT(*)`, and the CASE expression for magnet schools. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the schools table. Do filter with `T2.Magnet = 1`, `T2.GSoffered = 'K-8'`, and `T1.NSLP Provision Status = 'Multiple Provision Types'` instead of only `grade_span = 'Kindergarten to 8th grade'`. Do group by `T2.City` instead of `city` and remove the ORDER BY clause instead of keeping it. The amended query now correctly counts magnet schools with K-8 grade span that have multiple provision types by joining with the frpm table and filtering on the appropriate conditions."
        ],
        "rules": [
            "1) When answering about schools with magnet programs and K-8 grade span: join \"frpm\" as T1 with \"schools\" as T2 using T1.CDSCode = T2.CDSCode to combine data from both tables. 2) When filtering for magnet schools with K-8 grade span: apply conditions T2.Magnet = 1, T2.GSoffered = 'K-8', and T1.\"NSLP Provision Status\" = 'Multiple Provision Types'. 3) When counting schools per city: use T2.City for grouping and count using T2.CDSCode as the canonical key instead of counting all rows. 4) When the question asks for number of cities and schools per city: output T2.City and COUNT(T2.CDSCode) without additional ordering. 5) When handling identifier delimiters: preserve double quotes for \"NSLP Provision Status\" exactly as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    city,\n    COUNT(*) as number_of_schools,\n    COUNT(CASE WHEN provision_types = 'Multiple Provision Types' THEN 1 END) as magnet_schools_with_multiple_provisions\nFROM schools\nWHERE grade_span = 'Kindergarten to 8th grade'\nGROUP BY city\nORDER BY number_of_schools DESC;",
            "SELECT T2.City, COUNT(T2.CDSCode) \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.Magnet = 1 \nAND T2.GSoffered = 'K-8' \nAND T1.\"NSLP Provision Status\" = 'Multiple Provision Types' \nGROUP BY T2.City"
        ],
        "rule_sql": [
            "SELECT T2.City, COUNT(T2.CDSCode) AS SchoolCount\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.Magnet = 1\nAND T2.GSoffered = 'K-8'\nAND T1.\"NSLP Provision Status\" = 'Multiple Provision Types'\nGROUP BY T2.City;"
        ],
        "amend_res": 1
    },
    "244": {
        "db_id": "toxicology",
        "question": "Is the molecule with the most double bonds carcinogenic?",
        "ground_truth": "SELECT T1.label FROM molecule AS T1 INNER JOIN ( SELECT T.molecule_id, COUNT(T.bond_type) FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id ORDER BY COUNT(T.bond_type) DESC LIMIT 1 ) AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do select `T1.label` instead of `carcinogenic`. Do add a `FROM` clause with `molecule AS T1` instead of `molecules`. Do add an `INNER JOIN` with a subquery instead of a simple table reference. Do use the subquery to select `T.molecule_id` and `COUNT(T.bond_type)` from `bond AS T` instead of querying directly from molecules. Do add a `WHERE T.bond_type = '='` filter instead of no filter. Do add `GROUP BY T.molecule_id` instead of no grouping. Do order by `COUNT(T.bond_type) DESC` instead of `double_bonds DESC`. Do maintain the `LIMIT 1` but apply it within the subquery instead of the main query. Do add an `ON T1.molecule_id = T2.molecule_id` join condition instead of no join condition. The amended query now correctly identifies the molecule with the most double bonds by counting bond_type '=' records and joining to get the corresponding label."
        ],
        "rules": [
            "1) When answering about \"the molecule with the most double bonds\": make sure the output order: T1.label 2) When the question mentions \"double bonds\": \"double bonds\" actually means \"bond_type = '=' in schema\" 3) When the question asks for \"most double bonds\": rank rows by COUNT(T.bond_type) in descending direction and keep the first 1 row. 4) When counting double bonds: compute the number of rows using the exact condition T.bond_type = '=' grouped by T.molecule_id. 5) When combining molecule and bond tables for shared entities: link rows where T1.molecule_id = T2.molecule_id exactly as shown; keep only matching pairs (inner match). 6) When the question implies ordering ties: break ties using the canonical key T.molecule_id if needed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic FROM molecules ORDER BY double_bonds DESC LIMIT 1;",
            "SELECT T1.label\nFROM molecule AS T1\nINNER JOIN (\n    SELECT T.molecule_id, COUNT(T.bond_type) AS double_bond_count\n    FROM bond AS T\n    WHERE T.bond_type = '='\n    GROUP BY T.molecule_id\n    ORDER BY COUNT(T.bond_type) DESC\n    LIMIT 1\n) AS T2 ON T1.molecule_id = T2.molecule_id"
        ],
        "rule_sql": [
            "SELECT m.label\nFROM molecule m\nJOIN bond b ON m.molecule_id = b.molecule_id\nWHERE b.bond_type = '='\nGROUP BY m.molecule_id\nORDER BY COUNT(b.bond_type) DESC, m.molecule_id\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "82": {
        "db_id": "california_schools",
        "question": "What is the grade span offered in the school with the highest longitude?",
        "ground_truth": "SELECT GSoffered FROM schools ORDER BY ABS(longitude) DESC LIMIT 1",
        "amends": [
            "Do use `ABS(longitude)` in the ORDER BY clause instead of `longitude` to sort by absolute value rather than raw longitude. Do select `GSoffered` instead of `grade_span` as the output column. End with confirmation that the amended query now correctly selects the offered grade span from the school with the maximum absolute longitude value."
        ],
        "rules": [
            "1) When the question asks about \"grade span offered\": use the exact column name \"GSoffered\" from the schools table. 2) When the question asks for the school with the \"highest longitude\": use the absolute value of longitude (ABS(longitude)) for ordering to find the maximum absolute longitude value. 3) When ordering by longitude to find the highest value: sort in descending order (DESC) and take only the first result (LIMIT 1)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade_span FROM schools ORDER BY longitude DESC LIMIT 1;",
            "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "581": {
        "db_id": "codebase_community",
        "question": "Who is the editor of the post titled 'Open source tools for visualizing multi-dimensional data?'",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
        "amends": [
            "Do select `T2.DisplayName` instead of `editor` to properly reference the joined table's column. Do add `FROM posts AS T1 INNER JOIN users AS T2` instead of just `FROM posts` to include the necessary join with the users table. Do specify `ON T1.OwnerUserId = T2.Id` instead of omitting the join condition to correctly link the tables. Do keep the `WHERE` filter on `T1.Title` unchanged as it remains correct. The amended query now properly retrieves the display name from the joined users table instead of attempting to access a non-existent editor column, matching the right SQL's behavior.",
            "Do join on `T1.OwnerUserId = T2.Id` instead of `T1.LastEditorUserId = T2.Id` to correctly associate posts with their original owners rather than last editors, ensuring the query returns the intended post creators for the specified title."
        ],
        "rules": [
            "1) When the question asks for \"editor\" of a post: \"editor\" actually means \"T2.DisplayName\" from the users table. 2) When combining posts and users tables: link rows where T1.OwnerUserId = T2.Id and keep only matching pairs (inner match). 3) When filtering by post title: use T1.Title = 'Open source tools for visualizing multi-dimensional data?' exactly as specified with the exact case, spacing, and punctuation.",
            "1) When the question asks about the \"editor\" of a post: use the \"OwnerUserId\" column from the posts table (T1) instead of \"LastEditorUserId\" to correctly identify the original post creator. 2) When joining posts (T1) and users (T2) tables: link rows where T1.OwnerUserId = T2.Id to associate posts with their original owners. 3) When filtering for a specific post title: use the exact literal 'Open source tools for visualizing multi-dimensional data?' with the exact case, spacing, and punctuation as shown in the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT editor FROM posts WHERE title = 'Open source tools for visualizing multi-dimensional data?'",
            "SELECT T2.DisplayName \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id \nWHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'",
            "SELECT T2.DisplayName \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName \nFROM posts T1 \nINNER JOIN users T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'"
        ],
        "amend_res": 1
    },
    "599": {
        "db_id": "codebase_community",
        "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
        "evidence": "",
        "ground_truth": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT ph.PostHistoryTypeId, COUNT(DISTINCT c.UserId) AS unique_users\nFROM PostHistory ph\nLEFT JOIN Comments c ON ph.PostId = c.PostId\nWHERE ph.PostId = 3720\nGROUP BY ph.PostHistoryTypeId"
        ],
        "rule_sql": [
            "SELECT \n    ph.PostHistoryTypeId,\n    COUNT(DISTINCT c.UserId) AS unique_commenters\nFROM \n    postHistory ph\nLEFT JOIN \n    comments c ON ph.PostId = c.PostId\nWHERE \n    ph.PostId = 3720\nGROUP BY \n    ph.PostHistoryTypeId;"
        ],
        "amend_res": 1
    },
    "423": {
        "db_id": "card_games",
        "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
        "ground_truth": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
        "amends": [
            "Do select `cardKingdomFoilId` and `cardKingdomId` columns instead of `kingdom_foil_id` and `kingdom_card_id` aliases. Do query from `cards` table instead of joining `KingdomFoil` and `KingdomCards` tables. Do add `WHERE` filters for `cardKingdomFoilId IS NOT NULL` and `cardKingdomId IS NOT NULL` instead of omitting null checks. Do order by `cardKingdomFoilId` instead of `kf.id` while maintaining ascending order. Do keep `LIMIT 3` unchanged. The amended query now correctly retrieves non-null card kingdom identifiers from the single cards table instead of attempting an incorrect join between separate kingdom tables."
        ],
        "rules": [
            "1) When answering about \"top three powerful pairs of Kingdom Foil and Kingdom Cards\": select the exact columns \"cardKingdomFoilId\" and \"cardKingdomId\" from the \"cards\" table. 2) When filtering for valid pairs: ensure both \"cardKingdomFoilId IS NOT NULL\" and \"cardKingdomId IS NOT NULL\" to exclude null values. 3) When ordering results alphabetically by Kingdom Foil id: sort by \"cardKingdomFoilId\" in ascending order. 4) When limiting to top three results: keep only the first 3 rows after ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT kf.id AS kingdom_foil_id, kc.id AS kingdom_card_id\nFROM KingdomFoil kf\nJOIN KingdomCards kc ON kf.id = kc.id\nORDER BY kf.id ASC\nLIMIT 3;",
            "SELECT cardKingdomFoilId, cardKingdomId \nFROM cards \nWHERE cardKingdomFoilId IS NOT NULL \nAND cardKingdomId IS NOT NULL \nORDER BY cardKingdomFoilId ASC \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId ASC LIMIT 3;"
        ],
        "amend_res": 1
    },
    "491": {
        "db_id": "card_games",
        "question": "What's the magic card market name for the set which was released on 2017/6/9?",
        "ground_truth": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
        "amends": [
            "Do use column `mcmName` instead of `name` in the SELECT list. Do use column `releaseDate` instead of `release_date` in the WHERE filter. Do use date format `'2017-06-09'` with hyphens instead of `'2017/6/9'` with slashes and inconsistent zero-padding. The amended query now correctly references the actual column names and uses proper date formatting to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"magic card market name\": use the exact column \"mcmName\" from table \"sets\" instead of \"name\". 2) When filtering by release date: use the exact column \"releaseDate\" from table \"sets\" with date format 'YYYY-MM-DD' and proper zero-padding. 3) When the date in the question is '2017/6/9': convert it to the exact literal '2017-06-09' with hyphens and consistent zero-padding for month and day."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE release_date = '2017/6/9';",
            "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';"
        ],
        "rule_sql": [
            "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';"
        ],
        "amend_res": 1
    },
    "448": {
        "db_id": "card_games",
        "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and do select `T1.name` and `T1.type` with table aliases instead of `foreign_name` and `type` without qualification. Do add `INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid` instead of querying only the `cards` table, and do qualify the watermark filter as `T1.watermark` instead of just `watermark`. The amended query now correctly joins the tables and returns distinct results matching the RIGHT_SQL's behavior.",
            "Do select `T1.name` and `T1.type` instead of `T2.name` and `T2.type` to reference columns from the correct table while maintaining the same `INNER JOIN` on `T2.uuid = T1.uuid` and `WHERE` filter on `T1.watermark = 'abzan'` with `DISTINCT` preserved. The amended query now correctly retrieves card name and type from the cards table rather than the joined foreign_data table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"foreign name\" of a card: use \"T2.name\" from the foreign_data table instead of \"foreign_name\" from the cards table. 2) When joining cards and foreign_data tables: link rows where \"T2.uuid = T1.uuid\" and keep only matching pairs (inner match). 3) When filtering by watermark: use the exact token \"T1.watermark\" with the literal value 'abzan' exactly as specified. 4) When selecting results: use DISTINCT to return unique rows only. 5) When outputting columns: return \"T2.name\" (foreign name) first, then \"T1.type\" (card type) second, in that exact order.",
            "1) When the question asks for the foreign name and type of a card: select T1.name and T1.type from the cards table instead of T2.name and T2.type from foreign_data table. 2) When joining cards (T1) and foreign_data (T2) tables: use INNER JOIN on T2.uuid = T1.uuid to link matching rows. 3) When filtering for cards with abzan watermark: use WHERE T1.watermark = 'abzan' with exact literal value 'abzan'. 4) When ensuring unique results: apply DISTINCT to eliminate duplicate rows in the output."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT foreign_name, type FROM cards WHERE watermark = 'abzan';",
            "SELECT DISTINCT T2.name, T2.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'abzan'",
            "SELECT DISTINCT T1.name, T1.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'abzan'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name, T1.type FROM cards T1 INNER JOIN foreign_data T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan';"
        ],
        "amend_res": 1
    },
    "316": {
        "db_id": "toxicology",
        "question": "Among the molecules which contain \"c\" element, which of them are not carcinogenic?",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'",
        "amends": [
            "Do query from `atom AS T1 INNER JOIN molecule AS T2` instead of just `molecules` table. Do filter on `T1.element = 'c'` instead of `element LIKE '%c%'`. Do add `T2.label = '-'` condition instead of `carcinogenic = 'yes'`. Do select only `DISTINCT T1.molecule_id` instead of all columns with `SELECT *`. Do use explicit join condition `T1.molecule_id = T2.molecule_id` instead of no join specification. The amended query now correctly identifies molecules containing carbon atoms with specific labels rather than using pattern matching and incorrect carcinogenic criteria."
        ],
        "rules": [
            "1) When answering about molecules containing \"c\" element: use table atom AS T1 INNER JOIN molecule AS T2 with join condition T1.molecule_id = T2.molecule_id instead of just the molecules table. 2) When filtering for \"c\" element: use exact equality T1.element = 'c' instead of pattern matching LIKE '%c%'. 3) When identifying non-carcinogenic molecules: use condition T2.label = '-' instead of carcinogenic = 'yes'. 4) When selecting output: use DISTINCT T1.molecule_id instead of all columns with SELECT *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE element LIKE '%c%' AND carcinogenic = 'yes';",
            "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'"
        ],
        "amend_res": 1
    },
    "1433": {
        "db_id": "student_club",
        "question": "Which countries have zip codes with post office boxes?",
        "ground_truth": "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL",
        "amends": [
            "Do select `DISTINCT county` instead of `country` and change the source table to `zip_code` instead of `addresses`. Do use a `WHERE` filter with `type = 'PO Box'` and `county IS NOT NULL` instead of `LIKE` patterns on `zip_code` column. Do remove the `OR` condition with multiple `LIKE` patterns and instead use a direct equality check on the `type` column. The amended query now correctly identifies PO Box locations by their type rather than pattern matching zip codes and ensures distinct county values with proper null handling, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"countries\" with zip codes: \"countries\" actually means \"county\" in the schema. 2) When selecting from the zip_code table: use DISTINCT county to get unique county values. 3) When filtering for post office boxes: use type = 'PO Box' instead of pattern matching on zip_code. 4) When handling null values: ensure county IS NOT NULL to exclude records with missing county information. 5) When the question mentions \"zip codes with post office boxes\": this refers to records where the type column equals 'PO Box' exactly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM addresses WHERE zip_code LIKE '%PO Box%' OR zip_code LIKE '%P.O. Box%';",
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT DISTINCT county FROM zip_code WHERE type = 'PO Box' AND county IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "1278": {
        "db_id": "thrombosis_prediction",
        "question": "Of the patients with an normal level of IGG, how many of them admitted to the hospital?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGG > 900 AND T2.IGG <2000 AND  T1.Admission = '+'",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific column instead of `COUNT(*)` from all rows. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.IGG > 900 AND T2.IGG <2000` for numeric range instead of `igg_level = 'normal'` string comparison. Do filter on `T1.Admission = '+'` instead of `admitted = 'yes'` with different column name and value format. The amended query now correctly counts patients with specific laboratory IgG values and admission status, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using exact key equality and keep only matching pairs (inner match). 3) When filtering for normal IgG levels: use T2.IGG > 900 AND T2.IGG < 2000 for numeric range instead of string comparison with 'normal'. 4) When filtering for hospital admission status: use T1.Admission = '+' instead of admitted = 'yes' with the exact column name and value format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE igg_level = 'normal' AND admitted = 'yes';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.IGG > 900 AND T2.IGG < 2000 \nAND T1.Admission = '+';"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.IGG > 900 AND T2.IGG < 2000 \nAND T1.Admission = '+';"
        ],
        "amend_res": 1
    },
    "1034": {
        "db_id": "european_football_2",
        "question": "List the players' api id who had the highest above average overall ratings in 2010.",
        "ground_truth": "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(`date`, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1",
        "amends": [
            "Do query the `Player_Attributes` table instead of the `players` table. Do select `player_api_id` instead of `api_id`. Do filter with `SUBSTR(date, 1, 4) = '2010'` instead of `year = 2010`. The amended query now correctly retrieves the highest-rated player from the 2010 season attributes data.",
            "Do use `ORDER BY overall_rating DESC LIMIT 1` instead of a subquery with `MAX(overall_rating)` to find the highest rated player. Do remove the correlated subquery that unnecessarily complicates the logic instead of keeping it. Do add explicit backticks around `date` column instead of omitting them for better SQL compatibility. The amended query now correctly identifies the single player with the highest overall rating in 2010 using a more efficient approach that matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about players' api id: select \"player_api_id\" instead of \"api_id\". 2) When the question mentions \"highest above average overall ratings in 2010\": use the \"Player_Attributes\" table instead of the \"players\" table. 3) When filtering for the year 2010: use SUBSTR(date, 1, 4) = '2010' instead of year = 2010. 4) When finding the highest rating: order by overall_rating in descending direction and keep the first row.",
            "1) When the question asks for \"highest above average overall ratings\": use ORDER BY overall_rating DESC LIMIT 1 instead of a subquery with MAX(overall_rating) to find the single highest rated player. 2) When handling the date column: use explicit backticks around `date` column for better SQL compatibility. 3) When filtering for year 2010: use SUBSTR(date, 1, 4) = '2010' to extract the year portion from the date string."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT api_id FROM players WHERE year = 2010 ORDER BY overall_rating DESC LIMIT 1;",
            "SELECT player_api_id\nFROM Player_Attributes\nWHERE SUBSTR(date, 1, 4) = '2010'\nAND overall_rating = (\n    SELECT MAX(overall_rating)\n    FROM Player_Attributes\n    WHERE SUBSTR(date, 1, 4) = '2010'\n)",
            "SELECT player_api_id \nFROM Player_Attributes \nWHERE SUBSTR(`date`, 1, 4) = '2010' \nORDER BY overall_rating DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT player_api_id FROM Player_Attributes WHERE SUBSTR(`date`, 1, 4) = '2010' ORDER BY overall_rating DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1216": {
        "db_id": "thrombosis_prediction",
        "question": "Sort in descending order all patients by birthday for male patient with albumin not within range.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC",
        "amends": [
            "Do select only `T1.ID` with `DISTINCT` instead of all columns with `*`. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T1.SEX = 'M'` instead of `gender = 'male'`. Do use `T2.ALB <= 3.5 OR T2.ALB >= 5.5` instead of `albumin BETWEEN 3.4 AND 5.4` to find values outside rather than inside the range. Do order by `T1.Birthday DESC` instead of `birthday ASC`. The amended query now correctly identifies patients with abnormal albumin levels by joining tables and using proper exclusion criteria."
        ],
        "rules": [
            "1) When answering about patients with abnormal albumin levels: join Patient table as T1 with Laboratory table as T2 using inner join on T1.ID = T2.ID instead of querying only one table. 2) When the question mentions \"male patient\": use T1.SEX = 'M' instead of gender = 'male' for filtering. 3) When the question mentions \"albumin not within range\": use T2.ALB <= 3.5 OR T2.ALB >= 5.5 instead of BETWEEN to find values outside the normal range. 4) When sorting patients by birthday in descending order: use T1.Birthday DESC instead of ascending order. 5) When selecting output columns: use DISTINCT T1.ID instead of all columns with * to avoid duplicate patient records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients WHERE gender = 'male' AND albumin BETWEEN 3.4 AND 5.4 ORDER BY birthday ASC;",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5)\nORDER BY T1.Birthday DESC;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5)\nORDER BY T1.Birthday DESC;"
        ],
        "amend_res": 1
    },
    "536": {
        "db_id": "codebase_community",
        "question": "How many users with more than 10 views created their account after the year 2013?",
        "ground_truth": "SELECT COUNT(id) FROM users WHERE STRFTIME('%Y', CreationDate) > '2013' AND Views > 10",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count non-null IDs rather than all rows. Do reference `CreationDate` instead of `created_at` as the date column name. Do apply `STRFTIME('%Y', CreationDate) > '2013'` instead of `created_at > '2013-01-01'` to filter by year rather than specific date. Do use `Views` instead of `views` with proper column name casing. The amended query now correctly counts users created after 2013 with more than 10 views."
        ],
        "rules": [
            "1) When counting users: use COUNT(id) instead of COUNT(*) to count non-null IDs rather than all rows. 2) When filtering by creation year: use STRFTIME('%Y', CreationDate) > '2013' instead of direct date comparison to filter by year rather than specific date. 3) When referencing the views column: use Views instead of views with proper column name casing. 4) When referencing the creation date column: use CreationDate instead of created_at as the column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE views > 10 AND created_at > '2013-01-01';",
            "SELECT COUNT(Id) FROM users WHERE Views > 10 AND STRFTIME('%Y', CreationDate) > '2013'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM users WHERE Views > 10 AND STRFTIME('%Y', CreationDate) > '2013'"
        ],
        "amend_res": 1
    },
    "1088": {
        "db_id": "european_football_2",
        "question": "Please list the names of the players whose volley score and dribbling score are over 70.",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.volleys > 70 AND t2.dribbling > 70",
        "amends": [
            "Do select `t1.player_name` with `DISTINCT` instead of `name` without distinct. Do add `INNER JOIN` on `Player_Attributes AS t2` with join condition `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do change filter to `t2.volleys > 70 AND t2.dribbling > 70` instead of `volley_score > 70 OR dribbling_score > 70`, using the correct column names from the joined table with AND logic instead of OR. The amended query now correctly joins the necessary tables, uses proper column references, and applies the intended filtering logic to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for player names: use \"t1.player_name\" with DISTINCT instead of just \"name\" without distinct. 2) When combining player information with attributes: perform an INNER JOIN between \"players\" as T1 and \"Player_Attributes\" as T2 where \"t1.player_api_id = t2.player_api_id\". 3) When filtering for players with volley and dribbling scores over 70: use the condition \"t2.volleys > 70 AND t2.dribbling > 70\" instead of \"volley_score > 70 OR dribbling_score > 70\", ensuring both conditions must be met simultaneously."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE volley_score > 70 OR dribbling_score > 70;",
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.volleys > 70 AND t2.dribbling > 70;"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.volleys > 70 AND t2.dribbling > 70;"
        ],
        "amend_res": 1
    },
    "1249": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the disease names of the patients that have a proteinuria level higher than normal.",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` >= 30",
        "amends": [
            "Do select `Diagnosis` from table `Patient` instead of `disease_name` from `patients`. Do join `Laboratory` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `U-PRO >= 30` instead of `proteinuria_level > 100`. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins patient and laboratory data to filter based on urinary protein levels."
        ],
        "rules": [
            "1) When the question asks for \"disease names\": use the exact column \"Diagnosis\" from table \"Patient\" (aliased as T1) instead of \"disease_name\" from \"patients\". 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID using an inner join between tables \"Patient\" (T1) and \"Laboratory\" (T2). 3) When filtering for proteinuria level higher than normal: use the condition T2.\"U-PRO\" >= 30 instead of proteinuria_level > 100. 4) When answering about disease names of patients with abnormal proteinuria: make sure the output order: Diagnosis."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disease_name FROM patients WHERE proteinuria_level > 100",
            "SELECT T1.Diagnosis \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.\"U-PRO\" >= 30"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Diagnosis\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.\"U-PRO\" >= 30\nORDER BY T1.Diagnosis;"
        ],
        "amend_res": 1
    },
    "1019": {
        "db_id": "formula_1",
        "question": "What is the average lap time in milliseconds of all the lap records set on the various circuits in Italy?",
        "ground_truth": "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'",
        "amends": [
            "Do use `CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap)` instead of `AVG(lap_time)` to calculate the average lap time with proper type casting and explicit aggregation. Do join `lapTimes AS T1` with `races AS T2` on `T1.raceId = T2.raceId` instead of querying a single table, and then join `circuits AS T3` on `T2.circuitId = T3.circuitId` to access circuit information. Do filter on `T3.country = 'Italy'` instead of `country = 'Italy'` to correctly reference the circuit's country rather than an unspecified table's country field. The amended query now properly calculates average lap times by joining the necessary tables and filtering on circuit country, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average lap time in milliseconds: use CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) instead of AVG(lap_time) to ensure proper type casting and explicit aggregation. 2) When accessing circuit information for filtering by country: join lapTimes AS T1 with races AS T2 on T1.raceId = T2.raceId, then join circuits AS T3 on T2.circuitId = T3.circuitId. 3) When filtering for circuits in Italy: use T3.country = 'Italy' to reference the circuit's country field rather than an unspecified table's country field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(lap_time) FROM lap_records WHERE country = 'Italy';",
            "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) AS average_lap_time_milliseconds\nFROM lapTimes AS T1\nJOIN races AS T2 ON T1.raceId = T2.raceId\nJOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE T3.country = 'Italy'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) AS average_lap_time_ms\nFROM lapTimes AS T1\nJOIN races AS T2 ON T1.raceId = T2.raceId\nJOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE T3.country = 'Italy';"
        ],
        "amend_res": 1
    },
    "561": {
        "db_id": "codebase_community",
        "question": "What is the title for the post which got the highest score comment?",
        "ground_truth": "SELECT Title FROM posts WHERE Id = ( SELECT PostId FROM comments ORDER BY Score DESC LIMIT 1 )",
        "amends": [
            "Do use `Title` instead of `title` in the SELECT list to match the correct column name casing. Do use `Id` instead of `id` in the WHERE clause predicate to match the correct column name casing. Do use `PostId` instead of `post_id` in the subquery SELECT list to match the correct column name casing. Do use `Score` instead of `score` in the subquery ORDER BY clause to match the correct column name casing. The amended query now correctly matches the column name casing conventions used in the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for the title of a post: use the exact column name \"Title\" from the posts table. 2) When the question mentions \"highest score comment\": use the exact column name \"Score\" from the comments table to determine the maximum value. 3) When matching posts to comments: use the exact column name \"Id\" from the posts table and \"PostId\" from the comments table to link the tables. 4) When ordering comments by score to find the highest: sort comments by \"Score\" in descending order and take the first result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts WHERE id = (SELECT post_id FROM comments ORDER BY score DESC LIMIT 1);",
            "SELECT Title \nFROM posts \nWHERE Id = (\n    SELECT PostId \n    FROM comments \n    ORDER BY Score DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT p.Title\nFROM posts p\nJOIN comments c ON p.Id = c.PostId\nORDER BY c.Score DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "55": {
        "db_id": "california_schools",
        "question": "Of the schools with a mailing state address in California, what is the ratio of the schools located in the county of Colusa against the school located in the county of Humboldt?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) FROM schools WHERE MailState = 'CA'",
        "amends": [
            "Do use `SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END)` and `SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END)` instead of separate subqueries with `COUNT(*)`. Do filter with `WHERE MailState = 'CA'` instead of `mailing_state = 'California'`. Do add `CAST(... AS REAL)` for proper division instead of integer division. Do reference `County` instead of `county` and `MailState` instead of `mailing_state` to match the correct column names. The amended query now correctly calculates the ratio using conditional aggregation with proper data type handling and accurate column references."
        ],
        "rules": [
            "1) When the question mentions \"mailing state address in California\": use the exact literal 'CA' instead of 'California' and reference the column \"MailState\" exactly as shown in the schema. 2) When counting schools by county: use conditional aggregation with SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) and SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) instead of separate subqueries. 3) When calculating ratios: cast the numerator to REAL to ensure proper decimal division instead of integer division. 4) When referencing column names: use exact case-sensitive identifiers \"County\" and \"MailState\" as shown in the schema, not lowercase versions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM schools WHERE mailing_state = 'California' AND county = 'Colusa') / \n    (SELECT COUNT(*) FROM schools WHERE mailing_state = 'California' AND county = 'Humboldt') \nAS ratio",
            "SELECT \n    CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) AS REAL) AS ratio\nFROM schools\nWHERE MailState = 'CA';"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) AS ratio\nFROM schools\nWHERE MailState = 'CA';"
        ],
        "amend_res": 1
    },
    "458": {
        "db_id": "card_games",
        "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
        "ground_truth": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards",
        "amends": [
            "Do use a single table query from `cards` instead of joining multiple tables with `artists` and `printings`. Do select `COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END)` instead of `COUNT(DISTINCT a.id)` with complex joins. Do filter directly with `availability LIKE '%arena,mtgo%' AND borderColor = 'black'` in the CASE expression instead of using separate WHERE clauses for `c.border_color = 'black'` and `p.printing_type IN ('arena', 'mtgo')` with GROUP BY and HAVING. Do remove the GROUP BY `p.card_id` and HAVING `COUNT(DISTINCT p.printing_type) = 2` clauses entirely instead of keeping them. The amended query now correctly counts cards that have both arena and mtgo availability with black border in a single table approach.",
            "Do use `COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END)` instead of `COUNT(DISTINCT artist)` with separate `LIKE '%arena%'` and `LIKE '%mtgo%'` conditions. Do remove the explicit `artist IS NOT NULL` filter instead of keeping it, as the CASE expression handles NULL values appropriately. Do consolidate the availability check to a single pattern `'%arena,mtgo%'` instead of requiring both patterns separately. The amended query now correctly counts only cards that have both arena and mtgo availability in a single field while maintaining the black border condition, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about artists who designed cards with specific border color and availability: use the cards table directly instead of joining with artists and printings tables. 2) When the question mentions \"black border color\": use the exact column token \"borderColor\" with literal value 'black'. 3) When the question mentions \"available in both 'arena' and 'mtgo' printing type\": use the exact column token \"availability\" with pattern matching '%arena,mtgo%'. 4) When counting distinct artists: use COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) instead of complex joins and grouping. 5) When filtering for specific conditions: apply the conditions directly in the CASE expression rather than using separate WHERE clauses with GROUP BY and HAVING.",
            "1) When counting artists who designed cards with specific attributes: use COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) instead of COUNT(DISTINCT artist). 2) When checking for cards available in both \"arena\" and \"mtgo\" printing types: use a single pattern '%arena,mtgo%' instead of separate LIKE conditions for '%arena%' and '%mtgo%'. 3) When filtering for black border color: use exact literal 'black' for borderColor comparison. 4) When handling NULL values in artist field: do not include explicit artist IS NOT NULL filter as the CASE expression handles NULL values appropriately."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT a.id) \nFROM artists a\nJOIN cards c ON a.id = c.artist_id\nJOIN printings p ON c.id = p.card_id\nWHERE c.border_color = 'black'\nAND p.printing_type IN ('arena', 'mtgo')\nGROUP BY p.card_id\nHAVING COUNT(DISTINCT p.printing_type) = 2;",
            "SELECT COUNT(DISTINCT artist) FROM cards WHERE borderColor = 'black' AND availability LIKE '%arena%' AND availability LIKE '%mtgo%' AND artist IS NOT NULL;",
            "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards;"
        ],
        "rule_sql": [
            "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) FROM cards;"
        ],
        "amend_res": 1
    },
    "1283": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "amends": [
            "Do select `COUNT(T1.ID)` instead of `COUNT(*)` to count specific patient IDs. Do use tables `Patient AS T1` and `Laboratory AS T2` instead of just `patients` to properly join patient and lab data. Do perform an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table to connect patient records with laboratory results. Do filter with `T2.GOT < 60` instead of `glutamic_pylvic_transaminase = 'normal'` to use the correct numeric threshold for normal GOT levels. Do filter with `T1.SEX = 'M'` instead of `gender = 'male'` to use the proper column name and value format. The amended query now correctly counts male patients with normal glutamic oxaloacetic transaminase levels by joining patient and laboratory tables with appropriate filtering conditions."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs. 2) When combining patient and laboratory data: use tables Patient AS T1 and Laboratory AS T2 with an INNER JOIN on T1.ID = T2.ID to connect patient records with laboratory results. 3) When filtering for normal glutamic oxaloacetic transaminase levels: use T2.GOT < 60 instead of text comparison to apply the correct numeric threshold. 4) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male' to use the proper column name and value format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND glutamic_pylvic_transaminase = 'normal';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.GOT < 60 AND T1.SEX = 'M'"
        ],
        "amend_res": 1
    },
    "454": {
        "db_id": "card_games",
        "question": "Among the cards with a white border color, how many of them have unknown power?",
        "ground_truth": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
        "amends": [
            "Do use `SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count specific conditions. Do change the WHERE filter to use `borderColor` instead of `border_color` for the column name. Do remove the `AND power IS NULL` condition from the WHERE clause instead of keeping it, as the NULL check is now handled within the CASE expression. Do add the `power LIKE '%*%'` condition to capture cards with asterisks in power instead of omitting it. The amended query now correctly counts cards with white borders that either have NULL power or contain asterisks in the power field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"white border color\": use the exact column token \"borderColor\" with literal value 'white' for filtering. 2) When counting cards with unknown power: use SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) instead of COUNT(*) to capture both NULL values and asterisk patterns. 3) When filtering for border color: do not include power conditions in the WHERE clause as they are handled within the CASE expression. 4) When handling unknown power values: include both NULL values and values containing asterisks ('%*%') to capture all unknown power cases."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE border_color = 'white' AND power IS NULL;",
            "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) \nFROM cards \nWHERE borderColor = 'white'"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) AS unknown_power_count\nFROM cards\nWHERE borderColor = 'white';"
        ],
        "amend_res": 1
    },
    "1370": {
        "db_id": "student_club",
        "question": "List all the expenses incurred by the vice president.",
        "ground_truth": "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'",
        "amends": [
            "Do select specific columns `T2.expense_id` and `T2.expense_description` instead of using `SELECT *`. Do join tables using `INNER JOIN` between `member AS T1` and `expense AS T2` instead of querying only the `expenses` table. Do use the join condition `T1.member_id = T2.link_to_member` instead of no join condition. Do filter on `T1.position = 'Vice President'` instead of filtering on `employee_role = 'vice president'`. The amended query now correctly retrieves expense details by joining member and expense tables and filtering by position, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"expenses incurred by the vice president\": make sure the output order: T2.expense_id, T2.expense_description. 2) When the question mentions \"vice president\": \"vice president\" actually means \"T1.position = 'Vice President'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation from 'Vice President'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM expenses WHERE employee_role = 'vice president';",
            "SELECT T2.expense_id, T2.expense_description FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Vice President'"
        ],
        "rule_sql": [
            "SELECT T2.expense_id, T2.expense_description\nFROM member T1\nINNER JOIN expense T2 ON T1.member_id = T2.link_to_member\nWHERE T1.position = 'Vice President'"
        ],
        "amend_res": 1
    },
    "841": {
        "db_id": "superhero",
        "question": "Provide the weight and race of the superhero with superhero ID 40.",
        "ground_truth": "SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table names. Do select `T1.weight_kg` and `T2.race` instead of `weight` and `race` without table qualification. Do add `INNER JOIN race AS T2 ON T1.race_id = T2.id` instead of querying a single table. Do filter on `T1.id = 40` instead of `superhero_id = 40` to use the correct primary key column. Do reference `superhero` table instead of `superheroes` to use the correct table name. The amended query now correctly joins tables to retrieve race information from the related race table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about superhero information: use table \"superhero\" as T1 instead of \"superheroes\". 2) When the question mentions \"superhero ID\": use column T1.id instead of superhero_id. 3) When the question asks for weight: select T1.weight_kg as the exact column. 4) When the question asks for race: select T2.race from table \"race\" as T2. 5) When combining superhero and race information: link rows where T1.race_id = T2.id using an inner match. 6) When filtering by superhero ID 40: use condition T1.id = 40 with the exact literal value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT weight, race FROM superheroes WHERE superhero_id = 40;",
            "SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40"
        ],
        "rule_sql": [
            "SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40"
        ],
        "amend_res": 1
    },
    "609": {
        "db_id": "codebase_community",
        "question": "How many posts have a score of 10 on the list?",
        "ground_truth": "SELECT COUNT(id) FROM posts WHERE Score = 10",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE score = 10;"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM posts WHERE Score = 10;"
        ],
        "amend_res": 1
    },
    "583": {
        "db_id": "codebase_community",
        "question": "What is the total score of the posts edited by Yevgeny and include the user's website URL.",
        "ground_truth": "SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny' GROUP BY T2.WebsiteUrl",
        "amends": [
            "Do use `T1.Score` instead of `p.score` for the aggregate column and remove the `total_score` alias instead of keeping it. Do join on `T1.LastEditorUserId = T2.Id` instead of `p.user_id = u.id` for the join condition. Do filter on `T2.DisplayName = 'Yevgeny'` instead of `u.name = 'Yevgeny'` for the WHERE condition. Do add `GROUP BY T2.WebsiteUrl` instead of omitting it to properly group the aggregated results. The amended query now correctly aggregates scores by website URL for users with the specified display name."
        ],
        "rules": [
            "1) When the question asks for \"total score of posts\": use T1.Score for aggregation instead of p.score. 2) When joining posts and users tables: link rows where T1.LastEditorUserId = T2.Id instead of p.user_id = u.id. 3) When filtering for user named Yevgeny: use T2.DisplayName = 'Yevgeny' instead of u.name = 'Yevgeny'. 4) When including the user's website URL in results: add GROUP BY T2.WebsiteUrl to properly group aggregated results by website URL. 5) When computing total score: remove the total_score alias from the output column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(p.score) as total_score, u.website_url \nFROM posts p \nJOIN users u ON p.user_id = u.id \nWHERE u.name = 'Yevgeny'",
            "SELECT SUM(T1.Score), T2.WebsiteUrl \nFROM posts T1 \nJOIN users T2 ON T1.LastEditorUserId = T2.Id \nWHERE T2.DisplayName = 'Yevgeny' \nGROUP BY T2.WebsiteUrl"
        ],
        "rule_sql": [
            "SELECT SUM(T1.Score) AS total_score, T2.WebsiteUrl\nFROM posts T1\nJOIN users T2 ON T1.LastEditorUserId = T2.Id\nWHERE T2.DisplayName = 'Yevgeny'\nGROUP BY T2.WebsiteUrl"
        ],
        "amend_res": 1
    }
}