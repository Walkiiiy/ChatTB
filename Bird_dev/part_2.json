{
    "792": {
        "db_id": "superhero",
        "question": "What is Abomination's superpower?",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Abomination'",
        "amends": [
            "Do select `T3.power_name` from the `superpower` table instead of `superpower` from the `characters` table. Do join `superhero` as `T1` with `hero_power` as `T2` on `T1.id = T2.hero_id` instead of querying a single table. Do add a second join to `superpower` as `T3` on `T2.power_id = T3.id` instead of omitting the necessary table relationships. Do filter on `T1.superhero_name = 'Abomination'` instead of `name = 'Abomination'` to use the correct column name from the proper table. The amended query now correctly retrieves power names through proper table relationships instead of assuming all data exists in a single table."
        ],
        "rules": [
            "1) When the question asks about a character's superpower: use the \"superpower\" table (T3) to get power_name instead of the characters table. 2) When joining tables for superhero information: link superhero table (T1) with hero_power table (T2) using T1.id = T2.hero_id. 3) When accessing superpower details: join hero_power table (T2) with superpower table (T3) using T2.power_id = T3.id. 4) When filtering by character name: use T1.superhero_name = 'Abomination' with exact case and spelling. 5) When selecting the final result: output T3.power_name as the superpower information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superpower FROM characters WHERE name = 'Abomination';",
            "SELECT T3.power_name \nFROM superhero AS T1\nJOIN hero_power AS T2 ON T1.id = T2.hero_id\nJOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = 'Abomination'"
        ],
        "rule_sql": [
            "SELECT sp.power_name \nFROM superhero sh\nJOIN hero_power hp ON sh.id = hp.hero_id\nJOIN superpower sp ON hp.power_id = sp.id\nWHERE sh.superhero_name = 'Abomination'"
        ],
        "amend_res": 1
    },
    "356": {
        "db_id": "card_games",
        "question": "How many cards have infinite power?",
        "ground_truth": "SELECT COUNT(*) FROM cards WHERE power = '*'",
        "amends": [
            "Do use `power = '*'` in the WHERE filter instead of `power = 'infinite'` to correctly count cards with asterisk power values rather than those with literal 'infinite' values. The amended query now matches RIGHT_SQL's behavior by fixing the filter condition to target the appropriate power designation."
        ],
        "rules": [
            "1) When the question asks about cards with \"infinite power\": use the exact literal value \"*\" for the power column filter instead of the word \"infinite\" 2) When counting cards that match a specific power condition: count all rows where the power column equals the exact literal \"*\""
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE power = 'infinite';",
            "SELECT COUNT(*) FROM cards WHERE power = '*';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) FROM cards WHERE power = '*';"
        ],
        "amend_res": 1
    },
    "760": {
        "db_id": "superhero",
        "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
        "amends": [
            "Do use explicit `CAST` to `REAL` for the percentage calculation instead of implicit conversion. Do reference `T2.publisher_name` instead of `publisher` and add `ELSE NULL` to the `CASE` expression instead of omitting it. Do join `superhero AS T1` with `publisher AS T2` on `T1.publisher_id = T2.id` instead of querying a single table. Do reference `T1.height_cm` instead of `height` in the filter. Do remove `GROUP BY publisher` instead of keeping it since the aggregation now operates on the joined result set without grouping. The amended query now correctly calculates the percentage of Marvel Comics superheroes within the specified height range by properly joining the tables and using explicit type casting.",
            "Do place the multiplication by 100 after the division instead of before it, and do use `COUNT(T1.id)` instead of `COUNT(*)` to ensure accurate counting of superhero records. Do maintain the same `SELECT` list structure with the percentage calculation, keep the `INNER JOIN` on `T1.publisher_id = T2.id`, and preserve the `WHERE` filter on `T1.height_cm BETWEEN 150 AND 180`. The amended query now correctly calculates the percentage by performing division before multiplication and uses specific counting of superhero IDs for accuracy, matching the RIGHT_SQL's behavior.",
            "Do use `1` instead of `T1.id` in the CASE WHEN expression to count occurrences more efficiently. Do place the multiplication by 100 after the division instead of before it to ensure correct percentage calculation. Do remove the alias `percentage` instead of keeping it since the RIGHT_SQL omits column naming. The amended query now correctly calculates the percentage of Marvel Comics superheroes within the specified height range.",
            "Do use `COUNT` instead of `SUM` for the case expression to properly count Marvel Comics superheroes. Do place the multiplication by 100 after the division instead of before it to correctly calculate the percentage. Do maintain the same `INNER JOIN` on `T1.publisher_id = T2.id` and the same `WHERE` filter on `T1.height_cm BETWEEN 150 AND 180`. The amended query now correctly calculates the percentage of Marvel Comics superheroes within the specified height range.",
            "Do place the multiplication by 100 after the CAST operation instead of wrapping the entire expression in parentheses. Do maintain the same SELECT list columns, FROM sources with INNER JOIN on T1.publisher_id = T2.id, and WHERE filter on T1.height_cm BETWEEN 150 AND 180 without any changes. The amended query now correctly calculates the percentage by multiplying after casting to REAL instead of applying multiplication to the entire parenthesized expression, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN publisher = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS marvel_percentage\nFROM superheroes\nWHERE height BETWEEN 150 AND 180\nGROUP BY publisher;",
            "SELECT \n    (CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    superhero AS T1\nJOIN \n    publisher AS T2 ON T1.publisher_id = T2.id\nWHERE \n    T1.height_cm BETWEEN 150 AND 180",
            "SELECT \n    (CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN T1.id ELSE NULL END) AS REAL) / COUNT(T1.id)) * 100 AS percentage\nFROM \n    superhero AS T1\nINNER JOIN \n    publisher AS T2 ON T1.publisher_id = T2.id\nWHERE \n    T1.height_cm BETWEEN 150 AND 180",
            "SELECT CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(T1.id) * 100\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.height_cm BETWEEN 150 AND 180;",
            "SELECT (CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(T1.id)) * 100\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.height_cm BETWEEN 150 AND 180",
            "SELECT (CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) / COUNT(T1.id)) * 100\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.height_cm BETWEEN 150 AND 180"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "834": {
        "db_id": "superhero",
        "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
        "amends": [
            "Do add explicit table aliases `T1`, `T2`, and `T3` instead of using bare table names. Do change the FROM clause to use `INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id` and `INNER JOIN gender AS T3 ON T1.gender_id = T3.id` instead of querying only the `superheroes` table. Do modify the WHERE condition to filter on `T2.publisher_name = 'George Lucas'` instead of `creator = 'George Lucas'`. Do change the denominator to `COUNT(T1.id)` instead of `COUNT(*)`. Do add explicit `CAST` to `REAL` and include `ELSE NULL` in the CASE expression instead of omitting the ELSE clause. Do remove the column alias `percentage_female` instead of keeping it. The amended query now correctly joins related tables and calculates the percentage of female superheroes published by George Lucas."
        ],
        "rules": [
            "1) When answering about superheroes created by George Lucas: use table aliases T1 for superheroes, T2 for publisher, and T3 for gender. 2) When combining superheroes with publisher information: link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match). 3) When combining superheroes with gender information: link rows where T1.gender_id = T3.id and keep only matching pairs (inner match). 4) When filtering for George Lucas as creator: use T2.publisher_name = 'George Lucas' instead of creator column. 5) When counting female superheroes: use COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) with explicit ELSE NULL clause. 6) When calculating the denominator for percentage: use COUNT(T1.id) instead of COUNT(*) to count superhero entities. 7) When computing percentage: multiply by 100.0 and cast to REAL data type. 8) When producing output: do not include column aliases in the final result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM superheroes\nWHERE creator = 'George Lucas';",
            "SELECT \n    (CAST(SUM(CASE WHEN T3.gender = 'Female' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.id)) * 100\nFROM \n    superhero AS T1\n    INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\n    INNER JOIN gender AS T3 ON T1.gender_id = T3.id\nWHERE \n    T2.publisher_name = 'George Lucas'"
        ],
        "rule_sql": [
            "SELECT (COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) * 100.0 / COUNT(T1.id)) FROM superhero T1 INNER JOIN publisher T2 ON T1.publisher_id = T2.id INNER JOIN gender T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas';"
        ],
        "amend_res": 1
    },
    "1002": {
        "db_id": "formula_1",
        "question": "As of the present, what is the full name of the youngest racer? Indicate her nationality and the name of the race to which he/she first joined.",
        "ground_truth": "SELECT T1.forename, T1.surname, T1.nationality, T3.name FROM drivers AS T1 INNER JOIN driverStandings AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T2.raceId = T3.raceId ORDER BY JULIANDAY(T1.dob) DESC LIMIT 1",
        "amends": [
            "Do select `T1.forename`, `T1.surname`, `T1.nationality`, and `T3.name` instead of `racer_name`, `nationality`, and `race_name`. Do use `FROM drivers AS T1` with `INNER JOIN driverStandings AS T2` on `T1.driverId = T2.driverId` and `INNER JOIN races AS T3` on `T2.raceId = T3.raceId` instead of a single `FROM racers` table. Do remove the `WHERE` filter with subquery for maximum age instead of keeping it. Do add `ORDER BY JULIANDAY(T1.dob) DESC` instead of omitting ordering. Do keep `LIMIT 1` but change the context from filtering by maximum age to ordering by date of birth. The amended query now correctly retrieves the oldest driver based on date of birth across joined tables rather than finding maximum age within a single table."
        ],
        "rules": [
            "1) When answering about the youngest racer: use T1.forename and T1.surname instead of racer_name to get the full name. 2) When the question mentions \"youngest\": order by JULIANDAY(T1.dob) DESC to find the person with the most recent date of birth. 3) When combining driver information with standings and races: link T1 and T2 using T1.driverId = T2.driverId and link T2 and T3 using T2.raceId = T3.raceId, keeping only matching pairs (inner match). 4) When retrieving the race information: use T3.name instead of race_name for the race name. 5) When limiting to the youngest racer: keep only the first result after ordering by date of birth descending. 6) When handling nationality: use T1.nationality exactly as specified in the schema."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT racer_name, nationality, race_name \nFROM racers \nWHERE age = (SELECT MAX(age) FROM racers) \nLIMIT 1;",
            "SELECT T1.forename, T1.surname, T1.nationality, T3.name \nFROM drivers AS T1 \nINNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId \nINNER JOIN races AS T3 ON T2.raceId = T3.raceId \nORDER BY JULIANDAY(T1.dob) DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.forename || ' ' || T1.surname AS full_name, T1.nationality, T3.name AS race_name\nFROM drivers AS T1\nINNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId\nINNER JOIN races AS T3 ON T2.raceId = T3.raceId\nORDER BY JULIANDAY(T1.dob) DESC\nLIMIT 1;",
            "SELECT T1.forename || ' ' || T1.surname AS full_name, T1.nationality, T3.name AS race_name\nFROM drivers T1\nINNER JOIN results T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nORDER BY JULIANDAY(T1.dob) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1462": {
        "db_id": "student_club",
        "question": "What category was budgeted for the 'January Speaker' event and how much was the amount budgeted for that category?",
        "ground_truth": "SELECT T2.category, T2.amount FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'January Speaker'",
        "amends": [
            "Do add table `event AS T1` and join it with `budget AS T2` using `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only the `budget` table without any join. Do reference columns as `T2.category` and `T2.amount` instead of directly using `category` and `amount` without table qualification. Do filter on `T1.event_name = 'January Speaker'` instead of filtering directly on `budget.event_name` which may not exist or could be ambiguous. Do remove `ORDER BY amount DESC LIMIT 1` instead of keeping it since the join ensures only one matching record exists. The amended query now correctly retrieves budget information by joining through the event table using the proper relationship."
        ],
        "rules": [
            "1) When answering about budget information for a specific event: join table \"event\" as T1 with table \"budget\" as T2 using T1.event_id = T2.link_to_event to establish the proper relationship between events and their budgets. 2) When the question mentions 'January Speaker' event: filter using T1.event_name = 'January Speaker' exactly as specified. 3) When retrieving budget category and amount: reference the columns as T2.category and T2.amount from the budget table. 4) When only one matching record exists due to the join relationship: do not apply ordering or limiting operations that would unnecessarily restrict the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT category, amount FROM budget WHERE event_name = 'January Speaker' ORDER BY amount DESC LIMIT 1;",
            "SELECT T2.category, T2.amount\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'January Speaker'"
        ],
        "rule_sql": [
            "SELECT T2.category, T2.amount \nFROM event AS T1 \nJOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'January Speaker'"
        ],
        "amend_res": 1
    },
    "820": {
        "db_id": "superhero",
        "question": "How strong is the Hulk?",
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T1.superhero_name = 'Hulk' AND T3.attribute_name = 'Strength'",
        "amends": [
            "Do select `T2.attribute_value` instead of `strength` from a single table. Do add joins to `hero_attribute AS T2` and `attribute AS T3` instead of querying only `superheroes`. Do use `INNER JOIN` on `T1.id = T2.hero_id` and `T2.attribute_id = T3.id` instead of no joins. Do filter with `T1.superhero_name = 'Hulk'` and `T3.attribute_name = 'Strength'` instead of just `name = 'Hulk'`. The amended query now correctly retrieves the strength attribute through proper table relationships instead of assuming a direct column exists."
        ],
        "rules": [
            "1) When answering about \"How strong is the Hulk?\": make sure the output order: T2.attribute_value 2) When the question mentions \"Hulk\": \"Hulk\" actually means \"T1.superhero_name = 'Hulk'\" in schema 3) When the question mentions \"strength\": \"strength\" actually means \"T3.attribute_name = 'Strength'\" in schema 4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match) 5) When combining T2 and T3 for shared entities: link rows where T2.attribute_id = T3.id exactly as shown in the amends; keep only matching pairs (inner match)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT strength FROM superheroes WHERE name = 'Hulk';",
            "SELECT T2.attribute_value\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T1.superhero_name = 'Hulk'\nAND T3.attribute_name = 'Strength'"
        ],
        "rule_sql": [
            "SELECT T2.attribute_value\nFROM superhero T1\nJOIN hero_attribute T2 ON T1.id = T2.hero_id\nJOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T1.superhero_name = 'Hulk'\nAND T3.attribute_name = 'Strength'"
        ],
        "amend_res": 1
    },
    "1134": {
        "db_id": "european_football_2",
        "question": "What is the difference between players 6 and 23's jumping scores?",
        "ground_truth": "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) FROM Player_Attributes AS t1",
        "amends": [
            "Do use `SUM(CASE WHEN t1.id=6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id=23 THEN t1.jumping ELSE 0 END)` instead of `ABS(p1.jumping_score - p2.jumping_score)` to calculate the difference between two players' jumping scores. Do reference table `Player_Attributes AS t1` instead of `players p1, players p2` with a cross join. Do remove the explicit `WHERE` filter conditions since the logic is now handled within the `CASE` expressions instead of filtering specific player IDs. The amended query now correctly calculates the absolute difference between player 6 and player 23's jumping attributes from a single table source."
        ],
        "rules": [
            "1) When calculating the difference between two specific players' scores: use SUM(CASE WHEN t1.id=6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id=23 THEN t1.jumping ELSE 0 END) instead of ABS(p1.jumping_score - p2.jumping_score). 2) When referencing the player attributes table: use Player_Attributes AS t1 instead of players p1, players p2 with a cross join. 3) When filtering for specific player IDs: handle the logic within CASE expressions instead of using explicit WHERE filter conditions. 4) When working with player jumping scores: use t1.jumping as the column name for jumping scores. 5) When identifying players: use t1.id as the player identifier column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT ABS(p1.jumping_score - p2.jumping_score) AS score_difference\nFROM players p1, players p2\nWHERE p1.player_id = 6 AND p2.player_id = 23;",
            "SELECT ABS(SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END)) AS jumping_difference FROM Player_Attributes AS t1"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN t1.player_api_id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.player_api_id = 23 THEN t1.jumping ELSE 0 END) AS jumping_difference FROM Player_Attributes AS t1 WHERE t1.player_api_id IN (6, 23);",
            "SELECT SUM(CASE WHEN t1.id = 6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id = 23 THEN t1.jumping ELSE 0 END) AS jumping_difference FROM Player_Attributes AS t1"
        ],
        "amend_res": 1
    },
    "929": {
        "db_id": "formula_1",
        "question": "Please list the Formula_1 races that Lewis Hamilton participated.",
        "evidence": "",
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'",
        "amends": [
            "Do select only `T1.name` instead of `*` to return specific columns. Do add joins to `results AS T2` and `drivers AS T3` instead of querying only the `races` table. Do use `INNER JOIN` on `T2.raceId = T1.raceId` and `T3.driverId = T2.driverId` instead of no joins. Do filter on `T3.forename = 'Lewis'` and `T3.surname = 'Hamilton'` instead of `driver_name = 'Lewis Hamilton'` to properly match driver names across normalized tables. The amended query now correctly joins related tables and filters on the proper driver name fields to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"Formula_1 races that Lewis Hamilton participated\": make sure the output order: T1.name. 2) When the question mentions \"Lewis Hamilton\": \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' and T3.surname = 'Hamilton'\" in schema. 3) When combining T1, T2, and T3 for shared entities: link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation for 'Lewis' and 'Hamilton'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM races WHERE driver_name = 'Lewis Hamilton';",
            "SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM races T1\nINNER JOIN results T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\nORDER BY T1.name"
        ],
        "amend_res": 1
    },
    "1501": {
        "db_id": "debit_card_specializing",
        "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
        "ground_truth": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
        "amends": [
            "Do select `DISTINCT T2.Country` instead of `country` from a single table. Do join `transactions_1k AS T1` and `gasstations AS T2` with `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of querying only `gas_stations`. Do add another `INNER JOIN` to `yearmonth AS T3` on `T1.CustomerID = T3.CustomerID` instead of omitting this table. Do filter with `T3.Date = '201306'` instead of `transaction_date = '2013-06-01'` using a different date format and column. The amended query now correctly joins multiple tables to find distinct countries with transactions in the specified month, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about countries of gas stations with transactions in June 2013: make sure the output order: T2.Country. 2) When the question mentions \"countries\": \"countries\" actually means \"T2.Country\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.GasStationID = T2.GasStationID exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T1 and T3 for shared entities: link rows where T1.CustomerID = T3.CustomerID exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for transactions in June 2013: use T3.Date = '201306' with the exact literal '201306' instead of transaction_date = '2013-06-01'. 6) When selecting distinct countries: compute the number of unique values of T2.Country."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM gas_stations WHERE transaction_date = '2013-06-01';",
            "SELECT DISTINCT T2.Country \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Date = '201306'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.Country\nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN yearmonth T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Date = '201306'\nORDER BY T2.Country"
        ],
        "amend_res": 1
    },
    "1090": {
        "db_id": "european_football_2",
        "question": "What is the long passing score of the oldest player?",
        "ground_truth": "SELECT t2.long_passing FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday ASC LIMIT 1",
        "amends": [
            "Do select `t2.long_passing` from the joined table instead of selecting `long_passing` directly. Do add `Player AS t1 INNER JOIN Player_Attributes AS t2` as the data source instead of just `players`. Do use the join condition `ON t1.player_api_id = t2.player_api_id` to properly relate the tables instead of missing this relationship. Do order by `t1.birthday ASC` to sort by actual birth date instead of the ambiguous `age ASC`. The amended query now correctly retrieves long_passing from the joined attributes table while properly ordering by birth date."
        ],
        "rules": [
            "1) When the question asks for \"long passing score\": select \"t2.long_passing\" from the Player_Attributes table instead of a direct column reference. 2) When combining player information with player attributes: join \"Player AS t1\" with \"Player_Attributes AS t2\" using the condition \"t1.player_api_id = t2.player_api_id\" to properly relate the tables. 3) When the question asks for the \"oldest player\": order by \"t1.birthday ASC\" to sort by actual birth date instead of an ambiguous age column. 4) When retrieving the oldest player's attribute: take only the first row after ordering by birth date to get the oldest player."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT long_passing FROM players ORDER BY age ASC LIMIT 1;",
            "SELECT t2.long_passing \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nORDER BY t1.birthday ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.long_passing \nFROM Player AS t1 \nJOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nORDER BY t1.birthday ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "252": {
        "db_id": "toxicology",
        "question": "What are the atoms that can bond with the atom that has the element lead?",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
        "amends": [
            "Do select `T2.atom_id, T2.atom_id2` instead of `DISTINCT a2.element`. Do use `atom AS T1` instead of `atoms a1` and `connected AS T2` instead of `bonds b` and `atoms a2`. Do perform `INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id` instead of joining `bonds b ON a1.atom_id = b.atom1_id` and then `atoms a2 ON b.atom2_id = a2.atom_id`. Do filter with `T1.element = 'pb'` instead of `a1.element = 'lead'`. The amended query now correctly retrieves connected atom pairs from the connected table using proper element filtering."
        ],
        "rules": [
            "1) When the question asks for atoms that can bond with lead: use element value 'pb' instead of 'lead' for filtering. 2) When joining tables for bonding relationships: use INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id to connect atoms through the connected table. 3) When selecting output columns: return T2.atom_id and T2.atom_id2 instead of DISTINCT a2.element to show the connected atom pairs. 4) When referring to table aliases: use atom AS T1 for the base atom table and connected AS T2 for the bonding relationships table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a2.element \nFROM atoms a1\nJOIN bonds b ON a1.atom_id = b.atom1_id\nJOIN atoms a2 ON b.atom2_id = a2.atom_id\nWHERE a1.element = 'lead';",
            "SELECT T2.atom_id, T2.atom_id2 \nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id \nWHERE T1.element = 'pb'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T1.element = 'pb'"
        ],
        "amend_res": 1
    },
    "1100": {
        "db_id": "european_football_2",
        "question": "What is the highest overall rating received by Dorlan Pabon?",
        "ground_truth": "SELECT MAX(t2.overall_rating) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Dorlan Pabon'",
        "amends": [
            "Do use `MAX(t2.overall_rating)` instead of `MIN(rating)` for the aggregate function and column reference. Do join `Player AS t1` and `Player_Attributes AS t2` with `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of querying only `player_ratings` table. Do reference `t1.player_name` in the WHERE clause instead of `player_name` alone. The amended query now correctly retrieves the maximum overall rating for the specified player by properly joining the relevant tables."
        ],
        "rules": [
            "1) When answering about \"highest overall rating received by Dorlan Pabon\": use MAX(t2.overall_rating) instead of MIN(rating) for the aggregate function and column reference. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id using an inner join instead of querying only one table. 3) When filtering for player name \"Dorlan Pabon\": reference t1.player_name in the WHERE clause instead of player_name alone."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(rating) FROM player_ratings WHERE player_name = 'Dorlan Pabon';",
            "SELECT MAX(t2.overall_rating) AS highest_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Dorlan Pabon';"
        ],
        "rule_sql": [
            "SELECT MAX(t2.overall_rating) AS highest_overall_rating\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Dorlan Pabon';"
        ],
        "amend_res": 1
    },
    "918": {
        "db_id": "formula_1",
        "question": "What's Lewis Hamilton's reference name?",
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'",
        "amends": [
            "Do select `driverRef` instead of `first_name` in the SELECT list. Do use filter conditions `forename = 'Lewis'` and `surname = 'Hamilton'` instead of `last_name = 'Hamilton'` in the WHERE clause. The amended query now correctly retrieves the driver reference using the appropriate column names and precise filtering criteria to match the intended result set."
        ],
        "rules": [
            "1) When the question asks for \"reference name\": select the exact column \"driverRef\" from the drivers table. 2) When filtering for Lewis Hamilton: use both conditions \"forename = 'Lewis'\" and \"surname = 'Hamilton'\" in the WHERE clause. 3) When the question mentions \"Lewis Hamilton's reference name\": ensure the output contains only the \"driverRef\" column with the exact literal values as stored in the database."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM drivers WHERE last_name = 'Hamilton';",
            "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton';"
        ],
        "rule_sql": [
            "SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton';"
        ],
        "amend_res": 1
    },
    "1464": {
        "db_id": "student_club",
        "question": "Write the full names of students who received funds on the date of 9/9/2019 and include the amount received.",
        "ground_truth": "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T3.member_id = T2.link_to_member INNER JOIN income AS T4 ON T4.link_to_member = T3.member_id WHERE T4.date_received = '2019-09-09'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select from `event AS T1` instead of `students`. Do `INNER JOIN attendance AS T2` on `T1.event_id = T2.link_to_event` instead of joining `funds`, and `INNER JOIN member AS T3` on `T3.member_id = T2.link_to_member` instead of joining directly on student ID. Do `INNER JOIN income AS T4` on `T4.link_to_member = T3.member_id` instead of joining funds directly, and filter on `T4.date_received = '2019-09-09'` instead of `funds.date`. Do select `T3.first_name`, `T3.last_name`, and `T4.amount` instead of the original column references. The amended query now correctly retrieves distinct member information with income data for the specified date through the proper table relationships."
        ],
        "rules": [
            "1) When answering about students who received funds: use the exact identifier \"member\" as table T3 instead of \"students\" and select \"T3.first_name\" and \"T3.last_name\" for student names. 2) When the question mentions \"received funds on the date of 9/9/2019\": filter using \"T4.date_received = '2019-09-09'\" instead of funds.date, and include \"T4.amount\" for the amount received. 3) When combining tables for this query: perform inner joins where T1.event_id = T2.link_to_event, T3.member_id = T2.link_to_member, and T4.link_to_member = T3.member_id to establish proper relationships between event, attendance, member, and income tables. 4) When retrieving distinct student information: use DISTINCT to ensure each student appears only once in the results. 5) When handling the date literal: preserve the exact format '2019-09-09' as shown in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, amount FROM students JOIN funds ON students.id = funds.student_id WHERE funds.date = '2019-09-09';",
            "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T3.member_id = T2.link_to_member\nINNER JOIN income AS T4 ON T4.link_to_member = T3.member_id\nWHERE T4.date_received = '2019-09-09'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.first_name, T3.last_name, T4.amount\nFROM event T1\nINNER JOIN attendance T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member T3 ON T3.member_id = T2.link_to_member\nINNER JOIN income T4 ON T4.link_to_member = T3.member_id\nWHERE T4.date_received = '2019-09-09'"
        ],
        "amend_res": 1
    },
    "1344": {
        "db_id": "student_club",
        "question": "What was the notes of the fundraising on 2019/9/14?",
        "ground_truth": "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'",
        "amends": [
            "Do query the `income` table instead of the `fundraisings` table. Do filter by `source = 'Fundraising'` instead of omitting this condition. Do use `date_received = '2019-09-14'` with ISO date format instead of `date = '2019/9/14'` with non-standard date format. The amended query now correctly retrieves fundraising notes from the income table with proper date handling and source filtering."
        ],
        "rules": [
            "1) When answering about fundraising notes: query the \"income\" table instead of the \"fundraisings\" table. 2) When filtering for fundraising events: include the condition where \"source\" equals 'Fundraising' exactly. 3) When filtering by date: use \"date_received\" = '2019-09-14' with ISO date format instead of non-standard date formats. 4) When retrieving notes from fundraising events: select the \"notes\" column from the \"income\" table with proper date and source filtering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT notes FROM fundraisings WHERE date = '2019/9/14';",
            "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'"
        ],
        "rule_sql": [
            "SELECT notes FROM income WHERE source = 'Fundraising' AND date_received = '2019-09-14'"
        ],
        "amend_res": 1
    },
    "506": {
        "db_id": "card_games",
        "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)` instead of `(COUNT(CASE WHEN foil_only = 0 AND non_foil_only = 1 THEN 1 END) * 100.0 / COUNT(*))` for the percentage calculation. Do query from `sets` table instead of `cards` table. Do add a subquery `WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')` instead of the simple filter `WHERE japanese_translation = 1`. Do remove the explicit column aliasing instead of including `AS percentage_non_foil_only`. The amended query now correctly calculates the percentage of non-foil only sets with Japanese translations by joining through the set_translations table rather than relying on a direct flag in the main table."
        ],
        "rules": [
            "1) When answering about percentage of non-foil only sets with Japanese translations: calculate using (number of sets where isNonFoilOnly = 1) divided by (total sets) multiplied by 100. 2) When the question mentions \"cards that has Japanese translation\": this actually means sets where code exists in set_translations with language = 'Japanese'. 3) When computing the percentage: use CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) as the calculation formula. 4) When querying for sets with Japanese translations: filter using WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese'). 5) When producing output: do not include explicit column aliases in the final result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN foil_only = 0 AND non_foil_only = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_non_foil_only\nFROM cards\nWHERE japanese_translation = 1;",
            "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')"
        ],
        "amend_res": 1
    },
    "1215": {
        "db_id": "thrombosis_prediction",
        "question": "For all female patient with total protein (TP) beyond the normal index, what is the deviation of their TP idex from the normal.",
        "ground_truth": "SELECT T2.TP - 8.5 FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.TP > 8.5",
        "amends": [
            "Do select `T2.TP - 8.5` instead of `p.gender, t.test_name, t.result_value, t.normal_range, (t.result_value - t.normal_range) AS deviation`. Do use table `Patient AS T1` instead of `patients p` and `Laboratory AS T2` instead of `tests t`. Do use join condition `T1.ID = T2.ID` instead of `p.patient_id = t.patient_id`. Do filter on `T1.SEX = 'F'` instead of `p.gender = 'Male'` and `T2.TP > 8.5` instead of `t.test_name = 'TP' AND t.result_value > t.normal_range`. The amended query now correctly calculates TP deviation from 8.5 for female patients only."
        ],
        "rules": [
            "1) When answering about female patients with TP beyond normal: use table \"Patient\" as T1 and \"Laboratory\" as T2. 2) When combining T1 and T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for female patients: use T1.SEX = 'F' exactly. 4) When filtering for TP beyond normal: use T2.TP > 8.5 exactly. 5) When calculating deviation from normal TP: compute T2.TP - 8.5 as the deviation. 6) When producing output: return only the deviation calculation (T2.TP - 8.5) as the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.gender, t.test_name, t.result_value, t.normal_range, (t.result_value - t.normal_range) AS deviation\nFROM patients p\nJOIN tests t ON p.patient_id = t.patient_id\nWHERE p.gender = 'Male'\nAND t.test_name = 'TP'\nAND t.result_value > t.normal_range;",
            "SELECT T2.TP - 8.5 AS deviation\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.TP > 8.5"
        ],
        "rule_sql": [
            "SELECT T2.TP - 8.5 AS deviation\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' AND T2.TP > 8.5"
        ],
        "amend_res": 1
    },
    "1476": {
        "db_id": "debit_card_specializing",
        "question": "What was the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "ground_truth": "SELECT SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2012'",
        "amends": [
            "Do use a single `SELECT` with conditional aggregation using `IIF` functions instead of separate subqueries for each currency. Do join the `customers` table with `yearmonth` table using `INNER JOIN` on `CustomerID` instead of querying only the `customers` table. Do reference `T2.Consumption` from the joined table instead of `gas_consumption` from a single table. Do filter by year using `SUBSTR(T2.Date, 1, 4) = '2012'` on the date field instead of a `year` column filter. Do calculate the difference between conditional sums of consumption for CZK and EUR currencies instead of subtracting results from separate subqueries. The amended query now correctly joins related data and performs conditional aggregation in a single pass, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about gas consumption difference between currency types: use conditional aggregation with IIF functions instead of separate subqueries. 2) When combining customer and yearmonth data: perform an inner join between customers table (T1) and yearmonth table (T2) using CustomerID equality (T1.CustomerID = T2.CustomerID). 3) When referencing consumption data: use T2.Consumption instead of gas_consumption column. 4) When filtering for year 2012: use SUBSTR(T2.Date, 1, 4) = '2012' on the date field instead of a year column filter. 5) When calculating currency-specific sums: use IIF(T1.currency = 'CZK', T2.Consumption, 0) for CZK-paying customers and IIF(T1.currency = 'EUR', T2.Consumption, 0) for EUR-paying customers. 6) When computing the final difference: calculate SUM(IIF(T1.currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.currency = 'EUR', T2.Consumption, 0)) as consumption_difference."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT SUM(gas_consumption) FROM customers WHERE currency = 'CZK' AND year = 2012) - \n    (SELECT SUM(gas_consumption) FROM customers WHERE currency = 'EUR' AND year = 2012) AS consumption_difference;",
            "SELECT \n    SUM(IIF(c.Currency = 'CZK', y.Consumption, 0)) - SUM(IIF(c.Currency = 'EUR', y.Consumption, 0)) AS consumption_difference\nFROM \n    customers c\nINNER JOIN \n    yearmonth y ON c.CustomerID = y.CustomerID\nWHERE \n    SUBSTR(y.Date, 1, 4) = '2012'"
        ],
        "rule_sql": [
            "SELECT \n    SUM(IIF(T1.Currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.Currency = 'EUR', T2.Consumption, 0)) AS consumption_difference\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    SUBSTR(T2.Date, 1, 4) = '2012'"
        ],
        "amend_res": 1
    },
    "276": {
        "db_id": "toxicology",
        "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select `T2.atom_id, T2.atom_id2` instead of just `atom_id`. Do join `bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id` instead of querying only the `atoms` table. Do filter on `T1.bond_type = '#'` instead of `bond_type = 'triple'`. Do remove `ORDER BY atom_id LIMIT 2` instead of keeping the ordering and limit clause. The amended query now correctly retrieves atom pairs from connected bonds with the specified bond type rather than individual atoms, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"atom IDs of the first and second atoms of triple bond type molecules\": make sure the output order: T2.atom_id, T2.atom_id2\n2) When the question mentions \"triple bond type\": \"triple\" actually means \"# in schema\" for T1.bond_type\n3) When combining bond table as T1 and connected table as T2 for shared bond entities: link rows where T1.bond_id = T2.bond_id exactly; keep only matching pairs (inner match)\n4) When filtering for bond type: use T1.bond_type = '#' instead of any other representation of triple bonds\n5) When retrieving atom pairs from connected bonds: select both T2.atom_id and T2.atom_id2 instead of just one atom_id\n6) When the question asks for \"first and second atoms\": do not apply ordering or limit clauses as the natural pairing in connected table already provides the atom pairs"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id FROM atoms WHERE bond_type = 'triple' ORDER BY atom_id LIMIT 2;",
            "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "329": {
        "db_id": "toxicology",
        "question": "Which carcinogenic molecule have the highest number of atoms consisted in it?",
        "ground_truth": "SELECT T.molecule_id FROM ( SELECT T2.molecule_id, COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.atom_id) DESC LIMIT 1 ) t",
        "amends": [
            "Do select `T.molecule_id` instead of `molecule_name` and `MAX(atom_count)`. Do use a subquery instead of querying the table directly. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying a single table. Do add filter `WHERE T2.label = '+'` instead of omitting any condition. Do use `COUNT(T1.atom_id)` with `GROUP BY T2.molecule_id` instead of `MAX(atom_count)` without grouping. Do order by `COUNT(T1.atom_id) DESC` instead of `atom_count DESC`. The amended query now correctly identifies the molecule with the most atoms among carcinogenic molecules labeled '+', matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"carcinogenic molecule with highest number of atoms\": make sure the output order: molecule_id first, then count of atoms. 2) When the question mentions \"carcinogenic molecule\": \"carcinogenic\" actually means \"T2.label = '+'\" in schema. 3) When combining atom AS T1 and molecule AS T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match). 4) When counting atoms per molecule: compute the number of rows using T1.atom_id as the counting key with GROUP BY T2.molecule_id. 5) When the question mentions \"highest number of atoms\": rank rows by COUNT(T1.atom_id) in descending direction and keep the first 1 row."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT molecule_name, MAX(atom_count) FROM carcinogenic_molecules ORDER BY atom_count DESC LIMIT 1;",
            "SELECT T.molecule_id\nFROM (\n    SELECT T2.molecule_id, COUNT(T1.atom_id) AS atom_count\n    FROM atom AS T1\n    JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\n    WHERE T2.label = '+'\n    GROUP BY T2.molecule_id\n    ORDER BY COUNT(T1.atom_id) DESC\n    LIMIT 1\n) AS T"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, COUNT(T1.atom_id) AS atom_count\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'\nGROUP BY T2.molecule_id\nORDER BY atom_count DESC\nLIMIT 1",
            "SELECT T2.molecule_id, COUNT(T1.atom_id) AS atom_count\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'\nGROUP BY T2.molecule_id\nORDER BY atom_count DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1463": {
        "db_id": "student_club",
        "question": "List the event names which were budgeted for the food.",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'",
        "amends": [
            "Do select `T1.event_name` with table alias qualification instead of unqualified `event_name`. Do use `FROM event AS T1 INNER JOIN budget AS T2` instead of single table `FROM events`. Do add join condition `ON T1.event_id = T2.link_to_event` instead of omitting the join. Do filter on `T2.category = 'Food'` instead of `budget_category = 'food'` to reference the correct table and use proper case sensitivity. The amended query now correctly joins the event and budget tables to filter events based on their budget category."
        ],
        "rules": [
            "1) When answering about \"event names which were budgeted for the food\": make sure the output order: T1.event_name. 2) When combining event and budget tables: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match). 3) When the question mentions \"budgeted for the food\": \"food\" actually means T2.category = 'Food' in schema (with exact case sensitivity). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation - use 'Food' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM events WHERE budget_category = 'food';",
            "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T2.category = 'Food'"
        ],
        "amend_res": 1
    },
    "1306": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients diagnosed with SLE have a normal white blood cell level?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.WBC BETWEEN 3.5 AND 9",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific column instead of `COUNT(*)` from all rows. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter `T1.Diagnosis = 'SLE'` instead of `diagnosis = 'SLE'` with proper table qualification. Do use `T2.WBC BETWEEN 3.5 AND 9` for numeric range comparison instead of `white_blood_cell_level = 'normal'` string matching. The amended query now correctly joins patient and laboratory data to count SLE patients with normal white blood cell levels within the specified numeric range."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 2) When combining patient and laboratory data: join Patient AS T1 and Laboratory AS T2 using INNER JOIN where T1.ID = T2.ID to match patient records with their lab results. 3) When filtering for SLE diagnosis: use T1.Diagnosis = 'SLE' with exact case and table qualification. 4) When checking for normal white blood cell levels: use T2.WBC BETWEEN 3.5 AND 9 for numeric range comparison instead of string matching."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE diagnosis = 'SLE' AND white_blood_cell_level = 'normal';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.Diagnosis = 'SLE' \nAND T2.WBC BETWEEN 3.5 AND 9"
        ],
        "amend_res": 1
    },
    "527": {
        "db_id": "card_games",
        "question": "What are the rulings for the card named and designed by Kev Walker? List them in descending order of dates.",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Kev Walker' ORDER BY T2.date DESC",
        "amends": [
            "Do select `T2.text` instead of `ruling_date, ruling_text` and use table aliases. Do join `cards AS T1` with `rulings AS T2` using `INNER JOIN` on `T2.uuid = T1.uuid` instead of querying only the `rulings` table. Do filter on `T1.artist = 'Kev Walker'` instead of `card_name = 'Kev Walker'` to correctly reference the artist column in the cards table. Do order by `T2.date DESC` instead of `ruling_date ASC` to sort by the correct date column in descending order. The amended query now properly joins the cards and rulings tables to find rulings for cards by a specific artist rather than incorrectly searching for a card name matching the artist's name."
        ],
        "rules": [
            "1) When answering about rulings for cards by a specific artist: join cards table as T1 with rulings table as T2 using T2.uuid = T1.uuid to link cards to their rulings. 2) When the question mentions \"card named and designed by Kev Walker\": filter on T1.artist = 'Kev Walker' to find cards created by that artist. 3) When selecting ruling information: output T2.text as the ruling content instead of separate date and text columns. 4) When ordering by dates in descending order: sort by T2.date DESC to show most recent rulings first. 5) When combining cards and rulings tables: use inner join on T2.uuid = T1.uuid to ensure only matching card-ruling pairs are included."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT ruling_date, ruling_text FROM rulings WHERE card_name = 'Kev Walker' ORDER BY ruling_date ASC;",
            "SELECT T2.text \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T2.uuid = T1.uuid \nWHERE T1.artist = 'Kev Walker' \nORDER BY T2.date DESC"
        ],
        "rule_sql": [
            "SELECT T2.text \nFROM cards AS T1 \nINNER JOIN rulings AS T2 ON T2.uuid = T1.uuid \nWHERE T1.artist = 'Kev Walker' \nORDER BY T2.date DESC"
        ],
        "amend_res": 1
    },
    "128": {
        "db_id": "financial",
        "question": "List the top nine districts, by descending order, from the highest to the lowest, the number of female account holders.",
        "ground_truth": "SELECT T2.A2, COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' GROUP BY T2.district_id, T2.A2 ORDER BY COUNT(T1.client_id) DESC LIMIT 9",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do select `T2.A2` instead of just `district_id`. Do count `T1.client_id` instead of `COUNT(*)`. Do join `client AS T1` with `district AS T2` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do filter for `T1.gender = 'F'` instead of `gender = 'male'`. Do group by both `T2.district_id` and `T2.A2` instead of only `district_id`. Do order by `COUNT(T1.client_id)` instead of the alias `female_count`. The amended query now correctly joins client and district tables to count female clients per district with proper district information.",
            "Do remove `T2.district_id` from the SELECT list instead of including it, while keeping `T2.A2` and the aggregate. Do use explicit `INNER JOIN` instead of implicit `JOIN` for clarity. Do change the ORDER BY to use `COUNT(T1.client_id)` directly instead of the `female_count` alias. Do maintain the same FROM clause with proper join condition `T1.district_id = T2.district_id`, WHERE filter `T1.gender = 'F'`, GROUP BY on both `T2.district_id` and `T2.A2`, and LIMIT 9. The amended query now correctly orders by the actual count value rather than an alias and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"top nine districts by number of female account holders\": make sure the output order: T2.A2, COUNT(T1.client_id) in descending order and keep the first 9 rows. 2) When the question mentions \"female account holders\": \"female\" actually means \"T1.gender = 'F'\" in schema. 3) When combining T1 (client) and T2 (district) for shared entities: link rows where T1.district_id = T2.district_id; keep only matching pairs (inner match). 4) When counting female clients per district: compute the number of rows using T1.client_id as the counting key. 5) When the question asks for \"districts by number of female account holders\": organize results by both T2.district_id and T2.A2 and compute the count per group. 6) When producing output: include T2.A2 as the district identifier instead of just district_id.",
            "1) When the question asks for \"top nine districts\": rank districts by the number of female account holders in descending order and keep the first 9 rows. 2) When counting female account holders: count using T1.client_id where T1.gender equals exactly 'F'. 3) When combining client and district tables: link rows where T1.district_id equals T2.district_id and keep only matching pairs (inner match). 4) When organizing results by district: group by both T2.district_id and T2.A2 to ensure correct aggregation. 5) When ordering results: order by the actual count value (COUNT(T1.client_id)) directly rather than using an alias. 6) When selecting output columns: include only T2.A2 (district name) and the female count, not T2.district_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_id, COUNT(*) as female_count FROM accounts WHERE gender = 'male' GROUP BY district_id ORDER BY female_count DESC LIMIT 9;",
            "SELECT T2.district_id, T2.A2, COUNT(T1.client_id) AS female_count\nFROM client AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY female_count DESC\nLIMIT 9;",
            "SELECT T2.A2, COUNT(T1.client_id) AS female_count\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9"
        ],
        "rule_sql": [
            "SELECT T2.A2, COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F'\nGROUP BY T2.district_id, T2.A2\nORDER BY COUNT(T1.client_id) DESC\nLIMIT 9"
        ],
        "amend_res": 1
    },
    "622": {
        "db_id": "codebase_community",
        "question": "State the name of badge that the user whose display name is \"Sharpie\" obtained.",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Sharpie'",
        "amends": [
            "Do use an `INNER JOIN` between `users` and `badges` tables on `T1.Id = T2.UserId` instead of a subquery with `user_id = (SELECT id FROM users)`. Do reference the badge column as `T2.Name` instead of `badge_name`. Do filter on `T1.DisplayName = 'Sharpie'` in the WHERE clause instead of using a subquery filter. Do use proper table aliases `T1` and `T2` instead of direct table references. The amended query now correctly joins the tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining users and badges tables: link rows where T1.Id = T2.UserId and keep only matching pairs (inner match). 2) When filtering for a specific display name: use T1.DisplayName = 'Sharpie' exactly as specified. 3) When selecting badge information: reference the badge name column as T2.Name. 4) When answering about badge names for a specific user: make sure the output order includes only the badge name column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM badges WHERE user_id = (SELECT id FROM users WHERE display_name = 'Sharpie')",
            "SELECT T2.Name \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'Sharpie'"
        ],
        "rule_sql": [
            "SELECT badges.Name \nFROM users \nINNER JOIN badges ON users.Id = badges.UserId \nWHERE users.DisplayName = 'Sharpie'"
        ],
        "amend_res": 1
    },
    "964": {
        "db_id": "formula_1",
        "question": "List out the code for drivers who have nationality in America.",
        "ground_truth": "SELECT code FROM drivers WHERE Nationality = 'American'",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM drivers WHERE nationality = 'American'"
        ],
        "rule_sql": [
            "SELECT code FROM drivers WHERE nationality = 'American';"
        ],
        "amend_res": 1
    },
    "1397": {
        "db_id": "student_club",
        "question": "On average, how much did the Student_Club spend on food for the typical event in the past?",
        "ground_truth": "SELECT SUM(spent) / COUNT(spent) FROM budget WHERE category = 'Food' AND event_status = 'Closed'",
        "amends": [
            "Do use `SUM(spent) / COUNT(spent)` instead of `AVG(food_cost)` for the aggregate calculation. Do reference the `budget` table instead of the `events` table as the data source. Do filter on `category = 'Food'` instead of `event_type = 'Student_Club'` for the category condition. Do add `event_status = 'Closed'` instead of omitting the status filter. Do remove the date condition `date < date('now')` instead of keeping it. The amended query now correctly calculates the average spending from the budget table for closed food events, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating average spending: use SUM(spent) divided by COUNT(spent) instead of AVG(food_cost) for the aggregate calculation. 2) When referencing data source: use the \"budget\" table instead of the \"events\" table. 3) When filtering for category: use category = 'Food' instead of event_type = 'Student_Club'. 4) When filtering for event status: include event_status = 'Closed' condition. 5) When handling date conditions: remove the date < date('now') condition instead of keeping it."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(food_cost) FROM events WHERE event_type = 'Student_Club' AND date < date('now')",
            "SELECT SUM(spent) / COUNT(spent) AS average_food_spending\nFROM budget\nWHERE category = 'Food' AND event_status = 'Closed';"
        ],
        "rule_sql": [
            "SELECT SUM(spent) / COUNT(spent) AS average_spending\nFROM budget\nWHERE category = 'Food' AND event_status = 'Closed';"
        ],
        "amend_res": 1
    },
    "446": {
        "db_id": "card_games",
        "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
        "amends": [
            "Do use `CAST(SUM(CASE WHEN convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE set_name = 'Abyssal Horror')` for the percentage calculation. Do add `INNER JOIN sets AS T2 ON T2.code = T1.setCode` instead of omitting the sets table join. Do filter on `T1.name = 'Abyssal Horror'` instead of `set_name = 'Abyssal Horror'` to reference the correct column. Do include `T1.name` in the SELECT list instead of omitting it. Do reference `convertedManaCost` instead of `converted_mana_cost` for the correct column name. The amended query now correctly calculates the percentage of cards with converted mana cost 10 within the 'Abyssal Horror' set by properly joining the sets table and using accurate column references.",
            "Do select `T1.name` instead of `T2.name` in the SELECT list. Do filter on `T1.name = 'Abyssal Horror'` instead of `T2.name = 'Abyssal Horror'` in the WHERE clause. The amended query now correctly calculates the percentage of cards with converted mana cost 10 for the specific card named 'Abyssal Horror' rather than incorrectly filtering by set name, matching the intended behavior.",
            "Do place the aggregate expression first in the SELECT list instead of starting with `T1.name`. Do use `T1.id` in the COUNT function instead of `id` without table qualification. Do remove the explicit GROUP BY clause instead of keeping it since the WHERE filter `T1.name = 'Abyssal Horror'` already restricts to a single name value, making grouping unnecessary. The amended query now correctly calculates the percentage without redundant grouping while maintaining the same logical behavior.",
            "Do add `T1.name` to the SELECT list instead of omitting it. Do add `INNER JOIN sets AS T2 ON T2.code = T1.setCode` to the FROM clause instead of having only the cards table. Do qualify `convertedManaCost` with `T1.` instead of using it unqualified. The amended query now correctly joins with the sets table and includes the name column while properly qualifying all column references.",
            "Do place the `T1.name` column at the end of the SELECT list instead of at the beginning, maintaining the same calculation expression `CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)` without changes. The FROM clause with `INNER JOIN` on `T2.code = T1.setCode` and WHERE filter on `T1.name = 'Abyssal Horror'` remain identical. The amended query now matches RIGHT_SQL's behavior with the correct column ordering."
        ],
        "rules": [
            "1) When calculating percentage of cards with converted mana cost 10 in a specific set: use CAST(SUM(CASE WHEN convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) instead of COUNT(*) * 100.0 / subquery. 2) When joining cards and sets tables: use INNER JOIN sets AS T2 ON T2.code = T1.setCode to properly link the tables. 3) When filtering by set name 'Abyssal Horror': use T1.name = 'Abyssal Horror' instead of set_name = 'Abyssal Horror' to reference the correct column. 4) When selecting output columns: include T1.name in the SELECT list. 5) When referencing converted mana cost column: use convertedManaCost instead of converted_mana_cost for the correct column name.",
            "1) When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror: make sure the output order: T1.name, percentage\n2) When the question mentions \"Abyssal Horror\": \"Abyssal Horror\" actually means T1.name = 'Abyssal Horror' in the cards table\n3) When calculating percentage of cards with convertedManaCost = 10: compute (number of rows where T1.convertedManaCost = 10) divided by (total number of rows where T1.name = 'Abyssal Horror'), guarding division by zero\n4) When selecting columns: include T1.name in the output to identify the card being analyzed",
            "1) When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror: make sure the output order starts with the aggregate expression first instead of T1.name. 2) When counting cards: use T1.id as the counting key instead of unqualified id. 3) When the WHERE filter T1.name = 'Abyssal Horror' already restricts to a single name value: do not include an explicit GROUP BY clause as it becomes redundant.",
            "1) When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror: make sure the output order includes T1.name as the first column. 2) When combining cards table T1 and sets table T2: link rows where T2.code = T1.setCode and keep only matching pairs (inner match). 3) When qualifying column references: always use T1.convertedManaCost instead of unqualified convertedManaCost. 4) When the question asks for percentage of cards with converted Mana Cost of 10: compute (number of rows where T1.convertedManaCost = 10) divided by (total number of rows) multiplied by 100, using T1.id as the counting key.",
            "1) When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror: make sure the output order is percentage calculation first, then T1.name at the end. 2) When combining cards table T1 and sets table T2: link rows where T2.code = T1.setCode and keep only matching pairs (inner match). 3) When filtering for the set of Abyssal Horror: use exact literal 'Abyssal Horror' for T1.name condition. 4) When calculating percentage of cards with converted Mana Cost of 10: compute (number of rows where T1.convertedManaCost = 10) divided by (total number of rows using T1.id as counting key), then multiply by 100."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE set_name = 'Abyssal Horror')) AS percentage FROM cards WHERE converted_mana_cost = 10 AND set_name = 'Abyssal Horror';",
            "SELECT \n    T2.name,\n    CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T2.name = 'Abyssal Horror';",
            "SELECT \n    T1.name,\n    CAST(SUM(CASE WHEN convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T1.name = 'Abyssal Horror'\nGROUP BY \n    T1.name;",
            "SELECT CAST(SUM(CASE WHEN convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM cards AS T1\nWHERE T1.name = 'Abyssal Horror'",
            "SELECT \n    T1.name,\n    CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T1.name = 'Abyssal Horror';",
            "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage,\n    T1.name\nFROM \n    cards AS T1\nINNER JOIN \n    sets AS T2 ON T2.code = T1.setCode\nWHERE \n    T1.name = 'Abyssal Horror'"
        ],
        "amend_res": 1
    },
    "1346": {
        "db_id": "student_club",
        "question": "Tell the phone number of \"Carlo Jacobs\".",
        "ground_truth": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'",
        "amends": [
            "Do query the `member` table instead of the `customers` table, while keeping the same `SELECT phone` column and `WHERE first_name = 'Carlo' AND last_name = 'Jacobs'` filter conditions. The amended query now correctly retrieves phone information from the member table instead of the customers table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for phone number of a person: use the \"phone\" column from the \"member\" table. 2) When filtering for a person named \"Carlo Jacobs\": use exact literal values 'Carlo' for \"first_name\" and 'Jacobs' for \"last_name\" with AND conditions. 3) When the schema specifies a \"member\" table instead of \"customers\": query the \"member\" table to retrieve phone information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone FROM customers WHERE first_name = 'Carlo' AND last_name = 'Jacobs';",
            "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs'"
        ],
        "rule_sql": [
            "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs';"
        ],
        "amend_res": 1
    },
    "802": {
        "db_id": "superhero",
        "question": "Who is the tallest superhero?",
        "ground_truth": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
        "amends": [
            "Do reference `superhero_name` instead of `name` and use table `superhero` instead of `superheroes`. Do order by `height_cm` instead of `height` and use `DESC` direction instead of `ASC`. The amended query now correctly retrieves the tallest superhero by height in centimeters from the proper table structure."
        ],
        "rules": [
            "1) When the question asks about superheroes: use table \"superhero\" instead of \"superheroes\". 2) When the question asks for a superhero's name: use column \"superhero_name\" instead of \"name\". 3) When the question asks about height: use column \"height_cm\" instead of \"height\". 4) When the question asks for the tallest superhero: order by \"height_cm\" in descending direction and keep the first row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes ORDER BY height ASC LIMIT 1;",
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1207": {
        "db_id": "thrombosis_prediction",
        "question": "List all patients with their sex and date of birthday, whose AST glutamic oxaloacetic transaminase (GOT) index is within normal range for loboratory examination in 1994.",
        "ground_truth": "SELECT DISTINCT T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND STRFTIME('%Y', T2.Date) = '1994'",
        "amends": [
            "Do select `SEX` and `Birthday` instead of `name`, `sex`, and `date_of_birth`. Do use `DISTINCT` instead of omitting it. Do join `Laboratory` as `T2` instead of `laboratory_examinations` as `le`. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `p.patient_id = le.patient_id`. Do filter with `T2.GOT < 60` instead of `le.result_value BETWEEN 10 AND 40`. Do use `STRFTIME('%Y', T2.Date) = '1994'` for year extraction instead of `le.examination_year = 1994`. Do remove the `ORDER BY` clause instead of keeping it. The amended query now correctly retrieves distinct patient demographics with appropriate laboratory value filtering and date handling."
        ],
        "rules": [
            "1) When selecting patient demographic information: output columns must be exactly \"SEX\" and \"Birthday\" in that order, not \"name\", \"sex\", and \"date_of_birth\". 2) When retrieving patient records: ensure distinct results by removing duplicate patient entries. 3) When joining Patient and Laboratory tables: use INNER JOIN on exact key equality \"T1.ID = T2.ID\" to match rows between tables. 4) When filtering for AST GOT laboratory results: use the condition \"T2.GOT < 60\" to identify values within normal range. 5) When filtering for examinations in 1994: extract year using \"STRFTIME('%Y', T2.Date) = '1994'\" with exact literal '1994'. 6) When the question does not specify ordering: do not include any ORDER BY clause in the final output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.name, p.sex, p.date_of_birth \nFROM patients p\nJOIN laboratory_examinations le ON p.patient_id = le.patient_id\nWHERE le.examination_type = 'AST GOT' \nAND le.examination_year = 1994\nAND le.result_value BETWEEN 10 AND 40\nORDER BY p.name;",
            "SELECT DISTINCT T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60\nAND STRFTIME('%Y', T2.Date) = '1994'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GOT < 60\nAND STRFTIME('%Y', T2.Date) = '1994'"
        ],
        "amend_res": 1
    },
    "107": {
        "db_id": "financial",
        "question": "What is the gender of the oldest client who opened his/her account in the highest average salary branch?",
        "ground_truth": "SELECT T2.gender FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id ORDER BY T1.A11 DESC, T2.birth_date ASC LIMIT 1",
        "amends": [
            "Do select `T2.gender` from `district AS T1` instead of `gender` from `clients`. Do use `INNER JOIN` on `T1.district_id = T2.district_id` instead of filtering with subqueries for `age` and `branch_id`. Do remove all WHERE clause conditions and subqueries instead of keeping complex nested subqueries. Do add `ORDER BY T1.A11 DESC, T2.birth_date ASC` instead of omitting ordering. Do add `LIMIT 1` instead of omitting row limiting. The amended query now correctly retrieves the gender from the client associated with the highest A11 district value, using proper table joins instead of incorrect subquery logic."
        ],
        "rules": [
            "1) When answering about \"gender of the oldest client who opened his/her account in the highest average salary branch\": make sure the output order: T2.gender. 2) When combining district AS T1 and client AS T2 for shared entities: link rows where T1.district_id = T2.district_id exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question mentions \"highest average salary branch\": \"highest average salary branch\" actually means \"T1.A11 in schema\" and requires ordering by T1.A11 DESC. 4) When the question mentions \"oldest client\": \"oldest client\" actually means \"T2.birth_date in schema\" and requires ordering by T2.birth_date ASC to find the earliest birth date. 5) When the question asks for a single result: use LIMIT 1 to return only the first row after ordering. 6) When handling ordering ties: break ties using the canonical key if needed, with T1.A11 DESC as primary ordering and T2.birth_date ASC as secondary ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender FROM clients WHERE age = (SELECT MAX(age) FROM clients) AND branch_id = (SELECT branch_id FROM branches WHERE avg_salary = (SELECT MAX(avg_salary) FROM branches));",
            "SELECT T2.gender\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nORDER BY T1.A11 DESC, T2.birth_date ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.gender\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nORDER BY T1.A11 DESC, T2.birth_date ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1008": {
        "db_id": "formula_1",
        "question": "During which lap did Lewis Hamilton take a pit stop during the 2011 Australian Grand Prix?",
        "evidence": "",
        "ground_truth": "SELECT T1.lap FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.year = 2011 AND T3.name = 'Australian Grand Prix'",
        "amends": [
            "Do join `pitStops AS T1` with `drivers AS T2` on `T1.driverId = T2.driverId` instead of directly filtering on driver name. Do join with `races AS T3` on `T1.raceId = T3.raceId` instead of filtering on race name alone. Do filter on `T2.forename = 'Lewis'` and `T2.surname = 'Hamilton'` instead of using a combined driver name string. Do filter on `T3.year = 2011` and `T3.name = 'Australian Grand Prix'` instead of using a year-included race name string. Do remove `ORDER BY lap DESC LIMIT 1` instead of keeping it since the query logic now correctly returns the specific lap without needing ordering and limiting. The amended query now correctly joins through proper foreign key relationships and uses separate fields for driver names and race year."
        ],
        "rules": [
            "1) When joining pit stops with driver information: combine \"pitStops AS T1\" with \"drivers AS T2\" where \"T1.driverId\" equals \"T2.driverId\" to link through proper foreign key relationships. 2) When joining pit stops with race information: combine \"pitStops AS T1\" with \"races AS T3\" where \"T1.raceId\" equals \"T3.raceId\" to link through proper foreign key relationships. 3) When filtering for Lewis Hamilton: check both \"T2.forename = 'Lewis'\" and \"T2.surname = 'Hamilton'\" instead of using a combined driver name string. 4) When filtering for the 2011 Australian Grand Prix: check both \"T3.year = 2011\" and \"T3.name = 'Australian Grand Prix'\" instead of using a year-included race name string. 5) When answering about specific lap information: return the lap value directly without ordering or limiting since the query logic correctly identifies the specific lap."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT lap FROM pit_stops WHERE driver = 'Lewis Hamilton' AND race = '2011 Australian Grand Prix' ORDER BY lap DESC LIMIT 1;",
            "SELECT T1.lap \nFROM pitStops AS T1 \nJOIN drivers AS T2 ON T1.driverId = T2.driverId \nJOIN races AS T3 ON T1.raceId = T3.raceId \nWHERE T2.forename = 'Lewis' \nAND T2.surname = 'Hamilton' \nAND T3.year = 2011 \nAND T3.name = 'Australian Grand Prix'"
        ],
        "rule_sql": [
            "SELECT T1.lap \nFROM pitStops AS T1 \nJOIN drivers AS T2 ON T1.driverId = T2.driverId \nJOIN races AS T3 ON T1.raceId = T3.raceId \nWHERE T2.forename = 'Lewis' \nAND T2.surname = 'Hamilton' \nAND T3.year = 2011 \nAND T3.name = 'Australian Grand Prix'"
        ],
        "amend_res": 1
    },
    "277": {
        "db_id": "toxicology",
        "question": "What are the toxicology elements associated with bond ID TR000_1_2?",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR000_1_2'",
        "amends": [
            "Do select `T1.element` instead of `*` to return only the specific column needed. Do use `FROM atom AS T1` instead of `FROM toxicology_elements` to reference the correct table containing element data. Do add `INNER JOIN connected AS T2` instead of omitting the join to properly connect atom and bond information. Do use join condition `ON T1.atom_id = T2.atom_id` instead of no join condition to establish the correct relationship between tables. Do move the filter to `WHERE T2.bond_id = 'TR000_1_2'` instead of `WHERE bond_id = 'TR000_1_2'` to reference the joined table's column. The amended query now correctly retrieves elements associated with the specified bond ID through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"toxicology elements associated with bond ID\": make sure the output order: T1.element 2) When the question mentions \"bond ID TR000_1_2\": use the exact literal 'TR000_1_2' with the correct case and underscores 3) When combining atom table as T1 and connected table as T2: link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match) 4) When filtering for a specific bond ID: apply the condition T2.bond_id = 'TR000_1_2' to reference the bond ID column from the connected table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM toxicology_elements WHERE bond_id = 'TR000_1_2';",
            "SELECT T1.element \nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR000_1_2'"
        ],
        "rule_sql": [
            "SELECT T1.element \nFROM atom AS T1 \nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id \nWHERE T2.bond_id = 'TR000_1_2'"
        ],
        "amend_res": 1
    },
    "390": {
        "db_id": "card_games",
        "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
        "ground_truth": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
        "amends": [
            "Do select `T1.colors` and `T2.format` instead of `color` and `format`. Do add `FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid` instead of `FROM cards` alone. Do keep the `WHERE T1.id BETWEEN 1 AND 20` filter but reference it through the joined table alias instead of the base table. The amended query now correctly joins the cards and legalities tables to retrieve color and format information from their respective sources while maintaining the same record filtering logic."
        ],
        "rules": [
            "1) When answering about card colors and formats for IDs 1-20: make sure the output order: T1.colors, T2.format 2) When the question mentions \"colors\": \"colors\" actually means \"T1.colors in schema\" 3) When the question mentions \"format\": \"format\" actually means \"T2.format in schema\" 4) When combining cards and legalities tables: link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match) 5) When filtering by card IDs 1-20: apply the condition T1.id BETWEEN 1 AND 20 to select only those specific records"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT color, format FROM cards WHERE id BETWEEN 1 AND 20;",
            "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20"
        ],
        "rule_sql": [
            "SELECT T1.colors, T2.format \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T1.id BETWEEN 1 AND 20 \nORDER BY T1.colors, T2.format"
        ],
        "amend_res": 1
    },
    "811": {
        "db_id": "superhero",
        "question": "Give the alignment and superpowers of the superhero named Atom IV.",
        "ground_truth": "SELECT T4.alignment, T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id WHERE T1.superhero_name = 'Atom IV'",
        "amends": [
            "Do use table aliases `T4.alignment` and `T3.power_name` instead of direct column references `alignment` and `superpowers`. Do add `INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` instead of omitting the join table. Do add `INNER JOIN superpower AS T3 ON T3.id = T2.power_id` instead of omitting the power table. Do add `INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id` instead of directly referencing the alignment column. Do use `T1.superhero_name` in the WHERE filter instead of `name`. The amended query now correctly joins through the necessary relationship tables to retrieve alignment and power information for the specified superhero."
        ],
        "rules": [
            "1) When the question asks about a superhero's alignment and superpowers: use table aliases T4.alignment and T3.power_name instead of direct column references alignment and superpowers. 2) When joining tables to get superhero information: add INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id to connect superheroes to their powers. 3) When retrieving power information: add INNER JOIN superpower AS T3 ON T3.id = T2.power_id to get the actual power names. 4) When retrieving alignment information: add INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id instead of directly referencing the alignment column. 5) When filtering by superhero name: use T1.superhero_name in the WHERE clause instead of name to match the exact column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT alignment, superpowers FROM superheroes WHERE name = 'Atom IV';",
            "SELECT T4.alignment, T3.power_name \nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T3.id = T2.power_id\nINNER JOIN alignment AS T4 ON T1.alignment_id = T4.id\nWHERE T1.superhero_name = 'Atom IV'"
        ],
        "rule_sql": [
            "SELECT T4.alignment, T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T3.id = T2.power_id\nINNER JOIN alignment AS T4 ON T1.alignment_id = T4.id\nWHERE T1.superhero_name = 'Atom IV'"
        ],
        "amend_res": 1
    },
    "1178": {
        "db_id": "thrombosis_prediction",
        "question": "What was the gender of the first AORTITIS diagnosed patient?",
        "ground_truth": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
        "amends": [
            "Do select `SEX` instead of `gender` and use table `Patient` instead of `patients`. Do add filter `AND First Date IS NOT NULL` instead of omitting it. Do order by `First Date ASC` instead of `patient_id ASC` while keeping the `LIMIT 1` clause. The amended query now correctly filters for non-null diagnosis dates and orders by the relevant date field instead of patient ID, matching the RIGHT_SQL's behavior.",
            "Do use backticks around `First Date` in both the WHERE filter and ORDER BY clause instead of using unquoted identifiers with spaces, which would cause syntax errors in SQL engines that require proper quoting of column names containing spaces. The amended query now correctly handles the column name with spaces by properly quoting it, ensuring the query executes successfully and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"gender\": \"gender\" actually means \"SEX in schema\". 2) When the question mentions \"patients\": \"patients\" actually means \"Patient in schema\". 3) When filtering for AORTITIS diagnosis: include only rows where diagnosis equals 'AORTITIS' exactly. 4) When ordering by diagnosis date: order rows by First Date ASC instead of patient_id. 5) When filtering for valid diagnosis dates: include only rows where First Date IS NOT NULL. 6) When selecting the first diagnosed patient: keep only the first row after ordering by First Date ASC.",
            "1) When the question asks about the gender of a patient diagnosed with 'AORTITIS': use the exact literal 'AORTITIS' for the Diagnosis column filter. 2) When handling column names with spaces like 'First Date': always use backticks around the identifier as `First Date` in both WHERE conditions and ORDER BY clauses. 3) When finding the first diagnosed patient: order by `First Date` in ascending order and take only the first result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender FROM patients WHERE diagnosis = 'AORTITIS' ORDER BY patient_id ASC LIMIT 1;",
            "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND First Date IS NOT NULL ORDER BY First Date ASC LIMIT 1",
            "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND \"First Date\" IS NOT NULL ORDER BY \"First Date\" ASC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1"
        ],
        "amend_res": 1
    },
    "882": {
        "db_id": "formula_1",
        "question": "Which year was the first Singapore Grand Prix?",
        "ground_truth": "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1",
        "amends": [
            "Do query the `races` table instead of the `grand_prix` table. Do filter by `name = 'Singapore Grand Prix'` instead of `country = 'Singapore'`. Do use `ORDER BY year ASC` instead of `ORDER BY year DESC` to sort in ascending order rather than descending. The amended query now correctly retrieves the year from the races table using the specific Grand Prix name and returns the earliest occurrence with ascending order."
        ],
        "rules": [
            "1) When answering about \"first Singapore Grand Prix\": query the \"races\" table instead of the \"grand_prix\" table. 2) When filtering for Singapore Grand Prix: use \"name = 'Singapore Grand Prix'\" instead of filtering by country. 3) When finding the first occurrence by year: use \"ORDER BY year ASC\" instead of descending order to get the earliest year. 4) When retrieving the year of the first occurrence: use \"LIMIT 1\" to get only the earliest result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM grand_prix WHERE country = 'Singapore' ORDER BY year DESC LIMIT 1;",
            "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT year FROM races WHERE name = 'Singapore Grand Prix' ORDER BY year ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "214": {
        "db_id": "toxicology",
        "question": "What type of label is not on molecules with atoms with tin?",
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
        "amends": [
            "Do use `INNER JOIN` between `atom` and `molecule` tables with `T1.molecule_id = T2.molecule_id` instead of querying `molecules` separately with a subquery. Do filter with `T1.element != 'sn'` instead of using `NOT IN` with a subquery for `element = 'Sn'`. Do select `T2.label` instead of `label_type` from the joined table. Do maintain `DISTINCT` but apply it to the joined result set instead of the original table. The amended query now correctly identifies molecules without tin atoms by joining the tables and filtering directly on element values."
        ],
        "rules": [
            "1) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id using an inner match that keeps only pairs with matching molecule_id values. 2) When filtering for atoms without tin: use T1.element != 'Sn' to exclude rows where the element equals exactly 'Sn' (case-sensitive). 3) When selecting the label information: select T2.label instead of label_type from the molecule table. 4) When ensuring unique results: apply DISTINCT to the joined result set to remove duplicate label values. 5) When answering about label types not on molecules with tin atoms: make sure the output order shows only distinct label values from molecules that have no atoms with element 'Sn'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT label_type \nFROM molecules \nWHERE molecule_id NOT IN (\n    SELECT molecule_id \n    FROM atoms \n    WHERE element = 'Sn'\n)",
            "SELECT DISTINCT T2.label \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.element != 'sn'"
        ],
        "rule_sql": [
            "SELECT DISTINCT m.label\nFROM molecule m\nWHERE m.molecule_id NOT IN (\n    SELECT DISTINCT a.molecule_id\n    FROM atom a\n    WHERE a.element = 'Sn'\n)\nAND m.label IS NOT NULL\nORDER BY m.label;"
        ],
        "amend_res": 1
    },
    "200": {
        "db_id": "toxicology",
        "question": "Find the triple-bonded molecules which are carcinogenic.",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '+'",
        "amends": [
            "Do select `DISTINCT T2.molecule_id` instead of `*` from all columns. Do use `INNER JOIN` between `bond AS T1` and `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying only `molecules` table. Do filter with `T1.bond_type = '#'` instead of `bond_type = 'triple'` and `T2.label = '+'` instead of `carcinogenic = 'yes'`. The amended query now correctly joins related tables and uses appropriate column references and filter conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"triple-bonded molecules which are carcinogenic\": make sure the output order: T2.molecule_id. 2) When the question mentions \"triple-bonded\": \"triple-bonded\" actually means \"T1.bond_type = '#'\" in schema. 3) When the question mentions \"carcinogenic\": \"carcinogenic\" actually means \"T2.label = '+'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match). 5) When selecting results: return only distinct T2.molecule_id values instead of all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE bond_type = 'triple' AND carcinogenic = 'yes';",
            "SELECT DISTINCT T2.molecule_id\nFROM bond AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#' AND T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id\nFROM bond T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#' AND T2.label = '+'"
        ],
        "amend_res": 1
    },
    "713": {
        "db_id": "codebase_community",
        "question": "What is the up vote number of the user that commented \"R is also lazy evaluated.\"?",
        "ground_truth": "SELECT T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'R is also lazy evaluated.'",
        "amends": [
            "Do select `T2.UpVotes` from the `users` table instead of `up_votes` from the `users` table. Do join `comments AS T1` with `users AS T2` using `INNER JOIN` on `T1.UserId = T2.Id` instead of querying only the `users` table. Do filter on `T1.Text = 'R is also lazy evaluated.'` instead of filtering on `users.comment = 'R is also lazy evaluated.'` since the comment text is stored in the comments table rather than the users table. The amended query correctly retrieves upvotes from the user who made the specific comment by joining the comments and users tables, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for up vote number of a user who made a specific comment: select \"T2.UpVotes\" from the users table instead of \"up_votes\". 2) When combining comments and users tables: join \"comments AS T1\" with \"users AS T2\" using inner join where \"T1.UserId = T2.Id\" to link comments to their authors. 3) When filtering for a specific comment text: use \"T1.Text = 'R is also lazy evaluated.'\" instead of filtering on users table since comment text is stored in comments table. 4) When answering about user attributes based on comment content: retrieve user information from the users table (T2) after joining with comments table (T1) where the comment text matches exactly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT up_votes FROM users WHERE comment = 'R is also lazy evaluated.'",
            "SELECT T2.UpVotes \nFROM comments AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.Text = 'R is also lazy evaluated.'"
        ],
        "rule_sql": [
            "SELECT T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'R is also lazy evaluated.'"
        ],
        "amend_res": 1
    },
    "1531": {
        "db_id": "debit_card_specializing",
        "question": "Who is the top spending customer and how much is the average price per single item purchased by this customer? What currency was being used?",
        "ground_truth": "SELECT T2.CustomerID, SUM(T2.Price / T2.Amount), T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.CustomerID = ( SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1 ) GROUP BY T2.CustomerID, T1.Currency",
        "amends": [
            "Do select `T2.CustomerID`, `SUM(T2.Price / T2.Amount)`, and `T1.Currency` instead of `c.customer_name`, `SUM(o.total_amount)`, `AVG(p.price)`, and `c.currency`. Do use `INNER JOIN` with `transactions_1k AS T2` on `T1.CustomerID = T2.CustomerID` instead of multiple joins with `orders`, `order_items`, and `products` tables. Do add a `WHERE` filter `T2.CustomerID = (subquery)` instead of omitting it. Do change the `GROUP BY` to `T2.CustomerID, T1.Currency` instead of just `c.customer_id`. Do remove the `ORDER BY total_spent DESC LIMIT 1` from the main query instead of keeping it, as the limiting logic is now handled in the subquery. The amended query now correctly identifies the top customer through a subquery and calculates the appropriate aggregated metrics, matching the RIGHT_SQL's behavior.",
            "Do use the subquery `SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1` instead of `SELECT CustomerID FROM transactions_1k GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1` to correctly identify the target customer based on consumption data from the yearmonth table rather than attempting to aggregate transaction data. Do remove the alias `avg_price_per_item` from the SUM expression instead of keeping it, as the right SQL does not include column aliases. The amended query now correctly references the yearmonth table for identifying the highest consumption customer and matches the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about the top spending customer: identify the customer with the highest total spending using a subquery that computes SUM(T2.Price / T2.Amount) for each T2.CustomerID and orders by this sum in descending order, keeping only the top result. 2) When calculating average price per single item: compute SUM(T2.Price / T2.Amount) as the average price per item rather than using AVG(p.price). 3) When combining customer and transaction data: use INNER JOIN between T1 (customers) and T2 (transactions_1k) where T1.CustomerID = T2.CustomerID to match customer records with their transactions. 4) When grouping results: group by both T2.CustomerID and T1.Currency to ensure currency information is properly included in the grouped results. 5) When filtering for the top customer: use a WHERE clause with T2.CustomerID = (subquery) to restrict results to only the top spending customer identified in the subquery. 6) When selecting output columns: include T2.CustomerID instead of customer_name, SUM(T2.Price / T2.Amount) instead of total spending and average price calculations, and T1.Currency for the currency information.",
            "1) When identifying the top spending customer: use the CustomerID from the yearmonth table ordered by Consumption DESC with LIMIT 1 instead of aggregating transaction data. 2) When calculating average price per item: compute SUM(T2.Price / T2.Amount) without assigning an alias to the expression. 3) When combining customer and transaction data: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 4) When outputting results: include T2.CustomerID, the computed average price expression, and T1.Currency in that order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.customer_name, SUM(o.total_amount) as total_spent, AVG(p.price) as avg_price_per_item, c.currency\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nJOIN order_items oi ON o.order_id = oi.order_id\nJOIN products p ON oi.product_id = p.product_id\nGROUP BY c.customer_id\nORDER BY total_spent DESC\nLIMIT 1;",
            "SELECT \n    T2.CustomerID,\n    SUM(T2.Price / T2.Amount) AS avg_price_per_item,\n    T1.Currency\nFROM \n    customers T1\nINNER JOIN \n    transactions_1k T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID\n        FROM transactions_1k\n        GROUP BY CustomerID\n        ORDER BY SUM(Price) DESC\n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency",
            "SELECT \n    T2.CustomerID, \n    SUM(T2.Price / T2.Amount), \n    T1.Currency\nFROM \n    customers AS T1\nINNER JOIN \n    transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T2.CustomerID = (SELECT CustomerID FROM yearmonth ORDER BY Consumption DESC LIMIT 1)\nGROUP BY \n    T2.CustomerID, T1.Currency"
        ],
        "rule_sql": [
            "SELECT \n    T2.CustomerID, \n    SUM(T2.Price / T2.Amount), \n    T1.Currency\nFROM \n    customers T1\nINNER JOIN \n    transactions_1k T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T2.CustomerID = (\n        SELECT CustomerID \n        FROM yearmonth \n        ORDER BY Consumption DESC \n        LIMIT 1\n    )\nGROUP BY \n    T2.CustomerID, T1.Currency"
        ],
        "amend_res": 1
    },
    "409": {
        "db_id": "card_games",
        "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability.\" that do not have multiple faces.",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
        "amends": [
            "Do add joins to `legalities` and `rulings` tables instead of querying only the `cards` table. Do use `INNER JOIN` on `T1.uuid = T2.uuid` and `T1.uuid = T3.uuid` instead of no joins. Do change the format filter to `T2.format = 'premodern'` instead of `format = 'pre-modern'`. Do change the ruling text filter to `T3.text = 'This is a triggered mana ability.'` instead of `ruling_text = 'This is a triggered mana ability.'`. Do change the multiple faces check to `T1.Side IS NULL` instead of `multiple_faces = 1`. Do count `T1.id` instead of `COUNT(*)`. The amended query now correctly joins related tables and uses appropriate filters to match the intended logic."
        ],
        "rules": [
            "1) When answering about cards with specific format and ruling text: join the cards table (T1) with legalities table (T2) using T1.uuid = T2.uuid and with rulings table (T3) using T1.uuid = T3.uuid, keeping only matching rows from all three tables. 2) When the question mentions \"pre-modern format\": use the exact literal 'premodern' (without hyphen) for T2.format comparison. 3) When the question mentions ruling text \"This is a triggered mana ability.\": use the exact literal 'This is a triggered mana ability.' for T3.text comparison. 4) When the question asks for cards that do not have multiple faces: check that T1.Side IS NULL instead of using a multiple_faces column. 5) When counting cards: count T1.id instead of using COUNT(*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE format = 'pre-modern' AND ruling_text = 'This is a triggered mana ability.' AND multiple_faces = 1;",
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nINNER JOIN rulings T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'premodern' \nAND T3.text = 'This is a triggered mana ability.'\nAND T1.side IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nJOIN rulings T3 ON T1.uuid = T3.uuid\nWHERE T2.format = 'premodern'\nAND T3.text = 'This is a triggered mana ability.'\nAND T1.side IS NULL"
        ],
        "amend_res": 1
    },
    "442": {
        "db_id": "card_games",
        "question": "Mention the base set size and set code of the set that was in block named \"Masques\" and \"Mirage\".",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the SELECT list to `T1.baseSetSize, T2.setCode` instead of `base_set_size, set_code`. Do add `INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of querying only the `sets` table. Do change the WHERE condition to `T1.block IN ('Masques', 'Mirage')` instead of the contradictory `block_name = 'Masques' AND block_name = 'Mirage'`. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins the translation table and filters for multiple block values instead of the impossible condition where a single column equals two different values simultaneously."
        ],
        "rules": [
            "1) When the question asks for \"base set size and set code\": use the exact column tokens \"T1.baseSetSize\" and \"T2.setCode\" instead of \"base_set_size\" and \"set_code\". 2) When the question mentions sets in blocks named \"Masques\" and \"Mirage\": filter using \"T1.block IN ('Masques', 'Mirage')\" instead of contradictory equality conditions. 3) When combining set information with translation data: perform an inner join between \"sets\" as T1 and \"set_translations\" as T2 where \"T2.setCode = T1.code\". 4) When selecting from multiple tables: use table aliases T1 for the \"sets\" table and T2 for the \"set_translations\" table. 5) When retrieving set information: include DISTINCT to eliminate duplicate rows from the result set."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT base_set_size, set_code FROM sets WHERE block_name = 'Masques' AND block_name = 'Mirage'",
            "SELECT DISTINCT T1.baseSetSize, T2.setCode\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T1.block IN ('Masques', 'Mirage')"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets T1 INNER JOIN set_translations T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')"
        ],
        "amend_res": 1
    },
    "592": {
        "db_id": "codebase_community",
        "question": "How many users are awarded with more than 5 badges?",
        "ground_truth": "SELECT COUNT(UserId) FROM ( SELECT UserId, COUNT(Name) AS num FROM badges GROUP BY UserId ) T WHERE T.num > 5",
        "amends": [
            "Do count `UserId` from a subquery instead of counting all rows from the base table. Do use a subquery that groups by `UserId` and counts `Name` as `num` instead of directly filtering on `badge_count`. Do filter on the aggregated count `T.num > 5` in the outer query instead of filtering on a non-aggregated column `badge_count > 5` in the WHERE clause. Do properly aggregate badge counts per user with `COUNT(Name)` and `GROUP BY UserId` instead of assuming a pre-aggregated `badge_count` column exists. The amended query now correctly counts users with more than 5 badges by properly aggregating and then filtering the results."
        ],
        "rules": [
            "1) When counting users with more than 5 badges: count distinct UserId values instead of all rows from the base table. 2) When aggregating badge counts per user: group by UserId and count the Name column from the badges table to get the number of badges per user. 3) When filtering for users with more than 5 badges: apply the condition num > 5 on the aggregated count result instead of filtering on a non-aggregated column. 4) When the question asks for \"users awarded with more than 5 badges\": this means counting UserId values where the count of Name from badges table grouped by UserId is greater than 5."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE badge_count > 5;",
            "SELECT COUNT(*) AS user_count\nFROM (\n    SELECT UserId\n    FROM badges\n    GROUP BY UserId\n    HAVING COUNT(Name) > 5\n) AS T"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS user_count\nFROM (\n    SELECT UserId\n    FROM badges\n    GROUP BY UserId\n    HAVING COUNT(Name) > 5\n) AS users_with_more_than_5_badges"
        ],
        "amend_res": 1
    },
    "703": {
        "db_id": "codebase_community",
        "question": "Among the tags with tag ID below 15, how many of them have 20 count of posts and below?",
        "ground_truth": "SELECT COUNT(id) FROM tags WHERE Count <= 20 AND Id < 15",
        "amends": [
            "Do use `COUNT(id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference column `Id` instead of `tag_id` in the WHERE clause filter. Do reference column `Count` instead of `post_count` in the WHERE clause filter. Do place the `Id < 15` condition after the `Count <= 20` condition instead of before it, though this ordering difference is functionally equivalent. The amended query now correctly counts non-null id values while filtering on the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When counting entities in the tags table: use COUNT(\"Id\") to count specific non-null values rather than all rows. 2) When filtering by tag ID below 15: use \"Id\" < 15 instead of tag_id. 3) When filtering by count of posts 20 and below: use \"Count\" <= 20 instead of post_count. 4) When ordering conditions in WHERE clause: place \"Count\" <= 20 condition before \"Id\" < 15 condition, though this ordering difference is functionally equivalent."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM tags WHERE tag_id < 15 AND post_count <= 20;",
            "SELECT COUNT(Id) FROM tags WHERE Count <= 20 AND Id < 15"
        ],
        "rule_sql": [
            "SELECT COUNT(\"Id\") FROM tags WHERE \"Count\" <= 20 AND \"Id\" < 15"
        ],
        "amend_res": 1
    },
    "786": {
        "db_id": "superhero",
        "question": "How many heroes have the highest attribute value in strength?",
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
        "amends": [
            "Do query the `hero_attribute` and `attribute` tables instead of the `heroes` table. Do use `INNER JOIN` on `T1.attribute_id = T2.id` instead of querying a single table. Do filter with `T2.attribute_name = 'Strength'` instead of directly using `strength`. Do count `T1.hero_id` instead of `COUNT(*)`. Do use `MAX(attribute_value)` in the subquery instead of `MIN(strength)`. Do reference `attribute_value` instead of `strength` in the main condition. The amended query now correctly counts heroes with the maximum strength value by properly joining attribute tables and using the correct aggregation function."
        ],
        "rules": [
            "1) When answering about heroes with highest attribute values: query both hero_attribute (T1) and attribute (T2) tables instead of just heroes table. 2) When combining hero_attribute and attribute tables: link rows where T1.attribute_id equals T2.id using inner join. 3) When filtering for strength attribute: use T2.attribute_name = 'Strength' exactly as specified. 4) When counting heroes: count T1.hero_id instead of using COUNT(*). 5) When finding the highest attribute value: use MAX(attribute_value) instead of MIN. 6) When comparing attribute values: reference attribute_value column instead of strength column in the main condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM heroes WHERE strength = (SELECT MIN(strength) FROM heroes);",
            "SELECT COUNT(T1.hero_id) \nFROM hero_attribute T1\nINNER JOIN attribute T2 ON T1.attribute_id = T2.id\nWHERE T2.attribute_name = 'Strength'\nAND T1.attribute_value = (\n    SELECT MAX(attribute_value) \n    FROM hero_attribute T3\n    INNER JOIN attribute T4 ON T3.attribute_id = T4.id\n    WHERE T4.attribute_name = 'Strength'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.hero_id) \nFROM hero_attribute T1 \nINNER JOIN attribute T2 ON T1.attribute_id = T2.id \nWHERE T2.attribute_name = 'Strength' \nAND T1.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute T3 INNER JOIN attribute T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Strength')"
        ],
        "amend_res": 1
    },
    "1385": {
        "db_id": "student_club",
        "question": "Which student was able to generate income more than $40?",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40",
        "amends": [
            "Do select `T1.first_name` and `T1.last_name` instead of `student_name`. Do use `member AS T1` and `income AS T2` as source tables instead of `students`. Do add `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of no join condition. Do filter on `T2.amount > 40` instead of `income > 40`. The amended query now correctly joins member and income tables to filter based on income amount rather than assuming an income column exists in a students table."
        ],
        "rules": [
            "1) When the question asks about \"student\": use the exact identifier \"member\" as table T1 instead of \"students\". 2) When the question asks for student name: select both \"T1.first_name\" and \"T1.last_name\" instead of \"student_name\". 3) When combining member and income data: use \"income\" as table T2 and link rows where \"T1.member_id = T2.link_to_member\" exactly as shown, keeping only matching pairs (inner match). 4) When filtering for income more than $40: use the exact condition \"T2.amount > 40\" instead of \"income > 40\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_name FROM students WHERE income > 40;",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member\nWHERE T2.amount > 40"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nWHERE T2.amount > 40"
        ],
        "amend_res": 1
    },
    "246": {
        "db_id": "toxicology",
        "question": "List the bond type and the bond ID of the atom 45.",
        "ground_truth": "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'",
        "amends": [
            "Do select `T1.bond_type` and `T1.bond_id` instead of `bond_type` and `atom_id`. Do use `FROM bond AS T1 INNER JOIN connected AS T2` instead of `FROM bonds` alone. Do add join condition `ON T1.bond_id = T2.bond_id` instead of omitting any join. Do change filter to `SUBSTR(T2.atom_id, 7, 2) = '45'` instead of `atom_id = 45` to extract the specific substring pattern. The amended query now correctly joins the bond and connected tables and properly filters based on the substring extraction from atom_id, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"bond type and bond ID of atom 45\": make sure the output order: T1.bond_type, T1.bond_id. 2) When the question mentions \"atom 45\": \"atom 45\" actually means \"SUBSTR(T2.atom_id, 7, 2) = '45'\" in schema. 3) When combining bond and connected tables for shared entities: link rows where T1.bond_id = T2.bond_id exactly as shown; keep only matching pairs (inner match). 4) When handling text literals: do not change case, spacing, or punctuation - use exact value '45'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type, atom_id FROM bonds WHERE atom_id = 45;",
            "SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE SUBSTR(T2.atom_id, 7, 2) = '45'"
        ],
        "rule_sql": [
            "SELECT T1.bond_type, T1.bond_id\nFROM bond T1\nJOIN connected T2 ON T1.bond_id = T2.bond_id\nWHERE SUBSTR(T2.atom_id, 7, 2) = '45'"
        ],
        "amend_res": 1
    },
    "596": {
        "db_id": "codebase_community",
        "question": "Which users have posted the most comments. List out the user's badge?",
        "ground_truth": "SELECT Name FROM badges AS T1 INNER JOIN comments AS T2 ON T1.UserId = t2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.UserId) DESC LIMIT 1",
        "amends": [
            "Do select `Name` from the `badges` table instead of `u.badge` from `users`. Do join `badges AS T1` with `comments AS T2` instead of joining `users u` with `comments c`. Do use the join condition `T1.UserId = T2.UserId` instead of `u.id = c.user_id`. Do group by `T2.UserId` instead of `u.id`. Do order by `COUNT(T2.UserId)` instead of the alias `comment_count`. The amended query now correctly retrieves the badge name from the badges table while maintaining the same aggregation logic to find the user with the most comments.",
            "Do select only `Name` instead of selecting both `Name` and `COUNT(T2.UserId)`. Do use `INNER JOIN` instead of just `JOIN` for explicit clarity. Do add `LIMIT 1` to return only the top result instead of omitting it. The amended query now correctly returns only the name with the highest comment count by limiting to one result."
        ],
        "rules": [
            "1) When the question asks for \"user's badge\": select \"Name\" from the \"badges\" table instead of any badge column from a users table. 2) When combining \"badges\" and \"comments\" tables: link rows where \"T1.UserId\" = \"T2.UserId\" and keep only matching pairs (inner match). 3) When counting comments per user: count using \"T2.UserId\" as the counting key. 4) When grouping for aggregation: organize results by \"T2.UserId\" to compute counts per user. 5) When finding the user with the most comments: rank rows by comment count in descending order and keep the first 1 row. 6) When answering about \"which users have posted the most comments\": make sure the output order: \"Name\" from badges table.",
            "1) When answering about \"users who have posted the most comments\": make sure the output order: T1.Name only, without including the comment count. 2) When the question asks for \"most comments\": rank users by comment count in descending order and keep only the top 1 result. 3) When combining badges table T1 and comments table T2: link rows where T1.UserId = T2.UserId using an inner join and keep only matching pairs. 4) When counting comments per user: compute the number of rows using T2.UserId as the counting key for each user group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.badge, COUNT(c.id) as comment_count \nFROM users u \nJOIN comments c ON u.id = c.user_id \nGROUP BY u.id \nORDER BY comment_count DESC \nLIMIT 1;",
            "SELECT T1.Name, COUNT(T2.UserId) AS comment_count\nFROM badges AS T1\nJOIN comments AS T2 ON T1.UserId = T2.UserId\nGROUP BY T2.UserId\nORDER BY COUNT(T2.UserId) DESC;",
            "SELECT T1.Name \nFROM badges AS T1 \nINNER JOIN comments AS T2 ON T1.UserId = T2.UserId \nGROUP BY T2.UserId \nORDER BY COUNT(T2.UserId) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT b.Name \nFROM badges b\nINNER JOIN comments c ON b.UserId = c.UserId\nGROUP BY c.UserId\nORDER BY COUNT(c.UserId) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "970": {
        "db_id": "formula_1",
        "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
        "ground_truth": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
        "amends": [
            "Do select `T2.driverId` instead of `name, birth_year, lap_time`. Do use `FROM pitStops AS T1 INNER JOIN drivers AS T2` instead of `FROM drivers` alone. Do join on `T1.driverId = T2.driverId` instead of no join condition. Do filter with `T2.nationality = 'German'` instead of just `nationality`. Do use `STRFTIME('%Y', T2.dob)` for year extraction instead of `birth_year` direct field. Do order by `T1.time` instead of `lap_time`. The amended query now correctly joins pit stop data with driver information and properly extracts birth years from date of birth, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"top 3 German drivers\": make sure the output order: T2.driverId. 2) When the question mentions \"German drivers\": \"German\" actually means \"T2.nationality = 'German'\" in schema. 3) When the question mentions \"born from 1980-1990\": use STRFTIME('%Y', T2.dob) to extract birth year and filter for values between 1980 and 1990 inclusive. 4) When the question mentions \"earliest lap time\": order by T1.time in ascending order. 5) When combining T1 (pitStops) and T2 (drivers) for shared entities: link rows where T1.driverId = T2.driverId; keep only matching pairs (inner match). 6) When the question asks for \"top 3\": rank rows by T1.time in ascending order and keep the first 3 rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, birth_year, lap_time \nFROM drivers \nWHERE nationality = 'German' \nAND birth_year BETWEEN 1980 AND 1990 \nORDER BY lap_time ASC \nLIMIT 3;",
            "SELECT T2.driverId\nFROM pitStops AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990'\nORDER BY T1.time ASC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T2.driverId, T2.forename, T2.surname, T2.dob, T2.nationality, T1.time\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990'\nORDER BY T1.time ASC, T2.driverId\nLIMIT 3",
            "SELECT T2.driverId\nFROM pitStops T1\nJOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990'\nORDER BY T1.time ASC\nLIMIT 3;"
        ],
        "amend_res": 1
    },
    "217": {
        "db_id": "toxicology",
        "question": "Identify all the atoms that are connected to the atoms of the TR181 molecule.",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T1.molecule_id = 'TR181'",
        "amends": [
            "Do select specific columns `atom_id` and `atom_id2` instead of using `a2.*` to select all columns. Do use table aliases `T1` and `T2` instead of `a1` and `a2`. Do join with table `connected` instead of `bonds` and `atoms` tables. Do use a simple `INNER JOIN` on `T2.atom_id = T1.atom_id` instead of complex OR conditions with `atom1_id` and `atom2_id`. Do remove the DISTINCT modifier instead of keeping it. Do remove the additional filter `a2.molecule_id != 'TR181'` instead of including it. The amended query now correctly retrieves connected atoms from the connected table using a simpler and more efficient join structure."
        ],
        "rules": [
            "1) When answering about atoms connected to TR181 molecule: select specific columns \"atom_id\" and \"atom_id2\" instead of using wildcard selection. 2) When joining tables for connected atoms: use table aliases T1 and T2 consistently throughout the query. 3) When finding connected atoms: use the \"connected\" table instead of joining \"bonds\" and \"atoms\" tables separately. 4) When linking connected atoms: use a simple INNER JOIN on T2.atom_id = T1.atom_id instead of complex OR conditions with atom1_id and atom2_id. 5) When retrieving connected atoms: do not use DISTINCT modifier as it is not needed. 6) When filtering for TR181 molecule: remove the additional filter T2.molecule_id != 'TR181' as it incorrectly excludes atoms from the same molecule. 7) When working with molecule identifiers: use the exact literal 'TR181' with the correct case and no quotes around the value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT a2.* \nFROM atoms a1\nJOIN bonds b ON a1.atom_id = b.atom1_id OR a1.atom_id = b.atom2_id\nJOIN atoms a2 ON (b.atom1_id = a2.atom_id OR b.atom2_id = a2.atom_id) \nWHERE a1.molecule_id = 'TR181' AND a2.molecule_id != 'TR181';",
            "SELECT T1.atom_id, T1.atom_id2\nFROM connected T1\nINNER JOIN atom T2 ON T2.atom_id = T1.atom_id\nWHERE T2.molecule_id = 'TR181'\nUNION\nSELECT T1.atom_id, T1.atom_id2\nFROM connected T1\nINNER JOIN atom T2 ON T2.atom_id = T1.atom_id2\nWHERE T2.molecule_id = 'TR181'"
        ],
        "rule_sql": [
            "SELECT T1.atom_id, T1.atom_id2 \nFROM connected T1\nINNER JOIN atom T2 ON T2.atom_id = T1.atom_id\nWHERE T2.molecule_id = 'TR181'"
        ],
        "amend_res": 1
    },
    "683": {
        "db_id": "codebase_community",
        "question": "What is the percentage of posts whose owners had a reputation of over 1000 in 2011?",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN condition THEN 1 END)` for percentage calculation. Do apply the year filter `STRFTIME('%Y', T2.CreationDate) = '2011'` within the conditional aggregate instead of in the `WHERE` clause to ensure proper denominator calculation. Do reference `T1.Id` in `COUNT(T1.Id)` instead of `COUNT(*)` to count distinct users. Do use explicit `INNER JOIN` syntax with table aliases `T1` for users and `T2` for posts instead of implicit join syntax. Do include the year condition in the aggregate logic instead of filtering it at the row level to correctly calculate the percentage of high-reputation users among all 2011 users. The amended query now correctly computes the percentage of users with reputation over 1000 among those who posted in 2011.",
            "Do move the date filter `STRFTIME('%Y', T2.CreationDate) = '2011'` from the `WHERE` clause into the `IIF` condition instead of applying it globally. Do add explicit `CAST` to `REAL` for the percentage calculation instead of relying on implicit conversion. Do remove the `WHERE` clause entirely instead of keeping it as a separate filter. Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the date function. The amended query now correctly calculates the percentage of users with reputation over 1000 who posted in 2011, matching the right SQL's behavior.",
            "Do place the `STRFTIME('%Y', T2.CreationDate) = '2011'` condition first in the IIF predicate instead of after the reputation check. Do use `COUNT(T1.Id)` instead of `COUNT(IIF(STRFTIME('%Y', T2.CreationDate) = '2011', T1.Id, NULL))` for the denominator calculation. Do apply the multiplication by 100 after the division instead of before it in the percentage calculation. The amended query now correctly calculates the percentage of users with reputation over 1000 who posted in 2011 by fixing the conditional logic and arithmetic order.",
            "Do place the multiplication by 100 after the division instead of before it, maintaining the same calculation order. Do remove the redundant WHERE clause filter `STRFTIME('%Y', T2.CreationDate) = '2011'` instead of keeping it since the same condition is already handled within the IIF function. Do use the correct spelling `CreaionDate` instead of `CreationDate` to match the actual column name. The amended query now correctly calculates the percentage without redundant filtering and matches the intended behavior."
        ],
        "rules": [
            "1) When calculating percentages: use SUM(IIF(condition, 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN condition THEN 1 END). 2) When filtering by year for percentage denominators: apply the year condition STRFTIME('%Y', T2.CreationDate) = '2011' within the conditional aggregate instead of in the WHERE clause. 3) When counting distinct entities: use COUNT(T1.Id) instead of COUNT(*) to count distinct users. 4) When joining tables: use explicit INNER JOIN syntax with table aliases T1 for users and T2 for posts. 5) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId to ensure proper user-post relationships. 6) When handling year 2011 data: use the exact literal '2011' with the format string '%Y' in STRFTIME function. 7) When checking reputation thresholds: use the exact comparison T1.Reputation > 1000 for reputation over 1000.",
            "1) When calculating percentage of posts whose owners had reputation over 1000 in 2011: use T2.CreationDate (not T2.CreaionDate) for the date filtering. 2) When filtering for posts from 2011: apply the date condition STRFTIME('%Y', T2.CreationDate) = '2011' within the conditional count instead of globally in WHERE clause. 3) When computing the percentage: cast the result to REAL type explicitly instead of relying on implicit conversion. 4) When counting posts from users with reputation over 1000: use the exact literal value 1000 for the reputation threshold. 5) When joining users and posts: use the exact join condition T1.Id = T2.OwnerUserId to link posts to their owners.",
            "1) When calculating a percentage ratio: compute (rows satisfying both conditions) divided by (rows satisfying the denominator condition) and then multiply by 100.0. 2) When filtering by year from a datetime column: use STRFTIME('%Y', T2.CreationDate) = '2011' to extract the year 2011. 3) When checking reputation condition: use T1.Reputation > 1000 to identify users with reputation over 1000. 4) When counting rows for the denominator: use COUNT(T1.Id) to count all relevant rows rather than using IIF within COUNT. 5) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId to connect posts with their owners.",
            "1) When the question asks about posts from 2011: use the exact column name \"CreaionDate\" (not \"CreationDate\") from the posts table to filter for year 2011. 2) When calculating a percentage: perform the division first, then multiply by 100 to get the correct percentage value. 3) When filtering conditions are already handled in conditional logic: avoid redundant WHERE clause filters that duplicate the same condition. 4) When joining users and posts tables: link rows where T1.Id = T2.OwnerUserId to connect posts with their owners."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Reputation > 1000 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Posts p\nJOIN \n    Users u ON p.OwnerUserId = u.Id\nWHERE \n    strftime('%Y', p.CreationDate) = '2011';",
            "SELECT \n    (SUM(IIF(T1.Reputation > 1000, 1, 0)) * 100.0 / COUNT(T1.Id)) AS Percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nWHERE \n    STRFTIME('%Y', T2.CreationDate) = '2011'",
            "SELECT \n    CAST(SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreationDate) = '2011', 1, 0)) AS REAL) / \n    CAST(COUNT(IIF(STRFTIME('%Y', T2.CreationDate) = '2011', T1.Id, NULL)) AS REAL) * 100.0 AS Percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId;",
            "SELECT \n    CAST(SUM(IIF(STRFTIME('%Y', T2.CreationDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) / COUNT(T1.Id) * 100.0 AS Percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId\nWHERE \n    STRFTIME('%Y', T2.CreationDate) = '2011'",
            "SELECT \n    CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011' AND T1.Reputation > 1000, 1, 0)) AS REAL) / COUNT(T1.Id) * 100 AS Percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(IIF(T1.Reputation > 1000 AND STRFTIME('%Y', T2.CreaionDate) = '2011', 1, 0)) AS REAL) / \n     CAST(SUM(IIF(STRFTIME('%Y', T2.CreaionDate) = '2011', 1, 0)) AS REAL)) * 100.0 AS percentage\nFROM \n    users T1\nINNER JOIN \n    posts T2 ON T1.Id = T2.OwnerUserId"
        ],
        "amend_res": 1
    },
    "1439": {
        "db_id": "student_club",
        "question": "Please list the phone numbers of the members who majored in business at the College of Agriculture and Applied Sciences.",
        "ground_truth": "SELECT T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T2.major_name = 'Business' AND T2.college = 'College of Agriculture and Applied Sciences'",
        "amends": [
            "Do select `phone` from the `member` table instead of `phone_number` from the `members` table. Do join `major` table with `INNER JOIN` on `major_id = link_to_major` instead of querying a single table. Do filter on `major_name = 'Business'` instead of `major = 'business'` to use the proper column name and case. Do keep the college filter `college = 'College of Agriculture and Applied Sciences'` but apply it to the joined major table instead of the original members table. The amended query now correctly retrieves phone numbers by joining through the major relationship using proper table relationships and column references."
        ],
        "rules": [
            "1) When the question asks for phone numbers: select the exact column \"phone\" from table \"member\" instead of \"phone_number\" from \"members\". 2) When the question mentions members who majored in a specific subject: join the \"major\" table with \"member\" using INNER JOIN where \"major_id = link_to_major\" to establish the proper relationship. 3) When filtering for business majors: use the exact condition \"major_name = 'Business'\" with proper capitalization instead of \"major = 'business'\". 4) When filtering for College of Agriculture and Applied Sciences: apply the filter \"college = 'College of Agriculture and Applied Sciences'\" to the joined major table rather than the member table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM members WHERE major = 'business' AND college = 'College of Agriculture and Applied Sciences'",
            "SELECT m.phone \nFROM member m\nINNER JOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business' \nAND maj.college = 'College of Agriculture and Applied Sciences'"
        ],
        "rule_sql": [
            "SELECT m.phone\nFROM member m\nINNER JOIN major maj ON m.link_to_major = maj.major_id\nWHERE maj.major_name = 'Business'\nAND maj.college = 'College of Agriculture and Applied Sciences'"
        ],
        "amend_res": 1
    },
    "844": {
        "db_id": "superhero",
        "question": "Give the eye colour of Blackwulf.",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Blackwulf'",
        "amends": [
            "Do select `T2.colour` from the joined table instead of `eye_color` from the base table. Do join `superhero AS T1` with `colour AS T2` using `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying a single table. Do filter on `T1.superhero_name = 'Blackwulf'` instead of `name = 'Blackwulf'` to reference the correct table and column. The amended query now correctly retrieves the eye color from the related colour table through proper table joining and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for eye colour of a character: use the colour table (T2) instead of the superhero table (T1) for the eye colour value. 2) When joining superhero table (T1) with colour table (T2): link rows where T1.eye_colour_id equals T2.id using an inner match. 3) When filtering for a specific character name: use T1.superhero_name = 'Blackwulf' with exact case and spelling. 4) When selecting the eye colour output: return T2.colour as the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM characters WHERE name = 'Blackwulf';",
            "SELECT T2.colour \nFROM superhero AS T1 \nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id \nWHERE T1.superhero_name = 'Blackwulf'"
        ],
        "rule_sql": [
            "SELECT c.colour \nFROM superhero s\nINNER JOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Blackwulf'"
        ],
        "amend_res": 1
    },
    "1519": {
        "db_id": "debit_card_specializing",
        "question": "What was the product id of the transaction happened at 2012/8/23 21:20:00?",
        "ground_truth": "SELECT T1.ProductID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'",
        "amends": [
            "Do specify `T1.ProductID` instead of `product_id` and add table alias qualification. Do change the FROM clause to use `transactions_1k AS T1` instead of `transactions` and add `INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID` instead of omitting the join. Do split the datetime filter into separate date and time components with `T1.Date = '2012-08-23' AND T1.Time = '21:20:00'` instead of using a combined `date = '2012/8/23 21:20:00'` with incorrect date format and separator. The amended query now correctly joins the necessary tables and handles the datetime filtering appropriately to match the intended behavior."
        ],
        "rules": [
            "1) When answering about transaction product ID at a specific datetime: make sure the output order: T1.ProductID. 2) When the question mentions \"transactions\": use table \"transactions_1k AS T1\" instead of \"transactions\". 3) When combining transactions and gasstations tables: link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match). 4) When filtering by datetime \"2012/8/23 21:20:00\": split into separate date and time components with T1.Date = '2012-08-23' AND T1.Time = '21:20:00' using exact date format '2012-08-23' and time format '21:20:00'. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.ProductID, T1.GasStationID, and T2.GasStationID."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_id FROM transactions WHERE date = '2012/8/23 21:20:00';",
            "SELECT T1.ProductID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'"
        ],
        "rule_sql": [
            "SELECT T1.ProductID FROM transactions_1k AS T1 WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'"
        ],
        "amend_res": 1
    },
    "1404": {
        "db_id": "student_club",
        "question": "Identify the type of expenses and their total value approved for 'October Meeting' event.",
        "ground_truth": "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'",
        "amends": [
            "Do use `T1.type` instead of `expense_type` for the expense type column. Do use `SUM(T3.cost)` instead of `SUM(amount)` for the aggregation. Do join `event AS T1` instead of querying expenses directly. Do add `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` to connect events to budgets. Do add `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` to connect budgets to expenses. Do filter on `T1.event_name = 'October Meeting'` instead of filtering expenses directly. Do remove the explicit alias `total_value` instead of keeping it. Do remove the `GROUP BY` clause instead of including it since the aggregation is now handled through proper table relationships. The amended query now correctly follows the relational structure from events to budgets to expenses."
        ],
        "rules": [
            "1) When answering about expenses for 'October Meeting' event: start from event table as T1 and filter where T1.event_name = 'October Meeting' exactly. 2) When combining events with budgets: link T1 to budget table as T2 using T1.event_id = T2.link_to_event with inner matching. 3) When combining budgets with expenses: link T2 to expense table as T3 using T2.budget_id = T3.link_to_budget with inner matching. 4) When extracting expense type: use T1.type instead of expense_type column. 5) When calculating total value: use SUM(T3.cost) instead of SUM(amount) for aggregation. 6) When producing output: do not include explicit aliases like total_value. 7) When organizing results: do not use GROUP BY clause as aggregation is handled through proper table relationships."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expense_type, SUM(amount) as total_value FROM expenses WHERE event_name = 'October Meeting' GROUP BY expense_type",
            "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'"
        ],
        "rule_sql": [
            "SELECT T1.type, SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting'"
        ],
        "amend_res": 1
    },
    "568": {
        "db_id": "codebase_community",
        "question": "Provide the display name of the user who made the vote No.6347.",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347",
        "amends": [
            "Do add `INNER JOIN votes AS T2 ON T1.Id = T2.UserId` instead of querying only the `users` table. Do reference `T2.Id` in the WHERE clause instead of `vote_id` which doesn't exist in the users table. Do use table alias `T1` and column alias `DisplayName` instead of direct table and column references. The amended query now correctly joins the users and votes tables to find the user associated with a specific vote ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the user who made vote No.6347\": make sure to combine information from both users and votes tables using an inner match. 2) When combining users table (T1) and votes table (T2): link rows where T1.Id equals T2.UserId exactly as shown in the amends. 3) When the question mentions \"vote No.6347\": this actually means T2.Id = 6347 in the schema. 4) When the question asks for \"display name\": this actually means T1.DisplayName in the schema. 5) When producing output: return only the T1.DisplayName column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users WHERE vote_id = 6347;",
            "SELECT T1.DisplayName \nFROM users AS T1 \nINNER JOIN votes AS T2 ON T1.Id = T2.UserId \nWHERE T2.Id = 6347"
        ],
        "rule_sql": [
            "SELECT u.DisplayName FROM users u INNER JOIN votes v ON u.Id = v.UserId WHERE v.Id = 6347"
        ],
        "amend_res": 1
    },
    "248": {
        "db_id": "toxicology",
        "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
        "amends": [
            "Do select `T2.atom_id` and `T2.atom_id2` instead of `atom1`, `atom2`, and `atom3`. Do add `atom AS T1` table with `INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id` instead of omitting these joins. Do add `INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id` instead of missing this table relationship. Do change filter to `T3.bond_type = '#' AND T3.molecule_id = 'TR041'` instead of `molecule = 'TR041'` to properly reference bond type and molecule ID through the correct table relationships. The amended query now correctly identifies connected atoms through bond relationships with proper table joins and filtering conditions."
        ],
        "rules": [
            "1) When answering about \"atoms of the triple bond with molecule TR041\": make sure the output order: T2.atom_id, T2.atom_id2\n2) When the question mentions \"triple bond\": \"triple bond\" actually means \"bond_type = '#' in schema\"\n3) When the question mentions \"molecule TR041\": \"TR041\" actually means \"T3.molecule_id = 'TR041' in schema\"\n4) When combining atom AS T1 and connected AS T2: link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)\n5) When combining connected AS T2 and bond AS T3: link rows where T2.bond_id = T3.bond_id and keep only matching pairs (inner match)\n6) When filtering for triple bonds: use T3.bond_type = '#' with exact literal '#'\n7) When filtering for molecule TR041: use T3.molecule_id = 'TR041' with exact literal 'TR041'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom1, atom2, atom3 FROM triple_bonds WHERE molecule = 'TR041';",
            "SELECT T2.atom_id, T2.atom_id2\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM connected AS T2\nJOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T3.bond_type = '#'\nAND T3.molecule_id = 'TR041'"
        ],
        "amend_res": 1
    },
    "551": {
        "db_id": "codebase_community",
        "question": "How many badges has the user csgillespie obtained?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do add `INNER JOIN users AS T2 ON T1.UserId = T2.Id` instead of querying only the badges table. Do change the filter to `T2.DisplayName = 'csgillespie'` instead of `user_id = 'csgillespie'` to properly reference the user's display name. Do use `COUNT(T1.Id)` instead of `COUNT(*)` for more precise counting of badge records. Do add table aliases `T1` and `T2` instead of using unaliased table names. The amended query now correctly joins the badges and users tables to count badges for a specific user by display name rather than assuming user_id matches the display name value."
        ],
        "rules": [
            "1) When answering about \"badges obtained by user csgillespie\": make sure to join badges table (T1) with users table (T2) using T1.UserId = T2.Id to properly link user records. 2) When the question mentions \"user csgillespie\": \"csgillespie\" actually means T2.DisplayName = 'csgillespie' in the schema. 3) When counting badges: compute the number of rows using the canonical key token T1.Id for precise badge counting. 4) When combining T1 and T2 for shared entities: link rows where T1.UserId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM badges WHERE user_id = 'csgillespie';",
            "SELECT COUNT(T1.Id) \nFROM badges AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "amend_res": 1
    },
    "222": {
        "db_id": "toxicology",
        "question": "What is the difference between the number of molecules that are carcinogenic and those that are not?",
        "ground_truth": "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule t",
        "amends": [
            "Do use `COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END)` instead of `COUNT(*) FROM molecules WHERE carcinogenic = 'yes' - COUNT(*) FROM molecules WHERE carcinogenic = 'no'` to properly calculate the difference between positive and negative labels in a single query. Do reference table `molecule` with alias `T` instead of `molecules` to match the correct table name. Do use column `label` with values `'+'` and `'-'` instead of `carcinogenic` with values `'yes'` and `'no'` to align with the correct column naming and value semantics. Do include `AS diff_car_notcar` to provide an explicit alias for the result instead of omitting it. The amended query now correctly computes the difference between positive and negative labeled molecules in a single table scan."
        ],
        "rules": [
            "1) When answering about the difference between carcinogenic and non-carcinogenic molecules: use the exact table name \"molecule\" with alias T instead of \"molecules\". 2) When the question mentions \"carcinogenic\" and \"not carcinogenic\": these actually mean label values '+' and '-' in the schema respectively. 3) When computing the difference between positive and negative labels: use COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) in a single query. 4) When producing output: include an explicit alias AS diff_car_notcar for the result column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE carcinogenic = 'yes' - COUNT(*) FROM molecules WHERE carcinogenic = 'no';",
            "SELECT COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar FROM molecule T"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - \n    COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) AS diff_car_notcar\nFROM molecule T"
        ],
        "amend_res": 1
    },
    "1228": {
        "db_id": "thrombosis_prediction",
        "question": "Provide list of patients and their diagnosis with triglyceride (TG) index greater than 100 of the normal range?",
        "ground_truth": "SELECT T1.ID, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG > 300",
        "amends": [
            "Do select `T1.ID` and `T1.Diagnosis` instead of `patient_name` and `diagnosis`. Do use `Patient AS T1` and `Laboratory AS T2` with an `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.TG > 300` instead of `triglyceride > 100`. The amended query now correctly joins patient and laboratory data to filter based on triglyceride levels from the laboratory table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"patients and their diagnosis with triglyceride index greater than 100 of the normal range\": make sure the output order: T1.ID, T1.Diagnosis. 2) When the question mentions \"patients\": use Patient AS T1 and Laboratory AS T2 with an INNER JOIN on T1.ID = T2.ID instead of querying only the patients table. 3) When the question mentions \"triglyceride (TG) index greater than 100 of the normal range\": T2.TG > 300 instead of triglyceride > 100. 4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_name, diagnosis FROM patients WHERE triglyceride > 100;",
            "SELECT T1.ID, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG > 300"
        ],
        "rule_sql": [
            "SELECT T1.ID, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG > 300\nORDER BY T1.ID, T1.Diagnosis;"
        ],
        "amend_res": 1
    },
    "984": {
        "db_id": "formula_1",
        "question": "What is the website of the constructor who tallied the most total wins.",
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
        "amends": [
            "Do select `T1.url` instead of `website` and add table alias `T1` for clarity. Do add `INNER JOIN` on `constructorStandings AS T2` instead of omitting this table entirely. Do join on `T1.constructorId = T2.constructorId` instead of missing the join condition. Do order by `T2.wins` instead of just `wins` to specify the table source. The amended query now correctly joins the constructors and constructorStandings tables to retrieve the URL associated with the constructor having the most wins."
        ],
        "rules": [
            "1) When the question asks for \"website\": use the exact column token \"T1.url\" instead of \"website\". 2) When combining constructors and constructorStandings tables: link rows where \"T1.constructorId = T2.constructorId\" and keep only matching pairs (inner match). 3) When the question asks for \"most total wins\": rank rows by \"T2.wins\" in descending order and keep the first 1 row. 4) When answering about constructor website with most wins: make sure the output order: \"T1.url\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website FROM constructors ORDER BY wins DESC LIMIT 1;",
            "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.url FROM constructors T1 INNER JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1187": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
        "ground_truth": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
        "amends": [
            "Do select `DISTINCT ID` instead of `patient_id` without distinct. Do use table `Laboratory` instead of `examinations`. Do use column `Date` instead of `exam_date` with proper date format `'1987-07-06'` instead of `'1987/7/6'`. Do remove the `ORDER BY patient_id` clause instead of keeping it. The amended query now correctly retrieves unique patient IDs from the Laboratory table with the specified date range and test value conditions."
        ],
        "rules": [
            "1) When the question asks for patient IDs: use the exact column token \"ID\" from the Laboratory table instead of \"patient_id\". 2) When counting distinct patients: use DISTINCT with the \"ID\" column to get unique patient identifiers. 3) When filtering by examination dates: use the \"Date\" column with proper date format '1987-07-06' to '1996-01-31' instead of '1987/7/6' to '1996/1/31'. 4) When the question mentions GPT level greater than 30: use the condition \"GPT > 30\" with the exact column name. 5) When the question mentions ALB level less than 4: use the condition \"ALB < 4\" with the exact column name. 6) When retrieving results: do not include any ORDER BY clause as the question only asks to list them by ID without specifying ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM examinations WHERE exam_date BETWEEN '1987/7/6' AND '1996/1/31' AND GPT > 30 AND ALB < 4 ORDER BY patient_id;",
            "SELECT DISTINCT ID \nFROM Laboratory \nWHERE Date BETWEEN '1987-07-06' AND '1996-01-31' \nAND GPT > 30 \nAND ALB < 4"
        ],
        "rule_sql": [
            "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4"
        ],
        "amend_res": 1
    },
    "1486": {
        "db_id": "debit_card_specializing",
        "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
        "ground_truth": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
        "amends": [
            "Do use `SUM(Currency = 'CZK') - SUM(Currency = 'EUR')` instead of `COUNT(CASE WHEN currency = 'CZK' THEN 1 END) - COUNT(CASE WHEN currency = 'EUR' THEN 1 END)` for the difference calculation. Do change the table source from `sme_payments` to `customers` instead of the original table. Do add `WHERE Segment = 'SME'` filter instead of `WHERE currency IN ('CZK', 'EUR')`. Do remove the individual count columns `czk_count` and `eur_count` instead of including them. Do use boolean aggregation with `SUM()` instead of `COUNT(CASE...)` expressions. The amended query now correctly calculates the difference between CZK and EUR currencies for SME segment customers."
        ],
        "rules": [
            "1) When the question asks about SMEs: filter to only include rows where \"Segment\" equals exactly 'SME'. 2) When counting payments in specific currencies: use boolean aggregation with SUM() where \"Currency\" equals exactly 'CZK' for Czech koruna and exactly 'EUR' for euros. 3) When calculating the difference between two counts: compute SUM(Currency = 'CZK') - SUM(Currency = 'EUR') to get how many more SMEs pay in Czech koruna than in euros. 4) When the question asks \"how many more\": only output the difference value, not the individual currency counts. 5) When querying customer payment data: use the \"customers\" table instead of any other table source."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN currency = 'CZK' THEN 1 END) AS czk_count,\n    COUNT(CASE WHEN currency = 'EUR' THEN 1 END) AS eur_count,\n    COUNT(CASE WHEN currency = 'CZK' THEN 1 END) - COUNT(CASE WHEN currency = 'EUR' THEN 1 END) AS difference\nFROM sme_payments\nWHERE currency IN ('CZK', 'EUR');",
            "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') AS difference\nFROM customers\nWHERE Segment = 'SME';"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) - SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS difference\nFROM customers\nWHERE Segment = 'SME';"
        ],
        "amend_res": 1
    },
    "1510": {
        "db_id": "debit_card_specializing",
        "question": "What is the average total price of the transactions taken place in gas stations in the Czech Republic?",
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'",
        "amends": [
            "Do reference the `transactions_1k` table as `T1` instead of `transactions`, and use `gasstations` as `T2` instead of omitting it. Do perform an `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of filtering directly on location. Do filter on `T2.Country = 'CZE'` instead of `country = 'Czech Republic'` to use the country code. Do select `AVG(T1.Price)` instead of `AVG(total_price)` to reference the correct column. The amended query now correctly joins the transactions with gas station details and uses proper country code filtering."
        ],
        "rules": [
            "1) When answering about average transaction price in gas stations in the Czech Republic: make sure the output order: AVG(T1.Price). 2) When the question mentions \"gas stations\": use table \"gasstations\" as T2 and join with T1 using T1.GasStationID = T2.GasStationID. 3) When the question mentions \"Czech Republic\": use country code 'CZE' instead of the full name, filtering on T2.Country = 'CZE'. 4) When computing average transaction price: use T1.Price column instead of total_price. 5) When combining transactions and gas stations: perform an inner join where T1.GasStationID equals T2.GasStationID to ensure only matching pairs are included."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(total_price) FROM transactions WHERE location = 'gas station' AND country = 'Czech Republic';",
            "SELECT AVG(T1.Price) \nFROM transactions_1k T1\nINNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.Price) \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE'"
        ],
        "amend_res": 1
    },
    "987": {
        "db_id": "formula_1",
        "question": "What is the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix?",
        "ground_truth": "SELECT AVG(T1.fastestLapTime) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank < 11 AND T2.year = 2006 AND T2.name = 'United States Grand Prix'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of no aliases. Do join `results AS T1` with `races AS T2` on `T1.raceId = T2.raceId` instead of querying only `race_results`. Do filter on `T1.rank < 11` instead of using `LIMIT 10` with `ORDER BY position ASC`. Do filter on `T2.year = 2006` and `T2.name = 'United States Grand Prix'` instead of filtering directly on the results table. Do remove `ORDER BY position ASC` and `LIMIT 10` instead of keeping them since the aggregation makes them unnecessary. The amended query now correctly calculates the average fastest lap time for top 10 finishers in the specified race by using proper table joins and filtering logic."
        ],
        "rules": [
            "1) When answering about \"average fastest lap time of the top 10 drivers\": make sure the output order: AVG(T1.fastest_lap_time). 2) When the question mentions \"top 10 drivers\": use T1.rank < 11 instead of LIMIT with ORDER BY. 3) When combining results (T1) and races (T2) tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 4) When filtering for the 2006 United States Grand Prix: use T2.year = 2006 and T2.name = 'United States Grand Prix' exactly as specified. 5) When performing aggregation: remove ORDER BY and LIMIT clauses since they are unnecessary for aggregate calculations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fastest_lap_time) \nFROM race_results \nWHERE race_name = 'United States Grand Prix' \nAND year = 2006 \nORDER BY position ASC \nLIMIT 10;",
            "SELECT AVG(T1.fastestLapTime) AS average_fastest_lap_time\nFROM results AS T1\nJOIN races AS T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2006\nAND T2.name = 'United States Grand Prix'\nAND T1.rank < 11"
        ],
        "rule_sql": [
            "SELECT AVG(T1.fastestLapTime) \nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nWHERE T2.year = 2006 \nAND T2.name = 'United States Grand Prix'\nAND T1.rank < 11"
        ],
        "amend_res": 1
    },
    "1116": {
        "db_id": "european_football_2",
        "question": "List down most tallest players' name.",
        "ground_truth": "SELECT player_name FROM (SELECT player_name, height, DENSE_RANK() OVER (ORDER BY height DESC) as rank FROM Player) WHERE rank = 1",
        "amends": [
            "Do select `player_name` instead of `name` and use a subquery with `DENSE_RANK()` window function instead of simple `ORDER BY` with `LIMIT 1`. Do add `height` column in the subquery for ranking instead of omitting it. Do use `ORDER BY height DESC` in the window function instead of `ORDER BY height ASC` to properly rank tallest players. Do filter by `rank = 1` in the outer query instead of using `LIMIT 1` to handle ties correctly. The amended query now matches RIGHT_SQL's behavior by returning all players with the maximum height using dense ranking instead of just one arbitrary player."
        ],
        "rules": [
            "1) When the question asks for \"most tallest players' name\": use \"player_name\" from table \"Player\" instead of \"name\" from table \"Country\". 2) When ranking players by height to find tallest: use \"height\" column from table \"Player\" and order in descending direction. 3) When handling ties for tallest players: use dense ranking to assign the same rank to players with equal height values. 4) When selecting the tallest players: filter to include all players with rank = 1 to handle multiple players with maximum height."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY height ASC LIMIT 1;",
            "SELECT player_name\nFROM (\n    SELECT \n        player_name,\n        height,\n        DENSE_RANK() OVER (ORDER BY height DESC) as rank\n    FROM Player\n) ranked_players\nWHERE rank = 1;"
        ],
        "rule_sql": [
            "WITH RankedPlayers AS (\n    SELECT \n        player_name,\n        height,\n        DENSE_RANK() OVER (ORDER BY height DESC) as height_rank\n    FROM Player\n)\nSELECT player_name\nFROM RankedPlayers\nWHERE height_rank = 1\nORDER BY player_name;"
        ],
        "amend_res": 1
    },
    "221": {
        "db_id": "toxicology",
        "question": "What are the atoms that are bonded in the molecule TR001 with the bond ID of TR001_2_6?",
        "ground_truth": "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1 , T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'",
        "amends": [
            "Do select `SUBSTR(T.bond_id, 1, 7) AS atom_id1` and `T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2` instead of `*` from all columns. Do query from `bond AS T` instead of `atoms` table. Do keep `T.molecule_id = 'TR001'` filter but change `atom_id = 'TR001_2_6'` to `T.bond_id = 'TR001_2_6'` in the WHERE clause. The amended query now correctly retrieves bond information with proper atom ID construction instead of incorrectly querying the atoms table."
        ],
        "rules": [
            "1) When answering about atoms bonded in a molecule with a specific bond ID: query from the bond table (aliased as T) instead of the atoms table. 2) When the question mentions bond ID \"TR001_2_6\": use exact literal filter T.bond_id = 'TR001_2_6' in the WHERE clause. 3) When the question mentions molecule \"TR001\": use exact literal filter T.molecule_id = 'TR001' in the WHERE clause. 4) When retrieving atom information from bond data: construct atom_id1 as SUBSTR(T.bond_id, 1, 7) and atom_id2 as T.molecule_id || SUBSTR(T.bond_id, 8, 2) instead of selecting all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM atoms WHERE molecule_id = 'TR001' AND atom_id = 'TR001_2_6';",
            "SELECT SUBSTR(T.bond_id, 1, 7) AS atom_id1, T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2 FROM bond AS T WHERE T.molecule_id = 'TR001' AND T.bond_id = 'TR001_2_6'"
        ],
        "rule_sql": [
            "SELECT \n    SUBSTR(T.bond_id, 1, 7) AS atom_id1,\n    T.molecule_id || SUBSTR(T.bond_id, 8, 2) AS atom_id2\nFROM \n    bond AS T\nWHERE \n    T.bond_id = 'TR001_2_6' AND \n    T.molecule_id = 'TR001'"
        ],
        "amend_res": 1
    },
    "816": {
        "db_id": "superhero",
        "question": "Provide the names of superheroes with attribute value between 75 to 80.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T2.attribute_value BETWEEN 75 AND 80",
        "amends": [
            "Do select `T1.superhero_name` from the `superhero` table instead of `name` from a single table. Do join `hero_attribute AS T2` using `INNER JOIN` with predicate `T1.id = T2.hero_id` instead of querying a single table without joins. Do filter with `BETWEEN 75 AND 80` instead of the impossible condition `>= 80 AND <= 75`. The amended query now correctly retrieves superhero names based on attribute values within the specified range."
        ],
        "rules": [
            "1) When answering about superhero names with attribute values between 75 and 80: make sure the output order: T1.superhero_name. 2) When the question mentions \"superheroes\": \"superheroes\" actually means \"superhero\" table as T1 and \"hero_attribute\" table as T2 in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering attribute values between 75 and 80: use the exact range condition BETWEEN 75 AND 80 instead of impossible conditions like >= 80 AND <= 75."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE attribute_value >= 80 AND attribute_value <= 75;",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T2.attribute_value BETWEEN 75 AND 80"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T2.attribute_value BETWEEN 75 AND 80\nORDER BY T1.superhero_name;"
        ],
        "amend_res": 1
    },
    "1415": {
        "db_id": "student_club",
        "question": "List out the position of members who joined major of Business.",
        "ground_truth": "SELECT T2.position FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business'",
        "amends": [
            "Do select `T2.position` from the `member` table instead of `position` from the `members` table. Do join `major AS T1` with `member AS T2` using `INNER JOIN` on `T1.major_id = T2.link_to_major` instead of querying only the `members` table. Do filter on `T1.major_name = 'Business'` instead of `major = 'Business'` to properly reference the major name from the correct table. The amended query now correctly retrieves positions by joining through the proper relationship between major and member tables."
        ],
        "rules": [
            "1) When answering about \"position of members who joined major of Business\": make sure the output order: T2.position 2) When the question mentions \"major of Business\": \"Business\" actually means \"T1.major_name = 'Business'\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.major_id = T2.link_to_major exactly as shown in the amends; keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT position FROM members WHERE major = 'Business';",
            "SELECT T2.position \nFROM member AS T2\nINNER JOIN major AS T1 ON T1.major_id = T2.link_to_major\nWHERE T1.major_name = 'Business'"
        ],
        "rule_sql": [
            "SELECT T2.position FROM major T1 INNER JOIN member T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business'"
        ],
        "amend_res": 1
    },
    "227": {
        "db_id": "toxicology",
        "question": "What is the percentage of molecules that are carcinogenic? Please provide your answer as a percentage with three decimal places.",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3) FROM molecule t",
        "amends": [
            "Do use `ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id),3)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM molecules)` for the percentage calculation. Do reference table alias `T` instead of direct table name `molecules`. Do filter with `CASE WHEN T.label = '+'` instead of `WHERE carcinogenic = 'yes'`. Do remove the subquery and instead use `COUNT(T.molecule_id)` in the denominator. Do add `ROUND` function with precision 3 instead of keeping unrounded decimal. The amended query now correctly calculates the percentage of molecules with '+' label using proper case logic and rounding."
        ],
        "rules": [
            "1) When calculating percentage of molecules that are carcinogenic: use T.label = '+' instead of carcinogenic = 'yes' to identify carcinogenic molecules. 2) When computing the percentage: use COUNT(T.molecule_id) as the denominator instead of a subquery with COUNT(*). 3) When counting carcinogenic molecules: use COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) instead of simple COUNT(*). 4) When formatting the result: apply ROUND function with precision 3 to get three decimal places in the percentage. 5) When referencing the molecules table: use alias T consistently throughout the query."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM molecules)) AS percentage_carcinogenic FROM molecules WHERE carcinogenic = 'yes';",
            "SELECT ROUND(CAST(COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T.molecule_id), 3) AS percentage\nFROM molecule T"
        ],
        "rule_sql": [
            "SELECT \n    ROUND(\n        (COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) * 100.0 / COUNT(T.molecule_id)), \n        3\n    ) AS percentage_carcinogenic\nFROM \n    molecule T"
        ],
        "amend_res": 1
    },
    "854": {
        "db_id": "formula_1",
        "question": "What is the coordinates location of the circuits for Australian grand prix?",
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T1.lat` and `T1.lng` with table aliases instead of `latitude` and `longitude` without aliases. Do add `races AS T2` table instead of querying only the `circuits` table. Do use `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of no join condition. Do change the filter to `T2.name = 'Australian Grand Prix'` instead of `country = 'Australia' AND name LIKE '%grand prix%'` to precisely match race names rather than circuit attributes. The amended query now correctly retrieves coordinates for circuits that have hosted the specific Australian Grand Prix race."
        ],
        "rules": [
            "1) When answering about coordinates location of circuits for Australian grand prix: make sure the output order: T1.lat, T1.lng\n2) When the question mentions \"Australian grand prix\": \"Australian grand prix\" actually means T2.name = 'Australian Grand Prix' in schema\n3) When combining T1 and T2 for shared entities: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)\n4) When selecting coordinate columns: use T1.lat and T1.lng with table aliases instead of latitude and longitude without aliases\n5) When eliminating duplicate rows: use DISTINCT to ensure each circuit appears only once in results"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude FROM circuits WHERE country = 'Australia' AND name LIKE '%grand prix%';",
            "SELECT DISTINCT T1.lat, T1.lng\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'Australian Grand Prix';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.lat, T1.lng\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'Australian Grand Prix'"
        ],
        "amend_res": 1
    },
    "223": {
        "db_id": "toxicology",
        "question": "What are the atom IDs of the bond TR000_2_5?",
        "ground_truth": "SELECT T.atom_id FROM connected AS T WHERE T.bond_id = 'TR000_2_5'",
        "amends": [
            "Do reference table `connected` with alias `T` instead of table `bonds` without an alias. Do use qualified column `T.atom_id` instead of unqualified `atom_id`. Do maintain the filter `T.bond_id = 'TR000_2_5'` with the same predicate logic. The amended query now correctly queries from the appropriate table structure while preserving the intended filtering behavior."
        ],
        "rules": [
            "1) When answering about \"atom IDs of the bond TR000_2_5\": make sure the output order: T.atom_id. 2) When the question mentions \"bond TR000_2_5\": use the exact literal 'TR000_2_5' for filtering. 3) When querying for atom IDs related to bonds: use table \"connected\" with alias T instead of table \"bonds\". 4) When filtering by bond_id: use qualified column T.bond_id = 'TR000_2_5' with exact literal matching. 5) When selecting atom_id: use qualified column T.atom_id from the connected table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id FROM bonds WHERE bond_id = 'TR000_2_5';",
            "SELECT T.atom_id FROM connected T WHERE T.bond_id = 'TR000_2_5'"
        ],
        "rule_sql": [
            "SELECT T.atom_id FROM connected T WHERE T.bond_id = 'TR000_2_5'"
        ],
        "amend_res": 1
    },
    "545": {
        "db_id": "codebase_community",
        "question": "Among the posts owned by csgillespie, how many of them are root posts?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL",
        "amends": [
            "Do join `users` as `T2` on `T1.OwnerUserId = T2.Id` instead of querying `posts` alone without any join. Do filter by `T2.DisplayName = 'csgillespie'` instead of directly using `owner = 'csgillespie'`. Do count `T1.Id` instead of `COUNT(*)` for more precise counting. Do reference `T1.ParentId` instead of `parent_id` with proper table qualification. The amended query now correctly counts posts by joining with users table to match on display name rather than assuming owner field contains the username directly, ensuring accurate user-specific post counting."
        ],
        "rules": [
            "1) When answering about posts owned by a specific user: join the posts table (T1) with the users table (T2) where T1.OwnerUserId equals T2.Id to correctly link posts to users. 2) When filtering for posts owned by 'csgillespie': use T2.DisplayName = 'csgillespie' instead of directly filtering on owner field. 3) When counting posts: count T1.Id instead of using COUNT(*) for more precise counting. 4) When identifying root posts: check if T1.ParentId is NULL to find posts without parent posts."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE owner = 'csgillespie' AND parent_id IS NULL",
            "SELECT COUNT(T1.Id) \nFROM posts T1\nJOIN users T2 ON T1.OwnerUserId = T2.Id\nWHERE T2.DisplayName = 'csgillespie' AND T1.ParentId IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(p.Id) \nFROM posts p\nJOIN users u ON p.OwnerUserId = u.Id\nWHERE u.DisplayName = 'csgillespie' \nAND p.ParentId IS NULL"
        ],
        "amend_res": 1
    },
    "265": {
        "db_id": "toxicology",
        "question": "List down the molecule id for non carcinogenic molecules.",
        "ground_truth": "SELECT T.molecule_id FROM molecule AS T WHERE T.label = '-'",
        "amends": [
            "Do reference the table with alias `T` instead of using the bare table name. Do select from table `molecule` instead of `molecules`. Do filter on column `label` with value `'-'` instead of filtering on column `carcinogenic` with value `'yes'`. The amended query now correctly selects molecule IDs from the molecule table where the label equals a dash character, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"non carcinogenic molecules\": filter rows where T.label equals exactly '-' 2) When selecting from the molecule table: use alias T for the molecule table 3) When outputting molecule identifiers: select the molecule_id column from table T"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM molecules WHERE carcinogenic = 'yes';",
            "SELECT T.molecule_id FROM molecule T WHERE T.label = '-'"
        ],
        "rule_sql": [
            "SELECT T.molecule_id FROM molecule T WHERE T.label = '-'"
        ],
        "amend_res": 1
    },
    "840": {
        "db_id": "superhero",
        "question": "List the attribute value of the superhero named Aquababy.",
        "evidence": "",
        "ground_truth": "SELECT T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Aquababy'",
        "amends": [
            "Do select `T2.attribute_value` instead of `*` for all columns. Do use table aliases `T1` and `T2` instead of no aliases. Do join `hero_attribute AS T2` on `T1.id = T2.hero_id` instead of querying only the `superheroes` table. Do filter on `T1.superhero_name = 'Aquababy'` instead of `name = 'Aquaman'`. The amended query now correctly retrieves attribute values for the specified superhero by joining related tables with proper column references."
        ],
        "rules": [
            "1) When answering about \"attribute value of the superhero named Aquababy\": make sure the output order: T2.attribute_value. 2) When the question mentions \"superhero named Aquababy\": \"Aquababy\" actually means T1.superhero_name = 'Aquababy' in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM superheroes WHERE name = 'Aquaman';",
            "SELECT T2.attribute_value\nFROM superhero AS T1\nJOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Aquababy'"
        ],
        "rule_sql": [
            "SELECT T2.attribute_value\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nWHERE T1.superhero_name = 'Aquababy'"
        ],
        "amend_res": 1
    },
    "130": {
        "db_id": "financial",
        "question": "How many of the account holders in South Bohemia still do not own credit cards?",
        "ground_truth": "SELECT COUNT(T3.account_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.client_id = T3.client_id WHERE T1.A3 = 'south Bohemia' AND T3.type != 'OWNER'",
        "amends": [
            "Do join `district AS T1` and `client AS T2` on `T1.district_id = T2.district_id` instead of querying `account_holders` directly. Do join `disp AS T3` on `T2.client_id = T3.client_id` instead of omitting these table relationships. Do filter on `T1.A3 = 'south Bohemia'` instead of `region = 'South Bohemia'` to use the correct column name and case. Do filter on `T3.type != 'OWNER'` instead of `credit_card_owned = 'No'` to use the proper exclusion logic. Do count `T3.account_id` instead of `COUNT(*)` to target the specific relationship. The amended query now correctly identifies non-owner accounts in the South Bohemia region through proper table joins and filtering."
        ],
        "rules": [
            "1) When answering about account holders in South Bohemia: join district table as T1 and client table as T2 where T1.district_id = T2.district_id. 2) When identifying account relationships: join disp table as T3 where T2.client_id = T3.client_id. 3) When filtering for South Bohemia region: use T1.A3 = 'south Bohemia' with exact case and spacing. 4) When excluding credit card owners: filter where T3.type != 'OWNER' to identify non-owner accounts. 5) When counting account holders: count T3.account_id instead of all rows to target the specific relationship."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM account_holders WHERE region = 'South Bohemia' AND credit_card_owned = 'No';",
            "SELECT COUNT(DISTINCT T3.account_id) \nFROM district AS T1 \nJOIN client AS T2 ON T1.district_id = T2.district_id \nJOIN disp AS T3 ON T2.client_id = T3.client_id \nWHERE T1.A3 = 'south Bohemia' \nAND T3.type != 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T3.account_id) \nFROM district AS T1\nJOIN client AS T2 ON T1.district_id = T2.district_id\nJOIN disp AS T3 ON T2.client_id = T3.client_id\nWHERE T1.A3 = 'south Bohemia' \nAND T3.type != 'OWNER'"
        ],
        "amend_res": 1
    },
    "515": {
        "db_id": "card_games",
        "question": "When was the oldest mythic card released and what are its legal play formats?",
        "ground_truth": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
        "amends": [
            "Do select `originalReleaseDate` and `format` instead of `release_date` and `legal_formats`. Do join `cards` with `legalities` on `uuid` instead of querying a single table. Do filter by `rarity = 'mythic'` instead of `card_type = 'mythic'`. Do add `originalReleaseDate IS NOT NULL` and `status = 'Legal'` conditions instead of omitting them. Do use table aliases `T1` and `T2` instead of no aliases. The amended query now correctly joins card data with legality information and applies proper filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"oldest mythic card\": make sure the output order: \"originalReleaseDate\" then \"format\". 2) When the question mentions \"mythic card\": \"mythic\" actually means \"rarity = 'mythic'\" in schema. 3) When combining T1 (cards) and T2 (legalities) for shared entities: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match). 4) When filtering for legal play formats: include only rows where T2.status = 'Legal'. 5) When handling date filtering: exclude rows where T1.originalReleaseDate IS NOT NULL. 6) When ordering by release date: sort by T1.originalReleaseDate in ascending order to find the oldest card. 7) When selecting the oldest card: take only the first row after ordering by T1.originalReleaseDate."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT release_date, legal_formats FROM cards WHERE card_type = 'mythic' ORDER BY release_date ASC LIMIT 1;",
            "SELECT T1.originalReleaseDate, T2.format\nFROM cards T1\nJOIN legalities T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'mythic'\nAND T1.originalReleaseDate IS NOT NULL\nAND T2.status = 'Legal'\nORDER BY T1.originalReleaseDate ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT c.originalReleaseDate, l.format\nFROM cards c\nINNER JOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'mythic'\nAND c.originalReleaseDate IS NOT NULL\nAND l.status = 'Legal'\nORDER BY c.originalReleaseDate ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "336": {
        "db_id": "toxicology",
        "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
        "amends": [
            "Do select `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all rows. Do join `molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table to properly relate molecules to their bonds. Do filter on `T2.bond_type = '#'` instead of `bond_type = 'triple'` to use the correct symbol representation for triple bonds. Do filter on `T1.label = '-'` instead of `carcinogenic = 'yes'` to use the proper column name and value for carcinogenic identification. The amended query now correctly counts distinct carcinogenic molecules with triple bonds by properly joining the molecule and bond tables and using the appropriate filter conditions."
        ],
        "rules": [
            "1) When counting molecules: count distinct T1.molecule_id instead of counting all rows. 2) When relating molecules to bonds: join molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id to properly connect molecules with their bonds. 3) When filtering for triple bonds: use T2.bond_type = '#' instead of 'triple' to match the correct symbol representation. 4) When identifying carcinogenic molecules: use T1.label = '-' instead of carcinogenic = 'yes' to use the proper column name and value for carcinogenic identification."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE bond_type = 'triple' AND carcinogenic = 'yes';",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '#' AND T1.label = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '#' \nAND T1.label != '-'",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM molecule AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '#' \nAND T1.label != '-'"
        ],
        "amend_res": 1
    },
    "492": {
        "db_id": "card_games",
        "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
        "ground_truth": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
        "amends": [
            "Do select `type` instead of `expansion_type` to reference the correct column name. Do use `LIKE '%FROM the Vault: Lore%'` instead of exact equality `= 'From the Vault: Lore'` to allow for case-insensitive matching and potential surrounding text variations. End with confirmation that the amended query now correctly retrieves the set type using flexible pattern matching."
        ],
        "rules": [
            "1) When the question asks about \"expansion type\" for a Magic: The Gathering set: use the column \"type\" from the sets table instead of \"expansion_type\". 2) When matching set names like \"From the Vault: Lore\": use pattern matching with LIKE '%FROM the Vault: Lore%' instead of exact equality to allow for case-insensitive matching and potential text variations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expansion_type FROM sets WHERE name = 'From the Vault: Lore';",
            "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%';"
        ],
        "rule_sql": [
            "SELECT type FROM sets WHERE name LIKE '%From the Vault: Lore%';"
        ],
        "amend_res": 1
    },
    "483": {
        "db_id": "card_games",
        "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
        "ground_truth": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
        "amends": [
            "Do select `T1.text` from the `foreign_data` table instead of `english_text` from the `cards` table. Do add `DISTINCT` to eliminate duplicate results instead of omitting it. Do change the FROM clause to use `foreign_data AS T1` instead of only `cards`. Do add `INNER JOIN cards AS T2 ON T2.uuid = T1.uuid` to properly link the tables instead of querying cards directly. Do add `INNER JOIN sets AS T3 ON T3.code = T2.setCode` to join with the sets table instead of filtering by set_name directly. Do change the WHERE condition to use `T3.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'` to filter by set name through the proper relationship. Do keep `T1.language = 'Italian'` but reference it through the foreign_data table instead of the cards table. The amended query now correctly retrieves Italian text from the foreign_data table while properly joining through the cards and sets tables to filter by set name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"Italian text ruling of cards in set Coldsnap\": make sure the output order: T1.text\n2) When the question mentions \"Italian text\": \"Italian text\" actually means \"T1.text in foreign_data table where T1.language = 'Italian'\"\n3) When the question mentions \"cards in the set Coldsnap\": this requires joining T1 (foreign_data) with T2 (cards) on T2.uuid = T1.uuid, then joining T2 with T3 (sets) on T3.code = T2.setCode, and filtering where T3.name = 'Coldsnap'\n4) When combining tables for shared entities: link rows where T2.uuid = T1.uuid and T3.code = T2.setCode; keep only matching pairs (inner match)\n5) When eliminating duplicate results: use DISTINCT on the output to ensure unique T1.text values\n6) When handling text literals: use exact literal 'Italian' for language and 'Coldsnap' for set name with exact case and spelling"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT english_text FROM cards WHERE set_name = 'Coldsnap' AND language = 'Italian';",
            "SELECT DISTINCT T1.text \nFROM foreign_data AS T1\nINNER JOIN cards AS T2 ON T2.uuid = T1.uuid\nINNER JOIN sets AS T3 ON T3.code = T2.setCode\nWHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.text\nFROM foreign_data T1\nJOIN cards T2 ON T2.uuid = T1.uuid\nJOIN sets T3 ON T3.code = T2.setCode\nWHERE T1.language = 'Italian'\nAND T3.name = 'Coldsnap'\nORDER BY T1.text;"
        ],
        "amend_res": 1
    },
    "43": {
        "db_id": "california_schools",
        "question": "What is the average math score of the school with the lowest average score for all subjects, and in which county is it located?",
        "ground_truth": "SELECT T1.AvgScrMath, T2.County FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.AvgScrMath IS NOT NULL ORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC LIMIT 1",
        "amends": [
            "Do select `T1.AvgScrMath` and `T2.County` instead of `AVG(math_score)` and `county`. Do use `FROM satscores AS T1 INNER JOIN schools AS T2` instead of `FROM schools` alone. Do add join condition `ON T1.cds = T2.CDSCode` instead of omitting it. Do add `WHERE T1.AvgScrMath IS NOT NULL` filter instead of omitting null handling. Do change ordering to `T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC` instead of `AVG(math_score) ASC`. Do remove `GROUP BY school_id` instead of keeping it. The amended query now correctly joins the relevant tables, handles null values, and orders by the appropriate composite score to match the intended behavior."
        ],
        "rules": [
            "1) When answering about average math score and county location: make sure the output order: T1.AvgScrMath, T2.County\n2) When the question mentions \"math score\": \"math score\" actually means \"T1.AvgScrMath in schema\"\n3) When the question mentions \"county\": \"county\" actually means \"T2.County in schema\"\n4) When combining T1 (satscores) and T2 (schools) for shared entities: link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)\n5) When handling average scores: filter out null values using T1.AvgScrMath IS NOT NULL\n6) When the question asks for the school with the lowest average score for all subjects: rank rows by T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite in ascending order and keep the first 1 row\n7) When computing the lowest average: do not use GROUP BY since we want individual school records, not aggregated groups"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(math_score), county FROM schools GROUP BY school_id ORDER BY AVG(math_score) ASC LIMIT 1;",
            "SELECT T1.AvgScrMath, T2.County \nFROM satscores AS T1 \nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode \nWHERE T1.AvgScrMath IS NOT NULL \nORDER BY T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.AvgScrMath, T2.County\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.AvgScrMath IS NOT NULL AND T1.AvgScrRead IS NOT NULL AND T1.AvgScrWrite IS NOT NULL\nORDER BY (T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite) ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "84": {
        "db_id": "california_schools",
        "question": "What are the two most common first names among the school administrators? Indicate the district to which they administer.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.AdmFName1, T1.District FROM schools AS T1 INNER JOIN ( SELECT admfname1 FROM schools GROUP BY admfname1 ORDER BY COUNT(admfname1) DESC LIMIT 2 ) AS T2 ON T1.AdmFName1 = T2.admfname1",
        "amends": [
            "Do select `AdmFName1` and `District` columns instead of `first_name` and `district`. Do use `DISTINCT` instead of omitting it. Do join the main `schools` table (aliased as `T1`) with a subquery instead of querying only the `administrators` table. Do use `INNER JOIN` on `T1.AdmFName1 = T2.admfname1` instead of grouping by `first_name` alone. Do move the aggregation and limit to a subquery that groups by `admfname1`, orders by `COUNT(admfname1) DESC`, and applies `LIMIT 2` instead of performing these operations directly on the main result set. The amended query now correctly identifies the top 2 most common administrator first names across districts while preserving district information, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"most common first names among school administrators\": select \"AdmFName1\" and \"District\" columns instead of generic \"first_name\" and \"district\". 2) When counting administrator first names: use DISTINCT to count unique values of \"admfname1\" instead of counting all rows. 3) When combining data from multiple tables: join the main \"schools\" table (aliased as T1) with a subquery using INNER JOIN on T1.AdmFName1 = T2.admfname1 instead of querying only one table. 4) When finding the top 2 most common names: perform aggregation in a subquery that groups by \"admfname1\", orders by COUNT(admfname1) DESC, and applies LIMIT 2 instead of performing these operations directly on the main result set. 5) When handling identifier delimiters: use exact column names \"AdmFName1\" and \"District\" as shown in the schema, without changing case or quoting."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT first_name, district, COUNT(*) as count\nFROM administrators\nGROUP BY first_name\nORDER BY count DESC\nLIMIT 2;",
            "SELECT T1.AdmFName1, T1.District\nFROM schools T1\nINNER JOIN (\n    SELECT AdmFName1\n    FROM schools\n    WHERE AdmFName1 IS NOT NULL\n    GROUP BY AdmFName1\n    ORDER BY COUNT(AdmFName1) DESC\n    LIMIT 2\n) T2 ON T1.AdmFName1 = T2.AdmFName1\nWHERE T1.AdmFName1 IS NOT NULL\nGROUP BY T1.AdmFName1, T1.District"
        ],
        "rule_sql": [
            "SELECT T1.AdmFName1, T1.District\nFROM schools T1\nINNER JOIN (\n    SELECT AdmFName1, COUNT(DISTINCT AdmFName1) as name_count\n    FROM schools\n    WHERE AdmFName1 IS NOT NULL\n    GROUP BY AdmFName1\n    ORDER BY name_count DESC\n    LIMIT 2\n) T2 ON T1.AdmFName1 = T2.AdmFName1\nWHERE T1.AdmFName1 IS NOT NULL\nORDER BY T2.name_count DESC, T1.AdmFName1;",
            "SELECT T1.AdmFName1, T1.District\nFROM schools T1\nINNER JOIN (\n    SELECT AdmFName1\n    FROM schools\n    WHERE AdmFName1 IS NOT NULL\n    GROUP BY AdmFName1\n    ORDER BY COUNT(DISTINCT AdmFName1) DESC\n    LIMIT 2\n) T2 ON T1.AdmFName1 = T2.AdmFName1\nWHERE T1.AdmFName1 IS NOT NULL\nGROUP BY T1.AdmFName1, T1.District;"
        ],
        "amend_res": 1
    },
    "363": {
        "db_id": "card_games",
        "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
        "amends": [
            "Do `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count unique cards. Do `INNER JOIN legalities AS T2` instead of `JOIN legalities l` with the table alias change. Do join on `T1.uuid = T2.uuid` instead of `c.id = l.card_id` to use UUID matching. Do filter with `T2.status = 'Restricted'` instead of `l.status = 'restricted'` to match the exact case-sensitive value. Do use `T1.isStarter = 1` instead of joining with `decks d` and filtering `d.type = 'starter'` to directly check the card's starter status property. Do remove the unnecessary `decks` table join entirely instead of including it. The amended query now correctly counts distinct restricted starter cards using proper UUID joins and direct boolean checks."
        ],
        "rules": [
            "1) When counting cards: count distinct values of T1.id instead of counting all rows. 2) When joining cards and legalities tables: use T1.uuid = T2.uuid for matching instead of id-based joins. 3) When filtering for restricted status: use T2.status = 'Restricted' with exact case-sensitive matching instead of 'restricted'. 4) When checking for starter deck cards: use T1.isStarter = 1 instead of joining with a decks table. 5) When the question involves deck types: do not include unnecessary table joins when direct boolean properties are available."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards c JOIN legalities l ON c.id = l.card_id JOIN decks d ON c.deck_id = d.id WHERE l.status = 'restricted' AND d.type = 'starter';",
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid\nWHERE T2.status = 'Restricted' AND T1.isStarter = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nJOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' \nAND T1.isStarter = 1"
        ],
        "amend_res": 1
    },
    "314": {
        "db_id": "toxicology",
        "question": "How many single bonds are there in the list?",
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '-'",
        "amends": [
            "Do reference the table with alias `T` instead of using the bare table name. Do count `T.bond_id` instead of `*` to exclude NULL values. Do filter for `T.bond_type = '-'` instead of `'double'` to match the correct bond type criteria. The amended query now correctly counts non-NULL bond_id values for bonds with the specified bond type, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"how many single bonds\": make sure the output order: count of bonds with single bond type. 2) When the question mentions \"single bonds\": \"single bonds\" actually means \"bond_type = '-' in schema\". 3) When counting bonds: compute the number of rows using the canonical key token T.bond_id to exclude NULL values. 4) When filtering for bond type: use the exact literal '-' with single quotes to match the correct bond type criteria."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM bonds WHERE bond_type = 'double';",
            "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(bond_id) FROM bond WHERE bond_type = '-'"
        ],
        "amend_res": 1
    },
    "1460": {
        "db_id": "student_club",
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "ground_truth": "SELECT T2.first_name, T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "amends": [
            "Do select `T2.first_name`, `T2.last_name`, and `T1.cost` instead of `m.first_name`, `m.last_name`, and `SUM(i.cost) AS total_cost`. Do use `FROM expense AS T1` instead of `FROM members m` and change the source table structure. Do use `INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id` instead of joining through `purchases` and `items` tables with different join conditions. Do apply filter `WHERE T1.expense_description = 'Water, Veggie tray, supplies'` instead of filtering on `i.item_name IN ('water', 'veggie tray', 'supplies')`. Do remove `GROUP BY m.member_id`, `ORDER BY total_cost DESC`, and `LIMIT 1` instead of keeping aggregation and ranking operations. The amended query now correctly retrieves individual expense records with direct member linking instead of aggregating purchase costs through multiple joins."
        ],
        "rules": [
            "1) When the question asks for spending on specific items: use exact literal 'Water, Veggie tray, supplies' for expense_description filtering instead of separate item names. 2) When selecting member information and cost: use T2.first_name, T2.last_name, and T1.cost directly without aggregation. 3) When joining member and expense tables: link using T1.link_to_member = T2.member_id for direct member association. 4) When the source data structure changes: use FROM expense AS T1 as the primary table instead of members table. 5) When the question requires individual expense records: remove GROUP BY, ORDER BY, and LIMIT operations that aggregate and rank results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.first_name, m.last_name, SUM(i.cost) AS total_cost\nFROM members m\nJOIN purchases p ON m.member_id = p.member_id\nJOIN items i ON p.item_id = i.item_id\nWHERE i.item_name IN ('water', 'veggie tray', 'supplies')\nGROUP BY m.member_id\nORDER BY total_cost DESC\nLIMIT 1;",
            "SELECT T2.first_name, T2.last_name, T1.cost\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nWHERE T1.expense_description = 'Water, Veggie tray, supplies'"
        ],
        "rule_sql": [
            "SELECT T2.first_name, T2.last_name, T1.cost \nFROM expense AS T1 \nJOIN member AS T2 ON T1.link_to_member = T2.member_id \nWHERE T1.expense_description = 'Water, Veggie tray, supplies'"
        ],
        "amend_res": 1
    },
    "817": {
        "db_id": "superhero",
        "question": "Give the race of the blue-haired male superhero.",
        "ground_truth": "SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T2.colour = 'Blue' AND T4.gender = 'Male'",
        "amends": [
            "Do join multiple tables instead of querying a single table, specifically adding `INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id`, `INNER JOIN race AS T3 ON T1.race_id = T3.id`, and `INNER JOIN gender AS T4 ON T1.gender_id = T4.id` instead of omitting these necessary joins. Do reference `T3.race` instead of just `race` to specify the table source. Do filter on `T2.colour = 'Blue'` instead of `hair_color = 'blue'` to use the joined colour table's value. Do filter on `T4.gender = 'Male'` instead of `gender = 'male'` to use the joined gender table's value with proper case matching. The amended query now correctly joins the necessary lookup tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about race of a superhero: join the race table (T3) using the superheroes table's race_id column to access the race value. 2) When filtering by hair color: join the colour table (T2) using the superheroes table's hair_colour_id column and filter on T2.colour = 'Blue' (exact case). 3) When filtering by gender: join the gender table (T4) using the superheroes table's gender_id column and filter on T4.gender = 'Male' (exact case). 4) When selecting race information: reference T3.race instead of just race to specify the table source."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race FROM superheroes WHERE hair_color = 'blue' AND gender = 'male';",
            "SELECT T3.race\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id\nINNER JOIN race AS T3 ON T1.race_id = T3.id\nINNER JOIN gender AS T4 ON T1.gender_id = T4.id\nWHERE T2.colour = 'Blue' AND T4.gender = 'Male'"
        ],
        "rule_sql": [
            "SELECT T3.race\nFROM superhero\nJOIN colour T2 ON superhero.hair_colour_id = T2.id\nJOIN gender T4 ON superhero.gender_id = T4.id\nJOIN race T3 ON superhero.race_id = T3.id\nWHERE T2.colour = 'Blue' AND T4.gender = 'Male'"
        ],
        "amend_res": 1
    },
    "1035": {
        "db_id": "european_football_2",
        "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
        "ground_truth": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60"
        ],
        "rule_sql": [
            "SELECT team_fifa_api_id \nFROM Team_Attributes \nWHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60 \nGROUP BY team_fifa_api_id;"
        ],
        "amend_res": 1
    },
    "845": {
        "db_id": "superhero",
        "question": "List the power of superheroes with height greater than 80% of the average height of all superheroes.",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.height_cm * 100 > ( SELECT AVG(height_cm) FROM superhero ) * 80",
        "amends": [
            "Do select `T3.power_name` instead of `power`. Do use `superhero AS T1` joined with `hero_power AS T2` on `T1.id = T2.hero_id` and `superpower AS T3` on `T2.power_id = T3.id` instead of querying only `superheroes`. Do filter with `T1.height_cm * 100 >` instead of `height >`. Do use `(SELECT AVG(height_cm) FROM superhero) * 80` instead of `(SELECT AVG(height) * 0.8 FROM superheroes)`. The amended query now correctly joins multiple tables to retrieve power names and fixes the height comparison logic to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"power of superheroes\": make sure the output order: T3.power_name\n2) When the question mentions \"power\": \"power\" actually means \"T3.power_name\" in schema\n3) When combining tables for superhero powers: link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match)\n4) When filtering by height greater than 80% of average: use T1.height_cm * 100 > (SELECT AVG(height_cm) FROM superhero) * 80\n5) When computing average height: use AVG(height_cm) from the superhero table\n6) When handling height comparison: multiply T1.height_cm by 100 and compare to average multiplied by 80 to achieve the 80% threshold"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT power FROM superheroes WHERE height > (SELECT AVG(height) * 0.8 FROM superheroes);",
            "SELECT T3.power_name\nFROM superhero AS T1\nJOIN hero_power AS T2 ON T1.id = T2.hero_id\nJOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.height_cm * 100 > (SELECT AVG(height_cm) FROM superhero) * 80"
        ],
        "rule_sql": [
            "SELECT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T1.height_cm * 100 > (SELECT AVG(height_cm) FROM superhero) * 80\nORDER BY T3.power_name"
        ],
        "amend_res": 1
    },
    "1389": {
        "db_id": "student_club",
        "question": "Which event has the lowest cost?",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
        "amends": [
            "Do select `T1.event_name` instead of `event_name` to explicitly specify the table source. Do add `FROM event AS T1` instead of `FROM events` to use the correct table name and alias. Do add `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` instead of omitting the budget table join to properly relate events to budgets. Do add `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of omitting the expense table join to access cost data. Do order by `T3.cost` instead of `cost` to reference the correct table column. Do remove `DESC` from the ordering instead of keeping it to sort in ascending order. The amended query now correctly joins the necessary tables to access cost information and returns the appropriate result matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which event has the lowest cost\": make sure the output order: T1.event_name. 2) When the question mentions \"event\": use table \"event AS T1\" with column \"T1.event_name\". 3) When the question mentions \"cost\": use table \"expense AS T3\" with column \"T3.cost\". 4) When combining T1 and T2 for shared entities: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match). 5) When combining T2 and T3 for shared entities: link rows where T2.budget_id = T3.link_to_budget and keep only matching pairs (inner match). 6) When the question asks for \"lowest cost\": order by T3.cost in ascending order and keep the first row. 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM events ORDER BY cost DESC LIMIT 1;",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nORDER BY T3.cost ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nORDER BY T3.cost ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "364": {
        "db_id": "card_games",
        "question": "What is the status of card \"Cloudchaser Eagle\"?",
        "ground_truth": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it. Do change the SELECT list from `status` to `T2.status` instead of the unqualified column. Do add `INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid` instead of querying only the `cards` table. Do add table alias `T1` to the `cards` table instead of using it unaliased. Do move the filter condition to reference `T1.name` instead of just `name`. The amended query now correctly joins the cards and legalities tables to retrieve the appropriate status values while eliminating duplicates."
        ],
        "rules": [
            "1) When answering about card status: make sure the output order: T2.status 2) When the question mentions \"card\": \"card\" actually means \"T1.name in schema\" 3) When combining T1 (cards) and T2 (legalities) for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match) 4) When filtering for a specific card name: use the exact literal 'Cloudchaser Eagle' with case and spacing preserved 5) When selecting status values: use T2.status instead of unqualified status to specify the correct table source 6) When retrieving status information: add DISTINCT modifier to eliminate duplicate values"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT status FROM cards WHERE name = 'Cloudchaser Eagle';",
            "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.status FROM cards T1 INNER JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'"
        ],
        "amend_res": 1
    },
    "787": {
        "db_id": "superhero",
        "question": "What are the race and alignment of Cameron Hicks?",
        "ground_truth": "SELECT T2.race, T3.alignment FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T1.superhero_name = 'Cameron Hicks'",
        "amends": [
            "Do join `superhero AS T1` with `race AS T2` on `T1.race_id = T2.id` and `alignment AS T3` on `T1.alignment_id = T3.id` instead of querying `characters` directly. Do select `T2.race` and `T3.alignment` instead of `race` and `alignment` from a single table. Do filter on `T1.superhero_name = 'Cameron Hicks'` instead of `name = 'Cameron Hicks'` to use the correct column name. The amended query now properly joins related tables to retrieve race and alignment information through foreign key relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about a character's race and alignment: join table \"superhero\" as T1 with table \"race\" as T2 on T1.race_id = T2.id and with table \"alignment\" as T3 on T1.alignment_id = T3.id. 2) When the question mentions \"race\": select T2.race instead of a direct column from the main table. 3) When the question mentions \"alignment\": select T3.alignment instead of a direct column from the main table. 4) When filtering for a specific character name: use T1.superhero_name = 'Cameron Hicks' instead of name = 'Cameron Hicks' to match the correct column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race, alignment FROM characters WHERE name = 'Cameron Hicks';",
            "SELECT T2.race, T3.alignment\nFROM superhero AS T1\nJOIN race AS T2 ON T1.race_id = T2.id\nJOIN alignment AS T3 ON T1.alignment_id = T3.id\nWHERE T1.superhero_name = 'Cameron Hicks'"
        ],
        "rule_sql": [
            "SELECT T2.race, T3.alignment\nFROM superhero AS T1\nJOIN race AS T2 ON T1.race_id = T2.id\nJOIN alignment AS T3 ON T1.alignment_id = T3.id\nWHERE T1.superhero_name = 'Cameron Hicks'"
        ],
        "amend_res": 1
    },
    "714": {
        "db_id": "codebase_community",
        "question": "List the comments commented by the user with a username of Harvey Motulsky.",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'",
        "amends": [
            "Do select `T1.Text` instead of `*` to return only the comment text instead of all columns. Do use `INNER JOIN` on `T1.UserId = T2.Id` instead of a subquery with `user_id = (SELECT id FROM users WHERE username = 'Harvey Motulsky')` to properly join the tables. Do filter on `T2.DisplayName = 'Harvey Motulsky'` instead of `username = 'Harvey Motulsky'` to use the correct column name for the display name. Do add table aliases `T1` for comments and `T2` for users instead of omitting them for better readability. The amended query now correctly joins the tables and filters by display name to match the intended behavior."
        ],
        "rules": [
            "1) When selecting comments for a specific user: return only the \"Text\" column from the comments table instead of all columns. 2) When joining comments and users tables: use an inner join where T1.UserId equals T2.Id to properly link the tables. 3) When filtering by username: use T2.DisplayName = 'Harvey Motulsky' instead of username to match the correct column name. 4) When referring to tables: use T1 as the alias for comments table and T2 as the alias for users table for consistency."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM comments WHERE user_id = (SELECT id FROM users WHERE username = 'Harvey Motulsky');",
            "SELECT T1.Text \nFROM comments T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T2.DisplayName = 'Harvey Motulsky'"
        ],
        "rule_sql": [
            "SELECT T1.Text FROM comments T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'"
        ],
        "amend_res": 1
    },
    "1350": {
        "db_id": "student_club",
        "question": "What is the status of the event which bought \"Post Cards, Posters\" on 2019/8/20?",
        "ground_truth": "SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'",
        "amends": [
            "Do select `T1.event_status` instead of `status` from the `budget AS T1` table instead of `events`. Do use `INNER JOIN expense AS T2` instead of querying only one table. Do join on `T1.budget_id = T2.link_to_budget` instead of no join condition. Do filter on `T2.expense_description = 'Post Cards, Posters'` instead of `item = 'Post Cards, Posters'`. Do use date format `'2019-08-20'` with hyphens instead of `'2019/8/20'` with slashes and filter on `T2.expense_date` instead of `date`. The amended query now correctly joins budget and expense tables to retrieve event status based on expense criteria."
        ],
        "rules": [
            "1) When answering about event status for purchases: select \"T1\".\"event_status\" from the \"budget\" table as \"T1\" instead of \"status\" from \"events\". 2) When the question mentions \"Post Cards, Posters\": this refers to \"T2\".\"expense_description\" = 'Post Cards, Posters' exactly as written. 3) When the question mentions date \"2019/8/20\": convert to date format '2019-08-20' with hyphens and use \"T2\".\"expense_date\" instead of \"date\". 4) When combining budget and expense information: use INNER JOIN between \"budget\" as \"T1\" and \"expense\" as \"T2\" on \"T1\".\"budget_id\" = \"T2\".\"link_to_budget\" to link related records. 5) When filtering by expense criteria: apply filters on the \"expense\" table (\"T2\") for both description and date conditions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT status FROM events WHERE item = 'Post Cards, Posters' AND date = '2019/8/20';",
            "SELECT T1.event_status \nFROM budget AS T1 \nINNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget \nWHERE T2.expense_description = 'Post Cards, Posters' \nAND T2.expense_date = '2019-08-20'"
        ],
        "rule_sql": [
            "SELECT T1.event_status \nFROM budget AS T1 \nINNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget \nWHERE T2.expense_description = 'Post Cards, Posters' \nAND T2.expense_date = '2019-08-20'"
        ],
        "amend_res": 1
    },
    "1406": {
        "db_id": "student_club",
        "question": "Among the budgets for Food, which one has the highest budgeted amount?",
        "ground_truth": "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = ( SELECT MAX(amount) FROM budget )",
        "amends": [
            "Do select only `budget_id` instead of all columns with `*`. Do reference table `budget` instead of `budgets`. Do add a subquery to find the maximum amount with `SELECT MAX(amount) FROM budget` instead of ordering and limiting. Do change the filter to `amount = (subquery)` instead of ordering by `budgeted_amount ASC` with `LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly identifies the budget with the maximum amount in the Food category rather than the smallest budgeted amount."
        ],
        "rules": [
            "1) When answering about \"highest budgeted amount\": find the maximum value of the \"amount\" column instead of ordering and limiting. 2) When the question mentions \"Food\": \"Food\" actually means category = 'Food' in the budget table. 3) When selecting columns: select only \"budget_id\" instead of all columns with *. 4) When referring to the table: use table name \"budget\" instead of \"budgets\". 5) When finding the maximum amount: use a subquery with SELECT MAX(amount) FROM budget to get the maximum value. 6) When filtering for the maximum amount: use amount = (subquery) instead of ordering by budgeted_amount ASC with LIMIT 1."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM budgets WHERE category = 'Food' ORDER BY budgeted_amount ASC LIMIT 1;",
            "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food');"
        ],
        "rule_sql": [
            "SELECT budget_id FROM budget WHERE category = 'Food' AND amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food')"
        ],
        "amend_res": 1
    },
    "721": {
        "db_id": "superhero",
        "question": "How many superheroes have blue eyes?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'",
        "amends": [
            "Do reference the `superhero` table as `T1` instead of `superheroes`. Do join with `colour` table as `T2` on `T1.eye_colour_id = T2.id` instead of directly filtering on `eye_color`. Do count `T1.id` instead of using `COUNT(*)`. Do filter on `T2.colour = 'Blue'` instead of `eye_color = 'brown'`. The amended query now correctly counts superheroes with blue eyes by joining through the color reference table instead of relying on a direct color value column."
        ],
        "rules": [
            "1) When answering about \"how many superheroes have blue eyes\": make sure the output order: count of superheroes with blue eyes. 2) When the question mentions \"superheroes\": \"superheroes\" actually means \"T1.id in schema\" for counting purposes. 3) When the question mentions \"blue eyes\": \"blue eyes\" actually means \"T2.colour = 'Blue'\" in schema after joining through the colour table. 4) When combining T1 and T2 for shared entities: link rows where T1.eye_colour_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 5) When counting superheroes: compute the number of rows using the canonical key token T1.id instead of counting all columns. 6) When handling text literals: do not change case, spacing, or punctuation - use exactly 'Blue' not 'blue' or 'BLUE'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE eye_color = 'brown';",
            "SELECT COUNT(T1.id) \nFROM superhero T1\nJOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'"
        ],
        "amend_res": 1
    },
    "769": {
        "db_id": "superhero",
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do add joins to `hero_attribute`, `attribute`, and `publisher` tables instead of querying only the `superheroes` table. Do join `superhero` to `hero_attribute` on `T1.id = T2.hero_id` instead of missing this relationship entirely. Do join `hero_attribute` to `attribute` on `T3.id = T2.attribute_id` instead of omitting the attribute metadata. Do join `superhero` to `publisher` on `T4.id = T1.publisher_id` instead of directly filtering by publisher name. Do filter on `T4.publisher_name = 'Dark Horse Comics'` instead of the incorrect `publisher` column. Do add filter `T3.attribute_name = 'Durability'` instead of assuming durability is a direct column. Do order by `T2.attribute_value DESC` instead of the non-existent `durability` column. The amended query now correctly joins multiple tables to find durability attribute values for Dark Horse Comics superheroes and returns the highest value, matching the intended behavior.",
            "Do use table aliases `T1`, `T2`, `T3`, and `T4` instead of `s`, `ha`, `a`, and `p` for consistency. Do remove the column `attribute_value` from the SELECT list instead of including it, as only `superhero_name` is needed. Do specify `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do change the join condition from `s.id = ha.hero_id` to `T1.id = T2.hero_id` with proper aliasing. Do change the attribute join from `ha.attribute_id = a.id` to `T3.id = T2.attribute_id` with correct table references. Do change the publisher join from `s.publisher_id = p.id` to `T4.id = T1.publisher_id` with proper aliasing. Do maintain the same WHERE filters for `publisher_name` and `attribute_name` but with updated table aliases. Do keep the same ORDER BY on `attribute_value` with the correct alias `T2` instead of `ha`. Do preserve the LIMIT 1 clause unchanged. The amended query now correctly returns only superhero names from Dark Horse Comics with maximum durability attributes."
        ],
        "rules": [
            "1) When answering about superhero durability published by Dark Horse Comics: make sure the output order: superhero_name. 2) When the question mentions \"durability\": \"durability\" actually means \"T3.attribute_name = 'Durability'\" in schema. 3) When the question mentions \"Dark Horse Comics\": \"Dark Horse Comics\" actually means \"T4.publisher_name = 'Dark Horse Comics'\" in schema. 4) When combining T1 (superhero) and T2 (hero_attribute) for shared entities: link rows where T1.id = T2.hero_id and keep only matching pairs (inner match). 5) When combining T2 (hero_attribute) and T3 (attribute) for shared entities: link rows where T3.id = T2.attribute_id and keep only matching pairs (inner match). 6) When combining T1 (superhero) and T4 (publisher) for shared entities: link rows where T4.id = T1.publisher_id and keep only matching pairs (inner match). 7) When the question asks for \"most durability\": rank rows by T2.attribute_value in descending direction and keep the first 1 row. 8) When filtering for durability attribute: use exact literal 'Durability' for T3.attribute_name. 9) When filtering for publisher: use exact literal 'Dark Horse Comics' for T4.publisher_name.",
            "1) When answering about \"superhero with the most durability published by Dark Horse Comics\": make sure the output order: T1.superhero_name only\n2) When the question mentions \"Dark Horse Comics\": \"Dark Horse Comics\" actually means T4.publisher_name = 'Dark Horse Comics' in schema\n3) When the question mentions \"durability\": \"durability\" actually means T3.attribute_name = 'Durability' in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id; keep only matching pairs (inner match)\n5) When combining T2 and T3 for shared attributes: link rows where T3.id = T2.attribute_id; keep only matching pairs (inner match)\n6) When combining T1 and T4 for shared publishers: link rows where T4.id = T1.publisher_id; keep only matching pairs (inner match)\n7) When the question asks for \"most durability\": rank rows by T2.attribute_value in descending order and keep the first 1 row\n8) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n9) When handling text literals: do not change case, spacing, or punctuation of 'Dark Horse Comics' or 'Durability'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superhero_name FROM superheroes WHERE publisher = 'Dark Horse Comics' ORDER BY durability DESC LIMIT 1;",
            "SELECT s.superhero_name, ha.attribute_value\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name = 'Dark Horse Comics'\nAND a.attribute_name = 'Durability'\nORDER BY ha.attribute_value DESC\nLIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T3.id = T2.attribute_id\nINNER JOIN publisher T4 ON T4.id = T1.publisher_id\nWHERE T4.publisher_name = 'Dark Horse Comics'\nAND T3.attribute_name = 'Durability'\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT s.superhero_name\nFROM superhero s\nINNER JOIN hero_attribute ha ON s.id = ha.hero_id\nINNER JOIN attribute a ON a.id = ha.attribute_id\nINNER JOIN publisher p ON p.id = s.publisher_id\nWHERE a.attribute_name = 'Durability'\nAND p.publisher_name = 'Dark Horse Comics'\nORDER BY ha.attribute_value DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "343": {
        "db_id": "card_games",
        "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
        "ground_truth": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
        "amends": [
            "Do select `id` instead of `card_name` in the SELECT list. Do use column `edhrecRank` instead of `edhrec_rank` with the comparison operator `< 100` instead of `> 100`. Do use column `frameVersion` instead of `frame_style` with the numeric value `2015` instead of the string literal `'2015'`. The amended query now correctly filters for cards with edhrecRank less than 100 and frameVersion equal to 2015, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"cards with 2015 frame style ranking below 100 on EDHRec\": make sure the output order: id\n2) When the question mentions \"frame style\": \"frame style\" actually means \"frameVersion in schema\"\n3) When the question mentions \"ranking below 100 on EDHRec\": \"ranking below 100\" actually means \"edhrecRank < 100\"\n4) When filtering for frame style: use numeric value 2015 instead of string literal '2015' for frameVersion\n5) When selecting card identifiers: use column id instead of card_name"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_name FROM cards WHERE frame_style = '2015' AND edhrec_rank > 100;",
            "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015;"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE frameVersion = 2015 AND edhrecRank < 100 ORDER BY id;"
        ],
        "amend_res": 1
    },
    "417": {
        "db_id": "card_games",
        "question": "What percentage of Japanese translated sets are expansion sets?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN s.type = 'expansion' THEN 1 END)` for the numerator calculation. Do add `INNER JOIN set_translations AS T2 ON T1.code = T2.setCode` instead of omitting the join to the translations table. Do move the language filter to the `CASE` expression instead of keeping it in the `WHERE` clause. Do change the filter to `T1.type = 'expansion'` instead of `s.type = 'expansion'` and remove the `translation = 1` condition. Do use `CAST(... AS REAL)` for proper division instead of implicit casting with `100.0`. Do reference `T1.id` for the denominator count instead of `COUNT(*)`. The amended query now correctly calculates the percentage of Japanese translations for expansion sets by joining to the translations table and properly handling the division with explicit casting."
        ],
        "rules": [
            "1) When combining sets and set_translations tables: link rows where T1.code = T2.setCode and keep only matching pairs (inner match). 2) When calculating percentage of Japanese translated expansion sets: compute (number of Japanese translations for expansion sets) divided by (total number of expansion sets), guarding division by zero. 3) When counting Japanese translations for expansion sets: use SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) where T1.type = 'expansion'. 4) When counting total expansion sets: use COUNT(T1.id) where T1.type = 'expansion'. 5) When handling division for percentages: use explicit casting to REAL instead of implicit casting with 100.0. 6) When filtering for Japanese language: move the language filter to the CASE expression instead of the WHERE clause. 7) When referring to expansion sets: use T1.type = 'expansion' exactly as specified. 8) When referring to Japanese language: use T2.language = 'Japanese' exactly as specified with the exact case and quotes."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN s.type = 'expansion' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM sets s\nWHERE s.language = 'Japanese' AND s.translation = 1;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.id) * 100.0 AS percentage\nFROM \n    sets AS T1\nINNER JOIN \n    set_translations AS T2 ON T1.code = T2.setCode\nWHERE \n    T1.type = 'expansion'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    sets T1\nINNER JOIN \n    set_translations T2 ON T1.code = T2.setCode\nWHERE \n    T1.type = 'expansion';"
        ],
        "amend_res": 1
    },
    "127": {
        "db_id": "financial",
        "question": "List the account IDs with monthly issuance of statements.",
        "ground_truth": "SELECT account_id FROM account WHERE Frequency = 'POPLATEK MESICNE'",
        "amends": [
            "Do select from `account` table instead of `statements` table. Do filter on `Frequency = 'POPLATEK MESICNE'` instead of using `issuance_date LIKE '%-%-%'` pattern matching. The amended query now correctly retrieves account IDs from the appropriate table with the proper filter condition, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"account IDs with monthly issuance of statements\": select from the \"account\" table instead of the \"statements\" table. 2) When filtering for monthly issuance: use the exact literal value 'POPLATEK MESICNE' for the Frequency condition instead of pattern matching on dates. 3) When retrieving account IDs: use the exact column token \"account\" from the \"account\" table as the output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id FROM statements WHERE issuance_date LIKE '%-%-%'",
            "SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';"
        ],
        "rule_sql": [
            "SELECT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';"
        ],
        "amend_res": 1
    },
    "449": {
        "db_id": "card_games",
        "question": "What is the language of the card that has azorius watermark? List out the type of this card.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.language, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'azorius'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do add `T1.type` to the SELECT list instead of only selecting `language`. Do change the FROM source to `cards AS T1 INNER JOIN foreign_data AS T2` instead of just `cards`. Do add the join condition `ON T2.uuid = T1.uuid` instead of having no join. Do qualify the language column as `T2.language` instead of unqualified `language`. Do qualify the watermark filter as `T1.watermark` instead of unqualified `watermark`. The amended query now correctly joins the tables and returns distinct language-type pairs from the Azorius watermark cards."
        ],
        "rules": [
            "1) When the question asks for \"language of the card\" and \"type of this card\": select both T2.language and T1.type as output columns. 2) When the question mentions \"azorius watermark\": filter for rows where T1.watermark equals exactly 'azorius'. 3) When combining cards and foreign_data tables: link rows where T2.uuid equals T1.uuid and keep only matching pairs (inner match). 4) When selecting from multiple tables: qualify columns with their table aliases (T1 for cards, T2 for foreign_data). 5) When the question asks for distinct language-type pairs: return only unique combinations of T2.language and T1.type values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM cards WHERE watermark = 'azorius';",
            "SELECT DISTINCT T2.language, T1.type\nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.watermark = 'azorius';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.language, T1.type\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.watermark = 'azorius';"
        ],
        "amend_res": 1
    },
    "85": {
        "db_id": "california_schools",
        "question": "What is the Percent (%) Eligible Free (K-12) in the school administered by an administrator whose first name is Alusine. List the district code of the school.",
        "ground_truth": "SELECT T1.`Free Meal Count (K-12)` * 100 / T1.`Enrollment (K-12)`, T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
        "amends": [
            "Do select the calculated expression `Free Meal Count (K-12) * 100 / Enrollment (K-12)` and `District Code` instead of `district_code` and `percent_eligible_free_k12`. Do use `frpm AS T1` as the main table instead of only `schools`. Do add `INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode` instead of querying only the schools table. Do filter on `T2.AdmFName1 = 'Alusine'` instead of `administrator_first_name = 'Alusine'`. The amended query now correctly joins the frpm and schools tables to calculate the percentage and matches the RIGHT_SQL's behavior.",
            "Do move `T1.\"District Code\"` to the SELECT list instead of placing it first, and do calculate `T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\"` as an expression without an alias instead of aliasing it as \"Percent (%) Eligible Free (K-12)\". The amended query now matches RIGHT_SQL's behavior by returning the calculated percentage and district code without the alias."
        ],
        "rules": [
            "1) When calculating Percent (%) Eligible Free (K-12): compute the expression Free Meal Count (K-12) * 100 / Enrollment (K-12) instead of using the pre-calculated column. 2) When selecting the district code: use the exact column name \"District Code\" instead of \"district_code\". 3) When querying about schools: use table \"frpm\" as T1 as the main table instead of only querying the schools table. 4) When combining frpm and schools data: perform an inner join where T1.CDSCode = T2.CDSCode to match records between tables. 5) When filtering by administrator first name: use T2.AdmFName1 = 'Alusine' with exact case and spelling instead of administrator_first_name.",
            "1) When the question asks for \"Percent (%) Eligible Free (K-12)\": use the expression T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\" without an alias instead of the existing column Percent (%) Eligible Free (K-12). 2) When the question asks for district code: include T1.\"District Code\" in the output. 3) When combining frpm (T1) and schools (T2) tables: link rows where T1.CDSCode = T2.CDSCode using an inner match. 4) When filtering for administrator first name: use T2.AdmFName1 = 'Alusine' exactly as specified."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT district_code, percent_eligible_free_k12 \nFROM schools \nWHERE administrator_first_name = 'Alusine';",
            "SELECT T1.\"District Code\", (T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\") AS \"Percent (%) Eligible Free (K-12)\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'",
            "SELECT T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\", T1.\"District Code\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.AdmFName1 = 'Alusine'"
        ],
        "rule_sql": [
            "SELECT T1.\"District Code\", T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\" \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.AdmFName1 = 'Alusine'"
        ],
        "amend_res": 1
    },
    "469": {
        "db_id": "card_games",
        "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
        "ground_truth": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
        "amends": [
            "Do select `IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO')` instead of `*` to return a specific conditional value rather than all columns. Do join `sets AS T2` with `INNER JOIN` on `T2.code = T1.setCode` instead of querying only the `cards` table to incorporate set information. Do reference `T1.name` in the WHERE clause instead of just `name` to properly qualify the column with its table alias. Do use the conditional logic `IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO')` instead of the direct column value `online_availability = 'Yes'` to dynamically determine availability based on the presence of mtgoCode. The amended query now correctly determines online availability by checking for mtgoCode in the joined sets table rather than relying on a potentially incorrect static value."
        ],
        "rules": [
            "1) When answering about whether cards with a specific name appeared online: use IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') to return availability status instead of selecting all columns. 2) When the question mentions \"Angel of Mercy\": use T1.name = 'Angel of Mercy' with exact case and spacing in the WHERE clause. 3) When combining cards and sets tables: link rows using T2.code = T1.setCode with an inner join to only keep matching pairs. 4) When determining online availability: check for the presence of T2.mtgoCode instead of using a static value like 'Yes'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE name = 'Angel of Mercy' AND online_availability = 'Yes';",
            "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') \nFROM cards AS T1 \nINNER JOIN sets AS T2 ON T2.code = T1.setCode \nWHERE T1.name = 'Angel of Mercy'"
        ],
        "rule_sql": [
            "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') AS online_availability\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Angel of Mercy';"
        ],
        "amend_res": 1
    },
    "1173": {
        "db_id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "ground_truth": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "amends": [
            "Do select `T2.Diagnosis` instead of `illness` and do count `T2.Diagnosis` instead of `COUNT(*)`. Do use `Examination AS T1 INNER JOIN Patient AS T2` instead of `FROM patients` and do join on `T1.ID = T2.ID` instead of no join condition. Do filter on `T1.Examination Date` instead of `lab_date` while keeping the same date range. Do group by `T2.Diagnosis` instead of `illness`. Do order by `COUNT(T2.Diagnosis)` instead of `count` while maintaining descending order and limit 1. The amended query now correctly joins examination and patient tables to count diagnoses from examinations within the specified date range, matching the RIGHT_SQL's behavior.",
            "Do remove `COUNT(T2.Diagnosis) AS count_diagnosis` from the SELECT list instead of including it, as the RIGHT_SQL only returns the diagnosis column without the count aggregation. The query structure remains identical otherwise, maintaining the same FROM clause with `INNER JOIN` on `T1.ID = T2.ID`, the same WHERE filter on `T1.Examination Date` between the specified date range, the same GROUP BY on `T2.Diagnosis`, the same ORDER BY on `COUNT(T2.Diagnosis) DESC`, and the same LIMIT 1. The amended query now matches RIGHT_SQL's behavior by returning only the diagnosis value rather than both diagnosis and count."
        ],
        "rules": [
            "1) When the question asks about \"illness\" among patients: \"illness\" actually means \"T2.Diagnosis\" in the schema. 2) When the question mentions \"lab work was done between 1/1/1985, and 12/31/1995\": filter on \"T1.Examination Date\" between '1985-01-01' AND '1995-12-31' instead of lab_date. 3) When combining examination and patient data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When counting the most common illness: count using T2.Diagnosis instead of counting all rows. 5) When the question asks for \"most common illness\": rank rows by count of T2.Diagnosis in descending order and keep only the first 1 row.",
            "1) When the question asks for the most common illness: rank diagnoses by count in descending order and keep only the top 1 result. 2) When counting occurrences of diagnoses: count using the exact token T2.Diagnosis as the counting key. 3) When filtering by date range for lab work: use T1.\"Examination Date\" between '1985-01-01' and '1995-12-31' inclusive. 4) When combining Examination (T1) and Patient (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 5) When the output should show only the diagnosis value: return only T2.Diagnosis column without the count aggregation in the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT illness, COUNT(*) as count \nFROM patients \nWHERE lab_date BETWEEN '1985-01-01' AND '1995-12-31' \nGROUP BY illness \nORDER BY count DESC \nLIMIT 1;",
            "SELECT T2.Diagnosis, COUNT(T2.Diagnosis) AS count_diagnosis\nFROM Examination AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nWHERE T1.\"Examination Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1;",
            "SELECT T2.Diagnosis\nFROM Examination AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nWHERE T1.\"Examination Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.Diagnosis\nFROM Examination T1\nINNER JOIN Patient T2 ON T1.ID = T2.ID\nWHERE T1.\"Examination Date\" BETWEEN '1985-01-01' AND '1995-12-31'\nGROUP BY T2.Diagnosis\nORDER BY COUNT(T2.Diagnosis) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "185": {
        "db_id": "financial",
        "question": "What proportion of customers who have accounts at the Prague branch are female?",
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id) * 100 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'Prague'",
        "amends": [
            "Do use `SUM(T2.gender = 'F')` with explicit `CAST` to `REAL` instead of `COUNT(*)` with a subquery for female proportion calculation. Do join `district AS T1` and `client AS T2` on `T1.district_id = T2.district_id` instead of querying only the `customers` table. Do filter on `T1.A3 = 'Prague'` instead of `branch = 'Prague'` to use the correct table and column reference. Do calculate percentage with `* 100` instead of simple proportion without scaling. Do remove the redundant subquery and gender filter in the main WHERE clause instead of keeping them. The amended query now correctly calculates the percentage of female clients in Prague districts using proper table relationships and casting."
        ],
        "rules": [
            "1) When answering about proportion of customers at Prague branch who are female: join district as T1 and client as T2 on T1.district_id = T2.district_id using inner match. 2) When filtering for Prague branch: use T1.A3 = 'Prague' instead of branch = 'Prague'. 3) When calculating female proportion: use SUM(T2.gender = 'F') with explicit CAST to REAL instead of COUNT(*) with subquery. 4) When computing percentage: multiply the proportion by 100 to get percentage instead of simple proportion. 5) When handling gender values: use exact literal 'F' for female instead of 'Female'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) / (SELECT COUNT(*) FROM customers WHERE branch = 'Prague') AS proportion\nFROM customers\nWHERE branch = 'Prague' AND gender = 'Female';",
            "SELECT \n    CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) / COUNT(*) * 100 AS female_percentage\nFROM \n    district AS T1\nJOIN \n    client AS T2 ON T1.district_id = T2.district_id\nWHERE \n    T1.A3 = 'Prague';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN T2.gender = 'F' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100 AS female_percentage\nFROM \n    district AS T1\nINNER JOIN \n    client AS T2 ON T1.district_id = T2.district_id\nWHERE \n    T1.A3 = 'Prague';"
        ],
        "amend_res": 1
    },
    "1378": {
        "db_id": "student_club",
        "question": "What is the highest amount of budget spend for an event?",
        "ground_truth": "SELECT MAX(spent) FROM budget",
        "amends": [
            "Do select `MAX(spent)` instead of `MIN(budget)` to retrieve the maximum spent amount rather than the minimum budget value. Do query from `budget` table instead of `events` table to access the correct data source containing spending information. The amended query now correctly returns the highest expenditure value from the budget table instead of the smallest budget figure from events."
        ],
        "rules": [
            "1) When the question asks for the \"highest amount of budget spend\": use MAX(\"spent\") instead of MIN(\"budget\") to find the maximum expenditure value. 2) When querying for budget spending information: use the \"budget\" table instead of the \"events\" table to access the correct data source containing spending records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(budget) FROM events;",
            "SELECT MAX(spent) FROM budget;"
        ],
        "rule_sql": [
            "SELECT MAX(spent) AS highest_budget_spend FROM budget;"
        ],
        "amend_res": 1
    },
    "1204": {
        "db_id": "thrombosis_prediction",
        "question": "How long did it take after patient number 821298 arrived at the hospital for the first time before her evaluation began?",
        "ground_truth": "SELECT STRFTIME('%d', T3.`Examination Date`) - STRFTIME('%d', T1.`First Date`) FROM Patient AS T1 INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.ID = 821298",
        "amends": [
            "Do use `STRFTIME('%d', T3.\\`Examination Date\\`) - STRFTIME('%d', T1.\\`First Date\\`)` as the calculation instead of `MIN(evaluation_time) - MIN(arrival_time)` to compute day differences between specific date columns. Do join `Patient AS T1` and `Examination AS T3` with `INNER JOIN` on `T1.ID = T3.ID` instead of querying only from `patient_visits` table. Do filter on `T1.ID = 821298` instead of `patient_id = 821298 AND visit_number = 1` to target the correct patient identifier. Do remove the aggregation functions and time difference alias since the calculation now operates on individual date values rather than aggregated minimums. The amended query now correctly calculates the day difference between examination and first visit dates for the specified patient, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating time differences between dates: use STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\") to compute day differences between specific date columns. 2) When combining Patient and Examination tables: link rows where T1.ID = T3.ID using an inner join to match patient records. 3) When filtering for a specific patient: use T1.ID = 821298 to target the correct patient identifier. 4) When calculating individual date differences: do not use aggregation functions since the calculation operates on individual date values rather than aggregated minimums."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(evaluation_time) - MIN(arrival_time) AS time_difference\nFROM patient_visits\nWHERE patient_id = 821298\nAND visit_number = 1;",
            "SELECT STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\") \nFROM Patient AS T1\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T1.ID = 821298"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\") AS days_difference\nFROM Patient T1\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T1.ID = 821298"
        ],
        "amend_res": 1
    },
    "954": {
        "db_id": "formula_1",
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T3.nationality = 'Japanese' AND T2.year BETWEEN 2007 AND 2009",
        "amends": [
            "Do use `SUM(IIF(T1.time IS NOT NULL, 1, 0))` instead of `COUNT(DISTINCT r.raceId)` to count completed races based on time presence rather than position. Do calculate percentage directly with `* 100 / COUNT(T1.raceId)` instead of using a subquery for total races. Do reference `T1.time IS NOT NULL` instead of `r.position IS NOT NULL` to determine race completion. Do use table aliases `T1`, `T2`, and `T3` consistently instead of mixed aliases. Do remove the unnecessary `DISTINCT` and subquery structure instead of keeping the complex percentage calculation. The amended query now correctly calculates the percentage of races completed by Japanese drivers between 2007-2009 based on time data rather than position, matching the RIGHT_SQL's behavior.",
            "Do remove `T2.year` from the SELECT list and GROUP BY clause instead of including it, as the query now returns a single aggregate value. Do add `CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL)` instead of using the integer SUM directly, to ensure proper decimal division. Do remove the ORDER BY clause instead of keeping it, since the result is now a single scalar value. Do use explicit `INNER JOIN` syntax instead of just `JOIN` for clarity. The amended query now correctly calculates the completion percentage as a single aggregate value across all years instead of per-year breakdowns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating race completion percentage for Japanese drivers: use SUM(IIF(T1.time IS NOT NULL, 1, 0)) to count completed races based on time presence rather than position. 2) When computing completion percentage: multiply the completed race count by 100 and divide by COUNT(T1.raceId) instead of using a subquery for total races. 3) When determining race completion: check T1.time IS NOT NULL instead of position being not null. 4) When combining tables for this analysis: use consistent table aliases T1, T2, and T3 as established in the schema relationships. 5) When filtering for Japanese drivers: use the exact literal 'Japanese' for nationality comparison. 6) When filtering for years 2007 to 2009: use inclusive range BETWEEN 2007 AND 2009.",
            "1) When calculating a single aggregate value across multiple years instead of per-year breakdowns: remove the year column from both the SELECT list and GROUP BY clause. 2) When computing percentage calculations that require decimal precision: cast the numerator to REAL type before division to ensure proper decimal results. 3) When the result is a single scalar value without grouping: remove the ORDER BY clause as no ordering is needed. 4) When joining tables for clarity: use explicit INNER JOIN syntax instead of just JOIN."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(DISTINCT r.raceId) * 100.0 / (SELECT COUNT(DISTINCT raceId) FROM races WHERE year BETWEEN 2007 AND 2009) AS completion_percentage\nFROM results r\nJOIN drivers d ON r.driverId = d.driverId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE d.nationality = 'Japanese'\nAND ra.year BETWEEN 2007 AND 2009\nAND r.position IS NOT NULL",
            "SELECT \n    T2.year,\n    SUM(IIF(T1.time IS NOT NULL, 1, 0)) * 100 / COUNT(T1.raceId) AS completion_percentage\nFROM \n    results T1\nJOIN \n    races T2 ON T1.raceId = T2.raceId\nJOIN \n    drivers T3 ON T1.driverId = T3.driverId\nWHERE \n    T2.year BETWEEN 2007 AND 2009\n    AND T3.nationality = 'Japanese'\nGROUP BY \n    T2.year\nORDER BY \n    T2.year;",
            "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.raceId) AS completion_percentage\nFROM results T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T1.raceId = T3.raceId\nWHERE T2.nationality = 'Japanese' AND T3.year BETWEEN 2007 AND 2009"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) * 100.0 AS REAL) / COUNT(T1.raceId) AS completion_percentage\nFROM \n    results T1\nINNER JOIN \n    drivers T2 ON T1.driverId = T2.driverId\nINNER JOIN \n    races T3 ON T1.raceId = T3.raceId\nWHERE \n    T2.nationality = 'Japanese'\n    AND T3.year BETWEEN 2007 AND 2009;"
        ],
        "amend_res": 1
    },
    "625": {
        "db_id": "codebase_community",
        "question": "How many users were from New York?",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE Location = 'New York'",
        "amends": [
            "Do count `Id` instead of `*` to exclude null values. Do filter on `Location` instead of `city` to use the correct column name. Do filter for 'New York' instead of 'California' to query the correct location. The amended query now correctly counts users with non-null IDs located in New York."
        ],
        "rules": [
            "1) When counting users: count the \"Id\" column instead of all columns to exclude null values. 2) When filtering by location: use the \"Location\" column instead of \"city\" to match the correct schema column. 3) When querying for New York users: filter for the exact literal 'New York' instead of 'California' to match the question requirement."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE city = 'California';",
            "SELECT COUNT(Id) FROM users WHERE Location = 'New York';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM users WHERE Location = 'New York';"
        ],
        "amend_res": 1
    },
    "426": {
        "db_id": "card_games",
        "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
        "ground_truth": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
        "amends": [
            "Do filter on `mtgoCode IS NULL` instead of `online = 'false'` in the WHERE clause. Do remove the `ASC` keyword from the ORDER BY clause instead of keeping it. The amended query now correctly filters for sets without MTGO codes and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When filtering for sets that don't appear in Magic: The Gathering Online: use the condition \"mtgoCode IS NULL\" instead of checking online status. 2) When ordering set names alphabetically: order by the \"name\" column without specifying ASC direction (default ascending order). 3) When retrieving the top three sets: limit the results to exactly 3 rows after applying all filters and ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE online = 'false' ORDER BY name ASC LIMIT 3;",
            "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3;"
        ],
        "rule_sql": [
            "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3;"
        ],
        "amend_res": 1
    },
    "1192": {
        "db_id": "thrombosis_prediction",
        "question": "List all patients who were followed up at the outpatient clinic who underwent a laboratory test in October 1991 and had a total blood bilirubin level within the normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.`T-BIL` < 2.0 AND T2.Date LIKE '1991-10-%'",
        "amends": [
            "Do select only `T1.ID` with `DISTINCT` instead of all columns with `*`. Do use explicit table aliases `Patient AS T1` and `Laboratory AS T2` instead of a single table `patients`. Do perform an `INNER JOIN` between `T1` and `T2` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `T1.Admission = '-'` instead of `follow_up_clinic = 'outpatient'`. Do filter on `T2.\"T-BIL\" < 2.0` instead of `bilirubin_level > 0`. Do use a more precise date pattern `'1991-10-%'` instead of `'1991-10%'` for the LIKE condition. The amended query now correctly joins patient and laboratory data, filters for specific admission status and bilirubin levels, and returns distinct patient IDs matching the intended logic."
        ],
        "rules": [
            "1) When answering about patients who were followed up at the outpatient clinic: filter for patients where T1.Admission equals exactly '-' instead of using 'outpatient' as the literal value. 2) When combining patient and laboratory data: perform an inner join between Patient AS T1 and Laboratory AS T2 where T1.ID equals T2.ID exactly. 3) When filtering for laboratory tests in October 1991: use the date pattern '1991-10-%' with exact spacing and punctuation. 4) When checking for normal bilirubin levels: filter where T2.\"T-BIL\" is less than 2.0 instead of checking for values greater than 0. 5) When listing distinct patients: select only T1.ID with DISTINCT instead of all columns with *."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients WHERE follow_up_clinic = 'outpatient' AND test_date LIKE '1991-10%' AND bilirubin_level > 0;",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-'\nAND T2.\"T-BIL\" < 2.0\nAND T2.Date LIKE '1991-10-%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-'\nAND T2.Date LIKE '1991-10-%'\nAND T2.\"T-BIL\" < 2.0"
        ],
        "amend_res": 1
    },
    "1169": {
        "db_id": "thrombosis_prediction",
        "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "amends": [
            "Do use `SUM` with conditional expressions instead of `COUNT` with `CASE` for calculating counts. Do reference tables `Patient AS T1` and `Laboratory AS T2` instead of just `patients`. Do perform an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do apply different uric acid thresholds for males (`UA <= 8.0`) and females (`UA <= 6.5`) instead of a single filter `uric_acid > 7.0 OR uric_acid < 3.0` for all patients. Do calculate the ratio directly using `CAST` to `REAL` division instead of separate count columns and ratio calculation. Do remove the `WHERE` clause entirely instead of filtering before aggregation. The amended query now correctly handles gender-specific uric acid thresholds and calculates the male-to-female ratio with proper table joins and aggregation.",
            "Do use `T2.UA <= 8.0 AND T1.SEX = 'M'` instead of `T1.SEX = 'M' AND (T2.UA > 8.0 OR T2.UA < 3.0)` for the male condition, and do use `T2.UA <= 6.5 AND T1.SEX = 'F'` instead of `T1.SEX = 'F' AND (T2.UA > 6.5 OR T2.UA < 3.0)` for the female condition, changing the logic from counting values outside ranges to counting values within upper bounds. Do remove the redundant `CAST` on the denominator instead of keeping it, as division between REAL values doesn't require explicit casting. Do simplify the CASE expressions by removing the ELSE 0 clause instead of including it, since SUM implicitly treats NULL as 0. The amended query now correctly calculates the ratio of males with UA \u2264 8.0 to females with UA \u2264 6.5, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"ratio of male to female patients among those with abnormal uric acid counts\": use tables \"Patient AS T1\" and \"Laboratory AS T2\" with an inner join on T1.ID = T2.ID. 2) When calculating counts for male and female patients: use SUM with conditional expressions instead of COUNT with CASE. 3) When determining abnormal uric acid levels: apply gender-specific thresholds where males have UA <= 8.0 and females have UA <= 6.5 instead of a single threshold for all patients. 4) When calculating the male-to-female ratio: compute it directly using CAST to REAL division of male count divided by female count. 5) When filtering for abnormal uric acid: do not use a WHERE clause before aggregation, instead apply the gender-specific thresholds within the conditional expressions for counting.",
            "1) When the question asks for ratio of male to female patients with abnormal uric acid counts: compute (count of male patients with UA \u2264 8.0) divided by (count of female patients with UA \u2264 6.5), guarding against division by zero. 2) When counting male patients with abnormal uric acid: count rows where T1.SEX = 'M' AND T2.UA \u2264 8.0. 3) When counting female patients with abnormal uric acid: count rows where T1.SEX = 'F' AND T2.UA \u2264 6.5. 4) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 5) When handling text literals: preserve exact case and quotes for 'M' and 'F' values. 6) When computing ratios: avoid unnecessary casting operations as division between numeric values doesn't require explicit casting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    COUNT(CASE WHEN gender = 'M' THEN 1 END) AS male_count,\n    COUNT(CASE WHEN gender = 'F' THEN 1 END) AS female_count,\n    COUNT(CASE WHEN gender = 'M' THEN 1 END) / COUNT(CASE WHEN gender = 'F' THEN 1 END) AS male_to_female_ratio\nFROM patients\nWHERE uric_acid > 7.0 OR uric_acid < 3.0;",
            "SELECT \n    CAST(SUM(CASE WHEN T1.SEX = 'M' AND (T2.UA > 8.0 OR T2.UA < 3.0) THEN 1 ELSE 0 END) AS REAL) / \n    CAST(SUM(CASE WHEN T1.SEX = 'F' AND (T2.UA > 6.5 OR T2.UA < 3.0) THEN 1 ELSE 0 END) AS REAL) AS male_to_female_ratio\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / \n    SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS male_to_female_ratio\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T1.SEX = 'M' AND T2.UA <= 8.0 THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN T1.SEX = 'F' AND T2.UA <= 6.5 THEN 1 ELSE 0 END), 0) AS male_to_female_ratio\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID"
        ],
        "amend_res": 1
    },
    "1326": {
        "db_id": "student_club",
        "question": "How many members of the Student_Club have majored Environmental Engineering?\n",
        "ground_truth": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'",
        "amends": [
            "Do select `COUNT(T1.member_id)` instead of `COUNT(*)` to count specific members rather than all rows. Do use `FROM member AS T1 INNER JOIN major AS T2` instead of `FROM Student_Club` to properly join the member and major tables. Do add the join condition `ON T1.link_to_major = T2.major_id` instead of omitting any join relationship. Do filter with `WHERE T2.major_name = 'Environmental Engineering'` instead of `WHERE major = 'Environmental Engineering'` to reference the correct table column. The amended query now correctly counts members by joining through proper relationships and matches the intended behavior."
        ],
        "rules": [
            "1) When counting members: use COUNT(T1.member_id) instead of COUNT(*) to count specific members rather than all rows. 2) When joining member and major tables: use FROM member AS T1 INNER JOIN major AS T2 instead of FROM Student_Club to properly access both tables. 3) When linking member and major tables: add the join condition ON T1.link_to_major = T2.major_id to establish the proper relationship between tables. 4) When filtering for Environmental Engineering majors: use WHERE T2.major_name = 'Environmental Engineering' instead of WHERE major = 'Environmental Engineering' to reference the correct table column with exact literal value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Student_Club WHERE major = 'Environmental Engineering';",
            "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.member_id) \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T2.major_name = 'Environmental Engineering'"
        ],
        "amend_res": 1
    },
    "1084": {
        "db_id": "european_football_2",
        "question": "Among the players born before the year 1986, how many of them would remain in his position and defense while the team attacked?",
        "ground_truth": "SELECT COUNT(DISTINCT t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE STRFTIME('%Y',t1.birthday) < '1986' AND t2.defensive_work_rate = 'high'",
        "amends": [
            "Do select `COUNT(DISTINCT t1.player_name)` instead of `COUNT(*)`. Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do filter with `STRFTIME('%Y',t1.birthday) < '1986'` instead of `birth_year < 1986`. Do filter with `t2.defensive_work_rate = 'high'` instead of `position = 'defense' AND team_status = 'attacking'`. The amended query now correctly counts distinct player names from joined tables using proper date extraction and defensive work rate filtering."
        ],
        "rules": [
            "1) When answering about players born before 1986: extract year from t1.birthday using STRFTIME('%Y',t1.birthday) and compare to '1986' as string. 2) When determining defensive players during attack: use t2.defensive_work_rate = 'high' instead of position and team_status filters. 3) When counting players: count distinct t1.player_name values rather than all rows. 4) When combining player information: join Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id to link player attributes with player data. 5) When handling player identification: use t1.player_api_id as the join key between Player and Player_Attributes tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players \nWHERE birth_year < 1986 \nAND position = 'defense' \nAND team_status = 'attacking';",
            "SELECT COUNT(DISTINCT t1.player_name) \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE STRFTIME('%Y', t1.birthday) < '1986' \nAND t2.defensive_work_rate = 'high'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t1.player_name) \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE STRFTIME('%Y', t1.birthday) < '1986' \nAND t2.defensive_work_rate = 'high';"
        ],
        "amend_res": 1
    },
    "511": {
        "db_id": "card_games",
        "question": "What is the most common visual frame effects among the incredibly powerful foils?",
        "ground_truth": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1",
        "amends": [
            "Do select `frameEffects` instead of `visual_frame_effects` and do remove the alias `count` instead of keeping it. Do use table `cards` instead of `foils` and do add filters `cardKingdomFoilId IS NOT NULL` and `cardKingdomId IS NOT NULL` instead of omitting them. Do change the WHERE filter from `power_level = 'incredibly powerful'` to the added NULL checks instead of the power level condition. Do group by `frameEffects` instead of `visual_frame_effects` and do order by `COUNT(frameEffects)` instead of the aliased `count`. The amended query now correctly retrieves the most common frame effects from cards with both Card Kingdom identifiers present.",
            "Do remove `COUNT(frameEffects)` from the SELECT list instead of including it, since the query only needs to return the frameEffects value with the highest count rather than both the value and its count. The GROUP BY clause, ORDER BY clause with COUNT(frameEffects) DESC, and LIMIT 1 remain unchanged to correctly identify the most frequently occurring frameEffects value among records where both cardKingdomFoilId and cardKingdomId are not null. The amended query now matches RIGHT_SQL's behavior by returning just the frameEffects value with the maximum occurrence count."
        ],
        "rules": [
            "1) When answering about \"most common visual frame effects among the incredibly powerful foils\": make sure the output order: frameEffects first, then the count. 2) When the question mentions \"visual frame effects\": \"visual frame effects\" actually means \"frameEffects in schema\". 3) When the question mentions \"foils\": \"foils\" actually means \"cards with both cardKingdomFoilId IS NOT NULL and cardKingdomId IS NOT NULL in schema\". 4) When the question asks for \"most common\": rank rows by COUNT(frameEffects) in descending order and keep the first 1 row. 5) When the question asks for \"count of frame effects\": compute the number of rows using the exact token frameEffects without an alias. 6) When filtering for foils: apply both conditions cardKingdomFoilId IS NOT NULL and cardKingdomId IS NOT NULL instead of any power level condition.",
            "1) When answering about \"most common visual frame effects among the incredibly powerful foils\": make sure the output order: frameEffects only (without the count). 2) When the question mentions \"incredibly powerful foils\": \"incredibly powerful foils\" actually means records where both cardKingdomFoilId and cardKingdomId are not null in schema. 3) When the question asks for \"most common\" frame effects: rank rows by count of frameEffects in descending order and keep the first 1 row. 4) When counting frame effects occurrences: compute the number of rows using the frameEffects column for grouping and counting. 5) When producing output for \"most common\" queries: return only the value column (frameEffects) without the count column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT visual_frame_effects, COUNT(*) as count FROM foils WHERE power_level = 'incredibly powerful' GROUP BY visual_frame_effects ORDER BY count DESC LIMIT 1;",
            "SELECT frameEffects, COUNT(frameEffects) FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1;",
            "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "367": {
        "db_id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "amends": [
            "Do select `artist` from the `cards` table instead of `artist_name` from the `artists` table. Do join `foreign_data` using an `INNER JOIN` on `uuid` instead of querying a single table. Do filter on `language = 'Phyrexian'` in the joined `foreign_data` table instead of filtering directly on the original table. The amended query now correctly retrieves artist information from the cards table joined with language data, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about artists who illustrated card art in Phyrexian: select \"artist\" from the \"cards\" table instead of \"artist_name\" from \"artists\". 2) When combining card and language data: join \"cards\" (as T1) with \"foreign_data\" (as T2) using an INNER JOIN where T1.\"uuid\" = T2.\"uuid\". 3) When filtering for Phyrexian language: apply the condition T2.\"language\" = 'Phyrexian' to the joined \"foreign_data\" table. 4) When retrieving artist information: ensure the output column is \"artist\" from the \"cards\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name FROM artists WHERE language = 'Phyrexian';",
            "SELECT DISTINCT c.artist\nFROM cards c\nINNER JOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Phyrexian';"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.artist FROM cards c INNER JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian'"
        ],
        "amend_res": 1
    },
    "211": {
        "db_id": "toxicology",
        "question": "Indicate which atoms are connected in non-carcinogenic type molecules.",
        "ground_truth": "SELECT DISTINCT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.label = '-'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the source from `atoms` to `atom AS T1` instead of keeping the original table. Do add `INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of omitting this join. Do add `INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id` instead of omitting this second join. Do change the filter to `T2.label = '-'` instead of `molecule_type = 'carcinogenic'`. The amended query now correctly joins multiple tables and filters on molecule labels rather than molecule types."
        ],
        "rules": [
            "1) When answering about \"atoms connected in non-carcinogenic type molecules\": make sure the output order: atom_id\n2) When the question mentions \"non-carcinogenic type molecules\": \"non-carcinogenic\" actually means \"T2.label = '-'\" in schema\n3) When combining T1 (atom) and T2 (molecule) for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)\n4) When combining T1 (atom) and T3 (connected) for shared entities: link rows where T1.atom_id = T3.atom_id; keep only matching pairs (inner match)\n5) When the question asks for \"which atoms are connected\": use DISTINCT to return unique atom_id values\n6) When filtering molecules: use the exact literal '-' for T2.label to identify non-carcinogenic molecules"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_id FROM atoms WHERE molecule_type = 'carcinogenic';",
            "SELECT DISTINCT T1.atom_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT a.atom_id\nFROM atom a\nJOIN molecule m ON a.molecule_id = m.molecule_id\nJOIN connected c ON a.atom_id = c.atom_id\nWHERE m.label = '-';"
        ],
        "amend_res": 1
    },
    "893": {
        "db_id": "formula_1",
        "question": "Name the top 3 drivers and the points they scored in the 2017 Chinese Grand Prix.",
        "evidence": "",
        "ground_truth": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017 ORDER BY T2.points DESC LIMIT 3",
        "amends": [
            "Do add table joins with `INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId` and `INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId` instead of querying a single table. Do select specific columns `T3.forename, T3.surname, T2.points` instead of generic `driver_name, points`. Do use proper table aliases and qualified column references throughout instead of unqualified column names. Do filter on `T1.name = 'Chinese Grand Prix'` instead of `race_name` and maintain `T1.year = 2017`. Do order by `T2.points DESC` instead of just `points DESC` while keeping the same `LIMIT 3`. The amended query now correctly joins the necessary tables to retrieve driver names with their points from the specific race."
        ],
        "rules": [
            "1) When answering about \"top 3 drivers and points in the 2017 Chinese Grand Prix\": make sure the output order: T3.forename, T3.surname, T2.points. 2) When the question mentions \"Chinese Grand Prix\": \"Chinese Grand Prix\" actually means \"T1.name = 'Chinese Grand Prix'\" in schema. 3) When the question mentions \"top 3\" by points: rank rows by T2.points in descending order and keep the first 3 rows. 4) When combining T1, T2, and T3 for shared entities: link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match). 5) When filtering by year: use T1.year = 2017 exactly as specified in the question."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT driver_name, points FROM races WHERE year = 2017 AND race_name = 'Chinese Grand Prix' ORDER BY points DESC LIMIT 3;",
            "SELECT T3.forename, T3.surname, T2.points\nFROM races AS T1\nINNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T1.name = 'Chinese Grand Prix' AND T1.year = 2017\nORDER BY T2.points DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname, r.points\nFROM races ra\nJOIN results r ON ra.raceId = r.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.year = 2017\nAND ra.name = 'Chinese Grand Prix'\nORDER BY r.points DESC\nLIMIT 3",
            "SELECT d.forename, d.surname, r.points\nFROM races ra\nJOIN results r ON ra.raceId = r.raceId\nJOIN drivers d ON r.driverId = d.driverId\nWHERE ra.name = 'Chinese Grand Prix' AND ra.year = 2017\nORDER BY r.points DESC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "1298": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients whose total cholesterol is within the normal range, how many of them have a P pattern observed in the sheet of ANA examination?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T3.`ANA Pattern` = 'P' AND T2.`T-CHO` < 250",
        "amends": [
            "Do select `COUNT(T1.ID)` instead of `COUNT(*)` to count specific non-null values. Do use table aliases `T1`, `T2`, `T3` instead of `p`, `lr`, `ae` for consistent naming. Do reference tables `Patient`, `Laboratory`, `Examination` instead of `patients`, `lab_results`, `ana_examination` to match the correct schema. Do join on `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of using `patient_id` columns to properly link the tables. Do filter with `T3.ANA Pattern = 'P'` instead of `ae.sheet_pattern = 'P'` to reference the correct column name and pattern value. Do filter with `T2.T-CHO < 250` instead of `lr.cholesterol > 200` to use the correct column name and change the comparison from greater than to less than with a different threshold value. The amended query now correctly counts patients with specific examination patterns and laboratory values below the specified threshold."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific non-null patient identifiers. 2) When referencing tables: use table aliases T1 for Patient, T2 for Laboratory, and T3 for Examination instead of p, lr, ae. 3) When joining tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID to properly connect patient records across tables. 4) When filtering for ANA examination patterns: use T3.\"ANA Pattern\" = 'P' to reference the correct column name and pattern value. 5) When filtering for normal cholesterol range: use T2.\"T-CHO\" < 250 instead of greater than 200 to use the correct column name and threshold value with less than comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN lab_results lr ON p.patient_id = lr.patient_id\nJOIN ana_examination ae ON p.patient_id = ae.patient_id\nWHERE lr.cholesterol > 200 \nAND ae.sheet_pattern = 'P';",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-CHO\" < 250 \nAND T3.\"ANA Pattern\" = 'P'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nJOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-CHO\" < 250 \nAND T3.\"ANA Pattern\" = 'P'"
        ],
        "amend_res": 1
    },
    "156": {
        "db_id": "financial",
        "question": "Who is the owner of the account with the largest loan amount?",
        "evidence": "",
        "ground_truth": "SELECT T1.client_id FROM disp AS T1 INNER JOIN account AS T3 ON T1.account_id = T3.account_id INNER JOIN loan AS T2 ON T3.account_id = T2.account_id WHERE T1.type = 'OWNER' ORDER BY T2.amount DESC LIMIT 1",
        "amends": [
            "Do select `T1.client_id` instead of `owner` and add joins to `disp AS T1`, `account AS T3`, and `loan AS T2` instead of querying only `accounts`. Do use `INNER JOIN` on `T1.account_id = T3.account_id` and `INNER JOIN` on `T3.account_id = T2.account_id` instead of no joins. Do add a WHERE filter `T1.type = 'OWNER'` instead of omitting it. Do order by `T2.amount DESC` instead of `loan_amount DESC`. The amended query now correctly identifies the client with the highest loan amount among account owners by properly joining the disp, account, and loan tables with appropriate conditions."
        ],
        "rules": [
            "1) When answering about \"owner of the account with the largest loan amount\": make sure the output order: T1.client_id. 2) When the question mentions \"owner\": \"owner\" actually means \"T1.type = 'OWNER'\" in schema. 3) When the question mentions \"largest loan amount\": \"largest loan amount\" actually means \"T2.amount DESC\" in schema. 4) When combining T1 (disp), T3 (account), and T2 (loan) for shared entities: link rows where T1.account_id = T3.account_id and T3.account_id = T2.account_id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation for 'OWNER'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner FROM accounts ORDER BY loan_amount DESC LIMIT 1;",
            "SELECT T1.client_id\nFROM disp AS T1\nINNER JOIN account AS T3 ON T1.account_id = T3.account_id\nINNER JOIN loan AS T2 ON T3.account_id = T2.account_id\nWHERE T1.type = 'OWNER'\nORDER BY T2.amount DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.client_id\nFROM disp T1\nINNER JOIN account T3 ON T1.account_id = T3.account_id\nINNER JOIN loan T2 ON T3.account_id = T2.account_id\nWHERE T1.type = 'OWNER'\nORDER BY T2.amount DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1521": {
        "db_id": "debit_card_specializing",
        "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
        "amends": [
            "Do add `INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID` instead of querying only the transactions table. Do reference `T1.TransactionID` in the COUNT function instead of using `COUNT(*)`. Do move the country filter to `T2.Country = 'CZE'` instead of applying it directly to the transactions table. Do use table aliases `T1` and `T2` instead of direct table references. Do specify the table name as `transactions_1k AS T1` instead of just `transactions`. The amended query now correctly joins the tables and filters by country on the appropriate table, matching the RIGHT_SQL's behavior.",
            "Do use the ISO date format `2012-08-26` instead of the non-standard `2012/8/26` format. Do use full time format with seconds `08:00:00` and `09:00:00` instead of the partial time format `08:00` and `09:00` without seconds. The amended query now correctly handles date and time formatting while maintaining the same join logic and filtering conditions."
        ],
        "rules": [
            "1) When answering about transactions during a specific time period: use table \"transactions_1k AS T1\" instead of just \"transactions\". 2) When counting transactions: count using \"T1.TransactionID\" instead of counting all rows with COUNT(*). 3) When filtering by country: apply the filter \"T2.Country = 'CZE'\" on the gasstations table instead of directly on the transactions table. 4) When combining transaction and gas station data: link rows where \"T1.GasStationID = T2.GasStationID\" using an inner join between \"transactions_1k AS T1\" and \"gasstations AS T2\". 5) When handling time and date filters: keep the exact conditions \"date = '2012-08-26' AND time BETWEEN '08:00:00' AND '09:00:00'\" as specified in the question.",
            "1) When the question mentions a date in format \"2012/8/26\": use the ISO date format \"2012-08-26\" with leading zeros for month and day. 2) When the question mentions a time range \"8:00-9:00\": use the full time format with seconds as \"08:00:00\" and \"09:00:00\" including leading zeros for hours."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE country = 'CZE' AND date = '2012-08-26' AND time BETWEEN '08:00:00' AND '09:00:00';",
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012/8/26' \nAND T1.Time BETWEEN '08:00' AND '09:00'\nAND T2.Country = 'CZE'",
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012-08-26' \nAND T1.Time BETWEEN '08:00:00' AND '09:00:00'\nAND T2.Country = 'CZE'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012-08-26' \nAND T1.Time BETWEEN '08:00:00' AND '09:00:00'\nAND T2.Country = 'CZE'"
        ],
        "amend_res": 1
    },
    "1435": {
        "db_id": "student_club",
        "question": "List the names of closed event as \"game\" that was closed from 3/15/2019 to 3/20/2020.",
        "ground_truth": "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'Closed'",
        "amends": [
            "Do select `event_name` instead of `name AS game` and add `DISTINCT` instead of omitting it. Do reference table `event` instead of `events` and add filter `type = 'Game'` instead of omitting it. Do use `date(SUBSTR(event_date, 1, 10))` for date range filtering instead of `closed_date` and change the date column reference. Do change the status filter to `status = 'Closed'` (with capital C) instead of `status = 'closed'` (with lowercase c) to match the actual data values. The amended query now correctly selects distinct game event names from the proper table with accurate date handling and status filtering."
        ],
        "rules": [
            "1) When the question asks for \"names of closed event as 'game'\": select \"event_name\" instead of \"name AS game\" and use DISTINCT to avoid duplicates. 2) When filtering by event type: add condition \"type = 'Game'\" to only include game events. 3) When filtering by status: use \"status = 'Closed'\" (with capital C) instead of lowercase to match actual data values. 4) When filtering by date range: use \"date(SUBSTR(event_date, 1, 10))\" for date handling instead of \"closed_date\" and filter between '2019-03-15' AND '2020-03-20'. 5) When referencing the table: use \"event\" instead of \"events\" as the correct table name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name AS game FROM events WHERE status = 'closed' AND closed_date BETWEEN '2019-03-15' AND '2020-03-20'",
            "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND status = 'Closed' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20';"
        ],
        "rule_sql": [
            "SELECT DISTINCT event_name FROM event WHERE type = 'Game' AND status = 'Closed' AND date(SUBSTR(event_date, 1, 10)) BETWEEN '2019-03-15' AND '2020-03-20';"
        ],
        "amend_res": 1
    },
    "132": {
        "db_id": "financial",
        "question": "What is the average loan amount by male borrowers?",
        "ground_truth": "SELECT AVG(T4.amount) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN loan AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'M'",
        "amends": [
            "Do use `AVG(T4.amount)` instead of `AVG(loan_amount)` for the aggregate expression. Do join multiple tables starting with `client AS T1` instead of querying a single `loans` table. Do use `INNER JOIN disp AS T2 ON T1.client_id = T2.client_id` to connect client to disposition, then `INNER JOIN account AS T3 ON T2.account_id = T3.account_id` to connect to account, and finally `INNER JOIN loan AS T4 ON T3.account_id = T4.account_id` to reach the loan data instead of directly accessing loan information. Do filter on `T1.gender = 'M'` instead of `gender = 'female'` for the gender condition. The amended query now correctly navigates the database schema relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average loan amount by male borrowers\": make sure the output order: AVG(T4.amount). 2) When combining tables for client, disposition, account, and loan data: link rows where T1.client_id = T2.client_id, then T2.account_id = T3.account_id, and finally T3.account_id = T4.account_id; keep only matching pairs (inner match). 3) When the question mentions \"male borrowers\": use T1.gender = 'M' as the gender condition instead of 'female'. 4) When computing the average loan amount: use AVG(T4.amount) instead of AVG(loan_amount)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(loan_amount) FROM loans WHERE gender = 'female';",
            "SELECT AVG(T4.amount) AS average_loan_amount\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T3 ON T2.account_id = T3.account_id\nINNER JOIN loan AS T4 ON T3.account_id = T4.account_id\nWHERE T1.gender = 'M'"
        ],
        "rule_sql": [
            "SELECT AVG(T4.amount) \nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T3 ON T2.account_id = T3.account_id\nINNER JOIN loan T4 ON T3.account_id = T4.account_id\nWHERE T1.gender = 'M'"
        ],
        "amend_res": 1
    },
    "624": {
        "db_id": "codebase_community",
        "question": "What is the name of user with the ID of 30?",
        "ground_truth": "SELECT DisplayName FROM users WHERE Id = 30",
        "amends": [
            "Do use column alias `DisplayName` instead of `name` in the SELECT list. Do reference column `Id` instead of `user_id` in the WHERE filter. The amended query now correctly retrieves the display name using the proper column identifiers and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the name of a user: use the exact column token \"DisplayName\" from the users table instead of \"name\". 2) When filtering by user ID: use the exact column token \"Id\" from the users table instead of \"user_id\". 3) When the question specifies a user ID value of 30: use the exact literal value 30 without quotes for numeric comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM users WHERE user_id = 30;",
            "SELECT DisplayName FROM users WHERE Id = 30;"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE Id = 30;"
        ],
        "amend_res": 1
    },
    "684": {
        "db_id": "codebase_community",
        "question": "Identify the percentage of teenage users.",
        "ground_truth": "SELECT CAST(SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(Id) FROM users",
        "amends": [
            "Do use `SUM(IIF(Age BETWEEN 13 AND 18, 1, 0))` to count teenage users instead of `COUNT(*)` with a string filter `age = 'teenage'`. Do cast the result to `REAL` for proper division instead of implicit casting. Do calculate the percentage by dividing by `COUNT(Id)` instead of using a subquery `(SELECT COUNT(*) FROM users)`. Do remove the incorrect string comparison `age = 'teenage'` and instead use the numeric range check `Age BETWEEN 13 AND 18` for accurate age filtering. The amended query now correctly calculates the percentage of teenage users using proper numeric comparisons and avoids the subquery dependency."
        ],
        "rules": [
            "1) When counting teenage users: use SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) instead of COUNT(*) with string comparison. 2) When calculating percentages: cast the result to REAL for proper division instead of implicit casting. 3) When counting total users: use COUNT(Id) instead of COUNT(*) in a subquery. 4) When filtering by age: use numeric range check Age BETWEEN 13 AND 18 instead of string comparison age = 'teenage'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM users) AS percentage FROM users WHERE age = 'teenage';",
            "SELECT (SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) * 100.0 / COUNT(Id)) AS percentage_teenage_users FROM users;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) AS REAL) / COUNT(Id) * 100 AS percentage_teenage_users FROM users;"
        ],
        "amend_res": 1
    },
    "1384": {
        "db_id": "student_club",
        "question": "How many income generated by Grant Gilmour?",
        "ground_truth": "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'",
        "amends": [
            "Do select `T2.amount` as a single column instead of aggregating with `SUM(amount)`; do use `FROM member AS T1 INNER JOIN income AS T2` instead of `FROM transactions` alone; do join on `T1.member_id = T2.link_to_member` instead of no join condition; do filter with `T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'` instead of `customer_name = 'Grant Gilmour'`; do remove the `transaction_type = 'expense'` filter instead of keeping it; and do omit the aggregation entirely instead of using `SUM`. The amended query now correctly retrieves individual income amounts for the specified member rather than summing expense transactions."
        ],
        "rules": [
            "1) When answering about \"income generated by Grant Gilmour\": make sure the output order: T2.amount\n2) When the question mentions \"Grant Gilmour\": \"Grant Gilmour\" actually means \"T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for income amounts: do not apply any aggregation function to T2.amount instead of using SUM\n5) When filtering for transaction types: do not include transaction_type = 'expense' filter instead of removing it entirely"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM transactions WHERE customer_name = 'Grant Gilmour' AND transaction_type = 'expense';",
            "SELECT T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'"
        ],
        "rule_sql": [
            "SELECT T2.amount\nFROM member T1\nINNER JOIN income T2 ON T1.member_id = T2.link_to_member\nWHERE T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'\nORDER BY T2.amount"
        ],
        "amend_res": 1
    },
    "366": {
        "db_id": "card_games",
        "question": "What is the rule of playing card \"Benalish Knight\"?",
        "ground_truth": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "amends": [
            "Do select `T2.format` instead of `*` and specify the exact column needed. Do use `cards AS T1` and `legalities AS T2` as table sources instead of just `magic_cards`. Do add an `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying a single table. Do move the filter condition to reference `T1.name` instead of just `name` while keeping the same value 'Benalish Knight'. The amended query now correctly joins the cards and legalities tables to retrieve format information for the specified card name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"rule of playing card\": make sure the output order: T2.format 2) When the question mentions \"Benalish Knight\": \"Benalish Knight\" actually means T1.name = 'Benalish Knight' in schema 3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation from 'Benalish Knight'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM magic_cards WHERE name = 'Benalish Knight';",
            "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'"
        ],
        "rule_sql": [
            "SELECT T2.format, T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight' ORDER BY T2.format",
            "SELECT T2.format FROM cards T1 INNER JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'"
        ],
        "amend_res": 1
    },
    "1518": {
        "db_id": "debit_card_specializing",
        "question": "For the deal happened at 2012/8/24 12:42:00, which country was it?",
        "ground_truth": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Time = '12:42:00'",
        "amends": [
            "Do select `T2.Country` from the `gasstations` table instead of `country` from the `deals` table. Do join `transactions_1k AS T1` with `gasstations AS T2` using `INNER JOIN` on `T1.GasStationID = T2.GasStationID` instead of querying a single table. Do filter by both `T1.Date = '2012-08-24'` and `T1.Time = '12:42:00'` instead of a combined datetime string `'2012/8/24 12:42:00'`. Do use proper date format `'2012-08-24'` instead of `'2012/8/24'` and separate time component. The amended query now correctly retrieves country information by joining transaction data with gas station details using proper date/time filtering."
        ],
        "rules": [
            "1) When answering about \"which country was it for a deal\": make sure the output order: T2.Country. 2) When the question mentions \"deal happened at 2012/8/24 12:42:00\": filter using T1.Date = '2012-08-24' and T1.Time = '12:42:00' instead of a combined datetime string. 3) When combining transactions_1k AS T1 and gasstations AS T2: link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match). 4) When handling date literals: use exact format '2012-08-24' instead of '2012/8/24' and preserve time format '12:42:00' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM deals WHERE date = '2012/8/24 12:42:00';",
            "SELECT T2.Country \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012-08-24' AND T1.Time = '12:42:00'"
        ],
        "rule_sql": [
            "SELECT T2.Country\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T1.Date = '2012-08-24' AND T1.Time = '12:42:00'"
        ],
        "amend_res": 1
    },
    "76": {
        "db_id": "california_schools",
        "question": "What is the city location of the high school level school with Lunch Provision 2 whose lowest grade is 9 and the highest grade is 12 in the county of Merced?",
        "ground_truth": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Lunch Provision 2' AND T2.County = 'Merced' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12 AND T2.EILCode = 'HS'",
        "amends": [
            "Do select `T2.City` from the `schools` table instead of `city` from `schools` alone. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter by `T1.NSLP Provision Status = 'Lunch Provision 2'` instead of `lunch_provision = 2`. Do add `T2.EILCode = 'HS'` instead of `level = 'High School'`. Do use `T1.Low Grade = 9` and `T1.High Grade = 12` instead of `lowest_grade = 9` and `highest_grade = 12` while keeping `T2.County = 'Merced'`. The amended query now correctly joins the frpm and schools tables to match the required logic and returns the expected results."
        ],
        "rules": [
            "1) When answering about city location of schools: select \"T2.City\" from the schools table instead of just \"city\" from schools alone. 2) When combining frpm and schools tables: join \"frpm AS T1\" with \"schools AS T2\" using inner join where \"T1.CDSCode = T2.CDSCode\" to match shared entities. 3) When the question mentions \"Lunch Provision 2\": filter by \"T1.NSLP Provision Status = 'Lunch Provision 2'\" exactly as specified. 4) When the question mentions \"high school level\": filter by \"T2.EILCode = 'HS'\" instead of level = 'High School'. 5) When the question specifies lowest grade 9 and highest grade 12: use \"T1.Low Grade = 9\" and \"T1.High Grade = 12\" instead of lowest_grade and highest_grade. 6) When filtering by county: keep \"T2.County = 'Merced'\" as specified in the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT city FROM schools WHERE level = 'High School' AND lunch_provision = 2 AND lowest_grade = 9 AND highest_grade = 12 AND county = 'Merced';",
            "SELECT T2.City \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T1.\"NSLP Provision Status\" = 'Lunch Provision 2' \nAND T2.EILCode = 'HS' \nAND T1.\"Low Grade\" = '9' \nAND T1.\"High Grade\" = '12' \nAND T2.County = 'Merced'"
        ],
        "rule_sql": [
            "SELECT T2.City \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T1.\"NSLP Provision Status\" = 'Lunch Provision 2' \nAND T2.EILCode = 'HS' \nAND T1.\"Low Grade\" = '9' \nAND T1.\"High Grade\" = '12' \nAND T2.County = 'Merced'"
        ],
        "amend_res": 1
    },
    "700": {
        "db_id": "codebase_community",
        "question": "Identify the number of posts that offer a bounty amount over 30.",
        "ground_truth": "SELECT COUNT(id) FROM votes WHERE BountyAmount >= 30",
        "amends": [
            "Do select `COUNT(id)` from the `votes` table instead of `COUNT(*)` from the `posts` table. Do use the column `BountyAmount` with the condition `>= 30` instead of `bounty_amount > 30`. The amended query now correctly counts records from the votes table where the bounty amount is 30 or greater, matching the intended behavior."
        ],
        "rules": [
            "1) When counting posts that offer a bounty amount: count using the \"id\" column from the \"votes\" table instead of counting all rows from the \"posts\" table. 2) When checking for bounty amount over 30: use the condition \"BountyAmount\" >= 30 instead of bounty_amount > 30 to include values of exactly 30. 3) When answering about bounty amounts: \"BountyAmount\" in the \"votes\" table is the correct column to reference, not bounty_amount from the \"posts\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE bounty_amount > 30;",
            "SELECT COUNT(Id) FROM votes WHERE BountyAmount >= 30"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM votes WHERE BountyAmount >= 30;"
        ],
        "amend_res": 1
    },
    "432": {
        "db_id": "card_games",
        "question": "Which Russian set of cards contains the most cards overall?",
        "ground_truth": "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1",
        "amends": [
            "Do select `T1.id` instead of `name, COUNT(*) as total_cards`. Do use `FROM sets AS T1 INNER JOIN set_translations AS T2` instead of `FROM cards`. Do apply join condition `ON T1.code = T2.setCode` instead of no join. Do filter with `WHERE T2.language = 'Russian'` instead of `WHERE country = 'Russia'`. Do group by `T1.baseSetSize` instead of `name`. Do order by `T1.baseSetSize DESC` instead of `total_cards DESC`. The amended query now correctly retrieves set IDs for Russian translations ordered by base set size."
        ],
        "rules": [
            "1) When answering about \"Russian set of cards\": use tables \"sets\" as T1 and \"set_translations\" as T2 with inner join condition T1.code = T2.setCode. 2) When filtering for Russian language: apply exact literal filter T2.language = 'Russian'. 3) When counting cards in a set: use T1.baseSetSize instead of counting individual cards. 4) When ordering by card count: order by T1.baseSetSize in descending direction. 5) When selecting output: return T1.id as the set identifier."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, COUNT(*) as total_cards FROM cards WHERE country = 'Russia' GROUP BY name ORDER BY total_cards DESC LIMIT 1;",
            "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY T1.baseSetSize DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.id \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode \nWHERE T2.language = 'Russian' \nORDER BY T1.baseSetSize DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1351": {
        "db_id": "student_club",
        "question": "What was Brent Thomason's major?",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'",
        "amends": [
            "Do select `T2.major_name` instead of `major` and use table aliases instead of bare column references. Do join `member AS T1` and `major AS T2` with `INNER JOIN` on `T1.link_to_major = T2.major_id` instead of querying only the `students` table. Do filter with `T1.first_name = 'Brent' AND T1.last_name = 'Thomason'` instead of just `name = 'Brent Thomason'` to properly match separate first and last name fields. The amended query now correctly retrieves the major name from the joined tables using proper relationship constraints and name field separation."
        ],
        "rules": [
            "1) When the question asks about a person's major: use the exact column \"T2.major_name\" instead of \"major\" for output. 2) When combining member and major tables: link rows where \"T1.link_to_major = T2.major_id\" using an inner match. 3) When filtering for a person named \"Brent Thomason\": use separate conditions \"T1.first_name = 'Brent'\" AND \"T1.last_name = 'Thomason'\" instead of a single name field. 4) When answering about a person's major: make sure to join \"member AS T1\" and \"major AS T2\" tables instead of querying only a single students table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major FROM students WHERE name = 'Brent Thomason';",
            "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'"
        ],
        "rule_sql": [
            "SELECT T2.major_name \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'"
        ],
        "amend_res": 1
    },
    "543": {
        "db_id": "codebase_community",
        "question": "For the post that got the most number of answers owned by csgillespie, how many answers did it get?",
        "ground_truth": "SELECT MAX(T1.AnswerCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do use `MAX(T1.AnswerCount)` instead of `COUNT(*)` for the aggregate function. Do reference `posts AS T1` instead of `answers a` as the primary table source. Do use `INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id` instead of joining through answers and posts with `JOIN posts p ON a.parent_id = p.id JOIN users u ON p.owner_user_id = u.id`. Do place the filter `WHERE T2.DisplayName = 'csgillespie'` instead of the complex join chain. Do remove `ORDER BY COUNT(*) DESC LIMIT 1` instead of keeping the ordering and limiting, as the MAX function achieves the same result more efficiently. The amended query now correctly calculates the maximum answer count for the specified user without unnecessary joins and ordering."
        ],
        "rules": [
            "1) When answering about \"the post that got the most number of answers owned by csgillespie\": use MAX(T1.AnswerCount) instead of COUNT(*) to find the maximum answer count. 2) When the question mentions \"posts\": use \"posts AS T1\" as the primary table source instead of answers. 3) When combining posts and users for shared entities: link rows where T1.OwnerUserId = T2.Id using INNER JOIN users AS T2. 4) When filtering for user csgillespie: use WHERE T2.DisplayName = 'csgillespie' exactly as specified. 5) When finding the maximum value: remove ORDER BY and LIMIT clauses as MAX function achieves the same result more efficiently."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM answers a\nJOIN posts p ON a.parent_id = p.id\nJOIN users u ON p.owner_user_id = u.id\nWHERE u.display_name = 'csgillespie'\nORDER BY COUNT(*) DESC\nLIMIT 1;",
            "SELECT MAX(T1.AnswerCount) \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT MAX(T1.AnswerCount) \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "amend_res": 1
    },
    "342": {
        "db_id": "card_games",
        "question": "List the card names with value that cost more converted mana for the face.",
        "ground_truth": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
        "amends": [
            "Do select only `name` instead of both `card_name` and `value`. Do remove the `WHERE` filter on `converted_mana_cost > face_value` instead of keeping it. Do add `ORDER BY faceConvertedManaCost` instead of omitting ordering. Do add `LIMIT 1` instead of returning all matching rows. The amended query now correctly returns the single card name with the lowest faceConvertedManaCost value."
        ],
        "rules": [
            "1) When answering about \"card names with value that cost more converted mana for the face\": make sure the output order includes only \"name\" column instead of both \"card_name\" and \"value\". 2) When the question asks for the card with the lowest faceConvertedManaCost value: remove any WHERE filter conditions and instead order by \"faceConvertedManaCost\" in ascending order. 3) When the question implies finding a single result: limit the output to only 1 row using LIMIT 1 instead of returning all matching rows."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT card_name, value FROM cards WHERE converted_mana_cost > face_value;",
            "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name FROM cards ORDER BY faceConvertedManaCost DESC LIMIT 1;",
            "SELECT name FROM cards ORDER BY faceConvertedManaCost DESC;"
        ],
        "amend_res": 1
    },
    "743": {
        "db_id": "superhero",
        "question": "What is the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code? Indicate how many of the said superheroes were published by Marvel Comics.",
        "ground_truth": "SELECT (CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM superhero)), CAST(SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS REAL) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T3.id = T1.alignment_id WHERE T3.alignment = 'Bad'",
        "amends": [
            "Do use explicit `CAST` to `REAL` for division instead of implicit integer division. Do join `publisher` table on `p1.publisher_id = p2.id` instead of directly accessing `publisher` column. Do join `alignment` table on `a.id = p1.alignment_id` instead of directly accessing `alignment` column. Do filter with `WHERE a.alignment = 'Bad'` instead of `CASE WHEN alignment = 'bad'`. Do calculate percentage as `(COUNT(*) * 100.0 / subquery_count)` instead of `(COUNT(CASE...) * 100.0 / COUNT(*))`. Do use `SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN alignment = 'bad' AND publisher = 'Marvel Comics' THEN 1 END)`. Do remove the incorrect `marvel_count` alias and instead include the Marvel count as a separate column in the result. The amended query now correctly handles the schema relationships and ensures accurate percentage calculations with proper type casting."
        ],
        "rules": [
            "1) When the question asks about superheroes with specific alignment: filter rows where \"alignment\".\"alignment\" = 'Bad' (exact case and spelling). 2) When calculating percentages: use explicit CAST to REAL for division to avoid integer division. 3) When joining tables for publisher information: join \"publisher\" table on \"p1\".\"publisher_id\" = \"p2\".\"id\" to access publisher data correctly. 4) When joining tables for alignment information: join \"alignment\" table on \"a\".\"id\" = \"p1\".\"alignment_id\" to access alignment data correctly. 5) When counting Marvel Comics superheroes: use SUM(CASE WHEN \"T2\".\"publisher_name\" = 'Marvel Comics' THEN 1 ELSE 0 END) to count occurrences. 6) When outputting results: include both the percentage calculation and Marvel count as separate columns in the result."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN alignment = 'bad' THEN 1 END) * 100.0 / COUNT(*)) AS percentage,\n    COUNT(CASE WHEN alignment = 'bad' AND publisher = 'Marvel Comics' THEN 1 END) AS marvel_count\nFROM superheroes;",
            "SELECT \n    (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM superhero)) AS percentage,\n    SUM(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS marvel_count\nFROM \n    superhero s\nJOIN \n    alignment a ON s.alignment_id = a.id\nJOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    a.alignment = 'Bad';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(CASE WHEN a.alignment = 'Bad' THEN 1 END) AS REAL) / CAST(COUNT(*) AS REAL)) * 100 AS percentage,\n    SUM(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS marvel_count\nFROM \n    superhero s\nJOIN \n    alignment a ON s.alignment_id = a.id\nLEFT JOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    a.alignment = 'Bad';",
            "SELECT \n    (CAST(COUNT(*) AS REAL) / (SELECT COUNT(*) FROM superhero) * 100) AS percentage,\n    SUM(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS marvel_count\nFROM \n    superhero s\nJOIN \n    alignment a ON s.alignment_id = a.id\nJOIN \n    publisher p ON s.publisher_id = p.id\nWHERE \n    a.alignment = 'Bad'"
        ],
        "amend_res": 1
    },
    "189": {
        "db_id": "financial",
        "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
        "ground_truth": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id INNER JOIN disp AS T4 ON T1.client_id = T4.client_id AND T4.account_id = T3.account_id  WHERE T1.gender = 'F' ORDER BY T1.birth_date ASC, T2.A11 ASC LIMIT 1",
        "amends": [
            "Do use `T3.account_id` instead of `account_number` as the SELECT column. Do join multiple tables including `client AS T1`, `district AS T2`, `account AS T3`, and `disp AS T4` instead of querying only the `clients` table. Do use `INNER JOIN` relationships with specific join conditions including `T1.district_id = T2.district_id`, `T2.district_id = T3.district_id`, and `T4.account_id = T3.account_id` with an additional client linkage `T1.client_id = T4.client_id` instead of no joins. Do filter by `T1.gender = 'F'` instead of `gender = 'female'`. Do order by `T1.birth_date ASC` and `T2.A11 ASC` instead of `age DESC` and `salary ASC`. The amended query now correctly retrieves account IDs from the proper table relationships with appropriate filtering and ordering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about account numbers: use \"T3.account_id\" as the output column instead of \"account_number\". 2) When combining multiple tables: link \"client AS T1\", \"district AS T2\", \"account AS T3\", and \"disp AS T4\" using inner matches where T1.district_id = T2.district_id, T2.district_id = T3.district_id, T4.account_id = T3.account_id, and T1.client_id = T4.client_id. 3) When filtering for female clients: use T1.gender = 'F' instead of 'female'. 4) When ordering by age: use T1.birth_date ASC (ascending order) instead of age DESC. 5) When ordering by salary: use T2.A11 ASC (ascending order) instead of salary ASC. 6) When selecting the oldest and lowest average salary clients: use ORDER BY T1.birth_date ASC, T2.A11 ASC with LIMIT 1 to get the single matching row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_number FROM clients WHERE gender = 'female' ORDER BY age DESC, salary ASC LIMIT 1;",
            "SELECT T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN account AS T3 ON T2.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T4.account_id = T3.account_id AND T1.client_id = T4.client_id\nWHERE T1.gender = 'F'\nORDER BY T1.birth_date ASC, T2.A11 ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.account_id\nFROM client AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN account AS T3 ON T2.district_id = T3.district_id\nINNER JOIN disp AS T4 ON T4.account_id = T3.account_id AND T1.client_id = T4.client_id\nWHERE T1.gender = 'F'\nORDER BY T1.birth_date ASC, T2.A11 ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "818": {
        "db_id": "superhero",
        "question": "Among the bad superheroes, what is the percentage of female superheroes?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Bad'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `superhero AS T1` with `alignment AS T2` on `T1.alignment_id = T2.id` instead of querying a single table. Do add a second join to `gender AS T3` on `T1.gender_id = T3.id` instead of accessing gender directly. Do reference `T3.gender` instead of just `gender` in the CASE expression. Do use `T1.id` for counting instead of `COUNT(*)` to avoid counting NULL values. Do cast the count to `REAL` instead of using `100.0` for proper floating-point division. Do filter on `T2.alignment = 'Bad'` (with capital B) instead of `alignment = 'bad'` (lowercase). Do structure the calculation as `CAST(...) * 100 / COUNT(...)` instead of using percentage multiplication. The amended query now correctly handles the normalized database schema with proper joins and accurate percentage calculation."
        ],
        "rules": [
            "1) When answering about \"percentage of female superheroes among bad superheroes\": make sure the output order: percentage_female. 2) When the question mentions \"bad superheroes\": \"bad\" actually means \"T2.alignment = 'Bad'\" in schema (note capital B). 3) When the question mentions \"female superheroes\": \"female\" actually means \"T3.gender = 'Female'\" in schema. 4) When combining T1 (superhero) and T2 (alignment) for shared entities: link rows where T1.alignment_id = T2.id and keep only matching pairs (inner match). 5) When combining T1 (superhero) and T3 (gender) for shared entities: link rows where T1.gender_id = T3.id and keep only matching pairs (inner match). 6) When counting superheroes: compute the number of rows using the canonical key token T1.id instead of counting all columns. 7) When calculating percentage: compute (count of rows where T3.gender = 'Female') divided by (count of all rows where T2.alignment = 'Bad'), cast to REAL and multiply by 100, guarding division by zero."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_female\nFROM superheroes\nWHERE alignment = 'bad';",
            "SELECT \n    CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id END) AS REAL) * 100 / COUNT(T1.id) AS percentage_female\nFROM \n    superhero AS T1\nJOIN \n    alignment AS T2 ON T1.alignment_id = T2.id\nJOIN \n    gender AS T3 ON T1.gender_id = T3.id\nWHERE \n    T2.alignment = 'Bad'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id END) AS REAL) * 100.0 / \n    NULLIF(COUNT(CASE WHEN T2.alignment = 'Bad' THEN T1.id END), 0) AS percentage_female\nFROM \n    superhero T1\n    INNER JOIN alignment T2 ON T1.alignment_id = T2.id\n    INNER JOIN gender T3 ON T1.gender_id = T3.id\nWHERE \n    T2.alignment = 'Bad'"
        ],
        "amend_res": 1
    },
    "23": {
        "db_id": "california_schools",
        "question": "List the names of schools with more than 30 difference in enrollements between K-12 and ages 5-17? Please also give the full street adress of the schools.",
        "ground_truth": "SELECT T1.School, T1.Street FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` > 30",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of no aliases. Do join with `frpm AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do select columns `T1.School` and `T1.Street` instead of `name` and `street_address`. Do perform the enrollment calculation on `T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)` instead of `k12_enrollment - age_5_17_enrollment`. The amended query now correctly joins the necessary tables and references the proper column names to match the intended logic."
        ],
        "rules": [
            "1) When answering about schools with enrollment differences: make sure the output order: T1.School, T1.Street 2) When the question mentions \"names of schools\": \"names\" actually means \"T1.School in schema\" 3) When the question mentions \"full street address\": \"full street address\" actually means \"T1.Street in schema\" 4) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match) 5) When calculating enrollment difference between K-12 and ages 5-17: compute T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\" instead of generic column names 6) When filtering for differences greater than 30: apply the condition (T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, street_address \nFROM schools \nWHERE (k12_enrollment - age_5_17_enrollment) > 30;",
            "SELECT T1.School, T1.Street\nFROM schools AS T1\nJOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE ABS(T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30;"
        ],
        "rule_sql": [
            "SELECT T1.School, T1.Street \nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE (T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30\nORDER BY T1.School, T1.Street"
        ],
        "amend_res": 1
    },
    "812": {
        "db_id": "superhero",
        "question": "List down at least five full names of superheroes with blue eyes.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue' LIMIT 5",
        "amends": [
            "Do reference `T1.superhero_name` from the `superhero` table instead of `name` from `superheroes`. Do join `superhero AS T1` with `colour AS T2` using `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying a single table. Do filter on `T2.colour = 'Blue'` instead of directly filtering `eye_color = 'blue'`. Do use proper case sensitivity with 'Blue' instead of 'blue'. The amended query now correctly joins tables to look up color values through a foreign key relationship and matches the RIGHT_SQL's behavior.",
            "Do select `T1.superhero_name` instead of `T1.full_name` to reference the correct column name that contains superhero names. The amended query now correctly retrieves superhero names with blue eyes instead of attempting to access a non-existent full_name column, matching the intended behavior of the RIGHT_SQL."
        ],
        "rules": [
            "1) When the question asks for \"full names of superheroes\": use the exact column token \"T1.superhero_name\" from the \"superhero\" table. 2) When the question mentions \"blue eyes\": join \"superhero AS T1\" with \"colour AS T2\" using an inner match where \"T1.eye_colour_id = T2.id\" and filter for \"T2.colour = 'Blue'\" exactly. 3) When the question asks for \"at least five\": return the first 5 rows that match the criteria. 4) When handling text literals: use exact case sensitivity with 'Blue' instead of 'blue'.",
            "1) When the question asks for \"full names of superheroes\": use the exact column token \"T1.superhero_name\" instead of \"T1.full_name\" as it contains the correct superhero names. 2) When filtering for superheroes with blue eyes: use the exact literal value 'Blue' for the colour comparison. 3) When limiting results to \"at least five\": use a limit of 5 rows to return exactly five superhero names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE eye_color = 'blue' LIMIT 5;",
            "SELECT T1.full_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'\nLIMIT 5;",
            "SELECT T1.superhero_name \nFROM superhero AS T1 \nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id \nWHERE T2.colour = 'Blue' \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Blue'\nLIMIT 5;"
        ],
        "amend_res": 1
    },
    "1390": {
        "db_id": "student_club",
        "question": "Based on the total cost for all event, what is the percentage of cost for Yearly Kickoff event?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) AS REAL) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "amends": [
            "Do use `SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END)` instead of simple column reference `cost` to properly aggregate filtered costs. Do add table joins with `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` and `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of querying only the `events` table to access related budget and expense data. Do use proper division logic with `* 100 / SUM(T3.cost)` instead of subquery division `(cost / (SELECT SUM(cost) FROM events))` to calculate the percentage against total expenses. Do add `CAST(... AS REAL)` instead of omitting explicit casting to ensure proper numeric precision in division. Do remove the `WHERE` clause filter and instead incorporate it into the `CASE` expression instead of filtering before aggregation. The amended query now correctly calculates the percentage of 'Yearly Kickoff' event costs against total expenses by properly joining related tables and using conditional aggregation."
        ],
        "rules": [
            "1) When calculating percentage of cost for a specific event: use conditional aggregation with SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) instead of simple column references. 2) When accessing cost data for events: join tables using INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event and INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget to properly relate events to their expenses. 3) When computing percentage calculations: use the formula * 100 / SUM(T3.cost) instead of subquery division to calculate against total expenses. 4) When ensuring numeric precision in division: use CAST(... AS REAL) to maintain proper numeric precision. 5) When filtering for specific events in aggregation: incorporate the filter condition T1.event_name = 'Yearly Kickoff' into a CASE expression instead of using a WHERE clause before aggregation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (cost / (SELECT SUM(cost) FROM events)) * 100 AS percentage FROM events WHERE event_name = 'Yearly Kickoff'",
            "SELECT \n    CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) * 100.0 / SUM(T3.cost) AS REAL) AS percentage_cost\nFROM \n    event AS T1\nINNER JOIN \n    budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN \n    expense AS T3 ON T2.budget_id = T3.link_to_budget;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) * 100.0 / SUM(T3.cost) AS REAL) AS percentage_cost\nFROM \n    event AS T1\nINNER JOIN \n    budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN \n    expense AS T3 ON T2.budget_id = T3.link_to_budget;"
        ],
        "amend_res": 1
    },
    "1236": {
        "db_id": "thrombosis_prediction",
        "question": "For all the female patient age 50 and above, who has abnormal red blood cell count. State if they were admitted to hospital.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0) AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `T1.ID` and `T1.Admission` instead of `p.gender`, `p.age`, `l.red_blood_cell_count`, and `a.admission_status`. Do join `Laboratory AS T2` instead of `lab_results l` and use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `p.patient_id = l.patient_id`. Do remove the `admissions` table join instead of keeping it. Do filter with `T1.SEX = 'F'` instead of `p.gender = 'Male'`, and use `(T2.RBC <= 3.5 OR T2.RBC >= 6.0)` instead of `l.red_blood_cell_count = 'normal'`. Do calculate age with `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50` instead of `p.age < 50`, and remove `ORDER BY p.age DESC` instead of keeping it. The amended query now correctly filters for female patients with abnormal RBC values who are at least 50 years old, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about female patients age 50 and above with abnormal red blood cell count: select distinct T1.ID and T1.Admission instead of gender, age, red_blood_cell_count, and admission_status. 2) When joining the Laboratory table: use T2 as the alias and perform an inner join on T1.ID = T2.ID instead of joining on patient_id. 3) When filtering for female patients: use T1.SEX = 'F' instead of filtering for males. 4) When filtering for abnormal red blood cell count: use (T2.RBC <= 3.5 OR T2.RBC >= 6.0) instead of checking for 'normal' values. 5) When calculating age: use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 instead of direct age comparison. 6) When the question asks about hospital admission status: use T1.Admission column directly instead of joining an admissions table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.gender, p.age, l.red_blood_cell_count, a.admission_status\nFROM patients p\nJOIN lab_results l ON p.patient_id = l.patient_id\nJOIN admissions a ON p.patient_id = a.patient_id\nWHERE p.gender = 'Male' AND p.age < 50 AND l.red_blood_cell_count = 'normal'\nORDER BY p.age DESC;",
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F' \nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50)\nAND (T2.RBC <= 3.5 OR T2.RBC >= 6.0)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.Admission\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) >= 50\nAND (T2.RBC <= 3.5 OR T2.RBC >= 6.0)"
        ],
        "amend_res": 1
    },
    "1401": {
        "db_id": "student_club",
        "question": "Indicate the cost of posters for 'September Speaker' event.",
        "ground_truth": "SELECT T3.cost FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'September Speaker' AND T3.expense_description = 'Posters'",
        "amends": [
            "Do select `T3.cost` from joined tables instead of `price` from a single table. Do use `INNER JOIN` with `event AS T1` instead of querying only the `posters` table. Do add `INNER JOIN` with `budget AS T2` on `T1.event_id = T2.link_to_event` instead of omitting this table relationship. Do add `INNER JOIN` with `expense AS T3` on `T2.budget_id = T3.link_to_budget` instead of not joining to the expense table. Do add filter `T3.expense_description = 'Posters'` instead of omitting this condition that specifically identifies poster expenses. The amended query now correctly retrieves cost data through proper table relationships and filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"cost of posters for 'September Speaker' event\": make sure the output order: T3.cost\n2) When the question mentions \"posters\": \"posters\" actually means \"T3.expense_description = 'Posters'\" in schema\n3) When the question mentions \"'September Speaker' event\": \"'September Speaker'\" actually means \"T1.event_name = 'September Speaker'\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match)\n5) When combining T2 and T3 for shared entities: link rows where T2.budget_id = T3.link_to_budget exactly as shown in the amends; keep only matching pairs (inner match)\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n7) When handling text literals: do not change case, spacing, or punctuation for 'September Speaker' or 'Posters'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT price FROM posters WHERE event_name = 'September Speaker';",
            "SELECT T3.cost \nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'September Speaker' \nAND T3.expense_description = 'Posters'"
        ],
        "rule_sql": [
            "SELECT T3.cost\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'September Speaker'\nAND T3.expense_description = 'Posters'"
        ],
        "amend_res": 1
    },
    "1455": {
        "db_id": "student_club",
        "question": "Which budget allowed the most money for water, chips, and cookies?",
        "ground_truth": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
        "amends": [
            "Do select `T2.budget_id` instead of `budget_name` and `MAX(water_budget + chips_budget + cookies_budget) AS total_snack_budget`. Do use `FROM expense AS T1 INNER JOIN budget AS T2` instead of `FROM budgets`. Do add join condition `ON T1.link_to_budget = T2.budget_id` instead of no join. Do add WHERE filter `T1.expense_description = 'Water, chips, cookies'` instead of no filter. Do remove GROUP BY and aggregate function instead of using MAX aggregation. Do order by `T1.cost DESC` instead of `total_snack_budget DESC`. The amended query now correctly retrieves the budget ID associated with the specific expense description rather than calculating maximum snack budgets.",
            "Do remove the MAX aggregate function and the calculated `total_snack_budget` column instead of including them in the SELECT list. Do simplify the SELECT clause to only include `T2.budget_id` instead of selecting both the budget_id and an aggregated value. The amended query now correctly returns just the budget_id for the highest cost expense matching the description, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about budgets and expenses: combine tables expense as T1 and budget as T2 using inner match where T1.link_to_budget = T2.budget_id. 2) When the question mentions \"water, chips, and cookies\": filter for T1.expense_description = 'Water, chips, cookies' exactly. 3) When the question asks for \"which budget allowed the most money\": order results by T1.cost in descending order and take the first row. 4) When producing output: return T2.budget_id instead of budget_name.",
            "1) When the question asks for \"which budget allowed the most money for water, chips, and cookies\": select only the budget_id column from the budget table (T2). 2) When calculating the total cost for water, chips, and cookies: sum the individual budget amounts (water_budget + chips_budget + cookies_budget) rather than using MAX aggregate function. 3) When filtering for expenses related to water, chips, and cookies: use the exact literal 'Water, chips, cookies' for the expense_description condition. 4) When joining expense and budget tables: link rows where T1.link_to_budget equals T2.budget_id using an inner join. 5) When determining the highest cost: order the results by the total calculated sum in descending order and return only the top result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT budget_name, MAX(water_budget + chips_budget + cookies_budget) AS total_snack_budget FROM budgets ORDER BY total_snack_budget DESC LIMIT 1;",
            "SELECT T2.budget_id, MAX(water_budget + chips_budget + cookies_budget) AS total_snack_budget\nFROM expense AS T1 \nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nWHERE T1.expense_description = 'Water, chips, cookies'\nORDER BY T1.cost DESC\nLIMIT 1;",
            "SELECT T2.budget_id \nFROM expense AS T1 \nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id \nWHERE T1.expense_description = 'Water, chips, cookies' \nORDER BY T1.cost DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.budget_id\nFROM expense AS T1\nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\nWHERE T1.expense_description = 'Water, chips, cookies'\nORDER BY T1.cost DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "197": {
        "db_id": "toxicology",
        "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
        "ground_truth": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
        "amends": [
            "Do calculate the average of `oxygen_count` instead of `oxygen_atoms`. Do use a subquery to first count oxygen atoms per molecule instead of directly averaging from the molecules table. Do join `atom` and `bond` tables with `INNER JOIN` on `molecule_id` instead of querying only the molecules table. Do filter bonds with `bond_type = '-'` instead of `bond_type = 'single'`. Do filter atoms with `element = 'o'` instead of no element filtering. Do group by `molecule_id` to count oxygen atoms per molecule instead of no grouping. The amended query now correctly calculates the average number of oxygen atoms in molecules with single bonds by joining the necessary tables and properly aggregating the counts."
        ],
        "rules": [
            "1) When the question asks for oxygen atoms: filter atoms where \"element\" equals 'o' exactly. 2) When the question mentions single-bonded molecules: filter bonds where \"bond_type\" equals '-' exactly. 3) When calculating oxygen atoms per molecule: group by \"molecule_id\" to count oxygen atoms for each molecule. 4) When combining atom and bond tables: link rows where \"molecule_id\" values match exactly between both tables (inner match). 5) When calculating the average number of oxygen atoms: compute the average of the oxygen count per molecule after proper grouping and filtering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(oxygen_atoms) FROM molecules WHERE bond_type = 'single';",
            "SELECT AVG(oxygen_count) AS average_oxygen_atoms\nFROM (\n    SELECT a.molecule_id, COUNT(*) AS oxygen_count\n    FROM atom a\n    INNER JOIN bond b ON a.molecule_id = b.molecule_id\n    WHERE a.element = 'o' AND b.bond_type = '-'\n    GROUP BY a.molecule_id\n) AS oxygen_counts"
        ],
        "rule_sql": [
            "SELECT AVG(oxygen_count) AS avg_oxygen_atoms\nFROM (\n    SELECT a.molecule_id, COUNT(*) AS oxygen_count\n    FROM atom a\n    INNER JOIN molecule m ON a.molecule_id = m.molecule_id\n    INNER JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\n    INNER JOIN bond b ON c.bond_id = b.bond_id\n    WHERE a.element = 'o'\n    AND b.bond_type = '-'\n    GROUP BY a.molecule_id\n) AS oxygen_counts",
            "SELECT AVG(oxygen_count) AS avg_oxygen_atoms\nFROM (\n    SELECT a.molecule_id, COUNT(*) AS oxygen_count\n    FROM atom a\n    INNER JOIN bond b ON a.molecule_id = b.molecule_id\n    WHERE a.element = 'o'\n    AND b.bond_type = '-'\n    GROUP BY a.molecule_id\n) AS oxygen_counts"
        ],
        "amend_res": 1
    },
    "112": {
        "db_id": "financial",
        "question": "For the female client who was born in 1976/1/29, which district did she opened her account?",
        "ground_truth": "SELECT T1.A2 FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.birth_date = '1976-01-29' AND T2.gender = 'F'",
        "amends": [
            "Do select `T1.A2` from the `district` table instead of `district_id` from the `accounts` table. Do join `client AS T2` with `district AS T1` using `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do filter on `T2.birth_date = '1976-01-29'` with ISO date format instead of `'1976/1/29'`. Do filter on `T2.gender = 'F'` with single character instead of `'female'`. The amended query now correctly retrieves district information by joining with client data and using proper date format and gender codes."
        ],
        "rules": [
            "1) When the question asks about district information for a client: join the client table (T2) with the district table (T1) using T1.district_id = T2.district_id to link client and district data. 2) When filtering by gender: use T2.gender = 'F' with the exact single character 'F' instead of 'female'. 3) When filtering by birth date: use T2.birth_date = '1976-01-29' with ISO date format instead of '1976/1/29'. 4) When selecting district information: output T1.A2 from the district table instead of district_id from the accounts table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_id FROM accounts WHERE gender = 'female' AND birth_date = '1976/1/29'",
            "SELECT T1.A2 \nFROM district AS T1\nJOIN client AS T2 ON T1.district_id = T2.district_id\nWHERE T2.birth_date = '1976-01-29' \nAND T2.gender = 'F'"
        ],
        "rule_sql": [
            "SELECT d.A2 \nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE c.gender = 'F' AND c.birth_date = '1976-01-29'"
        ],
        "amend_res": 1
    },
    "326": {
        "db_id": "toxicology",
        "question": "Which molecule consisted of Sulphur atom with double bond?",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
        "amends": [
            "Do select `DISTINCT T1.molecule_id` instead of `*` from all columns. Do use tables `atom AS T1` and `bond AS T2` instead of `molecules` alone. Do perform `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying a single table. Do filter with `T1.element = 's'` instead of `atoms LIKE '%S%'` for exact element matching. Do filter with `T2.bond_type = '='` instead of `bonds = 'double'` using proper bond type syntax. The amended query now correctly joins atom and bond tables to find molecules containing sulfur atoms with double bonds, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about molecules with specific atoms and bonds: use tables \"atom AS T1\" and \"bond AS T2\" instead of a single molecules table. 2) When combining atom and bond information for the same molecule: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 3) When the question mentions \"Sulphur atom\": use exact element matching with T1.element = 's' instead of pattern matching. 4) When the question mentions \"double bond\": use proper bond type syntax with T2.bond_type = '=' instead of text 'double'. 5) When selecting output for molecule identification: return DISTINCT T1.molecule_id instead of all columns to avoid duplicate molecule entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE atoms LIKE '%S%' AND bonds = 'double';",
            "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.molecule_id FROM atom AS T1 JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='"
        ],
        "amend_res": 1
    },
    "29": {
        "db_id": "california_schools",
        "question": "When did the first-through-twelfth-grade school with the largest enrollment open?",
        "ground_truth": "SELECT T2.OpenDate FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
        "amends": [
            "Do select `T2.OpenDate` instead of `MIN(open_date)` and change the source to `frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode` instead of querying only `schools` with a subquery. Do remove the `WHERE enrollment = (SELECT MAX(enrollment)...` subquery condition and instead use `ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1` to get the maximum enrollment record directly. Do add the join condition `ON T1.CDSCode = T2.CDSCode` to properly relate the tables instead of the incorrect subquery approach. The amended query now correctly retrieves the OpenDate from the school with maximum K-12 enrollment by joining the appropriate tables and using ORDER BY with LIMIT instead of a flawed subquery comparison."
        ],
        "rules": [
            "1) When answering about \"first-through-twelfth-grade school with the largest enrollment\": use tables \"frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\" instead of querying only schools. 2) When the question asks for the opening date of the school with largest enrollment: select \"T2.OpenDate\" instead of MIN(open_date). 3) When finding the school with maximum enrollment: use \"ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1\" instead of a subquery comparison with MAX(enrollment). 4) When combining frpm and schools tables: link rows where \"T1.CDSCode = T2.CDSCode\" exactly and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(open_date) FROM schools WHERE enrollment = (SELECT MAX(enrollment) FROM schools WHERE grade_level BETWEEN 1 AND 12);",
            "SELECT T2.OpenDate \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nORDER BY T1.\"Enrollment (K-12)\" DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.OpenDate \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nORDER BY T1.`Enrollment (K-12)` DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "708": {
        "db_id": "codebase_community",
        "question": "List the creation date and age of the user that commented with webiste.",
        "ground_truth": "SELECT T2.CreationDate, T2.Age FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.text LIKE '%http://%'",
        "amends": [
            "Do select `T2.CreationDate` and `T2.Age` instead of `creation_date` and `age`. Do join `comments AS T1` with `users AS T2` on `T1.UserId = T2.Id` instead of querying only the `users` table. Do filter on `T1.text LIKE '%http://%'` instead of `comment LIKE '%webiste%'` to correctly search for URL patterns in comment text rather than website mentions in user comments. The amended query now properly joins the comments and users tables to find users who posted comments containing HTTP links, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"creation date and age of the user that commented with website\": make sure the output order: T2.CreationDate, T2.Age 2) When the question mentions \"commented with website\": \"website\" actually means \"text containing HTTP links in comments\" in schema, specifically filter on T1.text LIKE '%http://%' 3) When combining comments and users tables: link rows where T1.UserId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match) 4) When selecting columns: use T2.CreationDate and T2.Age instead of creation_date and age"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT creation_date, age FROM users WHERE comment LIKE '%webiste%'",
            "SELECT T2.CreationDate, T2.Age\nFROM comments AS T1\nJOIN users AS T2 ON T1.UserId = T2.Id\nWHERE T1.Text LIKE '%http://%'"
        ],
        "rule_sql": [
            "SELECT T2.CreationDate, T2.Age\nFROM comments T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T1.Text LIKE '%http://%'"
        ],
        "amend_res": 1
    },
    "794": {
        "db_id": "superhero",
        "question": "Which hero was the fastest?",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Speed' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do select `T1.superhero_name` from the `superhero` table instead of `hero_name` from an unspecified source. Do add `INNER JOIN` operations on `hero_attribute` with predicate `T1.id = T2.hero_id` and on `attribute` with predicate `T2.attribute_id = T3.id` instead of omitting these table joins entirely. Do add a WHERE filter `T3.attribute_name = 'Speed'` to specifically target speed attributes instead of querying without any filtering. Do order by `T2.attribute_value DESC` to sort by the actual attribute value instead of an unspecified `speed` column. The amended query now correctly joins the necessary tables to identify speed attributes and retrieves the superhero with the highest speed value, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which hero was the fastest\": make sure the output order: T1.superhero_name. 2) When the question mentions \"hero\": \"hero\" actually means \"superhero_name in schema\". 3) When combining T1 (superhero) and T2 (hero_attribute) for shared entities: link rows where T1.id = T2.hero_id and keep only matching pairs (inner match). 4) When combining T2 (hero_attribute) and T3 (attribute) for shared entities: link rows where T2.attribute_id = T3.id and keep only matching pairs (inner match). 5) When the question asks for \"fastest\" or \"highest speed\": add a WHERE filter T3.attribute_name = 'Speed' to specifically target speed attributes. 6) When the question asks for \"fastest\" or \"highest speed\": rank rows by T2.attribute_value in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_name FROM heroes ORDER BY speed DESC LIMIT 1;",
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Speed'\nORDER BY T2.attribute_value DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN hero_attribute T2 ON T1.id = T2.hero_id\nINNER JOIN attribute T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Speed'\nORDER BY T2.attribute_value DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "428": {
        "db_id": "card_games",
        "question": "What is the name of set number 5 and its translation?",
        "ground_truth": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
        "amends": [
            "Do add table `set_translations AS T2` and use `INNER JOIN` on `T1.code = T2.setCode` instead of querying only the `sets` table. Do change the column selection to `T1.name, T2.translation` instead of `name, translation` without table prefixes. Do move the filter condition to `T2.id = 5` instead of `id = 5` and add `GROUP BY T1.name, T2.translation` instead of omitting grouping. The amended query now correctly joins the translation data and filters by the translation ID rather than the set ID, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"set number 5 and its translation\": make sure the output order: T1.name, T2.translation. 2) When the question mentions \"set number 5\": \"set number 5\" actually means \"T2.id = 5\" in schema. 3) When combining T1 (sets) and T2 (set_translations) for shared entities: link rows where T1.code = T2.setCode exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"name of set\" and \"translation\": use T1.name for the set name and T2.translation for the translation. 5) When grouping results: organize results by T1.name and T2.translation to ensure proper aggregation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, translation FROM sets WHERE id = 5;",
            "SELECT T1.name, T2.translation\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode\nWHERE T2.id = 5\nGROUP BY T1.name, T2.translation"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.translation\nFROM sets T1\nINNER JOIN set_translations T2 ON T1.code = T2.setCode\nWHERE T2.id = 5\nGROUP BY T1.name, T2.translation"
        ],
        "amend_res": 1
    },
    "168": {
        "db_id": "financial",
        "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
        "ground_truth": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
        "amends": [
            "Do use `SUM(T2.gender = 'F')` with explicit `CAST` to `REAL` instead of `COUNT(CASE WHEN c.gender = 'F' THEN 1 END)` for percentage calculation. Do reference `T1.A11` instead of `d.average_salary` in the WHERE filter. Do remove the `c.account_opened_date IS NOT NULL` condition instead of keeping it. Do use `INNER JOIN` with explicit alias `T2` instead of `JOIN` with alias `c`. Do reference `COUNT(T2.client_id)` instead of `COUNT(*)` for the denominator. Do remove the column alias `percentage_women` instead of including it. The amended query now correctly calculates the percentage of female clients in districts with A11 values exceeding 10000 without unnecessary filters.",
            "Do join `district AS T1` directly to `client AS T2` on `T1.district_id = T2.district_id` instead of joining through `disp` and `account` tables. Do remove the unnecessary `INNER JOIN disp` and `INNER JOIN account` clauses instead of including them. Do place the division operation after the multiplication with `* 100` instead of wrapping the entire expression in parentheses. Do use the correct join condition `T1.district_id = T2.district_id` instead of the incorrect chain of joins through intermediary tables. The amended query now correctly calculates the percentage of female clients in districts with A11 > 10000 by directly relating clients to their districts."
        ],
        "rules": [
            "1) When calculating percentage of female clients: use SUM(T2.gender = 'F') with explicit CAST to REAL instead of COUNT(CASE WHEN c.gender = 'F' THEN 1 END). 2) When filtering by average salary: reference T1.A11 instead of d.average_salary and use the condition T1.A11 > 10000. 3) When joining tables: use INNER JOIN with explicit alias T2 for the client table instead of JOIN with alias c. 4) When calculating the denominator for percentage: use COUNT(T2.client_id) instead of COUNT(*). 5) When the question asks about clients who opened accounts: do not include the account_opened_date IS NOT NULL condition. 6) When producing output: do not include column aliases like percentage_women.",
            "1) When joining district and client tables: link rows where T1.district_id equals T2.district_id exactly as T1.district_id = T2.district_id and keep only matching pairs (inner match). 2) When filtering districts by average salary: include only rows where T1.A11 is greater than 10000. 3) When calculating percentage of female clients: compute (number of rows where T2.gender equals 'F') divided by (total number of rows) multiplied by 100. 4) When counting clients: use T2.client_id as the counting key for both numerator and denominator. 5) When handling text literals: preserve the exact value 'F' for gender comparison without changing case."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN c.gender = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_women\nFROM client c\nJOIN district d ON c.district_id = d.district_id\nWHERE d.average_salary > 10000\nAND c.account_opened_date IS NOT NULL",
            "SELECT (CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id)) * 100\nFROM client T2\nINNER JOIN disp ON T2.client_id = disp.client_id\nINNER JOIN account ON disp.account_id = account.account_id\nINNER JOIN district T1 ON account.district_id = T1.district_id\nWHERE T1.A11 > 10000",
            "SELECT (CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id)) * 100\nFROM district AS T1\nINNER JOIN client AS T2 ON T1.district_id = T2.district_id\nWHERE T1.A11 > 10000;"
        ],
        "rule_sql": [
            "SELECT (CAST(SUM(T2.gender = 'F') AS REAL) / COUNT(T2.client_id)) * 100\nFROM district T1\nINNER JOIN client T2 ON T1.district_id = T2.district_id\nWHERE T1.A11 > 10000"
        ],
        "amend_res": 1
    },
    "839": {
        "db_id": "superhero",
        "question": "In superheroes with weight less than 100, list the full name of the superheroes with brown eyes.",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'",
        "amends": [
            "Do reference `T1.full_name` with table alias instead of `full_name` without qualification. Do join `superhero AS T1` to `colour AS T2` on `T1.eye_colour_id = T2.id` instead of querying `superheroes` table alone. Do filter on `T1.weight_kg < 100` with the correct column name instead of `weight < 100`. Do filter on `T2.colour = 'Brown'` through the joined colour table instead of directly on `eye_color = 'brown'`. The amended query now correctly joins to resolve eye color through a reference table and uses proper column names with table aliases."
        ],
        "rules": [
            "1) When answering about superheroes with weight less than 100 and brown eyes: use table alias T1 for superhero table and T2 for colour table. 2) When joining superhero and colour tables: link rows where T1.eye_colour_id = T2.id and keep only matching pairs (inner match). 3) When filtering by weight: use T1.weight_kg < 100 instead of weight < 100. 4) When filtering by eye color: use T2.colour = 'Brown' instead of eye_color = 'brown'. 5) When selecting output: use T1.full_name as the output column with proper table qualification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT full_name FROM superheroes WHERE weight < 100 AND eye_color = 'brown';",
            "SELECT T1.full_name\nFROM superhero AS T1\nJOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T1.weight_kg < 100\nAND T2.colour = 'Brown'"
        ],
        "rule_sql": [
            "SELECT T1.full_name FROM superhero T1 INNER JOIN colour T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'"
        ],
        "amend_res": 1
    },
    "883": {
        "db_id": "formula_1",
        "question": "How many races were there in 2005? Name all the races in descending order.",
        "evidence": "",
        "ground_truth": "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC",
        "amends": [
            "Do select only `name` instead of `COUNT(*) as race_count, race_name` to return individual race names rather than an aggregate count. Do remove the `COUNT(*)` aggregation and `race_count` alias instead of including them since no grouping is needed. Do use column `name` instead of `race_name` as the correct column name for race identification. Do change sort direction to `DESC` instead of `ASC` to order results in descending alphabetical order. Do remove the unnecessary aggregation entirely instead of performing a count when individual records are required. The amended query now correctly returns race names from 2005 in descending order rather than attempting to count them."
        ],
        "rules": [
            "1) When the question asks for \"how many races\" but also requires naming all races: do not perform aggregation and counting, instead return individual race names. 2) When the question asks to \"name all the races\": use the exact column \"name\" from table \"races\" instead of any other column name. 3) When the question specifies \"in 2005\": filter rows where the year equals 2005. 4) When the question requires \"descending order\": sort the results by the \"name\" column in descending alphabetical order instead of ascending order. 5) When the question asks for both count and names but the schema only has name information: return only the individual race names without attempting to count them."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as race_count, race_name FROM races WHERE year = 2005 ORDER BY race_name ASC;",
            "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;"
        ],
        "rule_sql": [
            "SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;"
        ],
        "amend_res": 1
    },
    "949": {
        "db_id": "formula_1",
        "question": "Which constructor has the highest point?",
        "evidence": "",
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1",
        "amends": [
            "Do select `T2.name` instead of `constructor, MAX(points)` to retrieve the constructor name rather than aggregated points. Do join `constructorStandings AS T1` with `constructors AS T2` on `T1.constructorId = T2.constructorId` instead of querying only the `constructors` table to properly relate standings data with constructor details. Do order by `T1.points DESC` instead of `points DESC` to reference the correct table's points column from the joined standings table. The amended query now correctly identifies the constructor with the highest points by joining the standings and constructors tables and returns the constructor name rather than aggregated data."
        ],
        "rules": [
            "1) When answering about \"which constructor has the highest point\": make sure the output order: T2.name. 2) When the question mentions \"constructor\": \"constructor\" actually means \"T2.name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.constructorId = T2.constructorId exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question mentions \"highest\" point: rank rows by T1.points in descending order and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT constructor, MAX(points) FROM constructors ORDER BY points DESC LIMIT 1;",
            "SELECT T2.name \nFROM constructorStandings AS T1 \nJOIN constructors AS T2 ON T1.constructorId = T2.constructorId \nORDER BY T1.points DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.name FROM constructorStandings T1 JOIN constructors T2 ON T1.constructorId = T2.constructorId ORDER BY T1.points DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "313": {
        "db_id": "toxicology",
        "question": "How many atoms belong to molecule id TR001?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR001'",
        "amends": [
            "Do use the fully qualified column reference `COUNT(T.atom_id)` instead of `COUNT(*)` to count specific non-null values. Do specify the table alias `T` in the column reference instead of omitting it for clarity. Do use the table alias `AS T` in the FROM clause instead of referencing the table directly without an alias. Do reference the table as `atom` instead of `atoms` to match the correct table name. The amended query now correctly counts non-null atom_id values from the atom table with proper table qualification."
        ],
        "rules": [
            "1) When counting atoms: use COUNT(T.atom_id) instead of COUNT(*) to count specific non-null values. 2) When referencing the atom table: use the exact table name \"atom\" instead of \"atoms\". 3) When using table aliases: always specify the alias \"AS T\" in the FROM clause and use \"T\" to qualify column references. 4) When counting entities: use the canonical key \"atom_id\" for counting atoms rather than a generic count of all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE molecule_id = 'TR001';",
            "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR001'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.atom_id) FROM atom AS T WHERE T.molecule_id = 'TR001'"
        ],
        "amend_res": 1
    },
    "78": {
        "db_id": "california_schools",
        "question": "What is the most common type of grade span served in the city of Adelanto?",
        "evidence": "",
        "ground_truth": "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1",
        "amends": [
            "Do select `GSserved` instead of `grade_span` and do not alias the count. Do group by `GSserved` instead of `grade_span`. Do order by `COUNT(GSserved)` instead of the aliased `count`. Do use `City` instead of `city` in the WHERE filter. The amended query now correctly identifies the most common grade span served in Adelanto by counting occurrences of GSserved rather than using a different column name.",
            "Do remove `COUNT(GSserved)` from the SELECT list instead of including it, as the aggregate function is only needed for ordering purposes. Do keep the `GROUP BY GSserved` clause to group by the GSserved column instead of omitting it. Do maintain the `ORDER BY COUNT(GSserved) DESC` clause to order by the count of GSserved values instead of changing it. Do preserve the `LIMIT 1` clause to return only the top result instead of modifying it. The amended query now correctly returns only the GSserved value with the highest count for Adelanto city schools while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"grade span served\": use the exact column token \"GSserved\" instead of \"grade_span\". 2) When counting occurrences of grade span served: use COUNT(\"GSserved\") without aliasing the count result. 3) When grouping by grade span served: group by the exact column \"GSserved\". 4) When ordering by count results: order by COUNT(\"GSserved\") directly rather than using an alias. 5) When filtering for the city of Adelanto: use the exact column token \"City\" and the exact literal value 'Adelanto'.",
            "1) When answering about \"most common type of grade span served in the city of Adelanto\": make sure the output order: GSserved only (without count aggregates). 2) When the question asks for \"most common\" type: rank rows by count of GSserved in descending order and keep the first 1 row. 3) When the question mentions \"city of Adelanto\": \"Adelanto\" actually means City = 'Adelanto' in schema. 4) When the question asks for \"type of grade span served\": use the exact column token GSserved for grouping and selection."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT grade_span, COUNT(*) as count FROM schools WHERE city = 'Adelanto' GROUP BY grade_span ORDER BY count DESC LIMIT 1;",
            "SELECT GSserved, COUNT(GSserved) FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1;",
            "SELECT GSserved\nFROM schools\nWHERE City = 'Adelanto'\nGROUP BY GSserved\nORDER BY COUNT(GSserved) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "269": {
        "db_id": "toxicology",
        "question": "How many bond id have element iodine?",
        "ground_truth": "SELECT COUNT(T3.bond_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'i'",
        "amends": [
            "Do add tables `atom AS T1`, `molecule AS T2`, and `bond AS T3` with proper joins instead of querying only the `bonds` table. Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` and `T2.molecule_id = T3.molecule_id` instead of no joins. Do change the filter to `T1.element = 'i'` instead of `element = 'iodine'` to match the correct element symbol. Do count `T3.bond_id` instead of `COUNT(*)` to specifically count bonds. The amended query now correctly counts iodine bonds by properly joining through the molecule-atom relationship structure."
        ],
        "rules": [
            "1) When answering about \"bond id have element iodine\": make sure the output order: count of bond_id. 2) When the question mentions \"element iodine\": \"iodine\" actually means \"i\" in schema. 3) When combining tables atom AS T1, molecule AS T2, and bond AS T3: link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match). 4) When counting bonds: compute the number of rows using the canonical key token T3.bond_id. 5) When filtering for element: use T1.element = 'i' exactly as specified in the schema."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM bonds WHERE element = 'iodine';",
            "SELECT COUNT(T3.bond_id) \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id \nWHERE T1.element = 'i'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT b.bond_id) \nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE a.element = 'i'",
            "SELECT COUNT(DISTINCT T3.bond_id) \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id \nWHERE T1.element = 'i'"
        ],
        "amend_res": 1
    },
    "15": {
        "db_id": "california_schools",
        "question": "Which active district has the highest average score in Reading?",
        "evidence": "",
        "ground_truth": "SELECT T1.District FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1",
        "amends": [
            "Do select `District` and `AvgScrRead` instead of `district_name` and `AVG(math_score)` with incorrect alias `avg_reading_score`. Do use `INNER JOIN` between `schools` and `satscores` on `CDSCode=cds` instead of querying only `districts` table. Do filter on `StatusType='Active'` instead of `status='active'`. Do remove the `GROUP BY` clause and aggregate function instead of grouping by district name. Do order by `AvgScrRead DESC` instead of the incorrectly aliased `avg_reading_score`. The amended query now correctly retrieves the top district by reading score from joined school and SAT score data instead of attempting to aggregate math scores from a single table.",
            "Do select only `District` instead of including both `District` and `AvgScrRead` in the SELECT list. Do use table aliases `T1` and `T2` instead of `s` and `ss` for the schools and satscores tables respectively. Do maintain the `INNER JOIN` on `T1.CDSCode = T2.cds` instead of changing the join condition. Do keep the `WHERE` filter on `T1.StatusType = 'Active'` unchanged. Do preserve the `ORDER BY T2.AvgScrRead DESC` and `LIMIT 1` clauses without modification. The amended query now correctly returns only the district with the highest average reading score among active schools, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"active district has the highest average score in Reading\": make sure the output order: District, AvgScrRead\n2) When the question mentions \"active\": \"active\" actually means \"StatusType='Active' in schema\"\n3) When combining schools and satscores for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (schools.CDSCode = satscores.cds); keep only matching pairs (inner match)\n4) When the question mentions \"highest average score in Reading\": rank rows by AvgScrRead in descending direction and keep the first 1 row\n5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n6) When handling text literals: do not change case, spacing, or punctuation of 'Active'",
            "1) When answering about \"which active district has the highest average score in Reading\": make sure the output order includes only \"District\" column. 2) When the question mentions \"active district\": filter rows where T1.StatusType equals exactly 'Active'. 3) When the question mentions \"highest average score in Reading\": rank rows by T2.AvgScrRead in descending order and keep only the first 1 row. 4) When combining schools and satscores tables: link rows where T1.CDSCode equals T2.cds exactly and keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for any column or table names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_name, AVG(math_score) as avg_reading_score FROM districts WHERE status = 'active' GROUP BY district_name ORDER BY avg_reading_score DESC LIMIT 1;",
            "SELECT s.District, ss.AvgScrRead \nFROM schools s\nINNER JOIN satscores ss ON s.CDSCode = ss.cds\nWHERE s.StatusType = 'Active'\nORDER BY ss.AvgScrRead DESC\nLIMIT 1;",
            "SELECT T1.District\nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE T1.StatusType = 'Active'\nORDER BY T2.AvgScrRead DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT s.District\nFROM schools s\nINNER JOIN satscores sat ON s.CDSCode = sat.cds\nWHERE s.StatusType = 'Active'\nORDER BY sat.AvgScrRead DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1465": {
        "db_id": "student_club",
        "question": "Which budget category does the expense 'Posters' fall to?",
        "ground_truth": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
        "amends": [
            "Do use `DISTINCT T2.category` instead of just `category` to eliminate duplicate category values. Do join `expense AS T1` with `budget AS T2` using `INNER JOIN` on `T1.link_to_budget = T2.budget_id` instead of querying only the `expenses` table. Do filter on `T1.expense_description = 'Posters'` instead of `expense_name = 'Posters'` to use the correct column name. The amended query now correctly retrieves distinct categories from the joined budget table based on expense descriptions, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about budget category for an expense: join table \"expense\" as T1 with table \"budget\" as T2 using inner join where T1.link_to_budget = T2.budget_id. 2) When filtering for expense 'Posters': use T1.expense_description = 'Posters' exactly as written. 3) When selecting the category: use DISTINCT T2.category to eliminate duplicate category values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT category FROM expenses WHERE expense_name = 'Posters';",
            "SELECT DISTINCT T2.category \nFROM expense AS T1 \nINNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id \nWHERE T1.expense_description = 'Posters'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters';"
        ],
        "amend_res": 1
    },
    "1056": {
        "db_id": "european_football_2",
        "question": "What is the name of the football league in the country of Netherlands?",
        "ground_truth": "SELECT t2.name FROM Country AS t1 INNER JOIN League AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Netherlands'",
        "amends": [
            "Do select `t2.name` from the `League` table instead of `name` from the `leagues` table. Do join `Country AS t1` with `League AS t2` using `INNER JOIN` on `t1.id = t2.country_id` instead of querying only the `leagues` table. Do filter on `t1.name = 'Netherlands'` instead of `country = 'Netherlands'` to properly reference the country name from the joined Country table. The amended query now correctly joins the Country and League tables to find leagues associated with the Netherlands country name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about football leagues in a specific country: join Country table as T1 with League table as T2 using inner join on T1.id = T2.country_id. 2) When the question mentions \"Netherlands\": use T1.name = 'Netherlands' as the filter condition. 3) When selecting the league name: output T2.name from the League table. 4) When combining Country and League tables: keep only matching pairs where T1.id equals T2.country_id (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM leagues WHERE country = 'Netherlands';",
            "SELECT t2.name \nFROM Country AS t1 \nINNER JOIN League AS t2 ON t1.id = t2.country_id \nWHERE t1.name = 'Netherlands'"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM Country AS T1 \nINNER JOIN League AS T2 ON T1.id = T2.country_id \nWHERE T1.name = 'Netherlands'"
        ],
        "amend_res": 1
    },
    "990": {
        "db_id": "formula_1",
        "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
        "ground_truth": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do select `T3.constructorRef` and `T3.url` instead of `constructor_name` and `website`. Do join `results AS T1` and `races AS T2` with `INNER JOIN` on `T1.raceId = T2.raceId` instead of no joins. Do add `INNER JOIN constructors AS T3` on `T1.constructorId = T3.constructorId` instead of querying constructors directly. Do filter on `T2.name = 'Singapore Grand Prix'` and `T2.year = 2009` instead of `race_name = '2009 Singapore Grand Prix'`. Do add `T1.time LIKE '_:%:__.___'` filter instead of omitting it. The amended query now correctly retrieves constructor information from race results with proper joins and filtering conditions."
        ],
        "rules": [
            "1) When answering about constructor reference name and website of a champion: select T3.constructorRef and T3.url as output columns. 2) When combining race results and race information: link T1 (results) and T2 (races) where T1.raceId = T2.raceId and keep only matching pairs. 3) When combining results with constructor information: link T1 (results) and T3 (constructors) where T1.constructorId = T3.constructorId and keep only matching pairs. 4) When filtering for the 2009 Singapore Grand Prix: apply both T2.name = 'Singapore Grand Prix' and T2.year = 2009 conditions. 5) When identifying the champion in a race: filter for results where T1.time LIKE '_:%:__.___' to find the winning entry."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT constructor_name, website FROM constructors WHERE race_name = '2009 Singapore Grand Prix';",
            "SELECT T3.constructorRef, T3.url\nFROM results AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nINNER JOIN constructors AS T3 ON T1.constructorId = T3.constructorId\nWHERE T2.name = 'Singapore Grand Prix' \nAND T2.year = 2009\nAND T1.time LIKE '_:%:__.___'\nAND T1.position = 1;"
        ],
        "rule_sql": [
            "SELECT T3.constructorRef, T3.url\nFROM results T1\nJOIN races T2 ON T1.raceId = T2.raceId\nJOIN constructors T3 ON T1.constructorId = T3.constructorId\nWHERE T2.name = 'Singapore Grand Prix'\nAND T2.year = 2009\nAND T1.time LIKE '_:%:__.___'"
        ],
        "amend_res": 1
    },
    "901": {
        "db_id": "formula_1",
        "question": "Name the races along with its circuit name and location for f1 races hosted in September 2005.",
        "ground_truth": "SELECT DISTINCT T2.name, T1.name, T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do use table aliases `T1` and `T2` instead of `c` and `r` for better clarity. Do reference `T2.name` and `T1.name` instead of `r.name` and `c.name` to match the aliased table structure. Do use `INNER JOIN` with explicit join type instead of just `JOIN` for consistency. Do join on `T2.circuitID = T1.circuitId` instead of `r.circuit_id = c.circuit_id` to match the actual column names. Do add filter `T2.year = 2005` instead of relying solely on date parsing. Do use `STRFTIME('%m', T2.date) = '09'` instead of `r.date LIKE '2005-09%'` for proper month extraction from date values. The amended query now correctly identifies September 2005 races with proper date handling and eliminates duplicates."
        ],
        "rules": [
            "1) When eliminating duplicate rows: use DISTINCT to ensure each result row is unique. 2) When assigning table aliases: use T1 for circuits table and T2 for races table. 3) When selecting race names: use T2.name to get the race name from the races table. 4) When selecting circuit names: use T1.name to get the circuit name from the circuits table. 5) When selecting circuit locations: use T1.location to get the location from the circuits table. 6) When joining races and circuits tables: use INNER JOIN to combine only matching rows. 7) When specifying join condition: use T2.circuitID = T1.circuitId to match the exact column names. 8) When filtering for year 2005: use T2.year = 2005 to ensure races are from the correct year. 9) When filtering for September races: use STRFTIME('%m', T2.date) = '09' to extract the month from date values. 10) When answering about races hosted in September 2005: make sure the output order includes race name, circuit name, and location."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT r.name, c.name, c.location FROM races r JOIN circuits c ON r.circuit_id = c.circuit_id WHERE r.date LIKE '2005-09%';",
            "SELECT DISTINCT T2.name AS race_name, T1.name AS circuit_name, T1.location\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T2.year = 2005\nAND STRFTIME('%m', T2.date) = '09';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name, T1.name, T1.location FROM races T2 INNER JOIN circuits T1 ON T2.circuitId = T1.circuitId WHERE T2.year = 2005 AND STRFTIME('%m', T2.date) = '09'"
        ],
        "amend_res": 1
    },
    "47": {
        "db_id": "california_schools",
        "question": "What is the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in 1980?",
        "ground_truth": "SELECT CAST(COUNT(School) AS REAL) / 12 FROM schools WHERE DOC = 52 AND County = 'Alameda' AND strftime('%Y', OpenDate) = '1980'",
        "amends": [
            "Do select `CAST(COUNT(School) AS REAL) / 12` instead of `AVG(COUNT(*))`. Do change the FROM source to filter on `DOC = 52` instead of `district_type = 'Elementary School District'`. Do keep `County = 'Alameda'` but change the year filter to use `strftime('%Y', OpenDate) = '1980'` instead of `opened_year = 1980`. Do remove the `GROUP BY opened_month` clause instead of keeping it. The amended query now correctly calculates the average monthly count using proper casting and date extraction functions, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average monthly count of schools: compute CAST(COUNT(\"School\") AS REAL) / 12 instead of using AVG(COUNT(*)) function. 2) When filtering by Elementary School District: use \"DOC\" = 52 instead of district_type = 'Elementary School District'. 3) When filtering by Alameda County: keep \"County\" = 'Alameda' exactly as specified. 4) When filtering by year 1980: use strftime('%Y', \"OpenDate\") = '1980' instead of opened_year = 1980. 5) When computing overall monthly average: remove any GROUP BY clause instead of grouping by month."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(COUNT(*)) \nFROM schools \nWHERE county = 'Alameda' \nAND district_type = 'Elementary School District' \nAND opened_year = 1980 \nGROUP BY opened_month;",
            "SELECT CAST(COUNT(School) AS REAL) / 12\nFROM schools\nWHERE County = 'Alameda'\n  AND DOC = '52'\n  AND strftime('%Y', OpenDate) = '1980';"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(\"School\") AS REAL) / 12 AS monthly_average\nFROM schools\nWHERE \"County\" = 'Alameda'\nAND \"DOC\" = 52\nAND strftime('%Y', \"OpenDate\") = '1980';"
        ],
        "amend_res": 1
    },
    "525": {
        "db_id": "card_games",
        "question": "Find the uuid of cards in which the old school format is restricted or banned.",
        "ground_truth": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
        "amends": [
            "Do query the `legalities` table instead of the `cards` table. Do use `format = 'oldschool'` as a filter condition instead of checking `old_school_format` values. Do filter on `status` values 'Banned' and 'Restricted' instead of checking for 'banned' and 'restricted' in a different column. Do use `AND` logic to combine the format condition with the status conditions instead of using `OR` between different format values. The amended query now correctly retrieves UUIDs based on format legality status rather than card attributes."
        ],
        "rules": [
            "1) When answering about \"uuid of cards in which the old school format is restricted or banned\": make sure the output order: uuid from the legalities table. 2) When the question mentions \"old school format\": \"old school format\" actually means \"format = 'oldschool' in the legalities table\". 3) When the question mentions \"restricted or banned\": \"restricted or banned\" actually means \"status values 'Banned' and 'Restricted' in the legalities table\". 4) When filtering for format and status conditions: use AND logic to combine format = 'oldschool' with status IN ('Banned', 'Restricted') instead of OR between different format values. 5) When handling text literals: use exact values 'oldschool' for format, 'Banned' and 'Restricted' for status with exact case and spelling as shown in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT uuid FROM cards WHERE old_school_format = 'restricted' OR old_school_format = 'banned';",
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')"
        ],
        "rule_sql": [
            "SELECT uuid FROM legalities WHERE format = 'oldschool' AND status IN ('Banned', 'Restricted')"
        ],
        "amend_res": 1
    },
    "617": {
        "db_id": "codebase_community",
        "question": "What is the detailed content of the comment of the post which was created on 7/19/2010 7:37:33 PM?",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:37:33.0'",
        "amends": [
            "Do select only `T1.Text` instead of `*` to return specific columns. Do use an explicit `INNER JOIN` between `comments` and `posts` tables instead of a subquery for better performance and readability. Do join on `T1.PostId = T2.Id` instead of the subquery's equality condition to properly relate the tables. Do filter on `T1.CreationDate` with the standardized timestamp format '2010-07-19 19:37:33.0' instead of filtering `posts.created_at` with the non-standard '7/19/2010 7:37:33 PM' format. Do use proper table aliases `T1` and `T2` instead of no aliases for clarity. The amended query now correctly retrieves comment text based on creation date rather than attempting to match post creation dates, ensuring it matches the RIGHT_SQL's behavior.",
            "Do filter on `T1.CreationDate` instead of `T2.CreationDate` in the WHERE clause, as the condition should apply to the comments table's creation date rather than the posts table's creation date to correctly identify comments created at that specific timestamp."
        ],
        "rules": [
            "1) When the question asks for detailed content of a comment: select only the \"Text\" column from the comments table (T1.Text) instead of all columns. 2) When combining comments and posts tables: use an inner join where T1.PostId equals T2.Id (T1.PostId = T2.Id) to properly relate the tables. 3) When filtering by creation date '7/19/2010 7:37:33 PM': use the standardized timestamp format '2010-07-19 19:37:33.0' instead of the non-standard format. 4) When referring to tables in the query: use proper aliases T1 for comments and T2 for posts for clarity. 5) When the question asks about comment content for a specific post creation time: filter on the comment's CreationDate (T1.CreationDate) rather than the post's creation date.",
            "1) When the question asks for comments created at a specific timestamp: filter on T1.CreationDate using the exact timestamp '2010-07-19 19:37:33.0' 2) When joining comments and posts tables: link rows where T1.PostId equals T2.Id to connect comments to their parent posts 3) When answering about detailed comment content: output the T1.Text column to show the comment text"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM comments WHERE post_id = (SELECT id FROM posts WHERE created_at = '7/19/2010 7:37:33 PM');",
            "SELECT T1.Text \nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.CreationDate = '2010-07-19 19:37:33.0'",
            "SELECT T1.Text \nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.CreationDate = '2010-07-19 19:37:33.0'"
        ],
        "rule_sql": [
            "SELECT T1.Text \nFROM comments T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.CreationDate = '2010-07-19 19:37:33.0'"
        ],
        "amend_res": 1
    },
    "767": {
        "db_id": "superhero",
        "question": "What is the average of superheroes with no skin colour?",
        "ground_truth": "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id",
        "amends": [
            "Do use `CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END)` instead of `AVG(*)` for calculating the ratio. Do add `INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id` instead of omitting the join to the colour table. Do reference `T1.skin_colour_id` in the join condition instead of checking `skin_color IS NULL` directly. Do remove the `WHERE` clause filter instead of keeping it, as the condition is now handled through the join and case expression. The amended query now correctly calculates the proportion of superheroes with skin colour ID 1 by joining to the colour table and using proper ratio calculation instead of attempting to average all columns."
        ],
        "rules": [
            "1) When calculating the proportion of superheroes with a specific skin color: use the formula CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) instead of AVG(*) for ratio calculation. 2) When joining superheroes table to color table: use INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id to establish the relationship between tables. 3) When checking for skin color condition: reference T1.skin_colour_id in the join condition instead of checking skin_color IS NULL directly. 4) When handling the condition for no skin color: remove the WHERE clause filter entirely as the condition is handled through the join and case expression."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(*) FROM superheroes WHERE skin_color IS NULL;",
            "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) \nFROM superhero AS T1 \nINNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) AS average_proportion\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id\nWHERE T1.skin_colour_id IS NULL",
            "SELECT CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) AS average_no_skin_color\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id"
        ],
        "amend_res": 1
    },
    "934": {
        "db_id": "formula_1",
        "question": "Which driver was in the no. 4 grid formation when starting the race in 1989's Australian Grand Prix? Please give his forename and surname.",
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T2.grid = 4 AND T1.name = 'Australian Grand Prix' AND T1.year = 1989",
        "amends": [
            "Do add tables `races AS T1` and `results AS T2` with proper joins instead of querying only `drivers`. Do use `INNER JOIN results AS T2 ON T2.raceId = T1.raceId` and `INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId` instead of missing table relationships. Do reference columns with table aliases `T3.forename` and `T3.surname` instead of unqualified `forename` and `surname`. Do filter on `T2.grid = 4` instead of `grid = 4` to specify the correct table. Do filter on `T1.name = 'Australian Grand Prix'` instead of `race = 'Australian Grand Prix'` to use the proper column name. Do filter on `T1.year = 1989` instead of `year = 1989` to reference the correct table. The amended query now correctly joins the necessary tables to find drivers who started in grid position 4 for the 1989 Australian Grand Prix."
        ],
        "rules": [
            "1) When answering about drivers in specific grid positions: combine tables races AS T1, results AS T2, and drivers AS T3 using inner matches where T2.raceId = T1.raceId and T3.driverId = T2.driverId. 2) When the question mentions \"grid formation\": use T2.grid = 4 to filter for the exact grid position. 3) When the question mentions \"1989's Australian Grand Prix\": use T1.year = 1989 and T1.name = 'Australian Grand Prix' to filter for the specific race. 4) When the question asks for driver's forename and surname: output T3.forename and T3.surname in that order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT forename, surname FROM drivers WHERE grid = 4 AND year = 1989 AND race = 'Australian Grand Prix';",
            "SELECT T3.forename, T3.surname\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T1.year = 1989\nAND T1.name = 'Australian Grand Prix'\nAND T2.grid = 4"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname \nFROM races AS T1\nINNER JOIN results AS T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T1.year = 1989 \nAND T1.name = 'Australian Grand Prix'\nAND T2.grid = 4"
        ],
        "amend_res": 1
    },
    "1020": {
        "db_id": "european_football_2",
        "question": "Which player has the highest overall rating? Indicate the player's api id.",
        "ground_truth": "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1",
        "amends": [
            "Do select `player_api_id` instead of `api_id` and do source from `Player_Attributes` instead of `players` while keeping the same `ORDER BY overall_rating DESC LIMIT 1` structure, as the correct column and table names are essential for accurate data retrieval from the proper database relation."
        ],
        "rules": [
            "1) When answering about \"highest overall rating\": use the table \"Player_Attributes\" as the source table instead of \"players\". 2) When selecting the player's api id: use the exact column name \"player_api_id\" instead of \"api_id\". 3) When finding the highest overall rating: order by \"overall_rating\" in descending direction and keep only the top 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT api_id FROM players ORDER BY overall_rating DESC LIMIT 1;",
            "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_api_id FROM Player_Attributes ORDER BY overall_rating DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "837": {
        "db_id": "superhero",
        "question": "Give the hero ID of superhero with the lowest attribute value.",
        "ground_truth": "SELECT hero_id FROM hero_attribute WHERE attribute_value = ( SELECT MIN(attribute_value) FROM hero_attribute )",
        "amends": [
            "Do query from `hero_attribute` table instead of `superheroes` table. Do use a subquery with `MIN(attribute_value)` instead of `ORDER BY attribute_value DESC LIMIT 1`. Do filter with `attribute_value = (subquery)` instead of selecting the maximum value. Do remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. The amended query now correctly finds the hero with the minimum attribute value by using a subquery comparison instead of ordering and limiting to get the maximum value."
        ],
        "rules": [
            "1) When answering about \"the hero ID of superhero with the lowest attribute value\": make sure to query from the \"hero_attribute\" table instead of the \"superheroes\" table. 2) When finding the minimum attribute value: use a subquery with MIN(attribute_value) instead of ORDER BY attribute_value DESC LIMIT 1. 3) When filtering for the hero with the minimum attribute value: use attribute_value = (subquery) instead of selecting the maximum value. 4) When constructing the final query: remove the ORDER BY and LIMIT clauses instead of keeping them."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_id FROM superheroes ORDER BY attribute_value DESC LIMIT 1;",
            "SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute);"
        ],
        "rule_sql": [
            "SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute);"
        ],
        "amend_res": 1
    },
    "157": {
        "db_id": "financial",
        "question": "What is the number of committed crimes in 1995 in the district of the account with the id 532?",
        "ground_truth": "SELECT T1.A15 FROM district AS T1 INNER JOIN `account` AS T2 ON T1.district_id = T2.district_id WHERE T2.account_id = 532",
        "amends": [
            "Do select `T1.A15` instead of `COUNT(*)`. Do join `district AS T1` and `account AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of using a subquery to get `district_id` from `accounts`. Do filter with `T2.account_id = 532` instead of `year = 1995 AND district_id = (subquery)`. Do remove the aggregation and the `crimes` table reference instead of including them. The amended query now correctly retrieves the district A15 value for account 532 instead of counting crimes from 1995."
        ],
        "rules": [
            "1) When the question asks for \"number of committed crimes in 1995\": the schema actually stores this value directly as column \"A15\" in the district table instead of requiring counting from a crimes table. 2) When combining district and account tables: link rows where T1.district_id = T2.district_id using an inner match and keep only matching pairs. 3) When filtering for account with id 532: use exact literal value 532 with T2.account_id = 532. 4) When the question mentions \"district of the account\": this requires joining district (T1) and account (T2) tables to find the district associated with account 532. 5) When producing output: return the exact column T1.A15 which contains the pre-computed number of committed crimes in 1995 for that district."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM crimes WHERE year = 1995 AND district_id = (SELECT district_id FROM accounts WHERE account_id = 532);",
            "SELECT T1.A15\nFROM district AS T1\nINNER JOIN account AS T2 ON T1.district_id = T2.district_id\nWHERE T2.account_id = 532"
        ],
        "rule_sql": [
            "SELECT T1.A15 \nFROM district T1 \nINNER JOIN account T2 ON T1.district_id = T2.district_id \nWHERE T2.account_id = 532"
        ],
        "amend_res": 1
    },
    "544": {
        "db_id": "codebase_community",
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
        "amends": [
            "Do use an `INNER JOIN` between `posts` and `users` on `T1.LastEditorUserId = T2.Id` instead of a subquery with `user_id = (SELECT last_editor_user_id FROM posts...)`. Do reference the joined table with alias `T2` instead of directly querying the `users` table. Do select `T2.DisplayName` instead of `display_name` from the base table. Do remove the `ORDER BY creation_date DESC LIMIT 1` subquery logic instead of keeping it, as the join approach directly connects the matching post to its editor. Do add explicit table aliases `AS T1` and `AS T2` instead of omitting them. The amended query now correctly retrieves the display name through a direct join relationship rather than relying on potentially ambiguous subquery ordering."
        ],
        "rules": [
            "1) When combining posts and users tables: link rows where T1.LastEditorUserId equals T2.Id exactly as shown in the amends and keep only matching pairs (inner match). 2) When selecting the display name: use T2.DisplayName instead of display_name from the base table. 3) When the question asks for the user who last edited a specific post: filter posts where T1.title equals 'Examples for teaching: Correlation does not mean causation' exactly as specified. 4) When using table aliases: assign posts as T1 and users as T2 exactly as shown in the amends. 5) When retrieving the last editor: do not use ORDER BY creation_date DESC LIMIT 1 subquery logic, instead use the direct join relationship between posts and users tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users WHERE user_id = (SELECT last_editor_user_id FROM posts WHERE title = 'Examples for teaching: Correlation does not mean causation' ORDER BY creation_date DESC LIMIT 1);",
            "SELECT T2.DisplayName \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id \nWHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName\nFROM posts T1\nINNER JOIN users T2 ON T1.LastEditorUserId = T2.Id\nWHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'"
        ],
        "amend_res": 1
    },
    "558": {
        "db_id": "codebase_community",
        "question": "How many votes did the user No.58 take on 2010/7/19?",
        "ground_truth": "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'",
        "amends": [
            "Do reference column `Id` in the COUNT function instead of using `COUNT(*)` to count non-null values. Do use column name `UserId` instead of `user_id` for the user identifier filter. Do use column name `CreationDate` instead of `vote_date` for the date filter. Do use date format `'2010-07-19'` with hyphens and zero-padded month instead of `'2010/7/19'` with slashes and unpadded month. The amended query now correctly counts non-null Id values using the proper column names and standardized date format."
        ],
        "rules": [
            "1) When counting votes: count non-null values of the \"Id\" column instead of counting all rows. 2) When filtering by user identifier: use column name \"UserId\" instead of \"user_id\". 3) When filtering by date: use column name \"CreationDate\" instead of \"vote_date\". 4) When specifying date values: use format '2010-07-19' with hyphens and zero-padded month instead of '2010/7/19' with slashes and unpadded month."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE user_id = 58 AND vote_date = '2010/7/19';",
            "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND DATE(CreationDate) = '2010-07-19';"
        ],
        "amend_res": 1
    },
    "1263": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients whose level of Hematoclit isn't normal, which patient has the highest anti-Cardiolipin antibody concentration? Please list his or her ID.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 on T1.ID = T3.ID WHERE (T3.HCT >= 52 OR T3.HCT <= 29) ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "amends": [
            "Do use `DISTINCT T1.ID` instead of `Patient_ID` without distinct. Do join `Examination AS T2` and `Laboratory AS T3` on `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of querying only the `Patients` table. Do filter with `(T3.HCT >= 52 OR T3.HCT <= 29)` instead of `Hematoclit != 'normal'` to use numeric range checks on the correct column. Do order by `T2.`aCL IgA` DESC` instead of `anti_Cardiolipin DESC` to reference the correct column from the joined table. The amended query now correctly identifies patients with abnormal hematocrit values through proper table joins and numeric comparisons, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patients with abnormal hematocrit levels: use numeric range checks (T3.HCT >= 52 OR T3.HCT <= 29) instead of string comparison with 'normal'. 2) When combining patient data with examination and laboratory results: join Patients as T1 with Examination as T2 on T1.ID = T2.ID and with Laboratory as T3 on T1.ID = T3.ID using inner matches. 3) When ordering by anti-Cardiolipin antibody concentration: use T2.\"aCL IgA\" DESC to reference the correct column from the joined Examination table. 4) When selecting patient identification: use DISTINCT T1.ID instead of Patient_ID to ensure unique patient identifiers. 5) When the question asks for the highest value: order by the measurement column in descending direction and take the first result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT Patient_ID FROM Patients WHERE Hematoclit != 'normal' ORDER BY anti_Cardiolipin DESC LIMIT 1;",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nJOIN Examination AS T2 ON T1.ID = T2.ID\nJOIN Laboratory AS T3 ON T1.ID = T3.ID\nWHERE (T3.HCT >= 52 OR T3.HCT <= 29)\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nINNER JOIN Laboratory T3 ON T1.ID = T3.ID\nWHERE T3.HCT >= 52 OR T3.HCT <= 29\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "352": {
        "db_id": "card_games",
        "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
        "amends": [
            "Do add `INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid` instead of querying only the `cards` table. Do use `SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN language = 'Chinese Simplified' THEN 1 END)` to properly count matches. Do reference `T2.language` instead of just `language` to specify the joined table. Do include `ELSE 0` in the CASE statement instead of omitting it for accurate summation. Do use `CAST(... AS REAL)` instead of implicit casting with `100.0` for explicit type conversion. Do calculate percentage using `COUNT(T1.id)` instead of `COUNT(*)` for the denominator. Do add table aliases `T1` and `T2` instead of using unqualified column references. The amended query now correctly joins the tables and calculates the percentage of Chinese Simplified language cards."
        ],
        "rules": [
            "1) When calculating percentages from joined tables: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for accurate summation. 2) When combining tables for shared entities: link rows where T1.uuid = T2.uuid using an inner join and keep only matching pairs. 3) When referencing columns from joined tables: use qualified references like T2.language instead of unqualified column names. 4) When calculating percentage denominators: use COUNT(T1.id) instead of COUNT(*) to count only the canonical entities. 5) When performing explicit type conversion: use CAST(... AS REAL) instead of implicit casting with numeric literals like 100.0. 6) When the question asks for percentage of cards available in a specific language: the language 'Chinese Simplified' must be matched exactly with case and spacing as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN language = 'Chinese Simplified' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM cards\nWHERE available = 1;",
            "SELECT \n    CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T1.id) AS percentage\nFROM \n    cards AS T1\nINNER JOIN \n    foreign_data AS T2 ON T1.uuid = T2.uuid"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN fd.language = 'Chinese Simplified' THEN 1 ELSE 0 END) * 100.0 / COUNT(c.id)) AS percentage\nFROM \n    cards c\nINNER JOIN \n    foreign_data fd ON c.uuid = fd.uuid"
        ],
        "amend_res": 1
    },
    "1182": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient who first came to the hospital on 1991/6/13 who was diagnosed with SJS, what is the total number of his/her Laboratory tests in 1995?",
        "ground_truth": "SELECT COUNT(*) FROM Laboratory WHERE ID = ( SELECT ID FROM Patient WHERE `First Date` = '1991-06-13' AND Diagnosis = 'SJS' ) AND STRFTIME('%Y', Date) = '1995'",
        "amends": [
            "Do use a subquery to filter patients with `First Date = '1991-06-13'` and `Diagnosis = 'SJS'` instead of joining multiple tables with `p.FirstVisitDate = '1991/6/13'` and `d.Diagnosis = 'SJS'`. Do reference `Laboratory` table directly instead of `LaboratoryTests` and use `ID` column for filtering instead of `PatientID`. Do filter by `STRFTIME('%Y', Date) = '1995'` on the Laboratory table instead of `strftime('%Y', lt.TestDate) = '1995'`. Do use proper date format '1991-06-13' instead of '1991/6/13'. The amended query now correctly counts laboratory tests from 1995 for patients with SJS diagnosis who first visited on June 13, 1991."
        ],
        "rules": [
            "1) When the question asks about a patient who first came on a specific date: use the exact date format '1991-06-13' instead of '1991/6/13' for date comparisons. 2) When filtering for patients with a specific diagnosis: use the exact literal 'SJS' for the Diagnosis condition. 3) When counting laboratory tests for a specific year: use STRFTIME('%Y', Date) = '1995' to filter tests from 1995. 4) When referencing the laboratory tests table: use the table name \"Laboratory\" instead of \"LaboratoryTests\". 5) When joining or filtering by patient identifier: use the column \"ID\" instead of \"PatientID\" for patient identification. 6) When answering about laboratory test counts for specific patients: use a subquery approach to first identify patients meeting the criteria (First Date = '1991-06-13' and Diagnosis = 'SJS') before counting their laboratory tests."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM LaboratoryTests lt\nJOIN Patients p ON lt.PatientID = p.PatientID\nJOIN Diagnoses d ON p.PatientID = d.PatientID\nWHERE p.FirstVisitDate = '1991/6/13'\nAND d.Diagnosis = 'SJS'\nAND strftime('%Y', lt.TestDate) = '1995';",
            "SELECT COUNT(*) \nFROM Laboratory \nWHERE ID IN (\n    SELECT ID \n    FROM Patient \n    WHERE \"First Date\" = '1991-06-13' \n    AND Diagnosis = 'SJS'\n) \nAND STRFTIME('%Y', Date) = '1995'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS total_lab_tests\nFROM Laboratory\nWHERE ID IN (\n    SELECT ID\n    FROM Patient\n    WHERE \"First Date\" = '1991-06-13' AND Diagnosis = 'SJS'\n) AND STRFTIME('%Y', Date) = '1995';"
        ],
        "amend_res": 1
    },
    "776": {
        "db_id": "superhero",
        "question": "Provide the hero name and race of Charles Chandler.",
        "ground_truth": "SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'",
        "amends": [
            "Do reference `T1.superhero_name` and `T2.race` instead of `hero_name` and `race`. Do join `superhero AS T1` with `race AS T2` using `INNER JOIN` on `T1.race_id = T2.id` instead of querying a single table `heroes`. Do filter on `T1.full_name = 'Charles Chandler'` instead of separate `first_name = 'Charles' AND last_name = 'Chandler'` conditions. The amended query now correctly joins tables and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"hero name and race of Charles Chandler\": make sure the output order: T1.superhero_name, T2.race\n2) When the question mentions \"hero name\": \"hero name\" actually means \"T1.superhero_name\" in schema\n3) When the question mentions \"race\": \"race\" actually means \"T2.race\" in schema\n4) When combining T1 and T2 for shared entities: link rows where T1.race_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When filtering for Charles Chandler: use T1.full_name = 'Charles Chandler' exactly as specified in the amends, not separate first and last name conditions"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_name, race FROM heroes WHERE first_name = 'Charles' AND last_name = 'Chandler'",
            "SELECT T1.superhero_name, T2.race\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T1.full_name = 'Charles Chandler';"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name, T2.race\nFROM superhero T1\nINNER JOIN race T2 ON T1.race_id = T2.id\nWHERE T1.full_name = 'Charles Chandler'"
        ],
        "amend_res": 1
    },
    "1254": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with a normal Ig A level came to the hospital after 1990/1/1?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 AND  strftime('%Y',  T1.`First Date`) > '1990'",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific column instead of `COUNT(*)` from all rows. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.IGA BETWEEN 80 AND 500` for numeric range instead of `ig_a_level = 'normal'` string comparison. Do use `strftime('%Y', T1.First Date) > '1990'` for year extraction and comparison instead of `visit_date > '1990/1/1'` date string comparison. The amended query now correctly counts patients with specific laboratory IgA values within range from the appropriate joined tables using proper date handling."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 2) When combining patient and laboratory data: join Patient AS T1 and Laboratory AS T2 using INNER JOIN on T1.ID = T2.ID to link patient records with their laboratory results. 3) When filtering for normal IgA levels: use T2.IGA BETWEEN 80 AND 500 for numeric range checking instead of string comparison with 'normal'. 4) When filtering for visits after 1990/1/1: use strftime('%Y', T1.First Date) > '1990' to extract the year from the date field and compare it numerically instead of direct date string comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE ig_a_level = 'normal' AND visit_date > '1990/1/1';",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.IGA BETWEEN 80 AND 500\nAND strftime('%Y', T1.\"First Date\") > '1990'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.IGA BETWEEN 80 AND 500 \nAND strftime('%Y', T1.\"First Date\") > '1990'"
        ],
        "amend_res": 1
    },
    "1157": {
        "db_id": "thrombosis_prediction",
        "question": "For patients with severe degree of thrombosis, list their ID, sex and disease the patient is diagnosed with.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `ID` and `SEX` instead of `patient_id` and `sex` with different column names. Do select `Diagnosis` instead of `disease_name` with a different column reference. Do add `INNER JOIN` on `Examination AS T2` instead of querying only the `patients` table. Do use join condition `T1.ID = T2.ID` instead of no join condition. Do move filter to `T2.Thrombosis = 2` instead of `thrombosis_degree = 'mild'` with different table reference, column name, and numeric comparison instead of string matching. The amended query now correctly joins patient and examination data and filters based on the thrombosis severity level in the examination table.",
            "Do select `T1.Diagnosis` from the `Patient` table instead of `T2.Diagnosis` from the `Examination` table, as the diagnosis data should originate from the patient record rather than the examination record while maintaining the same `INNER JOIN` on `T1.ID = T2.ID` and filter for `T2.Thrombosis = 2` with `DISTINCT` preserved. The amended query now correctly retrieves diagnosis information from the appropriate source table while maintaining the original join logic and filtering conditions."
        ],
        "rules": [
            "1) When answering about patients with severe thrombosis: use DISTINCT to eliminate duplicate rows in the results. 2) When selecting patient identification: use \"ID\" instead of patient_id as the exact column name. 3) When selecting patient gender: use \"SEX\" instead of sex as the exact column name. 4) When selecting disease information: use \"Diagnosis\" instead of disease_name as the exact column name. 5) When combining patient and examination data: perform an INNER JOIN between patients table (T1) and Examination table (T2) using the condition T1.ID = T2.ID. 6) When filtering for severe thrombosis: use T2.Thrombosis = 2 instead of string matching, where 2 represents the severe degree numeric value.",
            "1) When answering about \"patients with severe degree of thrombosis\": filter rows where T2.Thrombosis = 2. 2) When combining Patient table (T1) and Examination table (T2): link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When the question asks for \"disease the patient is diagnosed with\": use T1.Diagnosis from the Patient table rather than T2.Diagnosis from the Examination table. 4) When selecting output columns: return T1.ID, T1.SEX, and T1.Diagnosis in that order. 5) When retrieving patient information: ensure DISTINCT is applied to eliminate duplicate rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, disease_name FROM patients WHERE thrombosis_degree = 'mild';",
            "SELECT DISTINCT T1.ID, T1.SEX, T2.Diagnosis\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 2",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 2"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.Thrombosis = 2"
        ],
        "amend_res": 1
    },
    "1062": {
        "db_id": "european_football_2",
        "question": "Which players had an overall rating of over 80 from 2008 to 2010? Please list player names.",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating > 80 AND SUBSTR(t2.`date`, 1, 4) BETWEEN '2008' AND '2010'",
        "amends": [
            "Do add `DISTINCT` and `t1.` prefix to `player_name` instead of selecting it directly without qualification. Do change the FROM clause to use `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do change the WHERE condition to filter on `t2.overall_rating > 80` instead of `overall_rating > 80` and add `SUBSTR(t2.\"date\", 1, 4) BETWEEN '2008' AND '2010'` instead of `year BETWEEN 2008 AND 2010` to properly extract year from the date string. The amended query now correctly joins the Player and Player_Attributes tables, uses proper table aliases, handles date extraction, and ensures distinct player names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about players with overall rating over 80 from 2008 to 2010: make sure the output order: DISTINCT t1.player_name. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match). 3) When filtering for overall rating over 80: use t2.overall_rating > 80. 4) When filtering for years 2008 to 2010: extract year from t2.\"date\" using SUBSTR(t2.\"date\", 1, 4) BETWEEN '2008' AND '2010'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM players WHERE overall_rating > 80 AND year BETWEEN 2008 AND 2010;",
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating > 80\nAND SUBSTR(t2.\"date\", 1, 4) BETWEEN '2008' AND '2010'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating > 80\nAND SUBSTR(t2.\"date\", 1, 4) BETWEEN '2008' AND '2010'\nORDER BY t1.player_name;"
        ],
        "amend_res": 1
    },
    "1155": {
        "db_id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday of patient with LDH beyond normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do specify table aliases `T1.ID`, `T1.SEX`, and `T1.Birthday` instead of unqualified column names `patient_id`, `sex`, and `birthday`. Do add `INNER JOIN Laboratory AS T2` instead of querying only the `patients` table. Do use the join condition `ON T1.ID = T2.ID` instead of no join. Do change the filter to `T2.LDH > 500` instead of `LDH > 100 OR LDH < 50` and reference the joined table's column. The amended query now correctly retrieves distinct patient records with elevated LDH values from the laboratory results."
        ],
        "rules": [
            "1) When answering about \"patient ID, sex and birthday of patient with LDH beyond normal range\": make sure the output order: T1.ID, T1.SEX, T1.Birthday\n2) When the question mentions \"patient with LDH beyond normal range\": use the condition T2.LDH > 500 instead of LDH > 100 OR LDH < 50\n3) When combining patients and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)\n4) When selecting patient information: use table aliases T1.ID, T1.SEX, and T1.Birthday instead of unqualified column names\n5) When retrieving patient records: use DISTINCT to eliminate duplicate rows"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, birthday FROM patients WHERE LDH > 100 OR LDH < 50;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 500"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 500"
        ],
        "amend_res": 1
    },
    "1280": {
        "db_id": "thrombosis_prediction",
        "question": "How many male patients have their glutamic oxaloacetic transaminase in the normal range?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
        "amends": [
            "Do reference the `Patient` table as `T1` instead of `patients`, and join with `Laboratory` as `T2` on `T1.ID = T2.ID` instead of querying a single table. Do count `T1.ID` instead of `COUNT(*)` for more precise counting. Do filter on `T2.GOT < 60` instead of `glutamic_oxaloacetic_transaminase > 50`, using the correct column name and inequality direction. Do filter on `T1.SEX = 'M'` instead of `gender = 'male'`, using the proper column name and value format. The amended query now correctly joins patient and laboratory data to count male patients with GOT levels below 60, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"male patients with glutamic oxaloacetic transaminase in normal range\": use table \"Patient\" as T1 and join with table \"Laboratory\" as T2 on T1.ID = T2.ID. 2) When counting patients: count T1.ID instead of all rows for precise counting. 3) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male'. 4) When filtering for glutamic oxaloacetic transaminase levels: use T2.GOT < 60 instead of glutamic_oxaloacetic_transaminase > 50 with the correct column name and inequality direction."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND glutamic_oxaloacetic_transaminase > 50;",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.GOT < 60"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' AND T2.GOT < 60",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nJOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' AND T2.GOT < 60"
        ],
        "amend_res": 1
    },
    "677": {
        "db_id": "codebase_community",
        "question": "How many posts did Jay Stevens have in 2010?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2010' AND T1.DisplayName = 'Jay Stevens'",
        "amends": [
            "Do select `COUNT(T1.Id)` from the joined result instead of `COUNT(*)` from a single table. Do join `users AS T1` with `posts AS T2` using `INNER JOIN` on `T1.Id = T2.OwnerUserId` instead of querying only the `posts` table. Do filter by `T1.DisplayName = 'Jay Stevens'` instead of `author = 'Jay Stevens'` to use the correct user identification. Do extract the year using `STRFTIME('%Y', T2.CreationDate) = '2010'` instead of a direct `year = 2010` column comparison to properly handle date formatting. The amended query now correctly counts posts by the specific user from 2010 using proper table relationships and date handling.",
            "Do count `T1.Id` instead of `T2.Id` to ensure the count reflects user records rather than post records. Do remove the filter `T1.DisplayName = 'Jay Stevens'` from the WHERE clause instead of keeping it, as the right query does not include this condition. Do maintain the same `INNER JOIN` on `T1.Id = T2.OwnerUserId` and the date filter `STRFTIME('%Y', T2.CreationDate) = '2010'` without changes. The amended query now matches the right SQL's behavior by counting user IDs and removing the unnecessary display name filter.",
            "Do add `AND T1.DisplayName = 'Jay Stevens'` to the WHERE clause instead of omitting this filter condition, which restricts the count to only users with the specific display name rather than all users from 2010.",
            "Do maintain the same `COUNT(T1.Id)` aggregation and `INNER JOIN` on `T1.Id = T2.OwnerUserId` between `users` and `posts` tables instead of changing them. Do reorder the WHERE clause predicates to place `STRFTIME('%Y', T2.CreationDate) = '2010'` before `T1.DisplayName = 'Jay Stevens'` instead of the original order, though this is purely cosmetic as the logical AND operation is commutative. The amended query now matches RIGHT_SQL's behavior with identical filtering logic and join conditions.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call to properly filter posts by their creation year. The amended query now correctly references the actual column name and matches the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, matching the intended behavior of counting posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the STRFTIME function within the WHERE clause. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, matching the intended behavior of counting posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call, ensuring proper date extraction from the posts table's creation timestamp. The amended query now correctly filters posts created in 2010 while maintaining the same join logic and user display name condition, matching the intended behavior of counting posts from user 'Jay Stevens' in that year.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause STRFTIME function. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, matching the intended behavior of counting posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and user display name filter, ensuring accurate counting of posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and user display name filter, ensuring accurate counting of posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function to properly filter posts by the year 2010. The amended query now correctly references the CreationDate column and matches the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, ensuring accurate results by properly referencing the complete schema-defined column name.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call, ensuring proper date extraction from the posts table's creation timestamp for accurate year filtering.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, matching the intended behavior of counting posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, matching the intended behavior of counting posts from 2010 by the specified user.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function, ensuring proper date extraction from the posts table's creation timestamp. The amended query now correctly filters posts created in 2010 while maintaining the same join logic and count aggregation, matching the intended behavior of the right SQL.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause filter condition. The amended query now correctly references the post creation date column to filter for posts from 2010, matching the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function call. The amended query now correctly filters posts by their creation date year while maintaining the same join logic and count aggregation, matching the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function to properly filter posts by their creation year. The amended query now correctly references the actual column name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "DisplayName = 'Jay Stevens'; in 2010 refers to YEAR(CreationDate) = 2010;"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM posts WHERE author = 'Jay Stevens' AND year = 2010;",
            "SELECT COUNT(T2.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE T1.DisplayName = 'Jay Stevens' \nAND STRFTIME('%Y', T2.CreationDate) = '2010'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE T1.DisplayName = 'Jay Stevens' \nAND STRFTIME('%Y', T2.CreationDate) = '2010'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2010' \nAND T1.DisplayName = 'Jay Stevens'"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "923": {
        "db_id": "formula_1",
        "question": "How many Formula_1 races took place on the circuits in Italy?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Italy'",
        "amends": [
            "Do join `circuits AS T1` with `races AS T2` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do filter on `T1.country = 'Italy'` instead of directly filtering `races.country`. Do count `T2.circuitId` instead of counting all rows with `COUNT(*)`. The amended query now correctly counts races held in Italy by joining through the circuits table to ensure proper country association."
        ],
        "rules": [
            "1) When answering about \"Formula_1 races on circuits in Italy\": make sure the output order: count of races\n2) When combining circuits and races tables: link rows where T2.circuitID = T1.circuitId exactly as shown; keep only matching pairs (inner match)\n3) When filtering for circuits in Italy: use T1.country = 'Italy' with exact literal 'Italy'\n4) When counting races: compute the number of rows using the canonical key T2.circuitId instead of counting all rows"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM races WHERE country = 'Italy';",
            "SELECT COUNT(T2.circuitId) \nFROM circuits AS T1 \nJOIN races AS T2 ON T2.circuitId = T1.circuitId \nWHERE T1.country = 'Italy'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.circuitId) \nFROM circuits T1 \nINNER JOIN races T2 ON T2.circuitId = T1.circuitId \nWHERE T1.country = 'Italy'"
        ],
        "amend_res": 1
    },
    "389": {
        "db_id": "card_games",
        "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
        "ground_truth": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
        "amends": [
            "Do select `T1.id` and `T2.date` instead of `name` and `date`. Do use `cards AS T1` and `rulings AS T2` with an `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do filter on `T1.originalType` instead of `original_type` while maintaining the same condition value. The amended query now correctly joins the cards and rulings tables to retrieve the appropriate data."
        ],
        "rules": [
            "1) When answering about \"name of cards with original types of Creature - Elf and the date of rulings\": make sure the output order: T1.id, T2.date 2) When the question mentions \"name of cards\": \"name\" actually means \"T1.id in schema\" 3) When the question mentions \"date of rulings\": \"date\" actually means \"T2.date in schema\" 4) When combining T1 (cards) and T2 (rulings) for shared entities: link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match) 5) When filtering for cards with original type of Creature - Elf: use T1.originalType = 'Creature - Elf' with exact case and spacing"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM cards WHERE original_type = 'Creature - Elf';",
            "SELECT T1.id, T2.date\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Creature - Elf';"
        ],
        "rule_sql": [
            "SELECT cards.id, rulings.date FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.originalType = 'Creature - Elf' ORDER BY cards.id, rulings.date"
        ],
        "amend_res": 1
    },
    "1294": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest.",
        "ground_truth": "SELECT T2.ID FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.CRE < 1.5 ORDER BY T2.`aCL IgA` DESC LIMIT 1",
        "amends": [
            "Do select `T2.ID` instead of `patient_id`. Do use `Laboratory AS T1` and `Examination AS T2` with an `INNER JOIN` on `T1.ID = T2.ID` instead of querying only `lab_results`. Do filter with `T1.CRE < 1.5` instead of `creatinine_level = 'normal'`. Do order by `T2.aCL IgA DESC` instead of `anti_cardiolipin_antibody DESC`. The amended query now correctly joins laboratory and examination data, uses proper numeric comparison for creatinine levels, and references the appropriate column for anti-cardiolipin antibody ordering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"patient's ID\": make sure the output order: T2.ID 2) When the question mentions \"creatinine level is normal\": \"normal\" actually means \"T1.CRE < 1.5\" in schema 3) When the question mentions \"highest anti Cardiolipin antibody concentration level\": rank rows by T2.aCL IgA in descending direction and keep the first 1 row 4) When combining Laboratory AS T1 and Examination AS T2 for shared entities: link rows where T1.ID = T2.ID exactly as shown in the amends; keep only matching pairs (inner match)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM lab_results WHERE creatinine_level = 'normal' ORDER BY anti_cardiolipin_antibody DESC LIMIT 1;",
            "SELECT T2.ID\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.CRE < 1.5\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.ID\nFROM Laboratory AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.CRE < 1.5\nORDER BY T2.\"aCL IgA\" DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "418": {
        "db_id": "card_games",
        "question": "What kind of printing is on the card that Daren Bader created?",
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader'",
        "amends": [
            "Do select `availability` instead of `printing_type` and add `DISTINCT` instead of omitting it. Do filter on `artist = 'Daren Bader'` instead of `creator = 'Daren Bader'` while keeping the same table source `cards` and WHERE clause structure. The amended query now correctly retrieves distinct availability values for the specified artist rather than printing types for a creator, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"printing\" on a card: \"printing\" actually means \"availability\" in the schema. 2) When the question mentions \"Daren Bader created\": \"created\" actually means \"artist = 'Daren Bader'\" in the schema. 3) When retrieving values for a specific artist: use DISTINCT to get unique values only."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT printing_type FROM cards WHERE creator = 'Daren Bader'",
            "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader';"
        ],
        "rule_sql": [
            "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader';"
        ],
        "amend_res": 1
    },
    "371": {
        "db_id": "card_games",
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
        "amends": [
            "Do use `SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN language = 'French' THEN 1 END)` for accurate counting. Do add `INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid` instead of querying only the `cards` table. Do reference `T2.language` instead of just `language` to specify the joined table. Do change the filter to `WHERE T1.isStorySpotlight = 1` instead of `WHERE type = 'Story Spotlight'` to use the correct column name and value format. Do add `CAST(... AS REAL)` instead of implicit casting for precise division. Do use `COUNT(T1.id)` instead of `COUNT(*)` for more explicit counting. Do remove the alias `percentage_french` instead of keeping it. The amended query now correctly joins tables and calculates the percentage of French language cards with story spotlight status."
        ],
        "rules": [
            "1) When answering about percentage of cards with French language among Story Spotlight cards: make sure to join the foreign_data table as T2 using T1.uuid = T2.uuid for language information. 2) When the question mentions \"language is French\": \"French\" actually means T2.language = 'French' with exact case and quotes. 3) When the question mentions \"Story Spotlight cards\": this actually means T1.isStorySpotlight = 1 using the correct boolean value format. 4) When calculating percentage: use SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) divided by COUNT(T1.id) and multiply by 100.0 with explicit casting to REAL for precise division. 5) When combining T1 (cards) and T2 (foreign_data): link rows where T1.uuid = T2.uuid exactly and keep only matching pairs (inner match). 6) When producing output: do not include any column alias for the percentage result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN language = 'French' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_french\nFROM cards\nWHERE type = 'Story Spotlight';",
            "SELECT \n    (CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.id)) * 100\nFROM \n    cards AS T1\nINNER JOIN \n    foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.isStorySpotlight = 1"
        ],
        "rule_sql": [
            "SELECT (SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.id)) \nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.isStorySpotlight = 1"
        ],
        "amend_res": 1
    },
    "1231": {
        "db_id": "thrombosis_prediction",
        "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patients. Do reference `Patient AS T1` and `Laboratory AS T2` tables instead of just `patients`. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter with `T1.SEX = 'M'` instead of `gender = 'Male'`. Do use `STRFTIME('%Y', T1.Birthday)` for year extraction instead of `year_of_birth`. Do change the creatinine phosphokinase condition to `T2.CPK >= 250` instead of `creatinine_phosphokinase > 100`. Do apply the year filter to the formatted birthday year instead of a direct year field. The amended query now correctly joins patient and laboratory data while counting distinct patients with the specified criteria."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patients. 2) When the question mentions \"male patients\": use T1.SEX = 'M' instead of gender = 'Male'. 3) When extracting birth year from patient data: use STRFTIME('%Y', T1.Birthday) for year extraction instead of a direct year_of_birth field. 4) When filtering for patients born between 1936-1956: apply the year range filter to the formatted birthday year (STRFTIME('%Y', T1.Birthday) BETWEEN 1936 AND 1956). 5) When checking creatinine phosphokinase levels: use T2.CPK >= 250 instead of creatinine_phosphokinase > 100 to identify values beyond normal range. 6) When combining patient and laboratory data: perform an INNER JOIN between Patient AS T1 and Laboratory AS T2 tables using T1.ID = T2.ID to link matching records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE gender = 'Male' \nAND year_of_birth BETWEEN 1936 AND 1956 \nAND creatinine_phosphokinase > 100",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' \nAND STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' \nAND T2.CPK >= 250"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M'\nAND STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956'\nAND T2.CPK >= 250"
        ],
        "amend_res": 1
    },
    "916": {
        "db_id": "formula_1",
        "question": "Please list the surnames of all the Italian drivers.",
        "ground_truth": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
        "amends": [
            "Do select `surname` instead of `first_name` while keeping the same `WHERE nationality = 'Italian'` filter. The amended query now correctly retrieves driver surnames instead of first names for Italian drivers, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"surnames\" of drivers: use the exact column token \"surname\" from the drivers table. 2) When filtering for Italian drivers: use the exact literal value 'Italian' for the nationality column comparison. 3) When selecting output columns: ensure the output contains only the surname column as requested."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM drivers WHERE nationality = 'Italian';",
            "SELECT surname FROM drivers WHERE nationality = 'Italian';"
        ],
        "rule_sql": [
            "SELECT surname FROM drivers WHERE nationality = 'Italian';"
        ],
        "amend_res": 1
    },
    "73": {
        "db_id": "california_schools",
        "question": "What is the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a mailing street address of PO Box 1040?",
        "evidence": "",
        "ground_truth": "SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.MailStreet = 'PO Box 1040' AND T2.SOCType = 'Youth Authority Facilities'",
        "amends": [
            "Do select `FRPM Count (Ages 5-17)` from the `frpm` table instead of `free_or_reduced_price_meal_count` from the `schools` table. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T2.MailStreet = 'PO Box 1040'` instead of `mailing_street_address = 'PO Box 1040'`. Do filter on `T2.SOCType = 'Youth Authority Facilities'` instead of `school_name = 'Youth Authority School'` and remove the `age_range = '5-17'` filter. The amended query now correctly joins the appropriate tables and uses the proper column names and filter conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about free or reduced price meal count for ages 5 to 17: select \"FRPM Count (Ages 5-17)\" from table frpm as T1 instead of free_or_reduced_price_meal_count from schools table. 2) When the question mentions \"Youth Authority School\": \"Youth Authority School\" actually means T2.SOCType = 'Youth Authority Facilities' in schema. 3) When the question mentions mailing street address \"PO Box 1040\": use T2.MailStreet = 'PO Box 1040' instead of mailing_street_address = 'PO Box 1040'. 4) When combining T1 (frpm) and T2 (schools) for shared entities: link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match). 5) When filtering for age range: do not include age_range = '5-17' filter as this is already encoded in the \"FRPM Count (Ages 5-17)\" column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT free_or_reduced_price_meal_count FROM schools WHERE school_name = 'Youth Authority School' AND mailing_street_address = 'PO Box 1040' AND age_range = '5-17';",
            "SELECT T1.\"FRPM Count (Ages 5-17)\" \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.MailStreet = 'PO Box 1040' \nAND T2.SOCType = 'Youth Authority Facilities';"
        ],
        "rule_sql": [
            "SELECT T1.\"FRPM Count (Ages 5-17)\" \nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.SOCType = 'Youth Authority Facilities'\nAND T2.MailStreet = 'PO Box 1040'"
        ],
        "amend_res": 1
    },
    "1437": {
        "db_id": "student_club",
        "question": "Which members who were approved from 1/10/2019 to 11/19/2019? Please identify the member who attended the event and the link to their event.",
        "ground_truth": "SELECT DISTINCT T1.link_to_member, T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'",
        "amends": [
            "Do select `DISTINCT T1.link_to_member, T3.link_to_event` instead of `m.member_name, e.event_name, e.event_link`. Do use `FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member` instead of `FROM members m JOIN events e ON m.member_id = e.member_id`, adding the expense and attendance tables while removing the events table. Do filter with `date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true'` instead of `m.approval_date BETWEEN '2019-10-01' AND '2019-11-19' AND e.attended = 1`, changing the date range start from October to January and using approved status instead of attendance. The amended query now correctly retrieves distinct member and event links from the expense, member, and attendance tables with the proper date filtering and approval conditions."
        ],
        "rules": [
            "1) When answering about members approved from 1/10/2019 to 11/19/2019: use date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true' for filtering instead of approval_date and attended conditions. 2) When combining tables for this question: use FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member to link expense, member, and attendance tables. 3) When selecting output columns: choose DISTINCT T1.link_to_member, T3.link_to_event instead of member_name, event_name, and event_link. 4) When handling date ranges: ensure the start date is '2019-01-10' (January 10th) not '2019-10-01' (October 1st). 5) When checking approval status: use T1.approved = 'true' literal exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.member_name, e.event_name, e.event_link \nFROM members m \nJOIN events e ON m.member_id = e.member_id \nWHERE m.approval_date BETWEEN '2019-10-01' AND '2019-11-19' \nAND e.attended = 1;",
            "SELECT DISTINCT T1.link_to_member, T3.link_to_event\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nINNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member\nWHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19'\nAND T1.approved = 'true'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.link_to_member, T3.link_to_event\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nINNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member\nWHERE date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19'\nAND T1.approved = 'true';"
        ],
        "amend_res": 1
    },
    "789": {
        "db_id": "superhero",
        "question": "Find the average weight of the heroes who are aliens.",
        "ground_truth": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "amends": [
            "Do use `CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id)` instead of `AVG(height)` to calculate the average weight with proper casting. Do join `superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id` instead of querying a single `heroes` table to properly relate superhero and race data. Do filter on `T2.race = 'Alien'` instead of `species = 'alien'` to use the correct column name and table reference. Do reference `weight_kg` and `id` columns instead of `height` to calculate the intended metric. The amended query now correctly calculates average weight for Alien superheroes using proper table relationships and casting."
        ],
        "rules": [
            "1) When calculating average weight: use CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) instead of AVG(height) to properly handle casting and use the correct metric. 2) When relating superhero and race data: join superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id instead of querying a single heroes table. 3) When filtering for alien species: use T2.race = 'Alien' instead of species = 'alien' to reference the correct column name and table. 4) When referencing columns for calculation: use weight_kg and id columns instead of height to calculate the intended weight metric."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM heroes WHERE species = 'alien';",
            "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) AS average_weight\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Alien'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) AS average_weight\nFROM superhero AS T1\nINNER JOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Alien';"
        ],
        "amend_res": 1
    },
    "350": {
        "db_id": "card_games",
        "question": "State the alternative languages available for card named Annul numbered 29.",
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = 29",
        "amends": [
            "Do join `foreign_data AS T2` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do reference `T2.language` instead of just `language` from the base table. Do add the table alias `T1` to both `name` and `number` predicates instead of using unqualified column references. The amended query now correctly retrieves language data from the joined foreign_data table while maintaining the same filtering conditions on the cards table."
        ],
        "rules": [
            "1) When answering about alternative languages for a specific card: make sure the output order: T2.language 2) When the question mentions \"card named Annul numbered 29\": \"Annul\" actually means T1.name = 'Annul' and \"29\" actually means T1.number = '29' 3) When combining T1 (cards) and T2 (foreign_data) for shared entities: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation for 'Annul' and '29'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM cards WHERE name = 'Annul' AND number = 29;",
            "SELECT T2.language\nFROM cards AS T1\nJOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Annul' AND T1.number = '29';"
        ],
        "rule_sql": [
            "SELECT T2.language FROM cards T1 INNER JOIN foreign_data T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = '29' ORDER BY T2.language"
        ],
        "amend_res": 1
    },
    "374": {
        "db_id": "card_games",
        "question": "How many black border cards are only available on mtgo?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do remove the redundant `availability != 'paper'` filter instead of keeping it since `availability = 'mtgo'` already excludes paper. Do correct the column name to `borderColor` instead of `border_color` to match the actual schema. Do remove the unnecessary `AND availability = 'mtgo'` duplication instead of maintaining redundant conditions. The amended query now correctly counts MTGO cards with black borders."
        ],
        "rules": [
            "1) When counting cards: use the exact column \"id\" instead of counting all columns to avoid counting null values. 2) When filtering for black border cards: use the exact column name \"borderColor\" with the exact literal value 'black' instead of 'border_color'. 3) When filtering for MTGO availability: use the exact condition \"availability = 'mtgo'\" and do not include redundant conditions like \"availability != 'paper'\" since 'mtgo' already excludes paper. 4) When the question asks for cards \"only available on mtgo\": ensure the condition specifically checks for availability equal to 'mtgo' without additional redundant filters."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE border_color = 'black' AND availability = 'mtgo' AND availability != 'paper';",
            "SELECT COUNT(id) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo'"
        ],
        "amend_res": 1
    },
    "1368": {
        "db_id": "student_club",
        "question": "What does the person with the phone number \"809-555-3360\" major in?",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.phone = '809-555-3360'",
        "amends": [
            "Do select `T2.major_name` from the `major` table instead of `major` from the `persons` table. Do join `member AS T1` with `major AS T2` using `INNER JOIN` on `T1.link_to_major = T2.major_id` instead of querying a single table without any joins. Do filter on `T1.phone = '809-555-3360'` instead of filtering on `phone` from the original table. The amended query now correctly retrieves the major name through the proper table relationships and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks about a person's major based on phone number: use the \"member\" table as T1 and \"major\" table as T2 with T1 as the base table. 2) When joining T1 and T2: link rows where T1.link_to_major equals T2.major_id using an inner join to keep only matching pairs. 3) When filtering by phone number \"809-555-3360\": apply the condition T1.phone = '809-555-3360' exactly as specified. 4) When selecting the major information: output T2.major_name instead of any major column from the persons table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major FROM persons WHERE phone = '809-555-3360';",
            "SELECT T2.major_name \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T1.phone = '809-555-3360'"
        ],
        "rule_sql": [
            "SELECT T2.major_name \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T1.phone = '809-555-3360'"
        ],
        "amend_res": 1
    },
    "821": {
        "db_id": "superhero",
        "question": "List down Ajax's superpowers.",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Ajax'",
        "amends": [
            "Do select only `T3.power_name` instead of all columns with `*`. Do join three tables with `INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` and `INNER JOIN superpower AS T3 ON T2.power_id = T3.id` instead of querying a single table. Do filter on `T1.superhero_name = 'Ajax'` instead of `hero_name = 'Batman'`. The amended query now correctly retrieves power names for the specified superhero through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"Ajax's superpowers\": make sure the output order: T3.power_name. 2) When the question mentions \"Ajax\": \"Ajax\" actually means \"T1.superhero_name = 'Ajax'\" in schema. 3) When combining T1, T2, and T3 for shared entities: link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match). 4) When selecting output columns: use only T3.power_name instead of all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM superpowers WHERE hero_name = 'Batman';",
            "SELECT T3.power_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = 'Ajax'"
        ],
        "rule_sql": [
            "SELECT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T1.superhero_name = 'Ajax'\nORDER BY T3.power_name;"
        ],
        "amend_res": 1
    },
    "400": {
        "db_id": "card_games",
        "question": "Lists the set code of all cards translated into Spanish.",
        "ground_truth": "SELECT setCode FROM set_translations WHERE language = 'Spanish'",
        "amends": [
            "Do select `setCode` from the `set_translations` table instead of `set_code` from the `cards` table. Do filter on `language = 'Spanish'` in the `WHERE` clause instead of keeping the same filter condition but applying it to the wrong table. The amended query now correctly retrieves set codes from the translations table rather than attempting to find them in the cards table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"set code of all cards translated into Spanish\": select \"setCode\" from the \"set_translations\" table. 2) When filtering for Spanish translations: apply the condition language = 'Spanish' to the \"set_translations\" table. 3) When the question mentions \"translated into Spanish\": this means filtering for records where the language column equals 'Spanish' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT set_code FROM cards WHERE language = 'Spanish';",
            "SELECT DISTINCT setCode FROM set_translations WHERE language = 'Spanish';"
        ],
        "rule_sql": [
            "SELECT DISTINCT setCode FROM set_translations WHERE language = 'Spanish';"
        ],
        "amend_res": 1
    },
    "1342": {
        "db_id": "student_club",
        "question": "What was the cost for the \"Posters\" on 2019/9/4?",
        "ground_truth": "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04'",
        "amends": [
            "Do reference table `expense` instead of `expenses`. Do use column `expense_description` for filtering instead of `item`. Do use column `expense_date` for date filtering instead of `date`. Do use ISO date format `2019-09-04` instead of `2019/9/4` format. The amended query now correctly references the proper table and column names with appropriate date formatting."
        ],
        "rules": [
            "1) When the question asks about \"cost for Posters\": use the exact literal value 'Posters' for filtering the \"expense_description\" column. 2) When the question specifies a date \"2019/9/4\": convert it to ISO date format '2019-09-04' for filtering the \"expense_date\" column. 3) When referencing the expenses table: use the exact table name \"expense\" (singular) instead of \"expenses\". 4) When filtering by item description: use the column \"expense_description\" instead of \"item\". 5) When filtering by date: use the column \"expense_date\" instead of \"date\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT cost FROM expenses WHERE item = 'Posters' AND date = '2019/9/4';",
            "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04';"
        ],
        "rule_sql": [
            "SELECT cost FROM expense WHERE expense_description = 'Posters' AND expense_date = '2019-09-04';"
        ],
        "amend_res": 1
    },
    "242": {
        "db_id": "toxicology",
        "question": "Among all the atoms from 21 to 25, list all the molecules that are carcinogenic.",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25' AND T2.label = '+'",
        "amends": [
            "Do select `DISTINCT T2.molecule_id` instead of `molecule_name` from the wrong table. Do join `atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of querying only the `atoms` table without proper joins. Do filter with `SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25'` instead of `atomic_number BETWEEN 21 AND 25` to extract numeric values from string identifiers. Do use `T2.label = '+'` instead of `carcinogenic = 'yes'` for the correct condition on molecule properties. The amended query now properly identifies molecules containing specific atoms through proper table relationships and string manipulation."
        ],
        "rules": [
            "1) When answering about molecules containing atoms from 21 to 25: make sure the output order: T2.molecule_id\n2) When the question mentions \"atoms from 21 to 25\": extract the numeric part from T1.atom_id using SUBSTR(T1.atom_id, -2) and check if it is between '21' and '25'\n3) When the question mentions \"carcinogenic\": use T2.label = '+' as the condition for carcinogenic molecules\n4) When combining atom (T1) and molecule (T2) tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner join)\n5) When selecting molecule identifiers: use DISTINCT T2.molecule_id to avoid duplicate molecule entries\n6) When handling text literals: use exact string '21', '25', and '+' as shown in the amends without changing case or spacing"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_name FROM atoms WHERE atomic_number BETWEEN 21 AND 25 AND carcinogenic = 'yes';",
            "SELECT DISTINCT T2.molecule_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE SUBSTR(T1.atom_id, -2) BETWEEN '21' AND '25'\nAND T2.label = '+';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE CAST(SUBSTR(T1.atom_id, -2) AS INTEGER) BETWEEN 21 AND 25\nAND T2.label = '+'"
        ],
        "amend_res": 1
    },
    "754": {
        "db_id": "superhero",
        "question": "What is the superpower of hero ID 56?",
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56",
        "amends": [
            "Do select `T2.power_name` from the `superpower` table instead of `superpower` from the `heroes` table. Do join `hero_power AS T1` with `superpower AS T2` using `INNER JOIN` on `T1.power_id = T2.id` instead of querying only the `heroes` table. Do filter on `T1.hero_id = 56` instead of `hero_id = 56` from the wrong table. The amended query now correctly retrieves power names through proper table relationships instead of assuming the heroes table contains superpower data directly."
        ],
        "rules": [
            "1) When answering about \"superpower of hero ID 56\": make sure the output order: T2.power_name. 2) When the question mentions \"superpower\": \"superpower\" actually means \"T2.power_name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.power_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for hero ID 56: use T1.hero_id = 56 instead of hero_id from the wrong table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superpower FROM heroes WHERE hero_id = 56;",
            "SELECT T2.power_name \nFROM hero_power AS T1 \nINNER JOIN superpower AS T2 ON T1.power_id = T2.id \nWHERE T1.hero_id = 56"
        ],
        "rule_sql": [
            "SELECT T2.power_name \nFROM hero_power T1 \nINNER JOIN superpower T2 ON T1.power_id = T2.id \nWHERE T1.hero_id = 56"
        ],
        "amend_res": 1
    },
    "298": {
        "db_id": "toxicology",
        "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
        "amends": [
            "Do use `CAST` with `REAL` for percentage calculation instead of implicit decimal conversion. Do calculate percentage using `COUNT(CASE WHEN condition THEN value END)` with specific conditions instead of simple `COUNT(*)`. Do reference `T1.element = 'h'` and `T2.label = '+'` in the conditional count instead of `c.element = 'hydrogen'` and `c.is_carcinogenic = 1`. Do join `atom AS T1` and `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of joining `molecules` and `compounds` on `m.compound_id = c.id`. Do remove the subquery for total count and instead use `COUNT(T2.molecule_id)` in the denominator. Do reference tables `atom` and `molecule` instead of `molecules` and `compounds`. The amended query now correctly calculates the percentage of molecules meeting specific atomic conditions rather than compound properties, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating percentages: use CAST with REAL for percentage calculation instead of implicit decimal conversion. 2) When counting with conditions: use COUNT(CASE WHEN condition THEN value END) with specific conditions instead of simple COUNT(*). 3) When the question mentions \"element is hydrogen\": use T1.element = 'h' instead of 'hydrogen'. 4) When the question mentions \"carcinogenic compounds\": use T2.label = '+' instead of is_carcinogenic = 1. 5) When combining atom and molecule tables: join atom AS T1 and molecule AS T2 on T1.molecule_id = T2.molecule_id. 6) When calculating total count for percentage denominator: use COUNT(T2.molecule_id) instead of a subquery. 7) When referring to database entities: use tables atom and molecule instead of molecules and compounds."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM molecules)) AS percentage\nFROM molecules m\nJOIN compounds c ON m.compound_id = c.id\nWHERE c.element = 'hydrogen'\nAND c.is_carcinogenic = 1;",
            "SELECT \n    CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN 1 END) AS REAL) * 100.0 / COUNT(T2.molecule_id) AS percentage\nFROM \n    atom AS T1\nJOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id END) AS REAL) / \n     CAST(COUNT(T2.molecule_id) AS REAL)) * 100.0 AS percentage\nFROM \n    atom AS T1\nJOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T2.label = '+'"
        ],
        "amend_res": 1
    },
    "1310": {
        "db_id": "thrombosis_prediction",
        "question": "For the male patients that have a normal prothrombin time, what is their average prothrombin time?",
        "ground_truth": "SELECT AVG(T2.PT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PT < 14 AND T1.SEX = 'M'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of direct table references. Do join `Patient` and `Laboratory` tables with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do reference `T2.PT` instead of `prothrombin_time` for the aggregate calculation. Do filter with `T2.PT < 14` instead of `prothrombin_time > 15` for the threshold condition. Do use `T1.SEX = 'M'` instead of `gender = 'male'` for the gender filter. The amended query now correctly joins patient and laboratory data, uses the appropriate column names, and applies the correct threshold logic for prothrombin time values below 14 instead of above 15."
        ],
        "rules": [
            "1) When answering about male patients with normal prothrombin time: use table aliases T1 for Patient table and T2 for Laboratory table. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male'. 4) When filtering for normal prothrombin time: use T2.PT < 14 instead of prothrombin_time > 15. 5) When calculating average prothrombin time: use AVG(T2.PT) instead of AVG(prothrombin_time)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(prothrombin_time) FROM patients WHERE gender = 'male' AND prothrombin_time > 15;",
            "SELECT AVG(T2.PT) AS average_prothrombin_time\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.PT < 14"
        ],
        "rule_sql": [
            "SELECT AVG(T2.PT) FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.PT < 14"
        ],
        "amend_res": 1
    },
    "785": {
        "db_id": "superhero",
        "question": "Describe the names of neutral alignment superheroes.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and use table alias `T1` instead of direct column reference. Do add `INNER JOIN alignment AS T2` instead of querying only the superheroes table. Do join on `T1.alignment_id = T2.id` instead of filtering directly on alignment values. Do filter on `T2.alignment = 'Neutral'` instead of `alignment = 'good'` to correctly reference the joined table's column and use the proper alignment value. The amended query now properly joins tables and filters through the relationship rather than assuming alignment values exist directly in the superhero table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about superhero names: use the exact column token \"T1.superhero_name\" instead of \"name\". 2) When the question mentions \"neutral alignment\": join the alignment table as T2 using \"T1.alignment_id = T2.id\" to establish the relationship. 3) When filtering for neutral alignment: use the exact literal value 'Neutral' with \"T2.alignment = 'Neutral'\" instead of 'good'. 4) When combining superheroes and alignment tables: perform an inner join to keep only matching pairs where alignment relationships exist."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE alignment = 'good';",
            "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name FROM superhero T1 INNER JOIN alignment T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'"
        ],
        "amend_res": 1
    },
    "1258": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with a normal Rhuematoid Factor has a positive measure of degree of coagulation?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.RA = '-' OR T2.RA = '+-') AND T3.KCT = '+'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count distinct patients rather than all test records. Do reference tables `Patient AS T1`, `Laboratory AS T2`, and `Examination AS T3` instead of `patients p` and `lab_tests lt`, adding the required `Examination` table. Do use `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` and `INNER JOIN Examination AS T3 ON T3.ID = T2.ID` instead of a single join on `patient_id`, changing both the join conditions and adding the examination relationship. Do apply filter `(T2.RA = '-' OR T2.RA = '+-')` instead of `lt.rheumatoid_factor = 'normal'` to check for specific rheumatoid factor values. Do add filter `T3.KCT = '+'` instead of `lt.coagulation_degree = 'positive'` to check coagulation time with different criteria. The amended query now correctly counts distinct patients with specific laboratory findings and examination results."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count distinct patients rather than all test records. 2) When referencing tables: use Patient AS T1, Laboratory AS T2, and Examination AS T3 as the canonical table aliases. 3) When joining Patient and Laboratory tables: use INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to link rows where the ID values match exactly. 4) When joining Laboratory and Examination tables: use INNER JOIN Examination AS T3 ON T3.ID = T2.ID to link rows where the ID values match exactly. 5) When checking for normal rheumatoid factor: use (T2.RA = '-' OR T2.RA = '+-') instead of checking for 'normal' value. 6) When checking for positive coagulation degree: use T3.KCT = '+' instead of checking for 'positive' value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN lab_tests lt ON p.patient_id = lt.patient_id\nWHERE lt.rheumatoid_factor = 'normal' \nAND lt.coagulation_degree = 'positive';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE (T2.RA = '-' OR T2.RA = '+-')\nAND T3.KCT = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE (T2.RA = '-' OR T2.RA = '+-') \nAND T3.KCT = '+'"
        ],
        "amend_res": 1
    },
    "1095": {
        "db_id": "european_football_2",
        "question": "How much is the average build up play speed of the Heart of Midlothian team?",
        "ground_truth": "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Heart of Midlothian'",
        "amends": [
            "Do use `CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id)` instead of `AVG(build_up_play_speed)` to properly calculate the average with explicit casting. Do join `Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id` instead of querying a single `teams` table to access the attributes data. Do filter on `t1.team_long_name = 'Heart of Midlothian'` instead of `team_name = 'Heart of Midlothian'` to use the correct column name for team identification. The amended query now correctly joins the necessary tables and calculates the average build-up play speed with proper data type handling."
        ],
        "rules": [
            "1) When calculating average build up play speed: use CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) instead of AVG(build_up_play_speed) to properly handle data type casting. 2) When accessing team attributes data: join Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id to combine team information with attributes. 3) When filtering for Heart of Midlothian team: use t1.team_long_name = 'Heart of Midlothian' instead of team_name = 'Heart of Midlothian' to match the correct column name for team identification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(build_up_play_speed) FROM teams WHERE team_name = 'Heart of Midlothian';",
            "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) AS average_build_up_play_speed\nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t1.team_long_name = 'Heart of Midlothian'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) AS average_build_up_play_speed\nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t1.team_long_name = 'Heart of Midlothian';"
        ],
        "amend_res": 1
    },
    "258": {
        "db_id": "toxicology",
        "question": "What are the bond type for atoms with element Tin?",
        "ground_truth": "SELECT DISTINCT T3.bond_type FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id WHERE T1.element = 'sn'",
        "amends": [
            "Do use `DISTINCT T3.bond_type` instead of `bond_type` without distinct. Do join `atom AS T1` instead of querying `atoms` table directly. Do add `INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id` instead of omitting the connected table. Do add `INNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id` instead of omitting the bond table. Do use `T1.element = 'sn'` instead of `element = 'Tin'` with proper element symbol. The amended query now correctly joins through the connected table to find bond types for tin elements."
        ],
        "rules": [
            "1) When the question asks for bond types for atoms with element Tin: use the exact element symbol 'sn' instead of 'Tin' for filtering. 2) When querying about bond types: join through the connected table using T1.atom_id = T2.atom_id and then join to bond table using T3.bond_id = T2.bond_id. 3) When retrieving bond types: use DISTINCT T3.bond_type to avoid duplicate bond type values. 4) When combining tables for this query: perform inner joins between atom AS T1, connected AS T2, and bond AS T3 using the exact key relationships shown in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM atoms WHERE element = 'Tin';",
            "SELECT DISTINCT T3.bond_type\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nINNER JOIN bond AS T3 ON T3.bond_id = T2.bond_id\nWHERE T1.element = 'sn'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.bond_type\nFROM atom AS T1\nINNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id\nINNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE T1.element = 'sn'"
        ],
        "amend_res": 1
    },
    "1066": {
        "db_id": "european_football_2",
        "question": "What is the passing class of CLB team?",
        "ground_truth": "SELECT DISTINCT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_short_name = 'CLB'",
        "amends": [
            "Do select `DISTINCT t2.buildUpPlayPassingClass` instead of `passing_class` to retrieve the specific attribute from the joined table. Do use `Team AS t1 INNER JOIN Team_Attributes AS t2` instead of querying only the `teams` table to properly join the attributes data. Do join on `t1.team_api_id = t2.team_api_id` instead of missing the join condition entirely. Do filter on `t1.team_short_name = 'CLB'` instead of `team_name = 'CLB'` to use the correct column name for team identification. The amended query now correctly retrieves distinct build-up play passing class data by properly joining the team attributes table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"passing class of CLB team\": select DISTINCT t2.buildUpPlayPassingClass instead of passing_class to retrieve the specific attribute from the joined table. 2) When combining Team and Team_Attributes tables: use Team AS t1 INNER JOIN Team_Attributes AS t2 instead of querying only the teams table to properly join the attributes data. 3) When joining Team and Team_Attributes tables: link rows where t1.team_api_id = t2.team_api_id instead of missing the join condition entirely. 4) When filtering for team identification: use t1.team_short_name = 'CLB' instead of team_name = 'CLB' to use the correct column name for team identification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT passing_class FROM teams WHERE team_name = 'CLB';",
            "SELECT DISTINCT t2.buildUpPlayPassingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'CLB'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.buildUpPlayPassingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_short_name = 'CLB'"
        ],
        "amend_res": 1
    },
    "1478": {
        "db_id": "debit_card_specializing",
        "question": "Which segment had the least consumption?",
        "evidence": "",
        "ground_truth": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do use `T1.Segment` as the only column in the SELECT list instead of `segment` and `SUM(consumption) as total_consumption`. Do change the FROM clause to use `customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` instead of a single `energy_data` table. Do remove the explicit aggregation column from SELECT and instead use `SUM(T2.Consumption)` directly in the ORDER BY clause instead of referencing the alias `total_consumption`. Do change the sort order to `ASC` instead of `DESC` to find the minimum consumption segment rather than the maximum. The amended query now correctly joins customer and consumption data, aggregates by segment, and identifies the segment with the lowest total consumption, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"which segment had the least consumption\": make sure the output order: T1.Segment. 2) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match). 3) When the question asks for \"least consumption\": rank rows by SUM(T2.Consumption) in ascending order and keep the first 1 row. 4) When the question says \"by segment\": organize results by T1.Segment and compute SUM(T2.Consumption) per group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT segment, SUM(consumption) as total_consumption FROM energy_data GROUP BY segment ORDER BY total_consumption DESC LIMIT 1;",
            "SELECT T1.Segment\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nGROUP BY T1.Segment\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT c.Segment\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nGROUP BY c.Segment\nORDER BY SUM(ym.Consumption) ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1126": {
        "db_id": "european_football_2",
        "question": "State the name of players who came from Belgium.",
        "ground_truth": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
        "amends": [
            "Do select `t3.player_name` instead of `name`. Do add `Country AS t1` and `Match AS t2` tables instead of omitting them. Do use `INNER JOIN Match AS t2 ON t1.id = t2.country_id` instead of no join. Do use `INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id` instead of no join. Do filter on `t1.name = 'Belgium'` instead of `country = 'Belgium'`. The amended query now correctly joins through the Country and Match tables to find players from Belgium, matching the RIGHT_SQL's behavior.",
            "Do remove the second `UNION` query block that selects from `away_player_1` instead of keeping duplicate logic. Do maintain only the single query selecting from `home_player_1` instead of including both home and away players. Do preserve the `INNER JOIN` structure on `t1.id=t2.country_id` and `t2.home_player_1=t3.player_api_id` instead of altering the join conditions. Do keep the `WHERE t1.name='Belgium'` filter unchanged instead of modifying the country selection. The amended query now correctly returns only home players from Belgium matches instead of including both home and away players through union duplication."
        ],
        "rules": [
            "1) When answering about \"players who came from Belgium\": make sure the output order: t3.player_name. 2) When the question mentions \"Belgium\": \"Belgium\" actually means \"t1.name = 'Belgium'\" in schema. 3) When combining Country as t1 and Match as t2: link rows where t1.id = t2.country_id and keep only matching pairs (inner match). 4) When combining Match as t2 and Player as t3: link rows where t2.home_player_1 = t3.player_api_id and keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "1) When answering about \"players who came from Belgium\": make sure the output order: t3.player_name\n2) When the question mentions \"Belgium\": \"Belgium\" actually means t1.name = 'Belgium' in schema\n3) When combining Country as T1 and Match as T2: link rows where T1.id = T2.country_id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When combining Match as T2 and Player as T3: link rows where T2.home_player_1 = T3.player_api_id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When selecting players from Belgium matches: only include home players (T2.home_player_1) instead of both home and away players through union duplication"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE country = 'Belgium';",
            "SELECT t3.player_name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nWHERE t1.name = 'Belgium'\nUNION\nSELECT t3.player_name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.away_player_1 = t3.player_api_id\nWHERE t1.name = 'Belgium'",
            "SELECT DISTINCT t3.player_name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nWHERE t1.name = 'Belgium'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t3.player_name\nFROM Country AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.country_id\nINNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id\nWHERE t1.name = 'Belgium'\nORDER BY t3.player_name"
        ],
        "amend_res": 1
    },
    "408": {
        "db_id": "card_games",
        "question": "How many unknown power cards contain info about the triggered ability",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power = '*') AND T2.text LIKE '%triggered ability%'",
        "amends": [
            "Do select `T2.text` instead of `COUNT(*)` to return actual ruling text rather than just a count. Do add `INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid` instead of querying only the `cards` table to incorporate rulings data. Do change the table reference to `T1.power` with proper aliasing instead of unqualified `power`. Do expand the power filter to `T1.power IS NULL OR T1.power = '*'` instead of only `power IS NULL` to include cards with asterisk power values. Do move the text filter to `T2.text LIKE '%triggered ability%'` instead of `text LIKE '%triggered ability%'` to search within ruling text rather than card text. The amended query now correctly joins cards with their rulings and filters for triggered ability mentions in ruling text while including all cards with null or asterisk power values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"unknown power cards\": include cards where T1.power IS NULL OR T1.power = '*' to cover both null and asterisk power values. 2) When the question mentions \"contain info about the triggered ability\": search for '%triggered ability%' in T2.text rather than card text. 3) When combining cards and rulings tables: link rows where T1.uuid = T2.uuid using an inner match to find corresponding rulings for each card. 4) When the question asks for actual ruling text: return T2.text instead of counting results."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE power IS NULL AND text LIKE '%triggered ability%'",
            "SELECT T2.text\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE (T1.power IS NULL OR T1.power = '*')\nAND T2.text LIKE '%triggered ability%'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE (T1.power IS NULL OR T1.power = '*')\nAND T2.text LIKE '%triggered ability%'"
        ],
        "amend_res": 1
    },
    "101": {
        "db_id": "financial",
        "question": "List out the accounts who have the earliest trading date in 1995 ?",
        "evidence": "",
        "ground_truth": "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1",
        "amends": [
            "Do select only `account_id` instead of including `MIN(trade_date)` in the SELECT list. Do query from `trans` table instead of `trades` table. Do use `date` column instead of `trade_date` column for filtering and ordering. Do filter using `STRFTIME('%Y', date) = '1995'` instead of `YEAR(trade_date) = 1995`. Do remove the GROUP BY clause instead of grouping by `account_id`. Do order by `date ASC` directly instead of ordering by `MIN(trade_date) ASC`. Do keep the LIMIT 1 clause as it remains unchanged. The amended query now correctly retrieves the first account_id from 1995 transactions without unnecessary aggregation."
        ],
        "rules": [
            "1) When answering about \"accounts who have the earliest trading date in 1995\": make sure the output order: account_id only. 2) When the question mentions \"trades\" table: \"trades\" actually means \"trans\" in schema. 3) When the question mentions \"trade_date\" column: \"trade_date\" actually means \"date\" in schema. 4) When filtering for year 1995: use STRFTIME('%Y', date) = '1995' exactly as specified. 5) When finding the earliest date: order by date ASC directly without aggregation. 6) When limiting to the first result: keep LIMIT 1 to get only the top row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, MIN(trade_date) FROM trades WHERE YEAR(trade_date) = 1995 GROUP BY account_id ORDER BY MIN(trade_date) ASC LIMIT 1;",
            "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT account_id FROM trans WHERE STRFTIME('%Y', date) = '1995' ORDER BY date ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "925": {
        "db_id": "formula_1",
        "question": "Please give the link of the website that shows more information about the circuits the Spanish Grand Prix used in 2009.",
        "ground_truth": "SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [
            "Do select `T1.url` instead of `website` and use table alias `T1` instead of direct table reference. Do join `races AS T2` instead of querying only the `circuits` table, using `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of no join. Do filter on `T2.year = 2009` instead of `year = 2009` and add `T2.name = 'Spanish Grand Prix'` instead of `country = 'Spain'`. The amended query now correctly retrieves the circuit URL for the specific Spanish Grand Prix race in 2009 by properly joining the races table to identify the correct event."
        ],
        "rules": [
            "1) When answering about website links for circuits: use the exact column token \"T1.url\" instead of \"website\" for the output. 2) When the question mentions \"Spanish Grand Prix\": use the exact literal 'Spanish Grand Prix' for filtering in \"T2.name\". 3) When the question specifies year 2009: filter using \"T2.year = 2009\" instead of a direct year column in circuits. 4) When combining circuit and race information: perform an inner join between \"circuits AS T1\" and \"races AS T2\" using the exact key equality \"T2.circuitID = T1.circuitId\". 5) When the question asks about a specific Grand Prix event: filter by both the race name ('Spanish Grand Prix') and year (2009) in the races table rather than using country filtering in the circuits table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website FROM circuits WHERE country = 'Spain' AND year = 2009;",
            "SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'"
        ],
        "rule_sql": [
            "SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T2.name = 'Spanish Grand Prix' AND T2.year = 2009;"
        ],
        "amend_res": 1
    },
    "616": {
        "db_id": "codebase_community",
        "question": "What is the comment's rating score of the post which was created on 7/19/2010 7:19:56 PM",
        "ground_truth": "SELECT T1.Score FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.CreationDate = '2010-07-19 19:19:56.0'",
        "amends": [
            "Do select `T1.Score` instead of `rating` and use table alias `T1` instead of no alias. Do add `INNER JOIN posts AS T2` instead of querying only the comments table. Do use join condition `T1.PostId = T2.Id` instead of no join. Do filter on `T1.CreationDate` instead of `post_created` and use ISO format timestamp '2010-07-19 19:19:56.0' instead of '7/19/2010 7:19:56 PM'. The amended query now correctly joins tables and uses proper date formatting to match the intended behavior.",
            "Do filter on `T1.CreationDate` instead of `T2.CreationDate` to correctly query comments created on the specified date rather than posts created at that time. The amended query now matches RIGHT_SQL's behavior by fixing the table reference in the WHERE clause condition."
        ],
        "rules": [
            "1) When answering about comment rating score for a specific post creation date: make sure the output order: T1.Score 2) When the question mentions \"comment's rating score\": \"rating\" actually means \"T1.Score\" in schema 3) When the question mentions \"post which was created on 7/19/2010 7:19:56 PM\": filter using T2.CreationDate with exact ISO format timestamp '2010-07-19 19:19:56.0' instead of '7/19/2010 7:19:56 PM' 4) When combining comments table T1 and posts table T2: link rows where T1.PostId = T2.Id and keep only matching pairs (inner match) 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 6) When handling text literals: do not change case, spacing, or punctuation of timestamp '2010-07-19 19:19:56.0'",
            "1) When the question asks about a comment's rating score for a post created on a specific date: filter on the comment's creation date (T1.CreationDate) rather than the post's creation date (T2.CreationDate) to correctly identify comments created on the specified date. 2) When filtering by date '7/19/2010 7:19:56 PM': use the exact literal value '2010-07-19 19:19:56.0' as shown in the amends, preserving the exact timestamp format. 3) When joining comments (T1) and posts (T2): use the exact join condition T1.PostId = T2.Id to link comments to their corresponding posts."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT rating FROM comments WHERE post_created = '7/19/2010 7:19:56 PM'",
            "SELECT T1.Score \nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T2.CreationDate = '2010-07-19 19:19:56.0'",
            "SELECT T1.Score\nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T1.CreationDate = '2010-07-19 19:19:56.0'"
        ],
        "rule_sql": [
            "SELECT T1.Score\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.CreationDate = '2010-07-19 19:19:56.0'"
        ],
        "amend_res": 1
    },
    "737": {
        "db_id": "superhero",
        "question": "What is Copycat's race?",
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'",
        "amends": [
            "Do select `T2.race` from the `race` table instead of `race` from the `characters` table. Do join `superhero` as `T1` with `race` as `T2` on `T1.race_id = T2.id` instead of querying a single `characters` table. Do filter on `T1.superhero_name = 'Copycat'` instead of `name = 'Copycat'`. The amended query now correctly joins the superhero and race tables to retrieve race information through the proper relationship."
        ],
        "rules": [
            "1) When the question asks about a character's race: use the race table (T2) to get race information instead of the characters table. 2) When joining superhero table (T1) with race table (T2): link rows where T1.race_id equals T2.id. 3) When filtering for a specific superhero name like 'Copycat': use T1.superhero_name = 'Copycat' instead of name = 'Copycat'. 4) When selecting race information: output T2.race from the race table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race FROM characters WHERE name = 'Copycat';",
            "SELECT T2.race \nFROM superhero T1\nJOIN race T2 ON T1.race_id = T2.id\nWHERE T1.superhero_name = 'Copycat'"
        ],
        "rule_sql": [
            "SELECT r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.superhero_name = 'Copycat'"
        ],
        "amend_res": 1
    },
    "1530": {
        "db_id": "debit_card_specializing",
        "question": "Which are the top five best selling products? Please state the full name of them.",
        "ground_truth": "SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID ORDER BY T1.Amount DESC LIMIT 5",
        "amends": [
            "Do select `T2.Description` from the `products` table instead of `product_name` from the `products` table. Do join `transactions_1k AS T1` with `products AS T2` using an `INNER JOIN` on `T1.ProductID = T2.ProductID` instead of querying only the `products` table without any join. Do order by `T1.Amount DESC` instead of `sales DESC`. The amended query now correctly retrieves product descriptions based on transaction amounts rather than a sales column, matching the intended behavior.",
            "Do remove the `GROUP BY T2.Description` clause instead of grouping by description. Do remove the `SUM(T1.Amount)` aggregation instead of summing amounts. Do use `ORDER BY T1.Amount DESC` instead of ordering by the sum of amounts. The amended query now correctly shows individual transaction amounts in descending order rather than grouping and summing amounts by product description."
        ],
        "rules": [
            "1) When answering about \"top five best selling products\": make sure the output order: T2.Description. 2) When the question mentions \"best selling products\": \"best selling\" actually means \"highest transaction amounts in T1.Amount\". 3) When the question mentions \"top five\": rank rows by T1.Amount in descending order and keep the first 5 rows. 4) When combining T1 and T2 for shared entities: link rows where T1.ProductID = T2.ProductID exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"full name of them\": use T2.Description from the products table instead of product_name.",
            "1) When answering about \"top five best selling products\": make sure the output order: T2.Description 2) When the question mentions \"best selling products\": \"best selling\" actually means \"highest individual transaction amounts in T1.Amount\" in schema 3) When the question mentions \"top five\": rank rows by T1.Amount in descending direction and keep the first 5 rows 4) When combining T1 and T2 for shared entities: link rows where T1.ProductID = T2.ProductID exactly as shown; keep only matching pairs (inner match) 5) When producing output: do not group by T2.Description or aggregate T1.Amount with SUM function"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT product_name FROM products ORDER BY sales DESC LIMIT 5;",
            "SELECT T2.Description \nFROM transactions_1k AS T1\nINNER JOIN products AS T2 ON T1.ProductID = T2.ProductID\nGROUP BY T2.Description\nORDER BY SUM(T1.Amount) DESC\nLIMIT 5",
            "SELECT T2.Description \nFROM transactions_1k AS T1\nINNER JOIN products AS T2 ON T1.ProductID = T2.ProductID\nORDER BY T1.Amount DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT p.Description\nFROM transactions_1k t\nJOIN products p ON t.ProductID = p.ProductID\nORDER BY t.Amount DESC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "645": {
        "db_id": "codebase_community",
        "question": "How many negative comments were given by user ID 13?",
        "ground_truth": "SELECT COUNT(Id) FROM comments WHERE UserId = 13 AND Score < 60",
        "amends": [
            "Do count `Id` instead of `*` to exclude null values. Do filter by `Score < 60` instead of `comment_text LIKE '%negative%'` to use a numeric threshold rather than text pattern matching. Do reference `UserId` instead of `user_id` to use the correct column name. The amended query now correctly counts low-scoring comments for user 13 using proper column references and numeric filtering."
        ],
        "rules": [
            "1) When counting entities from the votes table: use the \"Id\" column instead of counting all columns to exclude null values. 2) When filtering for negative comments: use the condition \"Score < 60\" instead of text pattern matching to apply a numeric threshold. 3) When referencing user identification: use the exact column name \"UserId\" instead of \"user_id\" to match the schema. 4) When counting comments for a specific user: filter using \"UserId = 13\" to find comments by user ID 13."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE user_id = 13 AND comment_text LIKE '%negative%';",
            "SELECT COUNT(Id) FROM comments WHERE UserId = 13 AND Score < 60"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM comments WHERE UserId = 13 AND Score < 60;"
        ],
        "amend_res": 1
    },
    "1413": {
        "db_id": "student_club",
        "question": "Mention the zip code of member who incurred less than 50USD.",
        "ground_truth": "SELECT T1.zip FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.cost < 50",
        "amends": [
            "Do select `zip` from table `member` instead of `zip_code` from table `members`. Do use `INNER JOIN` with table `expense` on `member_id = link_to_member` instead of querying only the `members` table. Do filter on `cost < 50` from the joined `expense` table instead of filtering `incurred_amount > 50` from the original table. The amended query now correctly joins related tables and filters based on expense cost rather than member attributes, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"zip code of member\": select \"zip\" from table \"member\" instead of \"zip_code\" from table \"members\". 2) When combining member and expense data: use an inner join between \"member\" and \"expense\" tables where \"member_id = link_to_member\" to link related records. 3) When filtering for members who incurred less than 50USD: apply the condition \"cost < 50\" from the \"expense\" table instead of filtering on member attributes."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code FROM members WHERE incurred_amount > 50",
            "SELECT m.zip FROM member m INNER JOIN expense e ON m.member_id = e.link_to_member WHERE e.cost < 50"
        ],
        "rule_sql": [
            "SELECT m.zip FROM member m INNER JOIN expense e ON m.member_id = e.link_to_member WHERE e.cost < 50"
        ],
        "amend_res": 1
    },
    "1196": {
        "db_id": "thrombosis_prediction",
        "question": "What is the most common sign of patients with SLE disease?",
        "ground_truth": "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1",
        "amends": [
            "Do use table `Examination` instead of `patients` and column `Symptoms` instead of `sign` in the SELECT list and GROUP BY clause. Do reference column `Diagnosis` instead of `disease` in the WHERE filter condition. Do use aggregate function `COUNT(Symptoms)` instead of `COUNT(*)` in the ORDER BY clause while maintaining the same descending sort order and single row limit. The amended query now correctly retrieves the most frequent symptom for SLE diagnosis from the appropriate examination records.",
            "Do select only `Symptoms` instead of including `COUNT(Symptoms) as count` in the SELECT list. Do remove the explicit count column from the output while keeping the same GROUP BY and ORDER BY logic that uses the count for sorting purposes. The amended query now correctly returns only the symptom with the highest occurrence count for SLE diagnosis instead of returning both the symptom and its count."
        ],
        "rules": [
            "1) When answering about \"most common sign of patients with SLE disease\": use table \"Examination\" instead of \"patients\" and column \"Symptoms\" instead of \"sign\". 2) When filtering for SLE disease: use column \"Diagnosis\" with literal value 'SLE' in the WHERE condition. 3) When counting occurrences: use COUNT(\"Symptoms\") instead of COUNT(*) for aggregation. 4) When grouping results: group by \"Symptoms\" column. 5) When ordering by frequency: sort by the count in descending order. 6) When retrieving the most common: limit to 1 row to get the single most frequent result.",
            "1) When answering about \"most common sign of patients with SLE disease\": make sure the output order: Symptoms. 2) When the question mentions \"SLE disease\": \"SLE\" actually means \"Diagnosis = 'SLE'\" in schema. 3) When the question asks for \"most common sign\": rank rows by count of Symptoms in descending order and keep the first 1 row. 4) When the question asks for \"count of symptoms\": compute the number of rows using the Symptoms column. 5) When the question says \"per symptom\"/\"by symptom\": organize results by Symptoms and compute requested aggregates per group."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT sign, COUNT(*) as count FROM patients WHERE disease = 'SLE' GROUP BY sign ORDER BY count DESC LIMIT 1;",
            "SELECT Symptoms, COUNT(Symptoms) as count\nFROM Examination\nWHERE Diagnosis = 'SLE'\nGROUP BY Symptoms\nORDER BY COUNT(Symptoms) DESC\nLIMIT 1;",
            "SELECT Symptoms FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY COUNT(Symptoms) DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT Symptoms, COUNT(Symptoms) as count FROM Examination WHERE Diagnosis = 'SLE' GROUP BY Symptoms ORDER BY count DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "962": {
        "db_id": "formula_1",
        "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` instead of `COUNT(DISTINCT CASE WHEN condition THEN id END)` for conditional counting. Do join with `races` table on `raceId` instead of omitting it, and use the `year` column from `races` instead of from `results` in the WHERE filter. Do reference `laps` column from `results` instead of `lap` from `laptimes` table, and remove the unnecessary join to `laptimes` table. Do use `COUNT(*)` instead of `COUNT(DISTINCT driverId)` for the denominator calculation. Do add explicit `CAST` to `REAL` instead of using decimal notation for percentage calculation. Do use `STRFTIME('%Y', dob)` for year extraction instead of direct date comparison with `dob < '1985-01-01'`. The amended query now correctly calculates the percentage of drivers born before 1985 who completed more than 50 laps in races between 2000 and 2005."
        ],
        "rules": [
            "1) When answering about percentage of drivers born before 1985 with laps over 50 from 2000 to 2005: use SUM(IIF(condition, 1, 0)) instead of COUNT(DISTINCT CASE WHEN condition THEN id END) for conditional counting. 2) When combining tables for races between 2000 and 2005: join with races table on raceId and use the year column from races instead of results in the WHERE filter. 3) When checking lap numbers: reference laps column from results table instead of lap from laptimes table, and remove unnecessary join to laptimes table. 4) When calculating denominator for percentage: use COUNT(*) instead of COUNT(DISTINCT driverId). 5) When calculating percentage: add explicit CAST to REAL instead of using decimal notation. 6) When checking driver birth year: use STRFTIME('%Y', dob) for year extraction instead of direct date comparison with dob < '1985-01-01'."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(DISTINCT CASE WHEN d.dob < '1985-01-01' AND l.lap > 50 THEN d.driverId END) * 100.0 / \n     COUNT(DISTINCT d.driverId)) AS percentage\nFROM \n    drivers d\nJOIN \n    results r ON d.driverId = r.driverId\nJOIN \n    laptimes l ON r.raceId = l.raceId AND r.driverId = l.driverId\nWHERE \n    r.year BETWEEN 2000 AND 2005",
            "SELECT \n    CAST(SUM(IIF(STRFTIME('%Y', d.dob) < '1985' AND r.laps > 50, 1, 0)) AS REAL) / COUNT(*) * 100.0 AS percentage\nFROM \n    results r\nJOIN \n    drivers d ON r.driverId = d.driverId\nJOIN \n    races rc ON r.raceId = rc.raceId\nWHERE \n    rc.year BETWEEN 2000 AND 2005;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(IIF(STRFTIME('%Y', d.dob) < '1985' AND r.laps > 50, 1, 0)) AS REAL) / COUNT(*)) * 100 AS percentage\nFROM \n    results res\nJOIN \n    races ra ON res.raceId = ra.raceId\nJOIN \n    drivers d ON res.driverId = d.driverId\nWHERE \n    ra.year BETWEEN 2000 AND 2005"
        ],
        "amend_res": 1
    },
    "580": {
        "db_id": "codebase_community",
        "question": "Name 10 users with the badge name 'Necromancer.'",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10",
        "amends": [],
        "rules": [],
        "rule_res": 0,
        "amend_sql": [
            "SELECT u.DisplayName FROM Users u JOIN Badges b ON u.Id = b.UserId WHERE b.Name = 'Necromancer' LIMIT 10;"
        ],
        "rule_sql": [
            "SELECT u.Id, u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;",
            "SELECT u.Id, u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;",
            "SELECT u.Id, u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;",
            "SELECT u.Id, u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Necromancer'\nLIMIT 10;"
        ],
        "amend_res": 1
    },
    "236": {
        "db_id": "toxicology",
        "question": "What are the bond type and the atoms of the bond ID of TR001_6_9?",
        "ground_truth": "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_id = 'TR001_6_9'",
        "amends": [
            "Do specify table aliases `T1.bond_type` instead of unqualified `bond_type`, and do select `T2.atom_id` and `T2.atom_id2` instead of `atom1` and `atom2`. Do use `FROM bond AS T1 INNER JOIN connected AS T2` instead of `FROM bonds` alone, adding the `connected` table with an inner join. Do specify the join condition `ON T1.bond_id = T2.bond_id` instead of omitting any join. Do apply the filter to `T2.bond_id` instead of `bond_id` without table qualification. The amended query now correctly joins the bond and connected tables to retrieve the appropriate atom identifiers for the specified bond_id."
        ],
        "rules": [
            "1) When answering about bond type and atoms for a specific bond ID: make sure the output order: bond_type, atom_id, atom_id2. 2) When the question mentions \"bond type\": \"bond type\" actually means \"T1.bond_type\" in schema. 3) When the question mentions \"atoms of the bond\": \"atoms\" actually means \"T2.atom_id\" and \"T2.atom_id2\" in schema. 4) When combining T1 (bond) and T2 (connected) for shared bond entities: link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for a specific bond ID like 'TR001_6_9': apply the filter to T2.bond_id = 'TR001_6_9' using the exact literal value with proper case and punctuation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type, atom1, atom2 FROM bonds WHERE bond_id = 'TR001_6_9';",
            "SELECT T1.bond_type, T2.atom_id, T2.atom_id2 \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T2.bond_id = 'TR001_6_9'"
        ],
        "rule_sql": [
            "SELECT b.bond_type, c.atom_id, c.atom_id2\nFROM bond b\nINNER JOIN connected c ON b.bond_id = c.bond_id\nWHERE c.bond_id = 'TR001_6_9'"
        ],
        "amend_res": 1
    },
    "1038": {
        "db_id": "european_football_2",
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "ground_truth": "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "amends": [
            "Do join `League AS t1` with `Match AS t2` on `t1.id = t2.league_id` instead of querying `leagues` alone without any join. Do select `t1.name` instead of `league_name` and calculate total goals as `SUM(t2.home_team_goal) + SUM(t2.away_team_goal)` instead of simply `SUM(goals)`. Do group by `t1.name` instead of `league_name` and order by the calculated sum expression instead of the alias `total_goals`. The amended query now correctly aggregates match goals from the Match table joined with League, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"top 5 leagues in ascending order of the number of goals\": make sure the output order: t1.name, then the calculated total goals sum. 2) When the question mentions \"number of goals made\": goals actually means the sum of t2.home_team_goal and t2.away_team_goal from the Match table. 3) When combining League AS t1 and Match AS t2: link rows where t1.id = t2.league_id exactly and keep only matching pairs (inner match). 4) When the question asks for \"top 5\" in ascending order: rank rows by the calculated total goals sum in ascending order and keep the first 5 rows. 5) When grouping by league: organize results by t1.name and compute the sum of goals per league group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT league_name, SUM(goals) as total_goals \nFROM leagues \nGROUP BY league_name \nORDER BY total_goals ASC \nLIMIT 5;",
            "SELECT t1.name, SUM(t2.home_team_goal) + SUM(t2.away_team_goal) AS total_goals\nFROM League AS t1\nJOIN Match AS t2 ON t1.id = t2.league_id\nGROUP BY t1.name\nORDER BY total_goals ASC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT t1.name, SUM(t2.home_team_goal + t2.away_team_goal) AS total_goals\nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nGROUP BY t1.name\nORDER BY total_goals ASC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "4": {
        "db_id": "california_schools",
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "ground_truth": "SELECT T2.Phone FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`Charter School (Y/N)` = 1 AND T2.OpenDate > '2000-01-01'",
        "amends": [
            "Do select `T2.Phone` instead of `phone_number` and use table alias `T2` instead of direct table reference. Do join `frpm AS T1` with `schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T1.Charter Funding Type = 'Directly funded'` and `T1.Charter School (Y/N) = 1` instead of `funding_type = 'charter'`. Do use `T2.OpenDate > '2000-01-01'` instead of `opened_date > '2000-01-01'` while maintaining the same date filter logic. The amended query now correctly joins the frpm and schools tables to identify charter schools with direct funding and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about phone numbers of direct charter-funded schools: use \"T2.Phone\" as the output column instead of \"phone_number\". 2) When combining frpm and schools tables: link rows where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match). 3) When filtering for charter funding type: use \"T1.Charter Funding Type = 'Directly funded'\" exactly as specified. 4) When identifying charter schools: use \"T1.Charter School (Y/N) = 1\" to filter for charter schools. 5) When filtering for schools opened after 2000/1/1: use \"T2.OpenDate > '2000-01-01'\" with the exact date format and comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM schools WHERE funding_type = 'charter' AND opened_date > '2000-01-01';",
            "SELECT T2.Phone\nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter Funding Type\" = 'Directly funded'\n  AND T1.\"Charter School (Y/N)\" = 1\n  AND T2.OpenDate > '2000-01-01'"
        ],
        "rule_sql": [
            "SELECT T2.Phone\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter School (Y/N)\" = 1\nAND T1.\"Charter Funding Type\" = 'Directly funded'\nAND T2.OpenDate > '2000-01-01'"
        ],
        "amend_res": 1
    },
    "184": {
        "db_id": "financial",
        "question": "How many female customers have a junior credit card?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T1.gender = 'F' AND T3.type = 'junior'",
        "amends": [
            "Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific client records. Do join tables `client AS T1`, `disp AS T2`, and `card AS T3` instead of querying a single `customers` table. Do use `INNER JOIN` on `T1.client_id = T2.client_id` and `T2.disp_id = T3.disp_id` instead of no joins. Do filter on `T1.gender = 'F'` instead of `gender = 'male'` to target female clients. Do filter on `T3.type = 'junior'` instead of `credit_card_type = 'junior'` to check card type from the correct table. The amended query now correctly counts female clients with junior cards through proper table relationships."
        ],
        "rules": [
            "1) When counting clients: use COUNT(T1.client_id) instead of COUNT(*) to count specific client records. 2) When combining client, disp, and card tables: link rows where T1.client_id = T2.client_id and T2.disp_id = T3.disp_id using inner joins. 3) When filtering for female clients: use T1.gender = 'F' instead of gender = 'male'. 4) When filtering for junior credit cards: use T3.type = 'junior' instead of credit_card_type = 'junior' to check from the correct table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM customers WHERE gender = 'male' AND credit_card_type = 'junior';",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN card AS T3 ON T2.disp_id = T3.disp_id\nWHERE T1.gender = 'F' AND T3.type = 'junior'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN card T3 ON T2.disp_id = T3.disp_id\nWHERE T1.gender = 'F' AND T3.type = 'junior'"
        ],
        "amend_res": 1
    },
    "548": {
        "db_id": "codebase_community",
        "question": "What is the location of the owner of the post \"Eliciting priors from experts\"?",
        "ground_truth": "SELECT T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "amends": [
            "Do select `T2.Location` from the `users` table instead of `location` from the `users` table. Do add a `posts` table as `T1` and join it with `users` as `T2` using `INNER JOIN` on `T1.OwnerUserId = T2.Id` instead of querying only the `users` table without any join. Do filter on `T1.Title` instead of `post_title` since the title column exists in the posts table rather than the users table. The amended query now correctly retrieves user locations by joining with the posts table where the specific title matches, ensuring the result matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the location of the owner of a specific post: select \"T2.Location\" from the users table instead of \"location\" from the users table. 2) When combining posts and users tables: add a posts table as T1 and join it with users as T2 using inner join on T1.OwnerUserId = T2.Id instead of querying only the users table without any join. 3) When filtering by post title: filter on T1.Title instead of post_title since the title column exists in the posts table rather than the users table. 4) When matching a specific post title: use the exact literal 'Eliciting priors from experts' with the correct case and spacing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM users WHERE post_title = 'Eliciting priors from experts';",
            "SELECT T2.Location \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Title = 'Eliciting priors from experts'"
        ],
        "rule_sql": [
            "SELECT T2.Location FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'"
        ],
        "amend_res": 1
    },
    "304": {
        "db_id": "toxicology",
        "question": "List all carcinogenic molecules and their elements.",
        "ground_truth": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do select `T2.molecule_id` and `T1.element` instead of `molecule_name` and `element`. Do add table `atom AS T1` and `molecule AS T2` instead of just `molecules`. Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of no join. Do filter on `T2.label = '+'` instead of `carcinogenic = 'no'`. Do add `DISTINCT` instead of omitting it. The amended query now correctly joins atom and molecule tables to find distinct molecule IDs with positive labels."
        ],
        "rules": [
            "1) When answering about \"carcinogenic molecules and their elements\": make sure the output order: T2.molecule_id, T1.element\n2) When the question mentions \"carcinogenic\": \"carcinogenic\" actually means \"T2.label = '+' in schema\"\n3) When combining T1 (atom) and T2 (molecule) for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)\n4) When the question asks for \"distinct molecules\": compute the number of unique values of T2.molecule_id\n5) When handling text literals: do not change case, spacing, or punctuation - use exactly '+' for the carcinogenic label"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_name, element FROM molecules WHERE carcinogenic = 'no';",
            "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id, T1.element\nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+'"
        ],
        "amend_res": 1
    },
    "517": {
        "db_id": "card_games",
        "question": "How many rare enchantment Abundance cards are there whose play format status are all legal?",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.rarity = 'rare' AND T1.types = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal'",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `legalities AS T2` with `INNER JOIN` on `T2.uuid = T1.uuid` instead of querying only the `cards` table. Do reference `T1.types` with value 'Enchantment' instead of `type` with value 'enchantment' to match the correct column name and case. Do filter on `T2.status = 'Legal'` instead of `play_format_status = 'legal'` to use the correct table and column for legality status. The amended query now correctly joins the cards and legalities tables to count rare Enchantment cards named Abundance that have legal status.",
            "Do use `T1.types = 'Enchantment'` instead of `T1.types LIKE '%Enchantment%'` for exact string matching. Do use lowercase `'rare'` instead of `'Rare'` for the rarity value. Do maintain the same join condition `T2.uuid = T1.uuid` and keep all other filters including `T1.name = 'Abundance'` and `T2.status = 'Legal'` unchanged. The amended query now correctly uses exact equality comparisons instead of pattern matching and consistent case sensitivity, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting cards: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"play format status\": this actually means T2.status in the legalities table. 3) When filtering for legal status: use T2.status = 'Legal' with exact case matching. 4) When filtering for card type: use T1.types = 'Enchantment' with exact case matching instead of 'enchantment'. 5) When combining cards and legalities tables: link rows where T2.uuid = T1.uuid using inner join to keep only matching pairs. 6) When the question asks about cards with specific properties: include filters for T1.rarity = 'rare' and T1.name = 'Abundance'.",
            "1) When the question mentions \"rare\" rarity: use the exact literal value 'rare' (lowercase) for rarity comparison. 2) When the question mentions \"enchantment\" type: use exact string equality comparison with T1.types = 'Enchantment' instead of pattern matching. 3) When combining cards (T1) and legalities (T2) tables: link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match). 4) When filtering for cards named 'Abundance': use exact string equality T1.name = 'Abundance'. 5) When filtering for legal status: use exact string equality T2.status = 'Legal'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE rarity = 'rare' AND type = 'enchantment' AND name = 'Abundance' AND play_format_status = 'legal';",
            "SELECT COUNT(T1.id) \nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T2.uuid = T1.uuid\nWHERE T1.name = 'Abundance'\nAND T1.rarity = 'Rare'\nAND T1.types LIKE '%Enchantment%'\nAND T2.status = 'Legal'",
            "SELECT COUNT(T1.id) \nFROM cards AS T1\nINNER JOIN legalities AS T2 ON T2.uuid = T1.uuid\nWHERE T1.name = 'Abundance'\nAND T1.types = 'Enchantment'\nAND T1.rarity = 'rare'\nAND T2.status = 'Legal'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.rarity = 'rare' \nAND T1.types = 'Enchantment' \nAND T1.name = 'Abundance' \nAND T2.status = 'Legal'"
        ],
        "amend_res": 1
    },
    "681": {
        "db_id": "codebase_community",
        "question": "Please list the users' display names whose posts had over 20000 views in 2011.",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE STRFTIME('%Y', T2.CreaionDate) = '2011' AND T2.ViewCount > 20000",
        "amends": [
            "Do add `INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId` instead of querying only the `users` table. Do change the filter to `STRFTIME('%Y', T2.CreationDate) = '2011'` instead of `year = 2011` to properly extract the year from the post creation date. Do change the view count filter to `T2.ViewCount > 20000` instead of `post_views > 20000` to reference the correct column from the posts table. Do use `T1.DisplayName` with proper table alias instead of `display_name` for consistent naming. The amended query now correctly joins users with their posts and filters based on post creation year and view count, matching the intended behavior.",
            "Do remove `DISTINCT` instead of keeping it. Do reorder the WHERE clause predicates to place `STRFTIME('%Y', T2.CreationDate) = '2011'` before `T2.ViewCount > 20000` instead of the reverse order. The amended query now matches RIGHT_SQL's behavior by eliminating unnecessary distinct filtering and maintaining the same logical filtering conditions.",
            "Do correct the typo in `T2.CreationDate` instead of `T2.CreaionDate` to properly reference the column name. The amended query now matches RIGHT_SQL's behavior with the correct column reference.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause STRFTIME function. The amended query now correctly filters posts by their creation year and matches the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause's STRFTIME function. The amended query now correctly filters posts by their creation year and matches the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause STRFTIME function. The amended query now correctly filters posts by their creation year and matches the RIGHT_SQL's behavior.",
            "Do use the correct column name `T2.CreationDate` instead of the misspelled `T2.CreaionDate` in the WHERE clause STRFTIME function. The amended query now correctly filters posts by their creation year and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT display_name FROM users WHERE post_views > 20000 AND year = 2011;",
            "SELECT DISTINCT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE T2.ViewCount > 20000\nAND STRFTIME('%Y', T2.CreationDate) = '2011'",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011'\nAND T2.ViewCount > 20000",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011'\nAND T2.ViewCount > 20000",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011'\nAND T2.ViewCount > 20000",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011'\nAND T2.ViewCount > 20000",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011'\nAND T2.ViewCount > 20000",
            "SELECT T1.DisplayName\nFROM users AS T1\nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nWHERE STRFTIME('%Y', T2.CreationDate) = '2011'\nAND T2.ViewCount > 20000"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "478": {
        "db_id": "card_games",
        "question": "What is card number 4 in the set Coldsnap?",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
        "amends": [
            "Do select only `T1.name` instead of all columns with `*`. Do join `sets AS T2` instead of querying only the `cards` table. Do use `INNER JOIN` on `T2.code = T1.setCode` instead of filtering directly on `set_name`. Do filter on `T2.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'`. Do filter on `T1.number = 4` instead of `card_number = 4`. The amended query now correctly joins the sets table to validate the set name and retrieves only the card name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"card number 4 in the set Coldsnap\": make sure the output order: T1.name. 2) When combining cards table T1 and sets table T2: link rows where T2.code = T1.setCode and keep only matching pairs (inner match). 3) When the question mentions \"set Coldsnap\": \"Coldsnap\" actually means T2.name = 'Coldsnap' in schema. 4) When the question mentions \"card number 4\": \"card number 4\" actually means T1.number = 4 in schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE set_name = 'Coldsnap' AND card_number = 4;",
            "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = '4'"
        ],
        "rule_sql": [
            "SELECT T1.name FROM cards T1 INNER JOIN sets T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = '4'"
        ],
        "amend_res": 1
    },
    "1314": {
        "db_id": "student_club",
        "question": "Please list the full names of the students in the Student_Club that come from the Art and Design Department.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'",
        "amends": [
            "Do select from `member` and `major` tables instead of `Students` and `Student_Club`. Do use `INNER JOIN` on `link_to_major = major_id` instead of `JOIN` on `student_id = student_id`. Do filter on `department = 'Art and Design Department'` instead of `department = 'Art and Design'`. Do reference columns from the `member` table (aliased as `T1`) instead of the `Students` table. The amended query now correctly joins member records with their major information and filters by the specific department name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about students in Student_Club from Art and Design Department: use the \"member\" table as T1 and \"major\" table as T2 instead of \"Students\" and \"Student_Club\" tables. 2) When combining member and major tables: link rows where T1.\"link_to_major\" = T2.\"major_id\" using inner join. 3) When filtering by department: use the exact literal 'Art and Design Department' instead of 'Art and Design'. 4) When selecting student names: reference columns from the \"member\" table (T1) instead of the \"Students\" table."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT s.first_name, s.last_name FROM Students s JOIN Student_Club sc ON s.student_id = sc.student_id WHERE s.department = 'Art and Design'",
            "SELECT T1.first_name, T1.last_name FROM member T1 INNER JOIN major ON T1.link_to_major = major.major_id WHERE major.department = 'Art and Design Department'"
        ],
        "rule_sql": [
            "SELECT T1.first_name || ' ' || T1.last_name AS full_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'Art and Design Department';"
        ],
        "amend_res": 1
    },
    "528": {
        "db_id": "card_games",
        "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
        "ground_truth": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
        "amends": [
            "Do `SELECT DISTINCT` with `T2.name` and a `CASE` expression that returns `T1.format` when `T1.status = 'Legal'` instead of selecting `c.name` and `f.format_name` directly. Do join `legalities AS T1` with `cards AS T2` on `T2.uuid = T1.uuid` instead of joining on `c.id = l.card_id` and `l.format_id = f.id`. Do use a subquery in the `WHERE` clause to filter by `T2.setCode IN (SELECT code FROM sets WHERE name = 'Hour of Devastation')` instead of directly filtering on `c.set_name = 'Hour of Devastation'`. Do remove the explicit `AND l.legality = 'legal'` filter instead of keeping it, as the logic is now handled by the `CASE` expression that checks `T1.status = 'Legal'`. The amended query now correctly handles the set filtering through the sets table and properly distinguishes legal cards using the CASE expression, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cards in a specific set: filter cards using the set code from the sets table where the set name matches 'Hour of Devastation' exactly. 2) When joining legalities and cards tables: link rows where T2.uuid = T1.uuid exactly as shown in the schema. 3) When determining legal formats: use a CASE expression that returns T1.format only when T1.status equals 'Legal' exactly. 4) When selecting card names and formats: use SELECT DISTINCT to return unique combinations of T2.name and the CASE expression result. 5) When filtering by set name: use a subquery with T2.setCode IN (SELECT code FROM sets WHERE name = 'Hour of Devastation') instead of direct set_name comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, f.format_name \nFROM cards c \nJOIN legalities l ON c.id = l.card_id \nJOIN formats f ON l.format_id = f.id \nWHERE c.set_name = 'Hour of Devastation' \nAND l.legality = 'legal';",
            "SELECT DISTINCT T2.name,\n       CASE \n           WHEN T1.status = 'Legal' THEN T1.format \n           ELSE NULL \n       END AS legal_format\nFROM legalities AS T1\nJOIN cards AS T2 ON T2.uuid = T1.uuid\nWHERE T2.setCode IN (SELECT code FROM sets WHERE name = 'Hour of Devastation');"
        ],
        "rule_sql": [
            "SELECT DISTINCT \n    c.name,\n    CASE \n        WHEN l.status = 'Legal' THEN l.format \n        ELSE NULL \n    END AS legal_format\nFROM \n    cards c\nJOIN \n    legalities l ON c.uuid = l.uuid\nWHERE \n    c.setCode IN (SELECT code FROM sets WHERE name = 'Hour of Devastation')\nORDER BY \n    c.name, legal_format;"
        ],
        "amend_res": 1
    },
    "347": {
        "db_id": "card_games",
        "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
        "ground_truth": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
        "amends": [
            "Do select `T1.id` and `T1.hasContentWarning` instead of `c.name` and a hardcoded `'missing' as property_status`. Do use `INNER JOIN` instead of `JOIN` and join on `T1.uuid = T2.uuid` instead of `c.id = r.card_id`. Do filter on `T1.artist = 'Stephen Daniele'` instead of `c.illustrator = 'Stephen Daniel'` to match the correct artist name spelling. The amended query now correctly selects actual card properties and joins on UUID while using the proper artist filter.",
            "Do use `T2.text` without an alias instead of `T2.text as ruling_text` in the SELECT list. Do maintain the same `INNER JOIN` on `T1.uuid = T2.uuid` and identical `WHERE T1.artist = 'Stephen Daniele'` filter. The amended query now correctly selects the raw text column without unnecessary aliasing while preserving the same join logic and filtering behavior.",
            "Do reorder the SELECT list to `T1.id, T2.text, T1.hasContentWarning` instead of `T1.id, T1.hasContentWarning, T2.text`. Do add the `AS` keyword for table aliases by specifying `cards AS T1` instead of just `cards T1`. The amended query now correctly matches the RIGHT_SQL's behavior with identical column ordering and proper table alias syntax."
        ],
        "rules": [
            "1) When selecting card information: include T1.id and T1.hasContentWarning instead of c.name and a hardcoded 'missing' value. 2) When joining cards and rulings tables: use INNER JOIN with the exact join condition T1.uuid = T2.uuid. 3) When filtering by artist: use the exact literal 'Stephen Daniele' for T1.artist instead of 'Stephen Daniel'.",
            "1) When the question asks for cards illustrated by Stephen Daniel: filter the cards table where T1.artist equals 'Stephen Daniele' exactly. 2) When combining cards and rulings tables: link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match). 3) When selecting output columns: include T1.id, T1.hasContentWarning, and T2.text without aliasing the text column. 4) When the question asks about missing or degraded properties: include T1.hasContentWarning in the output to indicate content warning status.",
            "1) When answering about \"cards illustrated by Stephen Daniel and their rulings\": make sure the output order is T1.id, T2.text, T1.hasContentWarning. 2) When specifying table aliases: use the exact syntax \"cards AS T1\" instead of \"cards T1\". 3) When the question mentions \"Stephen Daniel\": the exact literal value to match is 'Stephen Daniele' (case-sensitive). 4) When combining cards and rulings tables: link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, r.text, 'missing' as property_status FROM cards c JOIN rulings r ON c.id = r.card_id WHERE c.illustrator = 'Stephen Daniel'",
            "SELECT \n    T1.id,\n    T1.hasContentWarning,\n    T2.text as ruling_text\nFROM \n    cards T1\nINNER JOIN \n    rulings T2 ON T1.uuid = T2.uuid\nWHERE \n    T1.artist = 'Stephen Daniele';",
            "SELECT T1.id, T1.hasContentWarning, T2.text\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele'",
            "SELECT T1.id, T2.text, T1.hasContentWarning\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele'"
        ],
        "rule_sql": [
            "SELECT T1.id, T2.text, T1.hasContentWarning\nFROM cards AS T1\nINNER JOIN rulings AS T2 ON T1.uuid = T2.uuid\nWHERE T1.artist = 'Stephen Daniele'\nORDER BY T1.id, T2.text, T1.hasContentWarning"
        ],
        "amend_res": 1
    },
    "89": {
        "db_id": "financial",
        "question": "How many accounts who choose issuance after transaction are staying in East Bohemia region?",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A3 = 'east Bohemia' AND T2.frequency = 'POPLATEK PO OBRATU'",
        "amends": [
            "Do add table `district AS T1` and `account AS T2` with an `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table without proper joins. Do change the count expression to `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific account identifiers. Do replace the region filter with `T1.A3 = 'east Bohemia'` instead of `region = 'East Bohemia'` to reference the correct table and column with proper case sensitivity. Do replace the date comparison condition with `T2.frequency = 'POPLATEK PO OBRATU'` instead of `issuance_date > transaction_date` to filter by account frequency rather than date logic. The amended query now correctly joins district and account tables to count accounts with the specified frequency in the east Bohemia region, matching the intended behavior."
        ],
        "rules": [
            "1) When combining district and account tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match). 2) When counting accounts: compute the number of rows using T2.account_id as the counting key. 3) When the question mentions \"East Bohemia region\": \"East Bohemia\" actually means T1.A3 = 'east Bohemia' with exact case sensitivity. 4) When the question mentions \"choose issuance after transaction\": this actually means T2.frequency = 'POPLATEK PO OBRATU' with exact literal value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE region = 'East Bohemia' AND issuance_date > transaction_date;",
            "SELECT COUNT(T2.account_id) \nFROM district AS T1 \nINNER JOIN account AS T2 ON T1.district_id = T2.district_id \nWHERE T1.A3 = 'east Bohemia' \nAND T2.frequency = 'POPLATEK PO OBRATU'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT a.account_id) \nFROM district d\nINNER JOIN account a ON d.district_id = a.district_id\nWHERE d.A3 = 'east Bohemia' \nAND a.frequency = 'POPLATEK PO OBRATU'"
        ],
        "amend_res": 1
    },
    "988": {
        "db_id": "formula_1",
        "question": "List down top 3 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "ground_truth": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 3",
        "amends": [
            "Do use `T2.forename` and `T2.surname` instead of `d.forename` and `d.surname` for column references. Do reference `pitStops AS T1` instead of `pit_stops ps` for the table name and alias. Do use `INNER JOIN` instead of `JOIN` for explicit join type. Do reference `drivers AS T2` instead of `drivers d` for the table alias. Do use `STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'` instead of `d.dob BETWEEN '1980-01-01' AND '1985-12-31'` for proper year extraction and comparison. Do group by `T2.forename, T2.surname` instead of `d.driverId` to match the selected non-aggregated columns. Do order by `AVG(T1.duration)` instead of `avg_pitstop_duration` to use the aggregate function directly rather than the alias. Do remove the explicit alias `avg_pitstop_duration` instead of keeping it since it's not referenced in the ORDER BY. The amended query now correctly handles year-based filtering and proper grouping semantics to match the RIGHT_SQL's behavior.",
            "Do remove `AVG(T1.duration) AS avg_pitstop_duration` from the SELECT list instead of including it, as the RIGHT_SQL only returns driver names without the average calculation. Do keep the same `FROM pitStops AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId` structure instead of changing it, as the join logic remains identical. Do maintain the `WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'` filters instead of altering them, as the filtering conditions are unchanged. Do preserve the `GROUP BY T2.forename, T2.surname` clause instead of modifying it, since the grouping remains necessary for the ORDER BY operation. Do keep `ORDER BY AVG(T1.duration)` without the `ASC` keyword instead of including it, as the default ascending order is implied. Do maintain `LIMIT 3` without change instead of altering it. The amended query now correctly returns only German drivers born between 1980-1985 ordered by their average pitstop duration without displaying the calculated average value."
        ],
        "rules": [
            "1) When the question mentions \"German drivers\": use \"T2.nationality = 'German'\" with exact literal 'German'. 2) When filtering by birth years 1980-1985: extract year from T2.dob using STRFTIME('%Y', T2.dob) and check BETWEEN '1980' AND '1985'. 3) When combining pit stops and drivers tables: use INNER JOIN where T1.driverId = T2.driverId. 4) When computing average pit stop duration: calculate AVG(T1.duration). 5) When grouping results: group by T2.forename, T2.surname to match output columns. 6) When ordering by shortest average pit stop duration: order by AVG(T1.duration) in ASCending order. 7) When selecting top 3: limit to 3 rows after ordering. 8) When outputting driver names: use T2.forename and T2.surname as the exact column references.",
            "1) When answering about \"top 3 German drivers with shortest average pit stop duration born between 1980-1985\": make sure the output order includes only T2.forename and T2.surname without displaying the average calculation. 2) When the question mentions \"German drivers\": filter using T2.nationality = 'German' exactly as specified. 3) When the question mentions \"born between 1980-1985\": filter using STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' with exact year literals. 4) When the question asks for \"shortest average pit stop duration\": compute AVG(T1.duration) for ordering but do not include it in the final output. 5) When the question asks for \"top 3\": rank rows by AVG(T1.duration) in ascending order and keep the first 3 rows. 6) When combining T1 (pitStops) and T2 (drivers): link rows where T1.driverId = T2.driverId exactly as shown; keep only matching pairs (inner match). 7) When grouping by driver: organize results by T2.forename and T2.surname to compute the average per driver."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, AVG(ps.duration) as avg_pitstop_duration\nFROM drivers d\nJOIN pit_stops ps ON d.driverId = ps.driverId\nWHERE d.nationality = 'German' \nAND d.dob BETWEEN '1980-01-01' AND '1985-12-31'\nGROUP BY d.driverId\nORDER BY avg_pitstop_duration ASC\nLIMIT 3;",
            "SELECT T2.forename, T2.surname, AVG(T1.duration) AS avg_pitstop_duration\nFROM pitStops AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'\nGROUP BY T2.forename, T2.surname\nORDER BY AVG(T1.duration) ASC\nLIMIT 3;",
            "SELECT T2.forename, T2.surname\nFROM pitStops AS T1\nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'\nGROUP BY T2.forename, T2.surname\nORDER BY AVG(T1.duration)\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T2.forename, T2.surname\nFROM pitStops T1\nINNER JOIN drivers T2 ON T1.driverId = T2.driverId\nWHERE T2.nationality = 'German'\nAND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985'\nGROUP BY T2.forename, T2.surname\nORDER BY AVG(T1.duration) ASC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "751": {
        "db_id": "superhero",
        "question": "List down at least five superpowers of male superheroes.",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T3.id = T2.power_id INNER JOIN gender AS T4 ON T4.id = T1.gender_id WHERE T4.gender = 'Male' LIMIT 5",
        "amends": [
            "Do select `T3.power_name` from the `superpower` table instead of `superpower` from the `superheroes` table. Do join `hero_power` on `T1.id = T2.hero_id` and `superpower` on `T3.id = T2.power_id` instead of querying a single table. Do join `gender` on `T4.id = T1.gender_id` instead of filtering directly on a gender column. Do filter on `T4.gender = 'Male'` instead of `gender = 'female'` to query male heroes instead of female ones. The amended query now correctly joins multiple normalized tables and filters by gender through proper table relationships, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"superpowers of male superheroes\": make sure the output order: T3.power_name. 2) When the question mentions \"male superheroes\": \"male\" actually means \"T4.gender = 'Male'\" in schema. 3) When combining T1 (superheroes), T2 (hero_power), T3 (superpower), and T4 (gender) for shared entities: link rows where T1.id = T2.hero_id and T3.id = T2.power_id and T4.id = T1.gender_id; keep only matching pairs (inner match). 4) When filtering by gender: use the exact literal 'Male' with exact case and spacing as shown in the schema. 5) When selecting superpowers: use T3.power_name from the superpower table instead of any superpower column from the superheroes table."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT superpower FROM superheroes WHERE gender = 'female' LIMIT 5;",
            "SELECT DISTINCT T3.power_name \nFROM superhero T1\nJOIN hero_power T2 ON T1.id = T2.hero_id\nJOIN superpower T3 ON T3.id = T2.power_id\nJOIN gender T4 ON T4.id = T1.gender_id\nWHERE T4.gender = 'Male'\nLIMIT 5;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T3.id = T2.power_id\nINNER JOIN gender T4 ON T4.id = T1.gender_id\nWHERE T4.gender = 'Male'\nORDER BY T3.power_name\nLIMIT 5;"
        ],
        "amend_res": 1
    },
    "772": {
        "db_id": "superhero",
        "question": "List the eyes, hair and skin colour of all female superheroes published by Dark Horse Comics.",
        "ground_truth": "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'",
        "amends": [
            "Do reference columns `T1.eye_colour_id`, `T1.hair_colour_id`, and `T1.skin_colour_id` instead of `eyes`, `hair`, and `skin`. Do use table `superhero` instead of `superheroes`. Do add `INNER JOIN publisher AS T2 ON T2.id = T1.publisher_id` instead of omitting the publisher join. Do add `INNER JOIN gender AS T3 ON T3.id = T1.gender_id` instead of omitting the gender join. Do use filter `T2.publisher_name = 'Dark Horse Comics'` instead of `publisher = 'Dark Horse Comics'`. Do use filter `T3.gender = 'Female'` instead of `gender = 'male'`. The amended query now correctly joins related tables and uses proper foreign key relationships to filter by publisher name and gender.",
            "Do select `T1.eye_colour_id`, `T1.hair_colour_id`, and `T1.skin_colour_id` instead of joining to `colour` tables and selecting `c1.colour`, `c2.colour`, and `c3.colour` with aliases. Do remove all three `INNER JOIN colour AS c1`, `INNER JOIN colour AS c2`, and `INNER JOIN colour AS c3` instead of keeping unnecessary joins to the colour table. The amended query now directly selects the colour ID columns from the superhero table rather than joining to resolve colour names, matching the RIGHT_SQL's behavior of returning the raw ID values instead of resolved colour names."
        ],
        "rules": [
            "1) When the question asks about superhero attributes: use table \"superhero\" (not \"superheroes\") with alias T1. 2) When referencing eye, hair, and skin colors: use columns T1.eye_colour_id, T1.hair_colour_id, and T1.skin_colour_id instead of eyes, hair, and skin. 3) When filtering by publisher: join table \"publisher\" as T2 using T2.id = T1.publisher_id and filter with T2.publisher_name = 'Dark Horse Comics'. 4) When filtering by gender: join table \"gender\" as T3 using T3.id = T1.gender_id and filter with T3.gender = 'Female' (not 'male'). 5) When combining tables: perform inner joins on the exact key relationships T2.id = T1.publisher_id and T3.id = T1.gender_id to ensure only matching pairs are kept.",
            "1) When the question asks for eye, hair, and skin colour: select the raw ID columns \"T1.eye_colour_id\", \"T1.hair_colour_id\", and \"T1.skin_colour_id\" directly from the superhero table instead of joining to resolve colour names. 2) When joining tables for publisher filtering: link \"T1.publisher_id\" with \"T2.id\" where \"T2.publisher_name\" equals 'Dark Horse Comics' exactly. 3) When filtering for female superheroes: link \"T1.gender_id\" with \"T3.id\" where \"T3.gender\" equals 'Female' exactly. 4) When selecting output columns: maintain the order eye_colour, hair_colour, skin_colour as specified in the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eyes, hair, skin FROM superheroes WHERE gender = 'male' AND publisher = 'Dark Horse Comics';",
            "SELECT \n    c1.colour AS eye_colour,\n    c2.colour AS hair_colour, \n    c3.colour AS skin_colour\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T2.id = T1.publisher_id\nINNER JOIN gender AS T3 ON T3.id = T1.gender_id\nINNER JOIN colour AS c1 ON c1.id = T1.eye_colour_id\nINNER JOIN colour AS c2 ON c2.id = T1.hair_colour_id\nINNER JOIN colour AS c3 ON c3.id = T1.skin_colour_id\nWHERE T2.publisher_name = 'Dark Horse Comics' \nAND T3.gender = 'Female'",
            "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T2.id = T1.publisher_id\nINNER JOIN gender AS T3 ON T3.id = T1.gender_id\nWHERE T2.publisher_name = 'Dark Horse Comics' AND T3.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id\nFROM superhero T1\nINNER JOIN publisher T2 ON T2.id = T1.publisher_id\nINNER JOIN gender T3 ON T3.id = T1.gender_id\nWHERE T2.publisher_name = 'Dark Horse Comics'\nAND T3.gender = 'Female';"
        ],
        "amend_res": 1
    },
    "354": {
        "db_id": "card_games",
        "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
        "ground_truth": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
        "amends": [
            "Do count `type` instead of `*` to count non-null values of a specific column rather than all rows. Do remove the `card_art = 'illustrated'` filter instead of keeping it to include all cards by the specified artist regardless of art type. The amended query now correctly counts the number of cards by Aaron Boyd without the unnecessary art type restriction."
        ],
        "rules": [
            "1) When counting types of cards: count the number of non-null values in the \"type\" column instead of counting all rows. 2) When filtering by artist: use the exact literal 'Aaron Boyd' for the artist condition. 3) When the question asks about cards regardless of art type: do not include any filter on card_art column."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE artist = 'Aaron Boyd' AND card_art = 'illustrated';",
            "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT type) FROM cards WHERE artist = 'Aaron Boyd' AND type IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1353": {
        "db_id": "student_club",
        "question": "What's Christof Nielson's zip code type?",
        "evidence": "",
        "ground_truth": "SELECT T2.type FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'",
        "amends": [
            "Do select `T2.type` from the `zip_code` table instead of `zip_code_type` from the `customers` table. Do join `member AS T1` with `zip_code AS T2` using `INNER JOIN` on `T1.zip = T2.zip_code` instead of querying only the `customers` table. Do apply the filters `first_name = 'Christof'` and `last_name = 'Nielson'` to the `member` table (`T1`) instead of the `customers` table. The amended query now correctly retrieves zip code type information by joining member data with zip code reference data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about zip code type for a person: select \"type\" from the \"zip_code\" table (as T2) instead of \"zip_code_type\" from the \"customers\" table. 2) When joining member and zip_code tables: use INNER JOIN between \"member\" AS T1 and \"zip_code\" AS T2 on T1.zip = T2.zip_code. 3) When filtering by first and last name: apply the conditions first_name = 'Christof' and last_name = 'Nielson' to the \"member\" table (T1). 4) When selecting output columns: return T2.type as the zip code type information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT zip_code_type FROM customers WHERE first_name = 'Christof' AND last_name = 'Nielson';",
            "SELECT T2.type \nFROM member AS T1 \nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code \nWHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'"
        ],
        "rule_sql": [
            "SELECT T2.type \nFROM member AS T1 \nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code \nWHERE T1.first_name = 'Christof' AND T1.last_name = 'Nielson'"
        ],
        "amend_res": 1
    },
    "766": {
        "db_id": "superhero",
        "question": "What is the hero's full name with the highest attribute in strength?",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Strength' ORDER BY T2.attribute_value DESC LIMIT 1",
        "amends": [
            "Do select `full_name` from the `superhero` table instead of `hero_name` from a non-existent `heroes` table. Do add two `INNER JOIN` operations to connect `superhero` with `hero_attribute` on `id=hero_id` and then with `attribute` on `attribute_id=id` instead of querying a single table. Do add a `WHERE` filter for `attribute_name='Strength'` instead of ordering by a non-existent `strength` column. Do order by `attribute_value DESC` instead of the incorrect `strength DESC`. The amended query now correctly retrieves the superhero with the highest strength attribute value by properly joining the normalized tables and filtering for the specific attribute type."
        ],
        "rules": [
            "1) When the question asks for \"hero's full name\": select \"full_name\" from the \"superhero\" table instead of \"hero_name\" from any other table. 2) When the question mentions \"highest attribute in strength\": join \"superhero\" with \"hero_attribute\" on \"id\" = \"hero_id\" and then with \"attribute\" on \"attribute_id\" = \"id\" to access attribute values. 3) When filtering for strength attribute: add a condition where \"attribute_name\" equals 'Strength' exactly. 4) When ordering by attribute value: sort by \"attribute_value DESC\" to find the highest value. 5) When retrieving the top result: limit to the first row after ordering to get the single highest value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_name FROM heroes ORDER BY strength DESC LIMIT 1;",
            "SELECT s.full_name\nFROM superhero s\nINNER JOIN hero_attribute ha ON s.id = ha.hero_id\nINNER JOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Strength'\nORDER BY ha.attribute_value DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT s.full_name\nFROM superhero s\nJOIN hero_attribute ha ON s.id = ha.hero_id\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE a.attribute_name = 'Strength'\nORDER BY ha.attribute_value DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1176": {
        "db_id": "thrombosis_prediction",
        "question": "What was the anti-nucleus antibody concentration level for the patient id 3605340 on 1996/12/2?",
        "ground_truth": "SELECT ANA FROM Examination WHERE ID = 3605340 AND `Examination Date` = '1996-12-02'",
        "amends": [
            "Do select `ANA` instead of `antibody_level` and use table `Examination` instead of `lab_tests`. Do filter on `ID` instead of `patient_id` and use date format `1996-12-02` instead of `1996/12/2`. Do remove the `test_type = 'anti-nucleus'` filter instead of keeping it, as the ANA column specifically represents this test type. The amended query now correctly retrieves the anti-nuclear antibody test result from the appropriate examination table."
        ],
        "rules": [
            "1) When answering about anti-nucleus antibody concentration level: select the exact column \"ANA\" from table \"Examination\" instead of \"antibody_level\" from \"lab_tests\". 2) When filtering by patient identifier: use the exact column \"ID\" with value 3605340 instead of \"patient_id\". 3) When filtering by date: use the exact date format '1996-12-02' instead of '1996/12/2'. 4) When querying for anti-nucleus antibody test results: do not include a separate test_type filter since the \"ANA\" column specifically represents this test type."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT antibody_level FROM lab_tests WHERE patient_id = 3605340 AND test_date = '1996/12/2' AND test_type = 'anti-nucleus'",
            "SELECT ANA FROM Examination WHERE ID = 3605340 AND \"Examination Date\" = '1996-12-02';"
        ],
        "rule_sql": [
            "SELECT ANA FROM Examination WHERE ID = 3605340 AND \"Examination Date\" = '1996-12-02';"
        ],
        "amend_res": 1
    },
    "968": {
        "db_id": "formula_1",
        "question": "What is reference name of Robert Kubica?",
        "ground_truth": "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica'",
        "amends": [
            "Do select `driverRef` instead of `first_name` in the SELECT list. Do filter on `forename = 'Robert'` and `surname = 'Kubica'` instead of only `last_name = 'Kubica'` in the WHERE clause. The amended query now correctly retrieves the driver reference using the appropriate column names and complete filtering criteria."
        ],
        "rules": [
            "1) When the question asks for \"reference name\": select the exact column \"driverRef\" from the drivers table. 2) When filtering for driver \"Robert Kubica\": use both conditions \"forename = 'Robert'\" and \"surname = 'Kubica'\" with exact string literals 'Robert' and 'Kubica'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM drivers WHERE last_name = 'Kubica';",
            "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';"
        ],
        "rule_sql": [
            "SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';"
        ],
        "amend_res": 1
    },
    "226": {
        "db_id": "toxicology",
        "question": "What is the percentage of double bonds in the molecule TR008? Please provide your answer as a percentage with five decimal places.",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) FROM bond AS T WHERE T.molecule_id = 'TR008'",
        "amends": [
            "Do use `ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5)` instead of `(double_bonds / total_bonds) * 100` for the percentage calculation, implementing proper aggregation with conditional counting and explicit casting. Do change the FROM source to `bond AS T` instead of `molecules` to access the correct table structure. Do modify the WHERE filter to `T.molecule_id = 'TR008'` instead of `molecule_name = 'TR008'` to use the appropriate identifier column. Do remove the alias `percentage` instead of keeping it since the right query omits column naming. The amended query now correctly calculates the percentage of double bonds for molecule TR008 using proper aggregation and table relationships."
        ],
        "rules": [
            "1) When calculating percentage of double bonds: use ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) for the calculation with 5 decimal places precision. 2) When accessing bond data: query from the bond table using alias T instead of molecules table. 3) When filtering for molecule TR008: use T.molecule_id = 'TR008' instead of molecule_name = 'TR008'. 4) When presenting the result: do not use column aliases as the output should be unnamed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (double_bonds / total_bonds) * 100 AS percentage FROM molecules WHERE molecule_name = 'TR008';",
            "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id), 5) FROM bond AS T WHERE T.molecule_id = 'TR008'"
        ],
        "rule_sql": [
            "SELECT ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id), 5) FROM bond T WHERE T.molecule_id = 'TR008'"
        ],
        "amend_res": 1
    },
    "476": {
        "db_id": "card_games",
        "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
        "ground_truth": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
        "amends": [
            "Do join `sets AS T2` instead of omitting it, and do use `INNER JOIN` on `T2.code = T1.setCode` instead of filtering directly on `set_name`. Do reference `T1.name` instead of just `name`, and do filter on `T2.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'`. Do order by `T1.convertedManaCost` instead of `converted_mana_cost`. The amended query now correctly joins the sets table to validate set names and uses proper column references, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"set Coldsnap\": \"Coldsnap\" actually means \"T2.name = 'Coldsnap'\" in schema. 2) When combining T1 and T2 for shared entities: link rows where T2.code = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match). 3) When the question asks for \"name of the cards\": reference T1.name instead of just name. 4) When the question asks for \"highest converted mana cost\": rank rows by T1.convertedManaCost in descending direction and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE set_name = 'Coldsnap' ORDER BY converted_mana_cost DESC LIMIT 1;",
            "SELECT T1.name\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap'\nORDER BY T1.convertedManaCost DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name\nFROM cards T1\nINNER JOIN sets T2 ON T2.code = T1.setCode\nWHERE T2.name = 'Coldsnap'\nORDER BY T1.convertedManaCost DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "335": {
        "db_id": "toxicology",
        "question": "What is the total number of molecules with double bonded oxygen?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '=' AND T1.element = 'o'",
        "amends": [
            "Do select `COUNT(DISTINCT T1.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all rows. Do use `FROM atom AS T1 INNER JOIN bond AS T2` instead of `FROM molecules` to join the atom and bond tables. Do add join condition `ON T1.molecule_id = T2.molecule_id` instead of omitting it to properly relate atoms to their bonds. Do add filter `WHERE T2.bond_type = '=' AND T1.element = 'o'` instead of `WHERE oxygen_bonds = 'double'` to correctly identify oxygen atoms with double bonds through the bond_type column. The amended query now correctly counts distinct molecules containing oxygen atoms with double bonds, matching the intended behavior."
        ],
        "rules": [
            "1) When counting molecules: count distinct T1.molecule_id instead of counting all rows to get unique molecule counts. 2) When combining atom and bond tables: use INNER JOIN between atom AS T1 and bond AS T2 with join condition T1.molecule_id = T2.molecule_id to properly relate atoms to their bonds. 3) When identifying oxygen atoms with double bonds: filter using T2.bond_type = '=' AND T1.element = 'o' instead of oxygen_bonds = 'double' to correctly identify oxygen atoms with double bonds through the bond_type column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE oxygen_bonds = 'double';",
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '=' AND T1.element = 'o'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.molecule_id) \nFROM atom AS T1 \nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.bond_type = '=' AND T1.element = 'o'"
        ],
        "amend_res": 1
    },
    "636": {
        "db_id": "codebase_community",
        "question": "How many negative comments did Neil McGuigan get in his posts?",
        "ground_truth": "SELECT COUNT(T3.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T2.Id = T3.PostId WHERE T1.DisplayName = 'Neil McGuigan' AND T3.Score < 60",
        "amends": [
            "Do join `users AS T1` and `posts AS T2` on `T1.Id = T2.OwnerUserId` instead of querying only the `comments` table, then do join `comments AS T3` on `T2.Id = T3.PostId` instead of missing these table relationships. Do filter on `T1.DisplayName = 'Neil McGuigan'` instead of `author = 'Neil McGuigan'`, and do filter on `T3.Score < 60` instead of `sentiment = 'negative'`. Do count `T3.Id` instead of `COUNT(*)` to ensure accurate counting of comment records. The amended query now correctly counts comments from the specified user with low scores rather than relying on a sentiment field that may not exist."
        ],
        "rules": [
            "1) When the question asks about comments for a specific user: join users as T1 with posts as T2 using T1.Id = T2.OwnerUserId, then join comments as T3 with T2 using T2.Id = T3.PostId to establish the proper relationships between users, their posts, and comments on those posts. 2) When filtering for a user named 'Neil McGuigan': use T1.DisplayName = 'Neil McGuigan' instead of an author field in the comments table. 3) When identifying negative comments: use T3.Score < 60 instead of a sentiment field, as low scores indicate negative feedback. 4) When counting comments: count T3.Id to accurately count comment records rather than using COUNT(*) which might include non-comment rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE author = 'Neil McGuigan' AND sentiment = 'negative';",
            "SELECT COUNT(T3.Id) \nFROM users AS T1 \nJOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nJOIN comments AS T3 ON T2.Id = T3.PostId \nWHERE T1.DisplayName = 'Neil McGuigan' \nAND T3.Score < 60"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.Id) AS negative_comment_count\nFROM users AS T1\nJOIN posts AS T2 ON T1.Id = T2.OwnerUserId\nJOIN comments AS T3 ON T2.Id = T3.PostId\nWHERE T1.DisplayName = 'Neil McGuigan'\nAND T3.Score < 60"
        ],
        "amend_res": 1
    },
    "942": {
        "db_id": "formula_1",
        "question": "What is the average fastest lap time in seconds for Lewis Hamilton in all the Formula_1 races?",
        "ground_truth": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis'",
        "amends": [
            "Do use `INNER JOIN` between `drivers AS T1` and `results AS T2` on `T1.driverId = T2.driverId` instead of querying a single table. Do filter on both `T1.surname = 'Hamilton'` and `T1.forename = 'Lewis'` instead of just `driver = 'Lewis Hamilton'`. Do add complex time conversion using `CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)` to properly convert the colon-separated time format to seconds instead of directly averaging the raw string value. The amended query now correctly handles the time conversion and joins the necessary tables to match the intended behavior."
        ],
        "rules": [
            "1) When answering about Formula 1 races and drivers: combine tables \"drivers\" as T1 and \"results\" as T2 using inner match where T1.driverId equals T2.driverId. 2) When the question mentions \"Lewis Hamilton\": filter using both T1.forename = 'Lewis' and T1.surname = 'Hamilton' to match the driver's full name. 3) When handling fastest lap time in seconds: convert the colon-separated time format using CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL) to properly calculate seconds instead of using the raw string value. 4) When computing average fastest lap time: calculate the average of the converted time values in seconds."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fastest_lap_time) FROM Formula_1_races WHERE driver = 'Lewis Hamilton';",
            "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) AS average_fastest_lap_seconds\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T1.driverId = T2.driverId\nWHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis' AND T2.fastestLapTime IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) AS average_fastest_lap_seconds\nFROM drivers AS T1\nINNER JOIN results AS T2 ON T1.driverId = T2.driverId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "465": {
        "db_id": "card_games",
        "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
        "ground_truth": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
        "amends": [
            "Do use `IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO')` instead of `SELECT *` to return a conditional result based on translation existence. Do add `INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode` instead of querying only the `cards` table to incorporate translation data. Do change the filter to `T1.name = 'Ancestor''s Chosen'` instead of `name = 'Ancestor\\'s Chosen'` for proper string escaping. Do remove the direct `language = 'Korean'` filter from the WHERE clause and instead incorporate it as `T2.language = 'Korean' AND T2.translation IS NOT NULL` within the CASE expression to check for valid Korean translations. The amended query now correctly identifies whether Korean translations exist for the specified card by joining with the translations table and using conditional aggregation."
        ],
        "rules": [
            "1) When answering about whether a Korean version exists for cards with \"Ancestor's Chosen\": use conditional logic to return 'YES' or 'NO' based on translation existence instead of selecting all columns. 2) When the question mentions \"cards with 'Ancestor's Chosen' in it\": filter using T1.name = 'Ancestor''s Chosen' with proper string escaping. 3) When combining cards table (T1) and set_translations table (T2): link rows where T2.setCode = T1.setCode using an inner join. 4) When checking for Korean translations: use the condition T2.language = 'Korean' AND T2.translation IS NOT NULL within the aggregation logic. 5) When determining if Korean translations exist: count using SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0 and return 'YES' if true, 'NO' if false."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE name = 'Ancestor\\'s Chosen' AND language = 'Korean';",
            "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') AS has_korean_version\nFROM cards AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Ancestor''s Chosen'"
        ],
        "rule_sql": [
            "SELECT CASE WHEN SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0 THEN 'YES' ELSE 'NO' END AS has_korean_version\nFROM cards T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.setCode\nWHERE T1.name = 'Ancestor''s Chosen'"
        ],
        "amend_res": 1
    },
    "1234": {
        "db_id": "thrombosis_prediction",
        "question": "List the patient ID, sex and birthday who has abnormal white blood cell count. Group them by sex and list the patient by age in ascending order.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0 GROUP BY T1.SEX,T1.ID ORDER BY T1.Birthday ASC",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do use `T1.ID` instead of `patient_id` and `T1.SEX` instead of `sex`. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table. Do change the filter to `T2.WBC <= 3.5 OR T2.WBC >= 9.0` instead of `white_blood_cell_count > 10000`. Do expand `GROUP BY` to include `T1.ID` instead of grouping by sex only. Do qualify `Birthday` as `T1.Birthday` instead of unqualified `birthday`. The amended query now correctly joins laboratory data, applies appropriate WBC range filtering, ensures proper grouping, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients with abnormal white blood cell count: use T1.ID instead of patient_id and T1.SEX instead of sex. 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID using an inner join. 3) When filtering for abnormal white blood cell count: use T2.WBC <= 3.5 OR T2.WBC >= 9.0 instead of white_blood_cell_count > 10000. 4) When grouping results: include T1.ID in the GROUP BY clause instead of grouping by sex only. 5) When referring to birthday: qualify it as T1.Birthday instead of unqualified birthday. 6) When selecting distinct patient records: use DISTINCT to avoid duplicate patient entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, birthday \nFROM patients \nWHERE white_blood_cell_count > 10000 \nGROUP BY sex \nORDER BY birthday ASC;",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0\nGROUP BY T1.SEX, T1.ID\nORDER BY T1.Birthday ASC"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0\nGROUP BY T1.ID, T1.SEX\nORDER BY T1.SEX, (julianday('now') - julianday(T1.Birthday)) ASC"
        ],
        "amend_res": 1
    },
    "876": {
        "db_id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers did not finish the game?",
        "ground_truth": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NULL",
        "amends": [
            "Do reference `races AS T1` and `results AS T2` tables instead of only the `drivers` table. Do use `INNER JOIN` on `T2.raceId = T1.raceId` instead of missing the join condition entirely. Do filter on `T1.date = '2015-11-29'` with proper date format instead of `race_date = '2015/11/29'`. Do check `T2.time IS NULL` instead of `finish_position IS NULL`. Do count `T2.driverId` specifically instead of using `COUNT(*)`. The amended query now correctly counts drivers with null finish times for the specified race date, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about drivers who did not finish a race: use tables \"races AS T1\" and \"results AS T2\" instead of only the \"drivers\" table. 2) When combining races and results tables: link rows where T2.raceId = T1.raceId using inner match. 3) When filtering for race date '2015/11/29': use T1.date = '2015-11-29' with exact date format instead of '2015/11/29'. 4) When checking for drivers who did not finish: use T2.time IS NULL instead of finish_position IS NULL. 5) When counting drivers: count T2.driverId specifically instead of using COUNT(*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE race_date = '2015/11/29' AND finish_position IS NULL;",
            "SELECT COUNT(T2.driverId) \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nWHERE T1.date = '2015-11-29' AND T2.time IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.driverId) \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nWHERE T1.date = '2015-11-29' \nAND T2.time IS NULL"
        ],
        "amend_res": 1
    },
    "532": {
        "db_id": "codebase_community",
        "question": "Please list the display names of all the users whose accounts were created in the year 2011.",
        "ground_truth": "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011'",
        "amends": [
            "Do reference the correct column `DisplayName` instead of `display_name` in the SELECT list. Do use the correct date column `CreationDate` instead of `created_at` in the WHERE filter. Do apply the `STRFTIME('%Y', CreationDate)` function to extract the year from the date column instead of comparing the raw date value to an integer. Do compare the extracted year to the string literal '2011' instead of the integer 2011 to ensure proper type matching. The amended query now correctly filters users by year of creation using proper date handling functions and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"display names\": use the exact column token \"DisplayName\" from the users table. 2) When filtering by year of account creation: extract the year from the \"CreationDate\" column using STRFTIME('%Y', CreationDate) function. 3) When comparing the extracted year to 2011: use the string literal '2011' instead of integer 2011 for proper type matching. 4) When answering about users created in a specific year: ensure the output order includes only the DisplayName column as requested."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users WHERE created_at = 2011;",
            "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011';"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE STRFTIME('%Y', CreationDate) = '2011';"
        ],
        "amend_res": 1
    },
    "1275": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patients. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.CENTROMEA IN ('negative', '0')` instead of `anti_centromere = 'normal'` to include both negative and zero values. Do filter on `T2.SSB IN ('negative', '0')` instead of `anti_ssb = 'normal'` for the same expanded condition set. Do filter on `T1.SEX = 'M'` instead of `gender = 'male'` using the correct column name and value format. The amended query now correctly counts distinct male patients with negative or zero centromere and SSB lab values by joining patient and laboratory data."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patients. 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 3) When filtering for normal anti-centromere levels: check T2.CENTROMEA IN ('negative', '0') instead of anti_centromere = 'normal'. 4) When filtering for normal anti-SSB levels: check T2.SSB IN ('negative', '0') instead of anti_ssb = 'normal'. 5) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male' with the correct column name and value format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE anti_centromere = 'normal' AND anti_ssb = 'normal' AND gender = 'male';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.CENTROMEA IN ('negative', '0') \nAND T2.SSB IN ('negative', '0') \nAND T1.SEX = 'M'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.CENTROMEA IN ('negative', '0')\nAND T2.SSB IN ('negative', '0')\nAND T1.SEX = 'M'"
        ],
        "amend_res": 1
    },
    "1067": {
        "db_id": "european_football_2",
        "question": "Which teams have build up play passing more than 70? Please list their short names.",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayPassing > 70",
        "amends": [
            "Do use `DISTINCT t1.team_short_name` instead of `short_name` to eliminate duplicates and specify the table alias. Do add `Team_Attributes AS t2` table with `INNER JOIN` instead of querying only the `teams` table. Do use join condition `t1.team_api_id = t2.team_api_id` instead of no join condition. Do reference `t2.buildUpPlayPassing` instead of `build_up_play_passing` to access the correct column from the joined table. The amended query now correctly joins the necessary tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"teams with build up play passing more than 70\": make sure the output order: t1.team_short_name. 2) When the question mentions \"short names\": \"short names\" actually means \"t1.team_short_name in schema\". 3) When the question mentions \"build up play passing more than 70\": \"build up play passing\" actually means \"t2.buildUpPlayPassing > 70 in schema\". 4) When combining teams and Team_Attributes for shared entities: link rows where t1.team_api_id = t2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When eliminating duplicates: use DISTINCT t1.team_short_name to ensure each team short name appears only once in results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT short_name FROM teams WHERE build_up_play_passing > 70;",
            "SELECT DISTINCT t1.team_short_name \nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlayPassing > 70"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.team_short_name\nFROM Team t1\nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.buildUpPlayPassing > 70\nORDER BY t1.team_short_name;"
        ],
        "amend_res": 1
    },
    "657": {
        "db_id": "codebase_community",
        "question": "Under the vote type of 8, provide the display names and websites URLs of the user who got the highest bounty amount.",
        "ground_truth": "SELECT DisplayName, WebsiteUrl FROM users WHERE Id = ( SELECT UserId FROM votes WHERE VoteTypeId = 8 ORDER BY BountyAmount DESC LIMIT 1 )",
        "amends": [
            "Do select `DisplayName` and `WebsiteUrl` instead of `display_name`, `website_url`, and `MAX(bounty_amount)`. Do use a subquery to find the `UserId` from `votes` where `VoteTypeId = 8` ordered by `BountyAmount DESC` with `LIMIT 1` instead of directly querying the `users` table with a `WHERE vote_type = 8` filter. Do remove the `GROUP BY display_name, website_url` and `ORDER BY MAX(bounty_amount) DESC` clauses instead of keeping them. Do filter the main query with `WHERE Id = (subquery)` instead of using a direct condition on `vote_type`. The amended query now correctly identifies the user with the highest bounty amount for vote type 8 by correlating between the users and votes tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for display names and website URLs: select \"DisplayName\" and \"WebsiteUrl\" from the users table. 2) When the question mentions vote type of 8: filter votes where \"VoteTypeId\" = 8. 3) When the question asks for the highest bounty amount: order votes by \"BountyAmount\" in descending order and take the first row. 4) When combining user information with vote data: link rows where users.\"Id\" equals the \"UserId\" from the votes table. 5) When finding the user with specific vote criteria: use a subquery to first identify the \"UserId\" with the highest bounty amount for vote type 8, then filter users where \"Id\" matches that subquery result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name, website_url, MAX(bounty_amount) \nFROM users \nWHERE vote_type = 8 \nGROUP BY display_name, website_url \nORDER BY MAX(bounty_amount) DESC \nLIMIT 1;",
            "SELECT DisplayName, WebsiteUrl \nFROM users \nWHERE Id = (\n    SELECT UserId \n    FROM votes \n    WHERE VoteTypeId = 8 \n    ORDER BY BountyAmount DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT u.DisplayName, u.WebsiteUrl\nFROM users u\nWHERE u.Id = (\n    SELECT v.UserId\n    FROM votes v\n    WHERE v.VoteTypeId = 8\n    ORDER BY v.BountyAmount DESC\n    LIMIT 1\n)"
        ],
        "amend_res": 1
    },
    "1454": {
        "db_id": "student_club",
        "question": "What is the percentage of the cost for the meeting events?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget",
        "amends": [
            "Do use `SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost)` instead of `(cost / total_cost) * 100` for calculating the percentage. Do join `event AS T1` instead of omitting it, with `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` instead of no join condition. Do add `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of missing this table join. Do remove the alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage of meeting costs relative to total costs by properly joining the necessary tables and using conditional aggregation."
        ],
        "rules": [
            "1) When calculating percentage of meeting event costs: use SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) instead of simple division 2) When combining event and budget tables: link rows where T1.event_id = T2.link_to_event using inner join 3) When combining budget and expense tables: link rows where T2.budget_id = T3.link_to_budget using inner join 4) When the question asks for percentage of meeting events: do not use an alias for the percentage calculation"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (cost / total_cost) * 100 AS percentage FROM meeting_events",
            "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event INNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget"
        ],
        "amend_res": 1
    },
    "1500": {
        "db_id": "debit_card_specializing",
        "question": "Please list the product description of the products consumed in September, 2013.",
        "ground_truth": "SELECT T3.Description FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN products AS T3 ON T1.ProductID = T3.ProductID WHERE T2.Date = '201309'",
        "amends": [
            "Do select `T3.Description` from the `products` table instead of `description` from `products` directly. Do join `transactions_1k AS T1` and `yearmonth AS T2` with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying `products` alone. Do add another `INNER JOIN` to `products AS T3` on `T1.ProductID = T3.ProductID` instead of accessing products without proper relationships. Do filter on `T2.Date = '201309'` instead of `consumption_date = '2013-09-01'` to use the correct date format and join condition. The amended query now correctly joins transaction, date, and product data to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"products consumed in September, 2013\": make sure the output order: T3.Description. 2) When the question mentions \"products consumed\": this requires joining transactions_1k AS T1, yearmonth AS T2, and products AS T3 using inner joins. 3) When combining T1 and T2: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs. 4) When combining T1 and T3: link rows where T1.ProductID = T3.ProductID and keep only matching pairs. 5) When filtering for September 2013: use T2.Date = '201309' exactly as specified, not '2013-09-01'. 6) When selecting product descriptions: use T3.Description from the products table, not description from products directly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT description FROM products WHERE consumption_date = '2013-09-01';",
            "SELECT T3.Description \nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN products AS T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Date = '201309'"
        ],
        "rule_sql": [
            "SELECT T3.Description\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN products AS T3 ON T1.ProductID = T3.ProductID\nWHERE T2.Date = '201309'\nORDER BY T3.Description;"
        ],
        "amend_res": 1
    },
    "926": {
        "db_id": "formula_1",
        "question": "What's the fastest lap time ever in a race for Lewis Hamilton?",
        "ground_truth": "SELECT T2.fastestLapTime FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1",
        "amends": [
            "Do select `T2.fastestLapTime` instead of `MIN(lap_time)` and add `ORDER BY T2.fastestLapTime ASC LIMIT 1` instead of using an aggregate function. Do join `drivers AS T1` and `results AS T2` with `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only `lap_times` table. Do filter with `T1.forename = 'Lewis' AND T1.surname = 'Hamilton'` instead of `driver_name = 'Lewis Hamilton'` and add `T2.fastestLapTime IS NOT NULL` instead of omitting null checks. The amended query now correctly retrieves the fastest lap time by joining driver information and handling null values."
        ],
        "rules": [
            "1) When answering about \"fastest lap time ever in a race for Lewis Hamilton\": make sure the output order: T2.fastestLapTime. 2) When the question mentions \"Lewis Hamilton\": \"Lewis Hamilton\" actually means \"T1.forename = 'Lewis' AND T1.surname = 'Hamilton' in schema\". 3) When combining T1 and T2 for shared entities: link rows where T2.driverId = T1.driverId; keep only matching pairs (inner match). 4) When handling fastest lap time values: exclude rows where T2.fastestLapTime IS NOT NULL. 5) When the question asks for \"fastest\" lap time: rank rows by T2.fastestLapTime in ascending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(lap_time) FROM lap_times WHERE driver_name = 'Lewis Hamilton';",
            "SELECT T2.fastestLapTime \nFROM drivers AS T1 \nINNER JOIN results AS T2 ON T2.driverId = T1.driverId \nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T2.fastestLapTime IS NOT NULL \nORDER BY T2.fastestLapTime ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.fastestLapTime \nFROM drivers T1 \nINNER JOIN results T2 ON T2.driverId = T1.driverId \nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' \nAND T2.fastestLapTime IS NOT NULL \nORDER BY T2.fastestLapTime ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "707": {
        "db_id": "codebase_community",
        "question": "Among the posts with views ranging from 100 to 150, what is the comment with the highest score?",
        "ground_truth": "SELECT Text FROM comments WHERE PostId IN ( SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150 ) ORDER BY Score DESC LIMIT 1",
        "amends": [
            "Do select `Text` from the `comments` table instead of selecting `comment` and `MAX(score)` from `posts`. Do use a subquery with `PostId IN` instead of directly querying the `posts` table. Do filter by `ViewCount BETWEEN 100 AND 150` in the subquery instead of filtering `views` in the main query. Do add `ORDER BY Score DESC LIMIT 1` to get the highest-scoring comment instead of using `MAX(score)` aggregation. Do remove the incorrect column references and table structure that mixed posts and comments data. The amended query now correctly retrieves the top-scoring comment text for posts with the specified view count range, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for a comment with the highest score among posts with specific view counts: select \"Text\" from the \"comments\" table instead of selecting from \"posts\" table. 2) When filtering posts by view count range 100 to 150: use a subquery with \"PostId IN\" and filter by \"ViewCount BETWEEN 100 AND 150\" in the subquery. 3) When finding the highest-scoring comment: use \"ORDER BY Score DESC LIMIT 1\" instead of MAX(score) aggregation. 4) When combining posts and comments data: ensure proper table separation and remove incorrect column references that mix data from different tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT comment, MAX(score) FROM posts WHERE views BETWEEN 100 AND 150;",
            "SELECT Text \nFROM comments \nWHERE PostId IN (\n    SELECT Id \n    FROM posts \n    WHERE ViewCount BETWEEN 100 AND 150\n) \nORDER BY Score DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Text FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE ViewCount BETWEEN 100 AND 150) ORDER BY Score DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1256": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients with a abnormal C-reactive protein don't have their data recorded?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE (T2.CRP = '+' ) AND T1.Description IS NULL",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific table column instead of `COUNT(*)` from all rows. Do use table aliases `Patient AS T1` and `Laboratory AS T2` with explicit sources instead of single table `patients`. Do perform `INNER JOIN` on `T1.ID = T2.ID` instead of querying only one table. Do filter on `T2.CRP = '+'` for abnormal values instead of `c_reactive_protein = 'abnormal'`. Do check `T1.Description IS NULL` instead of `data_recorded IS NULL`. The amended query now correctly joins patient and laboratory data to count patients with abnormal CRP results where description is missing, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 2) When querying patient and laboratory data: use table aliases Patient AS T1 and Laboratory AS T2 with explicit sources instead of a single patients table. 3) When combining patient and laboratory data: perform an inner join where T1.ID = T2.ID to link patient records with their laboratory results. 4) When filtering for abnormal C-reactive protein values: check T2.CRP = '+' instead of c_reactive_protein = 'abnormal'. 5) When checking for missing data recording: verify T1.Description IS NULL instead of data_recorded IS NULL."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE c_reactive_protein = 'abnormal' AND data_recorded IS NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.CRP = '+' AND T1.Description IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.CRP = '+' AND T1.Description IS NULL"
        ],
        "amend_res": 1
    },
    "687": {
        "db_id": "codebase_community",
        "question": "How many comments were added to the post with the highest score?",
        "ground_truth": "SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId GROUP BY T1.Id ORDER BY SUM(T1.Score) DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` between `posts` and `comments` on `T1.Id = T2.PostId` instead of a subquery with `post_id = (SELECT id FROM posts ORDER BY score ASC LIMIT 1)`. Do add `GROUP BY T1.Id` instead of omitting it. Do change the aggregation to `COUNT(T2.Id)` instead of `COUNT(*)`. Do add `ORDER BY SUM(T1.Score) DESC LIMIT 1` instead of ordering by `score ASC` in the subquery and limiting there. Do remove the subquery approach entirely instead of using it to find the lowest-scoring post. The amended query now correctly counts comments per post and returns the count for the post with the highest total score, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining posts and comments tables: link rows where T1.Id equals T2.PostId exactly and keep only matching pairs (inner join). 2) When counting comments: compute the number of rows using T2.Id as the counting key instead of counting all columns. 3) When organizing results by post: group by T1.Id to compute aggregates per post. 4) When finding the post with the highest score: rank posts by SUM(T1.Score) in descending order and keep only the first row. 5) When answering about comments for the highest-scoring post: make sure the output order shows only the comment count for that single post."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE post_id = (SELECT id FROM posts ORDER BY score ASC LIMIT 1);",
            "SELECT COUNT(comments.Id) \nFROM posts \nINNER JOIN comments ON posts.Id = comments.PostId \nGROUP BY posts.Id \nORDER BY SUM(posts.Score) DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT COUNT(c.Id) AS comment_count\nFROM posts p\nINNER JOIN comments c ON p.Id = c.PostId\nGROUP BY p.Id\nORDER BY SUM(p.Score) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "600": {
        "db_id": "codebase_community",
        "question": "List out all post that are related to post ID 61217 and what is the popularity of this post?",
        "ground_truth": "SELECT T1.ViewCount FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 61217",
        "amends": [
            "Do select `T1.ViewCount` instead of `*` to retrieve only the specific column needed. Do add `INNER JOIN postLinks AS T2` instead of querying only the `posts` table to incorporate the relationship data. Do use join condition `ON T1.Id = T2.PostId` instead of filtering on `post_id` and `related_post_id` in the WHERE clause. Do filter on `T2.PostId = 61217` instead of filtering both `post_id` and `related_post_id` with the same value, which correctly identifies posts linked to the specified post ID. The amended query now properly joins the tables and filters on the correct relationship column to match the intended behavior."
        ],
        "rules": [
            "1) When answering about posts related to post ID 61217: use INNER JOIN to combine posts table as T1 with postLinks table as T2. 2) When combining T1 and T2 for shared entities: link rows where T1.Id = T2.PostId exactly and keep only matching pairs (inner match). 3) When filtering for posts related to post ID 61217: filter on T2.PostId = 61217 to identify posts linked to the specified post ID. 4) When retrieving popularity information: select T1.ViewCount instead of all columns to get the specific popularity metric. 5) When handling the post ID value: use the exact literal value 61217 without quotes as it appears to be a numeric identifier."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM posts WHERE post_id = 61217 AND related_post_id = 61217;",
            "SELECT T1.ViewCount \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T1.Id = T2.PostId \nWHERE T2.PostId = 61217"
        ],
        "rule_sql": [
            "SELECT T1.Id, T1.Title, T1.ViewCount \nFROM posts AS T1 \nINNER JOIN postLinks AS T2 ON T1.Id = T2.RelatedPostId \nWHERE T2.PostId = 61217"
        ],
        "amend_res": 1
    },
    "445": {
        "db_id": "card_games",
        "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T2.language` and `T2.flavorText` instead of `language`, `flavor_text`, and `type` to focus on the correct columns from the joined table. Do add `INNER JOIN foreign_data AS T2` instead of querying only the `cards` table to incorporate the related foreign data. Do use the join condition `ON T2.uuid = T1.uuid` instead of no join to properly link the tables through their UUID relationship. Do remove the `type` column from the SELECT list instead of including it since it's not needed in the result. Do reference `T2.flavorText` instead of `flavor_text` to use the correct column name from the foreign_data table. Do filter on `T1.watermark = 'colorpie'` instead of `watermark = 'colorpie'` to explicitly specify the table source while maintaining the same filter logic. The amended query now correctly retrieves distinct language and flavor text combinations from joined card data with the specified watermark."
        ],
        "rules": [
            "1) When the question asks for \"language and flavor text of the card\": select T2.language and T2.flavorText from the foreign_data table instead of language and flavor_text from the cards table. 2) When combining cards and foreign_data tables: link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match). 3) When filtering for cards with colorpie watermark: use T1.watermark = 'colorpie' with exact literal 'colorpie'. 4) When eliminating duplicate results: use DISTINCT to return only unique combinations of language and flavorText. 5) When the question mentions \"type of this card\": do not include the type column in the output as it's not requested in the final result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, flavor_text, type FROM cards WHERE watermark = 'colorpie';",
            "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'"
        ],
        "rule_sql": [
            "SELECT DISTINCT fd.language, fd.flavorText\nFROM cards c\nINNER JOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE c.watermark = 'colorpie';"
        ],
        "amend_res": 1
    },
    "989": {
        "db_id": "formula_1",
        "question": "Who is the champion of the Canadian Grand Prix in 2008? Indicate his finish time.",
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___'",
        "amends": [
            "Do select `T1.time` instead of `driver_name` and `finish_time`. Do use `FROM results AS T1 INNER JOIN races AS T2` instead of `FROM races` alone. Do join on `T1.raceId = T2.raceId` instead of no join condition. Do filter with `T2.name = 'Canadian Grand Prix'` instead of `race_name = 'Canadian Grand Prix'`. Do filter with `T2.year = 2008` instead of `year = 2008`. Do add `T1.time LIKE '_:%:__.___'` instead of `position = 1`. Do remove the `position` filter instead of keeping it. The amended query now correctly retrieves formatted time results from the joined tables with proper filtering."
        ],
        "rules": [
            "1) When answering about the champion of a Grand Prix: use the exact time format pattern '_:%:__.___' to identify finishing times instead of position = 1. 2) When the question mentions \"Canadian Grand Prix\": use the exact literal 'Canadian Grand Prix' with column T2.name. 3) When the question mentions year 2008: use T2.year = 2008. 4) When combining results and races tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 5) When selecting output columns: use T1.time instead of driver_name and finish_time."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name, finish_time FROM races WHERE year = 2008 AND race_name = 'Canadian Grand Prix' AND position = 1;",
            "SELECT T1.time \nFROM results AS T1 \nINNER JOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'Canadian Grand Prix' \nAND T2.year = 2008 \nAND T1.time LIKE '_:%:__.___'"
        ],
        "rule_sql": [
            "SELECT T1.time FROM results T1 JOIN races T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2008 AND T1.time LIKE '_:%:__.___';"
        ],
        "amend_res": 1
    },
    "646": {
        "db_id": "codebase_community",
        "question": "Describe the post title which got positive comments and display names of the users who posted those comments.",
        "ground_truth": "SELECT T1.Title, T2.UserDisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE T1.Score > 60",
        "amends": [
            "Do select `Title` and `UserDisplayName` instead of `title` and `display_name`. Do use `INNER JOIN` with `comments AS T2` instead of joining both `comments` and `users` tables. Do join on `T2.PostId = T2.Id` instead of `p.post_id = c.post_id` and `c.user_id = u.user_id`. Do add filter `T1.Score > 60` instead of `c.sentiment = 'positive'`. Do remove the users table join and sentiment condition instead of including them. The amended query now correctly filters posts by score threshold rather than comment sentiment and eliminates the unnecessary user table join.",
            "Do use `T1` and `T2` as table aliases instead of `p` and `c`. Do correct the JOIN condition to `T2.PostId = T2.Id` instead of `p.Id = c.PostId`. Do move the filter to `T1.Score > 60` instead of `c.Score > 60`. The amended query now correctly filters on the posts table score instead of comments score and fixes the join condition to properly relate the tables.",
            "Do use `T2.PostId = T2.Id` instead of `T2.PostId = T1.Id` for the join condition, which correctly joins the comments table on its own PostId column rather than incorrectly referencing the posts table's Id column. The amended query now matches RIGHT_SQL's behavior.",
            "Do `ON T2.PostId = T2.Id` instead of `ON T2.PostId = T1.Id` for the join condition, which correctly links comments to their own ID rather than incorrectly joining comments to posts via the wrong column reference. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting post titles and user display names: use exact column names \"Title\" and \"UserDisplayName\" instead of \"title\" and \"display_name\". 2) When joining tables: use INNER JOIN with comments table as T2 instead of joining both comments and users tables. 3) When linking posts and comments: join on T2.PostId = T2.Id instead of p.post_id = c.post_id and c.user_id = u.user_id. 4) When filtering for positive engagement: use T1.Score > 60 instead of sentiment-based filtering. 5) When the question involves user information from comments: do not join the users table directly as the user display name is available in the comments table as \"UserDisplayName\".",
            "1) When combining posts and comments tables: link rows where T2.PostId = T2.Id to properly relate the tables and keep only matching pairs (inner match). 2) When filtering for positive comments: use T1.Score > 60 to filter on the posts table score instead of comments score. 3) When answering about post titles and user display names: make sure the output order: T1.Title, T2.UserDisplayName.",
            "1) When joining comments table T2 to posts table T1: use the join condition T2.PostId = T1.Id to correctly link comments to their parent posts. 2) When filtering for positive comments: use the condition T2.Score > 0 to identify comments with positive scores. 3) When answering about post titles and user display names: make sure the output order is T1.Title followed by T2.UserDisplayName.",
            "1) When joining comments table (T2) to posts table (T1): use the join condition T2.PostId = T2.Id to correctly link comments to their own ID rather than incorrectly joining comments to posts via the wrong column reference. 2) When the question asks for \"positive comments\": use the condition T1.Score > 60 to identify posts with positive scores. 3) When answering about \"post title which got positive comments and display names of the users who posted those comments\": make sure the output order: T1.Title, T2.UserDisplayName."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT p.title, u.display_name \nFROM posts p \nJOIN comments c ON p.post_id = c.post_id \nJOIN users u ON c.user_id = u.user_id \nWHERE c.sentiment = 'positive';",
            "SELECT p.Title, c.UserDisplayName \nFROM posts p \nINNER JOIN comments c ON p.Id = c.PostId \nWHERE c.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName\nFROM posts AS T1\nINNER JOIN comments AS T2 ON T2.PostId = T1.Id\nWHERE T1.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T2.PostId = T1.Id \nWHERE T1.Score > 60",
            "SELECT T1.Title, T2.UserDisplayName \nFROM posts AS T1 \nINNER JOIN comments AS T2 ON T2.PostId = T2.Id \nWHERE T1.Score > 60"
        ],
        "rule_sql": [
            "SELECT T1.Title, T2.UserDisplayName\nFROM posts T1\nINNER JOIN comments T2 ON T2.PostId = T1.Id\nWHERE T2.Score > 0\nORDER BY T1.Title, T2.UserDisplayName"
        ],
        "amend_res": 1
    },
    "557": {
        "db_id": "codebase_community",
        "question": "Among the posts with a score of over 5, what is the percentage of them being owned by an elder user?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5",
        "amends": [
            "Do use `SUM(IIF(T2.Age > 65, 1, 0))` instead of `COUNT(CASE WHEN u.Age >= 65 THEN 1 END)` for conditional counting. Do cast the sum to `REAL` instead of using `100.0` for floating-point division. Do reference `T1.Id` in the denominator instead of `COUNT(*)` for explicit counting. Do use table aliases `T1` and `T2` instead of `p` and `u` for consistency. Do use `INNER JOIN` explicitly instead of just `JOIN` for clarity. Do use `T2.Age > 65` instead of `u.Age >= 65` to exclude the exact age of 65 from the elderly count. The amended query now correctly calculates the percentage of posts owned by users over 65 with scores greater than 5."
        ],
        "rules": [
            "1) When counting posts with scores over 5: use T1.Id as the counting key instead of counting all rows. 2) When determining if a user is elderly: use T2.Age > 65 instead of >= 65 to exclude the exact age of 65. 3) When performing conditional counting of elderly users: use SUM(IIF(T2.Age > 65, 1, 0)) instead of COUNT(CASE WHEN...). 4) When calculating percentages: cast the sum to REAL instead of using 100.0 for floating-point division. 5) When joining tables: use INNER JOIN explicitly between T1 and T2 where T1.OwnerUserId = T2.Id. 6) When filtering posts: only include rows where T1.Score > 5."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.Age >= 65 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_elder_owned\nFROM Posts p\nJOIN Users u ON p.OwnerUserId = u.Id\nWHERE p.Score > 5",
            "SELECT \n    (SUM(IIF(T2.Age > 65, 1, 0)) * 100.0 / COUNT(T1.Id)) AS percentage\nFROM \n    posts T1\nINNER JOIN \n    users T2 ON T1.OwnerUserId = T2.Id\nWHERE \n    T1.Score > 5;"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(IIF(T2.Age > 65, 1, 0)) AS REAL) / COUNT(T1.Id)) * 100.0 AS percentage_elderly_owned\nFROM \n    posts T1\nINNER JOIN \n    users T2 ON T1.OwnerUserId = T2.Id\nWHERE \n    T1.Score > 5"
        ],
        "amend_res": 1
    },
    "1490": {
        "db_id": "debit_card_specializing",
        "question": "How many percent of LAM customer consumed more than 46.73?",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM'",
        "amends": [
            "Do use `SUM(IIF(T2.Consumption > 46.73, 1, 0))` to count qualifying records instead of `COUNT(*)` with a WHERE filter. Do add `INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` to include the yearmonth table instead of querying only the customers table. Do reference `T2.Consumption` from the joined table instead of `consumption` directly from customers. Do calculate percentage using `CAST(... AS FLOAT) * 100 / COUNT(T1.CustomerID)` with proper casting instead of `* 100.0 / (SELECT COUNT(*) ...)`. Do filter on `T1.Segment = 'LAM'` with table alias instead of `segment = 'LAM'`. The amended query now correctly joins the necessary tables and calculates the percentage of customers with consumption exceeding the threshold within the LAM segment."
        ],
        "rules": [
            "1) When answering about \"percent of LAM customer consumed more than 46.73\": make sure the output order: percentage. 2) When the question mentions \"LAM customer\": \"LAM\" actually means \"T1.Segment = 'LAM'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match). 4) When counting qualifying records with consumption > 46.73: use SUM(IIF(T2.Consumption > 46.73, 1, 0)) instead of COUNT(*) with a WHERE filter. 5) When calculating percentage: compute (SUM(IIF(T2.Consumption > 46.73, 1, 0)) * 100 / COUNT(T1.CustomerID)) with proper casting to FLOAT. 6) When referencing consumption data: use T2.Consumption from the joined yearmonth table instead of consumption directly from customers table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM customers WHERE segment = 'LAM') AS percentage\nFROM customers \nWHERE segment = 'LAM' AND consumption > 46.73",
            "SELECT CAST(SUM(IIF(T2.Consumption > 46.73, 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) AS Percentage\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(T2.Consumption > 46.73, 1, 0)) * 100.0 / COUNT(T1.CustomerID)) AS percentage\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Segment = 'LAM'"
        ],
        "amend_res": 1
    },
    "654": {
        "db_id": "codebase_community",
        "question": "Mention the display name and location of the user who owned the excerpt post with hypothesis-testing tag.",
        "ground_truth": "SELECT T3.DisplayName, T3.Location FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T3.Id = T2.OwnerUserId WHERE T1.TagName = 'hypothesis-testing'",
        "amends": [
            "Do use `INNER JOIN` on `tags.ExcerptPostId = posts.Id` instead of `JOIN posts ON users.id = posts.owner_user_id`. Do use `INNER JOIN` on `users.Id = posts.OwnerUserId` instead of joining through `post_tags` and `tags` tables. Do remove the `JOIN post_tags` and `JOIN tags` conditions entirely instead of including them. Do remove the `p.post_type_id = 2` filter instead of keeping it. Do reference `DisplayName` and `Location` columns directly instead of `display_name` and `location`. The amended query now correctly joins tags to posts via ExcerptPostId and then to users, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"display name and location of the user who owned the excerpt post with hypothesis-testing tag\": make sure the output order: DisplayName, Location. 2) When the question mentions \"display name\": \"display name\" actually means \"DisplayName in users table\". 3) When the question mentions \"location\": \"location\" actually means \"Location in users table\". 4) When combining tags and posts for excerpt posts: link rows where tags.ExcerptPostId = posts.Id exactly as shown in the amends; keep only matching pairs (inner match). 5) When combining posts and users for ownership: link rows where users.Id = posts.OwnerUserId exactly as shown in the amends; keep only matching pairs (inner match). 6) When filtering for the hypothesis-testing tag: include only rows where tags.tag_name = 'hypothesis-testing' exactly as specified. 7) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 8) When handling text literals: do not change case, spacing, or punctuation of 'hypothesis-testing'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.display_name, u.location FROM users u JOIN posts p ON u.id = p.owner_user_id JOIN post_tags pt ON p.id = pt.post_id JOIN tags t ON pt.tag_id = t.id WHERE t.tag_name = 'hypothesis-testing' AND p.post_type_id = 2",
            "SELECT u.DisplayName, u.Location\nFROM tags t\nINNER JOIN posts p ON t.ExcerptPostId = p.Id\nINNER JOIN users u ON p.OwnerUserId = u.Id\nWHERE t.TagName = 'hypothesis-testing'"
        ],
        "rule_sql": [
            "SELECT u.DisplayName, u.Location\nFROM tags t\nINNER JOIN posts p ON t.ExcerptPostId = p.Id\nINNER JOIN users u ON p.OwnerUserId = u.Id\nWHERE t.TagName = 'hypothesis-testing'"
        ],
        "amend_res": 1
    },
    "750": {
        "db_id": "superhero",
        "question": "What is the average weight of all female superheroes?",
        "ground_truth": "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'",
        "amends": [
            "Do use `AVG(T1.weight_kg)` instead of `AVG(height)` to calculate the average weight instead of height. Do join `superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id` instead of querying only `superheroes` to properly relate the gender through a foreign key relationship. Do filter with `WHERE T2.gender = 'Female'` instead of `WHERE gender = 'Female'` to filter based on the joined gender table's value rather than a direct column reference. The amended query now correctly calculates average weight for female superheroes using proper table relationships and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average weight of all female superheroes\": make sure the output order: AVG(T1.weight_kg). 2) When the question mentions \"female superheroes\": \"female\" actually means \"T2.gender = 'Female'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.gender_id = T2.id; keep only matching pairs (inner match). 4) When calculating average weight: use AVG(T1.weight_kg) instead of height-related columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM superheroes WHERE gender = 'Female';",
            "SELECT AVG(T1.weight_kg) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT AVG(s.weight_kg) \nFROM superhero s\nINNER JOIN gender g ON s.gender_id = g.id\nWHERE g.gender = 'Female'"
        ],
        "amend_res": 1
    },
    "120": {
        "db_id": "financial",
        "question": "From Year 1995 to 2000, who are the accounts holders from 'east Bohemia'. State the account ID the frequency of statement issuance.",
        "ground_truth": "SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'east Bohemia' AND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'",
        "amends": [
            "Do reference `T1.account_id` and `T1.frequency` instead of `account_id` and `COUNT(statement_id) as frequency`. Do join `account AS T1` with `district AS T2` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do filter on `T2.A3 = 'east Bohemia'` instead of `region = 'east Bohemia'`. Do use `STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'` for year extraction instead of `year BETWEEN 1995 AND 2000`. Do remove the `GROUP BY account_id` clause instead of keeping it since the aggregation is no longer needed. The amended query now correctly joins account and district tables to filter by region and properly handles date-based year filtering."
        ],
        "rules": [
            "1) When answering about account holders from 'east Bohemia': join table account as T1 with table district as T2 using T1.district_id = T2.district_id to access region information. 2) When filtering by region 'east Bohemia': use T2.A3 = 'east Bohemia' instead of a region column in the accounts table. 3) When filtering by years 1995 to 2000: extract year from T1.date using STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000' instead of a direct year column. 4) When selecting account information: output T1.account_id and T1.frequency directly instead of aggregating with COUNT(statement_id). 5) When the question asks for frequency of statement issuance: use the existing T1.frequency column rather than computing a count from statement_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, COUNT(statement_id) as frequency \nFROM accounts \nWHERE region = 'east Bohemia' \nAND year BETWEEN 1995 AND 2000 \nGROUP BY account_id",
            "SELECT T1.account_id, T1.frequency\nFROM account AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.A3 = 'east Bohemia'\nAND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000'"
        ],
        "rule_sql": [
            "SELECT T1.account_id, T1.frequency\nFROM account AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.A3 = 'east Bohemia'\nAND STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000';"
        ],
        "amend_res": 1
    },
    "1094": {
        "db_id": "european_football_2",
        "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
        "ground_truth": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "amends": [
            "Do use `SUM` aggregates with `CASE` expressions to calculate ratings for specific players instead of directly subtracting individual player ratings. Do join `Player` table with `Player_Attributes` table using `INNER JOIN` on `player_api_id` instead of self-joining the same table without proper join conditions. Do reference columns `player_name` and `overall_rating` from appropriate tables instead of assuming both exist in a single table. Do handle division by zero and data type conversion with `* 1.0` multiplication instead of direct integer division. The amended query now correctly calculates the percentage difference between two players' ratings by properly aggregating data from related tables.",
            "Do use a single `Player` table with alias `t1` instead of two separate `Player` table instances, and do use a single `Player_Attributes` table with alias `t2` instead of two separate `Player_Attributes` table instances. Do reference `t1.player_name` in all conditional expressions instead of using separate player tables for each condition. Do remove the comma join syntax and instead use a proper `INNER JOIN` between the single `Player` and `Player_Attributes` tables. Do use `* 1.0` for floating-point conversion instead of relying on implicit casting. Do eliminate the explicit `WHERE` clause filtering by player names since the conditional aggregation in the `SELECT` list already handles this logic. The amended query now correctly calculates the percentage difference using conditional aggregation on a single joined dataset rather than attempting to cross-join two separate player-attribute pairs."
        ],
        "rules": [
            "1) When answering about percentage difference between two specific players: use SUM aggregates with CASE expressions to calculate ratings for each player instead of directly subtracting individual player ratings. 2) When combining Player and Player_Attributes tables: link rows using INNER JOIN where Player.player_api_id equals Player_Attributes.player_api_id and keep only matching pairs. 3) When referencing player names: use the exact column token \"player_name\" from the appropriate table instead of assuming both exist in a single table. 4) When calculating percentage differences: handle division by zero and data type conversion by multiplying by 1.0 instead of using direct integer division. 5) When filtering for specific players Ariel Borysiuk and Paulin Puel: use exact string literals 'Ariel Borysiuk' and 'Paulin Puel' with correct case and spacing.",
            "1) When answering about percentage difference between two players' ratings: use a single Player table (alias t1) and a single Player_Attributes table (alias t2) joined together. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id using an INNER JOIN. 3) When calculating percentage difference: compute (Ariel Borysiuk's overall_rating - Paulin Puel's overall_rating) * 100.0 / Paulin Puel's overall_rating. 4) When handling player-specific values: use conditional expressions with t1.player_name = 'Ariel Borysiuk' and t1.player_name = 'Paulin Puel' to extract the respective overall_rating values from t2.overall_rating. 5) When performing floating-point arithmetic: use * 1.0 for explicit conversion to ensure proper division results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (A.overall_rating - P.overall_rating) * 100 / P.overall_rating AS percentage_higher\nFROM players A, players P\nWHERE A.name = 'Ariel Borysiuk' AND P.name = 'Paulin Puel';",
            "SELECT \n    (SUM(CASE WHEN p1.player_name = 'Ariel Borysiuk' THEN pa1.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN p2.player_name = 'Paulin Puel' THEN pa2.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN p2.player_name = 'Paulin Puel' THEN pa2.overall_rating ELSE 0 END) AS percentage_difference\nFROM \n    Player p1\nINNER JOIN Player_Attributes pa1 ON p1.player_api_id = pa1.player_api_id,\n    Player p2\nINNER JOIN Player_Attributes pa2 ON p2.player_api_id = pa2.player_api_id\nWHERE \n    p1.player_name = 'Ariel Borysiuk' AND p2.player_name = 'Paulin Puel'",
            "SELECT \n    (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) AS percentage_difference\nFROM \n    Player t1\nINNER JOIN \n    Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE \n    t1.player_name IN ('Ariel Borysiuk', 'Paulin Puel')"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN p.player_name = 'Ariel Borysiuk' THEN pa.overall_rating ELSE 0 END) - \n     SUM(CASE WHEN p.player_name = 'Paulin Puel' THEN pa.overall_rating ELSE 0 END)) * 100.0 / \n    SUM(CASE WHEN p.player_name = 'Paulin Puel' THEN pa.overall_rating ELSE 0 END) AS percentage_difference\nFROM \n    Player p\nINNER JOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.player_name IN ('Ariel Borysiuk', 'Paulin Puel');"
        ],
        "amend_res": 1
    },
    "1423": {
        "db_id": "student_club",
        "question": "How many income are received with an amount of 50?",
        "ground_truth": "SELECT COUNT(income_id) FROM income WHERE amount = 50",
        "amends": [
            "Do count `income_id` instead of `*` to exclude null values from the count. Do filter for `amount = 50` instead of `amount != 50` to count matching records instead of non-matching ones. The amended query now correctly counts records where the amount equals 50 rather than counting records where amount does not equal 50."
        ],
        "rules": [
            "1) When counting records in the income table: count using the exact token \"income_id\" instead of counting all columns to exclude null values. 2) When filtering for records with amount equal to 50: use the exact condition amount = 50 instead of amount != 50 to count matching records rather than non-matching ones."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM income WHERE amount != 50",
            "SELECT COUNT(income_id) FROM income WHERE amount = 50;"
        ],
        "rule_sql": [
            "SELECT COUNT(income_id) FROM income WHERE amount = 50;"
        ],
        "amend_res": 1
    },
    "1193": {
        "db_id": "thrombosis_prediction",
        "question": "Excluding all P only ANA Pattern patients, how many of the remainder are women born between 1980 and 1989?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.`ANA Pattern` != 'P' AND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' AND T1.SEX = 'F'",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Examination AS T2 ON T1.ID = T2.ID` instead of querying only the patients table to incorporate examination data. Do filter on `T2.\"ANA Pattern\" != 'P'` instead of `pattern != 'P only ANA'` to check for different pattern exclusion criteria. Do use `STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'` instead of `birth_year BETWEEN 1980 AND 1989` to extract year from date format. Do filter on `T1.SEX = 'F'` instead of `gender = 'F'` using the correct column name. The amended query now correctly counts distinct female patients born in the 1980s with specific ANA pattern exclusions by joining patient and examination data."
        ],
        "rules": [
            "1) When counting patients: count distinct T1.ID values instead of all rows to count unique patients. 2) When combining patient and examination data: link rows where T1.ID = T2.ID using an inner match to keep only patients with examination records. 3) When excluding P only ANA Pattern patients: filter on T2.\"ANA Pattern\" != 'P' instead of pattern != 'P only ANA' to use the correct exclusion criteria. 4) When filtering by birth year range: extract year from T1.Birthday using STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' instead of using a birth_year column. 5) When filtering for female patients: use T1.SEX = 'F' instead of gender = 'F' to use the correct column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE pattern != 'P only ANA' \nAND gender = 'F' \nAND birth_year BETWEEN 1980 AND 1989;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'\nAND T2.\"ANA Pattern\" != 'P'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.\"ANA Pattern\" != 'P'\nAND T1.SEX = 'F'\nAND STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989'"
        ],
        "amend_res": 1
    },
    "1393": {
        "db_id": "student_club",
        "question": "Provide the full name and email address of the Student_Club's Secretary.",
        "ground_truth": "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'",
        "amends": [
            "Do query the `member` table instead of the `Students` table. Do filter on `position = 'Secretary'` instead of `role = 'President'` while keeping the same column selection of `first_name`, `last_name`, and `email`. The amended query now correctly retrieves secretary information from the member table instead of president information from the students table."
        ],
        "rules": [
            "1) When answering about Student_Club's Secretary: query the \"member\" table instead of the \"Students\" table. 2) When filtering for the Secretary position: use \"position = 'Secretary'\" instead of \"role = 'President'\". 3) When selecting output columns: include \"first_name\", \"last_name\", and \"email\" in that order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name, email FROM Students WHERE role = 'President';",
            "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary';"
        ],
        "rule_sql": [
            "SELECT first_name, last_name, email FROM member WHERE position = 'Secretary';"
        ],
        "amend_res": 1
    },
    "971": {
        "db_id": "formula_1",
        "question": "Please state the reference name of the oldest German driver.",
        "ground_truth": "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1",
        "amends": [
            "Do select `driverRef` instead of `name` for the column name. Do use `JULIANDAY(dob)` instead of `date_of_birth` for the date ordering function and column reference. The amended query now correctly retrieves the driver reference using the proper column name and calculates Julian day for accurate date ordering, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"reference name\" of a driver: use the exact column token \"driverRef\" from the drivers table instead of \"name\". 2) When ordering by date of birth to find the oldest driver: use JULIANDAY(dob) function for accurate date ordering instead of the date_of_birth column. 3) When filtering for German drivers: use the exact literal value 'German' for the nationality condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM drivers WHERE nationality = 'German' ORDER BY date_of_birth ASC LIMIT 1;",
            "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT driverRef FROM drivers WHERE nationality = 'German' ORDER BY JULIANDAY(dob) ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1296": {
        "db_id": "thrombosis_prediction",
        "question": "What is the anti-nucleus antibody concentration of the patient whose total bilirubin is the highest in the normal range?",
        "ground_truth": "SELECT T3.ANA FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` < 2.0 ORDER BY T2.`T-BIL` DESC LIMIT 1",
        "amends": [
            "Do join `Patient AS T1`, `Laboratory AS T2`, and `Examination AS T3` tables instead of querying only the `patients` table. Do use `INNER JOIN` on `T1.ID = T2.ID` and `T1.ID = T3.ID` instead of no joins. Do select `T3.ANA` instead of `anti_nucleus_antibody_concentration`. Do filter with `T2.\"T-BIL\" < 2.0` instead of `total_bilirubin = (SELECT MAX(total_bilirubin) FROM patients WHERE total_bilirubin <= 1.2)`. Do add `ORDER BY T2.\"T-BIL\" DESC LIMIT 1` instead of omitting ordering and limiting. The amended query now correctly retrieves the highest ANA value for patients with T-BIL under 2.0 from the joined tables."
        ],
        "rules": [
            "1) When answering about anti-nucleus antibody concentration: select T3.ANA instead of anti_nucleus_antibody_concentration. 2) When combining Patient, Laboratory, and Examination tables: link rows where T1.ID = T2.ID and T1.ID = T3.ID using inner joins. 3) When filtering for total bilirubin in normal range: use T2.\"T-BIL\" < 2.0 instead of total_bilirubin. 4) When finding the patient with highest total bilirubin: order by T2.\"T-BIL\" DESC and limit to 1 result. 5) When the question mentions \"normal range\" for bilirubin: use the condition T2.\"T-BIL\" < 2.0 to represent the upper bound of normal range."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT anti_nucleus_antibody_concentration \nFROM patients \nWHERE total_bilirubin = (SELECT MAX(total_bilirubin) FROM patients WHERE total_bilirubin <= 1.2);",
            "SELECT T3.ANA\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" < 2.0\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.ANA\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T1.ID = T3.ID\nWHERE T2.\"T-BIL\" < 2.0\nORDER BY T2.\"T-BIL\" DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "474": {
        "db_id": "card_games",
        "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 100?",
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 100 AND T2.language = 'Italian'",
        "amends": [
            "Do select `COUNT(T1.id)` from the `sets` table instead of `COUNT(*)` from the `cards` table. Do join `set_translations AS T2` with `INNER JOIN` on `T2.setCode = T1.code` instead of querying a single table. Do filter with `T2.translation IS NOT NULL` and `T2.language = 'Italian'` instead of `italian_translation IS NOT NULL`. Do use `T1.baseSetSize < 100` instead of `base_set_number < 100`. The amended query now correctly counts Italian translations from the appropriate joined tables with proper language filtering."
        ],
        "rules": [
            "1) When counting cards with Italian translations: count using T1.id from the sets table instead of counting all rows from the cards table. 2) When combining set information with translations: link rows where T2.setCode = T1.code using an inner join between sets table (T1) and set_translations table (T2). 3) When filtering for Italian translations: use T2.translation IS NOT NULL and T2.language = 'Italian' instead of checking italian_translation. 4) When filtering for base set number under 100: use T1.baseSetSize < 100 instead of base_set_number < 100."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM cards \nWHERE italian_translation IS NOT NULL \nAND base_set_number < 100;",
            "SELECT COUNT(T1.id) \nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T2.translation IS NOT NULL \nAND T2.language = 'Italian'\nAND T1.baseSetSize < 100"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T2.language = 'Italian' \nAND T2.translation IS NOT NULL\nAND T1.baseSetSize < 100"
        ],
        "amend_res": 1
    },
    "1013": {
        "db_id": "formula_1",
        "question": "What is the lap record for the Austrian Grand Prix Circuit?",
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
        "amends": [
            "Do use a CTE named `fastest_lap_times` instead of querying `lap_records` directly. Do select from `results` table with alias `T1` instead of `lap_records`, filtering for `FastestLapTime IS NOT NULL` instead of a simple `circuit_name` condition. Do add `INNER JOIN` on `races AS T2` with predicate `fastest_lap_times.raceId = T2.raceId` instead of missing this table relationship. Do add another `INNER JOIN` on `circuits AS T3` with predicate `T2.circuitId = T3.circuitId` instead of omitting this table. Do filter on `T2.name = 'Austrian Grand Prix'` instead of `circuit_name = 'Austrian Grand Prix Circuit'` to match the correct race naming convention. Do aggregate `MIN(fastest_lap_times.fastestLapTime)` with alias `lap_record` instead of `MIN(lap_time)` from the wrong table. The amended query now correctly identifies the fastest lap time by joining through the proper table relationships and filtering on race name rather than circuit name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about lap records: use a CTE named fastest_lap_times instead of querying lap_records directly. 2) When selecting lap time data: select from results table with alias T1 instead of lap_records, filtering for FastestLapTime IS NOT NULL. 3) When combining race information: add INNER JOIN on races AS T2 with predicate fastest_lap_times.raceId = T2.raceId. 4) When combining circuit information: add INNER JOIN on circuits AS T3 with predicate T2.circuitId = T3.circuitId. 5) When filtering for Austrian Grand Prix: use T2.name = 'Austrian Grand Prix' instead of circuit_name = 'Austrian Grand Prix Circuit' to match the correct race naming convention. 6) When computing the lap record: aggregate MIN(fastest_lap_times.fastestLapTime) with alias lap_record instead of MIN(lap_time) from the wrong table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(lap_time) FROM lap_records WHERE circuit_name = 'Austrian Grand Prix Circuit';",
            "WITH fastest_lap_times AS (\n    SELECT \n        raceId,\n        fastestLapTime\n    FROM \n        results AS T1\n    WHERE \n        fastestLapTime IS NOT NULL\n)\nSELECT \n    MIN(fastest_lap_times.fastestLapTime) AS lap_record\nFROM \n    fastest_lap_times\n    INNER JOIN races AS T2 ON fastest_lap_times.raceId = T2.raceId\n    INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE \n    T2.name = 'Austrian Grand Prix'"
        ],
        "rule_sql": [
            "WITH fastest_lap_times AS (\n    SELECT \n        raceId,\n        fastestLapTime\n    FROM \n        results AS T1\n    WHERE \n        fastestLapTime IS NOT NULL\n)\nSELECT \n    MIN(fastest_lap_times.fastestLapTime) AS lap_record\nFROM \n    fastest_lap_times\nINNER JOIN \n    races AS T2 ON fastest_lap_times.raceId = T2.raceId\nINNER JOIN \n    circuits AS T3 ON T2.circuitId = T3.circuitId\nWHERE \n    T2.name = 'Austrian Grand Prix';"
        ],
        "amend_res": 1
    },
    "565": {
        "db_id": "codebase_community",
        "question": "User No.23853 gave a comment to a post at 9:08:18 on 2013/7/12, was that post well-finished?",
        "ground_truth": "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 23853 AND T1.CreationDate = '2013-07-12 09:08:18.0'",
        "amends": [
            "Do select `IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS resylt` instead of `*` from all columns. Do use `comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id` instead of querying only `posts` without joins. Do filter on `T1.UserId = 23853` instead of `user_id = 23853` and `T1.CreationDate = '2013-07-12 09:08:18.0'` instead of `comment_time = '2013-07-12 09:08:18'`. Do remove the `is_finished = 1` filter instead of keeping it. The amended query now correctly joins comments to posts and uses conditional logic to determine completion status based on ClosedDate."
        ],
        "rules": [
            "1) When answering about whether a post is well-finished: use conditional logic to return 'well-finished' if T2.ClosedDate IS NULL, otherwise 'NOT well-finished' as the result. 2) When the question mentions a user comment: query the comments table as T1 instead of posts, and filter on T1.UserId = 23853 instead of user_id. 3) When the question specifies a comment time: use the exact timestamp literal '2013-07-12 09:08:18.0' for T1.CreationDate instead of '2013-07-12 09:08:18'. 4) When combining comments and posts tables: link rows where T1.PostId = T2.Id using an inner join, and do not use the is_finished filter. 5) When determining post completion status: check if T2.ClosedDate IS NULL to determine if the post is well-finished, rather than using a direct boolean field."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM posts WHERE user_id = 23853 AND comment_time = '2013-07-12 09:08:18' AND is_finished = 1;",
            "SELECT IIF(T2.ClosedDate IS NULL, 'NOT well-finished', 'well-finished') AS result\nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853\nAND T1.CreationDate = '2013-07-12 09:08:18.0';"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN T2.ClosedDate IS NULL THEN 'well-finished' \n        ELSE 'NOT well-finished' \n    END AS result\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T1.UserId = 23853 \nAND T1.CreationDate = '2013-07-12 09:08:18.0'"
        ],
        "amend_res": 1
    },
    "419": {
        "db_id": "card_games",
        "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do use `edhrecRank` instead of `edhrec_rank` with the correct column name. Do filter on `borderColor = 'borderless'` instead of `border = 'none'` with the proper column name and value. Do remove the incorrect `color = 'color'` filter instead of including it. The amended query now correctly counts cards with edhrecRank over 12000 that have borderless borders."
        ],
        "rules": [
            "1) When counting cards: count using the canonical key \"id\" instead of counting all rows to avoid null values. 2) When the question mentions \"ranked higher than 12000 on EDHRec\": use the exact column \"edhrecRank\" with comparison > 12000. 3) When the question mentions \"no borders\": use the exact condition \"borderColor = 'borderless'\" with the literal value 'borderless'. 4) When the question mentions \"color cards\": do not include any filter on color columns as the question does not specify a particular color."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE color = 'color' AND border = 'none' AND edhrec_rank > 12000;",
            "SELECT COUNT(id) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000"
        ],
        "amend_res": 1
    },
    "213": {
        "db_id": "toxicology",
        "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
        "ground_truth": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
        "amends": [
            "Do query from `bond AS T1` instead of `bonds`, and add an `INNER JOIN` on `connected AS T2` with `T1.bond_id = T2.bond_id` instead of querying a single table. Do change the WHERE clause to filter on `T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'` instead of `atom1 = 'TR004_8' AND atom2 = 'TR004_20'` to properly handle bidirectional relationships. Do qualify the column as `T1.bond_type` instead of just `bond_type` for explicit table reference. The amended query now correctly identifies bonds between atoms regardless of their order in the relationship."
        ],
        "rules": [
            "1) When answering about bond type between specific atoms: use table \"bond\" as T1 and join with table \"connected\" as T2 on T1.bond_id = T2.bond_id. 2) When filtering for atoms TR004_8 and TR004_20: use condition T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20' to handle bidirectional relationships. 3) When selecting the bond type: use qualified column T1.bond_type instead of unqualified bond_type. 4) When combining bond and connected tables: perform an inner join using exact key equality T1.bond_id = T2.bond_id and keep only matching pairs."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM bonds WHERE atom1 = 'TR004_8' AND atom2 = 'TR004_20';",
            "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE (T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20') OR (T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20')"
        ],
        "rule_sql": [
            "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE (T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20') OR (T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20')"
        ],
        "amend_res": 1
    },
    "679": {
        "db_id": "codebase_community",
        "question": "Which post has the highest score? Please give its id and title's name.",
        "ground_truth": "SELECT T1.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
        "amends": [
            "Do select `T1.Id` and `T2.Title` from joined tables instead of just `id` and `title` from a single table. Do use `INNER JOIN` between `users AS T1` and `posts AS T2` with join condition `T1.Id = T2.OwnerUserId` instead of querying only the `posts` table. Do order by `T2.Score DESC` instead of `score ASC` to get the highest scoring post. The amended query now correctly retrieves the highest-scoring post from the joined user-post relationship instead of the lowest-scoring post from posts alone, matching the intended behavior.",
            "Do select `T1.Id` instead of `T2.Id` in the SELECT list to return the user ID from the users table rather than the post ID from the posts table, while maintaining the same `INNER JOIN` on `T1.Id = T2.OwnerUserId`, `ORDER BY T2.Score DESC`, and `LIMIT 1` structure. The amended query now correctly returns the user ID with the highest-scoring post instead of the post ID itself, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"highest score post\": make sure the output order: T1.Id, T2.Title. 2) When combining users and posts tables: link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match). 3) When the question mentions \"highest score\": rank rows by T2.Score in descending order and keep the first 1 row. 4) When the question asks for \"id and title's name\": select T1.Id and T2.Title using the exact identifier tokens from the joined tables.",
            "1) When answering about \"which post has the highest score\": make sure the output order: post id and title name. 2) When the question asks for \"post id and title's name\": use \"T2.Id\" for post id and \"T2.Title\" for title name from the posts table. 3) When the question mentions \"highest score\": rank rows by \"T2.Score\" in descending order and keep the first 1 row. 4) When combining users and posts tables: link rows where \"T1.Id = T2.OwnerUserId\" exactly as shown; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT id, title FROM posts ORDER BY score ASC LIMIT 1;",
            "SELECT T2.Id, T2.Title FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId ORDER BY T2.Score DESC LIMIT 1",
            "SELECT T1.Id, T2.Title \nFROM users AS T1 \nINNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId \nORDER BY T2.Score DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Id, T2.Title\nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nORDER BY T2.Score DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "429": {
        "db_id": "card_games",
        "question": "What is the language and expansion type of set number 206?",
        "ground_truth": "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206",
        "amends": [
            "Do select `T2.language` and `T1.type` instead of `language` and `expansion_type`. Do use `FROM sets AS T1 INNER JOIN set_translations AS T2` instead of `FROM sets` alone. Do apply join condition `ON T1.code = T2.setCode` instead of no join. Do filter with `WHERE T2.id = 206` instead of `WHERE set_number = 206`. The amended query now correctly joins the translation table and filters by translation ID rather than set number, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"language and expansion type of set number 206\": make sure the output order: T2.language, T1.type. 2) When the question mentions \"set number 206\": \"set number 206\" actually means \"T2.id = 206\" in schema. 3) When combining T1 (sets) and T2 (set_translations) for shared entities: link rows where T1.code = T2.setCode exactly as shown; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language, expansion_type FROM sets WHERE set_number = 206",
            "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206"
        ],
        "rule_sql": [
            "SELECT T2.language, T1.type FROM sets T1 INNER JOIN set_translations T2 ON T1.code = T2.setCode WHERE T2.id = 206"
        ],
        "amend_res": 1
    },
    "1308": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients who have a normal platelet level, how many of them have other symptoms observed?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 100 AND T2.PLT < 400 AND T1.Diagnosis IS NOT NULL",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific column instead of `COUNT(*)` from all rows. Do join `Patient AS T1 INNER JOIN Laboratory AS T2` instead of querying only the `patients` table. Do use join condition `ON T1.ID = T2.ID` instead of no join. Do filter on `T2.PLT > 100 AND T2.PLT < 400` for platelet range instead of `platelet_level = 'normal'` string comparison. Do check `T1.Diagnosis IS NOT NULL` instead of `symptoms IS NOT NULL`. The amended query now correctly counts patients with laboratory-confirmed normal platelet levels and valid diagnosis, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers. 2) When combining patient and laboratory data: join Patient AS T1 INNER JOIN Laboratory AS T2 using the condition T1.ID = T2.ID to link matching patient records. 3) When identifying normal platelet levels: filter on T2.PLT > 100 AND T2.PLT < 400 instead of using string comparison for platelet_level. 4) When checking for other symptoms: use T1.Diagnosis IS NOT NULL instead of symptoms IS NOT NULL to validate diagnosis information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE platelet_level = 'normal' AND symptoms IS NOT NULL;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.PLT > 100 AND T2.PLT < 400 \nAND T1.Diagnosis IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.PLT > 100 AND T2.PLT < 400 \nAND T1.Diagnosis IS NOT NULL"
        ],
        "amend_res": 1
    },
    "847": {
        "db_id": "formula_1",
        "question": "What is the surname of the driver with the best lap time in race number 19 in the second qualifying period?",
        "ground_truth": "SELECT T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 19 ORDER BY T1.q2 ASC LIMIT 1",
        "amends": [
            "Do join `qualifying AS T1` and `drivers AS T2` with `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `drivers` table. Do filter on `T1.raceId = 19` instead of `race_number = 19`. Do select `T2.surname` with table qualification instead of just `surname`. Do order by `T1.q2 ASC` instead of `lap_time ASC`. Do remove the `qualifying_period = 2` filter instead of keeping it. The amended query now correctly retrieves the driver surname based on qualifying session 2 performance for race 19."
        ],
        "rules": [
            "1) When answering about driver surnames from qualifying data: combine qualifying table as T1 and drivers table as T2 using inner match where T2.driverId = T1.driverId. 2) When the question mentions \"race number 19\": filter on T1.raceId = 19 instead of race_number. 3) When the question asks for the best lap time in the second qualifying period: order by T1.q2 ASC to find the fastest time. 4) When selecting the driver surname: use T2.surname with table qualification. 5) When the question specifies the second qualifying period: do not filter on qualifying_period = 2 as the timing data is already in T1.q2."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT surname FROM drivers WHERE race_number = 19 AND qualifying_period = 2 ORDER BY lap_time ASC LIMIT 1;",
            "SELECT T2.surname \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 19 \nORDER BY T1.q2 ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.surname \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 19 \nORDER BY T1.q2 ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "538": {
        "db_id": "codebase_community",
        "question": "Please list the titles of the posts owned by the user csgillespie?",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do join `posts AS T1` with `users AS T2` on `T1.OwnerUserId = T2.Id` instead of querying `posts` alone without any join. Do filter on `T2.DisplayName = 'csgillespie'` instead of filtering on non-existent `username` column. Do select `T1.Title` with proper table alias instead of selecting just `title` without qualification. The amended query now correctly joins user data to filter by display name instead of attempting to use a non-existent username column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"posts owned by user csgillespie\": make sure to join posts AS T1 with users AS T2 on T1.OwnerUserId = T2.Id and keep only matching pairs (inner match). 2) When the question mentions \"user csgillespie\": \"csgillespie\" actually means T2.DisplayName = 'csgillespie' in schema. 3) When selecting post titles: use T1.Title with proper table alias instead of unqualified title. 4) When combining T1 and T2 for shared entities: link rows where T1.OwnerUserId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts WHERE username = 'csgillespie';",
            "SELECT T1.Title \nFROM posts AS T1 \nJOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT T1.Title \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "amend_res": 1
    },
    "1214": {
        "db_id": "thrombosis_prediction",
        "question": "List ID, sex and date of birth of patient whose total protein (TP) below the lower range of the normal index.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate patient records. Do select `SEX` and `Birthday` instead of `sex` and `date_of_birth` with different column names. Do join `Laboratory` table as `T2` instead of `lab_results` with different table name and alias. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of `JOIN` on `p.ID = lr.patient_id` with different join condition and column references. Do filter with `T2.TP < 6.0` instead of the complex subquery checking `test_name = 'TP'` and comparing against `normal_ranges` table minimum values. Do remove the subquery entirely instead of including it, as the right query uses a direct threshold comparison. The amended query now correctly identifies patients with TP laboratory values below 6.0 without the unnecessary normal_ranges table reference."
        ],
        "rules": [
            "1) When answering about patients with total protein (TP) below normal range: use a direct threshold comparison of T2.TP < 6.0 instead of referencing a normal_ranges table. 2) When selecting patient information: use DISTINCT to eliminate duplicate patient records. 3) When selecting gender and birth date: use exact column names \"SEX\" and \"Birthday\" instead of \"sex\" and \"date_of_birth\". 4) When joining laboratory data: use table \"Laboratory\" with alias T2 instead of \"lab_results\". 5) When combining Patient and Laboratory tables: link rows using T1.ID = T2.ID instead of p.ID = lr.patient_id. 6) When filtering laboratory results: use T2.TP column directly instead of checking test_name = 'TP' and result_value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.ID, p.sex, p.date_of_birth \nFROM patients p \nJOIN lab_results lr ON p.ID = lr.patient_id \nWHERE lr.test_name = 'TP' AND lr.result_value < (SELECT MIN(normal_range_low) FROM normal_ranges WHERE test_name = 'TP')",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.TP < 6.0"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nJOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.TP < 6.0"
        ],
        "amend_res": 1
    },
    "330": {
        "db_id": "toxicology",
        "question": "Calculate the percentage of carcinogenic molecules with triple bonded Hidrogen atoms.",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T2.element = 'h'",
        "amends": [
            "Do use `SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN carcinogenic = 1 AND triple_bonded_hydrogen = 1 THEN 1 END)` for conditional counting. Do add explicit `CAST` to `REAL` instead of implicit decimal division. Do change the calculation to multiply by 100 after division instead of before. Do completely restructure the FROM clause with `INNER JOIN` on `molecule AS T1`, `atom AS T2`, and `bond AS T3` instead of a single table `molecules`. Do add join conditions `T1.molecule_id = T2.molecule_id` and `T1.molecule_id = T3.molecule_id` instead of no joins. Do add WHERE filter `T3.bond_type = '#' AND T2.element = 'h'` instead of filtering through CASE expressions. Do use `COUNT(DISTINCT T1.molecule_id)` instead of simple COUNT for denominator calculation. The amended query now correctly calculates the percentage of molecules with '+' label among those containing triple-bonded hydrogen atoms."
        ],
        "rules": [
            "1) When calculating percentages involving conditional counts: use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for conditional counting. 2) When performing decimal division: explicitly CAST to REAL instead of relying on implicit decimal conversion. 3) When calculating percentages: multiply by 100 after division instead of before division. 4) When combining data from multiple tables (molecule, atom, bond): use INNER JOIN with exact join conditions T1.molecule_id = T2.molecule_id and T1.molecule_id = T3.molecule_id instead of querying a single table. 5) When filtering for triple-bonded hydrogen atoms: use WHERE clause with exact conditions T3.bond_type = '#' AND T2.element = 'h' instead of filtering through CASE expressions. 6) When counting distinct entities in the denominator: use COUNT(DISTINCT T1.molecule_id) instead of simple COUNT to avoid double-counting. 7) When referring to carcinogenic molecules: use T1.label = '+' instead of carcinogenic = 1 as the condition."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN carcinogenic = 1 AND triple_bonded_hydrogen = 1 THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN triple_bonded_hydrogen = 1 THEN 1 END)) AS percentage\nFROM molecules;",
            "SELECT \n    (SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) * 100.0 / COUNT(DISTINCT T1.molecule_id)) AS percentage\nFROM \n    molecule AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN bond AS T3 ON T1.molecule_id = T3.molecule_id\nWHERE \n    T3.bond_type = '#' \n    AND T2.element = 'h';"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(SUM(CASE WHEN T1.label = '+' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T1.molecule_id)) * 100 AS percentage\nFROM \n    molecule T1\n    INNER JOIN atom T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN connected T3 ON T2.atom_id = T3.atom_id OR T2.atom_id = T3.atom_id2\n    INNER JOIN bond T4 ON T3.bond_id = T4.bond_id AND T1.molecule_id = T4.molecule_id\nWHERE \n    T4.bond_type = '#' AND T2.element = 'h'"
        ],
        "amend_res": 1
    },
    "1144": {
        "db_id": "european_football_2",
        "question": "Please state the finishing rate and curve score of the player who has the heaviest weight.",
        "ground_truth": "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = ( SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1 ) LIMIT 1",
        "amends": [
            "Do select `id`, `finishing`, and `curve` columns instead of `finishing_rate` and `curve_score`. Do query from `Player_Attributes` table instead of `players`. Do add a WHERE clause with a subquery that selects `player_api_id` from `Player` table ordered by `weight DESC` with `LIMIT 1` instead of directly ordering by weight from the main table. Do maintain the final `LIMIT 1` instead of omitting it. The amended query now correctly retrieves specific attributes for the heaviest player by first identifying that player's ID from the Player table and then fetching their attributes from Player_Attributes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"finishing rate\" and \"curve score\": these actually mean columns \"finishing\" and \"curve\" from table \"Player_Attributes\". 2) When identifying the heaviest player: first find the \"player_api_id\" from table \"Player\" ordered by \"weight DESC\" with \"LIMIT 1\". 3) When retrieving attributes for a specific player: use a WHERE clause to match \"player_api_id\" in \"Player_Attributes\" with the player ID found from the \"Player\" table. 4) When the question asks for a single result: maintain \"LIMIT 1\" on the final query."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT finishing_rate, curve_score FROM players ORDER BY weight DESC LIMIT 1;",
            "SELECT id, finishing, curve FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 1) LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT pa.finishing, pa.curve \nFROM Player_Attributes pa\nWHERE pa.player_api_id = (\n    SELECT player_api_id \n    FROM Player \n    ORDER BY weight DESC \n    LIMIT 1\n)\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "554": {
        "db_id": "codebase_community",
        "question": "What is the display name of the user who has obtained the most number of badges?",
        "ground_truth": "SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY T2.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
        "amends": [
            "Do use `INNER JOIN` on `T1.UserId = T2.Id` instead of a correlated subquery in the ORDER BY clause. Do add `GROUP BY T2.DisplayName` instead of omitting aggregation grouping. Do use `COUNT(T1.Id)` in the ORDER BY instead of `COUNT(*)` from a subquery. Do reference `T2.DisplayName` in the SELECT instead of `display_name` from the users table directly. The amended query now correctly joins and aggregates badge counts per user before ordering by the count."
        ],
        "rules": [
            "1) When counting badges per user: use COUNT(T1.Id) to count the number of badges for each user. 2) When combining users and badges tables: link rows where T1.UserId = T2.Id using an inner join to keep only users with badges. 3) When grouping results by user: use GROUP BY T2.DisplayName to organize results by each user's display name. 4) When selecting the user with the most badges: order results by the badge count in descending order and take the first result. 5) When outputting the result: return T2.DisplayName as the display name of the user."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users ORDER BY (SELECT COUNT(*) FROM badges WHERE badges.user_id = users.id) DESC LIMIT 1;",
            "SELECT T2.DisplayName\nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nGROUP BY T2.DisplayName\nORDER BY COUNT(T1.Id) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName\nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nGROUP BY T2.DisplayName\nORDER BY COUNT(T1.Id) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "312": {
        "db_id": "toxicology",
        "question": "What is the carcinogenic label for bond TR001_2_4?",
        "ground_truth": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'",
        "amends": [
            "Do query from `atom AS T1`, `molecule AS T2`, and `bond AS T3` tables instead of only `bonds`; do use `INNER JOIN` relationships between `T1.molecule_id = T2.molecule_id` and `T2.molecule_id = T3.molecule_id` instead of no joins; do select `T2.label` instead of `carcinogenic_label`; do add `DISTINCT` modifier instead of omitting it; do filter on `T3.bond_id = 'TR001_2_4'` instead of `bond_id = 'TR001_2_4'`; the amended query now correctly retrieves distinct labels from related molecule data through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"carcinogenic label for bond TR001_2_4\": make sure the output order: T2.label 2) When the question mentions \"bond TR001_2_4\": \"bond TR001_2_4\" actually means \"T3.bond_id = 'TR001_2_4'\" in schema 3) When combining tables for shared entities: link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match) 4) When selecting the label: use DISTINCT modifier to get unique values of T2.label 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for 'TR001_2_4'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic_label FROM bonds WHERE bond_id = 'TR001_2_4';",
            "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_id = 'TR001_2_4'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.label FROM bond T3 JOIN molecule T2 ON T3.molecule_id = T2.molecule_id WHERE T3.bond_id = 'TR001_2_4'"
        ],
        "amend_res": 1
    },
    "746": {
        "db_id": "superhero",
        "question": "Calculate the average attribute value of all superheroes.",
        "ground_truth": "SELECT AVG(attribute_value) FROM hero_attribute",
        "amends": [
            "Do reference the `attribute_value` column instead of `attribute` in the SELECT list. Do query from the `hero_attribute` table instead of the `superheroes` table. Do remove the `WHERE attribute IS NOT NULL` filter instead of keeping it, as the AVG function inherently ignores NULL values. The amended query now correctly calculates the average of attribute values from the appropriate table structure."
        ],
        "rules": [
            "1) When answering about \"average attribute value of all superheroes\": use the column \"attribute_value\" from table \"hero_attribute\" instead of \"attribute\" from table \"superheroes\". 2) When calculating averages: do not add explicit NULL filters since the AVG function inherently ignores NULL values. 3) When the question mentions \"superheroes\" but the data is stored in \"hero_attribute\" table: query from the \"hero_attribute\" table to access the correct attribute values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(attribute) FROM superheroes WHERE attribute IS NOT NULL;",
            "SELECT AVG(attribute_value) FROM hero_attribute;"
        ],
        "rule_sql": [
            "SELECT AVG(attribute_value) FROM hero_attribute;"
        ],
        "amend_res": 1
    },
    "655": {
        "db_id": "codebase_community",
        "question": "Write down the related posts titles and link type IDs of the post \"What are principal component scores?\".",
        "ground_truth": "SELECT T3.Title, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id WHERE T1.Title = 'What are principal component scores?'",
        "amends": [
            "Do add `INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId` and `INNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id` instead of querying only the `posts` table. Do select `T3.Title` and `T2.LinkTypeId` instead of `title` and `link_type_id` from the original table. Do keep the filter `WHERE T1.Title = 'What are principal component scores?'` but apply it to the source post instead of the related post. The amended query now correctly joins through the postLinks table to retrieve related post information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about related posts for a specific post title: join the posts table as T1 with postLinks as T2 using T1.Id = T2.PostId, then join with posts as T3 using T2.RelatedPostId = T3.Id to get related post information. 2) When the question asks for related post titles and link type IDs: select T3.Title and T2.LinkTypeId from the joined tables. 3) When filtering for the specific post \"What are principal component scores?\": apply the condition T1.Title = 'What are principal component scores?' to the source post table T1, not the related post table T3."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title, link_type_id FROM posts WHERE title = 'What are principal component scores?'",
            "SELECT T3.Title, T2.LinkTypeId\nFROM posts AS T1\nINNER JOIN postLinks AS T2 ON T1.Id = T2.PostId\nINNER JOIN posts AS T3 ON T2.RelatedPostId = T3.Id\nWHERE T1.Title = 'What are principal component scores?'"
        ],
        "rule_sql": [
            "SELECT T3.Title, T2.LinkTypeId \nFROM posts T1 \nJOIN postLinks T2 ON T1.Id = T2.PostId \nJOIN posts T3 ON T2.RelatedPostId = T3.Id \nWHERE T1.Title = 'What are principal component scores?'"
        ],
        "amend_res": 1
    },
    "141": {
        "db_id": "financial",
        "question": "Which districts have transactions greater than USS$10,000 in 1997?",
        "evidence": "",
        "ground_truth": "SELECT T1.district_id FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T1.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date) = '1997' GROUP BY T1.district_id HAVING SUM(T3.amount) > 10000",
        "amends": [
            "Do select `T1.district_id` instead of `district` and add proper table aliases. Do join `account AS T1` and `district AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of missing these tables entirely. Do add another `INNER JOIN` to `trans AS T3` on `T1.account_id = T3.account_id` instead of querying `transactions` directly. Do use `STRFTIME('%Y', T3.date) = '1997'` for year filtering instead of `year = 1997` to properly extract year from date. Do add `GROUP BY T1.district_id` and move the amount condition to `HAVING SUM(T3.amount) > 10000` instead of using `WHERE amount > 10000` to aggregate transactions per district. The amended query now correctly calculates total transaction amounts per district for 1997 and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about districts with transactions greater than USS$10,000 in 1997: make sure the output order: T1.district_id\n2) When the question mentions \"districts\": \"districts\" actually means \"T1.district_id in schema\"\n3) When combining account AS T1 and district AS T2 for shared entities: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)\n4) When combining T1 and trans AS T3 for shared entities: link rows where T1.account_id = T3.account_id and keep only matching pairs (inner match)\n5) When the question asks about transactions in 1997: use STRFTIME('%Y', T3.date) = '1997' to filter for year 1997\n6) When the question asks for transactions greater than USS$10,000 per district: organize results by T1.district_id and compute SUM(T3.amount) > 10000 per group using HAVING clause\n7) When handling text literals: do not change case, spacing, or punctuation for '1997'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district FROM transactions WHERE amount > 10000 AND year = 1997;",
            "SELECT T1.district_id\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T1.account_id = T3.account_id\nWHERE STRFTIME('%Y', T3.date) = '1997'\nGROUP BY T1.district_id\nHAVING SUM(T3.amount) > 10000"
        ],
        "rule_sql": [
            "SELECT T1.district_id\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN trans AS T3 ON T1.account_id = T3.account_id\nWHERE STRFTIME('%Y', T3.date) = '1997'\nGROUP BY T1.district_id\nHAVING SUM(T3.amount) > 10000\nORDER BY T1.district_id"
        ],
        "amend_res": 1
    },
    "1481": {
        "db_id": "debit_card_specializing",
        "question": "What is the difference in the annual average consumption of the customers with the least amount of consumption paid in CZK for 2013 between SME and LAM, LAM and KAM, and KAM and SME?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) , CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) - CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / COUNT(T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'CZK' AND T2.Consumption = ( SELECT MIN(Consumption) FROM yearmonth ) AND T2.Date BETWEEN 201301 AND 201312",
        "amends": [
            "Do use explicit column calculations with `SUM(IIF(...)) / COUNT(...)` instead of `AVG(CASE ... END)` for proper average computation. Do add table `yearmonth AS T2` with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do add filter conditions `T1.Currency = 'CZK'` and `T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)` and `T2.Date BETWEEN 201301 AND 201312` instead of only filtering by `year = 2013`. Do remove the `UNION ALL` structure and instead compute all three comparisons in a single row with separate columns instead of multiple rows. Do use `CAST(... AS REAL)` for explicit type conversion instead of implicit casting. Do reference columns with table aliases `T1.Segment` and `T2.Consumption` instead of unqualified column names. The amended query now correctly computes the average consumption differences between customer segments for the minimum consumption records within the specified date range and currency.",
            "Do use `COUNT(T1.CustomerID)` as the denominator instead of `SUM(IIF(T1.Segment = 'SME', 1, 0))` and similar conditional sums for each segment to properly count all relevant customers. Do remove the explicit `AS` aliases `SME_LAM_Diff`, `LAM_KAM_Diff`, and `KAM_SME_Diff` instead of keeping them to match the unaliased output. Do use integer literals `201301` and `201312` instead of string literals `'201301'` and `'201312'` for the date range comparison. The amended query now correctly calculates average consumption differences by using consistent customer counts across all segments rather than segment-specific counts, ensuring proper comparison logic."
        ],
        "rules": [
            "1) When answering about annual average consumption differences between customer segments: make sure the output order includes all three comparisons in a single row with separate columns instead of multiple rows. 2) When the question mentions \"customers with the least amount of consumption\": filter to only include rows where T2.Consumption equals the minimum consumption value from the yearmonth table. 3) When the question specifies \"paid in CZK\": add filter condition T1.Currency = 'CZK' exactly as shown. 4) When the question specifies \"for 2013\": filter T2.Date to be between 201301 and 201312 inclusive. 5) When combining customers and yearmonth tables: link rows where T1.CustomerID = T2.CustomerID using an inner join and keep only matching pairs. 6) When computing averages: use explicit calculations with SUM(IIF(...)) / COUNT(...) instead of AVG(CASE ... END) for proper average computation. 7) When handling numeric values: use CAST(... AS REAL) for explicit type conversion instead of implicit casting. 8) When referring to columns: always use table aliases T1.Segment and T2.Consumption instead of unqualified column names.",
            "1) When calculating average consumption differences between segments: use COUNT(T1.CustomerID) as the denominator instead of conditional sums for each segment to properly count all relevant customers. 2) When specifying date range for year 2013: use integer literals 201301 and 201312 instead of string literals '201301' and '201312'. 3) When producing output for consumption differences: do not use explicit column aliases SME_LAM_Diff, LAM_KAM_Diff, and KAM_SME_Diff to match unaliased output format."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    'SME vs LAM' as comparison,\n    AVG(CASE WHEN customer_type = 'SME' THEN annual_consumption END) - AVG(CASE WHEN customer_type = 'LAM' THEN annual_consumption END) as difference\nFROM customers\nWHERE year = 2013\nUNION ALL\nSELECT \n    'LAM vs KAM' as comparison,\n    AVG(CASE WHEN customer_type = 'LAM' THEN annual_consumption END) - AVG(CASE WHEN customer_type = 'KAM' THEN annual_consumption END) as difference\nFROM customers\nWHERE year = 2013\nUNION ALL\nSELECT \n    'KAM vs SME' as comparison,\n    AVG(CASE WHEN customer_type = 'KAM' THEN annual_consumption END) - AVG(CASE WHEN customer_type = 'SME' THEN annual_consumption END) as difference\nFROM customers\nWHERE year = 2013;",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / SUM(IIF(T1.Segment = 'SME', 1, 0)) - \n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / SUM(IIF(T1.Segment = 'LAM', 1, 0)) AS SME_LAM_Diff,\n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) AS REAL) / SUM(IIF(T1.Segment = 'LAM', 1, 0)) - \n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / SUM(IIF(T1.Segment = 'KAM', 1, 0)) AS LAM_KAM_Diff,\n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) AS REAL) / SUM(IIF(T1.Segment = 'KAM', 1, 0)) - \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) AS REAL) / SUM(IIF(T1.Segment = 'SME', 1, 0)) AS KAM_SME_Diff\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK' \nAND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)\nAND T2.Date BETWEEN '201301' AND '201312'",
            "SELECT \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) / COUNT(T1.CustomerID) AS REAL) - \n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) / COUNT(T1.CustomerID) AS REAL) AS SME_LAM_Diff,\n    CAST(SUM(IIF(T1.Segment = 'LAM', T2.Consumption, 0)) / COUNT(T1.CustomerID) AS REAL) - \n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) / COUNT(T1.CustomerID) AS REAL) AS LAM_KAM_Diff,\n    CAST(SUM(IIF(T1.Segment = 'KAM', T2.Consumption, 0)) / COUNT(T1.CustomerID) AS REAL) - \n    CAST(SUM(IIF(T1.Segment = 'SME', T2.Consumption, 0)) / COUNT(T1.CustomerID) AS REAL) AS KAM_SME_Diff\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'CZK' \n    AND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth)\n    AND T2.Date BETWEEN 201301 AND 201312"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(T1.Segment = 'SME', CAST(T2.Consumption AS REAL), 0)) / COUNT(IIF(T1.Segment = 'SME', T1.CustomerID, NULL))) - \n    (SUM(IIF(T1.Segment = 'LAM', CAST(T2.Consumption AS REAL), 0)) / COUNT(IIF(T1.Segment = 'LAM', T1.CustomerID, NULL))) AS SME_LAM_Diff,\n    \n    (SUM(IIF(T1.Segment = 'LAM', CAST(T2.Consumption AS REAL), 0)) / COUNT(IIF(T1.Segment = 'LAM', T1.CustomerID, NULL))) - \n    (SUM(IIF(T1.Segment = 'KAM', CAST(T2.Consumption AS REAL), 0)) / COUNT(IIF(T1.Segment = 'KAM', T1.CustomerID, NULL))) AS LAM_KAM_Diff,\n    \n    (SUM(IIF(T1.Segment = 'KAM', CAST(T2.Consumption AS REAL), 0)) / COUNT(IIF(T1.Segment = 'KAM', T1.CustomerID, NULL))) - \n    (SUM(IIF(T1.Segment = 'SME', CAST(T2.Consumption AS REAL), 0)) / COUNT(IIF(T1.Segment = 'SME', T1.CustomerID, NULL))) AS KAM_SME_Diff\nFROM \n    customers T1\nINNER JOIN \n    yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'CZK' \n    AND T2.Date BETWEEN 201301 AND 201312\n    AND T2.Consumption = (SELECT MIN(Consumption) FROM yearmonth WHERE Date BETWEEN 201301 AND 201312);"
        ],
        "amend_res": 1
    },
    "676": {
        "db_id": "codebase_community",
        "question": "Please list all display names of users who are adults.",
        "ground_truth": "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65",
        "amends": [
            "Do use `DisplayName` instead of `display_name` for the column selection. Do change the filter to `Age BETWEEN 19 AND 65` instead of `age < 18` to target a different age range. The amended query now correctly selects the appropriate column name and filters for users between 19 and 65 years old, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting display names from the users table: use the exact column name \"DisplayName\" as shown in the schema. 2) When filtering for adult users: use the age range condition Age BETWEEN 19 AND 65 to include users from 19 to 65 years old inclusive. 3) When the question asks for \"display names of users who are adults\": ensure the output contains only the DisplayName column with the specified age filter applied."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users WHERE age < 18;",
            "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65"
        ],
        "amend_res": 1
    },
    "1509": {
        "db_id": "debit_card_specializing",
        "question": "Among the transactions made in the gas stations in the Czech Republic, how many of them are taken place after 2012/1/1?",
        "ground_truth": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND STRFTIME('%Y', T1.Date) >= '2012'",
        "amends": [
            "Do join `gasstations` as `T2` instead of querying only the `transactions` table. Do reference `T2.Country` instead of `country` and use country code 'CZE' instead of full name 'Czech Republic'. Do filter by `STRFTIME('%Y', T1.Date) >= '2012'` instead of `transaction_date > '2012/01/01'` to capture all transactions from 2012 onward. Do count `T1.TransactionID` instead of `COUNT(*)` for more precise counting. The amended query now correctly joins the gas stations table to filter by country code and uses proper date handling to include all transactions from 2012, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about transactions in gas stations: combine tables \"transactions\" as T1 and \"gasstations\" as T2 using inner match where T1 and T2 are linked by their canonical keys. 2) When the question mentions \"Czech Republic\": use country code 'CZE' instead of full name 'Czech Republic' and reference T2.Country for filtering. 3) When filtering transactions by date after 2012/1/1: use STRFTIME('%Y', T1.Date) >= '2012' to capture all transactions from 2012 onward. 4) When counting transactions: count T1.TransactionID instead of all rows for more precise counting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM transactions WHERE country = 'Czech Republic' AND transaction_date > '2012/01/01';",
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k T1\nJOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE' \nAND STRFTIME('%Y', T1.Date) >= '2012'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.TransactionID) \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.Country = 'CZE'\nAND STRFTIME('%Y', T1.Date) >= '2012'"
        ],
        "amend_res": 1
    },
    "341": {
        "db_id": "card_games",
        "question": "What are the borderless cards available without powerful foils?",
        "ground_truth": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
        "amends": [
            "Do select `id` instead of `*` for the column list. Do use `borderColor` instead of `border` for the column name in the filter condition. Do replace the `foil = 'powerful'` condition with `(cardKingdomId IS NULL OR cardKingdomId IS NULL)` instead of keeping the incorrect filter. The amended query now correctly filters for borderless cards with null cardKingdomId values instead of incorrectly checking for foil cards with a 'powerful' value.",
            "Do use `cardKingdomId IS NULL` in both OR conditions instead of `cardKingdomFoilId IS NULL` in the second condition, maintaining the correct logic to find cards where either cardKingdomId value is missing for borderless cards instead of incorrectly checking cardKingdomFoilId. The amended query now correctly matches the intended behavior of checking the same column in both conditions."
        ],
        "rules": [
            "1) When answering about \"borderless cards available without powerful foils\": make sure the output order: id. 2) When the question mentions \"borderless\": \"borderless\" actually means \"borderColor = 'borderless'\" in schema. 3) When the question mentions \"without powerful foils\": \"without powerful foils\" actually means \"(cardKingdomId IS NULL OR cardKingdomId IS NULL)\" in schema. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms.",
            "1) When the question mentions \"borderless cards\": use the exact literal 'borderless' for the \"borderColor\" column condition. 2) When checking for cards available without powerful foils: verify that either \"cardKingdomId\" is missing (IS NULL) in both conditions of the OR clause, not checking different columns. 3) When producing output: include only the \"id\" column as specified in the question about available cards."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE border = 'borderless' AND foil = 'powerful'",
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL)",
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)"
        ],
        "amend_res": 1
    },
    "1417": {
        "db_id": "student_club",
        "question": "List out the type of events which have remaining budget more than 30 USD.",
        "ground_truth": "SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30",
        "amends": [
            "Do select `T1.type` from the `event` table instead of `event_type` from the `events` table. Do add an `INNER JOIN` with the `budget` table on `T1.event_id = T2.link_to_event` instead of querying a single table. Do filter on `T2.remaining > 30` instead of `budget > 30` to reference the correct column from the joined budget table. The amended query now correctly joins the event and budget tables to filter events based on remaining budget rather than attempting to reference a budget column that doesn't exist in the events table, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"type of events\": select \"T1.type\" from the \"event\" table instead of \"event_type\" from \"events\" table. 2) When combining event and budget information: perform an inner join between \"event\" table as T1 and \"budget\" table as T2 where \"T1.event_id\" = \"T2.link_to_event\" to match related records. 3) When filtering for remaining budget more than 30 USD: apply the condition \"T2.remaining\" > 30 to reference the correct budget column from the joined table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_type FROM events WHERE budget > 30",
            "SELECT DISTINCT e.type \nFROM event e\nINNER JOIN budget b ON e.event_id = b.link_to_event\nWHERE b.remaining > 30"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.type FROM event T1 INNER JOIN budget T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30"
        ],
        "amend_res": 1
    },
    "267": {
        "db_id": "toxicology",
        "question": "List down the bond type for molecules from molecule id TR000 to TR050.",
        "ground_truth": "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'",
        "amends": [
            "Do add table `molecule AS T1` and `bond AS T2` instead of querying only the `molecules` table. Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying a single table. Do change the SELECT list to include `T2.molecule_id, T2.bond_type` instead of only `bond_type`. Do move the filter condition to reference `T1.molecule_id` instead of `molecule_id` from the original table. The amended query now correctly joins the molecule and bond tables to retrieve bond information for the specified molecule range, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"bond type for molecules from molecule id TR000 to TR050\": make sure the output order: T2.molecule_id, T2.bond_type. 2) When the question mentions \"molecules\": \"molecules\" actually means \"molecule AS T1\" and \"bond AS T2\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match). 4) When filtering by molecule_id range: apply the condition T1.molecule_id BETWEEN 'TR000' AND 'TR050' using the exact literals 'TR000' and 'TR050'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM molecules WHERE molecule_id BETWEEN 'TR000' AND 'TR050';",
            "SELECT T2.molecule_id, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'"
        ],
        "rule_sql": [
            "SELECT T2.molecule_id, T2.bond_type\nFROM molecule AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.molecule_id BETWEEN 'TR000' AND 'TR050'\nORDER BY T2.molecule_id, T2.bond_type"
        ],
        "amend_res": 1
    },
    "1108": {
        "db_id": "european_football_2",
        "question": "What was the build up play speed class for \"Willem II\" on 2011/2/22?",
        "ground_truth": "SELECT t2.buildUpPlaySpeedClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Willem II' AND SUBSTR(t2.`date`, 1, 10) = '2011-02-22'",
        "amends": [
            "Do reference `buildUpPlaySpeedClass` from the joined table `t2` instead of directly from `team_attributes`. Do join `Team AS t1` with `Team_Attributes AS t2` on `t1.team_api_id = t2.team_api_id` instead of querying `team_attributes` alone. Do filter on `t1.team_long_name = 'Willem II'` instead of `team_name = 'Willem II'`. Do use `SUBSTR(t2.date, 1, 10) = '2011-02-22'` for date comparison instead of `date = '2011/2/22'` to properly handle date formatting. The amended query now correctly joins tables and handles date comparison to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"build up play speed class\" for a team: use the column \"buildUpPlaySpeedClass\" from table \"Team_Attributes\" (aliased as t2) instead of directly from \"team_attributes\". 2) When joining \"Team\" and \"Team_Attributes\" tables: link rows where \"t1.team_api_id = t2.team_api_id\" and keep only matching pairs (inner match). 3) When filtering by team name: use \"t1.team_long_name = 'Willem II'\" instead of \"team_name = 'Willem II'\". 4) When filtering by date: use \"SUBSTR(t2.date, 1, 10) = '2011-02-22'\" for date comparison instead of \"date = '2011/2/22'\" to properly handle date formatting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT build_up_play_speed_class FROM team_attributes WHERE team_name = 'Willem II' AND date = '2011/2/22';",
            "SELECT t2.buildUpPlaySpeedClass \nFROM Team AS t1 \nJOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Willem II' \nAND SUBSTR(t2.date, 1, 10) = '2011-02-22'"
        ],
        "rule_sql": [
            "SELECT t2.buildUpPlaySpeedClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Willem II' \nAND SUBSTR(t2.date, 1, 10) = '2011-02-22'"
        ],
        "amend_res": 1
    },
    "1338": {
        "db_id": "student_club",
        "question": "Was each expense in October Meeting on October 8, 2019 approved?",
        "ground_truth": "SELECT T3.approved FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T1.event_name = 'October Meeting' AND T1.event_date LIKE '2019-10-08%'",
        "amends": [
            "Do select only `T3.approved` instead of all columns with `*`. Do join `event AS T1` and `budget AS T2` with `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only `expenses`. Do add another `INNER JOIN` to `expense AS T3` on `T2.budget_id = T3.link_to_budget` instead of missing these table relationships. Do filter on `T1.event_name = 'October Meeting'` instead of `description LIKE '%October Meeting%'`. Do use `T1.event_date LIKE '2019-10-08%'` for date matching instead of exact `date = '2019-10-08'`. Do remove the `approved = 'yes'` filter instead of keeping it since the approved status is now being selected rather than filtered. The amended query now correctly navigates the relational schema to find expenses linked to the specific October Meeting event."
        ],
        "rules": [
            "1) When answering about expenses for a specific event: join event AS T1, budget AS T2, and expense AS T3 using inner joins on T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget instead of querying only expenses table. 2) When the question mentions \"October Meeting\": use exact literal matching with T1.event_name = 'October Meeting' instead of pattern matching on description. 3) When filtering by date \"October 8, 2019\": use T1.event_date LIKE '2019-10-08%' for date matching instead of exact equality. 4) When checking approval status: select T3.approved as output instead of filtering by approved = 'yes'. 5) When combining tables for shared entities: perform inner matches using the exact key equalities T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget to maintain relational integrity."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM expenses WHERE date = '2019-10-08' AND description LIKE '%October Meeting%' AND approved = 'yes';",
            "SELECT T3.approved\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting'\nAND T1.event_date LIKE '2019-10-08%'"
        ],
        "rule_sql": [
            "SELECT T3.approved \nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T1.event_name = 'October Meeting' \nAND T1.event_date LIKE '2019-10-08%'"
        ],
        "amend_res": 1
    },
    "579": {
        "db_id": "codebase_community",
        "question": "Write all comments made on the post titled 'How does gentle boosting differ from AdaBoost?'",
        "ground_truth": "SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'",
        "amends": [
            "Do select `T1.Text` instead of `*` to specify only the comment text column. Do add `INNER JOIN posts AS T2` instead of querying only the comments table to properly relate comments to posts. Do use join condition `T1.PostId = T2.Id` instead of filtering directly on post_title to correctly match comments to their parent posts through the foreign key relationship. Do filter on `T2.Title` instead of `post_title` since the title column exists in the posts table rather than the comments table. The amended query now correctly retrieves comment text by joining through the proper post relationship instead of attempting to filter on a non-existent column, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"comments made on a specific post\": make sure the output order: T1.Text 2) When the question mentions \"post titled 'How does gentle boosting differ from AdaBoost?'\": \"post title\" actually means \"T2.Title in schema\" with exact literal 'How does gentle boosting differ from AdaBoost?' 3) When combining T1 (comments) and T2 (posts) for shared entities: link rows where T1.PostId = T2.Id; keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation of 'How does gentle boosting differ from AdaBoost?'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM comments WHERE post_title = 'How does gentle boosting differ from AdaBoost?'",
            "SELECT T1.Text \nFROM comments AS T1 \nINNER JOIN posts AS T2 ON T1.PostId = T2.Id \nWHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'"
        ],
        "rule_sql": [
            "SELECT c.Text\nFROM comments c\nINNER JOIN posts p ON c.PostId = p.Id\nWHERE p.Title = 'How does gentle boosting differ from AdaBoost?'\nORDER BY c.Text"
        ],
        "amend_res": 1
    },
    "1061": {
        "db_id": "european_football_2",
        "question": "How many players whose first names are Adam and weigh more than 170?",
        "ground_truth": "SELECT COUNT(id) FROM Player WHERE weight > 170 AND player_name LIKE 'Adam%'",
        "amends": [
            "Do count `id` instead of `*` to exclude null values. Do reference table `Player` instead of `players` with proper case. Do use filter `weight > 170` instead of `weight < 170` to capture heavier players. Do filter with `player_name LIKE 'Adam%'` instead of `first_name = 'Adam'` to match names starting with Adam and use the correct column name. The amended query now correctly counts players with names starting with Adam who weigh more than 170."
        ],
        "rules": [
            "1) When counting players: use \"Player\" as the exact table name instead of \"players\" with proper case. 2) When filtering by name starting with Adam: use \"player_name LIKE 'Adam%'\" instead of \"first_name = 'Adam'\" to match names starting with Adam. 3) When filtering by weight greater than 170: use \"weight > 170\" instead of \"weight < 170\" to capture heavier players. 4) When counting players: count \"id\" instead of \"*\" to exclude null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE first_name = 'Adam' AND weight < 170;",
            "SELECT COUNT(id) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170;"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM Player WHERE player_name LIKE 'Adam%' AND weight > 170"
        ],
        "amend_res": 1
    },
    "982": {
        "db_id": "formula_1",
        "question": "How many American drivers have puncture status.",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN results AS T2 on T1.driverId = T2.driverId INNER JOIN status AS T3 on T2.statusId = T3.statusId WHERE T3.status = 'Puncture' AND T1.nationality = 'American'",
        "amends": [
            "Do add table joins to `results AS T2` and `status AS T3` instead of querying only the `drivers` table. Do change the count expression to `COUNT(T1.driverId)` instead of `COUNT(*)` to count specific driver instances. Do move the status filter to join with the `status` table using `T3.status = 'Puncture'` instead of directly filtering `drivers.status = 'puncture'`. Do use proper table aliases `T1`, `T2`, and `T3` instead of unaliased table references. Do change the join predicate to `T1.driverId = T2.driverId` and `T2.statusId = T3.statusId` instead of the missing join conditions. Do correct the status value case to `'Puncture'` instead of `'puncture'`. The amended query now correctly counts American drivers who experienced punctures by properly joining through the results and status tables."
        ],
        "rules": [
            "1) When answering about \"How many American drivers have puncture status\": make sure the output order: COUNT(T1.driverId). 2) When the question mentions \"American\": \"American\" actually means \"nationality = 'American' in schema\". 3) When the question mentions \"puncture status\": \"puncture status\" actually means \"T3.status = 'Puncture' in schema\". 4) When combining T1, T2, and T3 for shared entities: link rows where T1.driverId = T2.driverId and T2.statusId = T3.statusId; keep only matching pairs (inner match). 5) When the question asks for \"count of drivers\": compute the number of rows using the canonical key token T1.driverId. 6) When handling text literals: do not change case, spacing, or punctuation - use 'Puncture' exactly as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'American' AND status = 'puncture';",
            "SELECT COUNT(T1.driverId) \nFROM drivers AS T1\nJOIN results AS T2 ON T1.driverId = T2.driverId\nJOIN status AS T3 ON T2.statusId = T3.statusId\nWHERE T1.nationality = 'American' AND T3.status = 'Puncture'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.driverId) \nFROM drivers T1\nJOIN results T2 ON T1.driverId = T2.driverId\nJOIN status T3 ON T2.statusId = T3.statusId\nWHERE T1.nationality = 'American' AND T3.status = 'Puncture'"
        ],
        "amend_res": 1
    },
    "1165": {
        "db_id": "thrombosis_prediction",
        "question": "What is the age gap between the youngest and oldest patient with a normal triglyceride recorded?",
        "ground_truth": "SELECT STRFTIME('%Y', MAX(T1.Birthday)) - STRFTIME('%Y', MIN(T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200",
        "amends": [
            "Do calculate age difference using `STRFTIME('%Y', MAX(Birthday)) - STRFTIME('%Y', MIN(Birthday))` instead of `MAX(age) - MIN(age)` to properly compute age from birth dates. Do join `Patient` and `Laboratory` tables with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.TG >= 200` instead of `triglyceride = 'normal'` to use numeric comparison rather than string matching. Do remove the `AS age_gap` alias instead of keeping it. The amended query now correctly calculates age gap from birth dates while filtering patients based on triglyceride laboratory values exceeding 200, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating age from birth dates: use STRFTIME('%Y', MAX(Birthday)) - STRFTIME('%Y', MIN(Birthday)) instead of MAX(age) - MIN(age) to properly compute age from birth dates. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using an inner join instead of querying only one table. 3) When filtering for patients with normal triglyceride: use T2.TG >= 200 instead of triglyceride = 'normal' to use numeric comparison rather than string matching. 4) When producing output: do not include the AS age_gap alias in the final result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(age) - MIN(age) AS age_gap FROM patients WHERE triglyceride = 'normal';",
            "SELECT STRFTIME('%Y', MAX(p.Birthday)) - STRFTIME('%Y', MIN(p.Birthday)) FROM Patient p INNER JOIN Laboratory l ON p.ID = l.ID WHERE l.TG >= 200"
        ],
        "rule_sql": [
            "SELECT STRFTIME('%Y', MAX(p.Birthday)) - STRFTIME('%Y', MIN(p.Birthday)) FROM Patient p INNER JOIN Laboratory l ON p.ID = l.ID WHERE l.TG >= 200"
        ],
        "amend_res": 1
    },
    "467": {
        "db_id": "card_games",
        "question": "How many cards are there in the base set of \"Hauptset Zehnte Edition\"?",
        "ground_truth": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [
            "Do select `T1.baseSetSize` instead of `COUNT(*)`. Do join `sets AS T1` and `set_translations AS T2` instead of querying only `cards`. Do use `INNER JOIN` on `T2.setCode = T1.code` instead of filtering `set_name` directly. Do filter with `T2.translation = 'Hauptset Zehnte Edition'` instead of `set_name = 'Hauptset Zehnte Edition' AND base_set = 1`. The amended query now correctly retrieves the base set size from the sets table using proper table relationships instead of counting cards with potentially incorrect assumptions."
        ],
        "rules": [
            "1) When answering about \"How many cards are there in the base set\": make sure the output order: T1.baseSetSize\n2) When the question mentions \"Hauptset Zehnte Edition\": \"Hauptset Zehnte Edition\" actually means \"T2.translation\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)\n4) When filtering for the specific set translation: use T2.translation = 'Hauptset Zehnte Edition' exactly as specified with the exact case and spacing"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE set_name = 'Hauptset Zehnte Edition' AND base_set = 1;",
            "SELECT T1.baseSetSize \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T2.translation = 'Hauptset Zehnte Edition'"
        ],
        "rule_sql": [
            "SELECT T1.baseSetSize\nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T2.translation = 'Hauptset Zehnte Edition'"
        ],
        "amend_res": 1
    },
    "671": {
        "db_id": "codebase_community",
        "question": "What is the display name of the user who acquired the first Autobiographer badge?",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.`Name` = 'Autobiographer' ORDER BY T2.Date LIMIT 1",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.DisplayName \nFROM Users u \nJOIN Badges b ON u.Id = b.UserId \nWHERE b.Name = 'Autobiographer' \nORDER BY b.Date ASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM users u\nJOIN badges b ON u.Id = b.UserId\nWHERE b.Name = 'Autobiographer'\nORDER BY b.Date ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1265": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients have a normal level of anti-ribonuclear protein and have been admitted to the hospital?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patients. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.RNP = 'negative' OR T2.RNP = '0'` instead of `anti_ribonuclear_protein = 'normal'` to capture the correct laboratory values. Do use `T1.Admission = '+'` instead of `admission_status = 'admitted'` for the admission status check. The amended query now correctly counts distinct patients with specific RNP laboratory results and admission status, matching the intended behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions `T2.RNP = 'negative' OR T2.RNP = '0'` instead of keeping them, as the parentheses were unnecessary and could potentially change the logical evaluation order of the boolean expressions. Do maintain the explicit `INNER JOIN` syntax instead of the implicit `JOIN` shorthand, though this is a cosmetic difference that doesn't affect query behavior. The amended query now correctly matches the RIGHT_SQL's behavior with proper boolean operator precedence.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` remains the same without parentheses but the query structure is simplified. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` instead of enclosing them, as the original parentheses incorrectly changed the operator precedence by grouping the OR conditions together before applying the AND condition, which would filter patients differently by requiring either RNP condition to be true along with Admission being positive, rather than correctly evaluating the OR conditions within the broader AND context with the admission filter.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence without parentheses correctly evaluates `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` with the `AND` operator having higher precedence than `OR`, which maintains the intended logic while eliminating unnecessary grouping. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` requires the correct grouping without explicit parentheses to ensure the query filters for patients with either `RNP = 'negative'` or both `RNP = '0'` and `Admission = '+'`.",
            "Do remove the parentheses around the `WHERE` clause conditions `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` instead of enclosing them, which changes the logical evaluation order from grouping the OR conditions first to applying standard operator precedence where AND has higher precedence than OR. This amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of including them, as the logical operator precedence remains the same without affecting the query logic. The amended query now correctly matches the RIGHT_SQL's behavior with identical filtering conditions and join logic.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` remains the same without parentheses but the amended query matches the intended logic. The amended query now correctly counts distinct patient IDs where laboratory RNP is either 'negative' or '0' and the patient admission status is '+', matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence without parentheses correctly evaluates `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` with the `AND` having higher precedence than `OR`, which maintains the intended logic while simplifying the query structure. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` requires the `OR` conditions to be evaluated first before applying the `AND` condition with `T1.Admission = '+'`. The amended query now correctly matches the RIGHT_SQL's behavior by maintaining the same join logic and column selection while fixing the predicate evaluation order.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` remains unchanged without parentheses but the query structure is simplified. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` instead of enclosing them, which changes the logical evaluation order from grouping the OR conditions first to allowing proper operator precedence where AND has higher precedence than OR. This amendment ensures the query correctly filters records where either RNP is 'negative' or both RNP is '0' and Admission is '+', matching the intended logic without artificial grouping. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` instead of enclosing them, which changes the logical evaluation order from grouping the OR conditions first to applying standard operator precedence where AND has higher precedence than OR. This amendment ensures the query correctly counts patients with either negative RNP results or zero RNP results who also have positive admission status, matching the intended logic without artificial grouping that could produce incorrect results.",
            "Do remove the parentheses around the `WHERE` clause conditions `T2.RNP = 'negative' OR T2.RNP = '0' AND T1.Admission = '+'` instead of enclosing them, which changes the logical evaluation order from grouping the OR conditions first to allowing proper operator precedence where AND has higher precedence than OR. This amendment ensures the query correctly filters records where either RNP is 'negative' or both RNP is '0' and Admission is '+', matching the intended logic without artificial grouping. The amended query now matches RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` requires the correct grouping without explicit parentheses to ensure proper evaluation order where `T2.RNP = 'negative' OR T2.RNP = '0'` is evaluated first before applying the `AND T1.Admission = '+'` condition. The amended query now matches RIGHT_SQL's behavior with the correct logical evaluation.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence without parentheses correctly evaluates `OR` before `AND` to match the intended logic where patients with either RNP value 'negative' or '0' are counted only if they also have Admission '+', ensuring the query now correctly filters records where (T2.RNP is 'negative' OR T2.RNP is '0') AND T1.Admission is '+', thus matching the RIGHT_SQL's behavior.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` requires the correct grouping without explicit parentheses to ensure proper evaluation order where `T2.RNP = 'negative' OR T2.RNP = '0'` is evaluated first before applying the `AND T1.Admission = '+'` condition. The amended query now matches RIGHT_SQL's behavior with the correct logical evaluation of filter conditions.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence without parentheses correctly evaluates `OR` before `AND` to match the intended logic where patients with either RNP value 'negative' or '0' are counted only if they also have Admission '+', ensuring the query now correctly filters for patients with the specified laboratory results and admission status.",
            "Do remove the parentheses around the `WHERE` clause conditions instead of keeping them, as the logical operator precedence between `OR` and `AND` requires the explicit grouping to ensure correct evaluation where `T2.RNP = 'negative' OR T2.RNP = '0'` is evaluated first before applying the `AND T1.Admission = '+'` condition. The amended query now matches RIGHT_SQL's behavior with proper boolean logic evaluation."
        ],
        "rules": [
            "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE anti_ribonuclear_protein = 'normal' AND admission_status = 'admitted';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') \nAND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') \nAND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0')\nAND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID)\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE (T2.RNP = 'negative' OR T2.RNP = '0') AND T1.Admission = '+'"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "853": {
        "db_id": "formula_1",
        "question": "Please give the names of the races held on the circuits in Spain.",
        "ground_truth": "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'Spain'",
        "amends": [
            "Do select `DISTINCT T2.name` instead of `race_name` to return unique circuit names. Do join `circuits AS T1` with `races AS T2` instead of querying only the races table. Do use `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of no join condition. Do filter on `T1.country = 'Spain'` instead of `country = 'Spain'` to reference the correct table's country column. The amended query now correctly returns distinct circuit names located in Spain by properly joining the circuits and races tables."
        ],
        "rules": [
            "1) When answering about \"races held on circuits in Spain\": make sure the output order: T2.name. 2) When the question mentions \"circuits in Spain\": \"Spain\" actually means T1.country = 'Spain' in schema. 3) When combining T1 (circuits) and T2 (races) for shared entities: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"names of the races\": return distinct values of T2.name to avoid duplicates. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T2.circuitID and T1.circuitId."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name FROM races WHERE country = 'Spain';",
            "SELECT DISTINCT T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.country = 'Spain'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.name FROM circuits T1 INNER JOIN races T2 ON T2.circuitId = T1.circuitId WHERE T1.country = 'Spain' ORDER BY T2.name;"
        ],
        "amend_res": 1
    },
    "590": {
        "db_id": "codebase_community",
        "question": "Which user ID has the lowest view?",
        "ground_truth": "SELECT Id FROM users WHERE Views = ( SELECT MIN(Views) FROM users )",
        "amends": [
            "Do select `Id` from the `users` table instead of `user_id` from `views`. Do use a WHERE filter with a subquery to find the minimum `Views` value instead of ordering by `view_count` and limiting to one row. Do reference the `Views` column instead of `view_count`. Do remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly identifies the user with the minimum view count by using a correlated subquery approach instead of a simple ordering and limiting method."
        ],
        "rules": [
            "1) When the question asks for \"user ID\": use \"Id\" from the \"users\" table instead of \"user_id\" from \"views\". 2) When finding the user with the lowest view count: use a WHERE filter with a subquery to find the minimum \"Views\" value instead of ordering by \"view_count\" and limiting to one row. 3) When referencing view counts: use the \"Views\" column instead of \"view_count\". 4) When identifying minimum values: remove ORDER BY and LIMIT clauses and use a correlated subquery approach instead."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT user_id FROM views ORDER BY view_count ASC LIMIT 1;",
            "SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);"
        ],
        "rule_sql": [
            "SELECT Id FROM users WHERE Views = (SELECT MIN(Views) FROM users);"
        ],
        "amend_res": 1
    },
    "928": {
        "db_id": "formula_1",
        "question": "Which driver ranked the first in the Canadian Grand Prix in 2007? Please give his reference name.",
        "ground_truth": "SELECT T3.forename, T3.surname, T3.driverRef FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Canadian Grand Prix' AND T2.rank = 1 AND T1.year = 2007",
        "amends": [
            "Do select `T3.forename`, `T3.surname`, and `T3.driverRef` instead of just `driver_name`. Do join `races AS T1` with `results AS T2` on `T2.raceId = T1.raceId` instead of querying only the races table. Do add a second join to `drivers AS T3` on `T3.driverId = T2.driverId` instead of omitting the drivers table. Do filter by `T1.name = 'Canadian Grand Prix'` instead of `race_name` and add `T2.rank = 1` instead of ordering by position with LIMIT 1. Do keep `T1.year = 2007` but remove the ORDER BY and LIMIT clauses instead of keeping them. The amended query now correctly retrieves the winning driver details by joining through the results table and filtering by rank instead of using positional ordering."
        ],
        "rules": [
            "1) When the question asks about a driver's reference name in a specific Grand Prix: select T3.forename, T3.surname, and T3.driverRef as output columns. 2) When combining race information with results: join races AS T1 with results AS T2 on T2.raceId = T1.raceId using an inner match. 3) When adding driver details to results: join drivers AS T3 on T3.driverId = T2.driverId using an inner match. 4) When filtering for a specific Grand Prix: use T1.name = 'Canadian Grand Prix' exactly as written. 5) When filtering for a specific year: use T1.year = 2007. 6) When identifying the first-ranked driver: use T2.rank = 1 instead of ordering by position with LIMIT 1."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM races WHERE race_name = 'Canadian Grand Prix' AND year = 2007 ORDER BY position LIMIT 1;",
            "SELECT T3.forename, T3.surname, T3.driverRef \nFROM races AS T1 \nJOIN results AS T2 ON T2.raceId = T1.raceId \nJOIN drivers AS T3 ON T3.driverId = T2.driverId \nWHERE T1.name = 'Canadian Grand Prix' \nAND T1.year = 2007 \nAND T2.rank = 1"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname, T3.driverRef \nFROM races AS T1 \nINNER JOIN results AS T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId \nWHERE T1.name = 'Canadian Grand Prix' \nAND T1.year = 2007 \nAND T2.rank = 1"
        ],
        "amend_res": 1
    },
    "1137": {
        "db_id": "european_football_2",
        "question": "What percentage of players have a strength and stamina score of more than 80?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t",
        "amends": [
            "Do use `COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END)` instead of `COUNT(*)` to count only players meeting both conditions. Do change the logical operator to `AND` instead of `OR` to require both high strength and stamina. Do add explicit `CAST` to `REAL` instead of using decimal literal `100.0` for proper floating-point division. Do reference the correct table name `Player_Attributes` instead of `players`. Do use `COUNT(id)` in the denominator instead of a subquery for the total count. Do remove the unnecessary subquery and instead calculate the percentage directly in the main query. The amended query now correctly calculates the percentage of players with both strength and stamina above 80, matching the intended behavior.",
            "Do place the multiplication by 100 after the division instead of before it, changing `* 100.0` to `* 100 / COUNT(id)` to ensure correct percentage calculation order. Do remove the alias `percentage` instead of keeping it for cleaner output. Do add table alias `t` instead of omitting it for consistency. The amended query now correctly calculates the percentage by performing division before multiplication, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting players with both strength and stamina above 80: use COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) instead of COUNT(*) to count only players meeting both conditions. 2) When requiring both high strength and stamina: use the logical operator AND instead of OR to ensure both conditions are satisfied. 3) When performing floating-point division: use explicit CAST to REAL instead of decimal literal 100.0 for proper division. 4) When referencing the player attributes table: use the correct table name Player_Attributes instead of players. 5) When calculating the total count of players: use COUNT(id) in the denominator instead of a subquery for the total count. 6) When computing percentages: calculate the percentage directly in the main query instead of using unnecessary subqueries.",
            "1) When calculating percentages: perform division before multiplication by 100 to ensure correct percentage calculation order. 2) When the question asks for percentage of players with specific attribute scores: count players where both \"strength\" > 80 and \"stamina\" > 80, then divide by total players count. 3) When using table aliases: use consistent table alias \"t\" for the Player_Attributes table. 4) When output formatting: do not include column aliases for cleaner output when not required by the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM players)) AS percentage\nFROM players\nWHERE strength > 80 OR stamina > 80;",
            "SELECT \n    CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) / COUNT(id) * 100.0 AS percentage\nFROM \n    Player_Attributes;",
            "SELECT CAST(COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) AS REAL) * 100 / COUNT(id) FROM Player_Attributes t;"
        ],
        "rule_sql": [
            "SELECT 100.0 * COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) / COUNT(id) FROM Player_Attributes t;"
        ],
        "amend_res": 1
    },
    "468": {
        "db_id": "card_games",
        "question": "What is the Simplified Chinese translation of the name of the set \"Eighth Edition\"?",
        "ground_truth": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'",
        "amends": [
            "Do select `T2.translation` instead of `name` and change the source to an `INNER JOIN` between `sets AS T1` and `set_translations AS T2` on `T2.setCode = T1.code` instead of querying only the `sets` table. Do add a filter for `T2.language = 'Chinese Simplified'` instead of omitting it, and change the condition to `T1.name = 'Eighth Edition'` instead of `english_name = 'Eighth Edition'`. The amended query now correctly retrieves Chinese Simplified translations for the specified set instead of just the English name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about Simplified Chinese translation of a set name: make sure the output order: T2.translation 2) When the question mentions \"Simplified Chinese\": \"Simplified Chinese\" actually means \"T2.language = 'Chinese Simplified'\" in schema 3) When the question mentions \"set name 'Eighth Edition'\": \"Eighth Edition\" actually means \"T1.name = 'Eighth Edition'\" in schema 4) When combining T1 (sets) and T2 (set_translations) for shared entities: link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE english_name = 'Eighth Edition';",
            "SELECT T2.translation\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T1.name = 'Eighth Edition'\nAND T2.language = 'Chinese Simplified'"
        ],
        "rule_sql": [
            "SELECT T2.translation \nFROM sets T1 \nINNER JOIN set_translations T2 ON T2.setCode = T1.code \nWHERE T1.name = 'Eighth Edition' \nAND T2.language = 'Chinese Simplified'"
        ],
        "amend_res": 1
    },
    "1014": {
        "db_id": "formula_1",
        "question": "Please list the lap records for the circuits in Italy.",
        "ground_truth": "WITH fastest_lap_times AS (SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T1.FastestLapTime as lap_record FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN (SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T3.country = 'Italy' ) AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds LIMIT 1",
        "amends": [
            "Do completely restructure the query by adding a CTE `fastest_lap_times` with time conversion instead of a simple `SELECT *`. Do change the FROM clause to use multiple `INNER JOIN` operations between `results`, `races`, and `circuits` tables instead of querying only `circuits`. Do move the country filter `'Italy'` to a subquery that calculates the minimum lap time instead of applying it directly in the main WHERE clause. Do add complex time conversion logic using `CAST`, `SUBSTR`, and `INSTR` functions to convert `FastestLapTime` to seconds instead of selecting raw data. Do include a join condition matching the converted lap time to the minimum time found in Italian circuits instead of simple equality filtering. Do add `LIMIT 1` to return only the fastest lap record instead of all Italian circuits. The amended query now correctly identifies the fastest lap time record for Italian circuits rather than simply listing all circuits in Italy.",
            "Do remove the `circuit_name`, `race_name`, and `driver_name` columns from the SELECT list instead of including them, and do rename the output column to `lap_record` instead of keeping multiple columns. Do change the time conversion calculation to properly handle milliseconds by adding `(CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)` instead of omitting the millisecond component. Do move the `country = 'Italy'` filter from the CTE to the subquery that calculates the minimum time instead of applying it globally. Do restructure the query to use a subquery for finding the minimum time with proper joins to `races` and `circuits` instead of filtering the CTE directly. Do change the final join condition to compare the calculated time with the minimum time from the subquery instead of using a WHERE clause with a subquery. The amended query now correctly identifies the fastest lap record in Italy by properly handling time conversion with milliseconds and applying the country filter only to the minimum time calculation.",
            "Do select `T1.FastestLapTime` as `lap_record` instead of `flt.time_in_seconds` from the main `results` table instead of the CTE. Do join `results AS T1` directly with `races AS T2` and `circuits AS T3` instead of using the CTE as the primary source. Do use an INNER JOIN with a subquery that calculates the minimum time for Italian circuits instead of a WHERE clause with a correlated subquery. Do compute the time conversion directly in the JOIN condition `(CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + ... = T4.min_time_in_seconds` instead of comparing pre-computed values from the CTE. The amended query now correctly matches the RIGHT_SQL's behavior by ensuring the time calculation is performed on the original results data and properly joined with the minimum time subquery."
        ],
        "rules": [
            "1) When answering about lap records for circuits in Italy: restructure the query to use multiple INNER JOIN operations between results, races, and circuits tables instead of querying only circuits. 2) When the question mentions \"lap records\": calculate the minimum lap time using time conversion logic with CAST, SUBSTR, and INSTR functions to convert FastestLapTime to seconds. 3) When filtering for Italian circuits: apply the country filter 'Italy' in a subquery that calculates the minimum lap time rather than directly in the main WHERE clause. 4) When combining results, races, and circuits tables: use join conditions matching the converted lap time to the minimum time found in Italian circuits. 5) When the question asks for lap records: return only the fastest lap record using LIMIT 1 instead of all Italian circuits.",
            "1) When answering about lap records for circuits in Italy: make sure the output order contains only the lap_record column instead of multiple columns like circuit_name, race_name, and driver_name. 2) When converting fastest lap times that include milliseconds: properly handle the millisecond component by adding (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) to the time conversion calculation. 3) When filtering for circuits in Italy: apply the country = 'Italy' condition only to the subquery that calculates the minimum time instead of applying it globally. 4) When finding the minimum lap time: use a subquery with proper joins to races and circuits tables instead of filtering a CTE directly. 5) When comparing lap times: change the final join condition to compare the calculated time with the minimum time from the subquery instead of using a WHERE clause with a subquery.",
            "1) When answering about lap records for circuits in Italy: make sure the output order includes T1.FastestLapTime as lap_record. 2) When combining tables for lap records: link rows where T1.raceId = T2.raceId and T2.circuitId = T3.circuitId using inner joins. 3) When filtering for Italian circuits: ensure T3.country = 'Italy' exactly. 4) When finding the fastest lap time: compute the minimum converted time using (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) for Italian circuits. 5) When comparing lap times: match the converted time from T1 against the minimum converted time subquery result using equality comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM circuits WHERE country = 'Italy';",
            "WITH fastest_lap_times AS (\n    SELECT \n        c.circuitId,\n        c.name AS circuit_name,\n        r.raceId,\n        r.name AS race_name,\n        d.forename || ' ' || d.surname AS driver_name,\n        res.fastestLapTime,\n        CAST(SUBSTR(res.fastestLapTime, 1, INSTR(res.fastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(res.fastestLapTime, INSTR(res.fastestLapTime, ':') + 1) AS REAL) AS time_in_seconds\n    FROM results res\n    INNER JOIN races r ON res.raceId = r.raceId\n    INNER JOIN circuits c ON r.circuitId = c.circuitId\n    INNER JOIN drivers d ON res.driverId = d.driverId\n    WHERE c.country = 'Italy'\n    AND res.fastestLapTime IS NOT NULL\n)\nSELECT \n    circuit_name,\n    race_name,\n    driver_name,\n    fastestLapTime,\n    time_in_seconds\nFROM fastest_lap_times\nWHERE time_in_seconds = (\n    SELECT MIN(time_in_seconds)\n    FROM fastest_lap_times\n)\nLIMIT 1;",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.resultId,\n        r.raceId,\n        r.driverId,\n        r.constructorId,\n        r.FastestLapTime,\n        CAST(SUBSTR(r.FastestLapTime, 1, INSTR(r.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, ':') + 1, INSTR(r.FastestLapTime, '.') - INSTR(r.FastestLapTime, ':') - 1) AS REAL) +\n        (CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, '.') + 1) AS REAL) / 1000) AS time_in_seconds\n    FROM results r\n    WHERE r.FastestLapTime IS NOT NULL\n)\nSELECT \n    flt.time_in_seconds AS lap_record\nFROM fastest_lap_times flt\nINNER JOIN races rc ON flt.raceId = rc.raceId\nINNER JOIN circuits c ON rc.circuitId = c.circuitId\nWHERE flt.time_in_seconds = (\n    SELECT MIN(flt2.time_in_seconds)\n    FROM fastest_lap_times flt2\n    INNER JOIN races rc2 ON flt2.raceId = rc2.raceId\n    INNER JOIN circuits c2 ON rc2.circuitId = c2.circuitId\n    WHERE c2.country = 'Italy'\n)\nLIMIT 1;",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.resultId,\n        r.FastestLapTime,\n        (CAST(SUBSTR(r.FastestLapTime, 1, INSTR(r.FastestLapTime, ':') - 1) AS REAL) * 60) +\n        CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, ':') + 1, INSTR(r.FastestLapTime, '.') - INSTR(r.FastestLapTime, ':') - 1) AS REAL) +\n        (CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, '.') + 1) AS REAL) / 1000) AS time_in_seconds\n    FROM results r\n    INNER JOIN races rc ON r.raceId = rc.raceId\n    INNER JOIN circuits c ON rc.circuitId = c.circuitId\n    WHERE c.country = 'Italy'\n    AND r.FastestLapTime IS NOT NULL\n)\nSELECT \n    flt.FastestLapTime AS lap_record\nFROM fastest_lap_times flt\nINNER JOIN (\n    SELECT MIN(time_in_seconds) AS min_time\n    FROM fastest_lap_times\n) min_time ON flt.time_in_seconds = min_time.min_time\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.FastestLapTime AS lap_record\nFROM results T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nINNER JOIN circuits T3 ON T2.circuitId = T3.circuitId\nWHERE (\n    CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL) +\n    (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000)\n) = (\n    SELECT MIN(\n        CAST(SUBSTR(r.FastestLapTime, 1, INSTR(r.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, ':') + 1, INSTR(r.FastestLapTime, '.') - INSTR(r.FastestLapTime, ':') - 1) AS REAL) +\n        (CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, '.') + 1) AS REAL) / 1000)\n    )\n    FROM results r\n    INNER JOIN races ra ON r.raceId = ra.raceId\n    INNER JOIN circuits c ON ra.circuitId = c.circuitId\n    WHERE c.country = 'Italy'\n)\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "5": {
        "db_id": "california_schools",
        "question": "How many schools with an average score in Math greater than 400 in the SAT test are exclusively virtual?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.School) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' AND T1.AvgScrMath > 400",
        "amends": [
            "Do use `COUNT(DISTINCT T2.School)` instead of `COUNT(*)` to count unique schools rather than all rows. Do join `satscores AS T1` with `schools AS T2` on `T1.cds = T2.CDSCode` instead of querying only the schools table. Do filter on `T2.Virtual = 'F'` instead of `virtual = 'yes'` to exclude virtual schools rather than include them. Do use `T1.AvgScrMath > 400` instead of `math_score > 400` to filter on the correct math score column from the joined table. The amended query now correctly counts distinct non-virtual schools with math scores above 400 by properly joining the relevant tables and using the appropriate filtering conditions."
        ],
        "rules": [
            "1) When answering about schools with SAT math scores greater than 400: join \"satscores\" as T1 with \"schools\" as T2 where T1.cds = T2.CDSCode to combine score and school information. 2) When filtering for math scores: use T1.AvgScrMath > 400 instead of math_score to reference the correct column from the SAT scores table. 3) When identifying virtual schools: use T2.Virtual = 'F' instead of virtual = 'yes' to exclude virtual schools, as 'F' indicates non-virtual status. 4) When counting schools: use COUNT(DISTINCT T2.School) instead of COUNT(*) to count unique school entities rather than all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE math_score > 400 AND virtual = 'yes';",
            "SELECT COUNT(DISTINCT T2.School) \nFROM satscores AS T1 \nJOIN schools AS T2 ON T1.cds = T2.CDSCode \nWHERE T1.AvgScrMath > 400 \nAND T2.Virtual = 'F'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.School) \nFROM satscores T1 \nJOIN schools T2 ON T1.cds = T2.CDSCode \nWHERE T1.AvgScrMath > 400 \nAND T2.Virtual = 'F'"
        ],
        "amend_res": 1
    },
    "919": {
        "db_id": "formula_1",
        "question": "Which circuit did the 2009 Spanish Grand Prix use?",
        "evidence": "",
        "ground_truth": "SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [
            "Do add `T1` alias and join `races AS T2` instead of querying `circuits` alone. Do use `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of filtering directly on `circuits`. Do change the year filter to `T2.year = 2009` instead of `circuits.year = 2009`. Do replace the country filter with `T2.name = 'Spanish Grand Prix'` instead of `country = 'Spain'`. The amended query now correctly joins circuits with races to find circuits that hosted the Spanish Grand Prix in 2009, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about which circuit hosted a specific Grand Prix in a specific year: join the circuits table (as T1) with the races table (as T2) using an inner match where T2.circuitID equals T1.circuitId. 2) When the question mentions a specific year like \"2009\": filter races where T2.year equals 2009. 3) When the question mentions a specific Grand Prix name like \"Spanish Grand Prix\": filter races where T2.name equals 'Spanish Grand Prix' exactly. 4) When the final output asks for the circuit name: return the name column from the circuits table (T1.name)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM circuits WHERE year = 2009 AND country = 'Spain';",
            "SELECT T1.name \nFROM circuits AS T1 \nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId \nWHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM circuits T1 \nINNER JOIN races T2 ON T2.circuitId = T1.circuitId \nWHERE T2.year = 2009 \nAND T2.name = 'Spanish Grand Prix'"
        ],
        "amend_res": 1
    },
    "813": {
        "db_id": "superhero",
        "question": "Calculate the average attribute value of all neutral superheroes.",
        "ground_truth": "SELECT AVG(T1.attribute_value) FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id INNER JOIN alignment AS T3 ON T2.alignment_id = T3.id WHERE T3.alignment = 'Neutral'",
        "amends": [
            "Do use `hero_attribute AS T1` joined to `superhero AS T2` on `T1.hero_id = T2.id` instead of querying `superheroes` directly. Do add a second join to `alignment AS T3` on `T2.alignment_id = T3.id` instead of missing this relationship. Do filter on `T3.alignment = 'Neutral'` instead of `alignment = 'good'` to target the correct alignment category. Do specify `T1.attribute_value` instead of just `attribute_value` for explicit table qualification. The amended query now correctly calculates average attribute values for neutral-aligned heroes by properly navigating the relational schema."
        ],
        "rules": [
            "1) When answering about \"average attribute value of all neutral superheroes\": make sure the output order: average of T1.attribute_value. 2) When the question mentions \"neutral superheroes\": \"neutral\" actually means \"T3.alignment = 'Neutral'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.hero_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.alignment_id = T3.id exactly as shown in the amends; keep only matching pairs (inner match). 5) When referring to attribute values: use T1.attribute_value instead of just attribute_value for explicit table qualification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(attribute_value) FROM superheroes WHERE alignment = 'good';",
            "SELECT AVG(T1.attribute_value) AS average_attribute_value\nFROM hero_attribute AS T1\nJOIN superhero AS T2 ON T1.hero_id = T2.id\nJOIN alignment AS T3 ON T2.alignment_id = T3.id\nWHERE T3.alignment = 'Neutral'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.attribute_value) AS average_attribute_value\nFROM hero_attribute T1\nINNER JOIN superhero T2 ON T1.hero_id = T2.id\nINNER JOIN alignment T3 ON T2.alignment_id = T3.id\nWHERE T3.alignment = 'Neutral'"
        ],
        "amend_res": 1
    },
    "793": {
        "db_id": "superhero",
        "question": "Among the superheroes with the race of god/eternal, how many of them are male",
        "ground_truth": "SELECT COUNT(*) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id INNER JOIN gender AS T3 ON T3.id = T1.gender_id WHERE T1.race_id = 21 AND T1.gender_id = 1",
        "amends": [
            "Do join `superhero AS T1` with `race AS T2` on `T1.race_id = T2.id` and `gender AS T3` on `T3.id = T1.gender_id` instead of querying a single table. Do filter on `T1.race_id = 21` and `T1.gender_id = 1` instead of using string values `'god/eternal'` and `'male'` directly. Do reference the proper foreign key relationships through `race_id` and `gender_id` instead of assuming the `race` and `gender` columns exist as text fields in the main table. The amended query now correctly joins normalized tables and uses integer IDs for filtering, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about superheroes with race of 'god/eternal': use integer ID 21 for race filtering instead of the string literal 'god/eternal'. 2) When answering about male superheroes: use integer ID 1 for gender filtering instead of the string literal 'male'. 3) When combining superhero data with race information: join table superhero AS T1 with race AS T2 on T1.race_id = T2.id. 4) When combining superhero data with gender information: join table superhero AS T1 with gender AS T3 on T3.id = T1.gender_id. 5) When counting superheroes: use the canonical key from the superhero table to count entities."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE race = 'god/eternal' AND gender = 'male';",
            "SELECT COUNT(*) \nFROM superhero AS T1\nJOIN race AS T2 ON T1.race_id = T2.id\nJOIN gender AS T3 ON T3.id = T1.gender_id\nWHERE T1.race_id = 21 AND T1.gender_id = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM superhero AS T1\nJOIN race AS T2 ON T1.race_id = T2.id\nJOIN gender AS T3 ON T3.id = T1.gender_id\nWHERE T2.id = 21 AND T3.id = 1"
        ],
        "amend_res": 1
    },
    "1050": {
        "db_id": "european_football_2",
        "question": "What is the preferred foot when attacking of the youngest football player?",
        "ground_truth": "SELECT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t1.birthday DESC LIMIT 1",
        "amends": [
            "Do select `t2.preferred_foot` from the joined table instead of `preferred_foot` directly from the players table. Do use `INNER JOIN` between `Player` and `Player_Attributes` tables on `t1.player_api_id = t2.player_api_id` instead of querying a single table with a subquery. Do remove the `WHERE` clause with age comparison and position filter instead of keeping those conditions. Do add `ORDER BY t1.birthday DESC` to sort by the most recent birthday instead of using a MAX subquery for age calculation. Do add `LIMIT 1` to return only the top result instead of potentially multiple records. The amended query now correctly retrieves the preferred foot from the most recent player by joining the necessary tables and ordering by birthday."
        ],
        "rules": [
            "1) When answering about \"the youngest football player\": sort players by birthday in descending order (most recent first) and keep only the top 1 result. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match). 3) When the question asks for \"preferred foot when attacking\": select t2.preferred_foot from the joined Player_Attributes table instead of from the base Player table. 4) When determining the youngest player: use t1.birthday for age calculation instead of an age column or MAX subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT preferred_foot FROM players WHERE age = (SELECT MAX(age) FROM players) AND position = 'Attacker';",
            "SELECT t2.preferred_foot \nFROM Player t1 \nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id \nORDER BY t1.birthday DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT pa.preferred_foot \nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY p.birthday DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "158": {
        "db_id": "financial",
        "question": "What is the district Id of the account that placed the order with the id 33333?",
        "evidence": "",
        "ground_truth": "SELECT T3.district_id FROM `order` AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.order_id = 33333",
        "amends": [
            "Do use `T3.district_id` from the `district` table instead of `district_id` from the `accounts` table. Do join `order` as `T1` instead of omitting it. Do join `account` as `T2` with `T1.account_id = T2.account_id` instead of missing this relationship. Do join `district` as `T3` with `T2.district_id = T3.district_id` instead of accessing district directly. Do filter on `T1.order_id = 33333` instead of filtering `order_id` in the wrong table context. The amended query now correctly navigates the relational path from order to account to district to retrieve the appropriate district_id."
        ],
        "rules": [
            "1) When the question asks for district Id of an account that placed a specific order: navigate through the relational path from order to account to district tables using the exact join conditions shown in the amends. 2) When filtering for a specific order with id 33333: apply the filter condition T1.order_id = 33333 on the order table (T1) instead of filtering in the wrong table context. 3) When joining order (T1) and account (T2): link rows where T1.account_id = T2.account_id to establish the relationship between orders and accounts. 4) When joining account (T2) and district (T3): link rows where T2.district_id = T3.district_id to access district information from the account. 5) When retrieving the district_id: use T3.district_id from the district table instead of district_id from the accounts table, as the district table contains the canonical district information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_id FROM accounts WHERE order_id = 33333;",
            "SELECT T3.district_id\nFROM `order` AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN district AS T3 ON T2.district_id = T3.district_id\nWHERE T1.order_id = 33333;"
        ],
        "rule_sql": [
            "SELECT T3.district_id\nFROM `order` T1\nJOIN account T2 ON T1.account_id = T2.account_id\nJOIN district T3 ON T2.district_id = T3.district_id\nWHERE T1.order_id = 33333"
        ],
        "amend_res": 1
    },
    "974": {
        "db_id": "formula_1",
        "question": "State the racing year which has the fastest lap time?",
        "ground_truth": "SELECT T2.year FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.fastestLapTime IS NOT NULL",
        "amends": [
            "Do select `T2.year` with table qualification instead of unqualified `year`. Do add `FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId` instead of just `FROM races`. Do add `WHERE T1.fastestLapTime IS NOT NULL` filter instead of omitting it. Do remove `ORDER BY fastest_lap_time DESC LIMIT 1` instead of keeping it, as the correct logic filters for non-null fastest lap times rather than finding the maximum. The amended query now correctly retrieves years where races have recorded fastest lap times instead of attempting to find the year with the maximum lap time value."
        ],
        "rules": [
            "1) When answering about racing years with fastest lap times: use T2.year from the races table instead of unqualified year. 2) When combining results and races tables: link rows where T1.raceId = T2.raceId using an inner match. 3) When filtering for races with recorded fastest lap times: include only rows where T1.fastestLapTime IS NOT NULL. 4) When the question asks for years with fastest lap times: retrieve all qualifying years rather than finding the maximum value through ordering and limiting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM races ORDER BY fastest_lap_time DESC LIMIT 1;",
            "SELECT T2.year \nFROM results AS T1 \nINNER JOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T1.fastestLapTime IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.year \nFROM results T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T1.fastestLapTime IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1458": {
        "db_id": "student_club",
        "question": "Calculate the difference in the percentage of members in New Jersey and Vermont.",
        "ground_truth": "SELECT CAST((SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.member_id) AS diff FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
        "amends": [
            "Do use a single query with `SUM(CASE)` expressions instead of multiple subqueries. Do join `member` table with `zip_code` table on `zip_code` instead of querying `members` table directly. Do calculate the difference between state counts directly using `SUM(CASE)` instead of subtracting percentage results. Do cast the result to `REAL` instead of using implicit conversion. Do reference `T1.member_id` for counting instead of using `COUNT(*)` from a separate table. Do use proper table aliases `T1` and `T2` instead of no aliases. The amended query now correctly calculates the percentage difference between New Jersey and Vermont members by properly joining the member and zip_code tables and using conditional aggregation."
        ],
        "rules": [
            "1) When calculating percentages of members by state: join the member table (T1) with the zip_code table (T2) using the exact key equality T1.zip_code = T2.zip_code instead of querying members directly. 2) When counting members: use T1.member_id for counting instead of COUNT(*) from a separate table. 3) When computing state-specific counts: use SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) and SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END) expressions instead of multiple subqueries. 4) When calculating percentage difference: compute the difference between state counts directly using SUM(CASE) expressions instead of subtracting percentage results. 5) When handling numeric results: cast the final result to REAL type instead of using implicit conversion. 6) When organizing the query: use proper table aliases T1 for member table and T2 for zip_code table instead of no aliases."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM members) FROM members WHERE state = 'New Jersey') - \n    (SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM members) FROM members WHERE state = 'Vermont') \nAS percentage_difference;",
            "SELECT \n    CAST(\n        (SUM(CASE WHEN T2.short_state = 'NJ' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.member_id)) - \n        (SUM(CASE WHEN T2.short_state = 'VT' THEN 1 ELSE 0 END) * 100.0 / COUNT(T1.member_id))\n    AS REAL) AS percentage_difference\nFROM \n    member T1\nJOIN \n    zip_code T2 ON T1.zip = T2.zip_code;"
        ],
        "rule_sql": [
            "SELECT CAST(\n    (SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL\n) AS percentage_difference\nFROM member T1\nJOIN zip_code T2 ON T1.zip = T2.zip_code"
        ],
        "amend_res": 1
    },
    "20": {
        "db_id": "california_schools",
        "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
        "amends": [
            "Do select `COUNT(T1.School Name)` from the `frpm` table instead of `COUNT(*)` from only the `schools` table. Do add an `INNER JOIN` between `frpm AS T1` and `schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do move the `Low_Grade = 9` and `High_Grade = 12` filters to reference `T1.Low Grade` and `T1.High Grade` columns from the `frpm` table instead of applying them to the `schools` table. Do keep the `County = 'Amador'` filter on `T2.County` from the `schools` table. The amended query now correctly joins the two tables and counts school names from the frpm table while filtering on the appropriate columns from each table, matching the right SQL's behavior."
        ],
        "rules": [
            "1) When counting schools: use COUNT(T1.\"School Name\") from the frpm table instead of COUNT(*) from the schools table. 2) When combining frpm and schools tables: perform an INNER JOIN between frpm AS T1 and schools AS T2 on T1.CDSCode = T2.CDSCode to match related records. 3) When filtering by grade levels: apply Low_Grade = 9 and High_Grade = 12 conditions to T1.\"Low Grade\" and T1.\"High Grade\" columns from the frpm table. 4) When filtering by county: apply County = 'Amador' condition to T2.County column from the schools table. 5) When the question asks about schools in Amador with specific grade ranges: ensure the output order presents the count of schools matching all specified criteria."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE County = 'Amador' AND Low_Grade = 9 AND High_Grade = 12;",
            "SELECT COUNT(T1.\"School Name\") \nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Amador' \nAND T1.\"Low Grade\" = '9' \nAND T1.\"High Grade\" = '12'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.\"School Name\") \nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Amador'\nAND T1.\"Low Grade\" = '9'\nAND T1.\"High Grade\" = '12'"
        ],
        "amend_res": 1
    },
    "807": {
        "db_id": "superhero",
        "question": "What is the superpowers of the superhero has Helen Parr as their full name?",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Helen Parr'",
        "amends": [
            "Do select `T3.power_name` from the `superpower` table instead of `superpowers` from the `superheroes` table. Do join `superhero AS T1` with `hero_power AS T2` on `T1.id = T2.hero_id` instead of querying a single table. Do add a second join to `superpower AS T3` on `T2.power_id = T3.id` instead of omitting the necessary table relationships. Do filter on `T1.full_name = 'Helen Parr'` instead of the incorrect table reference, maintaining the same filter condition but with proper table qualification. The amended query now correctly retrieves power names through proper table relationships instead of attempting to access non-existent columns."
        ],
        "rules": [
            "1) When answering about \"superpowers of a superhero with a specific full name\": make sure the output order: T3.power_name. 2) When the question mentions \"superpowers\": \"superpowers\" actually means \"power_name in superpower table\". 3) When combining T1 (superhero) and T2 (hero_power) for shared entities: link rows where T1.id = T2.hero_id and keep only matching pairs (inner match). 4) When combining T2 (hero_power) and T3 (superpower) for shared entities: link rows where T2.power_id = T3.id and keep only matching pairs (inner match). 5) When filtering for a specific superhero by full name: use T1.full_name = 'Helen Parr' with exact case and spacing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT superpowers FROM superheroes WHERE full_name = 'Helen Parr';",
            "SELECT T3.power_name \nFROM superhero AS T1\nJOIN hero_power AS T2 ON T1.id = T2.hero_id\nJOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.full_name = 'Helen Parr'"
        ],
        "rule_sql": [
            "SELECT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T1.full_name = 'Helen Parr'\nORDER BY T3.power_name;"
        ],
        "amend_res": 1
    },
    "666": {
        "db_id": "codebase_community",
        "question": "Among the posts that were voted by user 1465, what is the id of the most valuable post?",
        "ground_truth": "SELECT T2.Id FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.UserId = 1465 ORDER BY T2.FavoriteCount DESC LIMIT 1",
        "amends": [
            "Do reference the posts table as `T2` instead of `p` and select `T2.Id` instead of `p.id`. Do use `INNER JOIN` with explicit table aliases `T1` and `T2` instead of simple `JOIN` with `p` and `v`. Do join on `T1.PostId = T2.Id` instead of `p.id = v.post_id`. Do filter on `T1.UserId = 1465` instead of `v.user_id = 1465`. Do order by `T2.FavoriteCount DESC` instead of `p.score DESC`. The amended query now correctly matches the RIGHT_SQL's behavior by using proper table aliases, the correct join condition, and ordering by FavoriteCount rather than score."
        ],
        "rules": [
            "1) When answering about \"posts voted by user 1465\": combine tables T1 (votes) and T2 (posts) using inner match where T1.PostId = T2.Id. 2) When filtering for user 1465: include only rows where T1.UserId = 1465. 3) When determining the most valuable post: rank posts by T2.FavoriteCount in descending order. 4) When selecting the top post: take the first row after ranking by T2.FavoriteCount DESC. 5) When outputting results: return T2.Id as the post identifier."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT p.id \nFROM posts p \nJOIN votes v ON p.id = v.post_id \nWHERE v.user_id = 1465 \nORDER BY p.score DESC \nLIMIT 1;",
            "SELECT T2.Id \nFROM votes T1 \nINNER JOIN posts T2 ON T1.PostId = T2.Id \nWHERE T1.UserId = 1465 \nORDER BY T2.FavoriteCount DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT p.Id \nFROM votes v\nINNER JOIN posts p ON v.PostId = p.Id\nWHERE v.UserId = 1465\nORDER BY p.FavoriteCount DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "381": {
        "db_id": "card_games",
        "question": "List down the name of artists for cards in Chinese Simplified.",
        "ground_truth": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
        "amends": [
            "Do reference the `artist` column from the `cards` table (aliased as `T1`) instead of `artist_name` from `cards`. Do join `cards AS T1` with `foreign_data AS T2` using an `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying only the `cards` table. Do filter on `T2.language = 'Chinese Simplified'` instead of `language = 'Chinese'` from the `cards` table. The amended query now correctly joins with the foreign_data table to access the proper language column and uses the appropriate language value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"artists for cards in Chinese Simplified\": make sure the output order: T1.artist 2) When the question mentions \"Chinese Simplified\": \"Chinese Simplified\" actually means T2.language = 'Chinese Simplified' in schema 3) When combining T1 (cards) and T2 (foreign_data) for shared entities: link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation from 'Chinese Simplified'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist_name FROM cards WHERE language = 'Chinese'",
            "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'"
        ],
        "rule_sql": [
            "SELECT DISTINCT c.artist\nFROM \"cards\" c\nINNER JOIN \"foreign_data\" fd ON c.uuid = fd.uuid\nWHERE fd.language = 'Chinese Simplified'\nORDER BY c.artist"
        ],
        "amend_res": 1
    },
    "1121": {
        "db_id": "european_football_2",
        "question": "Calculate the total home team goal scored by players whose age are 30 years old and below.",
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_1 WHERE datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31",
        "amends": [
            "Do use `SUM(t2.home_team_goal)` instead of `SUM(goals)` and change the source from `players` to `Player AS t1 INNER JOIN match AS t2` instead of a single table. Do add the join condition `ON t1.player_api_id = t2.away_player_1` instead of omitting it. Do replace the filter `age <= 30` with `datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31` to calculate age from birthday instead of using a static age column. Do remove the filter `team_type = 'home'` instead of keeping it. The amended query now correctly calculates age dynamically and aggregates home team goals from the match table through proper table joining."
        ],
        "rules": [
            "1) When calculating total home team goals: use SUM(t2.home_team_goal) instead of SUM(goals) and source data from Player AS t1 INNER JOIN match AS t2 instead of a single players table. 2) When joining Player and match tables: link rows where t1.player_api_id = t2.away_player_1 exactly as shown and keep only matching pairs (inner match). 3) When filtering by age 30 years old and below: calculate age dynamically using datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31 instead of using a static age column. 4) When the question mentions \"home team goal\": remove any filter for team_type = 'home' as this is not needed for the aggregation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(goals) FROM players WHERE age <= 30 AND team_type = 'home';",
            "SELECT SUM(t2.home_team_goal) \nFROM Player AS t1 \nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_1\nWHERE (datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(t1.birthday)) < 31"
        ],
        "rule_sql": [
            "SELECT SUM(t2.home_team_goal) AS total_home_goals\nFROM Player AS t1\nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_1\nWHERE (datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(t1.birthday)) < 31"
        ],
        "amend_res": 1
    },
    "725": {
        "db_id": "superhero",
        "question": "How many superheroes are published by Marvel Comics?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `superhero AS T1` with `publisher AS T2` instead of querying only the `superheroes` table. Do specify the join condition `ON T1.publisher_id = T2.id` instead of directly filtering on a publisher column. Do filter on `T2.publisher_name = 'Marvel Comics'` instead of `publisher = 'DC Comics'` to correctly reference the publisher table and use the appropriate publisher name. The amended query now properly counts Marvel Comics superheroes by joining through the publisher relationship instead of relying on a direct column that may not exist or be correctly normalized."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When answering about superheroes published by a specific publisher: join superhero AS T1 with publisher AS T2 using the condition T1.publisher_id = T2.id instead of querying only the superheroes table. 3) When filtering for Marvel Comics publisher: use T2.publisher_name = 'Marvel Comics' instead of publisher = 'DC Comics' to correctly reference the publisher table with the exact literal value. 4) When combining superhero and publisher tables: link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE publisher = 'DC Comics';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'Marvel Comics'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero AS T1 \nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id \nWHERE T2.publisher_name = 'Marvel Comics'"
        ],
        "amend_res": 1
    },
    "376": {
        "db_id": "card_games",
        "question": "What are the card layout of cards with keyword of flying?",
        "evidence": "",
        "ground_truth": "SELECT layout FROM cards WHERE keywords = 'Flying'",
        "amends": [
            "Do select only `layout` instead of all columns with `*`. Do reference the correct column name `keywords` instead of `keyword`. Do use the exact string value `'Flying'` instead of `'flying'` to match the proper capitalization. The amended query now correctly retrieves only the layout column from cards where the keywords column contains the exact value 'Flying', matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"card layout of cards with keyword of flying\": select only the \"layout\" column instead of all columns. 2) When the question mentions \"keyword\": the exact column name is \"keywords\" (not \"keyword\"). 3) When filtering for cards with flying keyword: use the exact string value 'Flying' (with proper capitalization) instead of 'flying'."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT * FROM cards WHERE keyword = 'flying';",
            "SELECT layout FROM cards WHERE keywords = 'Flying';"
        ],
        "rule_sql": [
            "SELECT layout FROM cards WHERE keywords LIKE '%Flying%'"
        ],
        "amend_res": 1
    },
    "1195": {
        "db_id": "thrombosis_prediction",
        "question": "What is the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE?",
        "ground_truth": "SELECT AVG(T2.ALB) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT > 400 AND T1.Diagnosis = 'SLE' AND T1.SEX = 'F'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of referencing tables directly. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying a single table. Do reference `T2.ALB` instead of `blood_albumin` for the average calculation. Do filter on `T2.PLT > 400` instead of `plt > 400` with proper table qualification. Do filter on `T1.Diagnosis = 'SLE'` instead of `diagnosis = 'SLE'` with proper table qualification. Do filter on `T1.SEX = 'F'` instead of `gender = 'male'` with the correct gender value and column name. The amended query now correctly joins patient and laboratory data and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about average blood albumin level: use T2.ALB for the average calculation instead of blood_albumin. 2) When the question mentions \"female patients\": use T1.SEX = 'F' instead of gender = 'male' with the exact literal 'F'. 3) When the question mentions \"PLT greater than 400\": use T2.PLT > 400 instead of plt > 400 with proper table qualification. 4) When the question mentions \"diagnosed with SLE\": use T1.Diagnosis = 'SLE' instead of diagnosis = 'SLE' with proper table qualification and exact literal 'SLE'. 5) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using an inner match instead of querying a single table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(blood_albumin) FROM patients WHERE gender = 'male' AND plt > 400 AND diagnosis = 'SLE';",
            "SELECT AVG(T2.ALB) AS average_albumin\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND T2.PLT > 400\nAND T1.Diagnosis = 'SLE'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.ALB) AS average_albumin\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'F'\nAND T2.PLT > 400\nAND T1.Diagnosis = 'SLE'"
        ],
        "amend_res": 1
    },
    "1153": {
        "db_id": "thrombosis_prediction",
        "question": "What is the disease patient '30609' diagnosed with. List all the date of laboratory tests done for this patient.",
        "ground_truth": "SELECT T1.Diagnosis, T2.Date FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID = 30609",
        "amends": [
            "Do select `Diagnosis` and `Date` instead of `disease_name` and `test_date`. Do use `Patient` and `Laboratory` tables instead of `patients`, `diagnoses`, and `laboratory_tests`. Do perform an `INNER JOIN` on `T1.ID = T2.ID` instead of joining through multiple tables with `patients.patient_id = diagnoses.patient_id` and `patients.patient_id = laboratory_tests.patient_id`. Do filter by numeric value `30609` instead of string value `'30609'`. The amended query now correctly retrieves diagnosis and test date information through a direct relationship between patient and laboratory records."
        ],
        "rules": [
            "1) When the question asks for disease diagnosis and laboratory test dates for a specific patient: select \"Diagnosis\" from table \"Patient\" and \"Date\" from table \"Laboratory\" as output columns. 2) When joining tables \"Patient\" and \"Laboratory\": perform an inner match where \"T1.ID\" equals \"T2.ID\" exactly. 3) When filtering for patient '30609': use numeric value 30609 without quotes for the patient ID filter. 4) When organizing output: maintain the column order as \"Diagnosis\" followed by \"Date\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disease_name, test_date FROM patients JOIN diagnoses ON patients.patient_id = diagnoses.patient_id JOIN laboratory_tests ON patients.patient_id = laboratory_tests.patient_id WHERE patients.patient_id = '30609';",
            "SELECT p.Diagnosis, l.Date\nFROM Patient p\nINNER JOIN Laboratory l ON p.ID = l.ID\nWHERE p.ID = 30609\nORDER BY l.Date;"
        ],
        "rule_sql": [
            "SELECT p.Diagnosis, l.Date FROM Patient p INNER JOIN Laboratory l ON p.ID = l.ID WHERE p.ID = 30609"
        ],
        "amend_res": 1
    },
    "284": {
        "db_id": "toxicology",
        "question": "Determine the bond type that is formed in the chemical compound containing element Carbon.",
        "ground_truth": "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'",
        "amends": [
            "Do use `DISTINCT T2.bond_type` instead of `bond_type` without distinct. Do join `atom AS T1 INNER JOIN bond AS T2` instead of querying a single table. Do use join condition `T1.molecule_id = T2.molecule_id` instead of no join. Do filter on `T1.element = 'c'` instead of `element = 'Carbon'`. Do reference `T2.bond_type` from the joined table instead of an unspecified source. The amended query now correctly identifies bond types from carbon atoms by properly joining the atom and bond tables and using appropriate filtering."
        ],
        "rules": [
            "1) When answering about bond types in chemical compounds containing Carbon: join table atom as T1 with table bond as T2 using inner match where T1.molecule_id = T2.molecule_id. 2) When filtering for element Carbon: use exact literal 'c' (lowercase) in condition T1.element = 'c' instead of 'Carbon'. 3) When selecting bond types: use DISTINCT T2.bond_type to get unique bond types from the bond table. 4) When referencing columns from joined tables: specify the exact table alias (T2.bond_type) rather than unspecified source."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM chemical_compounds WHERE element = 'Carbon';",
            "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'"
        ],
        "amend_res": 1
    },
    "739": {
        "db_id": "superhero",
        "question": "What are the names of the superheroes with the power of death touch?",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'",
        "amends": [
            "Do select `T1.superhero_name` instead of `name`. Do add `INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` and `INNER JOIN superpower AS T3 ON T2.power_id = T3.id` instead of querying only the `superheroes` table. Do filter on `T3.power_name = 'Death Touch'` instead of `power = 'death touch'` to properly reference the joined power table with correct case sensitivity. The amended query now correctly joins through the relationship tables to find superheroes with the specified power, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"names of superheroes with the power of death touch\": make sure the output order: T1.superhero_name. 2) When the question mentions \"superheroes\": use table \"superheroes\" as T1 with column \"superhero_name\" for names. 3) When the question mentions \"power of death touch\": this actually means \"T3.power_name = 'Death Touch'\" in the schema with exact case sensitivity. 4) When combining superheroes and power information: link rows using T1.id = T2.hero_id and T2.power_id = T3.id through hero_power as T2 and superpower as T3 tables, keeping only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE power = 'death touch';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Death Touch'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Death Touch'"
        ],
        "amend_res": 1
    },
    "391": {
        "db_id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
        "amends": [
            "Do select `T1.name` with `DISTINCT` instead of `*` from all columns. Do use `cards AS T1` and `foreign_data AS T2` tables instead of just `artifacts`. Do perform an `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying a single table. Do filter with `T1.originalType = 'Artifact'` and `T1.colors = 'B'` instead of `color = 'black'` and `language = 'foreign'`. The amended query now correctly identifies artifact cards with black color using proper table relationships and color coding conventions."
        ],
        "rules": [
            "1) When answering about \"Artifact cards\": make sure to filter using T1.originalType = 'Artifact' to identify artifact cards specifically. 2) When the question mentions \"black color\": use T1.colors = 'B' to match the color coding convention for black. 3) When the question mentions \"foreign language translation\": use the foreign_data table (T2) and join with T1 on T1.uuid = T2.uuid to access translation data. 4) When combining T1 and T2 for shared entities: link rows where T1.uuid = T2.uuid exactly and keep only matching pairs (inner match). 5) When selecting output: use DISTINCT T1.name instead of all columns to return only unique card names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM artifacts WHERE color = 'black' AND language = 'foreign';",
            "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN foreign_data T2 ON T1.uuid = T2.uuid\nWHERE T1.originalType = 'Artifact'\nAND T1.colors = 'B';"
        ],
        "amend_res": 1
    },
    "1130": {
        "db_id": "european_football_2",
        "question": "What are the short name of team who played safe while creating chance of passing?",
        "ground_truth": "SELECT DISTINCT t1.team_short_name FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.chanceCreationPassingClass = 'Safe'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it. Do change the column selection to `t1.team_short_name` instead of `short_name`. Do add `INNER JOIN` with `Team_Attributes AS t2` on `t1.team_api_id = t2.team_api_id` instead of querying only the `teams` table. Do change the filter to `t2.chanceCreationPassingClass = 'Safe'` instead of `chance_creation_passing = 'safe'`. The amended query now correctly joins tables and uses the proper column names to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"short name of team who played safe while creating chance of passing\": make sure the output order: t1.team_short_name\n2) When the question mentions \"short name\": \"short name\" actually means \"t1.team_short_name\" in schema\n3) When the question mentions \"safe while creating chance of passing\": \"safe while creating chance of passing\" actually means \"t2.chanceCreationPassingClass = 'Safe'\" in schema\n4) When combining teams and Team_Attributes for shared entities: link rows where t1.team_api_id = t2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When selecting team short names: use DISTINCT to return only unique values of t1.team_short_name"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT short_name FROM teams WHERE chance_creation_passing = 'safe';",
            "SELECT DISTINCT t1.team_short_name\nFROM Team AS t1\nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.chanceCreationPassingClass = 'Safe'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.team_short_name\nFROM Team t1\nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id\nWHERE t2.chanceCreationPassingClass = 'Safe'"
        ],
        "amend_res": 1
    },
    "784": {
        "db_id": "superhero",
        "question": "Provide the full names of vampire heroes.",
        "ground_truth": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "amends": [
            "Do reference `T1.full_name` instead of `first_name, last_name` columns. Do join `superhero AS T1` with `race AS T2` on `T1.race_id = T2.id` instead of querying a single `heroes` table. Do filter on `T2.race = 'Vampire'` instead of `species = 'vampire' AND alignment = 'villain'` conditions. The amended query now correctly joins tables and filters by race to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"full names of vampire heroes\": make sure the output order: T1.full_name. 2) When the question mentions \"vampire heroes\": \"vampire\" actually means \"T2.race = 'Vampire'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.race_id = T2.id; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation - use exact literal 'Vampire'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name, last_name FROM heroes WHERE species = 'vampire' AND alignment = 'villain';",
            "SELECT T1.full_name\nFROM superhero AS T1\nJOIN race AS T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Vampire'"
        ],
        "rule_sql": [
            "SELECT T1.full_name\nFROM superhero T1\nINNER JOIN race T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Vampire'"
        ],
        "amend_res": 1
    },
    "695": {
        "db_id": "codebase_community",
        "question": "How many users were awarded with 'Citizen Patrol' badge?",
        "ground_truth": "SELECT COUNT(id) FROM badges WHERE `Name` = 'Citizen Patrol'",
        "amends": [
            "Do query the `badges` table instead of the `users` table. Do use the `Name` column for filtering instead of `badge_name`. Do count `id` values instead of using `COUNT(*)`. Do filter for `'Citizen Patrol'` instead of maintaining the same filter condition. The amended query now correctly counts badges with the specified name rather than incorrectly counting users."
        ],
        "rules": [
            "1) When answering about \"users awarded with 'Citizen Patrol' badge\": query the \"badges\" table instead of the \"users\" table. 2) When filtering for badge names: use the \"Name\" column for filtering instead of \"badge_name\". 3) When counting badges: count \"id\" values instead of using COUNT(*). 4) When filtering for specific badge names: filter for exact literal 'Citizen Patrol' instead of maintaining the same filter condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE badge_name = 'Citizen Patrol';",
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Citizen Patrol'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Citizen Patrol'"
        ],
        "amend_res": 1
    },
    "507": {
        "db_id": "card_games",
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "amends": [
            "Do use `SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN availability = 'online' THEN 1 END)` to properly count boolean flags. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(id)` instead of `* 100.0 / COUNT(*)` for precise floating-point division. Do query from `sets` table instead of `cards` table as the source data. Do filter using `WHERE code IN (subquery)` instead of `WHERE translation = 'Brazil Portuguese'` to properly identify Brazilian Portuguese sets. Do add a correlated subquery `SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)'` instead of omitting the translation relationship logic. Do remove the incorrect `availability` column reference and instead use the correct `isOnlineOnly` boolean flag. The amended query now correctly calculates the percentage of online-only sets for Brazilian Portuguese translations."
        ],
        "rules": [
            "1) When answering about \"percentage of online-only sets for Brazilian Portuguese translations\": make sure the output order: percentage calculation as the single result. 2) When the question mentions \"cards that has Brazil Portuguese translation\": \"Brazil Portuguese translation\" actually means \"sets with code matching set_translations where language = 'Portuguese (Brazil)'\" in schema. 3) When querying from the sets table: use T1 as the alias for the sets table. 4) When counting online-only sets: use SUM(CASE WHEN T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) to properly count boolean flags. 5) When calculating percentage: use CAST(SUM(CASE WHEN T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) for precise floating-point division. 6) When filtering for Brazilian Portuguese translations: use WHERE T1.code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)') instead of direct translation column comparison. 7) When combining sets and set_translations: link rows where T1.code equals set_translations.setCode for the subquery condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN availability = 'online' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_online_only\nFROM cards\nWHERE translation = 'Brazil Portuguese';",
            "SELECT \n    CAST(SUM(CASE WHEN s.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(s.id) AS percentage_online_only\nFROM \n    sets s\nWHERE \n    s.code IN (\n        SELECT setCode \n        FROM set_translations \n        WHERE language = 'Portuguese (Brazil)'\n    )"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage\nFROM sets T1\nWHERE T1.code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)')"
        ],
        "amend_res": 1
    },
    "508": {
        "db_id": "card_games",
        "question": "What are the available printing types of the cards that doesn't have a text box created by Aleksi Briclot?",
        "ground_truth": "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1",
        "amends": [
            "Do select `availability` instead of `printing_type` and filter on `artist = 'Aleksi Briclot'` instead of `text_box_creator != 'Aleksi Briclot'`. Do add `AND isTextless = 1` instead of omitting it, and change the table reference to use the correct column names. The amended query now correctly filters for cards by Aleksi Briclot that are textless and returns their availability instead of printing type."
        ],
        "rules": [
            "1) When the question asks for \"available printing types\": actually select the \"availability\" column from the cards table instead of \"printing_type\". 2) When filtering for cards created by Aleksi Briclot: use the condition \"artist = 'Aleksi Briclot'\" instead of filtering on text_box_creator. 3) When looking for cards that don't have a text box: include the condition \"isTextless = 1\" to filter for textless cards. 4) When answering about available printing types of cards: make sure the output order shows distinct availability values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT printing_type \nFROM cards \nWHERE text_box_creator != 'Aleksi Briclot';",
            "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;"
        ],
        "rule_sql": [
            "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1 ORDER BY availability;"
        ],
        "amend_res": 1
    },
    "471": {
        "db_id": "card_games",
        "question": "What is the expansion type of the set \"Hauptset Zehnte Edition\"?",
        "ground_truth": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [
            "Do select `T1.type` from the `sets` table instead of `expansion_type` from just the `sets` table. Do add an `INNER JOIN` with `set_translations AS T2` on `T2.setCode = T1.code` instead of querying only the `sets` table. Do filter on `T2.translation = 'Hauptset Zehnte Edition'` instead of `set_name = 'Hauptset Zehnte Edition'` to properly match the translated set name. The amended query now correctly joins the translation table to find sets by their translated names rather than relying on the base table's set_name field."
        ],
        "rules": [
            "1) When the question asks about expansion type for a specific set name: use T1.type from the sets table as the output column instead of expansion_type. 2) When matching a set by translated name 'Hauptset Zehnte Edition': join sets table T1 with set_translations table T2 using T2.setCode = T1.code instead of querying only the sets table. 3) When filtering for the exact translation 'Hauptset Zehnte Edition': use T2.translation = 'Hauptset Zehnte Edition' instead of set_name = 'Hauptset Zehnte Edition' to properly match the translated set name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT expansion_type FROM sets WHERE set_name = 'Hauptset Zehnte Edition';",
            "SELECT T1.type \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T2.translation = 'Hauptset Zehnte Edition'"
        ],
        "rule_sql": [
            "SELECT T1.type FROM sets T1 JOIN set_translations T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'"
        ],
        "amend_res": 1
    },
    "877": {
        "db_id": "formula_1",
        "question": "For all the drivers who finished the game in race No. 872, who is the youngest?",
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 872 AND T2.time IS NOT NULL ORDER BY T1.dob DESC LIMIT 1",
        "amends": [
            "Do select `T1.forename` and `T1.surname` instead of just `driver_name`. Do join `drivers AS T1` with `results AS T2` using `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only the `drivers` table. Do filter with `T2.raceId = 872` and `T2.time IS NOT NULL` instead of just `race_id = 872`. Do order by `T1.dob DESC` instead of `age ASC`. The amended query now correctly retrieves driver names from qualified finishers of the specified race, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about drivers who finished a specific race: combine drivers table (as T1) with results table (as T2) using inner match where T2.driverId equals T1.driverId. 2) When filtering for race No. 872: use T2.raceId = 872 and ensure T2.time IS NOT NULL to identify finishers. 3) When determining the youngest driver: order by T1.dob in descending order (most recent birth date first) and take the first result. 4) When selecting driver names: output both T1.forename and T1.surname instead of a single driver_name field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM drivers WHERE race_id = 872 ORDER BY age ASC LIMIT 1;",
            "SELECT T1.forename, T1.surname \nFROM drivers AS T1 \nINNER JOIN results AS T2 ON T2.driverId = T1.driverId \nWHERE T2.raceId = 872 AND T2.time IS NOT NULL \nORDER BY T1.dob DESC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.forename, T1.surname \nFROM drivers AS T1 \nINNER JOIN results AS T2 ON T1.driverId = T2.driverId \nWHERE T2.raceId = 872 \nAND T2.time IS NOT NULL \nORDER BY T1.dob DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1285": {
        "db_id": "thrombosis_prediction",
        "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
        "amends": [
            "Do select `T1.First Date` instead of `MAX(record_date)`. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only `medical_data`. Do filter with `T2.LDH >= 500` instead of `lactate_dehydrogenase > 1000`. Do order by `T1.First Date DESC` instead of `patient_id DESC`. The amended query now correctly retrieves the first date from Patient table for cases with elevated LDH levels from Laboratory data."
        ],
        "rules": [
            "1) When answering about \"latest patient's medical data recorded\": make sure the output order: T1.\"First Date\" 2) When the question mentions \"patient's medical data\": combine Patient as T1 and Laboratory as T2 using inner match where T1.ID = T2.ID 3) When the question mentions \"abnormal level of lactate dehydrogenase\": filter with T2.LDH >= 500 4) When the question asks for \"latest\": order by T1.\"First Date\" DESC and take the first row"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(record_date) FROM medical_data WHERE lactate_dehydrogenase > 1000 ORDER BY patient_id DESC LIMIT 1;",
            "SELECT T1.`First Date` \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.LDH >= 500\nORDER BY T1.`First Date` DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.\"First Date\" \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.LDH >= 500 \nORDER BY T1.\"First Date\" DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "777": {
        "db_id": "superhero",
        "question": "What is the gender of Agent 13 hero?",
        "ground_truth": "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'",
        "amends": [
            "Do select `T2.gender` instead of `hero_name`. Do use `FROM superhero AS T1 INNER JOIN gender AS T2` instead of `FROM heroes`. Do specify join condition `ON T1.gender_id = T2.id` instead of omitting any join. Do filter with `WHERE T1.superhero_name = 'Agent 13'` instead of `WHERE agent_id = 13`. The amended query now correctly retrieves gender information by joining tables and using the proper superhero name filter instead of an agent ID, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"gender of Agent 13 hero\": make sure the output order: T2.gender 2) When the question mentions \"Agent 13 hero\": \"Agent 13\" actually means \"T1.superhero_name = 'Agent 13'\" in schema 3) When combining T1 and T2 for shared entities: link rows where T1.gender_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match) 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 5) When handling text literals: do not change case, spacing, or punctuation for 'Agent 13'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hero_name FROM heroes WHERE agent_id = 13;",
            "SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'"
        ],
        "rule_sql": [
            "SELECT T2.gender FROM superhero T1 JOIN gender T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'"
        ],
        "amend_res": 1
    },
    "1068": {
        "db_id": "european_football_2",
        "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
        "amends": [
            "Do use `CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id)` instead of `AVG(overall_rating)` to calculate the average with proper casting. Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying a single table. Do filter on `t1.height > 170` instead of just `height > 170` to specify the table source. Do use `STRFTIME('%Y',t2.date) >= '2010' AND STRFTIME('%Y',t2.date) <= '2015'` for year filtering instead of `year BETWEEN 2010 AND 2015` to properly extract years from date strings. The amended query now correctly joins the necessary tables and handles date parsing to match the intended behavior."
        ],
        "rules": [
            "1) When calculating averages of numeric columns: use CAST(SUM(column) AS REAL) / COUNT(key_column) instead of AVG() to ensure proper numeric casting. 2) When joining Player and Player_Attributes tables: perform an INNER JOIN where Player AS t1.player_api_id equals Player_Attributes AS t2.player_api_id exactly. 3) When filtering by height: specify the table source as t1.height instead of just height to avoid ambiguity. 4) When filtering by year ranges from date strings: use STRFTIME('%Y', date_column) >= 'start_year' AND STRFTIME('%Y', date_column) <= 'end_year' instead of year BETWEEN for proper date extraction. 5) When the question asks for average overall rating of players: calculate the average using t2.overall_rating from Player_Attributes table. 6) When filtering players by height: use the condition t1.height > 170 with the exact numeric value. 7) When filtering by years 2010 to 2015: use the exact string literals '2010' and '2015' with STRFTIME year extraction from t2.date."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) FROM players WHERE height > 170 AND year BETWEEN 2010 AND 2015;",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\nAND STRFTIME('%Y', t2.date) >= '2010' \nAND STRFTIME('%Y', t2.date) <= '2015'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.player_api_id) AS average_overall_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 170\nAND STRFTIME('%Y', t2.date) >= '2010' \nAND STRFTIME('%Y', t2.date) <= '2015'"
        ],
        "amend_res": 1
    },
    "593": {
        "db_id": "codebase_community",
        "question": "How many users from New York have a teacher and supporter badge?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name IN ('Supporter', 'Teacher') AND T2.Location = 'New York'",
        "amends": [
            "Do use `COUNT(DISTINCT T1.Id)` instead of `COUNT(*)` to count unique users. Do join `badges AS T1` with `users AS T2` on `T1.UserId = T2.Id` instead of querying only the users table. Do filter badge names with `T1.Name IN ('Supporter', 'Teacher')` instead of using `badge = 'teacher' AND badge = 'supporter'` which would never match. Do filter location with `T2.Location = 'New York'` instead of `city = 'New York'`. The amended query now correctly counts distinct users who have either Supporter or Teacher badges in New York, matching the RIGHT_SQL's behavior.",
            "Do count distinct `T1.Id` instead of `T1.UserId` in the SELECT clause. Do add explicit `INNER JOIN` syntax instead of implicit JOIN. Do reorder the WHERE clause predicates while maintaining the same logical conditions of `T1.Name IN ('Supporter', 'Teacher')` and `T2.Location = 'New York'`. The amended query now correctly counts distinct badge IDs from users in New York with specific badge types, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting users: use COUNT(DISTINCT T1.Id) to count unique users instead of COUNT(*) for all rows. 2) When combining badges and users tables: join badges AS T1 with users AS T2 on T1.UserId = T2.Id to link badge assignments to user information. 3) When filtering for specific badges: use T1.Name IN ('Supporter', 'Teacher') to find users with either badge instead of requiring both badges simultaneously. 4) When filtering for location: use T2.Location = 'New York' to find users from New York instead of city = 'New York'.",
            "1) When counting distinct badge IDs from users: use T1.Id as the counting key instead of T1.UserId. 2) When combining badges and users tables: use explicit INNER JOIN syntax to link rows where T1.UserId = T2.Id. 3) When filtering for users from New York: use the exact literal 'New York' for T2.Location comparison. 4) When filtering for specific badge types: use the exact literals 'Supporter' and 'Teacher' in the IN condition for T1.Name. 5) When organizing the WHERE clause: maintain both conditions T1.Name IN ('Supporter', 'Teacher') and T2.Location = 'New York' with proper logical ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE city = 'New York' AND badge = 'teacher' AND badge = 'supporter';",
            "SELECT COUNT(DISTINCT T1.UserId) \nFROM badges AS T1 \nJOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T2.Location = 'New York' \nAND T1.Name IN ('Supporter', 'Teacher')",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM badges AS T1\nINNER JOIN users AS T2 ON T1.UserId = T2.Id\nWHERE T1.Name IN ('Supporter', 'Teacher') \nAND T2.Location = 'New York'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Id) \nFROM badges AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.Name IN ('Supporter', 'Teacher') \nAND T2.Location = 'New York'"
        ],
        "amend_res": 1
    },
    "1432": {
        "db_id": "student_club",
        "question": "Among the members with t-shirt size of medium, what is the percentage of the amount 50 received by the Student_Club?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) AS REAL) * 100 / COUNT(T2.income_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.position = 'Member' AND T1.t_shirt_size = 'Medium'",
        "amends": [
            "Do use `SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END)` instead of `COUNT(*)` to count only specific rows. Do add `INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member` instead of querying only the members table. Do change the table reference to `member AS T1` instead of `members` and add `T1.position = 'Member'` filter instead of omitting it. Do use `COUNT(T2.income_id)` instead of the subquery `(SELECT COUNT(*) FROM members WHERE t_shirt_size = 'medium')` for the denominator. Do cast the result to `REAL` instead of using decimal multiplication directly. Do change the filter to `T1.t_shirt_size = 'Medium'` instead of `t_shirt_size = 'medium'` with proper case sensitivity. Do remove the incorrect `amount = 50` filter from the WHERE clause since amount is now in the joined income table. The amended query now correctly calculates the percentage of income records with amount 50 among all income records for members with medium t-shirt size."
        ],
        "rules": [
            "1) When the question asks for percentage of amount 50 received by Student_Club among members with medium t-shirt size: use SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) divided by COUNT(T2.income_id) to calculate the percentage. 2) When combining member and income tables: link rows where T1.member_id = T2.link_to_member using an inner join. 3) When filtering members: include only rows where T1.t_shirt_size = 'Medium' (case-sensitive) and T1.position = 'Member'. 4) When handling the amount condition: do not filter by amount = 50 in the WHERE clause since amount is in the joined income table. 5) When casting the result: cast the percentage calculation to REAL data type."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM members WHERE t_shirt_size = 'medium')) AS percentage\nFROM members \nWHERE t_shirt_size = 'medium' AND amount = 50;",
            "SELECT \n    (SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) / COUNT(T2.income_id)) * 100.0 AS percentage\nFROM \n    member AS T1\nINNER JOIN \n    income AS T2 ON T1.member_id = T2.link_to_member\nWHERE \n    T1.t_shirt_size = 'Medium' \n    AND T1.position = 'Member'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) / COUNT(T2.income_id) * 100 AS REAL) AS percentage\nFROM \n    member T1\nINNER JOIN \n    income T2 ON T1.member_id = T2.link_to_member\nWHERE \n    T1.t_shirt_size = 'Medium' \n    AND T1.position = 'Member';"
        ],
        "amend_res": 1
    },
    "1110": {
        "db_id": "european_football_2",
        "question": "Tell the build Up play passing class for \"FC Lorient\" on 2010/2/22.",
        "ground_truth": "SELECT t2.buildUpPlayPassingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'FC Lorient' AND t2.`date` LIKE '2010-02-22%'",
        "amends": [
            "Do select `t2.buildUpPlayPassingClass` instead of `passing_class` and use proper table aliases. Do join `Team AS t1` and `Team_Attributes AS t2` with `INNER JOIN` on `t1.team_api_id = t2.team_api_id` instead of querying a single table. Do filter on `t1.team_long_name = 'FC Lorient'` instead of `team = 'FC Lorient'` to use the correct column name. Do use `t2.date LIKE '2010-02-22%'` instead of `date = '2010/2/22'` to match the date format with wildcard pattern. The amended query now correctly retrieves the build-up play passing class from the joined tables using proper relationships and date matching."
        ],
        "rules": [
            "1) When answering about \"build Up play passing class for FC Lorient on 2010/2/22\": make sure the output order: t2.buildUpPlayPassingClass. 2) When the question mentions \"FC Lorient\": \"FC Lorient\" actually means \"t1.team_long_name = 'FC Lorient'\" in schema. 3) When the question mentions date \"2010/2/22\": use \"t2.date LIKE '2010-02-22%'\" to match the date format with wildcard pattern. 4) When combining Team as t1 and Team_Attributes as t2: link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT passing_class FROM matches WHERE team = 'FC Lorient' AND date = '2010/2/22';",
            "SELECT t2.buildUpPlayPassingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'FC Lorient' \nAND t2.date LIKE '2010-02-22%'"
        ],
        "rule_sql": [
            "SELECT t2.buildUpPlayPassingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'FC Lorient' \nAND t2.date LIKE '2010-02-22%'"
        ],
        "amend_res": 1
    },
    "275": {
        "db_id": "toxicology",
        "question": "Give me the molecule ID of the double bond type.",
        "ground_truth": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate molecule_id values. Do reference table with alias `T` instead of using no alias. Do query from `bond` table instead of `double_bonds` table. Do use filter `bond_type = '='` instead of `bond_type = 'double'` to match the correct bond type representation. The amended query now correctly selects unique molecule identifiers from the bond table where bond type equals the standard '=' notation."
        ],
        "rules": [
            "1) When answering about \"molecule ID of the double bond type\": make sure the output order: molecule_id. 2) When the question mentions \"double bond type\": \"double bond type\" actually means bond_type = '=' in schema. 3) When selecting molecule identifiers: use DISTINCT to eliminate duplicate molecule_id values. 4) When querying from the bond table: use alias T instead of no alias. 5) When filtering for bond type: use exact literal '=' instead of 'double' to match the correct bond type representation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM double_bonds WHERE bond_type = 'double'",
            "SELECT DISTINCT T.molecule_id FROM bond T WHERE T.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.molecule_id FROM bond T WHERE T.bond_type = '='"
        ],
        "amend_res": 1
    },
    "365": {
        "db_id": "card_games",
        "question": "What is the type of card \"Benalish Knight\"?",
        "ground_truth": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
        "amends": [
            "Do select `DISTINCT T1.type` instead of `name` and add table alias `T1` instead of omitting it. Do add `INNER JOIN foreign_data AS T2` instead of querying only the `cards` table. Do use join condition `ON T1.uuid = T2.uuid` instead of no join. Do change filter to `WHERE T1.name = 'Benalish Knight'` instead of `WHERE type = 'Benalish Knight'`. The amended query now correctly retrieves distinct card types by joining with foreign data and filtering on the card name, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about card types: make sure the output order: T1.type\n2) When the question mentions \"Benalish Knight\": \"Benalish Knight\" actually means T1.name in schema\n3) When combining T1 and T2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)\n4) When the question asks for distinct values: compute the number of unique values of the exact token for T1.type"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM cards WHERE type = 'Benalish Knight';",
            "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.type FROM cards T1 WHERE T1.name = 'Benalish Knight';"
        ],
        "amend_res": 1
    },
    "349": {
        "db_id": "card_games",
        "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
        "ground_truth": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 AND T1.artist = (SELECT artist FROM cards WHERE isPromo = 1 GROUP BY artist HAVING COUNT(DISTINCT uuid) = (SELECT MAX(count_uuid) FROM ( SELECT COUNT(DISTINCT uuid) AS count_uuid FROM cards WHERE isPromo = 1 GROUP BY artist ))) LIMIT 1",
        "amends": [
            "Do select `T1.name`, `T1.artist`, and `T1.isPromo` instead of `card_name`, `artist_name`, `COUNT(*) as ruling_count`, and `is_promotional`. Do use `INNER JOIN` on `T1.uuid = T2.uuid` instead of joining on `cards.card_id = rulings.card_id` and `cards.artist_id = artists.artist_id`. Do add a `WHERE` filter for `T1.isPromo = 1` instead of omitting it. Do add a correlated subquery to find the artist with the maximum count of distinct promo cards instead of grouping by card attributes and counting rulings. Do remove the `GROUP BY` and `ORDER BY ruling_count DESC` clauses instead of keeping them. The amended query now correctly identifies the promotional card from the artist with the most distinct promotional cards, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting card information: use T1.name for card name, T1.artist for artist name, and T1.isPromo for promotional status instead of card_name, artist_name, and is_promotional. 2) When combining card and ruling information: link rows using T1.uuid = T2.uuid with an inner join instead of joining on card_id and artist_id. 3) When filtering for promotional cards: include only rows where T1.isPromo = 1. 4) When finding the artist with the most distinct promotional cards: use a correlated subquery to count distinct promo cards per artist instead of grouping by card attributes and counting rulings. 5) When determining the maximum count: do not use GROUP BY or ORDER BY ruling_count DESC clauses."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT card_name, artist_name, COUNT(*) as ruling_count, is_promotional\nFROM cards\nJOIN rulings ON cards.card_id = rulings.card_id\nJOIN artists ON cards.artist_id = artists.artist_id\nGROUP BY card_name, artist_name, is_promotional\nORDER BY ruling_count DESC\nLIMIT 1;",
            "SELECT T1.name, T1.artist, T1.isPromo\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.isPromo = 1\nAND T1.artist = (\n    SELECT artist\n    FROM cards\n    WHERE isPromo = 1\n    GROUP BY artist\n    ORDER BY COUNT(DISTINCT uuid) DESC\n    LIMIT 1\n)\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.artist, T1.isPromo\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.isPromo = 1\nAND (SELECT COUNT(*) FROM rulings T3 WHERE T3.uuid = T1.uuid) = (\n    SELECT MAX(ruling_count)\n    FROM (\n        SELECT COUNT(*) as ruling_count\n        FROM rulings T4\n        INNER JOIN cards T5 ON T4.uuid = T5.uuid\n        WHERE T5.isPromo = 1\n        GROUP BY T5.uuid\n    )\n)"
        ],
        "amend_res": 1
    },
    "1483": {
        "db_id": "debit_card_specializing",
        "question": "How much did customer 6 consume in total between August and November 2013?",
        "ground_truth": "SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'",
        "amends": [
            "Do reference table `yearmonth` instead of `transactions` in the FROM clause. Do use column `Consumption` instead of `amount` in the SELECT list for aggregation. Do use column `CustomerID` instead of `customer_id` in the WHERE filter condition. Do use column `Date` instead of `date` in the date range filter. Do use date format 'YYYYMM' with values '201308' and '201311' instead of 'YYYY-MM-DD' format with '2013-08-01' and '2013-11-30' for the BETWEEN predicate. The amended query now correctly matches the intended logic and schema structure."
        ],
        "rules": [
            "1) When answering about customer consumption: use table \"yearmonth\" instead of \"transactions\" 2) When aggregating consumption amounts: use column \"Consumption\" instead of \"amount\" 3) When filtering by customer: use column \"CustomerID\" instead of \"customer_id\" with exact value 6 4) When filtering by date range: use column \"Date\" instead of \"date\" with exact format 'YYYYMM' 5) When specifying date range between August and November 2013: use exact values '201308' and '201311' instead of '2013-08-01' and '2013-11-30'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM transactions WHERE customer_id = 6 AND date BETWEEN '2013-08-01' AND '2013-11-30';",
            "SELECT SUM(Consumption) AS TotalConsumption FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'"
        ],
        "rule_sql": [
            "SELECT SUM(Consumption) AS TotalConsumption FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '201308' AND '201311'"
        ],
        "amend_res": 1
    },
    "1158": {
        "db_id": "thrombosis_prediction",
        "question": "List all patients who were born in 1937 whose total cholesterol was beyond the normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) = '1937' AND T2.`T-CHO` >= 250",
        "amends": [
            "Do select `DISTINCT T1.ID` instead of `*` to return only unique patient identifiers. Do use `Patient AS T1` and `Laboratory AS T2` tables instead of just `patients` to access both patient and lab data. Do perform an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table to combine patient and laboratory records. Do filter by `STRFTIME('%Y', T1.Birthday) = '1937'` instead of `year(birth_date) = 1937` to use proper date formatting. Do use `T2.\"T-CHO\" >= 250` instead of `cholesterol > 200` to reference the correct column name with proper threshold comparison. The amended query now correctly identifies patients born in 1937 with total cholesterol values of 250 or higher by joining patient and laboratory data."
        ],
        "rules": [
            "1) When answering about patients born in a specific year: use STRFTIME('%Y', T1.Birthday) = '1937' to filter by birth year with exact date formatting. 2) When combining patient and laboratory data: perform an inner join where T1.ID = T2.ID to link records using patient identifiers. 3) When checking for abnormal total cholesterol levels: use T2.\"T-CHO\" >= 250 as the threshold comparison with the correct column name and value. 4) When selecting patient identifiers: return DISTINCT T1.ID instead of all columns to ensure unique patient records. 5) When referring to tables: use Patient AS T1 and Laboratory AS T2 as the canonical table aliases."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM patients WHERE year(birth_date) = 1937 AND cholesterol > 200",
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.Birthday) = '1937'\nAND T2.\"T-CHO\" >= 250"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.Birthday) = '1937'\nAND T2.\"T-CHO\" >= 250"
        ],
        "amend_res": 1
    },
    "1237": {
        "db_id": "thrombosis_prediction",
        "question": "Among all outpatients, list out those have low hemoglobin level. State the different IDs and their sex.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HGB < 10 AND T1.Admission = '-'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `ID` and `SEX` instead of `patient_id` and `sex`. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.HGB < 10` instead of `hemoglobin_level > 12.0`, and add `T1.Admission = '-'` instead of `patient_type = 'outpatient'`. The amended query now correctly identifies patients with low hemoglobin levels from laboratory data rather than relying on outpatient status with high hemoglobin thresholds."
        ],
        "rules": [
            "1) When answering about \"outpatients\": use \"T1.Admission = '-'\" instead of \"patient_type = 'outpatient'\" to identify outpatients. 2) When the question mentions \"low hemoglobin level\": use \"T2.HGB < 10\" instead of \"hemoglobin_level > 12.0\" to identify low hemoglobin levels. 3) When combining Patient and Laboratory tables: link rows where \"T1.ID = T2.ID\" using an inner join to ensure only matching patient records are included. 4) When selecting patient identifiers: use \"ID\" instead of \"patient_id\" and \"SEX\" instead of \"sex\" as the exact column names. 5) When listing distinct patients: use DISTINCT to ensure each patient appears only once in the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex FROM patients WHERE patient_type = 'outpatient' AND hemoglobin_level > 12.0;",
            "SELECT DISTINCT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.HGB < 10 AND T1.Admission = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-' AND T2.HGB < 10"
        ],
        "amend_res": 1
    },
    "1453": {
        "db_id": "student_club",
        "question": "List the name of events with less than average parking cost.",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)",
        "amends": [
            "Do select `T1.event_name` instead of `name` and change the FROM clause to use `event AS T1` instead of `events`. Do add `INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event` and `INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget` instead of querying a single table. Do change the WHERE filter to `T2.category = 'Parking' AND T3.cost <` instead of `parking_cost <` and update the subquery to reference `expense` table with `cost` column instead of `events` table with `parking_cost`. The amended query now correctly joins related tables to filter parking expenses and compare against the average cost, matching the intended behavior.",
            "Do use a simpler subquery with just `SELECT AVG(cost) FROM expense` instead of the complex correlated subquery that joins `expense` with `budget` and filters by `T2.category = 'Parking'`. The amended subquery correctly calculates the overall average cost from the expense table rather than attempting to correlate with the outer query's budget category filter, which was redundant since the outer query already filters for 'Parking' category. This change eliminates unnecessary joins and correlation in the subquery while maintaining the same logical comparison of expense costs against the overall average. The amended query now matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"events with less than average parking cost\": make sure the output order: T1.event_name. 2) When the question mentions \"events\": use table \"event AS T1\" instead of \"events\". 3) When the question mentions \"parking cost\": \"parking cost\" actually means \"T2.category = 'Parking' AND T3.cost\" in schema. 4) When combining T1, T2, and T3 for shared entities: link rows where T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget; keep only matching pairs (inner match). 5) When computing average parking cost: calculate the average of T3.cost where T2.category = 'Parking'. 6) When filtering for events with less than average parking cost: include only rows where T2.category = 'Parking' AND T3.cost < (average parking cost).",
            "1) When calculating average parking cost: compute the overall average cost from the expense table using just SELECT AVG(cost) FROM expense instead of joining with budget table and filtering by category. 2) When filtering for parking expenses: use the outer query's budget category filter (T2.category = 'Parking') to identify parking-related expenses, not the subquery. 3) When comparing expense costs against average: use the simplified subquery result to compare T3.cost < (overall average cost) without redundant joins in the subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM events WHERE parking_cost < (SELECT AVG(parking_cost) FROM events)",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T2.category = 'Parking' \nAND T3.cost < (SELECT AVG(cost) FROM expense AS T3 INNER JOIN budget AS T2 ON T3.link_to_budget = T2.budget_id WHERE T2.category = 'Parking')",
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T2.category = 'Parking' AND T3.cost < (SELECT AVG(cost) FROM expense)"
        ],
        "rule_sql": [
            "SELECT T1.event_name\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget\nWHERE T2.category = 'Parking'\nAND T3.cost < (SELECT AVG(cost) FROM expense)\nORDER BY T1.event_name;"
        ],
        "amend_res": 1
    },
    "927": {
        "db_id": "formula_1",
        "question": "Which driver created the fastest lap speed in a Formula_1 race? Please give both his forename and surname.",
        "evidence": "",
        "ground_truth": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [
            "Do select only `forename` and `surname` instead of including `MAX(l.fastestLapSpeed)` in the SELECT list. Do join `results` table instead of `laptimes` table as the data source. Do use `INNER JOIN` on `T2.driverId = T1.driverId` instead of joining on the same condition but with different table aliases. Do add `WHERE T2.fastestLapTime IS NOT NULL` filter instead of omitting this condition. Do remove the `GROUP BY d.driverId` clause instead of keeping unnecessary aggregation. Do order by `T2.fastestLapSpeed DESC` directly instead of using `MAX(l.fastestLapSpeed)` aggregate function. The amended query now correctly retrieves the driver with the fastest lap speed from the results table where fastest lap time is recorded, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"fastest lap speed in a Formula_1 race\": make sure the output order: forename, surname. 2) When the question asks for the fastest lap speed: use the \"results\" table instead of \"laptimes\" table as the data source. 3) When combining drivers and results tables: link rows where T1.driverId = T2.driverId using inner join. 4) When filtering for valid lap speed records: include only rows where T2.fastestLapTime IS NOT NULL. 5) When ordering by fastest lap speed: sort by T2.fastestLapSpeed DESC to find the maximum value. 6) When selecting the top result: take only the first row after ordering by fastest lap speed descending."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.forename, d.surname, MAX(l.fastestLapSpeed) \nFROM drivers d\nJOIN laptimes l ON d.driverId = l.driverId\nGROUP BY d.driverId\nORDER BY MAX(l.fastestLapSpeed) DESC\nLIMIT 1;",
            "SELECT d.forename, d.surname\nFROM drivers d\nINNER JOIN results T2 ON d.driverId = T2.driverId\nWHERE T2.fastestLapTime IS NOT NULL\nORDER BY T2.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT d.forename, d.surname\nFROM drivers d\nINNER JOIN results r ON d.driverId = r.driverId\nWHERE r.fastestLapSpeed IS NOT NULL\nORDER BY r.fastestLapSpeed DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1418": {
        "db_id": "student_club",
        "question": "Mention the category of events which were held at MU 215.",
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215'",
        "amends": [
            "Do select `T2.category` from the `budget` table instead of `category` from the `events` table. Do add an `INNER JOIN` between `event AS T1` and `budget AS T2` with the predicate `T1.event_id = T2.link_to_event` instead of querying only the `events` table. Do keep the `WHERE` filter on `T1.location = 'MU 215'` but apply it to the joined `event` table instead of the original `events` table. The amended query now correctly retrieves category information from the budget table through proper table joining and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"category of events\": make sure the output order: T2.category 2) When the question mentions \"events held at MU 215\": \"MU 215\" actually means T1.location = 'MU 215' in schema 3) When combining event table (T1) and budget table (T2) for shared entities: link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match) 4) When retrieving category information: select T2.category from the budget table instead of category from the events table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT category FROM events WHERE location = 'MU 215';",
            "SELECT T2.category \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.location = 'MU 215'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.category \nFROM event T1 \nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event \nWHERE T1.location = 'MU 215' \nORDER BY T2.category"
        ],
        "amend_res": 1
    },
    "1240": {
        "db_id": "thrombosis_prediction",
        "question": "From laboratory examinations in 1991, what is the average hematoclit level that is lower than the normal range.",
        "ground_truth": "SELECT AVG(T2.HCT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HCT < 29 AND STRFTIME('%Y', T2.Date) = '1991'",
        "amends": [
            "Do reference table `Laboratory` with alias `T2` instead of `laboratory_examinations`. Do use column `HCT` instead of `hematocrit` for the average calculation. Do add an `INNER JOIN` on `Patient AS T1` with join condition `T1.ID = T2.ID` instead of omitting the patient table join. Do change the filter to `HCT < 29` instead of `hematocrit > normal_range`. Do use `STRFTIME('%Y', T2.Date) = '1991'` for year extraction instead of direct `year = 1991` comparison. The amended query now correctly calculates average HCT values for patients from 1991 with values below the specified threshold, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about average hematocrit levels: use column \"HCT\" from table \"Laboratory\" (aliased as T2) instead of \"hematocrit\". 2) When filtering for year 1991: extract year from \"Date\" column using STRFTIME('%Y', T2.Date) = '1991' instead of direct year comparison. 3) When filtering for values lower than normal range: use condition HCT < 29 instead of comparing to a normal_range column. 4) When combining patient and laboratory data: perform an INNER JOIN between \"Patient\" AS T1 and \"Laboratory\" AS T2 using join condition T1.ID = T2.ID. 5) When calculating averages: compute AVG(HCT) for the filtered results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(hematocrit) FROM laboratory_examinations WHERE year = 1991 AND hematocrit > normal_range;",
            "SELECT AVG(T2.HCT) AS average_hematocrit\nFROM Laboratory AS T2\nINNER JOIN Patient AS T1 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.Date) = '1991'\nAND T2.HCT < 29"
        ],
        "rule_sql": [
            "SELECT AVG(T2.HCT) AS average_hematocrit\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.Date) = '1991'\nAND T2.HCT < 29"
        ],
        "amend_res": 1
    },
    "662": {
        "db_id": "codebase_community",
        "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
        "amends": [
            "Do count `T1.Id` instead of `COUNT(*)` to avoid counting null votes. Do use `INNER JOIN` with alias `T2` instead of `v` for votes table. Do apply the `BountyAmount = 50` filter on `T2` (votes table) instead of `p` (posts table) since bounty amount belongs to votes. Do use `STRFTIME` on `T2.CreationDate` instead of `p.creation_date` to filter by vote creation year 2011 rather than post creation year. The amended query now correctly counts posts with votes that have a bounty amount of 50 and were created in 2011, matching the intended behavior."
        ],
        "rules": [
            "1) When counting posts with votes: count using T1.Id instead of all columns to avoid counting null votes. 2) When combining posts and votes tables: use INNER JOIN with alias T1 for posts and T2 for votes, linking rows where T1.Id = T2.PostId. 3) When filtering by bounty amount: apply BountyAmount = 50 filter on T2 (votes table) since bounty amount belongs to votes. 4) When filtering by creation year 2011: use STRFTIME on T2.CreationDate instead of post creation date to filter by vote creation year. 5) When answering about posts with votes: ensure the query counts posts that have matching votes with the specified conditions rather than counting all posts or votes."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM posts p\nJOIN votes v ON p.id = v.post_id\nWHERE strftime('%Y', p.creation_date) = '2011'\nAND p.bounty_amount = 50;",
            "SELECT COUNT(DISTINCT T1.Id) \nFROM posts T1\nINNER JOIN votes T2 ON T1.Id = T2.PostId\nWHERE T2.BountyAmount = 50 \nAND STRFTIME('%Y', T2.CreationDate) = '2011'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.Id) \nFROM posts AS T1 \nINNER JOIN votes AS T2 ON T1.Id = T2.PostId \nWHERE STRFTIME('%Y', T2.CreationDate) = '2011' \nAND T2.BountyAmount = 50"
        ],
        "amend_res": 1
    },
    "71": {
        "db_id": "california_schools",
        "question": "What is the district code for the School that does not offer a magnet program in the city of Fresno?",
        "ground_truth": "SELECT T1.`District Code` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.City = 'Fresno' AND T2.Magnet = 0",
        "amends": [
            "Do select `T1.District Code` instead of `district_code`. Do use `FROM frpm AS T1 INNER JOIN schools AS T2` instead of `FROM schools` alone. Do add join condition `ON T1.CDSCode = T2.CDSCode` instead of omitting it. Do change filter to `T2.City = 'Fresno'` instead of `city = 'Fresno'`. Do change magnet program filter to `T2.Magnet = 0` instead of `magnet_program = 'No'`. The amended query now correctly joins the frpm and schools tables to retrieve district codes and uses proper boolean logic for the magnet program indicator."
        ],
        "rules": [
            "1) When answering about district codes: select \"T1.District Code\" instead of district_code. 2) When combining frpm and schools tables: link rows where \"T1.CDSCode\" equals \"T2.CDSCode\" exactly and keep only matching pairs (inner match). 3) When filtering for city of Fresno: use \"T2.City = 'Fresno'\" with exact case and punctuation. 4) When filtering for schools without magnet programs: use \"T2.Magnet = 0\" instead of checking for 'No' text values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT district_code FROM schools WHERE city = 'Fresno' AND magnet_program = 'No';",
            "SELECT T1.\"District Code\" \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.City = 'Fresno' AND T2.Magnet = 0"
        ],
        "rule_sql": [
            "SELECT T1.\"District Code\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.City = 'Fresno' AND T2.Magnet = 0"
        ],
        "amend_res": 1
    },
    "884": {
        "db_id": "formula_1",
        "question": "List the names of all races that occurred in the earliest recorded year and month.",
        "ground_truth": "SELECT name FROM races WHERE STRFTIME('%Y', date) = ( SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1 ) AND STRFTIME('%m', date) = ( SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1 )",
        "amends": [
            "Do reference the `name` column instead of `race_name` in the SELECT list. Do use `STRFTIME('%Y', date)` instead of the `year` column for year extraction from the date field. Do use `STRFTIME('%m', date)` instead of the `month` column for month extraction from the date field. Do replace the subquery with `ORDER BY date ASC LIMIT 1` instead of using `MIN()` aggregates on separate year and month columns, which could return inconsistent results from different rows. Do ensure both year and month comparisons come from the same earliest race record instead of potentially different minimum values from separate aggregates. The amended query now correctly identifies races from the same earliest date record rather than potentially mixing the earliest year with the earliest month from different records."
        ],
        "rules": [
            "1) When the question asks for race names: use the exact column \"name\" from table \"races\" instead of \"race_name\". 2) When extracting year and month information from dates: use STRFTIME('%Y', date) for year and STRFTIME('%m', date) for month instead of separate year and month columns. 3) When finding the earliest recorded year and month: identify the single earliest date record using ORDER BY date ASC LIMIT 1 instead of separate MIN() aggregates on year and month to ensure consistency. 4) When comparing races to the earliest date: ensure both year and month comparisons come from the same earliest race record rather than potentially different minimum values from separate aggregates."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name FROM races WHERE year = (SELECT MIN(year) FROM races) AND month = (SELECT MIN(month) FROM races);",
            "SELECT name \nFROM races \nWHERE STRFTIME('%Y', date) = (SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1) \nAND STRFTIME('%m', date) = (SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1);"
        ],
        "rule_sql": [
            "SELECT name \nFROM races \nWHERE STRFTIME('%Y', date) = (SELECT STRFTIME('%Y', date) FROM races ORDER BY date ASC LIMIT 1) \nAND STRFTIME('%m', date) = (SELECT STRFTIME('%m', date) FROM races ORDER BY date ASC LIMIT 1);"
        ],
        "amend_res": 1
    },
    "340": {
        "db_id": "card_games",
        "question": "Which are the cards that have incredibly powerful foils.",
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
        "amends": [
            "Do select only `id` instead of all columns with `*`. Do add filters for `cardKingdomFoilId IS NOT NULL` and `cardKingdomId IS NOT NULL` instead of filtering on `foil_power > 1000`. Do remove the `ORDER BY foil_power DESC` clause instead of keeping it. The amended query now correctly selects card IDs where both Card Kingdom identifiers are present rather than filtering by an incorrect foil power threshold."
        ],
        "rules": [
            "1) When answering about \"cards that have incredibly powerful foils\": make sure the output order: id. 2) When selecting card identifiers: use \"id\" instead of all columns with \"*\". 3) When filtering for cards with foil versions: add conditions for \"cardKingdomFoilId IS NOT NULL\" and \"cardKingdomId IS NOT NULL\" instead of filtering on \"foil_power > 1000\". 4) When the question does not specify ordering: remove any ORDER BY clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE foil_power > 1000 ORDER BY foil_power DESC;",
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL"
        ],
        "amend_res": 1
    },
    "589": {
        "db_id": "codebase_community",
        "question": "Which user ID has the highest reputation?",
        "ground_truth": "SELECT Id FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users )",
        "amends": [
            "Do select `Id` instead of `user_id` and remove the `ORDER BY` and `LIMIT` clauses instead of keeping them. Do add a `WHERE` filter comparing `Reputation` to a subquery result instead of omitting it. Do use a correlated subquery with `MAX(Reputation)` to find the maximum reputation value instead of relying on ordering and limiting. The amended query now correctly identifies the user with the highest reputation by comparing against the maximum value rather than attempting to find it through sorting and limiting which could be unreliable for ties or edge cases."
        ],
        "rules": [
            "1) When answering about \"which user ID has the highest reputation\": select \"Id\" from the users table instead of \"user_id\". 2) When finding the maximum reputation value: use MAX(\"Reputation\") in a subquery to determine the highest reputation value. 3) When identifying the user with the highest reputation: use a WHERE filter comparing \"Reputation\" to the result of the MAX(\"Reputation\") subquery instead of using ORDER BY and LIMIT. 4) When handling potential ties in reputation values: use a correlated subquery approach that compares against the maximum value rather than relying on ordering which could be unreliable for ties."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT user_id FROM users ORDER BY reputation ASC LIMIT 1;",
            "SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "rule_sql": [
            "SELECT Id FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users);"
        ],
        "amend_res": 1
    },
    "8": {
        "db_id": "california_schools",
        "question": "What is the number of SAT test takers of the schools with the highest FRPM count for K-12 students?",
        "evidence": "",
        "ground_truth": "SELECT NumTstTakr FROM satscores WHERE cds = ( SELECT CDSCode FROM frpm ORDER BY `FRPM Count (K-12)` DESC LIMIT 1 )",
        "amends": [
            "Do select `NumTstTakr` instead of `COUNT(*) AS sat_takers`. Do query from `satscores` instead of `schools`. Do use a subquery that selects `CDSCode` from `frpm` ordered by `FRPM Count (K-12)` descending with `LIMIT 1` instead of comparing `frpm_count` to a maximum value from the same table. Do remove the `grade_level = 'K-12'` filter instead of keeping it. The amended query now correctly retrieves test taker counts by matching school codes with the highest FRPM count from the appropriate table."
        ],
        "rules": [
            "1) When answering about \"number of SAT test takers\": select \"NumTstTakr\" from table \"satscores\" instead of counting all rows. 2) When the question mentions \"schools with the highest FRPM count\": find the school with maximum \"FRPM Count (K-12)\" value from table \"frpm\" and get its \"CDSCode\" using descending order with limit 1. 3) When combining data from \"satscores\" and \"frpm\" tables: match rows where their \"CDSCode\" values are equal to identify the same school across tables. 4) When the question specifies \"K-12 students\": use the column \"FRPM Count (K-12)\" which already represents K-12 data, so no additional grade level filter is needed. 5) When producing output: return the exact \"NumTstTakr\" value for the school identified by the highest \"FRPM Count (K-12)\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS sat_takers\nFROM schools\nWHERE frpm_count = (SELECT MAX(frpm_count) FROM schools)\nAND grade_level = 'K-12';",
            "SELECT NumTstTakr \nFROM satscores \nWHERE cds = (\n    SELECT CDSCode \n    FROM frpm \n    ORDER BY \"FRPM Count (K-12)\" DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT s.NumTstTakr \nFROM satscores s\nJOIN frpm f ON s.cds = f.CDSCode\nWHERE f.CDSCode = (\n    SELECT CDSCode \n    FROM frpm \n    ORDER BY \"FRPM Count (K-12)\" DESC \n    LIMIT 1\n)"
        ],
        "amend_res": 1
    },
    "660": {
        "db_id": "codebase_community",
        "question": "What is the owner user id of the most valuable post?",
        "ground_truth": "SELECT OwnerUserId FROM posts WHERE FavoriteCount = ( SELECT MAX(FavoriteCount) FROM posts )",
        "amends": [
            "Do select `OwnerUserId` instead of `user_id` from the `posts` table. Do add a `WHERE` filter comparing `FavoriteCount` to a subquery instead of ordering by `value` and limiting. Do use a correlated subquery with `MAX(FavoriteCount)` to find the maximum value instead of relying on `ORDER BY` and `LIMIT 1`. Do remove the `ORDER BY` and `LIMIT` clauses entirely instead of keeping them. The amended query now correctly identifies the user with the maximum favorite count by using a subquery comparison instead of an ordering approach that might not handle ties properly."
        ],
        "rules": [
            "1) When the question asks for \"owner user id\": select \"OwnerUserId\" from the \"posts\" table instead of \"user_id\". 2) When the question asks for the \"most valuable post\" based on \"FavoriteCount\": use a subquery with MAX(\"FavoriteCount\") to find the maximum value instead of ordering by \"value\". 3) When identifying the most valuable post: use a WHERE filter comparing \"FavoriteCount\" to the maximum value from the subquery instead of using ORDER BY and LIMIT 1. 4) When handling ties for maximum \"FavoriteCount\": the correlated subquery approach ensures all posts with the maximum favorite count are considered, not just one arbitrary row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT user_id FROM posts ORDER BY value DESC LIMIT 1;",
            "SELECT OwnerUserId FROM posts WHERE FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts);"
        ],
        "rule_sql": [
            "SELECT OwnerUserId FROM posts WHERE FavoriteCount = (SELECT MAX(FavoriteCount) FROM posts);"
        ],
        "amend_res": 1
    },
    "1190": {
        "db_id": "thrombosis_prediction",
        "question": "What percentage of patients with a proteinuria level within the normal range have a uric acid level below the normal range?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE `U-PRO` > 0 AND `U-PRO` < 30",
        "amends": [
            "Do use `SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN uric_acid < normal_range_min THEN 1 END)` to count cases meeting the condition. Do reference table `Laboratory` instead of `patients` as the data source. Do filter with `U-PRO > 0 AND U-PRO < 30` instead of `proteinuria BETWEEN normal_range_min AND normal_range_max` for the proteinuria range condition. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(ID)` instead of `* 100.0 / COUNT(*)` with explicit casting to real numbers. Do remove the column alias `percentage` instead of keeping it. The amended query now correctly calculates the percentage of patients with UA \u2264 6.5 among those with U-PRO between 0 and 30, matching the intended behavior.",
            "Do use backticks around the column name `U-PRO` in the WHERE clause instead of using the unquoted identifier U-PRO, which would cause a syntax error due to the hyphen character. The amended query now properly handles the special character in the column name by enclosing it in backticks, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about percentage of patients with specific laboratory values: use table \"Laboratory\" as the data source instead of \"patients\". 2) When counting patients with uric acid level below normal range: use SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN uric_acid < normal_range_min THEN 1 END). 3) When filtering for proteinuria within normal range: use condition U-PRO > 0 AND U-PRO < 30 instead of proteinuria BETWEEN normal_range_min AND normal_range_max. 4) When calculating percentage: use CAST(... AS REAL) * 100 / COUNT(ID) with explicit casting to real numbers instead of * 100.0 / COUNT(*). 5) When producing final output: remove the column alias \"percentage\" instead of keeping it.",
            "1) When the question mentions \"proteinuria level within the normal range\": \"U-PRO > 0 AND U-PRO < 30\" represents the condition for proteinuria being within normal range. 2) When the question mentions \"uric acid level below the normal range\": \"UA <= 6.5\" represents the condition for uric acid being below normal range. 3) When the question asks for a percentage of patients: compute (number of patients with UA <= 6.5) divided by (total number of patients with U-PRO > 0 AND U-PRO < 30) multiplied by 100. 4) When handling column names with special characters like hyphens: enclose the column name `U-PRO` in backticks to avoid syntax errors. 5) When counting patients: use the canonical key \"ID\" to count individual patients rather than counting all rows."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN uric_acid < normal_range_min THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM patients\nWHERE proteinuria BETWEEN normal_range_min AND normal_range_max;",
            "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Laboratory WHERE U-PRO > 0 AND U-PRO < 30;",
            "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) \nFROM Laboratory \nWHERE `U-PRO` > 0 AND `U-PRO` < 30;"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT ID) \nFROM Laboratory \nWHERE `U-PRO` > 0 AND `U-PRO` < 30;"
        ],
        "amend_res": 1
    },
    "1051": {
        "db_id": "european_football_2",
        "question": "List all the football player with the highest potential score.",
        "ground_truth": "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes) ",
        "amends": [
            "Do select `DISTINCT(t1.player_name)` instead of `*` to return only unique player names rather than all columns. Do use `FROM Player AS t1 INNER JOIN Player_Attributes AS t2` instead of `FROM players` to join two tables rather than querying a single table. Do specify the join condition `ON t1.player_api_id = t2.player_api_id` instead of omitting it to properly relate the tables. Do filter with `WHERE t2.potential` instead of `WHERE potential` to reference the correct table's column. Do keep the subquery `(SELECT MAX(potential) FROM Player_Attributes)` but change it to reference `Player_Attributes` instead of `players` to match the joined table structure. Do remove `ORDER BY potential DESC` instead of keeping it since ordering is unnecessary when selecting distinct values for maximum potential. The amended query now correctly identifies players with maximum potential by joining the proper tables and referencing the correct columns."
        ],
        "rules": [
            "1) When answering about \"football player with the highest potential score\": make sure the output order: t1.player_name\n2) When the question mentions \"football player\": \"football player\" actually means \"t1.player_name in schema\"\n3) When the question mentions \"highest potential score\": \"highest potential score\" actually means \"t2.potential in schema\"\n4) When combining T1 and T2 for shared entities: link rows where t1.player_api_id = t2.player_api_id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"highest potential\": filter rows where t2.potential equals the maximum value from Player_Attributes table\n6) When selecting output: return only distinct t1.player_name values instead of all columns to avoid duplicate player names"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM players WHERE potential = (SELECT MAX(potential) FROM players) ORDER BY potential DESC;",
            "SELECT DISTINCT(t1.player_name) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.potential = (SELECT MAX(potential) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT DISTINCT p.player_name\nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE pa.potential = (SELECT MAX(potential) FROM Player_Attributes)\nORDER BY p.player_name;"
        ],
        "amend_res": 1
    },
    "783": {
        "db_id": "superhero",
        "question": "Provide the eye colours of the heroes whose skin colours are gold.",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T3.colour = 'Gold'",
        "amends": [
            "Do select `T2.colour` from the `colour` table instead of `eye_color` from the `heroes` table. Do join `superhero AS T1` with `colour AS T2` on `T1.eye_colour_id = T2.id` instead of querying a single table. Do add an additional join to `colour AS T3` on `T1.skin_colour_id = T3.id` instead of directly filtering on skin color. Do filter on `T3.colour = 'Gold'` with proper case sensitivity instead of `skin_color = 'gold'` with lowercase. The amended query now correctly retrieves eye colors by joining through proper relationship tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"eye colours of heroes\": select T2.colour from the colour table instead of eye_color from the heroes table. 2) When combining superhero table T1 with colour table T2: link rows where T1.eye_colour_id = T2.id and keep only matching pairs. 3) When combining superhero table T1 with colour table T3: link rows where T1.skin_colour_id = T3.id and keep only matching pairs. 4) When filtering for heroes with skin colour gold: filter on T3.colour = 'Gold' with exact case sensitivity instead of 'gold' with lowercase."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM heroes WHERE skin_color = 'gold';",
            "SELECT T2.colour \nFROM superhero AS T1\nJOIN colour AS T2 ON T1.eye_colour_id = T2.id\nJOIN colour AS T3 ON T1.skin_colour_id = T3.id\nWHERE T3.colour = 'Gold'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.colour \nFROM superhero T1\nJOIN colour T2 ON T1.eye_colour_id = T2.id\nJOIN colour T3 ON T1.skin_colour_id = T3.id\nWHERE T3.colour = 'Gold';"
        ],
        "amend_res": 1
    },
    "161": {
        "db_id": "financial",
        "question": "What type of credit card does the client with the id 13539 own?",
        "evidence": "",
        "ground_truth": "SELECT T3.type FROM disp AS T1 INNER JOIN client AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T1.disp_id = T3.disp_id WHERE T2.client_id = 13539",
        "amends": [
            "Do select `T3.type` instead of `credit_card_type` and do add joins to `disp AS T1`, `client AS T2`, and `card AS T3` instead of querying only the `clients` table. Do use `INNER JOIN` on `T1.client_id = T2.client_id` and `INNER JOIN` on `T1.disp_id = T3.disp_id` instead of no joins. Do keep the filter `T2.client_id = 13539` instead of `client_id = 13539` but move it to the correct table context. The amended query now correctly retrieves credit card type through the proper table relationships and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about credit card type for a specific client: make sure the output order: T3.type 2) When the question mentions \"client with id 13539\": \"client_id\" actually means \"T2.client_id\" in schema with value 13539 3) When combining tables for client information: link rows where T1.client_id = T2.client_id and T1.disp_id = T3.disp_id using inner matches only 4) When selecting from multiple tables: use tables disp AS T1, client AS T2, and card AS T3 instead of querying only clients table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT credit_card_type FROM clients WHERE client_id = 13539;",
            "SELECT T3.type \nFROM disp AS T1\nINNER JOIN client AS T2 ON T1.client_id = T2.client_id\nINNER JOIN card AS T3 ON T1.disp_id = T3.disp_id\nWHERE T2.client_id = 13539"
        ],
        "rule_sql": [
            "SELECT T3.type \nFROM disp AS T1 \nINNER JOIN client AS T2 ON T1.client_id = T2.client_id \nINNER JOIN card AS T3 ON T1.disp_id = T3.disp_id \nWHERE T2.client_id = 13539"
        ],
        "amend_res": 1
    },
    "520": {
        "db_id": "card_games",
        "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
        "ground_truth": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
        "amends": [
            "Do select `artist` and `format` columns instead of `illustrator`, `card_count`, and `format_of_play`. Do use `INNER JOIN` with `legalities` table on `uuid = uuid` instead of querying only the `cards` table. Do group by `artist` instead of `illustrator`. Do order by `COUNT(id)` instead of the alias `card_count`. Do remove the incorrect `format_of_play` column reference and add the proper join to access format data from the legalities table. The amended query now correctly joins related data and uses proper column references to match the intended behavior.",
            "Do remove the WHERE clause with its correlated subquery instead of keeping it, and do move the ORDER BY COUNT(id) ASC LIMIT 1 to the main query level instead of having it in a subquery. Do change the GROUP BY clause to only include T1.artist instead of grouping by both c.artist and l.format, and do add proper table aliases T1 and T2 instead of using c and l. Do fix the join condition to T2.uuid = T1.uuid instead of c.uuid = l.uuid, maintaining the same logical relationship. The amended query now correctly returns the artist with the fewest cards along with their formats, matching the RIGHT_SQL's behavior.",
            "Do remove `T2.format` from the SELECT list and GROUP BY clause instead of including it, as the query should only return artist information. Do change the GROUP BY to only `T1.artist` instead of grouping by both `T1.artist` and `T2.format`. Do add an `ORDER BY COUNT(T1.id) ASC` clause instead of omitting it, to order results by the count of card IDs. Do move the subquery filter from the WHERE clause to the main query's ORDER BY and LIMIT instead of using a correlated subquery, as the original approach incorrectly filtered results before aggregation. Do keep the `LIMIT 1` in the main query instead of placing it in a subquery, to correctly return only the artist with the fewest cards. The amended query now correctly identifies the artist with the fewest cards while maintaining proper join relationships.",
            "Do add `T2.format` to the SELECT list instead of omitting it, and do add `T2.format` to the GROUP BY clause instead of grouping only by `T1.artist`. The amended query now correctly includes the format column from the legalities table in both the selection and grouping, ensuring proper aggregation behavior that matches the RIGHT_SQL's logic.",
            "Do group by only `T1.artist` instead of grouping by both `T1.artist` and `T2.format`, as the format column is not aggregated and should be handled differently in the grouping logic. The amended query now correctly matches RIGHT_SQL's behavior by fixing the GROUP BY clause to properly aggregate the data."
        ],
        "rules": [
            "1) When the question asks about \"illustrator\": use the exact column token \"artist\" from the cards table instead. 2) When counting cards illustrated by an artist: count using the canonical key \"id\" from the cards table (COUNT(id)) rather than counting all columns. 3) When combining card and legality information: perform an inner join between cards table (T1) and legalities table (T2) where T1.uuid = T2.uuid to match related data. 4) When accessing format of play information: retrieve the \"format\" column from the legalities table (T2) rather than from the cards table. 5) When grouping results by artist: group by the \"artist\" column from the cards table. 6) When finding the illustrator with the least amount of cards: order by the count of cards (COUNT(id)) in ascending order and take only the first result.",
            "1) When finding the illustrator with the least amount of cards: rank artists by the count of their cards in ascending order and keep only the first artist (lowest count). 2) When combining cards and legalities tables: link rows where T2.uuid = T1.uuid exactly and keep only matching pairs (inner match). 3) When the question asks for the format of play of cards: include T2.format in the output columns. 4) When organizing results for the artist with fewest cards: group by T1.artist only, not by format. 5) When answering about the illustrator and their card formats: make sure the output order includes T1.artist and T2.format.",
            "1) When answering about \"the illustrator that illustrated the least amount of cards\": rank artists by the count of cards they illustrated in ascending order and keep only the top 1 artist. 2) When counting cards per artist: use T1.id as the counting key to determine how many cards each artist illustrated. 3) When the question asks for format of play information: do not include T2.format in the output columns since the question only asks for the illustrator, not the card formats. 4) When grouping results by artist: group only by T1.artist without including additional grouping columns. 5) When ordering results by card count: use ORDER BY COUNT(T1.id) ASC to sort artists from fewest to most cards illustrated.",
            "1) When answering about \"the illustrator that illustrated the least amount of cards\": count the number of cards using T1.id as the counting key for each T1.artist, then rank artists by this count in ascending order and keep the first 1 row. 2) When the question asks to \"list the format of play of the cards that he/she illustrated\": include T2.format in the output columns and group by both T1.artist and T2.format to ensure proper aggregation. 3) When combining cards T1 and legalities T2: link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match).",
            "1) When counting the number of cards illustrated by each artist: count using the canonical key T1.id for cards. 2) When grouping by artist to find who illustrated the least amount of cards: group only by T1.artist without including T2.format in the grouping. 3) When the question asks for the format of play of cards illustrated by the artist with the least illustrations: include T2.format in the output columns but do not aggregate or group by it. 4) When ordering results to find the illustrator with the least amount of cards: order by the count of T1.id in ascending order and take only the first result."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT illustrator, COUNT(*) as card_count, format_of_play \nFROM cards \nGROUP BY illustrator \nORDER BY card_count ASC \nLIMIT 1;",
            "SELECT c.artist, l.format\nFROM cards c\nINNER JOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = (\n    SELECT artist\n    FROM cards\n    GROUP BY artist\n    ORDER BY COUNT(id) ASC\n    LIMIT 1\n)\nGROUP BY c.artist, l.format;",
            "SELECT T1.artist, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.artist = (\n    SELECT artist\n    FROM cards\n    GROUP BY artist\n    ORDER BY COUNT(id) ASC\n    LIMIT 1\n)\nGROUP BY T1.artist, T2.format",
            "SELECT T1.artist\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nGROUP BY T1.artist\nORDER BY COUNT(T1.id) ASC\nLIMIT 1;",
            "SELECT T1.artist, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nGROUP BY T1.artist, T2.format\nORDER BY COUNT(T1.id) ASC\nLIMIT 1",
            "SELECT T1.artist, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nGROUP BY T1.artist\nORDER BY COUNT(T1.id) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT c.artist, l.format\nFROM cards c\nINNER JOIN legalities l ON c.uuid = l.uuid\nWHERE c.artist = (\n    SELECT c2.artist\n    FROM cards c2\n    GROUP BY c2.artist\n    ORDER BY COUNT(c2.id) ASC\n    LIMIT 1\n)\nGROUP BY c.artist, l.format"
        ],
        "amend_res": 1
    },
    "1230": {
        "db_id": "thrombosis_prediction",
        "question": "List all outpatient within normal range of creatinine phosphokinase. Give me the distinct ids.",
        "ground_truth": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CPK < 250 AND T1.Admission = '-'",
        "amends": [
            "Do add `Laboratory` table with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do change the filter to `T2.CPK < 250` instead of `creatinine_phosphokinase = 'normal'`. Do add an additional filter `T1.Admission = '-'` instead of omitting it. Do reference `T1.ID` with table alias instead of just `id`. The amended query now correctly joins patient and laboratory data to filter based on CPK values and admission status, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"outpatient within normal range of creatinine phosphokinase\": make sure to combine data from both patients and laboratory tables using an inner match where T1.ID = T2.ID. 2) When the question mentions \"outpatient\": this actually means T1.Admission = '-' in the schema. 3) When the question mentions \"normal range of creatinine phosphokinase\": this actually means T2.CPK < 250 in the schema. 4) When the question asks for \"distinct ids\": compute the number of unique values of T1.ID. 5) When producing output: return only T1.ID values in the results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT id FROM patients WHERE creatinine_phosphokinase = 'normal'",
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.CPK < 250\nAND T1.Admission = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Admission = '-' AND T2.CPK < 250"
        ],
        "amend_res": 1
    },
    "692": {
        "db_id": "codebase_community",
        "question": "How long did it take the user, known by his or her display name 'Zolomon' to get the badge? Count from the date the user's account was created.",
        "ground_truth": "SELECT T1.Date - T2.CreationDate FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'",
        "amends": [
            "Do use direct date subtraction `T1.Date - T2.CreationDate` instead of `julianday()` conversion functions. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do use table aliases `T1` and `T2` instead of full table names throughout the query. Do reference `T1.UserId = T2.Id` in the join condition instead of `u.Id = b.UserId`. Do remove the `LIMIT 1` clause instead of keeping it, as the query logic should return all matching records rather than just one. The amended query now correctly calculates date differences without unnecessary function conversions and returns all relevant results for the specified user."
        ],
        "rules": [
            "1) When the question asks about time duration between a user's account creation and badge date: calculate the difference using direct date subtraction T1.Date - T2.CreationDate instead of date conversion functions. 2) When joining the Users and Badges tables: use INNER JOIN explicitly and link rows where T1.UserId = T2.Id. 3) When filtering for a specific user by display name: use the exact literal 'Zolomon' with the correct case and quotes. 4) When the question asks for all matching records: do not apply any row limiting clauses like LIMIT 1. 5) When using table aliases throughout the query: refer to Badges as T1 and Users as T2 consistently."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT julianday(b.Date) - julianday(u.CreationDate) AS days_to_badge\nFROM Users u\nJOIN Badges b ON u.Id = b.UserId\nWHERE u.DisplayName = 'Zolomon'\nLIMIT 1;",
            "SELECT T1.Date - T2.CreationDate AS TimeToBadge\nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T2.DisplayName = 'Zolomon'"
        ],
        "rule_sql": [
            "SELECT T1.Date - T2.CreationDate AS TimeToBadge FROM badges T1 INNER JOIN users T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'"
        ],
        "amend_res": 1
    },
    "969": {
        "db_id": "formula_1",
        "question": "How many British drivers who were born in 1980?",
        "ground_truth": "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'",
        "amends": [
            "Do count `driverId` instead of `*` to exclude null values. Do use `STRFTIME('%Y', dob)` instead of `year(birth_date)` for proper SQLite date extraction. Do reference column `dob` instead of `birth_date` to match the actual schema. The amended query now correctly counts British drivers born in 1980 using the appropriate date function and column name."
        ],
        "rules": [
            "1) When counting drivers: use \"driverId\" as the counting key instead of \"*\" to exclude null values. 2) When extracting year from date of birth: use STRFTIME('%Y', dob) instead of year(birth_date) for proper SQLite date extraction. 3) When referencing date of birth column: use \"dob\" instead of \"birth_date\" to match the actual schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND year(birth_date) = 1980;",
            "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'"
        ],
        "rule_sql": [
            "SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND STRFTIME('%Y', dob) = '1980'"
        ],
        "amend_res": 1
    },
    "615": {
        "db_id": "codebase_community",
        "question": "Among the users who obtained the \"Organizer\" badges, calculate the percentage of users who are teenagers.",
        "ground_truth": "SELECT CAST(SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) AS REAL) * 100 / COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.`Name` = 'Organizer'",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` instead of `COUNT(CASE WHEN condition THEN 1 END)` for conditional counting. Do specify the age range as `BETWEEN 13 AND 18` instead of `BETWEEN 13 AND 19` to correctly identify teenagers. Do cast the sum to `REAL` instead of using `100.0` for proper floating-point division. Do reference the join condition as `T1.UserId = T2.Id` instead of `u.id = b.user_id` with corrected table aliases. Do filter on `T1.Name = 'Organizer'` instead of `b.name = 'Organizer'` with proper table reference. Do calculate the percentage as `SUM(...) * 100 / COUNT(...)` instead of `COUNT(...) * 100.0 / COUNT(*)` for accurate computation. The amended query now correctly calculates the percentage of teenage organizers using proper age boundaries and mathematical operations."
        ],
        "rules": [
            "1) When calculating percentages of users who are teenagers: use age range BETWEEN 13 AND 18 instead of 13 AND 19 to correctly identify teenagers. 2) When performing conditional counting: use SUM(IIF(condition, 1, 0)) instead of COUNT(CASE WHEN condition THEN 1 END). 3) When calculating percentages with division: cast the sum to REAL instead of using 100.0 for proper floating-point division. 4) When joining users and badges tables: use join condition T1.UserId = T2.Id with proper table aliases. 5) When filtering for \"Organizer\" badges: use T1.Name = 'Organizer' with proper table reference. 6) When calculating percentage formulas: use SUM(...) * 100 / COUNT(...) instead of COUNT(...) * 100.0 / COUNT(*) for accurate computation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.age BETWEEN 13 AND 19 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_teenagers\nFROM users u\nJOIN badges b ON u.id = b.user_id\nWHERE b.name = 'Organizer'",
            "SELECT \n    (SUM(IIF(T2.Age BETWEEN 13 AND 18, 1, 0)) * 100.0 / COUNT(*)) AS Percentage\nFROM \n    badges T1\nJOIN \n    users T2 ON T1.UserId = T2.Id\nWHERE \n    T1.Name = 'Organizer';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(IIF(u.Age BETWEEN 13 AND 18, 1, 0)) * 100.0 / COUNT(*)) AS percentage_teenagers\nFROM \n    badges b\nJOIN \n    users u ON b.UserId = u.Id\nWHERE \n    b.Name = 'Organizer';"
        ],
        "amend_res": 1
    },
    "414": {
        "db_id": "card_games",
        "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
        "amends": [
            "Do select `T2.language` from the `set_translations` table instead of `language` from the `cards` table. Do join `sets AS T1` and `set_translations AS T2` with an `INNER JOIN` on `T1.code = T2.setCode` instead of querying only the `cards` table. Do filter on `T1.block = 'Ravnica'` instead of `block = 'Ravnica'` and use `T1.baseSetSize = 180` instead of `card_count = 180`. The amended query now correctly retrieves language information from the appropriate translation table joined with sets data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about language translations for card sets: select T2.language from the set_translations table instead of language from the cards table. 2) When combining sets and set_translations tables: link rows where T1.code = T2.setCode and keep only matching pairs (inner match). 3) When filtering for the Ravnica block: use T1.block = 'Ravnica' with exact case and quotes. 4) When filtering for sets with 180 cards: use T1.baseSetSize = 180 instead of card_count = 180."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM cards WHERE block = 'Ravnica' AND card_count = 180;",
            "SELECT T2.language \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode \nWHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180;"
        ],
        "rule_sql": [
            "SELECT T2.language \nFROM sets T1 \nINNER JOIN set_translations T2 ON T1.code = T2.setCode \nWHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180;"
        ],
        "amend_res": 1
    },
    "375": {
        "db_id": "card_games",
        "question": "List down all the card IDs with converted mana cost of 0.",
        "ground_truth": "SELECT id FROM cards WHERE convertedManaCost = 0",
        "amends": [
            "Do reference column `id` instead of `card_id` in the SELECT list. Do use column name `convertedManaCost` instead of `converted_mana_cost` in the WHERE filter. The amended query now correctly retrieves card identifiers using the proper column names and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"card IDs\": use the exact column name \"id\" from the cards table to select the card identifiers. 2) When filtering for cards with converted mana cost of 0: use the exact column name \"convertedManaCost\" and the literal value 0.0 to match cards with zero converted mana cost."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id FROM cards WHERE converted_mana_cost = 0;",
            "SELECT id FROM cards WHERE convertedManaCost = 0;"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE convertedManaCost = 0.0"
        ],
        "amend_res": 1
    },
    "1416": {
        "db_id": "student_club",
        "question": "How many members of Business have the Medium size of tee shirt?",
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Business' AND T2.t_shirt_size = 'Medium'",
        "amends": [
            "Do select `COUNT(T2.member_id)` from specific columns instead of `COUNT(*)` from all rows. Do join `major AS T1` and `member AS T2` with an `INNER JOIN` on `T1.major_id = T2.link_to_major` instead of querying only the `Business` table. Do filter on `T1.major_name = 'Business'` and `T2.t_shirt_size = 'Medium'` in the WHERE clause instead of filtering only on `tee_shirt_size = 'Medium'` without proper table context. The amended query now correctly counts business major members with medium t-shirt sizes by properly joining the relevant tables and filtering on the appropriate conditions."
        ],
        "rules": [
            "1) When answering about \"members of Business\": join table \"major AS T1\" and table \"member AS T2\" where T1.major_id equals T2.link_to_major to connect members to their majors. 2) When filtering for Business major: use condition T1.major_name = 'Business' exactly as specified. 3) When filtering for Medium t-shirt size: use condition T2.t_shirt_size = 'Medium' exactly as specified. 4) When counting members: count using T2.member_id as the canonical key instead of counting all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Business WHERE tee_shirt_size = 'Medium';",
            "SELECT COUNT(T2.member_id) \nFROM major AS T1 \nINNER JOIN member AS T2 ON T1.major_id = T2.link_to_major \nWHERE T1.major_name = 'Business' AND T2.t_shirt_size = 'Medium'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.member_id) \nFROM major AS T1 \nJOIN member AS T2 ON T1.major_id = T2.link_to_major \nWHERE T1.major_name = 'Business' \nAND T2.t_shirt_size = 'Medium'"
        ],
        "amend_res": 1
    },
    "1405": {
        "db_id": "student_club",
        "question": "Calculate the amount budgeted for 'April Speaker' event. List all the budgeted categories for said event in an ascending order based on their amount budgeted.",
        "ground_truth": "SELECT T2.category, SUM(T2.amount) FROM event AS T1 JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'April Speaker' GROUP BY T2.category ORDER BY SUM(T2.amount) ASC",
        "amends": [
            "Do join `event AS T1` with `budget AS T2` on `T1.event_id = T2.link_to_event` instead of querying only `event_budgets` table. Do use `SUM(T2.amount)` aggregate function instead of selecting raw `amount`. Do add `GROUP BY T2.category` instead of omitting grouping. Do change sort order to `ASC` instead of `DESC` on the aggregated amount. Do filter on `T1.event_name = 'April Speaker'` instead of filtering directly on event_budgets. The amended query now correctly calculates total budget amounts per category for the specified event."
        ],
        "rules": [
            "1) When answering about budgeted categories for 'April Speaker' event: join table \"event\" as T1 with table \"budget\" as T2 on T1.event_id = T2.link_to_event using inner match. 2) When filtering for specific event: use condition T1.event_name = 'April Speaker' exactly as written. 3) When calculating budget amounts per category: use SUM(T2.amount) aggregate function instead of raw amount values. 4) When grouping results by category: use GROUP BY T2.category to organize results by budget category. 5) When ordering results by amount budgeted: sort in ascending order (ASC) on the aggregated SUM(T2.amount) values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT category, amount FROM event_budgets WHERE event_name = 'April Speaker' ORDER BY amount DESC;",
            "SELECT T2.category, SUM(T2.amount) AS total_budgeted\nFROM event AS T1\nJOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'April Speaker'\nGROUP BY T2.category\nORDER BY total_budgeted ASC;"
        ],
        "rule_sql": [
            "SELECT T2.category, SUM(T2.amount) AS amount_budgeted\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nWHERE T1.event_name = 'April Speaker'\nGROUP BY T2.category\nORDER BY amount_budgeted ASC;"
        ],
        "amend_res": 1
    },
    "955": {
        "db_id": "formula_1",
        "question": "What is the average time in seconds of champion for each year, before year 1975?",
        "ground_truth": "WITH time_in_seconds AS ( SELECT T2.year, T2.raceId, T1.positionOrder, CASE WHEN T1.positionOrder = 1 THEN (CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600) + (CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60) + CAST(SUBSTR(T1.time, 6,2) AS REAL )   + CAST(SUBSTR(T1.time, 9) AS REAL)/1000 ELSE 0 END AS time_seconds FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL ), champion_time AS ( SELECT year, raceId, time_seconds FROM time_in_seconds WHERE positionOrder = 1 ) SELECT year, AVG(time_seconds) FROM champion_time WHERE year < 1975 GROUP BY year HAVING AVG(time_seconds) IS NOT NULL",
        "amends": [
            "Do use a CTE structure with `time_in_seconds` and `champion_time` instead of directly querying a `champions` table. Do add table joins with `INNER JOIN races AS T2 ON T1.raceId = T2.raceId` instead of missing source tables. Do calculate time conversion using `CASE WHEN T1.positionOrder = 1 THEN` with substring parsing instead of assuming pre-calculated `time_seconds`. Do filter for winning positions with `WHERE positionOrder = 1` instead of missing this condition. Do add `HAVING AVG(time_seconds) IS NOT NULL` to exclude null averages instead of omitting this filter. Do remove the alias `as avg_time` from the final SELECT instead of keeping it. The amended query now correctly calculates average winning times from raw race data instead of relying on pre-aggregated data.",
            "Do include `T2.raceId` and `T1.positionOrder` in the SELECT list instead of omitting them. Do change the time parsing logic to use fixed position `SUBSTR` operations with specific offsets instead of dynamic `instr`-based parsing. Do add `T1.time IS NOT NULL` filter in the WHERE clause instead of omitting it. Do remove the `T1.positionOrder = 1` filter from the initial WHERE clause and instead filter by `positionOrder = 1` in the champion_time CTE. Do move the `year < 1975` filter from the initial CTE to the final SELECT's WHERE clause instead of applying it earlier. Do restructure the final query to calculate `AVG(time_seconds)` directly in the main SELECT instead of pre-aggregating in a CTE. The amended query now correctly handles time parsing with fixed positions and restructures the filtering logic to properly calculate average champion times for years before 1975.",
            "Do use `CASE WHEN T1.positionOrder = 1 THEN` instead of `CASE WHEN T1.positionOrder = 1 AND T1.time IS NOT NULL THEN` to remove the redundant time check. Do change the time parsing to `SUBSTR(T1.time, 1, 1)` for hours instead of `SUBSTR(T1.time, 1, 2)` to handle single-digit hour formats. Do use `SUBSTR(T1.time, 3, 2)` for minutes instead of `SUBSTR(T1.time, 4, 2)` to account for the changed hour position. Do use `SUBSTR(T1.time, 6, 2)` for seconds instead of `SUBSTR(T1.time, 7)` to properly extract two-digit seconds. Do add `+ CAST(SUBSTR(T1.time, 9) AS REAL)/1000` to include milliseconds instead of omitting them. Do use `ELSE 0` instead of `ELSE NULL` to provide a default value for non-winning positions. Do remove the explicit `T1.time` column from the SELECT list instead of including it. The amended query now correctly handles time parsing with milliseconds and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"average time in seconds of champion for each year\": make sure the output order: year, average time in seconds. 2) When the question mentions \"champion\": \"champion\" actually means \"positionOrder = 1\" in the schema. 3) When the question mentions \"time in seconds\": calculate time conversion using CASE WHEN T1.positionOrder = 1 THEN with substring parsing instead of assuming pre-calculated time_seconds. 4) When combining T1 and T2 for shared entities: link rows where T1.raceId = T2.raceId exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"before year 1975\": filter for year < 1975. 6) When the question says \"for each year\": organize results by year and compute average time per year. 7) When computing averages: exclude null averages by adding HAVING AVG(time_seconds) IS NOT NULL. 8) When producing output: do not use aliases like \"as avg_time\" in the final SELECT.",
            "1) When parsing time values from \"T1.time\": use fixed position SUBSTR operations with specific offsets instead of dynamic instr-based parsing. 2) When filtering for champion results: filter by \"T1.positionOrder = 1\" in the aggregation phase instead of the initial data extraction phase. 3) When handling time data: include \"T1.time IS NOT NULL\" filter to exclude null time values. 4) When filtering by year: apply \"T2.year < 1975\" filter in the final query instead of in intermediate CTEs. 5) When calculating average champion time: compute AVG(time_seconds) directly in the main SELECT instead of pre-aggregating in a CTE. 6) When selecting columns: include both \"T2.raceId\" and \"T1.positionOrder\" in the SELECT list instead of omitting them.",
            "1) When parsing time values in format 'H:MM:SS.mmm': extract hours using SUBSTR(T1.time, 1, 1) for single-digit hours, minutes using SUBSTR(T1.time, 3, 2), seconds using SUBSTR(T1.time, 6, 2), and milliseconds using SUBSTR(T1.time, 9) divided by 1000. 2) When calculating time in seconds for champion positions: use CASE WHEN T1.positionOrder = 1 THEN to convert time format to seconds, not including redundant time IS NOT NULL checks. 3) When handling non-winning positions: provide a default value of 0 instead of NULL for time_seconds calculation. 4) When selecting columns for time calculation: do not include the raw T1.time column in the output, only include the calculated time_seconds. 5) When the question asks for average time of champions per year before 1975: group results by year and compute average of time_seconds where year < 1975, filtering out NULL averages."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT year, AVG(time_seconds) as avg_time FROM champions WHERE year < 1975 GROUP BY year;",
            "WITH time_in_seconds AS (\n    SELECT \n        T2.year,\n        T1.raceId,\n        CASE \n            WHEN T1.time LIKE '%:%:%' THEN \n                (CAST(substr(T1.time, 1, instr(T1.time, ':') - 1) AS REAL) * 3600) + \n                (CAST(substr(T1.time, instr(T1.time, ':') + 1, instr(substr(T1.time, instr(T1.time, ':') + 1), ':') - 1) AS REAL) * 60) + \n                CAST(substr(T1.time, instr(T1.time, ':', instr(T1.time, ':') + 1) + 1) AS REAL)\n            WHEN T1.time LIKE '%:%' THEN \n                (CAST(substr(T1.time, 1, instr(T1.time, ':') - 1) AS REAL) * 60) + \n                CAST(substr(T1.time, instr(T1.time, ':') + 1) AS REAL)\n            ELSE CAST(T1.time AS REAL)\n        END AS time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T1.positionOrder = 1\n    AND T2.year < 1975\n),\nchampion_time AS (\n    SELECT \n        year,\n        AVG(time_seconds) AS avg_champion_time\n    FROM time_in_seconds\n    GROUP BY year\n    HAVING AVG(time_seconds) IS NOT NULL\n)\nSELECT \n    year,\n    avg_champion_time\nFROM champion_time\nORDER BY year;",
            "WITH time_in_seconds AS (\n    SELECT \n        T2.year,\n        T2.raceId,\n        T1.positionOrder,\n        T1.time,\n        CASE \n            WHEN T1.positionOrder = 1 AND T1.time IS NOT NULL THEN\n                CAST(SUBSTR(T1.time, 1, 2) AS REAL) * 3600 + \n                CAST(SUBSTR(T1.time, 4, 2) AS REAL) * 60 + \n                CAST(SUBSTR(T1.time, 7) AS REAL)\n            ELSE NULL\n        END AS time_seconds\n    FROM results T1\n    INNER JOIN races T2 ON T1.raceId = T2.raceId\n    WHERE T1.time IS NOT NULL\n),\nchampion_time AS (\n    SELECT \n        year,\n        raceId,\n        time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n)\nSELECT \n    year,\n    AVG(time_seconds) \nFROM champion_time\nWHERE year < 1975\nGROUP BY year\nHAVING AVG(time_seconds) IS NOT NULL\nORDER BY year;",
            "WITH time_in_seconds AS (\n    SELECT \n        T2.year,\n        T2.raceId,\n        T1.positionOrder,\n        CASE WHEN T1.positionOrder = 1 THEN\n            CAST(SUBSTR(T1.time, 1, 1) AS REAL) * 3600 +\n            CAST(SUBSTR(T1.time, 3, 2) AS REAL) * 60 +\n            CAST(SUBSTR(T1.time, 6, 2) AS REAL) +\n            CAST(SUBSTR(T1.time, 9) AS REAL)/1000\n        ELSE 0\n        END AS time_seconds\n    FROM results AS T1\n    INNER JOIN races AS T2 ON T1.raceId = T2.raceId\n    WHERE T1.time IS NOT NULL\n),\nchampion_time AS (\n    SELECT \n        year,\n        time_seconds\n    FROM time_in_seconds\n    WHERE positionOrder = 1\n)\nSELECT \n    year,\n    AVG(time_seconds) \nFROM champion_time\nWHERE year < 1975\nGROUP BY year\nHAVING AVG(time_seconds) IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT \n    r.year,\n    AVG(\n        CASE WHEN res.positionOrder = 1 THEN \n            CAST(SUBSTR(res.time, 1, 1) AS REAL) * 3600 + \n            CAST(SUBSTR(res.time, 3, 2) AS REAL) * 60 + \n            CAST(SUBSTR(res.time, 6, 2) AS REAL) + \n            CAST(SUBSTR(res.time, 9) AS REAL) / 1000 \n        ELSE 0 \n        END\n    )\nFROM \n    results res\nJOIN \n    races r ON res.raceId = r.raceId\nWHERE \n    res.time IS NOT NULL \n    AND r.year < 1975\nGROUP BY \n    r.year\nHAVING \n    AVG(\n        CASE WHEN res.positionOrder = 1 THEN \n            CAST(SUBSTR(res.time, 1, 1) AS REAL) * 3600 + \n            CAST(SUBSTR(res.time, 3, 2) AS REAL) * 60 + \n            CAST(SUBSTR(res.time, 6, 2) AS REAL) + \n            CAST(SUBSTR(res.time, 9) AS REAL) / 1000 \n        ELSE 0 \n        END\n    ) IS NOT NULL\nORDER BY \n    r.year;"
        ],
        "amend_res": 1
    },
    "836": {
        "db_id": "superhero",
        "question": "What is the total number of superheroes that have John as their first name?",
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'",
        "amends": [
            "Do reference the `id` column instead of `*` in the COUNT function. Do use the correct table name `superhero` instead of `superheroes`. Do filter on the `full_name` column instead of `name` for the LIKE condition. The amended query now correctly counts superhero entries by ID from the proper table using the appropriate name field filter."
        ],
        "rules": [
            "1) When counting superhero entries: use the \"id\" column from the \"superhero\" table instead of counting all columns with *. 2) When filtering for superheroes with John as their first name: use the \"full_name\" column from the \"superhero\" table with a LIKE condition matching 'John%' instead of using a \"name\" column. 3) When referencing the superhero table: use the exact table name \"superhero\" instead of \"superheroes\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE name LIKE 'John%';",
            "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John %' OR full_name LIKE 'John%'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM superhero WHERE full_name LIKE 'John%'"
        ],
        "amend_res": 1
    },
    "775": {
        "db_id": "superhero",
        "question": "What is the percentage of blue female superheroes among all female superheroes?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.gender = 'Female'",
        "amends": [
            "Do join `superhero` with `gender` on `gender_id` and `colour` on `skin_colour_id` instead of querying only the `superheroes` table. Do filter for `T2.gender = 'Female'` in the `WHERE` clause instead of filtering within the `CASE` expressions. Do count `T1.id` for the denominator instead of using `CASE WHEN gender = 'Female' THEN 1 END`. Do reference `T3.colour = 'Blue'` instead of `eye_color = 'blue'` for the eye color condition. Do cast the count to `REAL` before multiplication instead of using `100.0` directly. Do use proper table aliases `T1`, `T2`, and `T3` instead of direct column references. The amended query now correctly calculates the percentage of female superheroes with blue eyes using proper joins and casting."
        ],
        "rules": [
            "1) When answering about percentage of blue female superheroes among all female superheroes: join table superhero (T1) with gender (T2) on T1.gender_id = T2.id and with colour (T3) on T1.skin_colour_id = T3.id. 2) When filtering for female superheroes: use condition T2.gender = 'Female' in the WHERE clause. 3) When counting female superheroes with blue eyes: use condition T3.colour = 'Blue' for the numerator. 4) When counting all female superheroes: count T1.id for the denominator instead of using CASE expressions. 5) When calculating the percentage: cast the count to REAL before multiplication with 100.0. 6) When combining tables: use proper table aliases T1 for superhero, T2 for gender, and T3 for colour."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN eye_color = 'blue' AND gender = 'Female' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN gender = 'Female' THEN 1 END)) AS percentage_blue_female\nFROM superheroes;",
            "SELECT \n    (COUNT(CASE WHEN T3.colour = 'Blue' THEN 1 END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    superhero T1\nJOIN \n    gender T2 ON T1.gender_id = T2.id\nJOIN \n    colour T3 ON T1.skin_colour_id = T3.id\nWHERE \n    T2.gender = 'Female'"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id END) * 100.0 / COUNT(T1.id)) AS percentage\nFROM \n    superhero T1\nJOIN \n    gender T2 ON T1.gender_id = T2.id\nJOIN \n    colour T3 ON T1.eye_colour_id = T3.id\nWHERE \n    T2.gender = 'Female';"
        ],
        "amend_res": 1
    },
    "781": {
        "db_id": "superhero",
        "question": "Provide the heights of the heroes whose eye colours are amber.",
        "ground_truth": "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'",
        "amends": [
            "Do reference `T1.height_cm` from the `superhero` table instead of `height` from an unspecified source. Do join `superhero AS T1` with `colour AS T2` using `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying a single table. Do filter on `T2.colour = 'Amber'` with proper case sensitivity instead of `eye_color = 'amber'` using a direct string comparison. The amended query now correctly joins tables to resolve eye color through a reference table and returns the height in centimeters with proper case matching."
        ],
        "rules": [
            "1) When answering about \"heights of heroes whose eye colours are amber\": make sure the output order: T1.height_cm\n2) When the question mentions \"eye colours are amber\": \"amber\" actually means \"T2.colour = 'Amber'\" in schema with exact case sensitivity\n3) When combining T1 and T2 for shared entities: link rows where T1.eye_colour_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation - use exactly 'Amber' not 'amber'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT height FROM heroes WHERE eye_color = 'amber';",
            "SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'"
        ],
        "rule_sql": [
            "SELECT T1.height_cm\nFROM superhero T1\nJOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T2.colour = 'Amber'"
        ],
        "amend_res": 1
    },
    "1429": {
        "db_id": "student_club",
        "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
        "ground_truth": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
        "amends": [
            "Do select `T2.event_name` instead of `e.name`. Do join `attendance AS T1` instead of `Attendance a`. Do use `INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event` instead of `JOIN Social_Event e ON e.event_id = a.event_id`. Do join `member AS T3 ON T1.link_to_member = T3.member_id` instead of `JOIN Student_Club sc ON a.club_id = sc.club_id`. Do filter on `T3.position = 'Vice President'` instead of `sc.vice_president = a.student_id`. Do add `T2.location = '900 E. Washington St.'` instead of using `sc.address`. Do add `T2.type = 'Social'` instead of omitting it. The amended query now correctly filters by member position and event type/location instead of incorrectly comparing vice president IDs with student IDs."
        ],
        "rules": [
            "1) When selecting the name of a social event: use \"T2.event_name\" as the output column instead of \"e.name\". 2) When joining attendance records: use \"attendance AS T1\" as the table alias. 3) When linking events to attendance: use \"INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event\" to connect events through the correct relationship. 4) When joining member information: use \"INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\" to connect members through the correct relationship. 5) When filtering for vice presidents: use \"T3.position = 'Vice President'\" to identify members with the vice president role. 6) When filtering by location: use \"T2.location = '900 E. Washington St.'\" to find events at the specified address. 7) When ensuring the event is social: use \"T2.type = 'Social'\" to filter for social events specifically."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT e.name FROM Social_Event e JOIN Attendance a ON e.event_id = a.event_id JOIN Student_Club sc ON a.club_id = sc.club_id WHERE sc.address = '900 E. Washington St.' AND sc.vice_president = a.student_id",
            "SELECT T2.event_name\nFROM attendance AS T1\nINNER JOIN event AS T2 ON T2.event_id = T1.link_to_event\nINNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\nWHERE T3.position = 'Vice President'\nAND T2.location = '900 E. Washington St.'\nAND T2.type = 'Social';"
        ],
        "rule_sql": [
            "SELECT T2.event_name\nFROM attendance AS T1\nINNER JOIN event AS T2 ON T2.event_id = T1.link_to_event\nINNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\nWHERE T3.position = 'Vice President'\nAND T2.location = '900 E. Washington St.'\nAND T2.type = 'Social'"
        ],
        "amend_res": 1
    },
    "633": {
        "db_id": "codebase_community",
        "question": "Which post by slashnick has the most answers count? State the post ID.",
        "ground_truth": "SELECT T2.PostId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'slashnick' ORDER BY T3.AnswerCount DESC LIMIT 1",
        "amends": [
            "Do join `users AS T1` and `postHistory AS T2` on `T1.Id = T2.UserId` instead of querying `posts` directly without user context. Do join `posts AS T3` on `T2.PostId = T3.Id` instead of missing the postHistory relationship. Do filter on `T1.DisplayName = 'slashnick'` instead of `author = 'slashnick'` to use the correct user identification column. Do select `T2.PostId` instead of `post_id` to reference the joined table properly. Do order by `T3.AnswerCount DESC` instead of `answer_count DESC` to use the correct table alias and column name. The amended query now correctly retrieves the post with the highest answer count for the specified user by properly navigating the user-post relationships through the postHistory table."
        ],
        "rules": [
            "1) When answering about \"post by slashnick with most answers\": make sure the output order: T2.PostId. 2) When the question mentions \"slashnick\": \"slashnick\" actually means \"T1.DisplayName = 'slashnick'\" in schema. 3) When combining T1 (users) and T2 (postHistory) for shared entities: link rows where T1.Id = T2.UserId and keep only matching pairs (inner match). 4) When combining T2 (postHistory) and T3 (posts) for shared entities: link rows where T2.PostId = T3.Id and keep only matching pairs (inner match). 5) When the question mentions \"most answers count\" or \"highest answer count\": rank rows by T3.AnswerCount in descending direction and keep the first 1 row. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT post_id FROM posts WHERE author = 'slashnick' ORDER BY answer_count DESC LIMIT 1;",
            "SELECT T2.PostId\nFROM users AS T1\nJOIN postHistory AS T2 ON T1.Id = T2.UserId\nJOIN posts AS T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'slashnick'\nORDER BY T3.AnswerCount DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T3.Id AS PostId\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T2.PostId = T3.Id\nWHERE T1.DisplayName = 'slashnick'\nORDER BY T3.AnswerCount DESC\nLIMIT 1"
        ],
        "amend_res": 1
    }
}