{
    "california_schools": {
        "0": {
            "condition": "When answering about \"highest eligible free rate for K-12 students\"",
            "operation": " calculate Free Meal Count (K-12) divided by Enrollment (K-12) instead of selecting a pre-calculated free_rate column."
        },
        "1": {
            "condition": "When the question mentions \"schools\"",
            "operation": " query from table \"frpm\" instead of \"schools\"."
        },
        "2": {
            "condition": "When filtering for Alameda County",
            "operation": " use condition \"County Name\" = 'Alameda' instead of county = 'Alameda' AND student_type = 'K-12'."
        },
        "3": {
            "condition": "When finding the highest rate",
            "operation": " order by (CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\") in descending direction and keep only the first 1 row."
        },
        "4": {
            "condition": "When answering about \"highest eligible free rate for K-12 students\", When the question mentions \"schools\", When filtering for Alameda County, When finding the highest rate, When performing division",
            "operation": " cast \"Free Meal Count (K-12)\" to REAL to ensure proper numeric division."
        },
        "5": {
            "condition": "When the question asks for \"eligible free rates\"",
            "operation": " calculate the ratio of \"Free Meal Count (Ages 5-17)\" divided by \"Enrollment (Ages 5-17)\" instead of selecting a precomputed rate column."
        },
        "6": {
            "condition": "When querying about continuation schools",
            "operation": " filter for rows where \"Educational Option Type\" exactly equals 'Continuation School' (case-sensitive)."
        },
        "7": {
            "condition": "When calculating rates",
            "operation": " exclude rows where either \"Free Meal Count (Ages 5-17)\" or \"Enrollment (Ages 5-17)\" is null to avoid division errors."
        },
        "8": {
            "condition": "When the question asks for \"lowest three\" rates",
            "operation": " order the calculated ratio in ascending order and keep the first 3 rows."
        },
        "9": {
            "condition": "When the question asks for \"eligible free rates\", When querying about continuation schools, When calculating rates, When the question asks for \"lowest three\" rates, When the question specifies students aged 5-17",
            "operation": " use the columns specifically for ages 5-17 (\"Free Meal Count (Ages 5-17)\" and \"Enrollment (Ages 5-17)\")."
        },
        "10": {
            "condition": "When answering about \"lowest three eligible free rates\"",
            "operation": " make sure the output order: the eligible free rate in ascending order and keep only the first 3 rows."
        },
        "11": {
            "condition": "When the question mentions \"eligible free rates for students aged 5-17\"",
            "operation": " compute \"Free Meal Count (Ages 5-17)\" divided by \"Enrollment (Ages 5-17)\" as the rate."
        },
        "12": {
            "condition": "When the question mentions \"continuation schools\"",
            "operation": " filter for rows where \"Educational Option Type\" equals exactly 'Continuation School'."
        },
        "13": {
            "condition": "When computing division expressions",
            "operation": " ensure the division result is not null instead of checking individual column nullity and positive denominator separately."
        },
        "14": {
            "condition": "When ordering by calculated rates",
            "operation": " reference the division expression directly in the ORDER BY clause instead of using an alias."
        },
        "15": {
            "condition": "When answering about \"lowest three eligible free rates\", When the question mentions \"eligible free rates for students aged 5-17\", When the question mentions \"continuation schools\", When computing division expressions, When ordering by calculated rates, When producing output for rate queries",
            "operation": " include only the calculated rate value, not the CDSCode or \"School Name\" columns."
        },
        "16": {
            "condition": "When answering about charter schools in Fresno County Office of Education",
            "operation": " use \"T2.Zip\" instead of \"zip_code\" for the zip code output."
        },
        "17": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match)."
        },
        "18": {
            "condition": "When filtering for Fresno County Office of Education",
            "operation": " use \"T1.District Name = 'Fresno County Office of Education'\" instead of county filtering."
        },
        "19": {
            "condition": "When answering about charter schools in Fresno County Office of Education, When combining frpm and schools tables, When filtering for Fresno County Office of Education, When identifying charter schools",
            "operation": " use \"T1.Charter School (Y/N) = 1\" instead of type = 'charter'."
        },
        "20": {
            "condition": "When the question asks for charter schools in a specific county office of education",
            "operation": " filter rows where \"District Name\" exactly matches the specified county office name like 'Fresno County Office of Education'."
        },
        "21": {
            "condition": "When identifying charter schools",
            "operation": " filter rows where \"Charter School (Y/N)\" equals 1 to select only charter schools."
        },
        "22": {
            "condition": "When column names contain spaces or special characters",
            "operation": " use backticks around identifiers like `District Name` and `Charter School (Y/N)` to handle special characters properly."
        },
        "23": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where T1.CDSCode = T2.CDSCode using an inner match to find corresponding records."
        },
        "24": {
            "condition": "When the question asks for charter schools in a specific county office of education, When identifying charter schools, When column names contain spaces or special characters, When combining frpm and schools tables, When the question asks for zip codes",
            "operation": " select the \"Zip\" column from the schools table (T2.Zip) as the output."
        },
        "25": {
            "condition": "When answering about \"mailing street address\"",
            "operation": " make sure to select \"T2.MailStreet\" instead of \"mailing_street_address\"."
        },
        "26": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match)."
        },
        "27": {
            "condition": "When the question mentions \"highest FRPM count for K-12 students\"",
            "operation": " rank rows by \"T1.FRPM Count (K-12)\" in descending order and keep the first 1 row."
        },
        "28": {
            "condition": "When answering about \"mailing street address\", When combining frpm and schools tables, When the question mentions \"highest FRPM count for K-12 students\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for columns like \"T1.FRPM Count (K-12)\"."
        },
        "29": {
            "condition": "When answering about phone numbers of direct charter-funded schools",
            "operation": " use \"T2.Phone\" as the output column instead of \"phone_number\"."
        },
        "30": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match)."
        },
        "31": {
            "condition": "When filtering for charter funding type",
            "operation": " use \"T1.Charter Funding Type = 'Directly funded'\" exactly as specified."
        },
        "32": {
            "condition": "When identifying charter schools",
            "operation": " use \"T1.Charter School (Y/N) = 1\" to filter for charter schools."
        },
        "33": {
            "condition": "When answering about phone numbers of direct charter-funded schools, When combining frpm and schools tables, When filtering for charter funding type, When identifying charter schools, When filtering for schools opened after 2000/1/1",
            "operation": " use \"T2.OpenDate > '2000-01-01'\" with the exact date format and comparison."
        },
        "34": {
            "condition": "When answering about schools with SAT math scores greater than 400",
            "operation": " join \"satscores\" as T1 with \"schools\" as T2 where T1.cds = T2.CDSCode to combine score and school information."
        },
        "35": {
            "condition": "When filtering for math scores",
            "operation": " use T1.AvgScrMath > 400 instead of math_score to reference the correct column from the SAT scores table."
        },
        "36": {
            "condition": "When identifying virtual schools",
            "operation": " use T2.Virtual = 'F' instead of virtual = 'yes' to exclude virtual schools, as 'F' indicates non-virtual status."
        },
        "37": {
            "condition": "When answering about schools with SAT math scores greater than 400, When filtering for math scores, When identifying virtual schools, When counting schools",
            "operation": " use COUNT(DISTINCT T2.School) instead of COUNT(*) to count unique school entities rather than all rows."
        },
        "38": {
            "condition": "When answering about schools with SAT test takers over 500",
            "operation": " use T1.NumTstTakr > 500 as the filter condition instead of sat_takers > 500."
        },
        "39": {
            "condition": "When identifying magnet schools or programs",
            "operation": " use T2.Magnet = 1 as the filter condition instead of (magnet_school = 'Yes' OR magnet_program = 'Yes')."
        },
        "40": {
            "condition": "When combining SAT scores and school information",
            "operation": " join T1 (satscores) and T2 (schools) using T1.cds = T2.CDSCode with an inner match."
        },
        "41": {
            "condition": "When answering about schools with SAT test takers over 500, When identifying magnet schools or programs, When combining SAT scores and school information, When selecting output columns",
            "operation": " return T2.School specifically instead of all columns (*)."
        },
        "42": {
            "condition": "When answering about phone number of a school",
            "operation": " select \"T2.Phone\" from the schools table instead of phone_number."
        },
        "43": {
            "condition": "When combining satscores and schools tables",
            "operation": " link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "44": {
            "condition": "When the question asks for the school with highest number of test takers with SAT score over 1500",
            "operation": " order by T1.NumGE1500 in descending direction and keep the first row."
        },
        "45": {
            "condition": "When answering about phone number of a school, When combining satscores and schools tables, When the question asks for the school with highest number of test takers with SAT score over 1500, When handling the count of high scorers",
            "operation": " use the pre-calculated T1.NumGE1500 column instead of counting with a subquery."
        },
        "46": {
            "condition": "When answering about \"number of SAT test takers\"",
            "operation": " select \"NumTstTakr\" from table \"satscores\" instead of counting all rows."
        },
        "47": {
            "condition": "When the question mentions \"schools with the highest FRPM count\"",
            "operation": " find the school with maximum \"FRPM Count (K-12)\" value from table \"frpm\" and get its \"CDSCode\" using descending order with limit 1."
        },
        "48": {
            "condition": "When combining data from \"satscores\" and \"frpm\" tables",
            "operation": " match rows where their \"CDSCode\" values are equal to identify the same school across tables."
        },
        "49": {
            "condition": "When the question specifies \"K-12 students\"",
            "operation": " use the column \"FRPM Count (K-12)\" which already represents K-12 data, so no additional grade level filter is needed."
        },
        "50": {
            "condition": "When answering about \"number of SAT test takers\", When the question mentions \"schools with the highest FRPM count\", When combining data from \"satscores\" and \"frpm\" tables, When the question specifies \"K-12 students\", When producing output",
            "operation": " return the exact \"NumTstTakr\" value for the school identified by the highest \"FRPM Count (K-12)\"."
        },
        "51": {
            "condition": "When answering about schools with average math scores over 560",
            "operation": " use T1.AvgScrMath > 560 as the filter condition instead of math_score > 560."
        },
        "52": {
            "condition": "When counting schools",
            "operation": " use COUNT(T2.\"School Code\") instead of COUNT(*) to count specific school codes."
        },
        "53": {
            "condition": "When combining SAT scores and funding data",
            "operation": " join T1 (satscores) and T2 (frpm) using T1.cds = T2.CDSCode with an inner match."
        },
        "54": {
            "condition": "When answering about schools with average math scores over 560, When counting schools, When combining SAT scores and funding data, When identifying charter-funded schools",
            "operation": " use T2.\"Charter Funding Type\" = 'Directly funded' instead of funding_type = 'charter' to match the exact column name and literal value."
        },
        "55": {
            "condition": "When answering about \"school with the highest average score in Reading\"",
            "operation": " rank schools by T1.AvgScrRead in descending order and keep the first 1 row."
        },
        "56": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "57": {
            "condition": "When the question asks for \"FRPM count for students aged 5-17\"",
            "operation": " use the exact column T2.\"FRPM Count (Ages 5-17)\" instead of FRPM_5_17."
        },
        "58": {
            "condition": "When answering about \"school with the highest average score in Reading\", When combining T1 and T2 for shared entities, When the question asks for \"FRPM count for students aged 5-17\", When producing output",
            "operation": " make sure the output order includes only T2.\"FRPM Count (Ages 5-17)\"."
        },
        "59": {
            "condition": "When answering about \"schools with total enrollment over 500\"",
            "operation": " select \"T2.CDSCode\" as the output column instead of \"school_code\"."
        },
        "60": {
            "condition": "When combining schools and frpm tables",
            "operation": " link rows where \"T1.CDSCode\" equals \"T2.CDSCode\" exactly and keep only matching pairs (inner match)."
        },
        "61": {
            "condition": "When calculating total enrollment",
            "operation": " use the sum of \"T2.Enrollment (K-12)\" plus \"T2.Enrollment (Ages 5-17)\" instead of a single \"enrollment\" column."
        },
        "62": {
            "condition": "When answering about \"schools with total enrollment over 500\", When combining schools and frpm tables, When calculating total enrollment, When filtering for enrollment over 500",
            "operation": " apply the condition \"T2.Enrollment (K-12) + T2.Enrollment (Ages 5-17) > 500\" to identify schools meeting the enrollment threshold."
        },
        "63": {
            "condition": "When answering about schools with SAT excellence rate over 0.3",
            "operation": " use T1 for frpm table and T2 for satscores table with inner join on T1.CDSCode = T2.cds."
        },
        "64": {
            "condition": "When calculating SAT excellence rate",
            "operation": " compute CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3 instead of using a precomputed column."
        },
        "65": {
            "condition": "When calculating free rate for students aged 5-17",
            "operation": " compute CAST(T1.\"Free Meal Count (Ages 5-17)\" AS REAL) / T1.\"Enrollment (Ages 5-17)\" instead of using a precomputed free_rate column."
        },
        "66": {
            "condition": "When filtering by age group",
            "operation": " do not add age = '5-17' filter since the age-specific columns \"Free Meal Count (Ages 5-17)\" and \"Enrollment (Ages 5-17)\" already handle this constraint."
        },
        "67": {
            "condition": "When answering about schools with SAT excellence rate over 0.3, When calculating SAT excellence rate, When calculating free rate for students aged 5-17, When filtering by age group, When finding the highest eligible free rate",
            "operation": " use MAX() function on the calculated free rate expression."
        },
        "68": {
            "condition": "When answering about \"phone numbers of schools with top SAT excellence rate\"",
            "operation": " make sure the output order: T1.Phone."
        },
        "69": {
            "condition": "When combining schools and satscores tables",
            "operation": " link rows where T1.CDSCode = T2.cds exactly as shown and keep only matching pairs (inner match)."
        },
        "70": {
            "condition": "When calculating SAT excellence rate",
            "operation": " compute CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr instead of using sat_score."
        },
        "71": {
            "condition": "When the question mentions \"top 3\"",
            "operation": " rank rows by the excellence rate in descending order and keep the first 3 rows."
        },
        "72": {
            "condition": "When answering about \"phone numbers of schools with top SAT excellence rate\", When combining schools and satscores tables, When calculating SAT excellence rate, When the question mentions \"top 3\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T1.Phone, T1.CDSCode, and T2.cds."
        },
        "73": {
            "condition": "When answering about top schools by enrollment",
            "operation": " make sure the output order: T1.NCESSchool first, then T2.\"Enrollment (Ages 5-17)\""
        },
        "74": {
            "condition": "When the question mentions \"NCES school identification number\"",
            "operation": " \"NCES school identification number\" actually means \"T1.NCESSchool\" in schema"
        },
        "75": {
            "condition": "When the question mentions \"top five schools\" by \"Enrollment (Ages 5-17)\"",
            "operation": " rank rows by T2.\"Enrollment (Ages 5-17)\" in descending order and keep the first 5 rows"
        },
        "76": {
            "condition": "When combining schools table as T1 and frpm table as T2",
            "operation": " link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match)"
        },
        "77": {
            "condition": "When handling text literals",
            "operation": " do not change case, spacing, or punctuation in \"Enrollment (Ages 5-17)\""
        },
        "78": {
            "condition": "When answering about top schools by enrollment, When the question mentions \"NCES school identification number\", When the question mentions \"top five schools\" by \"Enrollment (Ages 5-17)\", When combining schools table as T1 and frpm table as T2, When handling text literals, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T2.\"Enrollment (Ages 5-17)\""
        },
        "79": {
            "condition": "When answering about \"active district has the highest average score in Reading\"",
            "operation": " make sure the output order: District, AvgScrRead"
        },
        "80": {
            "condition": "When the question mentions \"active\"",
            "operation": " \"active\" actually means \"StatusType='Active' in schema\""
        },
        "81": {
            "condition": "When combining schools and satscores for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (schools.CDSCode = satscores.cds); keep only matching pairs (inner match)"
        },
        "82": {
            "condition": "When the question mentions \"highest average score in Reading\"",
            "operation": " rank rows by AvgScrRead in descending direction and keep the first 1 row"
        },
        "83": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "84": {
            "condition": "When answering about \"active district has the highest average score in Reading\", When the question mentions \"active\", When combining schools and satscores for shared entities, When the question mentions \"highest average score in Reading\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Active'"
        },
        "85": {
            "condition": "When answering about \"which active district has the highest average score in Reading\"",
            "operation": " make sure the output order includes only \"District\" column."
        },
        "86": {
            "condition": "When the question mentions \"active district\"",
            "operation": " filter rows where T1.StatusType equals exactly 'Active'."
        },
        "87": {
            "condition": "When the question mentions \"highest average score in Reading\"",
            "operation": " rank rows by T2.AvgScrRead in descending order and keep only the first 1 row."
        },
        "88": {
            "condition": "When combining schools and satscores tables",
            "operation": " link rows where T1.CDSCode equals T2.cds exactly and keep only matching pairs (inner match)."
        },
        "89": {
            "condition": "When answering about \"which active district has the highest average score in Reading\", When the question mentions \"active district\", When the question mentions \"highest average score in Reading\", When combining schools and satscores tables, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for any column or table names."
        },
        "90": {
            "condition": "When answering about \"schools in merged Alameda\"",
            "operation": " make sure the output order: COUNT(T1.CDSCode)."
        },
        "91": {
            "condition": "When the question mentions \"schools\"",
            "operation": " use \"schools AS T1\" as the base table."
        },
        "92": {
            "condition": "When the question mentions \"number of test takers\"",
            "operation": " \"number of test takers\" actually means \"T2.NumTstTakr in schema\"."
        },
        "93": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CDSCode = T2.cds exactly as shown; keep only matching pairs (inner match)."
        },
        "94": {
            "condition": "When the question asks for \"count of schools\"",
            "operation": " compute the number of rows using T1.CDSCode as the counting key."
        },
        "95": {
            "condition": "When filtering for \"merged\" schools",
            "operation": " use T1.StatusType = 'Merged' exactly."
        },
        "96": {
            "condition": "When filtering for \"Alameda\" county",
            "operation": " use T1.County = 'Alameda' exactly (not 'Lake')."
        },
        "97": {
            "condition": "When answering about \"schools in merged Alameda\", When the question mentions \"schools\", When the question mentions \"number of test takers\", When combining T1 and T2 for shared entities, When the question asks for \"count of schools\", When filtering for \"merged\" schools, When filtering for \"Alameda\" county, When filtering for \"less than 100 test takers\"",
            "operation": " use T2.NumTstTakr < 100 exactly."
        },
        "98": {
            "condition": "When answering about ranking schools by average writing score",
            "operation": " use the exact column name \"AvgScrWrite\" from table satscores instead of \"writing_score\"."
        },
        "99": {
            "condition": "When the question mentions \"charter numbers\"",
            "operation": " use the exact column name \"CharterNum\" from table schools instead of \"charter_number\"."
        },
        "100": {
            "condition": "When combining schools and satscores tables",
            "operation": " link rows where T1.CDSCode = T2.cds and keep only matching pairs (inner match)."
        },
        "101": {
            "condition": "When filtering for scores greater than 499",
            "operation": " apply the condition T2.AvgScrWrite > 499 AND CharterNum is not null to exclude null charter numbers."
        },
        "102": {
            "condition": "When ranking schools",
            "operation": " use RANK() OVER (ORDER BY AvgScrWrite DESC) to assign ranks based on average writing score in descending order."
        },
        "103": {
            "condition": "When answering about ranking schools by average writing score, When the question mentions \"charter numbers\", When combining schools and satscores tables, When filtering for scores greater than 499, When ranking schools, When producing output",
            "operation": " show CharterNum, AvgScrWrite, and the rank value in that order without an explicit ORDER BY clause since the window function handles ordering."
        },
        "104": {
            "condition": "When counting schools",
            "operation": " use COUNT(T1.CDSCode) instead of COUNT(*) to count specific non-null values."
        },
        "105": {
            "condition": "When combining school data from multiple tables",
            "operation": " join frpm AS T1 and satscores AS T2 with INNER JOIN on T1.CDSCode = T2.cds instead of querying a single schools table."
        },
        "106": {
            "condition": "When filtering by funding type",
            "operation": " use T1.Charter Funding Type = 'Directly funded' instead of funding_type = 'direct' for the correct column name and value."
        },
        "107": {
            "condition": "When filtering by geographic location",
            "operation": " use T1.County Name = 'Fresno' instead of city = 'Fresno' to use the proper geographic attribute."
        },
        "108": {
            "condition": "When counting schools, When combining school data from multiple tables, When filtering by funding type, When filtering by geographic location, When filtering by number of test takers",
            "operation": " use T2.NumTstTakr <= 250 instead of test_takers > 250 to correctly identify schools with 250 or fewer test takers rather than more than 250."
        },
        "109": {
            "condition": "When answering about \"phone number of the school with highest average math score\"",
            "operation": " make sure the output order: T1.Phone."
        },
        "110": {
            "condition": "When the question mentions \"school\"",
            "operation": " use table \"schools AS T1\" with exact alias T1."
        },
        "111": {
            "condition": "When the question mentions \"average score in Math\"",
            "operation": " use column T2.AvgScrMath from table \"satscores AS T2\"."
        },
        "112": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CDSCode = T2.cds exactly as shown; keep only matching pairs (inner match)."
        },
        "113": {
            "condition": "When answering about \"phone number of the school with highest average math score\", When the question mentions \"school\", When the question mentions \"average score in Math\", When combining T1 and T2 for shared entities, When the question asks for \"highest average score\"",
            "operation": " rank rows by T2.AvgScrMath in descending order and keep the first 1 row."
        },
        "114": {
            "condition": "When counting schools",
            "operation": " use COUNT(T1.\"School Name\") from the frpm table instead of COUNT(*) from the schools table."
        },
        "115": {
            "condition": "When combining frpm and schools tables",
            "operation": " perform an INNER JOIN between frpm AS T1 and schools AS T2 on T1.CDSCode = T2.CDSCode to match related records."
        },
        "116": {
            "condition": "When filtering by grade levels",
            "operation": " apply Low_Grade = 9 and High_Grade = 12 conditions to T1.\"Low Grade\" and T1.\"High Grade\" columns from the frpm table."
        },
        "117": {
            "condition": "When filtering by county",
            "operation": " apply County = 'Amador' condition to T2.County column from the schools table."
        },
        "118": {
            "condition": "When counting schools, When combining frpm and schools tables, When filtering by grade levels, When filtering by county, When the question asks about schools in Amador with specific grade ranges",
            "operation": " ensure the output order presents the count of schools matching all specified criteria."
        },
        "119": {
            "condition": "When answering about schools in Los Angeles",
            "operation": " use \"County Name\" = 'Los Angeles' instead of city = 'Los Angeles'"
        },
        "120": {
            "condition": "When counting schools",
            "operation": " count using \"CDSCode\" instead of counting all rows"
        },
        "121": {
            "condition": "When filtering for free meals over 500",
            "operation": " use \"Free Meal Count (K-12)\" > 500"
        },
        "122": {
            "condition": "When filtering for free or reduced price meals under 700",
            "operation": " use \"FRPM Count (K-12)\" < 700"
        },
        "123": {
            "condition": "When answering about schools in Los Angeles, When counting schools, When filtering for free meals over 500, When filtering for free or reduced price meals under 700, When the question mentions K-12 meal counts",
            "operation": " do not add an additional grade_level filter since the meal columns already specify K-12 scope"
        },
        "124": {
            "condition": "When answering about \"school in Contra Costa with highest number of test takers\"",
            "operation": " make sure the output order: sname only."
        },
        "125": {
            "condition": "When the question mentions \"school\"",
            "operation": " \"school\" actually means \"sname in satscores table\"."
        },
        "126": {
            "condition": "When the question mentions \"Contra Costa\"",
            "operation": " \"Contra Costa\" actually means \"cname = 'Contra Costa' in satscores table\"."
        },
        "127": {
            "condition": "When the question mentions \"highest number of test takers\"",
            "operation": " \"test takers\" actually means \"NumTstTakr in satscores table\" and rank rows by NumTstTakr in descending direction and keep the first 1 row."
        },
        "128": {
            "condition": "When selecting school names",
            "operation": " ensure sname IS NOT NULL to exclude null values."
        },
        "129": {
            "condition": "When answering about \"school in Contra Costa with highest number of test takers\", When the question mentions \"school\", When the question mentions \"Contra Costa\", When the question mentions \"highest number of test takers\", When selecting school names, When handling the satscores table",
            "operation": " do not use aggregate functions like MAX when selecting individual school records."
        },
        "130": {
            "condition": "When answering about schools with enrollment differences",
            "operation": " make sure the output order: T1.School, T1.Street"
        },
        "131": {
            "condition": "When the question mentions \"names of schools\"",
            "operation": " \"names\" actually means \"T1.School in schema\""
        },
        "132": {
            "condition": "When the question mentions \"full street address\"",
            "operation": " \"full street address\" actually means \"T1.Street in schema\""
        },
        "133": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match)"
        },
        "134": {
            "condition": "When calculating enrollment difference between K-12 and ages 5-17",
            "operation": " compute T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\" instead of generic column names"
        },
        "135": {
            "condition": "When answering about schools with enrollment differences, When the question mentions \"names of schools\", When the question mentions \"full street address\", When combining T1 and T2 for shared entities, When calculating enrollment difference between K-12 and ages 5-17, When filtering for differences greater than 30",
            "operation": " apply the condition (T2.\"Enrollment (K-12)\" - T2.\"Enrollment (Ages 5-17)\") > 30"
        },
        "136": {
            "condition": "When joining tables for school data",
            "operation": " combine satscores as T1 with frpm as T2 where T1.cds equals T2.CDSCode and keep only matching pairs (inner match)."
        },
        "137": {
            "condition": "When calculating free meal percentage",
            "operation": " compute CAST(T2.\"Free Meal Count (K-12)\" AS REAL) divided by T2.\"Enrollment (K-12)\" and check if greater than 0.1."
        },
        "138": {
            "condition": "When checking for test takers with scores >= 1500",
            "operation": " verify that T1.NumGE1500 is greater than 0 to indicate existence of qualifying scores."
        },
        "139": {
            "condition": "When selecting school names",
            "operation": " output T2.\"School Name\" as the result."
        },
        "140": {
            "condition": "When joining tables for school data, When calculating free meal percentage, When checking for test takers with scores >= 1500, When selecting school names, When answering about schools meeting both criteria",
            "operation": " ensure both the free meal percentage condition and test score condition are satisfied simultaneously."
        },
        "141": {
            "condition": "When answering about schools in Riverside",
            "operation": " use \"T2.District Name LIKE 'Riverside%'\" instead of \"city = 'Riverside'\" for filtering."
        },
        "142": {
            "condition": "When combining SAT scores and funding data",
            "operation": " link rows where \"T1.cds = T2.CDSCode\" using an inner join."
        },
        "143": {
            "condition": "When calculating average math scores",
            "operation": " compute \"CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds)\" instead of using AVG(math_score)."
        },
        "144": {
            "condition": "When the question asks for school names and funding types",
            "operation": " select both \"T1.sname\" and \"T2.Charter Funding Type\" in the output."
        },
        "145": {
            "condition": "When grouping by school and funding type",
            "operation": " use \"GROUP BY T1.sname, T2.Charter Funding Type\" to organize results."
        },
        "146": {
            "condition": "When answering about schools in Riverside, When combining SAT scores and funding data, When calculating average math scores, When the question asks for school names and funding types, When grouping by school and funding type, When filtering on aggregate results",
            "operation": " place the condition \"CAST(SUM(T1.AvgScrMath) AS REAL) / COUNT(T1.cds) > 400\" in the HAVING clause instead of WHERE."
        },
        "147": {
            "condition": "When answering about high schools in Monterey",
            "operation": " use T1.School Name, T2.Street, T2.City, T2.State, and T2.Zip as output columns in that order."
        },
        "148": {
            "condition": "When combining data about free meals and school addresses",
            "operation": " link frpm as T1 and schools as T2 where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "149": {
            "condition": "When the question mentions \"Monterey\"",
            "operation": " filter on T2.County = 'Monterey' exactly."
        },
        "150": {
            "condition": "When the question mentions \"more than 800 free or reduced price meals\"",
            "operation": " filter on T1.\"Free Meal Count (Ages 5-17)\" > 800."
        },
        "151": {
            "condition": "When the question mentions \"high schools\"",
            "operation": " filter on T1.\"School Type\" = 'High Schools (Public)' exactly."
        },
        "152": {
            "condition": "When answering about high schools in Monterey, When combining data about free meals and school addresses, When the question mentions \"Monterey\", When the question mentions \"more than 800 free or reduced price meals\", When the question mentions \"high schools\", When the question mentions \"ages 15-17\"",
            "operation": " the condition is already covered by filtering for high schools (ages 15-17 are typically in high schools)."
        },
        "153": {
            "condition": "When selecting school names and writing scores",
            "operation": " use T2.\"School\" for school names and T1.\"AvgScrWrite\" for average writing scores instead of school_name and AVG(writing_score)."
        },
        "154": {
            "condition": "When selecting communication information",
            "operation": " use T2.\"Phone\" for communication numbers instead of communication_number."
        },
        "155": {
            "condition": "When combining school and SAT score data",
            "operation": " perform a LEFT JOIN between schools AS T2 and satscores AS T1 where T2.\"CDSCode\" equals T1.\"cds\"."
        },
        "156": {
            "condition": "When filtering for schools opened after 1991",
            "operation": " use strftime('%Y', T2.\"OpenDate\") > '1991' instead of opened_year > 1991."
        },
        "157": {
            "condition": "When filtering for schools closed before 2000",
            "operation": " use strftime('%Y', T2.\"ClosedDate\") < '2000' instead of closed_year < 2000."
        },
        "158": {
            "condition": "When selecting school names and writing scores, When selecting communication information, When combining school and SAT score data, When filtering for schools opened after 1991, When filtering for schools closed before 2000, When the question asks for average writing scores",
            "operation": " do not use aggregate functions or GROUP BY since the average score is directly available from T1.\"AvgScrWrite\" in the joined table."
        },
        "159": {
            "condition": "When answering about school names and DOC types",
            "operation": " select \"T2.School\" and \"T2.DOC\" as output columns."
        },
        "160": {
            "condition": "When combining enrollment data from frpm and schools tables",
            "operation": " join \"frpm AS T1\" with \"schools AS T2\" where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match)."
        },
        "161": {
            "condition": "When filtering for locally funded schools",
            "operation": " use condition \"T2.FundingType = 'Locally funded'\" exactly as specified."
        },
        "162": {
            "condition": "When calculating enrollment difference",
            "operation": " compute \"T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`\" using the exact column names from frpm table."
        },
        "163": {
            "condition": "When computing the average difference in subquery",
            "operation": " use the same join structure with \"frpm AS T3\" and \"schools AS T4\" on \"T3.CDSCode = T4.CDSCode\" and filter with \"T4.FundingType = 'Locally funded'\"."
        },
        "164": {
            "condition": "When answering about school names and DOC types, When combining enrollment data from frpm and schools tables, When filtering for locally funded schools, When calculating enrollment difference, When computing the average difference in subquery, When comparing to average difference",
            "operation": " filter schools where the enrollment difference is greater than the computed average difference from the subquery."
        },
        "165": {
            "condition": "When answering about \"first-through-twelfth-grade school with the largest enrollment\"",
            "operation": " use tables \"frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\" instead of querying only schools."
        },
        "166": {
            "condition": "When the question asks for the opening date of the school with largest enrollment",
            "operation": " select \"T2.OpenDate\" instead of MIN(open_date)."
        },
        "167": {
            "condition": "When finding the school with maximum enrollment",
            "operation": " use \"ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1\" instead of a subquery comparison with MAX(enrollment)."
        },
        "168": {
            "condition": "When answering about \"first-through-twelfth-grade school with the largest enrollment\", When the question asks for the opening date of the school with largest enrollment, When finding the school with maximum enrollment, When combining frpm and schools tables",
            "operation": " link rows where \"T1.CDSCode = T2.CDSCode\" exactly and keep only matching pairs (inner match)."
        },
        "169": {
            "condition": "When answering about cities with lowest enrollment",
            "operation": " use T2.City in the SELECT list without any alias for the city column."
        },
        "170": {
            "condition": "When calculating enrollment for grades 1 through 12",
            "operation": " use SUM(T1.\"Enrollment (K-12)\") as the enrollment measure instead of any other enrollment column."
        },
        "171": {
            "condition": "When combining frpm and schools tables",
            "operation": " perform an INNER JOIN where T1.CDSCode = T2.CDSCode to link related records."
        },
        "172": {
            "condition": "When ordering results for top 5 lowest enrollment",
            "operation": " order by the SUM(T1.\"Enrollment (K-12)\") expression directly in ASCending order and limit to 5 rows."
        },
        "173": {
            "condition": "When answering about cities with lowest enrollment, When calculating enrollment for grades 1 through 12, When combining frpm and schools tables, When ordering results for top 5 lowest enrollment, When grouping results",
            "operation": " group by T2.City to organize enrollment data by city."
        },
        "174": {
            "condition": "When answering about \"cities with top 5 lowest enrollment number for students in grades 1 through 12\"",
            "operation": " make sure the output order includes only \"T2.City\" without the enrollment sum column."
        },
        "175": {
            "condition": "When the question mentions \"enrollment number for students in grades 1 through 12\"",
            "operation": " \"enrollment\" actually means \"T1.\\\"Enrollment (K-12)\\\"\" in schema."
        },
        "176": {
            "condition": "When the question asks for \"top 5 lowest enrollment\"",
            "operation": " rank rows by SUM(T1.\\\"Enrollment (K-12)\\\") in ascending order and keep the first 5 rows."
        },
        "177": {
            "condition": "When the question says \"by cities\"/\"per city\"",
            "operation": " organize results by T2.City and compute enrollment sum per group."
        },
        "178": {
            "condition": "When answering about \"cities with top 5 lowest enrollment number for students in grades 1 through 12\", When the question mentions \"enrollment number for students in grades 1 through 12\", When the question asks for \"top 5 lowest enrollment\", When the question says \"by cities\"/\"per city\", When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match)."
        },
        "179": {
            "condition": "When answering about eligible free rate",
            "operation": " calculate it as CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" instead of using a precomputed column."
        },
        "180": {
            "condition": "When referencing the schools data",
            "operation": " use table \"frpm\" instead of \"schools\"."
        },
        "181": {
            "condition": "When ordering by enrollment",
            "operation": " use column \"Enrollment (K-12)\" in descending order instead of \"enrolment\"."
        },
        "182": {
            "condition": "When answering about eligible free rate, When referencing the schools data, When ordering by enrollment, When retrieving the 10th and 11th schools with highest enrollment",
            "operation": " use LIMIT 9, 2 syntax to get 2 rows starting from position 10 (offset 9)."
        },
        "183": {
            "condition": "When answering about eligible free or reduced price meal rate",
            "operation": " calculate the ratio CAST(T1.\"FRPM Count (K-12)\" AS REAL) / T1.\"Enrollment (K-12)\" instead of selecting school_name and free_or_reduced_price_meal_rate."
        },
        "184": {
            "condition": "When combining data from frpm and schools tables",
            "operation": " link rows where T1.CDSCode = T2.CDSCode using an inner join and keep only matching pairs."
        },
        "185": {
            "condition": "When filtering for ownership code 66",
            "operation": " use WHERE T2.SOC = 66 instead of ownership_code = 66, using the correct column name and table alias."
        },
        "186": {
            "condition": "When the question mentions grades 1-12",
            "operation": " do not filter with grades LIKE '%1-12%' as the logic is handled through K-12 specific columns."
        },
        "187": {
            "condition": "When ordering by highest free or reduced price meal count",
            "operation": " order by T1.\"FRPM Count (K-12)\" DESC instead of free_or_reduced_price_meal_count DESC."
        },
        "188": {
            "condition": "When answering about eligible free or reduced price meal rate, When combining data from frpm and schools tables, When filtering for ownership code 66, When the question mentions grades 1-12, When ordering by highest free or reduced price meal count, When the question asks for top 5 schools",
            "operation": " keep only the first 5 rows after ordering by T1.\"FRPM Count (K-12)\" in descending order."
        },
        "189": {
            "condition": "When answering about school websites and names with free meal counts between 1900-2000",
            "operation": " select \"T2.Website\" and \"T1.School Name\" as output columns."
        },
        "190": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where \"T1.CDSCode = T2.CDSCode\" using an inner match."
        },
        "191": {
            "condition": "When filtering for free meal count range 1900-2000",
            "operation": " use \"T1.Free Meal Count (Ages 5-17) BETWEEN 1900 AND 2000\" to include the specified range."
        },
        "192": {
            "condition": "When ensuring website availability",
            "operation": " add condition \"T2.Website IS NOT NULL\" to exclude schools without websites."
        },
        "193": {
            "condition": "When answering about school websites and names with free meal counts between 1900-2000, When combining frpm and schools tables, When filtering for free meal count range 1900-2000, When ensuring website availability, When the question mentions \"students aged 5-17\"",
            "operation": " this is already handled by the column name \"Free Meal Count (Ages 5-17)\" and no separate age filter is needed."
        },
        "194": {
            "condition": "When the question asks for website addresses and school names",
            "operation": " make sure the output order is Website first, then School Name."
        },
        "195": {
            "condition": "When referring to the \"School Name\" column",
            "operation": " use backticks for quoting as `School Name` instead of double quotes."
        },
        "196": {
            "condition": "When referring to the \"Free Meal Count (Ages 5-17)\" column",
            "operation": " use backticks for quoting as `Free Meal Count (Ages 5-17)` instead of double quotes."
        },
        "197": {
            "condition": "When combining frpm table (T1) and schools table (T2)",
            "operation": " link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "198": {
            "condition": "When filtering for free meal count between 1900 and 2000",
            "operation": " use the range 1900 to 2000 inclusive for `Free Meal Count (Ages 5-17)`."
        },
        "199": {
            "condition": "When the question asks for website addresses and school names, When referring to the \"School Name\" column, When referring to the \"Free Meal Count (Ages 5-17)\" column, When combining frpm table (T1) and schools table (T2), When filtering for free meal count between 1900 and 2000, When selecting website addresses",
            "operation": " include only rows where T2.Website is not null."
        },
        "200": {
            "condition": "When calculating free rate for students between ages 5-17",
            "operation": " compute CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\" instead of using a free_rate column."
        },
        "201": {
            "condition": "When querying about schools run by Kacey Gibson",
            "operation": " filter using T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson' instead of principal = 'Kacey Gibson' to match the separated first and last name columns."
        },
        "202": {
            "condition": "When combining schools and frpm data",
            "operation": " link rows using T1.CDSCode = T2.CDSCode and keep only matching pairs (inner join)."
        },
        "203": {
            "condition": "When calculating free rate for students between ages 5-17, When querying about schools run by Kacey Gibson, When combining schools and frpm data, When handling age range 5-17",
            "operation": " use the specific frpm table columns \"Free Meal Count (Ages 5-17)\" and \"Enrollment (Ages 5-17)\" instead of filtering by age range in the WHERE clause."
        },
        "204": {
            "condition": "When answering about administrator email addresses",
            "operation": " select T2.AdmEmail1 instead of email from administrators table."
        },
        "205": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where T1.CDSCode = T2.CDSCode using an inner join."
        },
        "206": {
            "condition": "When filtering for chartered schools",
            "operation": " use T1.Charter School (Y/N) = 1 instead of type = 'chartered'."
        },
        "207": {
            "condition": "When ordering by student enrollment",
            "operation": " use T1.Enrollment (K-12) in ascending order instead of total_students."
        },
        "208": {
            "condition": "When answering about administrator email addresses, When combining frpm and schools tables, When filtering for chartered schools, When ordering by student enrollment, When finding the school with fewest students",
            "operation": " maintain the ASC LIMIT 1 structure to get the single row with minimum enrollment."
        },
        "209": {
            "condition": "When answering about administrator names for schools",
            "operation": " select the exact columns T2.AdmFName1, T2.AdmLName1, T2.AdmFName2, T2.AdmLName2, T2.AdmFName3, T2.AdmLName3 instead of a generic administrator_name field."
        },
        "210": {
            "condition": "When combining SAT score data with school information",
            "operation": " link tables satscores AS T1 and schools AS T2 where T1.cds = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "211": {
            "condition": "When finding the school with the highest number of students scoring 1500+ on SAT",
            "operation": " order results by T1.NumGE1500 in descending direction and keep only the first row."
        },
        "212": {
            "condition": "When answering about administrator names for schools, When combining SAT score data with school information, When finding the school with the highest number of students scoring 1500+ on SAT, When the question asks about SAT scores of 1500 or more",
            "operation": " use the T1.NumGE1500 column which already represents this count, rather than filtering individual SAT scores."
        },
        "213": {
            "condition": "When answering about school addresses with lowest excellence rate",
            "operation": " make sure the output order: Street, City, Zip, State from the schools table."
        },
        "214": {
            "condition": "When the question mentions \"excellence rate\"",
            "operation": " \"excellence rate\" actually means \"calculated ratio CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr in schema\"."
        },
        "215": {
            "condition": "When the question asks for the school with the lowest excellence rate",
            "operation": " rank rows by the calculated ratio CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr in ascending order and keep the first 1 row."
        },
        "216": {
            "condition": "When combining satscores and schools tables",
            "operation": " link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)."
        },
        "217": {
            "condition": "When answering about school addresses with lowest excellence rate, When the question mentions \"excellence rate\", When the question asks for the school with the lowest excellence rate, When combining satscores and schools tables, When selecting address columns",
            "operation": " use explicit table aliases T2.Street, T2.City, T2.State, and T2.Zip instead of unqualified column names."
        },
        "218": {
            "condition": "When combining SAT scores and schools data",
            "operation": " use INNER JOIN to link rows where T1.cds = T2.CDSCode and keep only matching pairs."
        },
        "219": {
            "condition": "When ordering by excellence rate",
            "operation": " compute CAST(T1.NumGE1500 AS REAL) / T1.NumTstTakr and sort in ascending order to find the lowest rate."
        },
        "220": {
            "condition": "When selecting address information",
            "operation": " output columns in the order Street, City, State, Zip."
        },
        "221": {
            "condition": "When combining SAT scores and schools data, When ordering by excellence rate, When selecting address information, When finding the single school with the lowest excellence rate",
            "operation": " take only the first result after ordering."
        },
        "222": {
            "condition": "When answering about school webpages",
            "operation": " select \"T2\".\"Website\" instead of \"webpage\" and use table alias \"T2\" for the schools table."
        },
        "223": {
            "condition": "When combining SAT scores and schools data",
            "operation": " join \"satscores\" as \"T1\" with \"schools\" as \"T2\" using inner join where \"T1\".\"cds\" = \"T2\".\"CDSCode\" to match related records."
        },
        "224": {
            "condition": "When filtering for test takers count between 2000 and 3000",
            "operation": " use \"T1\".\"NumTstTakr\" BETWEEN 2000 AND 3000 instead of \"test_takers\" and place this condition in the WHERE clause."
        },
        "225": {
            "condition": "When answering about school webpages, When combining SAT scores and schools data, When filtering for test takers count between 2000 and 3000, When filtering for Los Angeles County",
            "operation": " use \"T2\".\"County\" = 'Los Angeles' with the exact literal value and proper table alias reference."
        },
        "226": {
            "condition": "When answering about average number of test takers",
            "operation": " use AVG(T1.NumTstTakr) from the satscores table instead of AVG(test_takers) from schools table."
        },
        "227": {
            "condition": "When combining satscores and schools tables",
            "operation": " link rows where T1.cds = T2.CDSCode using inner join and keep only matching pairs."
        },
        "228": {
            "condition": "When filtering for Fresno schools",
            "operation": " use T2.County = 'Fresno' instead of city = 'Fresno'."
        },
        "229": {
            "condition": "When answering about average number of test takers, When combining satscores and schools tables, When filtering for Fresno schools, When filtering for schools opened in 1980",
            "operation": " use strftime('%Y', T2.OpenDate) = '1980' instead of opened_date BETWEEN '1980-01-01' AND '1980-12-31'."
        },
        "230": {
            "condition": "When answering about telephone numbers for schools",
            "operation": " use T2.Phone from the schools table instead of telephone."
        },
        "231": {
            "condition": "When combining schools and satscores tables",
            "operation": " link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "232": {
            "condition": "When filtering for reading scores",
            "operation": " ensure T1.AvgScrRead IS NOT NULL to exclude null reading scores."
        },
        "233": {
            "condition": "When ordering by reading performance",
            "operation": " use T1.AvgScrRead to sort by average reading score instead of reading_score."
        },
        "234": {
            "condition": "When answering about telephone numbers for schools, When combining schools and satscores tables, When filtering for reading scores, When ordering by reading performance, When finding the lowest average reading score",
            "operation": " order by T1.AvgScrRead in ascending direction and keep the first row."
        },
        "235": {
            "condition": "When the question asks for \"virtual schools\"",
            "operation": " use the exact literal 'F' for the \"Virtual\" column instead of 'virtual' for the \"type\" column."
        },
        "236": {
            "condition": "When combining SAT scores and schools data",
            "operation": " link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "237": {
            "condition": "When ranking schools within counties by reading scores",
            "operation": " use RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) to assign ranks within each county group."
        },
        "238": {
            "condition": "When selecting top 5 schools per county",
            "operation": " filter for rows where the rank is less than or equal to 5."
        },
        "239": {
            "condition": "When the question asks for school names",
            "operation": " return the \"School\" column instead of \"school_name\"."
        },
        "240": {
            "condition": "When the question asks for \"virtual schools\", When combining SAT scores and schools data, When ranking schools within counties by reading scores, When selecting top 5 schools per county, When the question asks for school names, When the question mentions \"average reading scores\"",
            "operation": " use the exact column T1.AvgScrRead for reading score values."
        },
        "241": {
            "condition": "When answering about \"type of education offered in the school who scored the highest average in Math\"",
            "operation": " make sure the output order: T2.EdOpsName."
        },
        "242": {
            "condition": "When the question mentions \"type of education\"",
            "operation": " \"type of education\" actually means \"T2.EdOpsName in schema\"."
        },
        "243": {
            "condition": "When the question mentions \"highest average in Math\"",
            "operation": " \"highest average in Math\" actually means \"T1.AvgScrMath in schema\" and requires ordering by T1.AvgScrMath DESC."
        },
        "244": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.cds = T2.CDSCode exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "245": {
            "condition": "When answering about \"type of education offered in the school who scored the highest average in Math\", When the question mentions \"type of education\", When the question mentions \"highest average in Math\", When combining T1 and T2 for shared entities, When the question asks for the highest scoring school",
            "operation": " rank rows by T1.AvgScrMath in descending direction and keep the first 1 row."
        },
        "246": {
            "condition": "When answering about average math score and county location",
            "operation": " make sure the output order: T1.AvgScrMath, T2.County"
        },
        "247": {
            "condition": "When the question mentions \"math score\"",
            "operation": " \"math score\" actually means \"T1.AvgScrMath in schema\""
        },
        "248": {
            "condition": "When the question mentions \"county\"",
            "operation": " \"county\" actually means \"T2.County in schema\""
        },
        "249": {
            "condition": "When combining T1 (satscores) and T2 (schools) for shared entities",
            "operation": " link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)"
        },
        "250": {
            "condition": "When handling average scores",
            "operation": " filter out null values using T1.AvgScrMath IS NOT NULL"
        },
        "251": {
            "condition": "When the question asks for the school with the lowest average score for all subjects",
            "operation": " rank rows by T1.AvgScrMath + T1.AvgScrRead + T1.AvgScrWrite in ascending order and keep the first 1 row"
        },
        "252": {
            "condition": "When answering about average math score and county location, When the question mentions \"math score\", When the question mentions \"county\", When combining T1 (satscores) and T2 (schools) for shared entities, When handling average scores, When the question asks for the school with the lowest average score for all subjects, When computing the lowest average",
            "operation": " do not use GROUP BY since we want individual school records, not aggregated groups"
        },
        "253": {
            "condition": "When answering about average writing score",
            "operation": " use T1.AvgScrWrite instead of AVG(writing_score)."
        },
        "254": {
            "condition": "When answering about city location",
            "operation": " use T2.City instead of city."
        },
        "255": {
            "condition": "When combining SAT scores and schools data",
            "operation": " join T1 (satscores) and T2 (schools) using T1.cds = T2.CDSCode with inner match."
        },
        "256": {
            "condition": "When the question asks for the school with highest number of test takers with SAT scores >= 1500",
            "operation": " order by T1.NumGE1500 DESC instead of counting and filtering manually."
        },
        "257": {
            "condition": "When selecting the top result",
            "operation": " take only the first row after ordering by T1.NumGE1500 DESC."
        },
        "258": {
            "condition": "When answering about average writing score, When answering about city location, When combining SAT scores and schools data, When the question asks for the school with highest number of test takers with SAT scores >= 1500, When selecting the top result, When handling pre-calculated counts",
            "operation": " do not use WHERE total_sat_score >= 1500 filter or GROUP BY clause since T1.NumGE1500 already represents the count of test takers with scores >= 1500."
        },
        "259": {
            "condition": "When answering about schools managed by Ricci Ulrich",
            "operation": " select T2.School and T1.AvgScrWrite as output columns."
        },
        "260": {
            "condition": "When combining SAT scores and schools data",
            "operation": " link rows where T1.cds = T2.CDSCode using an inner match."
        },
        "261": {
            "condition": "When filtering for administrator Ricci Ulrich",
            "operation": " apply the condition T2.AdmFName1 = 'Ricci' AND T2.AdmLName1 = 'Ulrich' exactly as written."
        },
        "262": {
            "condition": "When the question asks for average writing scores",
            "operation": " use the pre-computed average T1.AvgScrWrite instead of calculating an average from raw scores."
        },
        "263": {
            "condition": "When answering about schools managed by Ricci Ulrich, When combining SAT scores and schools data, When filtering for administrator Ricci Ulrich, When the question asks for average writing scores, When the question does not require grouping",
            "operation": " do not include any GROUP BY clause in the query."
        },
        "264": {
            "condition": "When answering about state special schools",
            "operation": " filter schools where T2.DOC = 31 instead of using grade ranges."
        },
        "265": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "266": {
            "condition": "When the question asks for highest number of enrollees",
            "operation": " rank schools by T1.\"Enrollment (K-12)\" in descending order and keep the top school."
        },
        "267": {
            "condition": "When producing output",
            "operation": " select T2.School instead of state and SUM(enrollees)."
        },
        "268": {
            "condition": "When answering about state special schools, When combining frpm and schools tables, When the question asks for highest number of enrollees, When producing output, When grouping is not required",
            "operation": " do not use GROUP BY state."
        },
        "269": {
            "condition": "When the question asks for state special schools",
            "operation": " filter T2.DOC to equal numeric value 31 exactly (not string '31')."
        },
        "270": {
            "condition": "When ordering by enrollment count",
            "operation": " use the exact column name \"Enrollment (K-12)\" with double quotes as shown in the schema."
        },
        "271": {
            "condition": "When selecting output columns for this question",
            "operation": " include only T2.School in the results, not the enrollment count itself."
        },
        "272": {
            "condition": "When the question asks for state special schools, When ordering by enrollment count, When selecting output columns for this question, When finding the highest number of enrollees",
            "operation": " order rows by T1.\"Enrollment (K-12)\" in descending order and keep only the top result."
        },
        "273": {
            "condition": "When calculating average monthly count of schools",
            "operation": " compute CAST(COUNT(\"School\") AS REAL) / 12 instead of using AVG(COUNT(*)) function."
        },
        "274": {
            "condition": "When filtering by Elementary School District",
            "operation": " use \"DOC\" = 52 instead of district_type = 'Elementary School District'."
        },
        "275": {
            "condition": "When filtering by Alameda County",
            "operation": " keep \"County\" = 'Alameda' exactly as specified."
        },
        "276": {
            "condition": "When filtering by year 1980",
            "operation": " use strftime('%Y', \"OpenDate\") = '1980' instead of opened_year = 1980."
        },
        "277": {
            "condition": "When calculating average monthly count of schools, When filtering by Elementary School District, When filtering by Alameda County, When filtering by year 1980, When computing overall monthly average",
            "operation": " remove any GROUP BY clause instead of grouping by month."
        },
        "278": {
            "condition": "When the question asks for a ratio of merged Unified School District schools to merged Elementary School District schools in Orange County",
            "operation": " use SUM(CASE WHEN DOC = 54 THEN 1 ELSE 0 END) for Unified School District count and SUM(CASE WHEN DOC = 52 THEN 1 ELSE 0 END) for Elementary School District count."
        },
        "279": {
            "condition": "When filtering for Orange County and merged status",
            "operation": " use StatusType = 'Merged' AND County = 'Orange' in the WHERE clause."
        },
        "280": {
            "condition": "When performing division to calculate the ratio",
            "operation": " use explicit CAST(... AS REAL) to ensure proper numeric division instead of relying on implicit casting."
        },
        "281": {
            "condition": "When counting schools by district type",
            "operation": " use DOC column values 54 for Unified School District and 52 for Elementary School District as specified in the schema mapping."
        },
        "282": {
            "condition": "When the question asks for a ratio of merged Unified School District schools to merged Elementary School District schools in Orange County, When filtering for Orange County and merged status, When performing division to calculate the ratio, When counting schools by district type, When handling the Orange County filter",
            "operation": " use County = 'Orange' (not 'Orange County') as the exact literal value from the schema."
        },
        "283": {
            "condition": "When answering about \"different county has the most number of closed schools\"",
            "operation": " use a subquery to find the county with the maximum count of closed schools instead of direct grouping in the main query."
        },
        "284": {
            "condition": "When selecting output columns",
            "operation": " use DISTINCT \"County\", \"School\", \"ClosedDate\" instead of county, COUNT(*) as school_count, school_name, closure_date."
        },
        "285": {
            "condition": "When filtering for closed schools",
            "operation": " include \"StatusType\" = 'Closed' condition in both main query and subquery."
        },
        "286": {
            "condition": "When handling school names",
            "operation": " add \"School\" IS NOT NULL condition to exclude null school names."
        },
        "287": {
            "condition": "When finding the target county",
            "operation": " use WHERE \"County\" = (subquery) to filter for the county with most closed schools instead of GROUP BY county."
        },
        "288": {
            "condition": "When ordering and limiting",
            "operation": " remove ORDER BY and LIMIT from main query as limiting is handled through the subquery."
        },
        "289": {
            "condition": "When answering about \"different county has the most number of closed schools\", When selecting output columns, When filtering for closed schools, When handling school names, When finding the target county, When ordering and limiting, When counting closed schools per county",
            "operation": " count using the canonical key for schools in the subquery to determine the county with maximum closures."
        },
        "290": {
            "condition": "When answering about \"postal street address\" and \"school name\" for schools ranked by math average",
            "operation": " select T2.MailStreet and T2.School as output columns."
        },
        "291": {
            "condition": "When combining SAT scores and school information",
            "operation": " link T1 (satscores) and T2 (schools) using T1.cds = T2.CDSCode with inner matching."
        },
        "292": {
            "condition": "When the question asks for the 7th highest math average",
            "operation": " rank rows by T1.AvgScrMath in descending order and take the row at position 7 (using LIMIT 6, 1)."
        },
        "293": {
            "condition": "When answering about \"postal street address\" and \"school name\" for schools ranked by math average, When combining SAT scores and school information, When the question asks for the 7th highest math average, When handling identifier delimiters",
            "operation": " use exact tokens T1.cds and T2.CDSCode without changing their case or quoting."
        },
        "294": {
            "condition": "When answering about \"postal street address for the school with the 7th highest Math average\"",
            "operation": " make sure the output order: T2.MailStreet, T2.School"
        },
        "295": {
            "condition": "When the question asks for the 7th highest Math average",
            "operation": " rank rows by T1.AvgScrMath in descending order and take the row at position 7 (using LIMIT 6, 1 to skip first 6 rows and take 1 row)"
        },
        "296": {
            "condition": "When answering about \"postal street address for the school with the 7th highest Math average\", When the question asks for the 7th highest Math average, When combining satscores (T1) and schools (T2) tables",
            "operation": " link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match)"
        },
        "297": {
            "condition": "When answering about school addresses and reading scores",
            "operation": " combine tables satscores as T1 and schools as T2 using inner match where T1.cds equals T2.CDSCode."
        },
        "298": {
            "condition": "When filtering for valid reading scores",
            "operation": " include only rows where T1.AvgScrRead is not null."
        },
        "299": {
            "condition": "When ordering by reading performance",
            "operation": " sort rows by T1.AvgScrRead in ascending order to find the lowest score."
        },
        "300": {
            "condition": "When selecting output columns",
            "operation": " return T2.MailStreet for mailing street address and T2.School for school name."
        },
        "301": {
            "condition": "When answering about school addresses and reading scores, When filtering for valid reading scores, When ordering by reading performance, When selecting output columns, When limiting results",
            "operation": " return only the first row after ordering to get the single school with the lowest average reading score."
        },
        "302": {
            "condition": "When answering about schools with SAT scores",
            "operation": " join \"satscores\" as T1 with \"schools\" as T2 where T1.cds equals T2.CDSCode to combine SAT and school information."
        },
        "303": {
            "condition": "When calculating total SAT scores",
            "operation": " compute the sum of T1.AvgScrRead, T1.AvgScrMath, and T1.AvgScrWrite instead of using a precomputed total_sat_score column."
        },
        "304": {
            "condition": "When filtering by mailing city",
            "operation": " use T2.MailCity instead of city and match exactly 'Lakeport' with proper case."
        },
        "305": {
            "condition": "When counting schools",
            "operation": " count T1.cds (the canonical key) instead of using COUNT(*) to ensure accurate school counting."
        },
        "306": {
            "condition": "When answering about schools with SAT scores, When calculating total SAT scores, When filtering by mailing city, When counting schools, When applying SAT score threshold",
            "operation": " ensure the calculated total SAT score is greater than or equal to 1500."
        },
        "307": {
            "condition": "When answering about \"test takers at schools in Fresno\"",
            "operation": " make sure the output order: T1.NumTstTakr"
        },
        "308": {
            "condition": "When the question mentions \"test takers\"",
            "operation": " \"test takers\" actually means \"T1.NumTstTakr in schema\""
        },
        "309": {
            "condition": "When the question mentions \"mailing city address is in Fresno\"",
            "operation": " \"mailing city address\" actually means \"T2.MailCity in schema\" and use exact literal 'Fresno'"
        },
        "310": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)"
        },
        "311": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "312": {
            "condition": "When answering about \"test takers at schools in Fresno\", When the question mentions \"test takers\", When the question mentions \"mailing city address is in Fresno\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Fresno'"
        },
        "313": {
            "condition": "When selecting school information",
            "operation": " use column \"School\" instead of \"school_name\" and column \"MailZip\" instead of \"zip_code\"."
        },
        "314": {
            "condition": "When filtering by administrator name \"Avetik Atoian\"",
            "operation": " split into separate conditions for first name \"AdmFName1 = 'Avetik'\" and last name \"AdmLName1 = 'Atoian'\"."
        },
        "315": {
            "condition": "When selecting school information, When filtering by administrator name \"Avetik Atoian\", When outputting results",
            "operation": " maintain the column order with \"School\" first followed by \"MailZip\"."
        },
        "316": {
            "condition": "When the question mentions \"mailing state address in California\"",
            "operation": " use the exact literal 'CA' instead of 'California' and reference the column \"MailState\" exactly as shown in the schema."
        },
        "317": {
            "condition": "When counting schools by county",
            "operation": " use conditional aggregation with SUM(CASE WHEN County = 'Colusa' THEN 1 ELSE 0 END) and SUM(CASE WHEN County = 'Humboldt' THEN 1 ELSE 0 END) instead of separate subqueries."
        },
        "318": {
            "condition": "When calculating ratios",
            "operation": " cast the numerator to REAL to ensure proper decimal division instead of integer division."
        },
        "319": {
            "condition": "When the question mentions \"mailing state address in California\", When counting schools by county, When calculating ratios, When referencing column names",
            "operation": " use exact case-sensitive identifiers \"County\" and \"MailState\" as shown in the schema, not lowercase versions."
        },
        "320": {
            "condition": "When counting schools",
            "operation": " count using the canonical key \"CDSCode\" instead of counting all rows to ensure only non-null values are counted."
        },
        "321": {
            "condition": "When filtering for California mailing addresses",
            "operation": " use \"MailState = 'CA'\" instead of \"mailing_state = 'California'\" to match the correct state abbreviation format."
        },
        "322": {
            "condition": "When filtering for active schools",
            "operation": " include the condition \"StatusType = 'Active'\" to only count schools with active status."
        },
        "323": {
            "condition": "When referring to column names",
            "operation": " use exact case-sensitive identifiers \"City\" and \"MailState\" instead of lowercase versions."
        },
        "324": {
            "condition": "When counting schools, When filtering for California mailing addresses, When filtering for active schools, When referring to column names, When the question asks about schools in San Joaquin city",
            "operation": " filter using \"City = 'San Joaquin'\" with exact case and spelling."
        },
        "325": {
            "condition": "When answering about phone number and extension number for schools",
            "operation": " select \"T2\".\"Phone\" and \"T2\".\"Ext\" as output columns."
        },
        "326": {
            "condition": "When combining SAT scores and schools data",
            "operation": " link rows where \"T1\".\"cds\" equals \"T2\".\"CDSCode\" and keep only matching pairs (inner join)."
        },
        "327": {
            "condition": "When ranking schools by average writing score",
            "operation": " order rows by \"T1\".\"AvgScrWrite\" in descending order."
        },
        "328": {
            "condition": "When the question asks for the 333rd highest ranked school",
            "operation": " take 1 row starting from position 333 (using LIMIT 332, 1 syntax)."
        },
        "329": {
            "condition": "When answering about phone number and extension number for schools, When combining SAT scores and schools data, When ranking schools by average writing score, When the question asks for the 333rd highest ranked school, When handling identifier delimiters",
            "operation": " use double quotes exactly as shown in the schema (\"T1\", \"T2\", \"Phone\", \"Ext\", \"cds\", \"CDSCode\", \"AvgScrWrite\")."
        },
        "330": {
            "condition": "When the question asks for phone number and extension number",
            "operation": " use column aliases \"Phone\" and \"Ext\" instead of \"phone_number\" and \"extension\"."
        },
        "331": {
            "condition": "When the question asks for school name",
            "operation": " use column alias \"School\" instead of \"school_name\"."
        },
        "332": {
            "condition": "When the question asks for phone number and extension number, When the question asks for school name, When filtering by zip code '95203-3704'",
            "operation": " use column \"Zip\" instead of \"zip_code\" and maintain the exact literal value '95203-3704'."
        },
        "333": {
            "condition": "When the question asks for website information from schools",
            "operation": " use the exact column name \"Website\" from table \"schools\" (T1)."
        },
        "334": {
            "condition": "When the question mentions administrator names like \"Mike Larson\" and \"Dante Alvarez\"",
            "operation": " split these into separate first and last name components using columns \"AdmFName1\" and \"AdmLName1\"."
        },
        "335": {
            "condition": "When matching \"Mike Larson\"",
            "operation": " use the compound condition (\"AdmFName1\" = 'Mike' AND \"AdmLName1\" = 'Larson')."
        },
        "336": {
            "condition": "When matching \"Dante Alvarez\"",
            "operation": " use the compound condition (\"AdmFName1\" = 'Dante' AND \"AdmLName1\" = 'Alvarez')."
        },
        "337": {
            "condition": "When the question asks for website information from schools, When the question mentions administrator names like \"Mike Larson\" and \"Dante Alvarez\", When matching \"Mike Larson\", When matching \"Dante Alvarez\", When combining multiple administrator conditions",
            "operation": " use OR logic to include schools matching either administrator pair."
        },
        "338": {
            "condition": "When the question mentions \"located in San Joaquin\"",
            "operation": " use column \"County\" with exact value 'San Joaquin' for filtering."
        },
        "339": {
            "condition": "When the question mentions \"partially virtual\"",
            "operation": " use column \"Virtual\" with exact value 'P' for filtering."
        },
        "340": {
            "condition": "When the question mentions \"chartered schools\"",
            "operation": " use column \"Charter\" with exact value 1 for filtering."
        },
        "341": {
            "condition": "When the question asks for \"websites\"",
            "operation": " select column \"Website\" as the output."
        },
        "342": {
            "condition": "When the question mentions \"located in San Joaquin\", When the question mentions \"partially virtual\", When the question mentions \"chartered schools\", When the question asks for \"websites\", When filtering for multiple conditions",
            "operation": " apply all filters simultaneously (County = 'San Joaquin', Virtual = 'P', and Charter = 1)."
        },
        "343": {
            "condition": "When counting schools",
            "operation": " count the specific non-null values of \"School\" column instead of counting all rows."
        },
        "344": {
            "condition": "When filtering by city Hickman",
            "operation": " use exact literal 'Hickman' for the \"City\" column."
        },
        "345": {
            "condition": "When identifying charter schools",
            "operation": " use the flag condition \"Charter\" = 1 instead of district descriptions."
        },
        "346": {
            "condition": "When filtering by district",
            "operation": " use district code \"DOC\" = 52 instead of city name or district descriptions."
        },
        "347": {
            "condition": "When counting schools, When filtering by city Hickman, When identifying charter schools, When filtering by district, When the question asks about charter schools in a specific city owned by a district",
            "operation": " ensure all three conditions are applied - \"City\" = 'Hickman', \"Charter\" = 1, and \"DOC\" = 52."
        },
        "348": {
            "condition": "When answering about non-chartered schools in Los Angeles county",
            "operation": " use T2.\"County\" = 'Los Angeles' instead of county = 'Los Angeles'."
        },
        "349": {
            "condition": "When identifying non-chartered schools",
            "operation": " use T2.Charter = 0 instead of charter = 'No'."
        },
        "350": {
            "condition": "When calculating free meal percentage",
            "operation": " compute CAST(T1.\"Free Meal Count (K-12)\" AS REAL) * 100 / T1.\"Enrollment (K-12)\" < 0.18 instead of using a pre-calculated percent_free_meals column."
        },
        "351": {
            "condition": "When combining frpm and schools tables",
            "operation": " perform an INNER JOIN on T1.CDSCode = T2.CDSCode to link related records."
        },
        "352": {
            "condition": "When counting schools",
            "operation": " count T2.School instead of using COUNT(*)."
        },
        "353": {
            "condition": "When answering about non-chartered schools in Los Angeles county, When identifying non-chartered schools, When calculating free meal percentage, When combining frpm and schools tables, When counting schools, When filtering by grade levels",
            "operation": " do not include grade_level filters as the question specifies grades 1 through 12 but the calculation uses K-12 enrollment data."
        },
        "354": {
            "condition": "When the question asks for administrator names",
            "operation": " use both \"AdmFName1\" and \"AdmLName1\" columns instead of a single administrator_name field."
        },
        "355": {
            "condition": "When filtering for chartered schools",
            "operation": " apply both conditions \"Charter = 1\" and \"CharterNum = '00D2'\" instead of only checking charter number."
        },
        "356": {
            "condition": "When selecting school information",
            "operation": " use exact column names \"School\" for school name and \"City\" for city instead of generic names."
        },
        "357": {
            "condition": "When the question asks for administrator names, When filtering for chartered schools, When selecting school information, When answering about chartered schools with specific charter number",
            "operation": " ensure the output order includes administrator first name, administrator last name, school name, and city in that sequence."
        },
        "358": {
            "condition": "When the question mentions \"mailing city\"",
            "operation": " \"mailing city\" actually means \"MailCity\" in the schools table."
        },
        "359": {
            "condition": "When the question mentions \"charter number\"",
            "operation": " \"charter number\" actually means \"CharterNum\" in the schools table."
        },
        "360": {
            "condition": "When the question mentions \"mailing city\", When the question mentions \"charter number\", When filtering for schools with a specific mailing city and charter number",
            "operation": " use exact string literals 'Hickman' for MailCity and '00D4' for CharterNum with AND conditions."
        },
        "361": {
            "condition": "When the question mentions \"Santa Clara County\"",
            "operation": " \"County\" actually means \"County\" in schema and must exactly match the literal 'Santa Clara'."
        },
        "362": {
            "condition": "When the question asks about charter schools",
            "operation": " use \"Charter = 1\" instead of text comparisons to match the boolean column format."
        },
        "363": {
            "condition": "When counting occurrences of \"locally funded\" schools",
            "operation": " use SUM(CASE WHEN FundingType = 'Locally funded' THEN 1 ELSE 0 END) with explicit ELSE 0 instead of COUNT with conditional."
        },
        "364": {
            "condition": "When calculating percentage ratios",
            "operation": " cast the numerator to REAL type instead of using decimal literals for proper floating-point division."
        },
        "365": {
            "condition": "When referencing column names",
            "operation": " use exact identifiers \"FundingType\" and \"County\" instead of lowercase versions."
        },
        "366": {
            "condition": "When the question mentions \"Santa Clara County\", When the question asks about charter schools, When counting occurrences of \"locally funded\" schools, When calculating percentage ratios, When referencing column names, When the query returns a single calculated value",
            "operation": " do not use any alias for the result column."
        },
        "367": {
            "condition": "When the question asks for a ratio in percentage of schools with specific funding type compared to other funding types",
            "operation": " compute (count of rows where \"FundingType\" = 'Locally funded') divided by (count of rows where \"FundingType\" != 'Locally funded') and multiply by 100.0."
        },
        "368": {
            "condition": "When filtering for Santa Clara County schools",
            "operation": " include only rows where \"County\" = 'Santa Clara'."
        },
        "369": {
            "condition": "When filtering for charter schools",
            "operation": " include only rows where \"Charter\" = 1."
        },
        "370": {
            "condition": "When casting numeric results",
            "operation": " explicitly cast the sum as REAL type for proper division."
        },
        "371": {
            "condition": "When the question asks for a ratio in percentage of schools with specific funding type compared to other funding types, When filtering for Santa Clara County schools, When filtering for charter schools, When casting numeric results, When referencing columns",
            "operation": " use the exact column names without table aliases for consistency with simplified query structure."
        },
        "372": {
            "condition": "When counting schools",
            "operation": " count non-null values of \"School\" column instead of all rows."
        },
        "373": {
            "condition": "When filtering by opening date between 1/1/2000 to 12/31/2005",
            "operation": " extract year using strftime('%Y', OpenDate) instead of full date range comparison."
        },
        "374": {
            "condition": "When referencing county",
            "operation": " use exact column name \"County\" with proper case sensitivity instead of lowercase 'county'."
        },
        "375": {
            "condition": "When referencing funding type",
            "operation": " use exact column name \"FundingType\" with proper case sensitivity instead of lowercase 'funding_type'."
        },
        "376": {
            "condition": "When counting schools, When filtering by opening date between 1/1/2000 to 12/31/2005, When referencing county, When referencing funding type, When filtering for directly funded schools",
            "operation": " use exact literal value 'Directly funded' instead of 'direct'."
        },
        "377": {
            "condition": "When counting schools rather than summing amounts",
            "operation": " use COUNT(School) instead of SUM(amount)."
        },
        "378": {
            "condition": "When accessing school closure data",
            "operation": " query from the schools table instead of closures table."
        },
        "379": {
            "condition": "When filtering by year 1989",
            "operation": " use strftime('%Y', ClosedDate) = '1989' to extract year from the ClosedDate field rather than using a numeric year column."
        },
        "380": {
            "condition": "When filtering by city San Francisco",
            "operation": " use City = 'San Francisco' with exact capitalization to match the correct column name."
        },
        "381": {
            "condition": "When counting schools rather than summing amounts, When accessing school closure data, When filtering by year 1989, When filtering by city San Francisco, When filtering by district type Community College District",
            "operation": " use DOCType = 'Community College District' to use the appropriate column name for district type classification."
        },
        "382": {
            "condition": "When answering about school closures",
            "operation": " use table \"schools\" instead of \"school_closures\"."
        },
        "383": {
            "condition": "When filtering by county",
            "operation": " use column \"County\" exactly as shown in the schema."
        },
        "384": {
            "condition": "When filtering for 1980s closures",
            "operation": " use strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' to extract year from ClosedDate."
        },
        "385": {
            "condition": "When identifying closed schools",
            "operation": " filter for StatusType = 'Closed'."
        },
        "386": {
            "condition": "When filtering for Youth Authority Facilities",
            "operation": " use SOC = 11 instead of the text literal."
        },
        "387": {
            "condition": "When counting school closures",
            "operation": " count using COUNT(School) as the canonical key."
        },
        "388": {
            "condition": "When grouping results by county",
            "operation": " group by \"County\"."
        },
        "389": {
            "condition": "When finding the county with most closures",
            "operation": " order by COUNT(School) DESC and take the top result."
        },
        "390": {
            "condition": "When answering about school closures, When filtering by county, When filtering for 1980s closures, When identifying closed schools, When filtering for Youth Authority Facilities, When counting school closures, When grouping results by county, When finding the county with most closures, When selecting output columns",
            "operation": " include \"County\" and the count without aliases."
        },
        "391": {
            "condition": "When the question asks for \"National Center for Educational Statistics school district identification number\"",
            "operation": " select the exact column \"NCESDist\" from the schools table."
        },
        "392": {
            "condition": "When the question mentions schools with a \"School Ownership Code\"",
            "operation": " filter using the exact literal value 31 for the SOC column (SOC = 31)."
        },
        "393": {
            "condition": "When the question asks for \"National Center for Educational Statistics school district identification number\", When the question mentions schools with a \"School Ownership Code\", When the question mentions schools that are \"part of the State Special Schools\"",
            "operation": " this condition is already encoded in the SOC = 31 filter, so no additional filtering is needed."
        },
        "394": {
            "condition": "When counting schools",
            "operation": " use COUNT(\"School\") instead of conditional CASE expressions for status values."
        },
        "395": {
            "condition": "When filtering by status",
            "operation": " use \"StatusType\" IN ('Active', 'Closed') instead of separate conditional counts."
        },
        "396": {
            "condition": "When filtering for Alpine county",
            "operation": " use \"county\" = 'Alpine' exactly as specified."
        },
        "397": {
            "condition": "When applying SOC criteria",
            "operation": " include \"SOC\" = 69 filter as required."
        },
        "398": {
            "condition": "When the question asks about District Community Day Schools",
            "operation": " do not filter by school_type as this is not needed according to the schema and amends."
        },
        "399": {
            "condition": "When counting schools, When filtering by status, When filtering for Alpine county, When applying SOC criteria, When the question asks about District Community Day Schools, When producing output",
            "operation": " count all schools meeting the combined criteria of county, status types, and SOC value."
        },
        "400": {
            "condition": "When answering about district codes",
            "operation": " select \"T1.District Code\" instead of district_code."
        },
        "401": {
            "condition": "When combining frpm and schools tables",
            "operation": " link rows where \"T1.CDSCode\" equals \"T2.CDSCode\" exactly and keep only matching pairs (inner match)."
        },
        "402": {
            "condition": "When filtering for city of Fresno",
            "operation": " use \"T2.City = 'Fresno'\" with exact case and punctuation."
        },
        "403": {
            "condition": "When answering about district codes, When combining frpm and schools tables, When filtering for city of Fresno, When filtering for schools without magnet programs",
            "operation": " use \"T2.Magnet = 0\" instead of checking for 'No' text values."
        },
        "404": {
            "condition": "When the question asks for enrollment count of students aged 5-17",
            "operation": " use T1.\"Enrollment (Ages 5-17)\" instead of counting records to get actual enrollment data."
        },
        "405": {
            "condition": "When combining enrollment and school information",
            "operation": " join frpm as T1 with schools as T2 using T1.CDSCode = T2.CDSCode to properly relate enrollment records to their corresponding schools."
        },
        "406": {
            "condition": "When identifying State Special School",
            "operation": " use T2.EdOpsCode = 'SSS' instead of school name comparison to use the correct column name and code value."
        },
        "407": {
            "condition": "When filtering by city Fremont",
            "operation": " use T2.City = 'Fremont' to reference the city column from the correct table."
        },
        "408": {
            "condition": "When the question asks for enrollment count of students aged 5-17, When combining enrollment and school information, When identifying State Special School, When filtering by city Fremont, When filtering for academic year 2014-2015",
            "operation": " use T1.\"Academic Year\" BETWEEN 2014 AND 2015 instead of string equality to use numeric range comparison for the year filter."
        },
        "409": {
            "condition": "When answering about free or reduced price meal count for ages 5 to 17",
            "operation": " select \"FRPM Count (Ages 5-17)\" from table frpm as T1 instead of free_or_reduced_price_meal_count from schools table."
        },
        "410": {
            "condition": "When the question mentions \"Youth Authority School\"",
            "operation": " \"Youth Authority School\" actually means T2.SOCType = 'Youth Authority Facilities' in schema."
        },
        "411": {
            "condition": "When the question mentions mailing street address \"PO Box 1040\"",
            "operation": " use T2.MailStreet = 'PO Box 1040' instead of mailing_street_address = 'PO Box 1040'."
        },
        "412": {
            "condition": "When combining T1 (frpm) and T2 (schools) for shared entities",
            "operation": " link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "413": {
            "condition": "When answering about free or reduced price meal count for ages 5 to 17, When the question mentions \"Youth Authority School\", When the question mentions mailing street address \"PO Box 1040\", When combining T1 (frpm) and T2 (schools) for shared entities, When filtering for age range",
            "operation": " do not include age_range = '5-17' filter as this is already encoded in the \"FRPM Count (Ages 5-17)\" column."
        },
        "414": {
            "condition": "When answering about the lowest grade for a specific school type and district",
            "operation": " use MIN(T1.\"Low Grade\") instead of MAX(grade) for the aggregate function and column selection."
        },
        "415": {
            "condition": "When combining school data with FRPM data",
            "operation": " join frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode to access the required information."
        },
        "416": {
            "condition": "When filtering by National Center for Educational Statistics school district identification number",
            "operation": " use T2.NCESDist = '0613360' instead of district_id = '0613360'."
        },
        "417": {
            "condition": "When answering about the lowest grade for a specific school type and district, When combining school data with FRPM data, When filtering by National Center for Educational Statistics school district identification number, When identifying District Special Education Consortia School type",
            "operation": " use T2.EdOpsCode = 'SPECON' instead of name = 'District Special Education Consortia School'."
        },
        "418": {
            "condition": "When answering about educational level name and school name",
            "operation": " make sure the output order: T2.School, T2.EILName"
        },
        "419": {
            "condition": "When the question mentions \"Breakfast Provision 2\"",
            "operation": " \"Breakfast Provision 2\" actually means T1.\"NSLP Provision Status\" = 'Breakfast Provision 2' in schema"
        },
        "420": {
            "condition": "When the question mentions \"county code 37\"",
            "operation": " \"county code 37\" actually means T1.\"County Code\" = 37 in schema"
        },
        "421": {
            "condition": "When combining T1 (frpm) and T2 (schools) for shared entities",
            "operation": " link rows where T1.CDSCode = T2.CDSCode exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "422": {
            "condition": "When answering about educational level name and school name, When the question mentions \"Breakfast Provision 2\", When the question mentions \"county code 37\", When combining T1 (frpm) and T2 (schools) for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for columns like T1.\"NSLP Provision Status\" and T1.\"County Code\""
        },
        "423": {
            "condition": "When the question mentions \"Breakfast Provision 2\"",
            "operation": " use the exact literal value 'Breakfast Provision 2' for filtering the \"NSLP Provision Status\" column."
        },
        "424": {
            "condition": "When filtering on numeric county codes",
            "operation": " use the numeric value 37 without quotes for the \"County Code\" column."
        },
        "425": {
            "condition": "When referencing column names with spaces",
            "operation": " use backticks around \"NSLP Provision Status\" instead of double quotes."
        },
        "426": {
            "condition": "When joining frpm and schools tables",
            "operation": " link rows where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match)."
        },
        "427": {
            "condition": "When the question mentions \"Breakfast Provision 2\", When filtering on numeric county codes, When referencing column names with spaces, When joining frpm and schools tables, When answering about educational level name and school name",
            "operation": " output T2.EILName and T2.School in that order."
        },
        "428": {
            "condition": "When answering about city location of schools",
            "operation": " select \"T2.City\" from the schools table instead of just \"city\" from schools alone."
        },
        "429": {
            "condition": "When combining frpm and schools tables",
            "operation": " join \"frpm AS T1\" with \"schools AS T2\" using inner join where \"T1.CDSCode = T2.CDSCode\" to match shared entities."
        },
        "430": {
            "condition": "When the question mentions \"Lunch Provision 2\"",
            "operation": " filter by \"T1.NSLP Provision Status = 'Lunch Provision 2'\" exactly as specified."
        },
        "431": {
            "condition": "When the question mentions \"high school level\"",
            "operation": " filter by \"T2.EILCode = 'HS'\" instead of level = 'High School'."
        },
        "432": {
            "condition": "When the question specifies lowest grade 9 and highest grade 12",
            "operation": " use \"T1.Low Grade = 9\" and \"T1.High Grade = 12\" instead of lowest_grade and highest_grade."
        },
        "433": {
            "condition": "When answering about city location of schools, When combining frpm and schools tables, When the question mentions \"Lunch Provision 2\", When the question mentions \"high school level\", When the question specifies lowest grade 9 and highest grade 12, When filtering by county",
            "operation": " keep \"T2.County = 'Merced'\" as specified in the question."
        },
        "434": {
            "condition": "When the question asks about schools and their Percent (%) Eligible FRPM (Ages 5-17)",
            "operation": " combine data from both \"frpm\" table as T1 and \"schools\" table as T2 using an inner match where T1.CDSCode = T2.CDSCode."
        },
        "435": {
            "condition": "When the question mentions \"schools served a grade span of Kindergarten to 9th grade\"",
            "operation": " filter for rows where T2.GSserved = 'K-9'."
        },
        "436": {
            "condition": "When the question mentions \"county of Los Angeles\"",
            "operation": " filter for rows where T2.County = 'Los Angeles'."
        },
        "437": {
            "condition": "When the question asks for \"Percent (%) Eligible FRPM (Ages 5-17)\"",
            "operation": " calculate it as (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\") instead of selecting a precomputed percentage column."
        },
        "438": {
            "condition": "When the question asks about schools and their Percent (%) Eligible FRPM (Ages 5-17), When the question mentions \"schools served a grade span of Kindergarten to 9th grade\", When the question mentions \"county of Los Angeles\", When the question asks for \"Percent (%) Eligible FRPM (Ages 5-17)\", When producing output",
            "operation": " return T2.School and the calculated percentage, without any ordering."
        },
        "439": {
            "condition": "When the question asks about \"grade span served\"",
            "operation": " use the exact column token \"GSserved\" instead of \"grade_span\"."
        },
        "440": {
            "condition": "When counting occurrences of grade span served",
            "operation": " use COUNT(\"GSserved\") without aliasing the count result."
        },
        "441": {
            "condition": "When grouping by grade span served",
            "operation": " group by the exact column \"GSserved\"."
        },
        "442": {
            "condition": "When ordering by count results",
            "operation": " order by COUNT(\"GSserved\") directly rather than using an alias."
        },
        "443": {
            "condition": "When the question asks about \"grade span served\", When counting occurrences of grade span served, When grouping by grade span served, When ordering by count results, When filtering for the city of Adelanto",
            "operation": " use the exact column token \"City\" and the exact literal value 'Adelanto'."
        },
        "444": {
            "condition": "When answering about \"most common type of grade span served in the city of Adelanto\"",
            "operation": " make sure the output order: GSserved only (without count aggregates)."
        },
        "445": {
            "condition": "When the question asks for \"most common\" type",
            "operation": " rank rows by count of GSserved in descending order and keep the first 1 row."
        },
        "446": {
            "condition": "When the question mentions \"city of Adelanto\"",
            "operation": " \"Adelanto\" actually means City = 'Adelanto' in schema."
        },
        "447": {
            "condition": "When answering about \"most common type of grade span served in the city of Adelanto\", When the question asks for \"most common\" type, When the question mentions \"city of Adelanto\", When the question asks for \"type of grade span served\"",
            "operation": " use the exact column token GSserved for grouping and selection."
        },
        "448": {
            "condition": "When the question asks about counties \"San Diego\" and \"Santa Barbara\"",
            "operation": " use exact literal values 'San Diego' and 'Santa Barbara' with the column \"County\"."
        },
        "449": {
            "condition": "When identifying schools without physical buildings",
            "operation": " use the condition \"Virtual\" = 'F' instead of physical_building = 'no'."
        },
        "450": {
            "condition": "When counting schools",
            "operation": " use COUNT(\"Virtual\") instead of COUNT(*) to count only virtual schools."
        },
        "451": {
            "condition": "When grouping results by county",
            "operation": " use the column \"County\" for grouping."
        },
        "452": {
            "condition": "When ordering results by count",
            "operation": " order by COUNT(\"Virtual\") in descending order to find the highest count."
        },
        "453": {
            "condition": "When selecting output columns",
            "operation": " include \"County\" and the count without aliases."
        },
        "454": {
            "condition": "When the question asks about counties \"San Diego\" and \"Santa Barbara\", When identifying schools without physical buildings, When counting schools, When grouping results by county, When ordering results by count, When selecting output columns, When combining conditions for multiple counties",
            "operation": " use (\"County\" = 'San Diego' OR \"County\" = 'Santa Barbara') instead of IN clause."
        },
        "455": {
            "condition": "When selecting columns for school information",
            "operation": " use \"School Type\" from table frpm, \"School Name\" from table frpm, and \"Latitude\" from table schools instead of school_name, latitude, and school_type."
        },
        "456": {
            "condition": "When combining school data from multiple tables",
            "operation": " perform an inner join between frpm table (as T1) and schools table (as T2) using the exact key equality T1.CDSCode = T2.CDSCode."
        },
        "457": {
            "condition": "When finding the school with the highest latitude",
            "operation": " order results by \"Latitude\" in descending order (DESC) instead of ascending order (ASC)."
        },
        "458": {
            "condition": "When selecting columns for school information, When combining school data from multiple tables, When finding the school with the highest latitude, When answering about the school with highest latitude",
            "operation": " make sure the output order is \"School Name\", \"Latitude\", and \"School Type\"."
        },
        "459": {
            "condition": "When answering about schools in California with lowest latitude",
            "operation": " make sure the output order: T2.City, T1.Low Grade, T1.School Name."
        },
        "460": {
            "condition": "When the question mentions \"state of California\"",
            "operation": " \"California\" actually means \"T2.State = 'CA'\" in schema."
        },
        "461": {
            "condition": "When combining T1 (frpm) and T2 (schools) for shared entities",
            "operation": " link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match)."
        },
        "462": {
            "condition": "When the question asks for \"lowest latitude coordinates\"",
            "operation": " order rows by T2.Latitude in ascending direction and keep the first 1 row."
        },
        "463": {
            "condition": "When answering about schools in California with lowest latitude, When the question mentions \"state of California\", When combining T1 (frpm) and T2 (schools) for shared entities, When the question asks for \"lowest latitude coordinates\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for columns like T1.\"Low Grade\" and T1.\"School Name\"."
        },
        "464": {
            "condition": "When the question asks about \"grade span offered\"",
            "operation": " use the exact column name \"GSoffered\" from the schools table."
        },
        "465": {
            "condition": "When the question asks for the school with the \"highest longitude\"",
            "operation": " use the absolute value of longitude (ABS(longitude)) for ordering to find the maximum absolute longitude value."
        },
        "466": {
            "condition": "When the question asks about \"grade span offered\", When the question asks for the school with the \"highest longitude\", When ordering by longitude to find the highest value",
            "operation": " sort in descending order (DESC) and take only the first result (LIMIT 1)."
        },
        "467": {
            "condition": "When answering about schools with magnet programs and K-8 grade span",
            "operation": " join \"frpm\" as T1 with \"schools\" as T2 using T1.CDSCode = T2.CDSCode to combine data from both tables."
        },
        "468": {
            "condition": "When filtering for magnet schools with K-8 grade span",
            "operation": " apply conditions T2.Magnet = 1, T2.GSoffered = 'K-8', and T1.\"NSLP Provision Status\" = 'Multiple Provision Types'."
        },
        "469": {
            "condition": "When counting schools per city",
            "operation": " use T2.City for grouping and count using T2.CDSCode as the canonical key instead of counting all rows."
        },
        "470": {
            "condition": "When the question asks for number of cities and schools per city",
            "operation": " output T2.City and COUNT(T2.CDSCode) without additional ordering."
        },
        "471": {
            "condition": "When answering about schools with magnet programs and K-8 grade span, When filtering for magnet schools with K-8 grade span, When counting schools per city, When the question asks for number of cities and schools per city, When handling identifier delimiters",
            "operation": " preserve double quotes for \"NSLP Provision Status\" exactly as shown in the schema."
        },
        "472": {
            "condition": "When answering about \"most common first names among school administrators\"",
            "operation": " select \"AdmFName1\" and \"District\" columns instead of generic \"first_name\" and \"district\"."
        },
        "473": {
            "condition": "When counting administrator first names",
            "operation": " use DISTINCT to count unique values of \"admfname1\" instead of counting all rows."
        },
        "474": {
            "condition": "When combining data from multiple tables",
            "operation": " join the main \"schools\" table (aliased as T1) with a subquery using INNER JOIN on T1.AdmFName1 = T2.admfname1 instead of querying only one table."
        },
        "475": {
            "condition": "When finding the top 2 most common names",
            "operation": " perform aggregation in a subquery that groups by \"admfname1\", orders by COUNT(admfname1) DESC, and applies LIMIT 2 instead of performing these operations directly on the main result set."
        },
        "476": {
            "condition": "When answering about \"most common first names among school administrators\", When counting administrator first names, When combining data from multiple tables, When finding the top 2 most common names, When handling identifier delimiters",
            "operation": " use exact column names \"AdmFName1\" and \"District\" as shown in the schema, without changing case or quoting."
        },
        "477": {
            "condition": "When calculating Percent (%) Eligible Free (K-12)",
            "operation": " compute the expression Free Meal Count (K-12) * 100 / Enrollment (K-12) instead of using the pre-calculated column."
        },
        "478": {
            "condition": "When selecting the district code",
            "operation": " use the exact column name \"District Code\" instead of \"district_code\"."
        },
        "479": {
            "condition": "When querying about schools",
            "operation": " use table \"frpm\" as T1 as the main table instead of only querying the schools table."
        },
        "480": {
            "condition": "When combining frpm and schools data",
            "operation": " perform an inner join where T1.CDSCode = T2.CDSCode to match records between tables."
        },
        "481": {
            "condition": "When calculating Percent (%) Eligible Free (K-12), When selecting the district code, When querying about schools, When combining frpm and schools data, When filtering by administrator first name",
            "operation": " use T2.AdmFName1 = 'Alusine' with exact case and spelling instead of administrator_first_name."
        },
        "482": {
            "condition": "When the question asks for \"Percent (%) Eligible Free (K-12)\"",
            "operation": " use the expression T1.\"Free Meal Count (K-12)\" * 100 / T1.\"Enrollment (K-12)\" without an alias instead of the existing column Percent (%) Eligible Free (K-12)."
        },
        "483": {
            "condition": "When the question asks for district code",
            "operation": " include T1.\"District Code\" in the output."
        },
        "484": {
            "condition": "When combining frpm (T1) and schools (T2) tables",
            "operation": " link rows where T1.CDSCode = T2.CDSCode using an inner match."
        },
        "485": {
            "condition": "When the question asks for \"Percent (%) Eligible Free (K-12)\", When the question asks for district code, When combining frpm (T1) and schools (T2) tables, When filtering for administrator first name",
            "operation": " use T2.AdmFName1 = 'Alusine' exactly as specified."
        },
        "486": {
            "condition": "When the question asks for administrator's last name",
            "operation": " use column \"AdmLName1\" instead of \"administrator_last_name\"."
        },
        "487": {
            "condition": "When the question asks for district",
            "operation": " use column \"District\" instead of \"district\"."
        },
        "488": {
            "condition": "When the question asks for county",
            "operation": " use column \"County\" instead of \"county\"."
        },
        "489": {
            "condition": "When the question asks for school name",
            "operation": " use column \"School\" instead of \"school_name\"."
        },
        "490": {
            "condition": "When the question asks for administrator's last name, When the question asks for district, When the question asks for county, When the question asks for school name, When filtering by charter number 40",
            "operation": " use condition \"CharterNum = '0040'\" with string literal '0040' instead of numeric value 40."
        },
        "491": {
            "condition": "When answering about email addresses of school administrators",
            "operation": " select both \"T2.AdmEmail1\" and \"T2.AdmEmail2\" columns instead of just \"email\"."
        },
        "492": {
            "condition": "When combining school data from multiple tables",
            "operation": " join \"frpm AS T1\" with \"schools AS T2\" using inner join where \"T1.CDSCode = T2.CDSCode\" to match records."
        },
        "493": {
            "condition": "When filtering by county",
            "operation": " use \"T2.County = 'San Bernardino'\" exactly as specified."
        },
        "494": {
            "condition": "When filtering by city",
            "operation": " use \"T2.City = 'San Bernardino'\" instead of 'San Bernardino City Unified'."
        },
        "495": {
            "condition": "When filtering by district and school organization codes",
            "operation": " include conditions \"T2.DOC = 54\" and \"T2.SOC = 62\"."
        },
        "496": {
            "condition": "When filtering by opening date between 2009 and 2010",
            "operation": " use year-based filtering with \"strftime('%Y', T2.OpenDate) BETWEEN '2009' AND '2010'\" instead of exact date ranges."
        },
        "497": {
            "condition": "When the question mentions school types",
            "operation": " do not apply school_type filters as they are not required."
        },
        "498": {
            "condition": "When answering about email addresses of school administrators, When combining school data from multiple tables, When filtering by county, When filtering by city, When filtering by district and school organization codes, When filtering by opening date between 2009 and 2010, When the question mentions school types, When the question mentions administrators",
            "operation": " do not apply administrator = 'yes' filter as it is not required."
        },
        "499": {
            "condition": "When answering about the highest number of test takers with SAT scores \u22651500",
            "operation": " rank schools by T1.NumGE1500 in descending order and keep the first row."
        },
        "500": {
            "condition": "When combining SAT scores and schools data",
            "operation": " link rows where T1.cds = T2.CDSCode exactly and keep only matching pairs (inner match)."
        },
        "501": {
            "condition": "When selecting output columns",
            "operation": " return T2.AdmEmail1 and T2.School instead of school_name and administrator_email."
        },
        "502": {
            "condition": "When answering about the highest number of test takers with SAT scores \u22651500, When combining SAT scores and schools data, When selecting output columns, When ordering results",
            "operation": " use T1.NumGE1500 DESC instead of filtering by sat_score >= 1500 or maximum test takers count."
        },
        "503": {
            "condition": "When answering about \"administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500\"",
            "operation": " make sure the output order: AdmEmail1, School"
        },
        "504": {
            "condition": "When the question asks for the school with the highest number of test takers who received SAT scores of at least 1500",
            "operation": " rank rows by T1.NumGE1500 in descending order and keep the first 1 row."
        },
        "505": {
            "condition": "When answering about \"administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500\", When the question asks for the school with the highest number of test takers who received SAT scores of at least 1500, When combining satscores (T1) and schools (T2) for shared entities",
            "operation": " link rows where T1.cds = T2.CDSCode exactly as shown; keep only matching pairs (inner match)."
        }
    },
    "financial": {
        "0": {
            "condition": "When combining district and account tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "1": {
            "condition": "When counting accounts",
            "operation": " compute the number of rows using T2.account_id as the counting key."
        },
        "2": {
            "condition": "When the question mentions \"East Bohemia region\"",
            "operation": " \"East Bohemia\" actually means T1.A3 = 'east Bohemia' with exact case sensitivity."
        },
        "3": {
            "condition": "When combining district and account tables, When counting accounts, When the question mentions \"East Bohemia region\", When the question mentions \"choose issuance after transaction\"",
            "operation": " this actually means T2.frequency = 'POPLATEK PO OBRATU' with exact literal value."
        },
        "4": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "5": {
            "condition": "When answering about accounts with loans",
            "operation": " add INNER JOIN loan AS T2 ON T1.account_id = T2.account_id to link accounts to loans."
        },
        "6": {
            "condition": "When answering about accounts in a region",
            "operation": " add INNER JOIN district AS T3 ON T1.district_id = T3.district_id to link accounts to districts."
        },
        "7": {
            "condition": "When filtering by region 'Prague'",
            "operation": " use WHERE T3.A3 = 'Prague' instead of filtering directly on accounts table."
        },
        "8": {
            "condition": "When counting accounts, When answering about accounts with loans, When answering about accounts in a region, When filtering by region 'Prague', When determining loan eligibility",
            "operation": " do not filter by loan_eligible = 'yes' as the join to loan table implicitly filters for accounts with loans."
        },
        "9": {
            "condition": "When answering about average unemployment ratio comparison between 1995 and 1996",
            "operation": " use IIF(AVG(A13) > AVG(A12), '1996', '1995') to return a single conditional value instead of multiple rows."
        },
        "10": {
            "condition": "When the question mentions \"unemployment ratio\"",
            "operation": " use columns A13 and A12 from the district table instead of unemployment_ratio from unemployment_data."
        },
        "11": {
            "condition": "When computing averages for comparison",
            "operation": " calculate AVG(A13) for 1996 and AVG(A12) for 1995 from the district table."
        },
        "12": {
            "condition": "When the data source is specified",
            "operation": " query from the district table instead of unemployment_data."
        },
        "13": {
            "condition": "When answering about average unemployment ratio comparison between 1995 and 1996, When the question mentions \"unemployment ratio\", When computing averages for comparison, When the data source is specified, When returning a single conditional result",
            "operation": " remove GROUP BY, WHERE filters for specific years, and ORDER BY/LIMIT clauses since the IIF function handles the comparison directly."
        },
        "14": {
            "condition": "When counting districts",
            "operation": " count distinct T2.district_id instead of counting all rows."
        },
        "15": {
            "condition": "When combining client and district tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "16": {
            "condition": "When filtering for female clients",
            "operation": " use T1.gender = 'F' to specifically select female records."
        },
        "17": {
            "condition": "When counting districts, When combining client and district tables, When filtering for female clients, When filtering for salary range between 6000 and 10000",
            "operation": " use T2.A11 BETWEEN 6000 AND 10000 instead of separate greater than and less than conditions."
        },
        "18": {
            "condition": "When counting customers",
            "operation": " use COUNT(T1.client_id) instead of COUNT(*) to count specific non-null values."
        },
        "19": {
            "condition": "When the question mentions \"customers\"",
            "operation": " it refers to the \"client\" table which should be aliased as T1."
        },
        "20": {
            "condition": "When the question mentions \"region\" or \"North Bohemia\"",
            "operation": " it refers to district table column T2.A3 with value 'north Bohemia' (case-sensitive)."
        },
        "21": {
            "condition": "When the question mentions \"gender\" or \"male\"",
            "operation": " it refers to client table column T1.gender with value 'M' (not 'male')."
        },
        "22": {
            "condition": "When the question mentions \"average salary greater than 8000\"",
            "operation": " it refers to district table column T2.A11 with condition > 8000."
        },
        "23": {
            "condition": "When combining client and district information",
            "operation": " use INNER JOIN where T1.district_id = T2.district_id to link the tables."
        },
        "24": {
            "condition": "When counting customers, When the question mentions \"customers\", When the question mentions \"region\" or \"North Bohemia\", When the question mentions \"gender\" or \"male\", When the question mentions \"average salary greater than 8000\", When combining client and district information, When answering about customer counts",
            "operation": " ensure the output is a single count value using the correct counting method."
        },
        "25": {
            "condition": "When answering about account numbers",
            "operation": " use \"account_id\" instead of \"account_number\" in the output."
        },
        "26": {
            "condition": "When the question mentions \"female clients\"",
            "operation": " filter using \"gender = 'F'\" instead of \"gender = 'Female'\"."
        },
        "27": {
            "condition": "When the question asks for \"oldest\"",
            "operation": " order by \"birth_date ASC\" to find the earliest birth date."
        },
        "28": {
            "condition": "When combining tables",
            "operation": " link T1 (account) and T2 (district) using \"T1.district_id = T2.district_id\", link T1 and T3 (disp) using \"T1.account_id = T3.account_id\", and link T3 and T4 (client) using \"T3.client_id = T4.client_id\"."
        },
        "29": {
            "condition": "When filtering for district",
            "operation": " use \"T2.district_id = (subquery)\" where the subquery finds the district_id from client where gender = 'F' ordered by birth_date ASC with LIMIT 1."
        },
        "30": {
            "condition": "When calculating salary gap",
            "operation": " use \"(SELECT MAX(A11) - MIN(A11) FROM district)\" instead of direct column calculations."
        },
        "31": {
            "condition": "When answering about account numbers, When the question mentions \"female clients\", When the question asks for \"oldest\", When combining tables, When filtering for district, When calculating salary gap, When ordering results",
            "operation": " use \"T2.A11 DESC\" instead of age-based ordering."
        },
        "32": {
            "condition": "When answering about \"female clients who are oldest and has lowest average salary\"",
            "operation": " make sure to filter for gender = 'F' exactly as specified."
        },
        "33": {
            "condition": "When the question asks for \"account numbers\"",
            "operation": " use the exact identifier \"account_id\" from the account table."
        },
        "34": {
            "condition": "When the question mentions \"oldest\"",
            "operation": " order by birth_date in ascending order to find the earliest birth date."
        },
        "35": {
            "condition": "When the question asks for \"lowest average salary\"",
            "operation": " use the exact column \"A11\" from the district table and find the minimum value."
        },
        "36": {
            "condition": "When the question asks to \"calculate the gap between this lowest average salary with the highest average salary\"",
            "operation": " compute MAX(A11) - MIN(A11) from the district table."
        },
        "37": {
            "condition": "When combining tables for this analysis",
            "operation": " link account to district using district_id equality and account to disp using account_id equality, then disp to client using client_id equality."
        },
        "38": {
            "condition": "When answering about \"female clients who are oldest and has lowest average salary\", When the question asks for \"account numbers\", When the question mentions \"oldest\", When the question asks for \"lowest average salary\", When the question asks to \"calculate the gap between this lowest average salary with the highest average salary\", When combining tables for this analysis, When limiting results to the single oldest female client with lowest salary",
            "operation": " use LIMIT 1 on the outer query to return only one record."
        },
        "39": {
            "condition": "When the question asks for \"account numbers\"",
            "operation": " use the exact identifier \"T1.account_id\" instead of \"account_number\" and source from multiple joined tables including \"account AS T1\", \"disp AS T2\", \"client AS T3\", and \"district AS T4\"."
        },
        "40": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where \"T1.account_id = T2.account_id\", \"T2.client_id = T3.client_id\", and \"T4.district_id = T1.district_id\" using inner matches only."
        },
        "41": {
            "condition": "When the question asks for \"youngest client\"",
            "operation": " use \"birth_date DESC\" ordering instead of \"age ASC\" to identify the youngest client based on birth date."
        },
        "42": {
            "condition": "When filtering for the youngest client",
            "operation": " use a subquery with \"ORDER BY birth_date DESC\" to identify the target client instead of direct ordering in the main query."
        },
        "43": {
            "condition": "When organizing results",
            "operation": " use \"GROUP BY T4.A11, T1.account_id\" instead of no grouping."
        },
        "44": {
            "condition": "When the question asks for \"account numbers\", When combining tables for shared entities, When the question asks for \"youngest client\", When filtering for the youngest client, When organizing results, When the question asks for \"highest average salary\"",
            "operation": " this condition is not directly addressed in the final query structure as the amends focus on birth date for youngest client identification."
        },
        "45": {
            "condition": "When counting customers who choose weekly issuance",
            "operation": " use COUNT(T1.account_id) to count specific account IDs rather than all rows."
        },
        "46": {
            "condition": "When relating accounts with dispositions",
            "operation": " join account AS T1 INNER JOIN disp AS T2 to properly connect accounts with their disposition information."
        },
        "47": {
            "condition": "When filtering for owner status",
            "operation": " use T2.type = 'OWNER' instead of occupation columns to check for account ownership."
        },
        "48": {
            "condition": "When counting customers who choose weekly issuance, When relating accounts with dispositions, When filtering for owner status, When filtering for weekly issuance frequency",
            "operation": " use T1.frequency = 'POPLATEK TYDNE' with the exact Czech value meaning 'weekly' instead of 'issuance_type' columns."
        },
        "49": {
            "condition": "When answering about \"client who choose statement of issuance after transaction are Disponent\"",
            "operation": " make sure the output order: T2.client_id."
        },
        "50": {
            "condition": "When the question mentions \"client who choose statement of issuance after transaction are Disponent\"",
            "operation": " this actually means clients with disp type 'DISPONENT' and account frequency 'POPLATEK PO OBRATU' in the schema."
        },
        "51": {
            "condition": "When combining T1 (account) and T2 (disp) for shared entities",
            "operation": " link rows where T1.account_id = T2.account_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "52": {
            "condition": "When answering about \"client who choose statement of issuance after transaction are Disponent\", When the question mentions \"client who choose statement of issuance after transaction are Disponent\", When combining T1 (account) and T2 (disp) for shared entities, When filtering for the specific condition",
            "operation": " apply both filters T1.frequency = 'POPLATEK PO OBRATU' and T2.type = 'DISPONENT' instead of the incorrect issuance_statement filter."
        },
        "53": {
            "condition": "When answering about accounts with approved loan date in 1997",
            "operation": " use T1.date with STRFTIME('%Y', T1.date) = '1997' instead of approved_date."
        },
        "54": {
            "condition": "When the question mentions \"choose weekly issuance statement\"",
            "operation": " \"weekly\" actually means T2.frequency = 'POPLATEK TYDNE' in schema."
        },
        "55": {
            "condition": "When combining loan table T1 and account table T2",
            "operation": " link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match)."
        },
        "56": {
            "condition": "When the question asks for accounts with lowest approved amount",
            "operation": " order by T1.amount in ascending direction and keep the first row."
        },
        "57": {
            "condition": "When selecting output columns",
            "operation": " include account_id from T2 (account table) instead of from T1 (loan table)."
        },
        "58": {
            "condition": "When answering about accounts with approved loan date in 1997, When the question mentions \"choose weekly issuance statement\", When combining loan table T1 and account table T2, When the question asks for accounts with lowest approved amount, When selecting output columns, When producing output",
            "operation": " do not use GROUP BY or aggregation functions since we want individual loan records rather than aggregated values."
        },
        "59": {
            "condition": "When answering about accounts with loan validity more than 12 months",
            "operation": " use the \"loan\" table and filter where \"duration\" > 12 instead of \"loan_validity\" > 12."
        },
        "60": {
            "condition": "When combining loan and account information",
            "operation": " join \"loan\" and \"account\" tables using INNER JOIN on \"account_id\" to get matching records."
        },
        "61": {
            "condition": "When filtering by account opening date in 1993",
            "operation": " use STRFTIME('%Y', date) on the account table to extract the year and compare with '1993'."
        },
        "62": {
            "condition": "When finding the highest approved amount",
            "operation": " order results by \"amount\" in descending order and take only the top 1 record using LIMIT 1."
        },
        "63": {
            "condition": "When answering about accounts with loan validity more than 12 months, When combining loan and account information, When filtering by account opening date in 1993, When finding the highest approved amount, When selecting output columns",
            "operation": " return only \"account_id\" instead of all columns with *."
        },
        "64": {
            "condition": "When counting customers",
            "operation": " use COUNT(T2.client_id) instead of COUNT(*) to count specific non-null values."
        },
        "65": {
            "condition": "When structuring the data model",
            "operation": " use tables district AS T1 and client AS T2 instead of a single customers table."
        },
        "66": {
            "condition": "When combining district and client tables",
            "operation": " link rows where T1.district_id = T2.district_id using an inner match."
        },
        "67": {
            "condition": "When filtering for female customers",
            "operation": " use T2.gender = 'F' instead of 'female' to match the actual data format."
        },
        "68": {
            "condition": "When filtering for birth year before 1950",
            "operation": " use STRFTIME('%Y', T2.birth_date) < '1950' to extract year from a date field rather than using a separate year column."
        },
        "69": {
            "condition": "When counting customers, When structuring the data model, When combining district and client tables, When filtering for female customers, When filtering for birth year before 1950, When filtering for customers in Sokolov",
            "operation": " use T1.A2 = 'Sokolov' instead of city = 'Sokolov' to reference the district table's city name field."
        },
        "70": {
            "condition": "When answering about \"accounts who have the earliest trading date in 1995\"",
            "operation": " make sure the output order: account_id only."
        },
        "71": {
            "condition": "When the question mentions \"trades\" table",
            "operation": " \"trades\" actually means \"trans\" in schema."
        },
        "72": {
            "condition": "When the question mentions \"trade_date\" column",
            "operation": " \"trade_date\" actually means \"date\" in schema."
        },
        "73": {
            "condition": "When filtering for year 1995",
            "operation": " use STRFTIME('%Y', date) = '1995' exactly as specified."
        },
        "74": {
            "condition": "When finding the earliest date",
            "operation": " order by date ASC directly without aggregation."
        },
        "75": {
            "condition": "When answering about \"accounts who have the earliest trading date in 1995\", When the question mentions \"trades\" table, When the question mentions \"trade_date\" column, When filtering for year 1995, When finding the earliest date, When limiting to the first result",
            "operation": " keep LIMIT 1 to get only the top row."
        },
        "76": {
            "condition": "When answering about accounts with opening date before 1997 and money greater than 3000USD",
            "operation": " use DISTINCT T2.account_id instead of selecting all columns."
        },
        "77": {
            "condition": "When combining transaction and account tables",
            "operation": " use trans AS T1 INNER JOIN account AS T2 with join condition T1.account_id = T2.account_id instead of querying only accounts table."
        },
        "78": {
            "condition": "When filtering by opening date before 1997",
            "operation": " use STRFTIME('%Y', T2.date) < '1997' instead of opening_date < '1997-01-01'."
        },
        "79": {
            "condition": "When answering about accounts with opening date before 1997 and money greater than 3000USD, When combining transaction and account tables, When filtering by opening date before 1997, When filtering by amount greater than 3000",
            "operation": " use T1.amount > 3000 instead of amount > 3000 from the accounts table."
        },
        "80": {
            "condition": "When answering about clients who issued cards on a specific date",
            "operation": " make sure the output order: T2.client_id"
        },
        "81": {
            "condition": "When the question mentions \"client id\"",
            "operation": " \"client id\" actually means \"T2.client_id\" in schema"
        },
        "82": {
            "condition": "When combining T1 (client) and T2 (disp) for shared entities",
            "operation": " link rows where T1.client_id = T2.client_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "83": {
            "condition": "When combining T2 (disp) and T3 (card) for shared entities",
            "operation": " link rows where T2.disp_id = T3.disp_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "84": {
            "condition": "When answering about clients who issued cards on a specific date, When the question mentions \"client id\", When combining T1 (client) and T2 (disp) for shared entities, When combining T2 (disp) and T3 (card) for shared entities, When filtering by date '1994/3/3'",
            "operation": " use T3.issued = '1994-03-03' with proper date format instead of incorrect format '1994/3/3'"
        },
        "85": {
            "condition": "When the question asks about account opening date",
            "operation": " use \"T1.date\" from the \"account\" table instead of \"opened_date\" from \"accounts\"."
        },
        "86": {
            "condition": "When combining account and transaction information",
            "operation": " join \"account AS T1\" with \"trans AS T2\" using \"T1.account_id = T2.account_id\" to match related records."
        },
        "87": {
            "condition": "When filtering for a transaction amount of 840 USD",
            "operation": " use \"T2.amount = 840\" instead of \"transaction_amount = 840\"."
        },
        "88": {
            "condition": "When the question asks about account opening date, When combining account and transaction information, When filtering for a transaction amount of 840 USD, When filtering for transaction date 1998/10/14",
            "operation": " use \"T2.date = '1998-10-14'\" with the corrected date format instead of '1998/10/14'."
        },
        "89": {
            "condition": "When the question asks about account opening location but mentions a loan date",
            "operation": " join account table (T1) with loan table (T2) using account_id equality (T1.account_id = T2.account_id) to connect loan information with account details."
        },
        "90": {
            "condition": "When filtering by a specific loan date like '1994/8/25'",
            "operation": " use the exact date format '1994-08-25' with proper hyphen separation and zero-padded months."
        },
        "91": {
            "condition": "When retrieving district information for an account",
            "operation": " select district_id from the account table (T1.district_id) rather than from the loans table."
        },
        "92": {
            "condition": "When the question asks about account opening location but mentions a loan date, When filtering by a specific loan date like '1994/8/25', When retrieving district information for an account, When combining account and loan tables",
            "operation": " perform an inner join to keep only matching pairs where both account and loan records exist for the same account_id."
        },
        "93": {
            "condition": "When combining tables for client transaction data",
            "operation": " link card as T1, disp as T2, account as T3, and trans as T4 using exact key equalities T1.disp_id = T2.disp_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id, keeping only matching pairs (inner match)."
        },
        "94": {
            "condition": "When filtering for cards opened on a specific date",
            "operation": " use T1.issued = '1996-10-21' with exact date format and literal value."
        },
        "95": {
            "condition": "When finding the biggest transaction amount",
            "operation": " order rows by T4.amount in descending order and take only the first row."
        },
        "96": {
            "condition": "When combining tables for client transaction data, When filtering for cards opened on a specific date, When finding the biggest transaction amount, When selecting the transaction amount",
            "operation": " output T4.amount directly from the ordered result."
        },
        "97": {
            "condition": "When answering about \"gender of the oldest client who opened his/her account in the highest average salary branch\"",
            "operation": " make sure the output order: T2.gender."
        },
        "98": {
            "condition": "When combining district AS T1 and client AS T2 for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "99": {
            "condition": "When the question mentions \"highest average salary branch\"",
            "operation": " \"highest average salary branch\" actually means \"T1.A11 in schema\" and requires ordering by T1.A11 DESC."
        },
        "100": {
            "condition": "When the question mentions \"oldest client\"",
            "operation": " \"oldest client\" actually means \"T2.birth_date in schema\" and requires ordering by T2.birth_date ASC to find the earliest birth date."
        },
        "101": {
            "condition": "When the question asks for a single result",
            "operation": " use LIMIT 1 to return only the first row after ordering."
        },
        "102": {
            "condition": "When answering about \"gender of the oldest client who opened his/her account in the highest average salary branch\", When combining district AS T1 and client AS T2 for shared entities, When the question mentions \"highest average salary branch\", When the question mentions \"oldest client\", When the question asks for a single result, When handling ordering ties",
            "operation": " break ties using the canonical key if needed, with T1.A11 DESC as primary ordering and T2.birth_date ASC as secondary ordering."
        },
        "103": {
            "condition": "When joining loan and account tables",
            "operation": " link rows where T1.account_id equals T2.account_id exactly."
        },
        "104": {
            "condition": "When joining account and trans tables",
            "operation": " link rows where T2.account_id equals T3.account_id exactly."
        },
        "105": {
            "condition": "When finding the account with the biggest loan",
            "operation": " order rows by T1.amount in descending order."
        },
        "106": {
            "condition": "When finding the first transaction after account opening",
            "operation": " order transactions by T3.date in ascending order."
        },
        "107": {
            "condition": "When selecting the transaction amount",
            "operation": " use T3.amount as the output column."
        },
        "108": {
            "condition": "When limiting to the top result",
            "operation": " keep only the first row after ordering."
        },
        "109": {
            "condition": "When joining loan and account tables, When joining account and trans tables, When finding the account with the biggest loan, When finding the first transaction after account opening, When selecting the transaction amount, When limiting to the top result, When the question asks about the biggest loan",
            "operation": " do not use a subquery for maximum amount, instead use ordering by T1.amount DESC."
        },
        "110": {
            "condition": "When answering about clients from a specific branch",
            "operation": " join the district table (T2) with clients table (T1) using INNER JOIN where T1.district_id = T2.district_id to get branch information."
        },
        "111": {
            "condition": "When counting clients",
            "operation": " use T1.client_id as the counting key instead of counting all rows."
        },
        "112": {
            "condition": "When filtering by branch name \"Jesenik\"",
            "operation": " use T2.A2 = 'Jesenik' instead of the branch column in clients table."
        },
        "113": {
            "condition": "When answering about clients from a specific branch, When counting clients, When filtering by branch name \"Jesenik\", When filtering for female clients",
            "operation": " use T1.gender = 'F' instead of 'female' for the gender value."
        },
        "114": {
            "condition": "When the question asks about clients opening accounts in a specific branch",
            "operation": " use the district table to filter by branch name instead of joining with the account table."
        },
        "115": {
            "condition": "When the question mentions \"Jesenik branch\"",
            "operation": " the exact literal value is 'Jesenik' and it corresponds to column T2.A2 in the district table."
        },
        "116": {
            "condition": "When the question asks about gender being women",
            "operation": " the exact literal value is 'F' and it corresponds to column T1.gender in the client table."
        },
        "117": {
            "condition": "When counting clients",
            "operation": " use T1.client_id as the counting key to get the number of clients."
        },
        "118": {
            "condition": "When the question asks about clients opening accounts in a specific branch, When the question mentions \"Jesenik branch\", When the question asks about gender being women, When counting clients, When combining client and district tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "119": {
            "condition": "When answering about disposition id for a transaction",
            "operation": " select T1.disp_id from the disp table instead of disposition_id from the transactions table."
        },
        "120": {
            "condition": "When combining account and trans tables",
            "operation": " join account AS T2 on T1.account_id = T2.account_id and trans AS T3 on T2.account_id = T3.account_id using exact key equality."
        },
        "121": {
            "condition": "When filtering by transaction amount",
            "operation": " use T3.amount = 5100 condition."
        },
        "122": {
            "condition": "When answering about disposition id for a transaction, When combining account and trans tables, When filtering by transaction amount, When filtering by transaction date",
            "operation": " use T3.date = '1997-08-20' instead of '1998/9/2' with exact date format and literal value."
        },
        "123": {
            "condition": "When answering about accounts opened in a specific location and year",
            "operation": " join district table as T1 with account table as T2 using inner join where T1.district_id = T2.district_id."
        },
        "124": {
            "condition": "When the question mentions \"Litomerice\"",
            "operation": " use T1.A2 = 'Litomerice' to filter for the correct district."
        },
        "125": {
            "condition": "When the question mentions \"1996\" as the year",
            "operation": " use STRFTIME('%Y', T2.date) = '1996' to filter for accounts opened in that year."
        },
        "126": {
            "condition": "When answering about accounts opened in a specific location and year, When the question mentions \"Litomerice\", When the question mentions \"1996\" as the year, When counting accounts",
            "operation": " use COUNT(T2.account_id) instead of COUNT(*) to count specific account identifiers."
        },
        "127": {
            "condition": "When the question asks about district information for a client",
            "operation": " join the client table (T2) with the district table (T1) using T1.district_id = T2.district_id to link client and district data."
        },
        "128": {
            "condition": "When filtering by gender",
            "operation": " use T2.gender = 'F' with the exact single character 'F' instead of 'female'."
        },
        "129": {
            "condition": "When filtering by birth date",
            "operation": " use T2.birth_date = '1976-01-29' with ISO date format instead of '1976/1/29'."
        },
        "130": {
            "condition": "When the question asks about district information for a client, When filtering by gender, When filtering by birth date, When selecting district information",
            "operation": " output T1.A2 from the district table instead of district_id from the accounts table."
        },
        "131": {
            "condition": "When answering about a client's birthday",
            "operation": " select T4.birth_date from the client table instead of birthday from clients."
        },
        "132": {
            "condition": "When combining loan, account, disp, and client tables",
            "operation": " link rows using inner joins with predicates T1.account_id = T2.account_id, T2.account_id = T3.account_id, and T3.client_id = T4.client_id to keep only matching pairs."
        },
        "133": {
            "condition": "When filtering by loan application date",
            "operation": " use T1.date = '1996-01-03' with the exact date format '1996-01-03' instead of '1996/1/3'."
        },
        "134": {
            "condition": "When answering about a client's birthday, When combining loan, account, disp, and client tables, When filtering by loan application date, When filtering by loan amount",
            "operation": " use T1.amount = 98832 from the loan table instead of loan_amount from clients."
        },
        "135": {
            "condition": "When answering about the first client who opened an account in Prague",
            "operation": " make sure the output order includes T1.account_id."
        },
        "136": {
            "condition": "When the question mentions \"Prague\"",
            "operation": " \"Prague\" actually means T2.A3 = 'Prague' in the schema."
        },
        "137": {
            "condition": "When the question asks for the \"first\" client by account opening date",
            "operation": " rank rows by T1.date in ascending order and keep the first 1 row."
        },
        "138": {
            "condition": "When combining T1 (accounts) and T2 (district) for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id exactly as shown; keep only matching pairs (inner match)."
        },
        "139": {
            "condition": "When answering about the first client who opened an account in Prague, When the question mentions \"Prague\", When the question asks for the \"first\" client by account opening date, When combining T1 (accounts) and T2 (district) for shared entities, When referring to table roles",
            "operation": " use T1 for accounts table and T2 for district table as established in the amends."
        },
        "140": {
            "condition": "When joining client and district tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "141": {
            "condition": "When filtering for south Bohemia region",
            "operation": " use T2.A3 = 'south Bohemia' exactly as specified."
        },
        "142": {
            "condition": "When grouping results by district",
            "operation": " use T2.A4 as the grouping key."
        },
        "143": {
            "condition": "When counting male clients",
            "operation": " use SUM(T1.gender = 'M') with explicit CAST to REAL instead of COUNT(CASE WHEN c.gender = 'male' THEN 1 END)."
        },
        "144": {
            "condition": "When counting total clients",
            "operation": " use COUNT(T1.client_id) instead of COUNT(*) for accurate client counting."
        },
        "145": {
            "condition": "When ordering districts by population",
            "operation": " use T2.A4 DESC to find the district with the highest number of inhabitants."
        },
        "146": {
            "condition": "When joining client and district tables, When filtering for south Bohemia region, When grouping results by district, When counting male clients, When counting total clients, When ordering districts by population, When answering about the percentage of male clients",
            "operation": " compute (male client count) divided by (total client count) and multiply by 100.0, guarding division by zero."
        },
        "147": {
            "condition": "When the question asks for a percentage of male clients",
            "operation": " use SUM(T1.gender = 'M') to count male clients instead of CASE WHEN syntax."
        },
        "148": {
            "condition": "When the question specifies \"branch which located in the south Bohemia\"",
            "operation": " filter using T2.A3 = 'south Bohemia' exactly as written."
        },
        "149": {
            "condition": "When the question asks about the branch with biggest number of inhabitants",
            "operation": " group by T2.A4 and order by T2.A4 DESC to find the largest district, then take only the top result with LIMIT 1."
        },
        "150": {
            "condition": "When combining client and district tables",
            "operation": " use INNER JOIN with condition T1.district_id = T2.district_id to link clients to their districts."
        },
        "151": {
            "condition": "When the question asks for a percentage of male clients, When the question specifies \"branch which located in the south Bohemia\", When the question asks about the branch with biggest number of inhabitants, When combining client and district tables, When calculating percentage",
            "operation": " compute (SUM(T1.gender = 'M') / COUNT(T1.client_id)) * 100 and return only this calculated percentage without additional columns."
        },
        "152": {
            "condition": "When calculating percentage increase rate",
            "operation": " use conditional aggregation with SUM(IIF()) instead of direct column subtraction, and cast the result as REAL instead of implicit integer division."
        },
        "153": {
            "condition": "When joining account and loan tables",
            "operation": " join on account_id instead of client_id."
        },
        "154": {
            "condition": "When handling transaction data",
            "operation": " add the trans table with account_id join instead of joining accounts twice."
        },
        "155": {
            "condition": "When filtering for loan approval date",
            "operation": " filter on T1.date instead of l.approval_date."
        },
        "156": {
            "condition": "When the query returns a single aggregated result",
            "operation": " remove explicit ORDER BY and LIMIT clauses."
        },
        "157": {
            "condition": "When calculating percentage increase",
            "operation": " use proper numerator/denominator order and handle potential division by zero cases."
        },
        "158": {
            "condition": "When calculating percentage increase rate, When joining account and loan tables, When handling transaction data, When filtering for loan approval date, When the query returns a single aggregated result, When calculating percentage increase, When handling dates that might not exist",
            "operation": " use conditional sums through aggregation instead of requiring exact matches in join conditions."
        },
        "159": {
            "condition": "When answering about the client whose loan was approved first on a specific date",
            "operation": " identify the earliest approved loan on that date using the exact date literal '1993-07-05' and find the corresponding account."
        },
        "160": {
            "condition": "When calculating balance increase rate between two dates",
            "operation": " use a single transaction table with alias T3 instead of separate table aliases for different dates."
        },
        "161": {
            "condition": "When combining loan and transaction tables",
            "operation": " link rows where loan.account_id equals T3.account_id using inner join instead of left join."
        },
        "162": {
            "condition": "When filtering transactions for specific dates",
            "operation": " use the exact date literals '1993-03-22' and '1998-12-27' with proper date format."
        },
        "163": {
            "condition": "When computing percentage increase",
            "operation": " calculate (balance on '1998-12-27' minus balance on '1993-03-22') divided by balance on '1993-03-22' multiplied by 100, with explicit casting to REAL for the subtraction operation."
        },
        "164": {
            "condition": "When handling division",
            "operation": " perform direct division without NULLIF protection instead of using null protection functions."
        },
        "165": {
            "condition": "When using conditional expressions",
            "operation": " use IIF function instead of CASE expressions for date comparisons."
        },
        "166": {
            "condition": "When answering about the client whose loan was approved first on a specific date, When calculating balance increase rate between two dates, When combining loan and transaction tables, When filtering transactions for specific dates, When computing percentage increase, When handling division, When using conditional expressions, When the question involves temporal comparisons",
            "operation": " ensure proper date handling with exact date format 'YYYY-MM-DD' as shown in the literals."
        },
        "167": {
            "condition": "When combining tables for this question",
            "operation": " use INNER JOIN instead of implicit JOIN for clarity."
        },
        "168": {
            "condition": "When calculating percentage increase",
            "operation": " perform subtraction, cast to REAL, multiply by 100, and then divide to ensure correct mathematical order of operations."
        },
        "169": {
            "condition": "When filtering for specific dates",
            "operation": " do not use redundant IN conditions since IIF expressions already handle the specific date filtering."
        },
        "170": {
            "condition": "When using table aliases",
            "operation": " use T1, T2, and T3 consistently instead of mixing different alias patterns."
        },
        "171": {
            "condition": "When combining tables for this question, When calculating percentage increase, When filtering for specific dates, When using table aliases, When producing output",
            "operation": " do not include column aliases like increase_rate when the correct query omits them."
        },
        "172": {
            "condition": "When calculating percentage of loan amount paid",
            "operation": " use SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) to calculate paid amount value rather than counting rows."
        },
        "173": {
            "condition": "When computing percentage of paid loan amount",
            "operation": " calculate as (paid_amount *"
        },
        "174": {
            "condition": "/ total_amount instead of (count * 100.0) / total_count to properly weight by monetary value.",
            "operation": "/ total_amount instead of (count * 100.0) / total_count to properly weight by monetary value."
        },
        "175": {
            "condition": "When filtering for fully paid loans",
            "operation": " use status = 'A' instead of 'paid' to match the correct status code."
        },
        "176": {
            "condition": "When performing numeric division",
            "operation": " use CAST(... AS REAL) instead of implicit casting to ensure proper numeric division."
        },
        "177": {
            "condition": "When calculating percentage of loan amount paid, When computing percentage of paid loan amount, / total_amount instead of (count * 100.0) / total_count to properly weight by monetary value., When filtering for fully paid loans, When performing numeric division, When computing aggregates from the same table",
            "operation": " use aggregate functions directly in the main query instead of unnecessary subqueries."
        },
        "178": {
            "condition": "When answering about percentage of accounts with status 'C' for loans under 100,000",
            "operation": " use table \"loan\" as the data source instead of \"accounts\"."
        },
        "179": {
            "condition": "When filtering by loan amount less than 100,000",
            "operation": " use column \"amount\" instead of \"loan_amount\" with the condition amount < 100000."
        },
        "180": {
            "condition": "When checking account status",
            "operation": " use literal value 'C' instead of 'running' to identify accounts with no issues."
        },
        "181": {
            "condition": "When calculating the percentage",
            "operation": " use CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) instead of COUNT(CASE WHEN status = 'running' THEN 1 END) * 100.0 / COUNT(*)."
        },
        "182": {
            "condition": "When answering about percentage of accounts with status 'C' for loans under 100,000, When filtering by loan amount less than 100,000, When checking account status, When calculating the percentage, When counting accounts for the denominator",
            "operation": " use COUNT(account_id) instead of COUNT(*) to ensure accurate account counting."
        },
        "183": {
            "condition": "When joining accounts and district tables",
            "operation": " use INNER JOIN between T1 (accounts) and T2 (district) on T1.district_id = T2.district_id instead of joining with districts table."
        },
        "184": {
            "condition": "When selecting district information",
            "operation": " use T2.A2 for district name and T2.A3 for district region instead of d.district_name and d.region."
        },
        "185": {
            "condition": "When filtering by year 1993",
            "operation": " use STRFTIME('%Y', T1.date) = '1993' instead of YEAR(a.date) = 1993."
        },
        "186": {
            "condition": "When filtering accounts",
            "operation": " include the condition T1.frequency = 'POPLATEK PO OBRATU' which was previously omitted."
        },
        "187": {
            "condition": "When the question mentions accounts with statement issued after transaction",
            "operation": " remove the condition a.statement_date > a.transaction_date as it should not be included."
        },
        "188": {
            "condition": "When joining accounts and district tables, When selecting district information, When filtering by year 1993, When filtering accounts, When the question mentions accounts with statement issued after transaction, When ordering results",
            "operation": " remove the ORDER BY clause as it is not required by the question."
        },
        "189": {
            "condition": "When answering about account holders from 'east Bohemia'",
            "operation": " join table account as T1 with table district as T2 using T1.district_id = T2.district_id to access region information."
        },
        "190": {
            "condition": "When filtering by region 'east Bohemia'",
            "operation": " use T2.A3 = 'east Bohemia' instead of a region column in the accounts table."
        },
        "191": {
            "condition": "When filtering by years 1995 to 2000",
            "operation": " extract year from T1.date using STRFTIME('%Y', T1.date) BETWEEN '1995' AND '2000' instead of a direct year column."
        },
        "192": {
            "condition": "When selecting account information",
            "operation": " output T1.account_id and T1.frequency directly instead of aggregating with COUNT(statement_id)."
        },
        "193": {
            "condition": "When answering about account holders from 'east Bohemia', When filtering by region 'east Bohemia', When filtering by years 1995 to 2000, When selecting account information, When the question asks for frequency of statement issuance",
            "operation": " use the existing T1.frequency column rather than computing a count from statement_id."
        },
        "194": {
            "condition": "When answering about accounts from a specific location",
            "operation": " join \"account AS T1\" with \"district AS T2\" using the exact key equality T1.district_id = T2.district_id to link account and district information."
        },
        "195": {
            "condition": "When the question mentions 'account opening date'",
            "operation": " \"opening date\" actually means \"T1.date\" in the schema."
        },
        "196": {
            "condition": "When the question mentions 'Prachatice'",
            "operation": " filter on T2.A2 = 'Prachatice' exactly as specified, using the exact literal value 'Prachatice' with correct case and spelling."
        },
        "197": {
            "condition": "When answering about accounts from a specific location, When the question mentions 'account opening date', When the question mentions 'Prachatice', When selecting output columns",
            "operation": " use the exact column tokens T1.account_id and T1.date with their table aliases as shown in the schema."
        },
        "198": {
            "condition": "When answering about loan ID '4990'",
            "operation": " use the exact numeric value 4990 without quotes instead of string '4990'."
        },
        "199": {
            "condition": "When retrieving district and region information for a loan",
            "operation": " join account table as T1, district table as T2, and loan table as T3 using inner joins."
        },
        "200": {
            "condition": "When joining account and district tables",
            "operation": " link rows where T1.district_id equals T2.district_id."
        },
        "201": {
            "condition": "When joining account and loan tables",
            "operation": " link rows where T1.account_id equals T3.account_id."
        },
        "202": {
            "condition": "When filtering by loan ID",
            "operation": " use T3.loan_id = 4990 with the correct table alias."
        },
        "203": {
            "condition": "When answering about loan ID '4990', When retrieving district and region information for a loan, When joining account and district tables, When joining account and loan tables, When filtering by loan ID, When selecting output columns",
            "operation": " use T2.A2 for district and T2.A3 for region instead of the original column names."
        },
        "204": {
            "condition": "When answering about \"account ID, district and region for loan amount greater than USD300,000\"",
            "operation": " make sure the output order: T1.account_id, T2.A2, T2.A3"
        },
        "205": {
            "condition": "When combining account and district tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)"
        },
        "206": {
            "condition": "When combining account and loan tables",
            "operation": " link rows where T1.account_id = T3.account_id and keep only matching pairs (inner match)"
        },
        "207": {
            "condition": "When filtering for loan amount greater than USD300,000",
            "operation": " apply the condition T3.amount > 300000"
        },
        "208": {
            "condition": "When the question mentions \"district\"",
            "operation": " \"district\" actually means \"T2.A2 in schema\""
        },
        "209": {
            "condition": "When answering about \"account ID, district and region for loan amount greater than USD300,000\", When combining account and district tables, When combining account and loan tables, When filtering for loan amount greater than USD300,000, When the question mentions \"district\", When the question mentions \"region\"",
            "operation": " \"region\" actually means \"T2.A3 in schema\""
        },
        "210": {
            "condition": "When answering about \"loan ID, district and average salary for loan with duration of 60 months\"",
            "operation": " make sure the output order: T3.loan_id, T2.A2, T2.A11"
        },
        "211": {
            "condition": "When combining tables for loan information",
            "operation": " use FROM account AS T1 with INNER JOIN district AS T2 ON T1.district_id = T2.district_id and INNER JOIN loan AS T3 ON T1.account_id = T3.account_id"
        },
        "212": {
            "condition": "When filtering for loans with duration of 60 months",
            "operation": " use WHERE T3.duration = 60"
        },
        "213": {
            "condition": "When answering about \"loan ID, district and average salary for loan with duration of 60 months\", When combining tables for loan information, When filtering for loans with duration of 60 months, When selecting columns",
            "operation": " do not use GROUP BY loan_id, district"
        },
        "214": {
            "condition": "When calculating percentage change from year 1995 to 1996",
            "operation": " compute (T3.A13 - T3.A12) * 100 / T3.A12 with CAST(... AS REAL) to ensure floating-point division instead of simple subtraction multiplication."
        },
        "215": {
            "condition": "When combining loan and account tables",
            "operation": " link rows where T1.account_id = T2.account_id instead of using client relationships."
        },
        "216": {
            "condition": "When combining account and district tables",
            "operation": " link rows where T2.district_id = T3.district_id to use proper account-district linkage."
        },
        "217": {
            "condition": "When filtering for running loans",
            "operation": " use T1.status = 'D' instead of 'running' to use the correct status code."
        },
        "218": {
            "condition": "When the question mentions \"client are in debt\"",
            "operation": " do not include any debt_status filter as it's not required."
        },
        "219": {
            "condition": "When handling null values in unemployment rates",
            "operation": " do not include IS NOT NULL checks as the division operation handles nulls appropriately."
        },
        "220": {
            "condition": "When calculating percentage change from year 1995 to 1996, When combining loan and account tables, When combining account and district tables, When filtering for running loans, When the question mentions \"client are in debt\", When handling null values in unemployment rates, When the question asks for listing districts and states",
            "operation": " output T3.district_name and T3.state in the results without ordering requirements."
        },
        "221": {
            "condition": "When answering about loans contracts which are still running where clients are in debt",
            "operation": " filter rows where T1.status equals exactly 'D' (case-sensitive)."
        },
        "222": {
            "condition": "When combining loan, account, and district tables",
            "operation": " link T1 to T2 using T1.account_id = T2.account_id and T2 to T3 using T2.district_id = T3.district_id, keeping only matching pairs (inner match)."
        },
        "223": {
            "condition": "When calculating percentage unemployment rate increment from year 1995 to 1996",
            "operation": " compute (T3.A13 - T3.A12) * 100.0 / T3.A12 with CAST((T3.A13 - T3.A12) AS REAL) for proper numeric casting."
        },
        "224": {
            "condition": "When answering about loans contracts which are still running where clients are in debt, When combining loan, account, and district tables, When calculating percentage unemployment rate increment from year 1995 to 1996, When listing the district and the state",
            "operation": " output T3.A2 and T3.A3 without explicit column aliases in the result set."
        },
        "225": {
            "condition": "When answering about loans with status 'D'",
            "operation": " only return the calculated percentage unemployment rate increment as a single output column."
        },
        "226": {
            "condition": "When the question mentions \"percentage unemployment rate increment from year 1995 to 1996\"",
            "operation": " calculate it as CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12."
        },
        "227": {
            "condition": "When answering about loans with status 'D', When the question mentions \"percentage unemployment rate increment from year 1995 to 1996\", When the question asks for district and state information",
            "operation": " do not include T3.A2 AS district_name or T3.A3 AS state in the output columns."
        },
        "228": {
            "condition": "When calculating percentages for accounts from specific districts",
            "operation": " join the district table (T1) with the account table (T2) using T1.district_id = T2.district_id to properly link district information to accounts."
        },
        "229": {
            "condition": "When filtering accounts opened in a specific year",
            "operation": " use STRFTIME('%Y', T2.date) = '1993' to extract the year from the account opening date."
        },
        "230": {
            "condition": "When counting accounts from a specific district",
            "operation": " use SUM(T1.A2 = 'Decin') with explicit casting to REAL for accurate percentage calculation instead of COUNT(CASE WHEN...)."
        },
        "231": {
            "condition": "When calculating percentage denominators",
            "operation": " count T2.account_id instead of using COUNT(*) to ensure accurate account counting."
        },
        "232": {
            "condition": "When calculating percentages for accounts from specific districts, When filtering accounts opened in a specific year, When counting accounts from a specific district, When calculating percentage denominators, When the question asks for percentage of accounts from 'Decin' district",
            "operation": " preserve the exact literal 'Decin' with proper case and spelling."
        },
        "233": {
            "condition": "When answering about \"account IDs with monthly issuance of statements\"",
            "operation": " select from the \"account\" table instead of the \"statements\" table."
        },
        "234": {
            "condition": "When filtering for monthly issuance",
            "operation": " use the exact literal value 'POPLATEK MESICNE' for the Frequency condition instead of pattern matching on dates."
        },
        "235": {
            "condition": "When answering about \"account IDs with monthly issuance of statements\", When filtering for monthly issuance, When retrieving account IDs",
            "operation": " use the exact column token \"account\" from the \"account\" table as the output."
        },
        "236": {
            "condition": "When answering about \"top nine districts by number of female account holders\"",
            "operation": " make sure the output order: T2.A2, COUNT(T1.client_id) in descending order and keep the first 9 rows."
        },
        "237": {
            "condition": "When the question mentions \"female account holders\"",
            "operation": " \"female\" actually means \"T1.gender = 'F'\" in schema."
        },
        "238": {
            "condition": "When combining T1 (client) and T2 (district) for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id; keep only matching pairs (inner match)."
        },
        "239": {
            "condition": "When counting female clients per district",
            "operation": " compute the number of rows using T1.client_id as the counting key."
        },
        "240": {
            "condition": "When the question asks for \"districts by number of female account holders\"",
            "operation": " organize results by both T2.district_id and T2.A2 and compute the count per group."
        },
        "241": {
            "condition": "When answering about \"top nine districts by number of female account holders\", When the question mentions \"female account holders\", When combining T1 (client) and T2 (district) for shared entities, When counting female clients per district, When the question asks for \"districts by number of female account holders\", When producing output",
            "operation": " include T2.A2 as the district identifier instead of just district_id."
        },
        "242": {
            "condition": "When the question asks for \"top nine districts\"",
            "operation": " rank districts by the number of female account holders in descending order and keep the first 9 rows."
        },
        "243": {
            "condition": "When counting female account holders",
            "operation": " count using T1.client_id where T1.gender equals exactly 'F'."
        },
        "244": {
            "condition": "When combining client and district tables",
            "operation": " link rows where T1.district_id equals T2.district_id and keep only matching pairs (inner match)."
        },
        "245": {
            "condition": "When organizing results by district",
            "operation": " group by both T2.district_id and T2.A2 to ensure correct aggregation."
        },
        "246": {
            "condition": "When ordering results",
            "operation": " order by the actual count value (COUNT(T1.client_id)) directly rather than using an alias."
        },
        "247": {
            "condition": "When the question asks for \"top nine districts\", When counting female account holders, When combining client and district tables, When organizing results by district, When ordering results, When selecting output columns",
            "operation": " include only T2.A2 (district name) and the female count, not T2.district_id."
        },
        "248": {
            "condition": "When answering about \"top ten withdrawals by district names\"",
            "operation": " make sure the output order is T1.A2 ASC instead of aggregated withdrawal amounts in descending order."
        },
        "249": {
            "condition": "When the question mentions \"withdrawals (non-credit card)\"",
            "operation": " \"withdrawals\" actually means T3.type = 'VYDAJ' in schema and no credit card filter is needed."
        },
        "250": {
            "condition": "When the question asks for \"district names\"",
            "operation": " use DISTINCT T1.A2 instead of grouping and aggregating."
        },
        "251": {
            "condition": "When combining tables for this query",
            "operation": " start from district AS T1, then INNER JOIN account AS T2 ON T1.district_id = T2.district_id, then INNER JOIN trans AS T3 ON T2.account_id = T3.account_id."
        },
        "252": {
            "condition": "When answering about \"top ten withdrawals by district names\", When the question mentions \"withdrawals (non-credit card)\", When the question asks for \"district names\", When combining tables for this query, When the question asks for \"top ten\"",
            "operation": " rank rows by T1.A2 in ascending order and keep the first 10 rows using LIMIT 10."
        },
        "253": {
            "condition": "When answering about account holders in South Bohemia",
            "operation": " join district table as T1 and client table as T2 where T1.district_id = T2.district_id."
        },
        "254": {
            "condition": "When identifying account relationships",
            "operation": " join disp table as T3 where T2.client_id = T3.client_id."
        },
        "255": {
            "condition": "When filtering for South Bohemia region",
            "operation": " use T1.A3 = 'south Bohemia' with exact case and spacing."
        },
        "256": {
            "condition": "When excluding credit card owners",
            "operation": " filter where T3.type != 'OWNER' to identify non-owner accounts."
        },
        "257": {
            "condition": "When answering about account holders in South Bohemia, When identifying account relationships, When filtering for South Bohemia region, When excluding credit card owners, When counting account holders",
            "operation": " count T3.account_id instead of all rows to target the specific relationship."
        },
        "258": {
            "condition": "When answering about \"which district has highest active loan\"",
            "operation": " make sure the output order: T2.A3."
        },
        "259": {
            "condition": "When the question mentions \"district\"",
            "operation": " \"district\" actually means \"T2.A3\" in schema."
        },
        "260": {
            "condition": "When combining account (T1) and district (T2) for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "261": {
            "condition": "When combining account (T1) and loan (T3) for shared entities",
            "operation": " link rows where T1.account_id = T3.account_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "262": {
            "condition": "When filtering loan status",
            "operation": " use T3.status IN ('C', 'D') instead of 'active' as shown in the amends."
        },
        "263": {
            "condition": "When grouping by district",
            "operation": " use T2.A3 as the grouping key instead of district_id."
        },
        "264": {
            "condition": "When the question mentions \"highest\"",
            "operation": " rank rows by SUM(T3.amount) in descending order and keep the first 1 row."
        },
        "265": {
            "condition": "When answering about \"which district has highest active loan\", When the question mentions \"district\", When combining account (T1) and district (T2) for shared entities, When combining account (T1) and loan (T3) for shared entities, When filtering loan status, When grouping by district, When the question mentions \"highest\", When computing the highest loan amount",
            "operation": " use SUM(T3.amount) instead of counting active loans."
        },
        "266": {
            "condition": "When answering about \"average loan amount by male borrowers\"",
            "operation": " make sure the output order: AVG(T4.amount)."
        },
        "267": {
            "condition": "When combining tables for client, disposition, account, and loan data",
            "operation": " link rows where T1.client_id = T2.client_id, then T2.account_id = T3.account_id, and finally T3.account_id = T4.account_id; keep only matching pairs (inner match)."
        },
        "268": {
            "condition": "When the question mentions \"male borrowers\"",
            "operation": " use T1.gender = 'M' as the gender condition instead of 'female'."
        },
        "269": {
            "condition": "When answering about \"average loan amount by male borrowers\", When combining tables for client, disposition, account, and loan data, When the question mentions \"male borrowers\", When computing the average loan amount",
            "operation": " use AVG(T4.amount) instead of AVG(loan_amount)."
        },
        "270": {
            "condition": "When answering about districts with highest unemployment rate",
            "operation": " select \"district_id\" and \"A2\" from table \"district\" instead of \"branch_location\" and \"district_name\" from \"districts\"."
        },
        "271": {
            "condition": "When the question mentions year 1996",
            "operation": " do not filter by year as the schema does not contain year information."
        },
        "272": {
            "condition": "When the question asks for highest unemployment rate",
            "operation": " order by \"A13\" in descending direction instead of ascending."
        },
        "273": {
            "condition": "When answering about districts with highest unemployment rate, When the question mentions year 1996, When the question asks for highest unemployment rate, When the question asks for highest unemployment rate",
            "operation": " limit to 1 row instead of 5 rows to get the single highest value."
        },
        "274": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T2.account_id) instead of COUNT(*) to count specific account records."
        },
        "275": {
            "condition": "When combining district and account tables",
            "operation": " link rows where T1.district_id = T2.district_id using an inner match."
        },
        "276": {
            "condition": "When organizing results by district",
            "operation": " group by T1.A16 to aggregate counts per district."
        },
        "277": {
            "condition": "When finding the district with the highest account count",
            "operation": " order by T1.A16 DESC and keep only the first row (LIMIT 1)."
        },
        "278": {
            "condition": "When counting accounts, When combining district and account tables, When organizing results by district, When finding the district with the highest account count, When the question mentions crimes in 1996",
            "operation": " do not include crime-based filtering logic as it is incorrect for this query."
        },
        "279": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T1.account_id) from the trans table instead of COUNT(*) from the accounts table."
        },
        "280": {
            "condition": "When combining transaction and account data",
            "operation": " join account AS T2 with trans table using INNER JOIN on T1.account_id = T2.account_id."
        },
        "281": {
            "condition": "When filtering for credit card withdrawals",
            "operation": " use T1.operation = 'VYBER KARTOU' instead of account_type = 'credit card'."
        },
        "282": {
            "condition": "When filtering for negative balances",
            "operation": " use T1.balance < 0."
        },
        "283": {
            "condition": "When counting accounts, When combining transaction and account data, When filtering for credit card withdrawals, When filtering for negative balances, When filtering for monthly issuance accounts",
            "operation": " use T2.frequency = 'POPLATEK MESICNE' instead of monthly_issuance = 'yes'."
        },
        "284": {
            "condition": "When counting loans per account",
            "operation": " use COUNT(T2.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "285": {
            "condition": "When referencing tables",
            "operation": " use account AS T1 and loan AS T2 instead of loans l and accounts a."
        },
        "286": {
            "condition": "When combining account and loan tables",
            "operation": " use INNER JOIN with condition T1.account_id = T2.account_id."
        },
        "287": {
            "condition": "When filtering by date range",
            "operation": " use T2.date BETWEEN '1995-01-01' AND '1997-12-31' instead of loan_date."
        },
        "288": {
            "condition": "When filtering by account frequency",
            "operation": " use T1.frequency = 'POPLATEK MESICNE' instead of statement_frequency = 'monthly'."
        },
        "289": {
            "condition": "When filtering by loan amount",
            "operation": " keep T2.amount >= 250000."
        },
        "290": {
            "condition": "When counting loans per account, When referencing tables, When combining account and loan tables, When filtering by date range, When filtering by account frequency, When filtering by loan amount, When the question does not mention loan status",
            "operation": " do not include any status filter like 'approved'."
        },
        "291": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "292": {
            "condition": "When answering about accounts with contracts in Branch location 1",
            "operation": " add INNER JOIN district AS T2 ON T1.district_id = T2.district_id and INNER JOIN loan AS T3 ON T1.account_id = T3.account_id instead of querying only the accounts table."
        },
        "293": {
            "condition": "When filtering by branch location",
            "operation": " use T1.district_id = 1 instead of branch_location = 1 to use the correct column reference."
        },
        "294": {
            "condition": "When counting accounts, When answering about accounts with contracts in Branch location 1, When filtering by branch location, When checking for running contracts",
            "operation": " replace contract_status = 'running' with (T3.status = 'C' OR T3.status = 'D') to check loan status values."
        },
        "295": {
            "condition": "When counting clients",
            "operation": " use COUNT(T1.client_id) instead of COUNT(*) to count using the canonical key."
        },
        "296": {
            "condition": "When referring to the clients table",
            "operation": " use alias T1 instead of the bare table name."
        },
        "297": {
            "condition": "When combining clients and district tables",
            "operation": " join on T1.district_id = T2.district_id using an inner match."
        },
        "298": {
            "condition": "When filtering for male clients",
            "operation": " use T1.gender = 'M' instead of 'male' to match the exact literal value."
        },
        "299": {
            "condition": "When referring to the district identifier",
            "operation": " use T2.A15 instead of branch_id as the exact column token."
        },
        "300": {
            "condition": "When finding the second-highest value",
            "operation": " use ORDER BY T3.A15 DESC LIMIT 1, 1 instead of GROUP BY with COUNT and OFFSET."
        },
        "301": {
            "condition": "When counting clients, When referring to the clients table, When combining clients and district tables, When filtering for male clients, When referring to the district identifier, When finding the second-highest value, When selecting from district in subqueries",
            "operation": " use alias T3 for the district table in the subquery."
        },
        "302": {
            "condition": "When counting credit cards",
            "operation": " use COUNT(T1.card_id) to count specific non-null values instead of COUNT(*)."
        },
        "303": {
            "condition": "When combining card and disposition information",
            "operation": " join card AS T1 and disp AS T2 using INNER JOIN where T1.disp_id = T2.disp_id to properly link the tables."
        },
        "304": {
            "condition": "When filtering for high-level credit cards",
            "operation": " use T1.type = 'gold' instead of card_level = 'high' to reference the correct column and value."
        },
        "305": {
            "condition": "When counting credit cards, When combining card and disposition information, When filtering for high-level credit cards, When filtering for disposition type",
            "operation": " use T2.type = 'OWNER' instead of disposition_type = 'OWNER' to reference the joined table's column."
        },
        "306": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "307": {
            "condition": "When answering about accounts in a specific district",
            "operation": " join account AS T1 with district AS T2 using INNER JOIN on T1.district_id = T2.district_id to properly correlate accounts with their districts."
        },
        "308": {
            "condition": "When counting accounts, When answering about accounts in a specific district, When filtering by district name \"Pisek\"",
            "operation": " use T2.A2 = 'Pisek' instead of district = 'Pisek' to correctly reference the district name column from the joined table."
        },
        "309": {
            "condition": "When answering about districts with transactions greater than USS$10,000 in 1997",
            "operation": " make sure the output order: T1.district_id"
        },
        "310": {
            "condition": "When the question mentions \"districts\"",
            "operation": " \"districts\" actually means \"T1.district_id in schema\""
        },
        "311": {
            "condition": "When combining account AS T1 and district AS T2 for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)"
        },
        "312": {
            "condition": "When combining T1 and trans AS T3 for shared entities",
            "operation": " link rows where T1.account_id = T3.account_id and keep only matching pairs (inner match)"
        },
        "313": {
            "condition": "When the question asks about transactions in 1997",
            "operation": " use STRFTIME('%Y', T3.date) = '1997' to filter for year 1997"
        },
        "314": {
            "condition": "When the question asks for transactions greater than USS$10,000 per district",
            "operation": " organize results by T1.district_id and compute SUM(T3.amount) > 10000 per group using HAVING clause"
        },
        "315": {
            "condition": "When answering about districts with transactions greater than USS$10,000 in 1997, When the question mentions \"districts\", When combining account AS T1 and district AS T2 for shared entities, When combining T1 and trans AS T3 for shared entities, When the question asks about transactions in 1997, When the question asks for transactions greater than USS$10,000 per district, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for '1997'"
        },
        "316": {
            "condition": "When answering about accounts placing orders for household payment in Pisek",
            "operation": " make sure the output order: T2.account_id with DISTINCT."
        },
        "317": {
            "condition": "When the question mentions \"household payment\"",
            "operation": " \"household payment\" actually means \"T1.k_symbol = 'SIPO'\" in schema."
        },
        "318": {
            "condition": "When the question mentions \"Pisek\"",
            "operation": " \"Pisek\" actually means \"T3.A2 = 'Pisek'\" in schema (district name, not account city)."
        },
        "319": {
            "condition": "When combining T1 (trans) and T2 (account) for shared entities",
            "operation": " link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match)."
        },
        "320": {
            "condition": "When combining T2 (account) and T3 (district) for shared entities",
            "operation": " link rows where T2.district_id = T3.district_id and keep only matching pairs (inner match)."
        },
        "321": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "322": {
            "condition": "When answering about accounts placing orders for household payment in Pisek, When the question mentions \"household payment\", When the question mentions \"Pisek\", When combining T1 (trans) and T2 (account) for shared entities, When combining T2 (account) and T3 (district) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'SIPO' or 'Pisek'."
        },
        "323": {
            "condition": "When answering about \"accounts that have gold credit cards\"",
            "operation": " make sure the output order: T2.account_id."
        },
        "324": {
            "condition": "When the question mentions \"accounts\"",
            "operation": " \"accounts\" actually means \"T2.account_id in schema\"."
        },
        "325": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.disp_id = T2.disp_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "326": {
            "condition": "When answering about \"accounts that have gold credit cards\", When the question mentions \"accounts\", When combining T1 and T2 for shared entities, When filtering for gold credit cards",
            "operation": " use T1.type = 'gold' with exact literal 'gold' (case-sensitive)."
        },
        "327": {
            "condition": "When answering about average credit card amounts for account holders",
            "operation": " join tables using the exact key relationships shown - T1.disp_id = T2.disp_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id to access transaction data."
        },
        "328": {
            "condition": "When filtering for a specific year",
            "operation": " use STRFTIME('%Y', T4.date) = '1998' with exact literal '1998' instead of 2021."
        },
        "329": {
            "condition": "When filtering for credit card operations",
            "operation": " include T4.operation = 'VYBER KARTOU' with exact literal 'VYBER KARTOU'."
        },
        "330": {
            "condition": "When computing the average amount",
            "operation": " reference T4.amount instead of just amount."
        },
        "331": {
            "condition": "When answering about average credit card amounts for account holders, When filtering for a specific year, When filtering for credit card operations, When computing the average amount, When the question asks for a monthly average without grouping by month",
            "operation": " do not include any GROUP BY clause."
        },
        "332": {
            "condition": "When answering about account holder identification numbers",
            "operation": " use \"account_id\" from table \"trans\" instead of \"account_holder_id\" from \"credit_card_transactions\"."
        },
        "333": {
            "condition": "When combining account and transaction information",
            "operation": " link rows where T1.account_id = T2.account_id using an inner join between \"trans\" and \"account\" tables."
        },
        "334": {
            "condition": "When filtering for transactions in 1998",
            "operation": " use STRFTIME('%Y', T1.date) = '1998' to extract the year from the date column."
        },
        "335": {
            "condition": "When filtering for credit card operations",
            "operation": " include T1.operation = 'VYBER KARTOU' to select only credit card withdrawal transactions."
        },
        "336": {
            "condition": "When comparing transaction amounts to the average",
            "operation": " use amount < (subquery average) instead of amount > to find amounts less than average."
        },
        "337": {
            "condition": "When answering about account holder identification numbers, When combining account and transaction information, When filtering for transactions in 1998, When filtering for credit card operations, When comparing transaction amounts to the average, When calculating the average amount for comparison",
            "operation": " filter the subquery by STRFTIME('%Y', date) = '1998' to compute the average only for 1998 transactions rather than the overall average."
        },
        "338": {
            "condition": "When answering about account holder identification numbers",
            "operation": " use column \"account_id\" from table T1."
        },
        "339": {
            "condition": "When the question mentions \"transactions on the credit card\"",
            "operation": " filter for operation = 'VYBER KARTOU'."
        },
        "340": {
            "condition": "When the question specifies year 1998",
            "operation": " filter for transactions where the year part of date equals '1998'."
        },
        "341": {
            "condition": "When comparing transaction amounts to the average",
            "operation": " calculate the average amount from all transactions in 1998 without additional operation filters."
        },
        "342": {
            "condition": "When combining trans and account tables",
            "operation": " link rows where T1.account_id = T2.account_id using inner match."
        },
        "343": {
            "condition": "When answering about account holder identification numbers, When the question mentions \"transactions on the credit card\", When the question specifies year 1998, When comparing transaction amounts to the average, When combining trans and account tables, When selecting account identification numbers",
            "operation": " do not use DISTINCT to remove duplicates."
        },
        "344": {
            "condition": "When answering about female account holders who own credit cards and also have loans",
            "operation": " make sure the output order: T1.client_id"
        },
        "345": {
            "condition": "When the question mentions \"female\"",
            "operation": " \"female\" actually means \"T1.gender = 'F'\" in schema"
        },
        "346": {
            "condition": "When combining T1 (account_holders) and T2 (disp) for shared entities",
            "operation": " link rows where T1.client_id = T2.client_id and keep only matching pairs (inner match)"
        },
        "347": {
            "condition": "When combining T2 (disp) and T5 (account) for shared entities",
            "operation": " link rows where T2.account_id = T5.account_id and keep only matching pairs (inner match)"
        },
        "348": {
            "condition": "When combining T5 (account) and T3 (loan) for shared entities",
            "operation": " link rows where T5.account_id = T3.account_id and keep only matching pairs (inner match)"
        },
        "349": {
            "condition": "When combining T2 (disp) and T4 (card) for shared entities",
            "operation": " link rows where T2.disp_id = T4.disp_id and keep only matching pairs (inner match)"
        },
        "350": {
            "condition": "When answering about female account holders who own credit cards and also have loans, When the question mentions \"female\", When combining T1 (account_holders) and T2 (disp) for shared entities, When combining T2 (disp) and T5 (account) for shared entities, When combining T5 (account) and T3 (loan) for shared entities, When combining T2 (disp) and T4 (card) for shared entities, When the question asks for account holders with credit cards and loans",
            "operation": " the presence of credit cards is determined by successful inner join with card table (T4) and loans by successful inner join with loan table (T3), not by boolean flags"
        },
        "351": {
            "condition": "When counting clients",
            "operation": " count using T1.client_id instead of all columns to avoid counting null values."
        },
        "352": {
            "condition": "When combining clients and district tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "353": {
            "condition": "When filtering for female clients",
            "operation": " use T1.gender = 'F' instead of 'male' to use the correct gender code."
        },
        "354": {
            "condition": "When counting clients, When combining clients and district tables, When filtering for female clients, When filtering for South Bohemia region",
            "operation": " use T2.A3 = 'south Bohemia' instead of 'South Bohemia' to match the district table's region column with proper case sensitivity."
        },
        "355": {
            "condition": "When answering about accounts in a specific district",
            "operation": " join district table as T1 and account table as T2 on T1.district_id = T2.district_id instead of querying accounts directly."
        },
        "356": {
            "condition": "When identifying account owners",
            "operation": " join disp table as T3 on T2.account_id = T3.account_id and filter on T3.type = 'OWNER'."
        },
        "357": {
            "condition": "When filtering by district name",
            "operation": " use T1.A2 = 'Tabor' instead of district = 'Tabor'."
        },
        "358": {
            "condition": "When selecting output columns",
            "operation": " use only T2.account_id instead of all columns with *."
        },
        "359": {
            "condition": "When answering about accounts in a specific district, When identifying account owners, When filtering by district name, When selecting output columns, When the question asks about eligibility for loans",
            "operation": " do not filter on loan_status = 'approved' as this condition should be removed."
        },
        "360": {
            "condition": "When combining district and account tables",
            "operation": " link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "361": {
            "condition": "When combining account and disp tables",
            "operation": " link rows where T2.account_id = T3.account_id and keep only matching pairs (inner match)."
        },
        "362": {
            "condition": "When filtering by average income",
            "operation": " use T1.A11 BETWEEN 8000 AND 9000 (inclusive range) instead of separate greater than and less than or equal to conditions."
        },
        "363": {
            "condition": "When identifying account types that are not eligible for loans",
            "operation": " use T3.type != 'OWNER' instead of excluding loan account types through a subquery."
        },
        "364": {
            "condition": "When selecting account types",
            "operation": " use T3.type instead of a.account_type."
        },
        "365": {
            "condition": "When combining district and account tables, When combining account and disp tables, When filtering by average income, When identifying account types that are not eligible for loans, When selecting account types, When the question asks for distinct account types",
            "operation": " do not use DISTINCT in the selection."
        },
        "366": {
            "condition": "When answering about accounts in North Bohemia",
            "operation": " use T1.A3 = 'north Bohemia' for the region filter with exact case sensitivity."
        },
        "367": {
            "condition": "When filtering for transactions with partner bank AB",
            "operation": " use T3.bank = 'AB' instead of partner_bank column."
        },
        "368": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T2.account_id) to count specific account records instead of COUNT(*)."
        },
        "369": {
            "condition": "When combining district and accounts tables",
            "operation": " link rows where T1.district_id = T2.district_id using inner join."
        },
        "370": {
            "condition": "When answering about accounts in North Bohemia, When filtering for transactions with partner bank AB, When counting accounts, When combining district and accounts tables, When combining accounts and transactions tables",
            "operation": " link rows where T2.account_id = T3.account_id using inner join."
        },
        "371": {
            "condition": "When the question asks for \"how many accounts\"",
            "operation": " count all matching account rows using T2.account_id without removing duplicates."
        },
        "372": {
            "condition": "When combining district (T1) and account (T2) tables",
            "operation": " link rows where T1.district_id equals T2.district_id and keep only matching pairs."
        },
        "373": {
            "condition": "When combining account (T2) and trans (T3) tables",
            "operation": " link rows where T2.account_id equals T3.account_id and keep only matching pairs."
        },
        "374": {
            "condition": "When filtering for accounts from North Bohemia",
            "operation": " use the exact condition T1.A3 = 'north Bohemia' with the literal 'north Bohemia' exactly as specified."
        },
        "375": {
            "condition": "When the question asks for \"how many accounts\", When combining district (T1) and account (T2) tables, When combining account (T2) and trans (T3) tables, When filtering for accounts from North Bohemia, When filtering for transactions with partner's bank AB",
            "operation": " use the exact condition T3.bank = 'AB' with the literal 'AB' exactly as specified."
        },
        "376": {
            "condition": "When answering about \"districts with accounts that made withdrawal transactions\"",
            "operation": " make sure the output order: T1.A2."
        },
        "377": {
            "condition": "When the question mentions \"districts\"",
            "operation": " \"districts\" actually means \"district in schema\" and should be referenced as table T1."
        },
        "378": {
            "condition": "When the question mentions \"accounts\"",
            "operation": " \"accounts\" actually means \"account in schema\" and should be referenced as table T2."
        },
        "379": {
            "condition": "When the question mentions \"withdrawal transactions\"",
            "operation": " \"withdrawal transactions\" actually means \"trans in schema with type = 'VYDAJ'\" and should be referenced as table T3."
        },
        "380": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id; keep only matching pairs (inner match)."
        },
        "381": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.account_id = T3.account; keep only matching pairs (inner match)."
        },
        "382": {
            "condition": "When filtering for withdrawal transactions",
            "operation": " include only rows where T3.type = 'VYDAJ' exactly."
        },
        "383": {
            "condition": "When answering about \"districts with accounts that made withdrawal transactions\", When the question mentions \"districts\", When the question mentions \"accounts\", When the question mentions \"withdrawal transactions\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When filtering for withdrawal transactions, When selecting distinct district names",
            "operation": " return unique values of T1.A2."
        },
        "384": {
            "condition": "When answering about average number of crimes",
            "operation": " use AVG(T1.A15) from the district table instead of AVG(crimes) from crime_data."
        },
        "385": {
            "condition": "When combining district and account tables",
            "operation": " perform an INNER JOIN where T1.district_id = T2.district_id to link matching rows."
        },
        "386": {
            "condition": "When filtering for account opening year starting from 1997",
            "operation": " use STRFTIME('%Y', T2.date) >= '1997' instead of year-based filtering."
        },
        "387": {
            "condition": "When filtering for crimes exceeding 4000",
            "operation": " apply T1.A15 > 4000 directly as a condition."
        },
        "388": {
            "condition": "When answering about average number of crimes, When combining district and account tables, When filtering for account opening year starting from 1997, When filtering for crimes exceeding 4000, When handling date comparisons",
            "operation": " use STRFTIME function with format '%Y' to extract year from T2.date column."
        },
        "389": {
            "condition": "When answering about \"how many 'classic' cards are eligible for loan\"",
            "operation": " make sure the output order: COUNT(T1.card_id)."
        },
        "390": {
            "condition": "When the question mentions \"cards\"",
            "operation": " \"cards\" actually means \"card AS T1\" in schema."
        },
        "391": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.disp_id = T2.disp_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "392": {
            "condition": "When filtering for 'classic' cards",
            "operation": " use T1.type = 'classic' with exact literal 'classic'."
        },
        "393": {
            "condition": "When checking for loan eligibility",
            "operation": " use T2.type = 'OWNER' instead of loan_eligible = 'yes', with exact literal 'OWNER'."
        },
        "394": {
            "condition": "When answering about \"how many 'classic' cards are eligible for loan\", When the question mentions \"cards\", When combining T1 and T2 for shared entities, When filtering for 'classic' cards, When checking for loan eligibility, When counting cards",
            "operation": " compute the number of rows using the canonical key token T1.card_id instead of COUNT(*)."
        },
        "395": {
            "condition": "When counting clients",
            "operation": " use COUNT(T1.client_id) instead of COUNT(*) to count specific client identifiers."
        },
        "396": {
            "condition": "When combining client and district information",
            "operation": " join client AS T1 with district AS T2 on T1.district_id = T2.district_id to properly relate district information."
        },
        "397": {
            "condition": "When filtering for male clients",
            "operation": " use T1.gender = 'M' instead of filtering for female clients."
        },
        "398": {
            "condition": "When counting clients, When combining client and district information, When filtering for male clients, When filtering for district 'Hl.m. Praha'",
            "operation": " use T2.A2 = 'Hl.m. Praha' instead of a non-existent district column in the client table."
        },
        "399": {
            "condition": "When the question mentions 'Gold' cards",
            "operation": " use the exact literal 'gold' (lowercase) for card type comparison."
        },
        "400": {
            "condition": "When handling date comparisons with 'prior to 1998'",
            "operation": " extract year from the \"issued\" column using STRFTIME('%Y', issued) and compare to '1998'."
        },
        "401": {
            "condition": "When calculating percentage of Gold cards issued prior to 1998",
            "operation": " use conditional aggregation with SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') for the numerator."
        },
        "402": {
            "condition": "When counting total Gold cards for the denominator",
            "operation": " use COUNT(card_id) with condition type = 'gold' instead of counting all rows."
        },
        "403": {
            "condition": "When performing percentage calculation",
            "operation": " use CAST(... AS REAL) for floating-point division to avoid integer division."
        },
        "404": {
            "condition": "When the question mentions 'Gold' cards, When handling date comparisons with 'prior to 1998', When calculating percentage of Gold cards issued prior to 1998, When counting total Gold cards for the denominator, When performing percentage calculation, When referencing the table",
            "operation": " use the exact table name \"card\" (singular) instead of \"cards\" (plural)."
        },
        "405": {
            "condition": "When the question asks for percentage of 'Gold' cards issued prior to 1998",
            "operation": " use SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') with implicit boolean-to-integer conversion instead of explicit CASE WHEN expressions."
        },
        "406": {
            "condition": "When counting cards for percentage calculation",
            "operation": " divide by COUNT(card_id) to count all cards rather than just gold cards."
        },
        "407": {
            "condition": "When filtering for gold cards",
            "operation": " remove the WHERE type = 'gold' filter since the aggregation logic already handles gold card filtering internally."
        },
        "408": {
            "condition": "When the question asks for percentage of 'Gold' cards issued prior to 1998, When counting cards for percentage calculation, When filtering for gold cards, When calculating percentage",
            "operation": " use integer division 100 / COUNT(card_id) instead of floating-point division 100.0 / COUNT(...) as the CAST to REAL ensures proper percentage calculation."
        },
        "409": {
            "condition": "When answering about \"owner of the account with the largest loan amount\"",
            "operation": " make sure the output order: T1.client_id."
        },
        "410": {
            "condition": "When the question mentions \"owner\"",
            "operation": " \"owner\" actually means \"T1.type = 'OWNER'\" in schema."
        },
        "411": {
            "condition": "When the question mentions \"largest loan amount\"",
            "operation": " \"largest loan amount\" actually means \"T2.amount DESC\" in schema."
        },
        "412": {
            "condition": "When combining T1 (disp), T3 (account), and T2 (loan) for shared entities",
            "operation": " link rows where T1.account_id = T3.account_id and T3.account_id = T2.account_id; keep only matching pairs (inner match)."
        },
        "413": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "414": {
            "condition": "When answering about \"owner of the account with the largest loan amount\", When the question mentions \"owner\", When the question mentions \"largest loan amount\", When combining T1 (disp), T3 (account), and T2 (loan) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'OWNER'."
        },
        "415": {
            "condition": "When the question asks for \"number of committed crimes in 1995\"",
            "operation": " the schema actually stores this value directly as column \"A15\" in the district table instead of requiring counting from a crimes table."
        },
        "416": {
            "condition": "When combining district and account tables",
            "operation": " link rows where T1.district_id = T2.district_id using an inner match and keep only matching pairs."
        },
        "417": {
            "condition": "When filtering for account with id 532",
            "operation": " use exact literal value 532 with T2.account_id = 532."
        },
        "418": {
            "condition": "When the question mentions \"district of the account\"",
            "operation": " this requires joining district (T1) and account (T2) tables to find the district associated with account 532."
        },
        "419": {
            "condition": "When the question asks for \"number of committed crimes in 1995\", When combining district and account tables, When filtering for account with id 532, When the question mentions \"district of the account\", When producing output",
            "operation": " return the exact column T1.A15 which contains the pre-computed number of committed crimes in 1995 for that district."
        },
        "420": {
            "condition": "When the question asks for district Id of an account that placed a specific order",
            "operation": " navigate through the relational path from order to account to district tables using the exact join conditions shown in the amends."
        },
        "421": {
            "condition": "When filtering for a specific order with id 33333",
            "operation": " apply the filter condition T1.order_id = 33333 on the order table (T1) instead of filtering in the wrong table context."
        },
        "422": {
            "condition": "When joining order (T1) and account (T2)",
            "operation": " link rows where T1.account_id = T2.account_id to establish the relationship between orders and accounts."
        },
        "423": {
            "condition": "When joining account (T2) and district (T3)",
            "operation": " link rows where T2.district_id = T3.district_id to access district information from the account."
        },
        "424": {
            "condition": "When the question asks for district Id of an account that placed a specific order, When filtering for a specific order with id 33333, When joining order (T1) and account (T2), When joining account (T2) and district (T3), When retrieving the district_id",
            "operation": " use T3.district_id from the district table instead of district_id from the accounts table, as the district table contains the canonical district information."
        },
        "425": {
            "condition": "When answering about \"withdrawals in cash transactions for client with id 3356\"",
            "operation": " make sure the output order: T4.trans_id."
        },
        "426": {
            "condition": "When the question mentions \"client with the id 3356\"",
            "operation": " \"client_id\" actually means \"T1.client_id = 3356\" in schema."
        },
        "427": {
            "condition": "When the question mentions \"withdrawals in cash transactions\"",
            "operation": " \"withdrawal\" and \"cash\" actually mean \"T4.operation = 'VYBER'\" in schema."
        },
        "428": {
            "condition": "When combining T1, T2, T3, and T4 for shared entities",
            "operation": " link rows where T1.client_id = T2.client_id, T2.account_id = T3.account_id, and T3.account_id = T4.account_id; keep only matching pairs (inner match)."
        },
        "429": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "430": {
            "condition": "When answering about \"withdrawals in cash transactions for client with id 3356\", When the question mentions \"client with the id 3356\", When the question mentions \"withdrawals in cash transactions\", When combining T1, T2, T3, and T4 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'VYBER'."
        },
        "431": {
            "condition": "When counting entities from the database",
            "operation": " use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "432": {
            "condition": "When the question mentions \"weekly issuance accounts\"",
            "operation": " this means accounts where T2.frequency = 'POPLATEK TYDNE' exactly."
        },
        "433": {
            "condition": "When combining loan and account tables",
            "operation": " link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match)."
        },
        "434": {
            "condition": "When the question asks for loans \"under 200000\"",
            "operation": " use T1.amount < 200000 to find amounts below the threshold."
        },
        "435": {
            "condition": "When counting entities from the database, When the question mentions \"weekly issuance accounts\", When combining loan and account tables, When the question asks for loans \"under 200000\", When answering about \"how many have a loan of under 200000\"",
            "operation": " make sure the output order: count of accounts with weekly frequency and loan amount under 200000."
        },
        "436": {
            "condition": "When answering about credit card type for a specific client",
            "operation": " make sure the output order: T3.type"
        },
        "437": {
            "condition": "When the question mentions \"client with id 13539\"",
            "operation": " \"client_id\" actually means \"T2.client_id\" in schema with value 13539"
        },
        "438": {
            "condition": "When combining tables for client information",
            "operation": " link rows where T1.client_id = T2.client_id and T1.disp_id = T3.disp_id using inner matches only"
        },
        "439": {
            "condition": "When answering about credit card type for a specific client, When the question mentions \"client with id 13539\", When combining tables for client information, When selecting from multiple tables",
            "operation": " use tables disp AS T1, client AS T2, and card AS T3 instead of querying only clients table"
        },
        "440": {
            "condition": "When answering about \"region of the client with id 3541\"",
            "operation": " select T1.A3 from the district table instead of region from the clients table."
        },
        "441": {
            "condition": "When combining district and client tables",
            "operation": " link rows where T1.district_id = T2.district_id using an inner join to keep only matching pairs."
        },
        "442": {
            "condition": "When answering about \"region of the client with id 3541\", When combining district and client tables, When filtering for client with id 3541",
            "operation": " use T2.client_id = 3541 to properly reference the joined table."
        },
        "443": {
            "condition": "When answering about districts with accounts and loan contracts",
            "operation": " use explicit table aliases T1 for district, T2 for Account, and T3 for Loan instead of direct table references."
        },
        "444": {
            "condition": "When selecting the district identifier",
            "operation": " use T1.A2 in the SELECT list instead of district_id."
        },
        "445": {
            "condition": "When combining district, account, and loan information",
            "operation": " add joins with Account AS T2 and Loan AS T3 instead of querying only the accounts table."
        },
        "446": {
            "condition": "When linking district to account",
            "operation": " use join condition T1.District_id = T2.District_id."
        },
        "447": {
            "condition": "When linking account to loan",
            "operation": " use join condition T2.Account_id = T3.Account_id."
        },
        "448": {
            "condition": "When filtering for loan contracts finished with no problems",
            "operation": " use WHERE filter T3.status = 'A' instead of loan_status = 'finished'."
        },
        "449": {
            "condition": "When grouping by district",
            "operation": " use GROUP BY T1.District_id instead of district_id."
        },
        "450": {
            "condition": "When ordering by account count",
            "operation": " use ORDER BY COUNT(T2.Account_id) instead of account_count."
        },
        "451": {
            "condition": "When answering about districts with accounts and loan contracts, When selecting the district identifier, When combining district, account, and loan information, When linking district to account, When linking account to loan, When filtering for loan contracts finished with no problems, When grouping by district, When ordering by account count, When counting accounts",
            "operation": " use COUNT(T2.Account_id) as the counting key for accounts."
        },
        "452": {
            "condition": "When answering about \"Who placed the order with the id 32423\"",
            "operation": " make sure the output order: T3.client_id"
        },
        "453": {
            "condition": "When the question mentions \"order with the id 32423\"",
            "operation": " filter rows where T1.order_id = 32423"
        },
        "454": {
            "condition": "When combining tables for this query",
            "operation": " link T1 (order) and T2 (account) where T1.account_id = T2.account_id using inner match"
        },
        "455": {
            "condition": "When combining tables for this query",
            "operation": " link T4 (disp) and T2 (account) where T4.account_id = T2.account_id using inner match"
        },
        "456": {
            "condition": "When combining tables for this query",
            "operation": " link T4 (disp) and T3 (client) where T4.client_id = T3.client_id using inner match"
        },
        "457": {
            "condition": "When answering about \"Who placed the order with the id 32423\", When the question mentions \"order with the id 32423\", When combining tables for this query, When combining tables for this query, When combining tables for this query, When selecting output",
            "operation": " return only T3.client_id instead of all columns"
        },
        "458": {
            "condition": "When answering about \"transactions made by accounts from district 5\"",
            "operation": " make sure the output order: T3.trans_id."
        },
        "459": {
            "condition": "When the question mentions \"district 5\"",
            "operation": " \"district 5\" actually means \"T1.district_id = 5\" in schema."
        },
        "460": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.district_id = T2.district_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "461": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.account_id = T3.account_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "462": {
            "condition": "When answering about \"transactions made by accounts from district 5\", When the question mentions \"district 5\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "463": {
            "condition": "When answering about \"accounts from Jesenik district\"",
            "operation": " join table \"district\" as T1 with table \"account\" as T2 on T1.district_id = T2.district_id to link district information with account records."
        },
        "464": {
            "condition": "When filtering for \"Jesenik district\"",
            "operation": " use T1.A2 = 'Jesenik' to identify the correct district by name."
        },
        "465": {
            "condition": "When counting accounts",
            "operation": " count T2.account_id instead of all rows to ensure accurate counting of account records."
        },
        "466": {
            "condition": "When answering about \"accounts from Jesenik district\", When filtering for \"Jesenik district\", When counting accounts, When combining tables for shared entities",
            "operation": " perform an inner match where T1.district_id = T2.district_id to keep only accounts that have matching district information."
        },
        "467": {
            "condition": "When answering about \"clients' IDs whose junior credit cards were issued after 1996\"",
            "operation": " make sure the output order: T2.client_id."
        },
        "468": {
            "condition": "When the question mentions \"junior credit cards\"",
            "operation": " \"junior\" actually means \"T1.type = 'junior'\" in schema."
        },
        "469": {
            "condition": "When the question mentions \"issued after 1996\"",
            "operation": " use date comparison T1.issued >= '1997-01-01' to represent cards issued from 1997 onward."
        },
        "470": {
            "condition": "When combining card table as T1 and disp table as T2",
            "operation": " link rows where T1.disp_id = T2.disp_id and keep only matching pairs (inner match)."
        },
        "471": {
            "condition": "When answering about \"clients' IDs whose junior credit cards were issued after 1996\", When the question mentions \"junior credit cards\", When the question mentions \"issued after 1996\", When combining card table as T1 and disp table as T2, When selecting client IDs",
            "operation": " use T2.client_id from the disp table instead of client_id from the card table."
        },
        "472": {
            "condition": "When calculating percentage of female clients",
            "operation": " use SUM(T2.gender = 'F') with explicit CAST to REAL instead of COUNT(CASE WHEN c.gender = 'F' THEN 1 END)."
        },
        "473": {
            "condition": "When filtering by average salary",
            "operation": " reference T1.A11 instead of d.average_salary and use the condition T1.A11 > 10000."
        },
        "474": {
            "condition": "When joining tables",
            "operation": " use INNER JOIN with explicit alias T2 for the client table instead of JOIN with alias c."
        },
        "475": {
            "condition": "When calculating the denominator for percentage",
            "operation": " use COUNT(T2.client_id) instead of COUNT(*)."
        },
        "476": {
            "condition": "When the question asks about clients who opened accounts",
            "operation": " do not include the account_opened_date IS NOT NULL condition."
        },
        "477": {
            "condition": "When calculating percentage of female clients, When filtering by average salary, When joining tables, When calculating the denominator for percentage, When the question asks about clients who opened accounts, When producing output",
            "operation": " do not include column aliases like percentage_women."
        },
        "478": {
            "condition": "When joining district and client tables",
            "operation": " link rows where T1.district_id equals T2.district_id exactly as T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        },
        "479": {
            "condition": "When filtering districts by average salary",
            "operation": " include only rows where T1.A11 is greater than 10000."
        },
        "480": {
            "condition": "When calculating percentage of female clients",
            "operation": " compute (number of rows where T2.gender equals 'F') divided by (total number of rows) multiplied by 100."
        },
        "481": {
            "condition": "When counting clients",
            "operation": " use T2.client_id as the counting key for both numerator and denominator."
        },
        "482": {
            "condition": "When joining district and client tables, When filtering districts by average salary, When calculating percentage of female clients, When counting clients, When handling text literals",
            "operation": " preserve the exact value 'F' for gender comparison without changing case."
        },
        "483": {
            "condition": "When calculating growth rate between two years",
            "operation": " cast the numerator subtraction to REAL before division, then multiply by 100 after division instead of before."
        },
        "484": {
            "condition": "When joining tables for client loan analysis",
            "operation": " use T1 for loans, T2 for accounts, T3 for disp, and T4 for clients instead of custom aliases."
        },
        "485": {
            "condition": "When connecting accounts to clients",
            "operation": " add an INNER JOIN on disp table T3 with condition T3.account_id = T2.account_id."
        },
        "486": {
            "condition": "When joining clients to accounts",
            "operation": " use T4.client_id = T3.client_id instead of direct client-account linking."
        },
        "487": {
            "condition": "When filtering for male clients",
            "operation": " use T4.gender = 'M' instead of 'male'."
        },
        "488": {
            "condition": "When identifying account owners",
            "operation": " add filter T3.type = 'OWNER' to ensure only owner relationships are considered."
        },
        "489": {
            "condition": "When handling year filtering",
            "operation": " remove explicit year filters from WHERE clause since year filtering is already handled in CASE statements."
        },
        "490": {
            "condition": "When calculating growth rate between two years, When joining tables for client loan analysis, When connecting accounts to clients, When joining clients to accounts, When filtering for male clients, When identifying account owners, When handling year filtering, When producing output",
            "operation": " remove column aliases from the final result."
        },
        "491": {
            "condition": "When calculating growth rate percentages",
            "operation": " apply multiplication by 100 after casting the division result to REAL instead of before casting."
        },
        "492": {
            "condition": "When computing year-over-year loan amount differences",
            "operation": " use identical CASE expressions for filtering years 1996 and 1997 without changing the structure."
        },
        "493": {
            "condition": "When combining loan, account, disp, and client tables",
            "operation": " maintain INNER JOIN conditions exactly as T1.account_id=T2.account_id, T3.account_id=T2.account_id, and T4.client_id=T3.client_id."
        },
        "494": {
            "condition": "When calculating growth rate percentages, When computing year-over-year loan amount differences, When combining loan, account, disp, and client tables, When filtering for male clients who are account owners",
            "operation": " preserve WHERE conditions T4.gender='M' and T3.type='OWNER' unchanged."
        },
        "495": {
            "condition": "When calculating growth rate percentage between two years",
            "operation": " cast the entire numerator (difference between sums) as REAL before division, then multiply by 100 after the division operation."
        },
        "496": {
            "condition": "When joining loan, account, disp, and client tables",
            "operation": " use inner joins with T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id."
        },
        "497": {
            "condition": "When filtering for male clients",
            "operation": " use T4.gender = 'M' with exact case and quotes."
        },
        "498": {
            "condition": "When filtering for account owners",
            "operation": " use T3.type = 'OWNER' with exact case and quotes."
        },
        "499": {
            "condition": "When calculating growth rate percentage between two years, When joining loan, account, disp, and client tables, When filtering for male clients, When filtering for account owners, When calculating loan amounts by year",
            "operation": " use strftime('%Y', T1.date) to extract year from date column and compare with exact string literals '1996' and '1997'."
        },
        "500": {
            "condition": "When calculating growth rate percentage",
            "operation": " apply multiplication by 100 after casting to REAL to avoid integer division issues."
        },
        "501": {
            "condition": "When combining loan, account, disp, and client tables",
            "operation": " link rows using exact key equalities T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id with inner matches only."
        },
        "502": {
            "condition": "When filtering for male clients",
            "operation": " use exact literal 'M' for T4.gender."
        },
        "503": {
            "condition": "When filtering for account owners",
            "operation": " use exact literal 'OWNER' for T3.type."
        },
        "504": {
            "condition": "When calculating growth rate percentage, When combining loan, account, disp, and client tables, When filtering for male clients, When filtering for account owners, When computing loan amounts by year",
            "operation": " use strftime('%Y', T1.date) to extract year from date and compare with exact literals '1996' and '1997'."
        },
        "505": {
            "condition": "When calculating growth rate percentages",
            "operation": " apply multiplication by 100 after casting the division result to REAL type, not before."
        },
        "506": {
            "condition": "When filtering for male clients",
            "operation": " use the exact literal 'M' for the gender condition."
        },
        "507": {
            "condition": "When identifying account owners",
            "operation": " use the exact literal 'OWNER' for the disp type condition."
        },
        "508": {
            "condition": "When joining loan, account, disp, and client tables",
            "operation": " link rows using the exact key equalities T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id."
        },
        "509": {
            "condition": "When computing loan amounts by year",
            "operation": " extract the year from the date column using strftime('%Y', T1.date) and compare to exact literals '1996' and '1997'."
        },
        "510": {
            "condition": "When calculating growth rate percentages, When filtering for male clients, When identifying account owners, When joining loan, account, disp, and client tables, When computing loan amounts by year, When calculating growth rate",
            "operation": " compute (1997 total amount - 1996 total amount) divided by 1996 total amount, then multiply by 100 after casting to REAL."
        },
        "511": {
            "condition": "When calculating percentage growth rate",
            "operation": " perform the subtraction between 1997 and 1996 amounts before casting to REAL, then multiply by 100 after the division operation instead of before."
        },
        "512": {
            "condition": "When combining loan, account, disp, and client tables",
            "operation": " use inner joins with exact conditions T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id."
        },
        "513": {
            "condition": "When calculating percentage growth rate, When combining loan, account, disp, and client tables, When filtering for male clients who are account owners",
            "operation": " apply WHERE conditions T4.gender = 'M' and T3.type = 'OWNER' exactly as specified."
        },
        "514": {
            "condition": "When calculating growth rate percentages",
            "operation": " apply multiplication by 100 after casting the division result to REAL type, not before the division."
        },
        "515": {
            "condition": "When joining loan, account, disp, and client tables",
            "operation": " use inner joins exactly as specified with T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id."
        },
        "516": {
            "condition": "When filtering for male clients",
            "operation": " use exact condition T4.gender = 'M' with literal 'M'."
        },
        "517": {
            "condition": "When calculating growth rate percentages, When joining loan, account, disp, and client tables, When filtering for male clients, When filtering for account owners",
            "operation": " use exact condition T3.type = 'OWNER' with literal 'OWNER'."
        },
        "518": {
            "condition": "When calculating percentage growth rate between two years",
            "operation": " compute (sum for later year minus sum for earlier year) divided by sum for earlier year, then multiply by 100 to get percentage."
        },
        "519": {
            "condition": "When the question specifies a male client",
            "operation": " filter where T4.gender equals exactly 'M'."
        },
        "520": {
            "condition": "When the question involves account ownership",
            "operation": " filter where T3.type equals exactly 'OWNER'."
        },
        "521": {
            "condition": "When combining loan, account, disp, and client tables",
            "operation": " link rows where T1.account_id = T2.account_id, T3.account_id = T2.account_id, and T4.client_id = T3.client_id using inner matches only."
        },
        "522": {
            "condition": "When extracting year from date fields",
            "operation": " use strftime('%Y', T1.date) to get the 4-digit year."
        },
        "523": {
            "condition": "When calculating percentage growth rate between two years, When the question specifies a male client, When the question involves account ownership, When combining loan, account, disp, and client tables, When extracting year from date fields, When handling mathematical operations for growth rate",
            "operation": " cast only the difference calculation to REAL before division, not the entire expression."
        },
        "524": {
            "condition": "When counting credit card withdrawals",
            "operation": " count non-null account_id values instead of all rows to exclude null values."
        },
        "525": {
            "condition": "When referencing the transactions table",
            "operation": " use table name \"trans\" instead of \"transactions\" to match the correct schema."
        },
        "526": {
            "condition": "When filtering for credit card withdrawals",
            "operation": " use condition operation = 'VYBER KARTOU' instead of transaction_type = 'credit_card' to use the proper column name and value."
        },
        "527": {
            "condition": "When counting credit card withdrawals, When referencing the transactions table, When filtering for credit card withdrawals, When filtering for transactions after 1995",
            "operation": " extract year from date column using STRFTIME('%Y', date) > '1995' instead of filtering on a year column to properly handle date-based filtering."
        },
        "528": {
            "condition": "When the question asks about crime counts in specific regions",
            "operation": " use the district table instead of a crimes table, with column A3 for region names and A16 for count values."
        },
        "529": {
            "condition": "When calculating the difference between counts for 'East Bohemia' and 'North Bohemia'",
            "operation": " use SUM(IIF(A3 = 'east Bohemia', A16, 0)) - SUM(IIF(A3 = 'north Bohemia', A16, 0)) instead of subtracting separate COUNT(*) subqueries."
        },
        "530": {
            "condition": "When comparing region names",
            "operation": " use case-insensitive comparisons with 'east Bohemia' and 'north Bohemia' instead of exact case matches."
        },
        "531": {
            "condition": "When the question asks about crime counts in specific regions, When calculating the difference between counts for 'East Bohemia' and 'North Bohemia', When comparing region names, When working with aggregated crime data",
            "operation": " do not filter by year since the data already represents the specific year 1996 in aggregated form."
        },
        "532": {
            "condition": "When counting specific disposition types 'OWNER' and 'DISPONENT'",
            "operation": " use SUM(type = 'OWNER') and SUM(type = 'DISPONENT') to count each type separately instead of COUNT(*)."
        },
        "533": {
            "condition": "When referencing the dispositions table",
            "operation": " use table name \"disp\" instead of \"dispositions\"."
        },
        "534": {
            "condition": "When filtering account numbers from 1 to 10",
            "operation": " use account_id BETWEEN 1 AND 10 to include all accounts in the range rather than multiple equality conditions."
        },
        "535": {
            "condition": "When counting specific disposition types 'OWNER' and 'DISPONENT', When referencing the dispositions table, When filtering account numbers from 1 to 10, When handling disposition type filtering",
            "operation": " remove explicit IN ('OWNER', 'DISPONENT') filter since the SUM conditions handle type filtering implicitly."
        },
        "536": {
            "condition": "When answering about account statement release frequency and transaction purpose",
            "operation": " make sure the output order: T1.frequency, T2.k_symbol"
        },
        "537": {
            "condition": "When the question mentions \"account number 3\"",
            "operation": " \"account number 3\" actually means T1.account_id = 3 in schema"
        },
        "538": {
            "condition": "When the question asks for \"how often\" account statements are released",
            "operation": " use T1.frequency column instead of counting statement releases"
        },
        "539": {
            "condition": "When the question asks for \"aim of debiting 3539 in total\"",
            "operation": " use T2.k_symbol column to show the purpose instead of summing transaction amounts"
        },
        "540": {
            "condition": "When combining account and order data",
            "operation": " link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match)"
        },
        "541": {
            "condition": "When filtering for total amount of 3539",
            "operation": " apply filter T2.total_amount = 3539 instead of filtering individual transaction amounts"
        },
        "542": {
            "condition": "When answering about account statement release frequency and transaction purpose, When the question mentions \"account number 3\", When the question asks for \"how often\" account statements are released, When the question asks for \"aim of debiting 3539 in total\", When combining account and order data, When filtering for total amount of 3539, When aggregating order data",
            "operation": " calculate SUM(amount) AS total_amount from the order table with GROUP BY account_id, k_symbol instead of filtering transactions by type and amount"
        },
        "543": {
            "condition": "When the question asks for a year from a birth date",
            "operation": " extract the year component from the birth_date field using STRFTIME('%Y', T1.birth_date) instead of using a direct birth_year column."
        },
        "544": {
            "condition": "When querying about account owners",
            "operation": " use the client table (aliased as T1) instead of account_owners table, as it contains the birth_date field."
        },
        "545": {
            "condition": "When establishing relationships between client and account data",
            "operation": " join client AS T1 with disp AS T3 using T1.client_id = T3.client_id, then join with account AS T2 using T3.account_id = T2.account_id to properly connect client information to account ownership."
        },
        "546": {
            "condition": "When the question asks for a year from a birth date, When querying about account owners, When establishing relationships between client and account data, When filtering by account number 130",
            "operation": " use WHERE T2.account_id = 130 instead of owner_id = 130 to correctly identify the account by its account_id field."
        },
        "547": {
            "condition": "When counting accounts",
            "operation": " use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "548": {
            "condition": "When the question mentions \"owner disposition\"",
            "operation": " join disp AS T2 with account AS T1 using INNER JOIN on T1.account_id = T2.account_id to access disposition information."
        },
        "549": {
            "condition": "When filtering for owner disposition",
            "operation": " use T2.type = 'OWNER' with exact case instead of disposition = 'owner'."
        },
        "550": {
            "condition": "When the question mentions \"request for a statement to be generated upon a transaction\"",
            "operation": " this corresponds to T1.frequency = 'POPLATEK PO OBRATU' in the schema."
        },
        "551": {
            "condition": "When counting accounts, When the question mentions \"owner disposition\", When filtering for owner disposition, When the question mentions \"request for a statement to be generated upon a transaction\", When combining account and disposition tables",
            "operation": " only keep rows where T1.account_id = T2.account_id (inner match)."
        },
        "552": {
            "condition": "When answering about client debt and payment status",
            "operation": " select T4.amount and T4.status instead of aggregating with SUM and COUNT functions."
        },
        "553": {
            "condition": "When querying for client number 992",
            "operation": " filter using T1.client_id = 992 instead of just client_id = 992 to reference the correct joined table."
        },
        "554": {
            "condition": "When combining client and related tables",
            "operation": " link T1 (client) to T2 (disp) using T1.client_id = T2.client_id."
        },
        "555": {
            "condition": "When combining disp and account tables",
            "operation": " link T2 to T3 (account) using T2.account_id = T3.account_id."
        },
        "556": {
            "condition": "When combining account and loan tables",
            "operation": " link T3 to T4 (loan) using T3.account_id = T4.account_id."
        },
        "557": {
            "condition": "When answering about client debt and payment status, When querying for client number 992, When combining client and related tables, When combining disp and account tables, When combining account and loan tables, When retrieving loan details",
            "operation": " use inner joins for all table combinations to ensure only matching pairs are included."
        },
        "558": {
            "condition": "When answering about client number 4's account balance following transaction 851",
            "operation": " select \"balance\" from table \"trans\" instead of using SUM(amount) aggregation."
        },
        "559": {
            "condition": "When determining account ownership gender",
            "operation": " select \"gender\" from table \"client\" instead of using a CASE expression."
        },
        "560": {
            "condition": "When joining tables for client-account-transaction relationships",
            "operation": " use \"disp\" table as T2 as an intermediate join between \"client\" as T1 and \"account\" as T3."
        },
        "561": {
            "condition": "When filtering by client",
            "operation": " use client_id = 4 condition in WHERE clause."
        },
        "562": {
            "condition": "When filtering by transaction",
            "operation": " use trans_id = 851 condition in WHERE clause instead of transaction_id."
        },
        "563": {
            "condition": "When answering about client number 4's account balance following transaction 851, When determining account ownership gender, When joining tables for client-account-transaction relationships, When filtering by client, When filtering by transaction, When the question asks about a specific transaction's effect",
            "operation": " return individual record values rather than aggregated summaries."
        },
        "564": {
            "condition": "When answering about \"which kind of credit card client number 9 possess\"",
            "operation": " make sure the output order: T3.type."
        },
        "565": {
            "condition": "When the question mentions \"client number 9\"",
            "operation": " \"client number 9\" actually means \"T1.client_id = 9\" in schema."
        },
        "566": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.client_id = T2.client_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "567": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.disp_id = T3.disp_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "568": {
            "condition": "When answering about \"which kind of credit card client number 9 possess\", When the question mentions \"client number 9\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "569": {
            "condition": "When answering about client payments",
            "operation": " start with client as T1 and join through disposition, account, and transaction tables using the exact key relationships T1.client_id = T4.client_id, T4.account_id = T2.account_id, and T2.account_id = T3.account_id."
        },
        "570": {
            "condition": "When filtering by client number 617",
            "operation": " use T1.client_id = 617 with the exact table alias."
        },
        "571": {
            "condition": "When filtering transactions from year 1998",
            "operation": " extract year using STRFTIME('%Y', T3.date) = '1998' with exact function and literal format."
        },
        "572": {
            "condition": "When summing transaction amounts",
            "operation": " use SUM(T3.amount) with exact table alias qualification."
        },
        "573": {
            "condition": "When answering about client payments, When filtering by client number 617, When filtering transactions from year 1998, When summing transaction amounts, When combining tables for this query",
            "operation": " perform inner joins only to keep matching pairs across all four tables."
        },
        "574": {
            "condition": "When answering about clients and their accounts",
            "operation": " make sure to select both client_id and account_id from the appropriate tables."
        },
        "575": {
            "condition": "When combining client and district information",
            "operation": " link rows where T1.district_id = T2.district_id using an inner match."
        },
        "576": {
            "condition": "When combining client and account information through disposition",
            "operation": " link rows where T1.client_id = T4.client_id and T4.account_id = T3.account_id using inner matches."
        },
        "577": {
            "condition": "When filtering by region",
            "operation": " use T2.A3 = 'east Bohemia' with exact case sensitivity."
        },
        "578": {
            "condition": "When filtering by birth year range",
            "operation": " use STRFTIME('%Y', T1.birth_date) BETWEEN '1983' AND '1987' with string year bounds instead of numeric bounds."
        },
        "579": {
            "condition": "When answering about clients and their accounts, When combining client and district information, When combining client and account information through disposition, When filtering by region, When filtering by birth year range, When the question mentions \"account branch is in East Bohemia\"",
            "operation": " \"East Bohemia\" actually means \"T2.A3 = 'east Bohemia'\" in schema with lowercase 'e'."
        },
        "580": {
            "condition": "When answering about female clients with largest loans",
            "operation": " join tables \"clients\" as T1, \"disp\" as T4, \"account\" as T2, and \"loan\" as T3 using inner matches where T1.client_id = T4.client_id, T4.account_id = T2.account_id, and T4.account_id = T3.account_id."
        },
        "581": {
            "condition": "When filtering for female clients",
            "operation": " use T1.gender = 'F' exactly."
        },
        "582": {
            "condition": "When ordering by loan size",
            "operation": " sort by T3.amount in descending order."
        },
        "583": {
            "condition": "When selecting the top 3",
            "operation": " keep only the first 3 rows after ordering."
        },
        "584": {
            "condition": "When answering about female clients with largest loans, When filtering for female clients, When ordering by loan size, When selecting the top 3, When outputting results",
            "operation": " return only the client_id column from T1."
        },
        "585": {
            "condition": "When answering about male customers born between 1974 and 1976 with payments over $4000",
            "operation": " make sure the output order: COUNT(T1.account_id)."
        },
        "586": {
            "condition": "When the question mentions \"male customers\"",
            "operation": " \"male\" actually means \"T3.gender = 'M'\" in schema."
        },
        "587": {
            "condition": "When the question mentions \"born between 1974 and 1976\"",
            "operation": " extract birth year from STRFTIME('%Y', T3.birth_date) and filter between 1974 and 1976 inclusive."
        },
        "588": {
            "condition": "When the question mentions \"payment in excess of $4000\"",
            "operation": " use T1.amount > 4000."
        },
        "589": {
            "condition": "When the question mentions \"payment on their home\"",
            "operation": " use T1.k_symbol = 'SIPO'."
        },
        "590": {
            "condition": "When combining tables for this query",
            "operation": " link T1 to T2 on T1.account_id = T2.account_id, then T2 to T3 on T2.client_id = T3.client_id, and finally T3 to T4 on T3.client_id = T4.client_id using inner joins only."
        },
        "591": {
            "condition": "When answering about male customers born between 1974 and 1976 with payments over $4000, When the question mentions \"male customers\", When the question mentions \"born between 1974 and 1976\", When the question mentions \"payment in excess of $4000\", When the question mentions \"payment on their home\", When combining tables for this query, When counting customers",
            "operation": " compute the number of rows using T1.account_id as the counting key."
        },
        "592": {
            "condition": "When answering about accounts in Beroun",
            "operation": " join table \"account\" as T1 with table \"district\" as T2 using T1.district_id = T2.district_id to get location information."
        },
        "593": {
            "condition": "When filtering for Beroun location",
            "operation": " use T2.A2 = 'Beroun' instead of city column to reference the correct district table column."
        },
        "594": {
            "condition": "When checking accounts opened after 1996",
            "operation": " extract year from T1.date using STRFTIME('%Y', T1.date) > '1996' for proper date handling instead of direct date comparison."
        },
        "595": {
            "condition": "When answering about accounts in Beroun, When filtering for Beroun location, When checking accounts opened after 1996, When counting accounts",
            "operation": " count T1.account_id instead of all rows for more precise counting of non-null values."
        },
        "596": {
            "condition": "When counting clients",
            "operation": " use COUNT(T1.client_id) instead of COUNT(*) to count specific client records."
        },
        "597": {
            "condition": "When combining client, disp, and card tables",
            "operation": " link rows where T1.client_id = T2.client_id and T2.disp_id = T3.disp_id using inner joins."
        },
        "598": {
            "condition": "When filtering for female clients",
            "operation": " use T1.gender = 'F' instead of gender = 'male'."
        },
        "599": {
            "condition": "When counting clients, When combining client, disp, and card tables, When filtering for female clients, When filtering for junior credit cards",
            "operation": " use T3.type = 'junior' instead of credit_card_type = 'junior' to check from the correct table."
        },
        "600": {
            "condition": "When answering about proportion of customers at Prague branch who are female",
            "operation": " join district as T1 and client as T2 on T1.district_id = T2.district_id using inner match."
        },
        "601": {
            "condition": "When filtering for Prague branch",
            "operation": " use T1.A3 = 'Prague' instead of branch = 'Prague'."
        },
        "602": {
            "condition": "When calculating female proportion",
            "operation": " use SUM(T2.gender = 'F') with explicit CAST to REAL instead of COUNT(*) with subquery."
        },
        "603": {
            "condition": "When computing percentage",
            "operation": " multiply the proportion by 100 to get percentage instead of simple proportion."
        },
        "604": {
            "condition": "When answering about proportion of customers at Prague branch who are female, When filtering for Prague branch, When calculating female proportion, When computing percentage, When handling gender values",
            "operation": " use exact literal 'F' for female instead of 'Female'."
        },
        "605": {
            "condition": "When calculating percentages for male clients",
            "operation": " use CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) instead of COUNT(*) operations for precise calculation with explicit casting."
        },
        "606": {
            "condition": "When combining client and account data",
            "operation": " join multiple tables including client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id to incorporate related account and district data."
        },
        "607": {
            "condition": "When filtering for weekly statements",
            "operation": " use T2.frequency = 'POPLATEK TYDNE' instead of statement_frequency = 'Weekly' to use the correct column name and value from the joined account table."
        },
        "608": {
            "condition": "When calculating percentages for male clients, When combining client and account data, When filtering for weekly statements, When counting clients",
            "operation": " reference specific columns like T1.client_id and T1.gender instead of using COUNT(*) for more precise counting."
        },
        "609": {
            "condition": "When counting clients who choose weekly issuance",
            "operation": " use COUNT(T2.account_id) instead of COUNT(*) to count specific non-null values."
        },
        "610": {
            "condition": "When combining account and disp tables",
            "operation": " join account AS T1 and disp AS T2 with T2.account_id = T1.account_id using inner match."
        },
        "611": {
            "condition": "When filtering for weekly frequency",
            "operation": " use T1.frequency = 'POPLATEK TYDNE' instead of issuance_type = 'weekly'."
        },
        "612": {
            "condition": "When counting clients who choose weekly issuance, When combining account and disp tables, When filtering for weekly frequency, When filtering for owner type",
            "operation": " use T2.type = 'OWNER' instead of occupation = 'Owner' with exact case and value format."
        },
        "613": {
            "condition": "When answering about accounts with loan validity more than 24 months",
            "operation": " use table \"loan\" as T1 and filter with T1.duration > 24 instead of loan_validity > 24."
        },
        "614": {
            "condition": "When combining loan and account information",
            "operation": " use INNER JOIN on T1.account_id = T2.account_id to link the tables."
        },
        "615": {
            "condition": "When filtering accounts by opening date before 1997",
            "operation": " extract year from T2.date using STRFTIME('%Y', T2.date) < '1997' instead of direct date comparison."
        },
        "616": {
            "condition": "When finding the lowest approved amount",
            "operation": " order results by T1.amount ASC and use LIMIT 1 to get the single minimum record."
        },
        "617": {
            "condition": "When answering about accounts with loan validity more than 24 months, When combining loan and account information, When filtering accounts by opening date before 1997, When finding the lowest approved amount, When selecting output columns",
            "operation": " return only T1.account_id instead of all columns with *."
        },
        "618": {
            "condition": "When answering about account numbers",
            "operation": " use \"T3.account_id\" as the output column instead of \"account_number\"."
        },
        "619": {
            "condition": "When combining multiple tables",
            "operation": " link \"client AS T1\", \"district AS T2\", \"account AS T3\", and \"disp AS T4\" using inner matches where T1.district_id = T2.district_id, T2.district_id = T3.district_id, T4.account_id = T3.account_id, and T1.client_id = T4.client_id."
        },
        "620": {
            "condition": "When filtering for female clients",
            "operation": " use T1.gender = 'F' instead of 'female'."
        },
        "621": {
            "condition": "When ordering by age",
            "operation": " use T1.birth_date ASC (ascending order) instead of age DESC."
        },
        "622": {
            "condition": "When ordering by salary",
            "operation": " use T2.A11 ASC (ascending order) instead of salary ASC."
        },
        "623": {
            "condition": "When answering about account numbers, When combining multiple tables, When filtering for female clients, When ordering by age, When ordering by salary, When selecting the oldest and lowest average salary clients",
            "operation": " use ORDER BY T1.birth_date ASC, T2.A11 ASC with LIMIT 1 to get the single matching row."
        },
        "624": {
            "condition": "When counting clients",
            "operation": " use COUNT(T1.client_id) instead of COUNT(*) to count specific non-null values."
        },
        "625": {
            "condition": "When the question mentions \"clients\"",
            "operation": " use table \"client AS T1\" and join with \"district AS T2\" using INNER JOIN district AS T2 ON T1.district_id = T2.district_id."
        },
        "626": {
            "condition": "When filtering by birth year 1920",
            "operation": " use STRFTIME('%Y', T1.birth_date) = '1920' to extract year from the date field instead of a direct year_of_birth column."
        },
        "627": {
            "condition": "When counting clients, When the question mentions \"clients\", When filtering by birth year 1920, When filtering by region \"east Bohemia\"",
            "operation": " use T2.A3 = 'east Bohemia' instead of a region column from the clients table."
        },
        "628": {
            "condition": "When counting loan accounts",
            "operation": " use COUNT(T2.account_id) instead of COUNT(*) to count specific loan account entities."
        },
        "629": {
            "condition": "When relating account and loan information",
            "operation": " join account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id to properly combine account and loan tables."
        },
        "630": {
            "condition": "When filtering by duration",
            "operation": " use T2.duration = 24 to specify the duration condition from the loan table."
        },
        "631": {
            "condition": "When filtering by statement frequency",
            "operation": " use T1.frequency = 'POPLATEK TYDNE' instead of statement_frequency = 'weekly' to use the correct frequency column and value from the account table."
        },
        "632": {
            "condition": "When counting loan accounts, When relating account and loan information, When filtering by duration, When filtering by statement frequency, When the question mentions \"pre-payment\"",
            "operation": " do not include payment_type = 'pre-payment' condition as it is not required based on the schema relationship."
        },
        "633": {
            "condition": "When answering about average loan amount",
            "operation": " use AVG(T2.amount) with explicit table alias instead of unqualified AVG(amount)."
        },
        "634": {
            "condition": "When combining account and loan tables",
            "operation": " join account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id instead of querying only the loans table."
        },
        "635": {
            "condition": "When filtering for loans still on running contract",
            "operation": " use T2.status IN ('C', 'D') instead of status = 'running'."
        },
        "636": {
            "condition": "When answering about average loan amount, When combining account and loan tables, When filtering for loans still on running contract, When filtering for statement issuance after each transaction",
            "operation": " use T1.frequency = 'POPLATEK PO OBRATU' instead of statement_issuance = 'after_transaction'."
        },
        "637": {
            "condition": "When answering about \"clients that can only have the right to issue permanent orders or apply for loans\"",
            "operation": " use T3.\"type\" = 'OWNER' as the filter condition instead of permanent_orders = 1 OR loan_applications = 1."
        },
        "638": {
            "condition": "When selecting client ID and district information",
            "operation": " select T3.\"client_id\", T2.\"district_id\", and T2.\"A2\" instead of ID and district from the clients table."
        },
        "639": {
            "condition": "When combining account and district tables",
            "operation": " link rows where T1.\"district_id\" = T2.\"district_id\" and keep only matching pairs (inner match)."
        },
        "640": {
            "condition": "When combining account and disp tables",
            "operation": " link rows where T1.\"account_id\" = T3.\"account_id\" and keep only matching pairs (inner match)."
        },
        "641": {
            "condition": "When answering about \"clients that can only have the right to issue permanent orders or apply for loans\", When selecting client ID and district information, When combining account and district tables, When combining account and disp tables, When the question mentions \"clients\"",
            "operation": " the client information is actually stored in the disp table with alias T3, not the clients table directly."
        },
        "642": {
            "condition": "When answering about client IDs and age",
            "operation": " select T1.client_id and calculate age using STRFTIME functions instead of selecting age directly."
        },
        "643": {
            "condition": "When combining tables for this question",
            "operation": " join disp AS T1, card AS T2, and client AS T3 with INNER JOIN conditions instead of querying only the clients table."
        },
        "644": {
            "condition": "When filtering for high level credit card",
            "operation": " use T2.type = 'gold' instead of credit_card_level = 'high'."
        },
        "645": {
            "condition": "When answering about client IDs and age, When combining tables for this question, When filtering for high level credit card, When filtering for loan eligibility",
            "operation": " use T1.type = 'OWNER' instead of loan_eligibility = 'yes'."
        },
        "646": {
            "condition": "When calculating age from birth_date",
            "operation": " use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T3.birth_date) without day-of-year adjustment logic."
        },
        "647": {
            "condition": "When joining card and disp tables",
            "operation": " use T2.disp_id = T1.disp_id as the join condition with this exact table reference order."
        },
        "648": {
            "condition": "When the question asks for client age",
            "operation": " do not include an explicit AS age alias in the output."
        },
        "649": {
            "condition": "When calculating age from birth_date, When joining card and disp tables, When the question asks for client age, When referencing current timestamp",
            "operation": " use CURRENT_TIMESTAMP instead of 'now'."
        }
    },
    "toxicology": {
        "0": {
            "condition": "When answering about \"most common bond type\"",
            "operation": " make sure the output order: bond_type."
        },
        "1": {
            "condition": "When counting bonds",
            "operation": " compute the number of rows using the canonical key token \"bond_id\" from the bond table."
        },
        "2": {
            "condition": "When the question mentions \"most common\"",
            "operation": " rank bond types by count of bond_id in descending order and keep the first 1 row."
        },
        "3": {
            "condition": "When selecting from the bond table",
            "operation": " use the exact table name \"bond\" (not \"bonds\")."
        },
        "4": {
            "condition": "When counting bond occurrences",
            "operation": " use the exact column token \"bond_id\" (not \"*\") for counting."
        },
        "5": {
            "condition": "When answering about \"most common bond type\", When counting bonds, When the question mentions \"most common\", When selecting from the bond table, When counting bond occurrences, When ordering by frequency",
            "operation": " order by COUNT(bond_id) DESC (not ASC) to find the most common type."
        },
        "6": {
            "condition": "When counting molecules",
            "operation": " use COUNT(DISTINCT T1.molecule_id) instead of COUNT(*) to count unique molecules rather than all rows."
        },
        "7": {
            "condition": "When the question asks about molecules containing chlorine atoms",
            "operation": " join atom AS T2 on T1.molecule_id = T2.molecule_id to access atom information."
        },
        "8": {
            "condition": "When filtering for chlorine atoms",
            "operation": " use T2.element = 'cl' instead of pattern matching for exact element matching."
        },
        "9": {
            "condition": "When the question specifies non-carcinogenic molecules",
            "operation": " add T1.label = '-' condition to filter for non-carcinogenic molecules."
        },
        "10": {
            "condition": "When counting molecules, When the question asks about molecules containing chlorine atoms, When filtering for chlorine atoms, When the question specifies non-carcinogenic molecules, When the question asks about non-carcinogenic molecules",
            "operation": " remove any carcinogenic = 1 filter as it would select carcinogenic molecules instead."
        },
        "11": {
            "condition": "When the question asks for oxygen atoms",
            "operation": " filter atoms where \"element\" equals 'o' exactly."
        },
        "12": {
            "condition": "When the question mentions single-bonded molecules",
            "operation": " filter bonds where \"bond_type\" equals '-' exactly."
        },
        "13": {
            "condition": "When calculating oxygen atoms per molecule",
            "operation": " group by \"molecule_id\" to count oxygen atoms for each molecule."
        },
        "14": {
            "condition": "When combining atom and bond tables",
            "operation": " link rows where \"molecule_id\" values match exactly between both tables (inner match)."
        },
        "15": {
            "condition": "When the question asks for oxygen atoms, When the question mentions single-bonded molecules, When calculating oxygen atoms per molecule, When combining atom and bond tables, When calculating the average number of oxygen atoms",
            "operation": " compute the average of the oxygen count per molecule after proper grouping and filtering."
        },
        "16": {
            "condition": "When answering about average count of single bonds for carcinogenic molecules",
            "operation": " use AVG(single_bond_count) instead of AVG(bond_count)."
        },
        "17": {
            "condition": "When calculating single_bond_count",
            "operation": " count T1.bond_type occurrences instead of using a simple aggregate."
        },
        "18": {
            "condition": "When combining data from multiple tables",
            "operation": " join bond AS T1, atom AS T2, and molecule AS T3 with INNER JOIN conditions instead of querying only the molecules table."
        },
        "19": {
            "condition": "When filtering for single bonds",
            "operation": " use T1.bond_type = '-' instead of bond_type = 'single'."
        },
        "20": {
            "condition": "When filtering for carcinogenic molecules",
            "operation": " use T3.label = '+' instead of carcinogenic = 1."
        },
        "21": {
            "condition": "When answering about average count of single bonds for carcinogenic molecules, When calculating single_bond_count, When combining data from multiple tables, When filtering for single bonds, When filtering for carcinogenic molecules, When grouping for molecule-level calculations",
            "operation": " group by T3.molecule_id instead of omitting grouping."
        },
        "22": {
            "condition": "When joining bond and molecule tables",
            "operation": " use atom as an intermediate table by performing an INNER JOIN between bond AS T1 and atom AS T2 on T1.molecule_id = T2.molecule_id, then INNER JOIN atom AS T2 to molecule AS T3 on T3.molecule_id = T2.molecule_id instead of directly joining bond to molecule."
        },
        "23": {
            "condition": "When filtering for carcinogenic molecules",
            "operation": " use T3.label = '+' exactly as specified."
        },
        "24": {
            "condition": "When filtering for single bonds",
            "operation": " use T1.bond_type = '-' exactly as specified."
        },
        "25": {
            "condition": "When counting single bonds per molecule",
            "operation": " group by T3.molecule_id and count T1.bond_type."
        },
        "26": {
            "condition": "When joining bond and molecule tables, When filtering for carcinogenic molecules, When filtering for single bonds, When counting single bonds per molecule, When computing the average",
            "operation": " calculate the average of the single_bond_count values across all carcinogenic molecules with single bonds."
        },
        "27": {
            "condition": "When counting molecules containing sodium atoms",
            "operation": " count distinct T2.molecule_id instead of counting all rows."
        },
        "28": {
            "condition": "When combining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id using an inner join."
        },
        "29": {
            "condition": "When filtering for sodium atoms",
            "operation": " use T1.element = 'na' instead of 'sodium' to filter by atomic symbol."
        },
        "30": {
            "condition": "When counting molecules containing sodium atoms, When combining atom and molecule tables, When filtering for sodium atoms, When filtering for non-carcinogenic molecules",
            "operation": " use T2.label = '-' instead of carcinogenic = 'yes' to filter by molecule label."
        },
        "31": {
            "condition": "When answering about \"triple-bonded molecules which are carcinogenic\"",
            "operation": " make sure the output order: T2.molecule_id."
        },
        "32": {
            "condition": "When the question mentions \"triple-bonded\"",
            "operation": " \"triple-bonded\" actually means \"T1.bond_type = '#'\" in schema."
        },
        "33": {
            "condition": "When the question mentions \"carcinogenic\"",
            "operation": " \"carcinogenic\" actually means \"T2.label = '+'\" in schema."
        },
        "34": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)."
        },
        "35": {
            "condition": "When answering about \"triple-bonded molecules which are carcinogenic\", When the question mentions \"triple-bonded\", When the question mentions \"carcinogenic\", When combining T1 and T2 for shared entities, When selecting results",
            "operation": " return only distinct T2.molecule_id values instead of all columns."
        },
        "36": {
            "condition": "When calculating percentage of carbon atoms in molecules",
            "operation": " use CAST(COUNT(DISTINCT CASE WHEN T1.element = 'c' THEN T1.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T1.atom_id) instead of simple division to properly handle distinct atom counting."
        },
        "37": {
            "condition": "When accessing both atom and bond data",
            "operation": " join atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id to combine information from both tables using molecule_id as the linking key."
        },
        "38": {
            "condition": "When filtering for double bonds",
            "operation": " use T2.bond_type = '=' instead of 'double' to match the exact bond type syntax in the database."
        },
        "39": {
            "condition": "When calculating percentage of carbon atoms in molecules, When accessing both atom and bond data, When filtering for double bonds, When the calculation becomes complex",
            "operation": " remove the AS carbon_percentage alias to avoid oversimplifying the output column name."
        },
        "40": {
            "condition": "When counting bonds",
            "operation": " use COUNT(T.bond_id) to count specific non-null bond_id values rather than all rows."
        },
        "41": {
            "condition": "When referencing the bond table",
            "operation": " use alias T instead of the bare table name bonds."
        },
        "42": {
            "condition": "When filtering by bond type",
            "operation": " use T.bond_type = '#' instead of bond_type = 'triple' to match the correct bond type value."
        },
        "43": {
            "condition": "When counting bonds, When referencing the bond table, When filtering by bond type, When answering about triple type bonds",
            "operation": " the literal 'triple' in the question actually means '#' in the schema."
        },
        "44": {
            "condition": "When counting atoms",
            "operation": " use COUNT(DISTINCT T.atom_id) to count unique atom identifiers rather than all rows."
        },
        "45": {
            "condition": "When referencing the atom table",
            "operation": " use alias T and table name atom instead of atoms."
        },
        "46": {
            "condition": "When counting atoms, When referencing the atom table, When filtering for atoms without bromine",
            "operation": " use T.element <> 'br' to exclude bromine elements rather than including them with element = 'bromine'."
        },
        "47": {
            "condition": "When the question asks about \"first 100 molecules in number order\"",
            "operation": " filter molecules where \"molecule_id\" is between 'TR000' and 'TR099' inclusive."
        },
        "48": {
            "condition": "When the question asks about \"carcinogenic\" molecules",
            "operation": " filter for rows where \"label\" equals '+' exactly."
        },
        "49": {
            "condition": "When counting molecules",
            "operation": " count using the exact token \"T\".\"molecule_id\" as the counting key."
        },
        "50": {
            "condition": "When referring to the molecules table",
            "operation": " use the exact table name \"molecule\" with alias \"T\"."
        },
        "51": {
            "condition": "When the question asks about \"first 100 molecules in number order\", When the question asks about \"carcinogenic\" molecules, When counting molecules, When referring to the molecules table, When producing output",
            "operation": " return a single count value of the matching molecules."
        },
        "52": {
            "condition": "When answering about molecules containing carbon",
            "operation": " reference the \"atom\" table with alias \"T\" instead of the \"molecules\" table."
        },
        "53": {
            "condition": "When selecting molecule IDs",
            "operation": " use the column \"T.molecule_id\" instead of just \"molecule_id\"."
        },
        "54": {
            "condition": "When answering about molecules containing carbon, When selecting molecule IDs, When filtering for carbon element",
            "operation": " use the literal value 'c' instead of 'carbon'."
        },
        "55": {
            "condition": "When answering about elements in bond atoms",
            "operation": " make sure the output order: T1.element"
        },
        "56": {
            "condition": "When the question asks for distinct elements",
            "operation": " compute the number of unique values of the exact token T1.element"
        },
        "57": {
            "condition": "When combining T1 (atom) and T2 (connected) for shared entities",
            "operation": " link rows where T1.atom_id = T2.atom_id exactly as shown; keep only matching pairs (inner match)"
        },
        "58": {
            "condition": "When answering about elements in bond atoms, When the question asks for distinct elements, When combining T1 (atom) and T2 (connected) for shared entities, When filtering for bond_id 'TR004_8_9'",
            "operation": " apply the condition T2.bond_id = 'TR004_8_9' exactly with the literal 'TR004_8_9'"
        },
        "59": {
            "condition": "When answering about elements in double bonds",
            "operation": " make sure the output order: T1.element with DISTINCT."
        },
        "60": {
            "condition": "When the question mentions \"double type bond\"",
            "operation": " \"double\" actually means \"T2.bond_type = '='\" in schema."
        },
        "61": {
            "condition": "When combining tables atom AS T1, bond AS T2, and connected AS T3",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and T1.atom_id = T3.atom_id; keep only matching pairs (inner match)."
        },
        "62": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "63": {
            "condition": "When answering about elements in double bonds, When the question mentions \"double type bond\", When combining tables atom AS T1, bond AS T2, and connected AS T3, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for '='."
        },
        "64": {
            "condition": "When the question asks about \"atoms with hydrogen\"",
            "operation": " filter rows where T1.element equals 'h' exactly (not 'hydrogen')."
        },
        "65": {
            "condition": "When combining information about atoms and molecules",
            "operation": " join table molecule as T2 on T1.molecule_id = T2.molecule_id using inner match."
        },
        "66": {
            "condition": "When counting molecules per label",
            "operation": " count distinct T2.molecule_id values instead of counting all rows."
        },
        "67": {
            "condition": "When answering about \"most numerous label\"",
            "operation": " rank labels by molecule count in descending order and keep only the top result."
        },
        "68": {
            "condition": "When the question asks about \"atoms with hydrogen\", When combining information about atoms and molecules, When counting molecules per label, When answering about \"most numerous label\", When selecting output columns",
            "operation": " return only T2.label (not both label and count)."
        },
        "69": {
            "condition": "When the question mentions \"Chlorine\"",
            "operation": " use the exact literal 'cl' (lowercase) instead of 'Chlorine' to match the element symbol in the schema."
        },
        "70": {
            "condition": "When answering about bond types for an element",
            "operation": " join multiple tables using inner matches - connect bond table (T1) to connected table (T2) on T1.bond_id = T2.bond_id, then connect to atom table (T3) on T2.atom_id = T3.atom_id."
        },
        "71": {
            "condition": "When filtering for a specific element",
            "operation": " use T3.element = 'cl' with the correct table reference to atom table."
        },
        "72": {
            "condition": "When the question mentions \"Chlorine\", When answering about bond types for an element, When filtering for a specific element, When selecting bond types",
            "operation": " use DISTINCT T1.bond_type to return unique bond type values instead of duplicates."
        },
        "73": {
            "condition": "When answering about \"atoms connected in single type bonds\"",
            "operation": " make sure the output order: T2.atom_id, T2.atom_id2."
        },
        "74": {
            "condition": "When the question mentions \"single type bonds\"",
            "operation": " \"single\" actually means \"bond_type = '-' in schema\"."
        },
        "75": {
            "condition": "When combining bond table as T1 and connected table as T2",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly and keep only matching pairs (inner match)."
        },
        "76": {
            "condition": "When answering about \"atoms connected in single type bonds\", When the question mentions \"single type bonds\", When combining bond table as T1 and connected table as T2, When filtering for bond type",
            "operation": " use T1.bond_type = '-' exactly as specified in the schema."
        },
        "77": {
            "condition": "When answering about \"atoms connected in non-carcinogenic type molecules\"",
            "operation": " make sure the output order: atom_id"
        },
        "78": {
            "condition": "When the question mentions \"non-carcinogenic type molecules\"",
            "operation": " \"non-carcinogenic\" actually means \"T2.label = '-'\" in schema"
        },
        "79": {
            "condition": "When combining T1 (atom) and T2 (molecule) for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)"
        },
        "80": {
            "condition": "When combining T1 (atom) and T3 (connected) for shared entities",
            "operation": " link rows where T1.atom_id = T3.atom_id; keep only matching pairs (inner match)"
        },
        "81": {
            "condition": "When the question asks for \"which atoms are connected\"",
            "operation": " use DISTINCT to return unique atom_id values"
        },
        "82": {
            "condition": "When answering about \"atoms connected in non-carcinogenic type molecules\", When the question mentions \"non-carcinogenic type molecules\", When combining T1 (atom) and T2 (molecule) for shared entities, When combining T1 (atom) and T3 (connected) for shared entities, When the question asks for \"which atoms are connected\", When filtering molecules",
            "operation": " use the exact literal '-' for T2.label to identify non-carcinogenic molecules"
        },
        "83": {
            "condition": "When answering about \"least numerous element in non-carcinogenic molecules\"",
            "operation": " make sure the output order: T.element only."
        },
        "84": {
            "condition": "When combining atom as T1 and molecule as T2",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "85": {
            "condition": "When filtering for non-carcinogenic molecules",
            "operation": " use T2.label = '-' exactly as specified."
        },
        "86": {
            "condition": "When counting distinct molecules per element",
            "operation": " compute the number of unique T1.molecule_id values per T.element."
        },
        "87": {
            "condition": "When ranking for \"least numerous\"",
            "operation": " order by the count of distinct molecules in ascending order and keep only the first 1 row."
        },
        "88": {
            "condition": "When answering about \"least numerous element in non-carcinogenic molecules\", When combining atom as T1 and molecule as T2, When filtering for non-carcinogenic molecules, When counting distinct molecules per element, When ranking for \"least numerous\", When handling text literals",
            "operation": " do not change the '-' value for T2.label."
        },
        "89": {
            "condition": "When answering about bond type between specific atoms",
            "operation": " use table \"bond\" as T1 and join with table \"connected\" as T2 on T1.bond_id = T2.bond_id."
        },
        "90": {
            "condition": "When filtering for atoms TR004_8 and TR004_20",
            "operation": " use condition T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20' to handle bidirectional relationships."
        },
        "91": {
            "condition": "When selecting the bond type",
            "operation": " use qualified column T1.bond_type instead of unqualified bond_type."
        },
        "92": {
            "condition": "When answering about bond type between specific atoms, When filtering for atoms TR004_8 and TR004_20, When selecting the bond type, When combining bond and connected tables",
            "operation": " perform an inner join using exact key equality T1.bond_id = T2.bond_id and keep only matching pairs."
        },
        "93": {
            "condition": "When combining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id using an inner match that keeps only pairs with matching molecule_id values."
        },
        "94": {
            "condition": "When filtering for atoms without tin",
            "operation": " use T1.element != 'Sn' to exclude rows where the element equals exactly 'Sn' (case-sensitive)."
        },
        "95": {
            "condition": "When selecting the label information",
            "operation": " select T2.label instead of label_type from the molecule table."
        },
        "96": {
            "condition": "When ensuring unique results",
            "operation": " apply DISTINCT to the joined result set to remove duplicate label values."
        },
        "97": {
            "condition": "When combining atom and molecule tables, When filtering for atoms without tin, When selecting the label information, When ensuring unique results, When answering about label types not on molecules with tin atoms",
            "operation": " make sure the output order shows only distinct label values from molecules that have no atoms with element 'Sn'."
        },
        "98": {
            "condition": "When counting atoms with specific element types",
            "operation": " use COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) for iodine atoms and COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) for sulfur atoms instead of a single COUNT(*) with conflicting conditions."
        },
        "99": {
            "condition": "When querying about atoms in bonds",
            "operation": " join atom AS T1 with connected AS T2 on T1.atom_id = T2.atom_id and then with bond AS T3 on T2.bond_id = T3.bond_id instead of querying only the atoms table without relationships."
        },
        "100": {
            "condition": "When filtering for single bonds",
            "operation": " use T3.bond_type = '-' instead of bond_type = 'single' as the literal value."
        },
        "101": {
            "condition": "When counting atoms with specific element types, When querying about atoms in bonds, When filtering for single bonds, When handling element values",
            "operation": " use exact lowercase literals 'i' for iodine and 's' for sulfur as shown in the schema sample values, not the full element names."
        },
        "102": {
            "condition": "When answering about \"connected atoms with a triple bond\"",
            "operation": " make sure the output order: T2.atom_id, T2.atom_id2."
        },
        "103": {
            "condition": "When the question mentions \"triple bond\"",
            "operation": " \"triple bond\" actually means \"T1.bond_type = '#'\" in schema."
        },
        "104": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "105": {
            "condition": "When answering about \"connected atoms with a triple bond\", When the question mentions \"triple bond\", When combining T1 and T2 for shared entities, When selecting columns",
            "operation": " do not use * but instead select specific columns T2.atom_id and T2.atom_id2."
        },
        "106": {
            "condition": "When answering about atoms connected to TR181 molecule",
            "operation": " select specific columns \"atom_id\" and \"atom_id2\" instead of using wildcard selection."
        },
        "107": {
            "condition": "When joining tables for connected atoms",
            "operation": " use table aliases T1 and T2 consistently throughout the query."
        },
        "108": {
            "condition": "When finding connected atoms",
            "operation": " use the \"connected\" table instead of joining \"bonds\" and \"atoms\" tables separately."
        },
        "109": {
            "condition": "When linking connected atoms",
            "operation": " use a simple INNER JOIN on T2.atom_id = T1.atom_id instead of complex OR conditions with atom1_id and atom2_id."
        },
        "110": {
            "condition": "When retrieving connected atoms",
            "operation": " do not use DISTINCT modifier as it is not needed."
        },
        "111": {
            "condition": "When filtering for TR181 molecule",
            "operation": " remove the additional filter T2.molecule_id != 'TR181' as it incorrectly excludes atoms from the same molecule."
        },
        "112": {
            "condition": "When answering about atoms connected to TR181 molecule, When joining tables for connected atoms, When finding connected atoms, When linking connected atoms, When retrieving connected atoms, When filtering for TR181 molecule, When working with molecule identifiers",
            "operation": " use the exact literal 'TR181' with the correct case and no quotes around the value."
        },
        "113": {
            "condition": "When joining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "114": {
            "condition": "When filtering for labeled molecules",
            "operation": " include only rows where T2.label = '+'."
        },
        "115": {
            "condition": "When counting molecules without fluorine atoms",
            "operation": " count distinct T2.molecule_id where T1.element <> 'f'."
        },
        "116": {
            "condition": "When counting total labeled molecules",
            "operation": " count distinct T2.molecule_id."
        },
        "117": {
            "condition": "When calculating percentages",
            "operation": " convert counts to REAL using CAST to ensure proper division."
        },
        "118": {
            "condition": "When joining atom and molecule tables, When filtering for labeled molecules, When counting molecules without fluorine atoms, When counting total labeled molecules, When calculating percentages, When the question asks for percentage of carcinogenic-type molecules without fluorine",
            "operation": " compute (distinct molecules without fluorine) divided by (distinct total labeled molecules) and multiply by 100.0."
        },
        "119": {
            "condition": "When answering about percentage of carcinogenic molecules in triple type bonds",
            "operation": " make sure the output order: percentage_carcinogenic"
        },
        "120": {
            "condition": "When the question mentions \"carcinogenic molecules\"",
            "operation": " \"carcinogenic\" actually means T2.label = '+' in schema"
        },
        "121": {
            "condition": "When the question mentions \"triple type bonds\"",
            "operation": " \"triple\" actually means T3.bond_type = '#' in schema"
        },
        "122": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)"
        },
        "123": {
            "condition": "When counting carcinogenic molecules",
            "operation": " compute the number of distinct T2.molecule_id where T2.label = '+'"
        },
        "124": {
            "condition": "When calculating percentage",
            "operation": " compute (distinct carcinogenic molecules) divided by (total distinct molecules with triple bonds), guarding division by zero"
        },
        "125": {
            "condition": "When answering about percentage of carcinogenic molecules in triple type bonds, When the question mentions \"carcinogenic molecules\", When the question mentions \"triple type bonds\", When combining T1, T2, and T3 for shared entities, When counting carcinogenic molecules, When calculating percentage, When handling numeric conversion",
            "operation": " explicitly cast the result to REAL type instead of implicit conversion"
        },
        "126": {
            "condition": "When answering about \"top three elements of the toxicology of the molecule TR000 in alphabetical order\"",
            "operation": " make sure the output order: T.element in alphabetical order and limit to 3 rows."
        },
        "127": {
            "condition": "When the question mentions \"elements\"",
            "operation": " \"elements\" actually means \"T.element in schema\"."
        },
        "128": {
            "condition": "When the question asks for distinct elements",
            "operation": " compute the number of unique values of the exact token T.element."
        },
        "129": {
            "condition": "When filtering for molecule TR000",
            "operation": " use the exact literal 'TR000' with the condition T.molecule_id = 'TR000'."
        },
        "130": {
            "condition": "When answering about \"top three elements of the toxicology of the molecule TR000 in alphabetical order\", When the question mentions \"elements\", When the question asks for distinct elements, When filtering for molecule TR000, When using table atom",
            "operation": " use the alias T for the atom table as specified in the schema."
        },
        "131": {
            "condition": "When answering about atoms bonded in a molecule with a specific bond ID",
            "operation": " query from the bond table (aliased as T) instead of the atoms table."
        },
        "132": {
            "condition": "When the question mentions bond ID \"TR001_2_6\"",
            "operation": " use exact literal filter T.bond_id = 'TR001_2_6' in the WHERE clause."
        },
        "133": {
            "condition": "When the question mentions molecule \"TR001\"",
            "operation": " use exact literal filter T.molecule_id = 'TR001' in the WHERE clause."
        },
        "134": {
            "condition": "When retrieving atom information from bond data",
            "operation": " construct atom_id1 as SUBSTR(T.bond_id, 1,"
        },
        "135": {
            "condition": "and atom_id2 as T.molecule_id || SUBSTR(T.bond_id, 8,",
            "operation": "and atom_id2 as T.molecule_id || SUBSTR(T.bond_id, 8,"
        },
        "136": {
            "condition": "When answering about atoms bonded in a molecule with a specific bond ID, When the question mentions bond ID \"TR001_2_6\", When the question mentions molecule \"TR001\", When retrieving atom information from bond data, and atom_id2 as T.molecule_id || SUBSTR(T.bond_id, 8,, instead of selecting all columns.",
            "operation": "When answering about atoms bonded in a molecule with a specific bond ID, When the question mentions bond ID \"TR001_2_6\", When the question mentions molecule \"TR001\", When retrieving atom information from bond data, and atom_id2 as T.molecule_id || SUBSTR(T.bond_id, 8,, instead of selecting all columns."
        },
        "137": {
            "condition": "When answering about the difference between carcinogenic and non-carcinogenic molecules",
            "operation": " use the exact table name \"molecule\" with alias T instead of \"molecules\"."
        },
        "138": {
            "condition": "When the question mentions \"carcinogenic\" and \"not carcinogenic\"",
            "operation": " these actually mean label values '+' and '-' in the schema respectively."
        },
        "139": {
            "condition": "When computing the difference between positive and negative labels",
            "operation": " use COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) - COUNT(CASE WHEN T.label = '-' THEN T.molecule_id ELSE NULL END) in a single query."
        },
        "140": {
            "condition": "When answering about the difference between carcinogenic and non-carcinogenic molecules, When the question mentions \"carcinogenic\" and \"not carcinogenic\", When computing the difference between positive and negative labels, When producing output",
            "operation": " include an explicit alias AS diff_car_notcar for the result column."
        },
        "141": {
            "condition": "When answering about \"atom IDs of the bond TR000_2_5\"",
            "operation": " make sure the output order: T.atom_id."
        },
        "142": {
            "condition": "When the question mentions \"bond TR000_2_5\"",
            "operation": " use the exact literal 'TR000_2_5' for filtering."
        },
        "143": {
            "condition": "When querying for atom IDs related to bonds",
            "operation": " use table \"connected\" with alias T instead of table \"bonds\"."
        },
        "144": {
            "condition": "When filtering by bond_id",
            "operation": " use qualified column T.bond_id = 'TR000_2_5' with exact literal matching."
        },
        "145": {
            "condition": "When answering about \"atom IDs of the bond TR000_2_5\", When the question mentions \"bond TR000_2_5\", When querying for atom IDs related to bonds, When filtering by bond_id, When selecting atom_id",
            "operation": " use qualified column T.atom_id from the connected table."
        },
        "146": {
            "condition": "When answering about \"bond IDs that have the same atom ID 2 of TR000_2\"",
            "operation": " make sure the output order: T.bond_id."
        },
        "147": {
            "condition": "When the question mentions \"bond IDs\"",
            "operation": " \"bond IDs\" actually means \"T.bond_id in schema\"."
        },
        "148": {
            "condition": "When the question mentions \"atom ID 2 of TR000_2\"",
            "operation": " this actually means filtering where T.atom_id2 = 'TR000_2'."
        },
        "149": {
            "condition": "When selecting from the connected table",
            "operation": " always use explicit table qualification T.bond_id instead of unqualified bond_id."
        },
        "150": {
            "condition": "When answering about \"bond IDs that have the same atom ID 2 of TR000_2\", When the question mentions \"bond IDs\", When the question mentions \"atom ID 2 of TR000_2\", When selecting from the connected table, When filtering for specific atom identifier",
            "operation": " use exact literal 'TR000_2' with correct case and no spaces."
        },
        "151": {
            "condition": "When answering about molecules with double bonds",
            "operation": " use table \"bond AS T\" instead of \"molecules\""
        },
        "152": {
            "condition": "When filtering for double bonds",
            "operation": " use condition T.bond_type = '=' instead of 'double'"
        },
        "153": {
            "condition": "When selecting molecule identifiers",
            "operation": " use T.molecule_id instead of molecule_name"
        },
        "154": {
            "condition": "When ensuring unique molecules",
            "operation": " add DISTINCT to the selection"
        },
        "155": {
            "condition": "When ordering results alphabetically",
            "operation": " order by T.molecule_id in ascending order (remove DESC)"
        },
        "156": {
            "condition": "When answering about molecules with double bonds, When filtering for double bonds, When selecting molecule identifiers, When ensuring unique molecules, When ordering results alphabetically, When limiting to top five results",
            "operation": " keep LIMIT 5"
        },
        "157": {
            "condition": "When calculating percentage of double bonds",
            "operation": " use ROUND(CAST(COUNT(CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id),5) for the calculation with 5 decimal places precision."
        },
        "158": {
            "condition": "When accessing bond data",
            "operation": " query from the bond table using alias T instead of molecules table."
        },
        "159": {
            "condition": "When filtering for molecule TR008",
            "operation": " use T.molecule_id = 'TR008' instead of molecule_name = 'TR008'."
        },
        "160": {
            "condition": "When calculating percentage of double bonds, When accessing bond data, When filtering for molecule TR008, When presenting the result",
            "operation": " do not use column aliases as the output should be unnamed."
        },
        "161": {
            "condition": "When calculating percentage of molecules that are carcinogenic",
            "operation": " use T.label = '+' instead of carcinogenic = 'yes' to identify carcinogenic molecules."
        },
        "162": {
            "condition": "When computing the percentage",
            "operation": " use COUNT(T.molecule_id) as the denominator instead of a subquery with COUNT(*)."
        },
        "163": {
            "condition": "When counting carcinogenic molecules",
            "operation": " use COUNT(CASE WHEN T.label = '+' THEN T.molecule_id ELSE NULL END) instead of simple COUNT(*)."
        },
        "164": {
            "condition": "When formatting the result",
            "operation": " apply ROUND function with precision 3 to get three decimal places in the percentage."
        },
        "165": {
            "condition": "When calculating percentage of molecules that are carcinogenic, When computing the percentage, When counting carcinogenic molecules, When formatting the result, When referencing the molecules table",
            "operation": " use alias T consistently throughout the query."
        },
        "166": {
            "condition": "When counting hydrogen atoms in molecule TR206",
            "operation": " count atoms where T.element equals 'h' exactly using COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END)."
        },
        "167": {
            "condition": "When calculating total atoms for the denominator",
            "operation": " use COUNT(T.atom_id) to count all atoms regardless of element."
        },
        "168": {
            "condition": "When computing the percentage",
            "operation": " cast the hydrogen count to REAL type and multiply by 100 before division to ensure accurate decimal calculation."
        },
        "169": {
            "condition": "When querying for molecule TR206",
            "operation": " filter using T.molecule_id = 'TR206' with proper table qualification."
        },
        "170": {
            "condition": "When selecting from the atom table",
            "operation": " use the alias T for the atom table instead of hydrogen_data."
        },
        "171": {
            "condition": "When counting hydrogen atoms in molecule TR206, When calculating total atoms for the denominator, When computing the percentage, When querying for molecule TR206, When selecting from the atom table, When formatting the output",
            "operation": " do not include a column alias for the percentage result."
        },
        "172": {
            "condition": "When calculating percentages that require rounding to four decimal places",
            "operation": " use ROUND(...,4) to round the result to exactly four decimal places."
        },
        "173": {
            "condition": "When multiplying by 100 for percentage conversion",
            "operation": " use integer multiplication (*"
        },
        "174": {
            "condition": "instead of decimal notation (* 100.0).",
            "operation": "instead of decimal notation (* 100.0)."
        },
        "175": {
            "condition": "When calculating percentages that require rounding to four decimal places, When multiplying by 100 for percentage conversion, instead of decimal notation (* 100.0)., When performing percentage calculations with division",
            "operation": " consolidate the entire calculation within a single ROUND function rather than using separate CAST operations for numerator and denominator."
        },
        "176": {
            "condition": "When the question asks for \"type of bond\" for a specific molecule",
            "operation": " use the exact table name \"bond\" with alias \"T\" instead of \"bonds\"."
        },
        "177": {
            "condition": "When filtering for molecule 'TR000'",
            "operation": " use the exact condition T.molecule_id = 'TR000' with the literal 'TR000' exactly as specified."
        },
        "178": {
            "condition": "When returning bond types",
            "operation": " use DISTINCT to ensure only unique bond_type values are returned."
        },
        "179": {
            "condition": "When the question asks for \"type of bond\" for a specific molecule, When filtering for molecule 'TR000', When returning bond types, When the question asks about \"any bonds\"",
            "operation": " do not use LIMIT 1 since DISTINCT already ensures uniqueness of results."
        },
        "180": {
            "condition": "When answering about \"elements of the toxicology and label of molecule TR060\"",
            "operation": " make sure the output order: T1.element, T2.label"
        },
        "181": {
            "condition": "When the question asks for distinct element-label pairs",
            "operation": " use DISTINCT to eliminate duplicate rows"
        },
        "182": {
            "condition": "When combining atom table T1 and molecule table T2",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)"
        },
        "183": {
            "condition": "When filtering for molecule TR060",
            "operation": " use T2.molecule_id = 'TR060' instead of molecule_name"
        },
        "184": {
            "condition": "When answering about \"elements of the toxicology and label of molecule TR060\", When the question asks for distinct element-label pairs, When combining atom table T1 and molecule table T2, When filtering for molecule TR060, When selecting columns",
            "operation": " choose specific columns T1.element and T2.label instead of all columns with *"
        },
        "185": {
            "condition": "When answering about bond types for a specific molecule",
            "operation": " use table alias T1 for the bond table and reference columns as T1.bond_type and T1.molecule_id."
        },
        "186": {
            "condition": "When counting bonds per type for molecule 'TR010'",
            "operation": " count using T1.molecule_id instead of counting all rows."
        },
        "187": {
            "condition": "When finding the bond type with the highest count",
            "operation": " order results by COUNT(T1.molecule_id) in descending order and keep only the top result."
        },
        "188": {
            "condition": "When answering about bond types for a specific molecule, When counting bonds per type for molecule 'TR010', When finding the bond type with the highest count, When selecting output for the majority bond type",
            "operation": " return only T1.bond_type from the subquery, not both the bond type and its count."
        },
        "189": {
            "condition": "When answering about molecules with specific bond types and labels",
            "operation": " combine bond table as T1 and molecule table as T2 using an inner match where T1.molecule_id equals T2.molecule_id."
        },
        "190": {
            "condition": "When the question mentions \"single bonds\"",
            "operation": " filter for T1.bond_type = '-' exactly."
        },
        "191": {
            "condition": "When the question mentions \"not carcinogenic\"",
            "operation": " filter for T2.label = '-' exactly."
        },
        "192": {
            "condition": "When listing distinct molecules",
            "operation": " select DISTINCT T2.molecule_id to ensure unique molecule identification."
        },
        "193": {
            "condition": "When the question asks for alphabetical order",
            "operation": " order results by T2.molecule_id in ascending sequence."
        },
        "194": {
            "condition": "When answering about molecules with specific bond types and labels, When the question mentions \"single bonds\", When the question mentions \"not carcinogenic\", When listing distinct molecules, When the question asks for alphabetical order, When the question asks for top three",
            "operation": " keep only the first 3 rows after ordering."
        },
        "195": {
            "condition": "When answering about \"bonds that happened with the molecule TR006\"",
            "operation": " make sure the output order: T2.bond_id in alphabetical order."
        },
        "196": {
            "condition": "When the question mentions \"bonds\"",
            "operation": " \"bonds\" actually means \"T2.bond_id in schema\" from the connected table."
        },
        "197": {
            "condition": "When the question mentions \"molecule TR006\"",
            "operation": " \"TR006\" actually means \"T1.molecule_id = 'TR006'\" in schema."
        },
        "198": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.atom_id = T2.atom_id exactly as shown; keep only matching pairs (inner match)."
        },
        "199": {
            "condition": "When the question asks for \"top two\"",
            "operation": " rank rows by T2.bond_id in alphabetical order and keep the first 2 rows."
        },
        "200": {
            "condition": "When answering about \"bonds that happened with the molecule TR006\", When the question mentions \"bonds\", When the question mentions \"molecule TR006\", When combining T1 and T2 for shared entities, When the question asks for \"top two\", When the question asks for \"distinct bonds\"",
            "operation": " compute the number of unique values of T2.bond_id."
        },
        "201": {
            "condition": "When answering about bonds involving atom 12 for molecule TR009",
            "operation": " join bond table as T1 with connected table as T2 using T1.bond_id = T2.bond_id."
        },
        "202": {
            "condition": "When filtering for molecule TR009",
            "operation": " use T1.molecule_id = 'TR009' exactly."
        },
        "203": {
            "condition": "When filtering for atom 12",
            "operation": " use T2.atom_id = T1.molecule_id || '_1' and T2.atom_id2 = T1.molecule_id || '_2' instead of hardcoded atom_id = 12."
        },
        "204": {
            "condition": "When counting bonds",
            "operation": " count T2.bond_id instead of using COUNT(*)."
        },
        "205": {
            "condition": "When answering about bonds involving atom 12 for molecule TR009, When filtering for molecule TR009, When filtering for atom 12, When counting bonds, When combining bond and connected tables",
            "operation": " perform an inner join where T1.bond_id = T2.bond_id to keep only matching pairs."
        },
        "206": {
            "condition": "When answering about \"bonds which involved atom 12\"",
            "operation": " make sure the output order: COUNT(T2.bond_id)"
        },
        "207": {
            "condition": "When the question mentions \"molecule TR009\"",
            "operation": " \"TR009\" actually means \"T1.molecule_id = 'TR009'\" in schema"
        },
        "208": {
            "condition": "When filtering for bonds involving atom 12",
            "operation": " require both T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2' conditions to be satisfied simultaneously"
        },
        "209": {
            "condition": "When combining bond and connected tables",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "210": {
            "condition": "When answering about \"bonds which involved atom 12\", When the question mentions \"molecule TR009\", When filtering for bonds involving atom 12, When combining bond and connected tables, When counting bonds",
            "operation": " compute the number of rows using the canonical key token T2.bond_id"
        },
        "211": {
            "condition": "When counting molecules",
            "operation": " use COUNT(DISTINCT T2.molecule_id) to count unique molecules rather than all rows."
        },
        "212": {
            "condition": "When combining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id using an inner join to keep only matching pairs."
        },
        "213": {
            "condition": "When filtering for carcinogenic molecules",
            "operation": " use T2.label = '+' instead of carcinogenic = 'yes'."
        },
        "214": {
            "condition": "When counting molecules, When combining atom and molecule tables, When filtering for carcinogenic molecules, When filtering for bromine element",
            "operation": " use T1.element = 'br' instead of element = 'bromine'."
        },
        "215": {
            "condition": "When answering about bond type and atoms for a specific bond ID",
            "operation": " make sure the output order: bond_type, atom_id, atom_id2."
        },
        "216": {
            "condition": "When the question mentions \"bond type\"",
            "operation": " \"bond type\" actually means \"T1.bond_type\" in schema."
        },
        "217": {
            "condition": "When the question mentions \"atoms of the bond\"",
            "operation": " \"atoms\" actually means \"T2.atom_id\" and \"T2.atom_id2\" in schema."
        },
        "218": {
            "condition": "When combining T1 (bond) and T2 (connected) for shared bond entities",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "219": {
            "condition": "When answering about bond type and atoms for a specific bond ID, When the question mentions \"bond type\", When the question mentions \"atoms of the bond\", When combining T1 (bond) and T2 (connected) for shared bond entities, When filtering for a specific bond ID like 'TR001_6_9'",
            "operation": " apply the filter to T2.bond_id = 'TR001_6_9' using the exact literal value with proper case and punctuation."
        },
        "220": {
            "condition": "When answering about which molecule an atom belongs to",
            "operation": " join atom table T1 with molecule table T2 using T1.molecule_id = T2.molecule_id to link atom to its molecule."
        },
        "221": {
            "condition": "When filtering for a specific atom_id",
            "operation": " use T1.atom_id = 'TR001_10' with exact literal value 'TR001_10'."
        },
        "222": {
            "condition": "When selecting molecule identification",
            "operation": " output T2.molecule_id instead of molecule_name."
        },
        "223": {
            "condition": "When answering about which molecule an atom belongs to, When filtering for a specific atom_id, When selecting molecule identification, When determining carcinogenic status",
            "operation": " use IIF(T2.label='+','YES','NO') AS flag_carcinogenic to convert label '+' to 'YES' and other values to 'NO' for carcinogenic flag."
        },
        "224": {
            "condition": "When counting molecules",
            "operation": " count distinct T.molecule_id instead of counting all rows to get unique molecules rather than all bonds."
        },
        "225": {
            "condition": "When accessing bond data",
            "operation": " use table bond AS T instead of molecules to get the correct bond information."
        },
        "226": {
            "condition": "When counting molecules, When accessing bond data, When filtering for triple bond type",
            "operation": " use T.bond_type = '#' instead of 'triple' to match the proper bond type identifier in the schema."
        },
        "227": {
            "condition": "When counting connections for an atom",
            "operation": " count the number of bond_id values from table \"connected\" (aliased as T) where the bond_id is not null."
        },
        "228": {
            "condition": "When matching atom identifiers by their ending digits",
            "operation": " extract the last two characters of T.atom_id using SUBSTR and compare them to the string literal '19' exactly."
        },
        "229": {
            "condition": "When referencing columns from the connected table",
            "operation": " use the alias T for explicit column references (e.g., T.atom_id, T.bond_id)."
        },
        "230": {
            "condition": "When counting connections for an atom, When matching atom identifiers by their ending digits, When referencing columns from the connected table, When the question asks about \"connections\"",
            "operation": " this refers to bonds in the \"connected\" table, not a \"connections\" table."
        },
        "231": {
            "condition": "When answering about \"elements of the toxicology of the molecule 'TR004'\"",
            "operation": " make sure the output order: T.element"
        },
        "232": {
            "condition": "When the question mentions \"elements\"",
            "operation": " \"elements\" actually means \"element in schema\""
        },
        "233": {
            "condition": "When the question mentions \"molecule 'TR004'\"",
            "operation": " \"TR004\" actually means \"molecule_id = 'TR004' in schema\""
        },
        "234": {
            "condition": "When selecting from the atom table",
            "operation": " use alias T for the atom table instead of molecules"
        },
        "235": {
            "condition": "When retrieving distinct elements",
            "operation": " compute the number of unique values of the exact token T.element"
        },
        "236": {
            "condition": "When answering about \"elements of the toxicology of the molecule 'TR004'\", When the question mentions \"elements\", When the question mentions \"molecule 'TR004'\", When selecting from the atom table, When retrieving distinct elements, When filtering for molecule TR004",
            "operation": " use the exact literal 'TR004' with correct case and spacing"
        },
        "237": {
            "condition": "When counting molecules",
            "operation": " use COUNT(T.molecule_id) instead of COUNT(*) to count specific non-null values of the canonical key."
        },
        "238": {
            "condition": "When referencing the molecule table",
            "operation": " use alias T instead of the bare table name."
        },
        "239": {
            "condition": "When filtering for non-carcinogenic molecules",
            "operation": " use T.label = '-' instead of carcinogenic = 'yes' to apply the correct condition."
        },
        "240": {
            "condition": "When counting molecules, When referencing the molecule table, When filtering for non-carcinogenic molecules, When referencing the database table",
            "operation": " use table name molecule instead of molecules to reference the correct database object."
        },
        "241": {
            "condition": "When answering about molecules containing atoms from 21 to 25",
            "operation": " make sure the output order: T2.molecule_id"
        },
        "242": {
            "condition": "When the question mentions \"atoms from 21 to 25\"",
            "operation": " extract the numeric part from T1.atom_id using SUBSTR(T1.atom_id, -2) and check if it is between '21' and '25'"
        },
        "243": {
            "condition": "When the question mentions \"carcinogenic\"",
            "operation": " use T2.label = '+' as the condition for carcinogenic molecules"
        },
        "244": {
            "condition": "When combining atom (T1) and molecule (T2) tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner join)"
        },
        "245": {
            "condition": "When selecting molecule identifiers",
            "operation": " use DISTINCT T2.molecule_id to avoid duplicate molecule entries"
        },
        "246": {
            "condition": "When answering about molecules containing atoms from 21 to 25, When the question mentions \"atoms from 21 to 25\", When the question mentions \"carcinogenic\", When combining atom (T1) and molecule (T2) tables, When selecting molecule identifiers, When handling text literals",
            "operation": " use exact string '21', '25', and '+' as shown in the amends without changing case or spacing"
        },
        "247": {
            "condition": "When answering about bonds with phosphorus and nitrogen as atom elements",
            "operation": " make sure the output order: T2.bond_id"
        },
        "248": {
            "condition": "When combining atom and connected tables",
            "operation": " link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)"
        },
        "249": {
            "condition": "When filtering for nitrogen atoms",
            "operation": " use T1.element = 'n' with exact literal 'n'"
        },
        "250": {
            "condition": "When finding bonds connected to phosphorus atoms",
            "operation": " use a subquery with connected AS T3 and atom AS T4 linked by T3.atom_id = T4.atom_id where T4.element = 'p' with exact literal 'p'"
        },
        "251": {
            "condition": "When selecting bonds",
            "operation": " use T2.bond_id IN (subquery for phosphorus bonds) instead of OR conditions"
        },
        "252": {
            "condition": "When answering about bonds with phosphorus and nitrogen as atom elements, When combining atom and connected tables, When filtering for nitrogen atoms, When finding bonds connected to phosphorus atoms, When selecting bonds, When handling element symbols",
            "operation": " use exact symbols 'p' and 'n' instead of full element names like 'phosphorus' or 'nitrogen'"
        },
        "253": {
            "condition": "When answering about \"the molecule with the most double bonds\"",
            "operation": " make sure the output order: T1.label"
        },
        "254": {
            "condition": "When the question mentions \"double bonds\"",
            "operation": " \"double bonds\" actually means \"bond_type = '=' in schema\""
        },
        "255": {
            "condition": "When the question asks for \"most double bonds\"",
            "operation": " rank rows by COUNT(T.bond_type) in descending direction and keep the first 1 row."
        },
        "256": {
            "condition": "When counting double bonds",
            "operation": " compute the number of rows using the exact condition T.bond_type = '=' grouped by T.molecule_id."
        },
        "257": {
            "condition": "When combining molecule and bond tables for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id exactly as shown; keep only matching pairs (inner match)."
        },
        "258": {
            "condition": "When answering about \"the molecule with the most double bonds\", When the question mentions \"double bonds\", When the question asks for \"most double bonds\", When counting double bonds, When combining molecule and bond tables for shared entities, When the question implies ordering ties",
            "operation": " break ties using the canonical key T.molecule_id if needed."
        },
        "259": {
            "condition": "When calculating average bonds per atom",
            "operation": " use CAST(COUNT(T2.bond_id) AS REAL) / COUNT(T1.atom_id) instead of AVG(bond_count) to properly compute the ratio."
        },
        "260": {
            "condition": "When joining atom and connected tables",
            "operation": " specify atom AS T1 INNER JOIN connected AS T2 with the join condition ON T1.atom_id = T2.atom_id to link related records."
        },
        "261": {
            "condition": "When filtering for iodine atoms",
            "operation": " use T1.element = 'i' instead of 'iodine' to match the correct element abbreviation format."
        },
        "262": {
            "condition": "When calculating average bonds per atom, When joining atom and connected tables, When filtering for iodine atoms, When counting bonds per atom",
            "operation": " use T2.bond_id for bond counting and T1.atom_id for atom counting to ensure accurate ratio calculation."
        },
        "263": {
            "condition": "When answering about \"bond type and bond ID of atom 45\"",
            "operation": " make sure the output order: T1.bond_type, T1.bond_id."
        },
        "264": {
            "condition": "When the question mentions \"atom 45\"",
            "operation": " \"atom 45\" actually means \"SUBSTR(T2.atom_id, 7,"
        },
        "265": {
            "condition": "= '45'\" in schema.",
            "operation": "= '45'\" in schema."
        },
        "266": {
            "condition": "When combining bond and connected tables for shared entities",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly as shown; keep only matching pairs (inner match)."
        },
        "267": {
            "condition": "When answering about \"bond type and bond ID of atom 45\", When the question mentions \"atom 45\", = '45'\" in schema., When combining bond and connected tables for shared entities, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exact value '45'."
        },
        "268": {
            "condition": "When selecting elements from the atom table",
            "operation": " use table alias T for the atom table instead of the unaliased atoms table."
        },
        "269": {
            "condition": "When answering about elements that cannot bond with other atoms",
            "operation": " select only T.element with DISTINCT instead of selecting all columns with *."
        },
        "270": {
            "condition": "When filtering for elements with no connections",
            "operation": " use NOT IN with a correlated subquery that joins atom and connected tables on atom_id instead of checking bond_count = 0."
        },
        "271": {
            "condition": "When handling the connected table relationship",
            "operation": " remove the incorrect bond_count column reference since it doesn't exist in the schema."
        },
        "272": {
            "condition": "When selecting elements from the atom table, When answering about elements that cannot bond with other atoms, When filtering for elements with no connections, When handling the connected table relationship, When joining atom and connected tables",
            "operation": " link rows where T.atom_id equals the connected.atom_id to identify which elements appear in connected atoms."
        },
        "273": {
            "condition": "When answering about \"atoms of the triple bond with molecule TR041\"",
            "operation": " make sure the output order: T2.atom_id, T2.atom_id2"
        },
        "274": {
            "condition": "When the question mentions \"triple bond\"",
            "operation": " \"triple bond\" actually means \"bond_type = '#' in schema\""
        },
        "275": {
            "condition": "When the question mentions \"molecule TR041\"",
            "operation": " \"TR041\" actually means \"T3.molecule_id = 'TR041' in schema\""
        },
        "276": {
            "condition": "When combining atom AS T1 and connected AS T2",
            "operation": " link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)"
        },
        "277": {
            "condition": "When combining connected AS T2 and bond AS T3",
            "operation": " link rows where T2.bond_id = T3.bond_id and keep only matching pairs (inner match)"
        },
        "278": {
            "condition": "When filtering for triple bonds",
            "operation": " use T3.bond_type = '#' with exact literal '#'"
        },
        "279": {
            "condition": "When answering about \"atoms of the triple bond with molecule TR041\", When the question mentions \"triple bond\", When the question mentions \"molecule TR041\", When combining atom AS T1 and connected AS T2, When combining connected AS T2 and bond AS T3, When filtering for triple bonds, When filtering for molecule TR041",
            "operation": " use T3.molecule_id = 'TR041' with exact literal 'TR041'"
        },
        "280": {
            "condition": "When querying about elements of atoms connected to a specific bond",
            "operation": " select only the element column from the atom table (T2.element) instead of all columns."
        },
        "281": {
            "condition": "When the question mentions \"TR144_8_19\"",
            "operation": " this refers to a bond_id value, not an element value, so filter on T1.bond_id = 'TR144_8_19'."
        },
        "282": {
            "condition": "When combining connected and atom tables",
            "operation": " link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner join)."
        },
        "283": {
            "condition": "When querying about elements of atoms connected to a specific bond, When the question mentions \"TR144_8_19\", When combining connected and atom tables, When answering about elements of atoms",
            "operation": " query from the connected table (T1) as the base table instead of directly from atoms."
        },
        "284": {
            "condition": "When the question asks about \"carcinogenic molecules\"",
            "operation": " \"carcinogenic\" actually means \"T3.label = '+'\" in the schema."
        },
        "285": {
            "condition": "When the question asks about \"double bonds\"",
            "operation": " \"double bonds\" actually means \"T1.bond_type = '='\" in the schema."
        },
        "286": {
            "condition": "When combining bond table T1 and molecule table T3",
            "operation": " link rows where T1.molecule_id = T3.molecule_id and keep only matching pairs (inner match)."
        },
        "287": {
            "condition": "When counting double bonds",
            "operation": " count T1.bond_type occurrences where T1.bond_type = '='."
        },
        "288": {
            "condition": "When grouping by molecule",
            "operation": " group by T3.molecule_id instead of name."
        },
        "289": {
            "condition": "When finding the molecule with the most double bonds",
            "operation": " rank molecules by count of T1.bond_type in descending order and keep the first 1 row."
        },
        "290": {
            "condition": "When the question asks about \"carcinogenic molecules\", When the question asks about \"double bonds\", When combining bond table T1 and molecule table T3, When counting double bonds, When grouping by molecule, When finding the molecule with the most double bonds, When selecting output",
            "operation": " include T3.molecule_id instead of name and the count value instead of bond_count alias."
        },
        "291": {
            "condition": "When answering about \"least common element of all carcinogenic molecules\"",
            "operation": " make sure the output order: T2.element"
        },
        "292": {
            "condition": "When the question mentions \"carcinogenic molecules\"",
            "operation": " \"carcinogenic\" actually means \"T1.label = '+' in schema\""
        },
        "293": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "294": {
            "condition": "When the question asks for \"least common element\"",
            "operation": " rank elements by COUNT(DISTINCT T2.molecule_id) in ascending order and keep the first 1 row."
        },
        "295": {
            "condition": "When the question says \"per element\"",
            "operation": " organize results by T2.element and compute requested aggregates per group."
        },
        "296": {
            "condition": "When answering about \"least common element of all carcinogenic molecules\", When the question mentions \"carcinogenic molecules\", When combining T1 and T2 for shared entities, When the question asks for \"least common element\", When the question says \"per element\", When counting distinct molecule occurrences",
            "operation": " compute the number of unique values of T2.molecule_id using COUNT(DISTINCT T2.molecule_id)."
        },
        "297": {
            "condition": "When the question asks for atoms that can bond with lead",
            "operation": " use element value 'pb' instead of 'lead' for filtering."
        },
        "298": {
            "condition": "When joining tables for bonding relationships",
            "operation": " use INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id to connect atoms through the connected table."
        },
        "299": {
            "condition": "When selecting output columns",
            "operation": " return T2.atom_id and T2.atom_id2 instead of DISTINCT a2.element to show the connected atom pairs."
        },
        "300": {
            "condition": "When the question asks for atoms that can bond with lead, When joining tables for bonding relationships, When selecting output columns, When referring to table aliases",
            "operation": " use atom AS T1 for the base atom table and connected AS T2 for the bonding relationships table."
        },
        "301": {
            "condition": "When answering about \"elements of triple bonds\"",
            "operation": " make sure the output order: T3.element."
        },
        "302": {
            "condition": "When the question mentions \"triple bonds\"",
            "operation": " \"triple bonds\" actually means \"bonds with bond_type = '#'\" in schema."
        },
        "303": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "304": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.atom_id = T3.atom_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "305": {
            "condition": "When the question asks for \"distinct elements\"",
            "operation": " compute the number of unique values of the exact token T3.element."
        },
        "306": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "307": {
            "condition": "When answering about \"elements of triple bonds\", When the question mentions \"triple bonds\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When the question asks for \"distinct elements\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for the literal '#'."
        },
        "308": {
            "condition": "When calculating percentages involving bond types",
            "operation": " use CAST with REAL instead of implicit decimal conversion for accurate percentage calculation."
        },
        "309": {
            "condition": "When answering about bonds and their atom elements",
            "operation": " combine data from both connected and bond tables using an inner join where T1.bond_id = T2.bond_id instead of using only one table."
        },
        "310": {
            "condition": "When grouping bond types",
            "operation": " aggregate by T2.bond_type instead of atom1_element and atom2_element."
        },
        "311": {
            "condition": "When ordering by frequency",
            "operation": " order by COUNT(T2.bond_id) descending instead of COUNT(*)."
        },
        "312": {
            "condition": "When counting bonds",
            "operation": " reference atom_id in count expressions instead of using * for accurate entity counting."
        },
        "313": {
            "condition": "When calculating percentages involving bond types, When answering about bonds and their atom elements, When grouping bond types, When ordering by frequency, When counting bonds, When calculating the percentage of the most common bond type",
            "operation": " structure the query as a complex scalar expression that computes (count of most frequent bond type) divided by (total count of bonds) multiplied by 100.0."
        },
        "314": {
            "condition": "When calculating percentage of bonds with the most common combination of atoms' elements",
            "operation": " use COUNT(T1.atom_id) from connected table instead of COUNT(*) in the numerator."
        },
        "315": {
            "condition": "When counting bonds for the most common bond type",
            "operation": " group by T2.bond_type and order by COUNT(T2.bond_id) in descending order."
        },
        "316": {
            "condition": "When computing the percentage",
            "operation": " multiply the count by 100 and then divide by the total count of atom_id from connected table."
        },
        "317": {
            "condition": "When joining connected and bond tables",
            "operation": " link rows where T1.bond_id = T2.bond_id using an inner match."
        },
        "318": {
            "condition": "When calculating percentage of bonds with the most common combination of atoms' elements, When counting bonds for the most common bond type, When computing the percentage, When joining connected and bond tables, When referencing columns",
            "operation": " use exact identifiers T1.atom_id, T2.bond_id, and T2.bond_type as shown in the schema."
        },
        "319": {
            "condition": "When answering about proportion of single bonds that are carcinogenic",
            "operation": " make sure the output order: proportion_carcinogenic as a percentage with five decimal places."
        },
        "320": {
            "condition": "When the question mentions \"single bonds\"",
            "operation": " \"single\" actually means \"bond_type = '-' in schema\"."
        },
        "321": {
            "condition": "When the question mentions \"carcinogenic\"",
            "operation": " \"carcinogenic\" actually means \"molecule label = '+' in schema\"."
        },
        "322": {
            "condition": "When combining bond table T1 and molecule table T2",
            "operation": " link rows where T1.molecule_id = T2.molecule_id exactly as shown; keep only matching pairs (inner match)."
        },
        "323": {
            "condition": "When calculating the proportion",
            "operation": " compute (COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) * 100 / COUNT(T1.bond_id)) and ROUND to 5 decimal places."
        },
        "324": {
            "condition": "When answering about proportion of single bonds that are carcinogenic, When the question mentions \"single bonds\", When the question mentions \"carcinogenic\", When combining bond table T1 and molecule table T2, When calculating the proportion, When filtering for single bonds",
            "operation": " use T1.bond_type = '-' as the exact condition."
        },
        "325": {
            "condition": "When counting records of atoms",
            "operation": " use COUNT(T.atom_id) instead of SUM(atoms) to count individual atom records rather than summing numeric values."
        },
        "326": {
            "condition": "When referencing the atom table",
            "operation": " use FROM atom AS T with alias T instead of FROM elements to access the correct table structure."
        },
        "327": {
            "condition": "When filtering for carbon and hydrogen elements",
            "operation": " use WHERE T.element = 'c' OR T.element = 'h' with exact element symbol values 'c' and 'h' instead of full element names 'carbon' and 'hydrogen'."
        },
        "328": {
            "condition": "When counting records of atoms, When referencing the atom table, When filtering for carbon and hydrogen elements, When the question asks for \"atoms consisting of the element carbon and hydrogen\"",
            "operation": " this means atoms where the element column contains either 'c' (carbon) or 'h' (hydrogen) symbols."
        },
        "329": {
            "condition": "When the question asks for \"atom id2\"",
            "operation": " use the exact column token \"T2.atom_id2\" with the T2 alias."
        },
        "330": {
            "condition": "When the question mentions \"atoms with element sulfur\"",
            "operation": " the element condition should be \"T1.element = 's'\" using the exact literal 's' instead of 'sulfur'."
        },
        "331": {
            "condition": "When combining data about atoms and their connections",
            "operation": " perform an inner join between atoms table as T1 and connected table as T2 using the exact key equality \"T1.atom_id = T2.atom_id\"."
        },
        "332": {
            "condition": "When retrieving connected atom IDs",
            "operation": " ensure the results are distinct to avoid duplicate atom_id2 values."
        },
        "333": {
            "condition": "When the question asks for \"atom id2\", When the question mentions \"atoms with element sulfur\", When combining data about atoms and their connections, When retrieving connected atom IDs, When querying for specific elements",
            "operation": " always use the correct table alias T1 for the atoms table when filtering by element."
        },
        "334": {
            "condition": "When the question asks for bond types for atoms with element Tin",
            "operation": " use the exact element symbol 'sn' instead of 'Tin' for filtering."
        },
        "335": {
            "condition": "When querying about bond types",
            "operation": " join through the connected table using T1.atom_id = T2.atom_id and then join to bond table using T3.bond_id = T2.bond_id."
        },
        "336": {
            "condition": "When retrieving bond types",
            "operation": " use DISTINCT T3.bond_type to avoid duplicate bond type values."
        },
        "337": {
            "condition": "When the question asks for bond types for atoms with element Tin, When querying about bond types, When retrieving bond types, When combining tables for this query",
            "operation": " perform inner joins between atom AS T1, connected AS T2, and bond AS T3 using the exact key relationships shown in the amends."
        },
        "338": {
            "condition": "When counting distinct elements in molecules",
            "operation": " use COUNT(DISTINCT T1.element) instead of COUNT(*) to count unique elements rather than all rows."
        },
        "339": {
            "condition": "When joining tables for molecule analysis",
            "operation": " use atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id to properly connect atom, molecule, and bond tables."
        },
        "340": {
            "condition": "When filtering for single bond molecules",
            "operation": " use T3.bond_type = '-' instead of bond_type = 'single' to match the exact representation of single bonds in the schema."
        },
        "341": {
            "condition": "When counting distinct elements in molecules, When joining tables for molecule analysis, When filtering for single bond molecules, When the question asks about \"single bond molecules\"",
            "operation": " do not include element_count > 1 condition as it is not relevant to counting distinct elements."
        },
        "342": {
            "condition": "When counting atoms",
            "operation": " count T1.atom_id instead of all rows to avoid counting NULL values."
        },
        "343": {
            "condition": "When answering about atoms with triple-bond molecules",
            "operation": " join atom AS T1 with molecule AS T2 on T1.molecule_id = T2.molecule_id to access molecule information."
        },
        "344": {
            "condition": "When accessing bond information",
            "operation": " join molecule AS T2 with bond AS T3 on T2.molecule_id = T3.molecule_id."
        },
        "345": {
            "condition": "When filtering for triple bonds",
            "operation": " use T3.bond_type = '#' instead of 'triple' using the correct bond notation."
        },
        "346": {
            "condition": "When counting atoms, When answering about atoms with triple-bond molecules, When accessing bond information, When filtering for triple bonds, When filtering for phosphorus or bromine elements",
            "operation": " use T1.element IN ('p', 'br') with element symbols instead of full names."
        },
        "347": {
            "condition": "When answering about \"bond id for molecules that are carcinogenic\"",
            "operation": " make sure the output order: T1.bond_id."
        },
        "348": {
            "condition": "When the question mentions \"molecules that are carcinogenic\"",
            "operation": " \"carcinogenic\" actually means \"T2.label = '+'\" in schema."
        },
        "349": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)."
        },
        "350": {
            "condition": "When answering about \"bond id for molecules that are carcinogenic\", When the question mentions \"molecules that are carcinogenic\", When combining T1 and T2 for shared entities, When producing output",
            "operation": " do select DISTINCT T1.bond_id instead of molecule_id without distinct."
        },
        "351": {
            "condition": "When answering about molecules with single bonds",
            "operation": " query from both bond table as T1 and molecule table as T2 with an inner match on T1.molecule_id = T2.molecule_id instead of querying only from molecules."
        },
        "352": {
            "condition": "When filtering for single bond molecules",
            "operation": " use T1.bond_type = '-' instead of bond_type = 'single'."
        },
        "353": {
            "condition": "When filtering for non-carcinogenic molecules",
            "operation": " use T2.label = '-' instead of carcinogenic = 'yes'."
        },
        "354": {
            "condition": "When selecting molecule identifiers",
            "operation": " use T1.molecule_id with table qualification instead of just molecule_id."
        },
        "355": {
            "condition": "When answering about molecules with single bonds, When filtering for single bond molecules, When filtering for non-carcinogenic molecules, When selecting molecule identifiers, When returning distinct molecule IDs",
            "operation": " add DISTINCT to ensure unique values are returned."
        },
        "356": {
            "condition": "When answering about composition of element chlorine in percentage among single bond molecules",
            "operation": " calculate percentage using (count of atoms where element = 'cl') divided by (total count of atoms) multiplied by 100.0, casting to real number."
        },
        "357": {
            "condition": "When the question mentions \"single bond molecules\"",
            "operation": " filter for bond_type = '-' instead of 'single'."
        },
        "358": {
            "condition": "When the question mentions \"element chlorine\"",
            "operation": " use element = 'cl' instead of 'chlorine'."
        },
        "359": {
            "condition": "When combining tables atom, molecule, and bond",
            "operation": " link rows using molecule_id as the join key with inner matches."
        },
        "360": {
            "condition": "When counting chlorine atoms",
            "operation": " count rows where element = 'cl' using the atom table's canonical key."
        },
        "361": {
            "condition": "When answering about composition of element chlorine in percentage among single bond molecules, When the question mentions \"single bond molecules\", When the question mentions \"element chlorine\", When combining tables atom, molecule, and bond, When counting chlorine atoms, When calculating percentages",
            "operation": " use a subquery structure to compute the ratio and multiply by 100.0 to get percentage value."
        },
        "362": {
            "condition": "When the question asks for labels of specific molecule IDs",
            "operation": " select the exact columns \"molecule_id\" and \"label\" from table \"molecule\" with alias \"T\"."
        },
        "363": {
            "condition": "When filtering for specific molecule IDs like 'TR000', 'TR001', and 'TR002'",
            "operation": " use the exact column \"T.molecule_id\" with the exact string literals 'TR000', 'TR001', and 'TR002'."
        },
        "364": {
            "condition": "When the question asks for labels of specific molecule IDs, When filtering for specific molecule IDs like 'TR000', 'TR001', and 'TR002', When the question mentions \"labels\"",
            "operation": " this refers to the \"label\" column in the \"molecule\" table, not a table called \"labels\"."
        },
        "365": {
            "condition": "When answering about \"non carcinogenic molecules\"",
            "operation": " filter rows where T.label equals exactly '-'"
        },
        "366": {
            "condition": "When selecting from the molecule table",
            "operation": " use alias T for the molecule table"
        },
        "367": {
            "condition": "When answering about \"non carcinogenic molecules\", When selecting from the molecule table, When outputting molecule identifiers",
            "operation": " select the molecule_id column from table T"
        },
        "368": {
            "condition": "When counting molecules with carcinogenic labels",
            "operation": " use COUNT(T.molecule_id) instead of SUM(carcinogenic) to count the number of molecules rather than summing values."
        },
        "369": {
            "condition": "When filtering for carcinogenic molecules",
            "operation": " include the condition T.label = '+' to only count molecules with positive carcinogenic labels."
        },
        "370": {
            "condition": "When referring to the molecules table",
            "operation": " use the alias T for the molecule table as specified in the schema."
        },
        "371": {
            "condition": "When counting molecules with carcinogenic labels, When filtering for carcinogenic molecules, When referring to the molecules table, When querying molecule IDs in a range",
            "operation": " use BETWEEN 'TR000' AND 'TR030' to include all molecule IDs from TR000 through TR030 inclusive."
        },
        "372": {
            "condition": "When answering about \"bond type for molecules from molecule id TR000 to TR050\"",
            "operation": " make sure the output order: T2.molecule_id, T2.bond_type."
        },
        "373": {
            "condition": "When the question mentions \"molecules\"",
            "operation": " \"molecules\" actually means \"molecule AS T1\" and \"bond AS T2\" in schema."
        },
        "374": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)."
        },
        "375": {
            "condition": "When answering about \"bond type for molecules from molecule id TR000 to TR050\", When the question mentions \"molecules\", When combining T1 and T2 for shared entities, When filtering by molecule_id range",
            "operation": " apply the condition T1.molecule_id BETWEEN 'TR000' AND 'TR050' using the exact literals 'TR000' and 'TR050'."
        },
        "376": {
            "condition": "When answering about elements for a specific bond id",
            "operation": " make sure the output order: T2.element"
        },
        "377": {
            "condition": "When the question mentions \"bond id TR001_10_11\"",
            "operation": " filter rows where T1.bond_id equals exactly 'TR001_10_11'"
        },
        "378": {
            "condition": "When combining connected as T1 and atom as T2",
            "operation": " link rows where T1.atom_id equals T2.atom_id and keep only matching pairs (inner match)"
        },
        "379": {
            "condition": "When answering about elements for a specific bond id, When the question mentions \"bond id TR001_10_11\", When combining connected as T1 and atom as T2, When selecting output columns",
            "operation": " choose only T2.element instead of all columns"
        },
        "380": {
            "condition": "When answering about \"bond id have element iodine\"",
            "operation": " make sure the output order: count of bond_id."
        },
        "381": {
            "condition": "When the question mentions \"element iodine\"",
            "operation": " \"iodine\" actually means \"i\" in schema."
        },
        "382": {
            "condition": "When combining tables atom AS T1, molecule AS T2, and bond AS T3",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)."
        },
        "383": {
            "condition": "When counting bonds",
            "operation": " compute the number of rows using the canonical key token T3.bond_id."
        },
        "384": {
            "condition": "When answering about \"bond id have element iodine\", When the question mentions \"element iodine\", When combining tables atom AS T1, molecule AS T2, and bond AS T3, When counting bonds, When filtering for element",
            "operation": " use T1.element = 'i' exactly as specified in the schema."
        },
        "385": {
            "condition": "When answering about molecules with element Calcium",
            "operation": " combine tables atom AS T1 and molecule AS T2 using inner join where T1.molecule_id = T2.molecule_id."
        },
        "386": {
            "condition": "When filtering for element Calcium",
            "operation": " use T1.element = 'ca' exactly (not 'Calcium')."
        },
        "387": {
            "condition": "When grouping results",
            "operation": " group by T2.label instead of analyzing carcinogenic properties."
        },
        "388": {
            "condition": "When determining the most common category",
            "operation": " count occurrences of T2.label per group."
        },
        "389": {
            "condition": "When finding the majority category",
            "operation": " order results by COUNT(T2.label) in descending order and take only the top result with LIMIT 1."
        },
        "390": {
            "condition": "When answering about molecules with element Calcium, When filtering for element Calcium, When grouping results, When determining the most common category, When finding the majority category, When selecting output",
            "operation": " return T2.label instead of a CASE expression about carcinogenic properties."
        },
        "391": {
            "condition": "When answering about whether bond id TR001_1_8 has both chlorine and carbon elements",
            "operation": " make sure the output order includes bond_id, atom_id2, and flag_have_CaCl."
        },
        "392": {
            "condition": "When combining tables atom as T1 and connected as T2",
            "operation": " link rows where T2.atom_id = T1.atom_id and keep only matching pairs (inner match)."
        },
        "393": {
            "condition": "When filtering for bond id TR001_1_8",
            "operation": " use T2.bond_id = 'TR001_1_8' exactly as specified."
        },
        "394": {
            "condition": "When checking for chlorine and carbon elements",
            "operation": " use T1.element = 'c1' OR T1.element = 'c' instead of 'chlorine' and 'carbon' literals."
        },
        "395": {
            "condition": "When answering about whether bond id TR001_1_8 has both chlorine and carbon elements, When combining tables atom as T1 and connected as T2, When filtering for bond id TR001_1_8, When checking for chlorine and carbon elements, When handling element identifiers",
            "operation": " do not use 'chlorine' and 'carbon' literals, use 'c1' and 'c' as shown in the schema mapping."
        },
        "396": {
            "condition": "When answering about bond id TR001_1_8 having both chlorine and carbon elements",
            "operation": " select T2.bond_id, T2.atom_id2, and T1.element AS flag_have_CaCl instead of using aggregation with CASE and COUNT."
        },
        "397": {
            "condition": "When the question asks about specific bond id TR001_1_8",
            "operation": " filter using T2.bond_id = 'TR001_1_8' exactly as specified."
        },
        "398": {
            "condition": "When checking for chlorine and carbon elements",
            "operation": " use the exact element values from the schema without aggregation, returning individual rows with element values."
        },
        "399": {
            "condition": "When combining tables atom and connected",
            "operation": " link rows where T2.atom_id = T1.atom_id as shown in the schema foreign key relationship."
        },
        "400": {
            "condition": "When answering about bond id TR001_1_8 having both chlorine and carbon elements, When the question asks about specific bond id TR001_1_8, When checking for chlorine and carbon elements, When combining tables atom and connected, When the question mentions \"element of chlorine and carbon\"",
            "operation": " do not use GROUP BY clause as aggregation is not needed for this type of element existence check."
        },
        "401": {
            "condition": "When answering about \"molecule id of triple bond non carcinogenic molecules with element carbon\"",
            "operation": " make sure the output order: T2.molecule_id"
        },
        "402": {
            "condition": "When the question mentions \"triple bond\"",
            "operation": " \"triple bond\" actually means \"T3.bond_type = '#'\" in schema"
        },
        "403": {
            "condition": "When the question mentions \"element carbon\"",
            "operation": " \"element carbon\" actually means \"T1.element = 'c'\" in schema"
        },
        "404": {
            "condition": "When the question mentions \"non carcinogenic\"",
            "operation": " \"non carcinogenic\" actually means \"T2.label = '-'\" in schema"
        },
        "405": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)"
        },
        "406": {
            "condition": "When the question asks for \"molecule id\"",
            "operation": " compute the distinct values of T2.molecule_id instead of all values"
        },
        "407": {
            "condition": "When answering about \"molecule id of triple bond non carcinogenic molecules with element carbon\", When the question mentions \"triple bond\", When the question mentions \"element carbon\", When the question mentions \"non carcinogenic\", When combining T1, T2, and T3 for shared entities, When the question asks for \"molecule id\", When the question asks for \"two molecule id\"",
            "operation": " remove any limit clause instead of keeping it"
        },
        "408": {
            "condition": "When calculating percentage of chlorine atoms in carcinogenic molecules",
            "operation": " use CAST(COUNT(CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) instead of a subquery approach."
        },
        "409": {
            "condition": "When referencing tables",
            "operation": " use atom AS T1 and molecule AS T2 instead of molecules and elements."
        },
        "410": {
            "condition": "When joining tables",
            "operation": " use INNER JOIN with T1.molecule_id = T2.molecule_id to link atoms to molecules."
        },
        "411": {
            "condition": "When filtering for carcinogenic molecules",
            "operation": " use WHERE T2.label = '+' instead of checking carcinogenic = 1."
        },
        "412": {
            "condition": "When calculating percentage of chlorine atoms in carcinogenic molecules, When referencing tables, When joining tables, When filtering for carcinogenic molecules, When identifying chlorine atoms",
            "operation": " check for T1.element = 'cl' (lowercase) instead of 'chlorine'."
        },
        "413": {
            "condition": "When answering about \"toxicology elements associated with molecule TR001\"",
            "operation": " make sure the output order: T.element"
        },
        "414": {
            "condition": "When the question mentions \"toxicology elements\"",
            "operation": " \"toxicology elements\" actually means \"element in schema\" from table atom AS T"
        },
        "415": {
            "condition": "When the question asks for \"distinct toxicology elements\"",
            "operation": " compute the number of unique values of the exact token for T.element"
        },
        "416": {
            "condition": "When answering about \"toxicology elements associated with molecule TR001\", When the question mentions \"toxicology elements\", When the question asks for \"distinct toxicology elements\", When filtering for molecule TR001",
            "operation": " use the exact literal 'TR001' with the condition T.molecule_id = 'TR001'"
        },
        "417": {
            "condition": "When answering about \"molecule ID of the double bond type\"",
            "operation": " make sure the output order: molecule_id."
        },
        "418": {
            "condition": "When the question mentions \"double bond type\"",
            "operation": " \"double bond type\" actually means bond_type = '=' in schema."
        },
        "419": {
            "condition": "When selecting molecule identifiers",
            "operation": " use DISTINCT to eliminate duplicate molecule_id values."
        },
        "420": {
            "condition": "When querying from the bond table",
            "operation": " use alias T instead of no alias."
        },
        "421": {
            "condition": "When answering about \"molecule ID of the double bond type\", When the question mentions \"double bond type\", When selecting molecule identifiers, When querying from the bond table, When filtering for bond type",
            "operation": " use exact literal '=' instead of 'double' to match the correct bond type representation."
        },
        "422": {
            "condition": "When answering about \"atom IDs of the first and second atoms of triple bond type molecules\"",
            "operation": " make sure the output order: T2.atom_id, T2.atom_id2"
        },
        "423": {
            "condition": "When the question mentions \"triple bond type\"",
            "operation": " \"triple\" actually means \"# in schema\" for T1.bond_type"
        },
        "424": {
            "condition": "When combining bond table as T1 and connected table as T2 for shared bond entities",
            "operation": " link rows where T1.bond_id = T2.bond_id exactly; keep only matching pairs (inner match)"
        },
        "425": {
            "condition": "When filtering for bond type",
            "operation": " use T1.bond_type = '#' instead of any other representation of triple bonds"
        },
        "426": {
            "condition": "When retrieving atom pairs from connected bonds",
            "operation": " select both T2.atom_id and T2.atom_id2 instead of just one atom_id"
        },
        "427": {
            "condition": "When answering about \"atom IDs of the first and second atoms of triple bond type molecules\", When the question mentions \"triple bond type\", When combining bond table as T1 and connected table as T2 for shared bond entities, When filtering for bond type, When retrieving atom pairs from connected bonds, When the question asks for \"first and second atoms\"",
            "operation": " do not apply ordering or limit clauses as the natural pairing in connected table already provides the atom pairs"
        },
        "428": {
            "condition": "When answering about \"toxicology elements associated with bond ID\"",
            "operation": " make sure the output order: T1.element"
        },
        "429": {
            "condition": "When the question mentions \"bond ID TR000_1_2\"",
            "operation": " use the exact literal 'TR000_1_2' with the correct case and underscores"
        },
        "430": {
            "condition": "When combining atom table as T1 and connected table as T2",
            "operation": " link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)"
        },
        "431": {
            "condition": "When answering about \"toxicology elements associated with bond ID\", When the question mentions \"bond ID TR000_1_2\", When combining atom table as T1 and connected table as T2, When filtering for a specific bond ID",
            "operation": " apply the condition T2.bond_id = 'TR000_1_2' to reference the bond ID column from the connected table"
        },
        "432": {
            "condition": "When counting molecules",
            "operation": " use COUNT(DISTINCT T2.molecule_id) instead of COUNT(*) to count unique molecules rather than all bonds."
        },
        "433": {
            "condition": "When combining bond and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id using an inner join to properly relate bonds to their parent molecules."
        },
        "434": {
            "condition": "When filtering for single bond type molecules",
            "operation": " use T1.bond_type = '-' instead of bond_type = 'single' to match the exact column name and value format."
        },
        "435": {
            "condition": "When counting molecules, When combining bond and molecule tables, When filtering for single bond type molecules, When filtering for non-carcinogenic molecules",
            "operation": " use T2.label = '-' instead of carcinogenic = 'yes' to use the correct column name and value for the intended chemical property."
        },
        "436": {
            "condition": "When answering about \"label for bond ID\"",
            "operation": " make sure the output order: T2.label"
        },
        "437": {
            "condition": "When the question mentions \"bond ID\"",
            "operation": " \"bond ID\" actually means \"T1.bond_id in schema\""
        },
        "438": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)."
        },
        "439": {
            "condition": "When answering about \"label for bond ID\", When the question mentions \"bond ID\", When combining T1 and T2 for shared entities, When filtering for a specific bond ID",
            "operation": " use exact literal 'TR001_10_11' with T1.bond_id."
        },
        "440": {
            "condition": "When the question asks about \"bond ID of triple bond type molecules\"",
            "operation": " select distinct T1.bond_id from the bond table (aliased as T1) instead of from a molecules table."
        },
        "441": {
            "condition": "When the question asks about \"carcinogenic or not\"",
            "operation": " select T2.label instead of a carcinogenic column, as the carcinogenic information is stored in the label column of the molecule table."
        },
        "442": {
            "condition": "When combining bond and molecule information",
            "operation": " join bond AS T1 with molecule AS T2 on T1.molecule_id = T2.molecule_id using an inner join to ensure only matching pairs are included."
        },
        "443": {
            "condition": "When filtering for triple bond type",
            "operation": " use T1.bond_type = '#' instead of 'triple' as the exact literal value in the schema."
        },
        "444": {
            "condition": "When the question asks about \"bond ID of triple bond type molecules\", When the question asks about \"carcinogenic or not\", When combining bond and molecule information, When filtering for triple bond type, When referencing tables",
            "operation": " always use the aliases T1 for bond table and T2 for molecule table as established in the join."
        },
        "445": {
            "condition": "When answering about toxicology elements of the 4th atom",
            "operation": " use DISTINCT T1.element in the output instead of molecule_id and element without distinct."
        },
        "446": {
            "condition": "When combining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id using an inner match."
        },
        "447": {
            "condition": "When filtering for carcinogenic molecules",
            "operation": " use T2.label = '+' instead of carcinogenic = 'yes'."
        },
        "448": {
            "condition": "When identifying the 4th atom position",
            "operation": " use SUBSTR(T1.atom_id, -1) = '4' instead of atom_position = 4."
        },
        "449": {
            "condition": "When validating atom_id format",
            "operation": " add constraint LENGTH(T1.atom_id) = 7."
        },
        "450": {
            "condition": "When answering about toxicology elements of the 4th atom, When combining atom and molecule tables, When filtering for carcinogenic molecules, When identifying the 4th atom position, When validating atom_id format, When the question asks for distinct elements",
            "operation": " compute unique values of T1.element."
        },
        "451": {
            "condition": "When answering about the ratio of Hydrogen elements in a specific molecule",
            "operation": " use a CTE with SubQuery instead of querying molecule_elements directly."
        },
        "452": {
            "condition": "When selecting from atom and molecule tables",
            "operation": " join atom AS T1 with molecule AS T2 on T1.molecule_id = T2.molecule_id using inner match."
        },
        "453": {
            "condition": "When filtering for molecule ID TR006",
            "operation": " use T2.molecule_id = 'TR006' exactly as specified."
        },
        "454": {
            "condition": "When calculating hydrogen ratio",
            "operation": " compute CAST(COUNT(CASE WHEN element = 'h' THEN atom_id ELSE NULL END) AS REAL) / COUNT(atom_id) instead of selecting a precomputed ratio."
        },
        "455": {
            "condition": "When grouping results",
            "operation": " use GROUP BY label to organize by molecule label."
        },
        "456": {
            "condition": "When selecting output columns",
            "operation": " include label in the SELECT list along with the calculated ratio."
        },
        "457": {
            "condition": "When counting atoms",
            "operation": " use atom_id as the counting key for both total atoms and hydrogen atoms."
        },
        "458": {
            "condition": "When answering about the ratio of Hydrogen elements in a specific molecule, When selecting from atom and molecule tables, When filtering for molecule ID TR006, When calculating hydrogen ratio, When grouping results, When selecting output columns, When counting atoms, When handling hydrogen identification",
            "operation": " use element = 'h' (lowercase) to identify hydrogen atoms."
        },
        "459": {
            "condition": "When answering about \"ratio of Hydrogen elements in molecule ID TR006\"",
            "operation": " make sure the output order: ratio, label"
        },
        "460": {
            "condition": "When the question mentions \"Hydrogen elements\"",
            "operation": " \"Hydrogen\" actually means \"element = 'h'\" in schema"
        },
        "461": {
            "condition": "When the question asks for a ratio \"Hydrogen elements to all elements\"",
            "operation": " compute (rows satisfying element = 'h') divided by (rows satisfying all elements), guarding division by zero by checking if denominator is zero before division"
        },
        "462": {
            "condition": "When combining T1 (atom) and T2 (molecule) for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)"
        },
        "463": {
            "condition": "When filtering for molecule ID TR006",
            "operation": " use T2.molecule_id = 'TR006' with exact literal value"
        },
        "464": {
            "condition": "When counting atoms",
            "operation": " use T1.atom_id as the counting key for both numerator and denominator"
        },
        "465": {
            "condition": "When answering about \"ratio of Hydrogen elements in molecule ID TR006\", When the question mentions \"Hydrogen elements\", When the question asks for a ratio \"Hydrogen elements to all elements\", When combining T1 (atom) and T2 (molecule) for shared entities, When filtering for molecule ID TR006, When counting atoms, When handling text literals",
            "operation": " preserve exact case and value 'h' for Hydrogen element identification"
        },
        "466": {
            "condition": "When answering about whether a chemical compound containing Calcium is carcinogenic",
            "operation": " use table atom as T1 INNER JOIN table molecule as T2 instead of compounds table alone."
        },
        "467": {
            "condition": "When joining T1 and T2",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "468": {
            "condition": "When filtering for Calcium element",
            "operation": " use T1.element = 'ca' with exact lowercase 'ca' instead of 'Calcium'."
        },
        "469": {
            "condition": "When answering about whether a chemical compound containing Calcium is carcinogenic, When joining T1 and T2, When filtering for Calcium element, When selecting carcinogenic information",
            "operation": " use T2.label AS flag_carcinogenic instead of carcinogenic column."
        },
        "470": {
            "condition": "When answering about bond types in chemical compounds containing Carbon",
            "operation": " join table atom as T1 with table bond as T2 using inner match where T1.molecule_id = T2.molecule_id."
        },
        "471": {
            "condition": "When filtering for element Carbon",
            "operation": " use exact literal 'c' (lowercase) in condition T1.element = 'c' instead of 'Carbon'."
        },
        "472": {
            "condition": "When selecting bond types",
            "operation": " use DISTINCT T2.bond_type to get unique bond types from the bond table."
        },
        "473": {
            "condition": "When answering about bond types in chemical compounds containing Carbon, When filtering for element Carbon, When selecting bond types, When referencing columns from joined tables",
            "operation": " specify the exact table alias (T2.bond_type) rather than unspecified source."
        },
        "474": {
            "condition": "When answering about \"chemical elements that form a bond TR001_10_11\"",
            "operation": " select \"element\" from table \"atom\" (T1) instead of \"element_name\" from \"chemical_elements\"."
        },
        "475": {
            "condition": "When combining tables for this relationship",
            "operation": " add an INNER JOIN on \"connected\" (T2) with predicate T1.atom_id = T2.atom_id."
        },
        "476": {
            "condition": "When combining tables for this relationship",
            "operation": " add an INNER JOIN on \"bond\" (T3) with predicate T2.bond_id = T3.bond_id."
        },
        "477": {
            "condition": "When answering about \"chemical elements that form a bond TR001_10_11\", When combining tables for this relationship, When combining tables for this relationship, When filtering for bond TR001_10_11",
            "operation": " filter on T3.bond_id = 'TR001_10_11' instead of bond_id from the original single table."
        },
        "478": {
            "condition": "When answering about percentage of compounds with triple bonds",
            "operation": " use table \"bond\" with alias T as the data source instead of \"compounds\"."
        },
        "479": {
            "condition": "When counting specific bond types",
            "operation": " use COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) to properly count triple bonds instead of filtering with WHERE clause."
        },
        "480": {
            "condition": "When calculating percentage",
            "operation": " compute as (count of triple bonds) divided by (total count of T.bond_id) multiplied by 100, using CAST for real number division."
        },
        "481": {
            "condition": "When handling bond type identification",
            "operation": " the exact literal for triple bonds is '#' (not 'triple' or variations)."
        },
        "482": {
            "condition": "When answering about percentage of compounds with triple bonds, When counting specific bond types, When calculating percentage, When handling bond type identification, When counting entities",
            "operation": " use T.bond_id as the canonical counting key for bonds."
        },
        "483": {
            "condition": "When the question asks about chemical compounds containing molecule TR047",
            "operation": " use table \"bond\" with alias T instead of \"compounds\"."
        },
        "484": {
            "condition": "When counting double bonds",
            "operation": " use comparison T.bond_type = '=' instead of bond_type = 'double'."
        },
        "485": {
            "condition": "When calculating percentage",
            "operation": " use CAST with REAL type instead of implicit casting with * 100.0."
        },
        "486": {
            "condition": "When counting specific bonds",
            "operation": " use CASE WHEN T.bond_type = '=' THEN T.bond_id ELSE NULL END instead of simple COUNT(*) with filter."
        },
        "487": {
            "condition": "When counting entities",
            "operation": " use column bond_id for counting instead of *."
        },
        "488": {
            "condition": "When the question asks about chemical compounds containing molecule TR047, When counting double bonds, When calculating percentage, When counting specific bonds, When counting entities, When calculating ratios",
            "operation": " remove subqueries for total count and calculate percentage directly using COUNT(T.bond_id) as denominator."
        },
        "489": {
            "condition": "When answering about whether a molecule containing a specific atom is carcinogenic",
            "operation": " make sure the output order: flag_carcinogenic."
        },
        "490": {
            "condition": "When the question mentions \"molecule that contains atom TR001_1\"",
            "operation": " join atom table as T1 and molecule table as T2 where T1.molecule_id = T2.molecule_id to find the molecule containing the specified atom."
        },
        "491": {
            "condition": "When the question asks for carcinogenic status",
            "operation": " use T2.label AS flag_carcinogenic instead of carcinogenic to get the proper column with explicit alias."
        },
        "492": {
            "condition": "When answering about whether a molecule containing a specific atom is carcinogenic, When the question mentions \"molecule that contains atom TR001_1\", When the question asks for carcinogenic status, When filtering for atom TR001_1",
            "operation": " use WHERE T1.atom_id = 'TR001_1' with exact literal value 'TR001_1' and correct table alias T1."
        },
        "493": {
            "condition": "When answering about whether a molecule is carcinogenic",
            "operation": " make sure the output order: T.label"
        },
        "494": {
            "condition": "When the question mentions \"molecule TR151\"",
            "operation": " \"TR151\" actually means \"T.molecule_id = 'TR151'\" in schema"
        },
        "495": {
            "condition": "When answering about whether a molecule is carcinogenic, When the question mentions \"molecule TR151\", When referring to the molecule table",
            "operation": " use table alias \"T\" for molecule table instead of \"molecules\""
        },
        "496": {
            "condition": "When answering about toxic elements in molecule TR151",
            "operation": " make sure the output order: T.element"
        },
        "497": {
            "condition": "When the question mentions \"toxic element\"",
            "operation": " \"toxic element\" actually means \"element in schema\" from table atom"
        },
        "498": {
            "condition": "When the question mentions molecule TR151",
            "operation": " use literal value 'TR151' exactly as shown"
        },
        "499": {
            "condition": "When querying from the atom table",
            "operation": " use alias T for the atom table"
        },
        "500": {
            "condition": "When filtering for molecule TR151",
            "operation": " use condition T.molecule_id = 'TR151'"
        },
        "501": {
            "condition": "When selecting elements",
            "operation": " use T.element with table alias qualification instead of unqualified element"
        },
        "502": {
            "condition": "When eliminating duplicate elements",
            "operation": " add DISTINCT to the selection"
        },
        "503": {
            "condition": "When answering about toxic elements in molecule TR151, When the question mentions \"toxic element\", When the question mentions molecule TR151, When querying from the atom table, When filtering for molecule TR151, When selecting elements, When eliminating duplicate elements, When handling text literals",
            "operation": " preserve exact case and formatting of 'TR151'"
        },
        "504": {
            "condition": "When answering about \"chemical compounds\"",
            "operation": " the correct table to use is \"molecule AS T\" instead of \"compounds\"."
        },
        "505": {
            "condition": "When counting chemical compounds",
            "operation": " use COUNT(T.molecule_id) to count specific non-null values rather than COUNT(*)."
        },
        "506": {
            "condition": "When answering about \"chemical compounds\", When counting chemical compounds, When identifying carcinogenic compounds",
            "operation": " filter with T.label = '+' instead of carcinogenic = 'yes' to apply the appropriate condition for the desired subset."
        },
        "507": {
            "condition": "When selecting from the atom table",
            "operation": " use the exact table name \"atom\" instead of \"atoms\"."
        },
        "508": {
            "condition": "When filtering by element",
            "operation": " use the exact literal 'c' instead of 'carbon' to match the correct data values."
        },
        "509": {
            "condition": "When selecting specific columns",
            "operation": " explicitly specify T.atom_id instead of using * to select all columns."
        },
        "510": {
            "condition": "When selecting from the atom table, When filtering by element, When selecting specific columns, When referencing columns",
            "operation": " use the table alias T consistently with T.atom_id, T.molecule_id, and T.element instead of referencing columns without aliases."
        },
        "511": {
            "condition": "When counting atoms",
            "operation": " use COUNT(T1.atom_id) instead of COUNT(*) to count specific non-null values."
        },
        "512": {
            "condition": "When joining atom and molecule tables",
            "operation": " use INNER JOIN with ON T1.molecule_id = T2.molecule_id to link matching rows."
        },
        "513": {
            "condition": "When filtering for carcinogenic compounds",
            "operation": " use WHERE T2.label = '+' instead of 'carcinogenic' to match the correct label value."
        },
        "514": {
            "condition": "When counting atoms, When joining atom and molecule tables, When filtering for carcinogenic compounds, When referencing tables",
            "operation": " use atom AS T1 and molecule AS T2 as the canonical aliases."
        },
        "515": {
            "condition": "When selecting bond identifiers",
            "operation": " use the exact column token \"T1.bond_id\" with table alias qualification instead of unqualified \"bond_id\"."
        },
        "516": {
            "condition": "When referencing the bond table",
            "operation": " use the exact table name \"bond\" with alias \"T1\" instead of \"bonds\"."
        },
        "517": {
            "condition": "When combining bond and molecule data",
            "operation": " perform an inner join between \"bond AS T1\" and \"molecule AS T2\" using the exact join condition \"T1.molecule_id = T2.molecule_id\" instead of using a subquery."
        },
        "518": {
            "condition": "When filtering for double bonds with carcinogenic compounds",
            "operation": " use the exact filter conditions \"T2.label = '+' AND T1.bond_type = '='\" instead of \"bond_type = 'double' AND compound_id IN (SELECT compound_id FROM compounds WHERE carcinogenic = 'yes')\"."
        },
        "519": {
            "condition": "When handling carcinogenic compounds",
            "operation": " recognize that \"carcinogenic\" in the question maps to \"T2.label = '+'\" in the schema, not a separate compounds table."
        },
        "520": {
            "condition": "When selecting bond identifiers, When referencing the bond table, When combining bond and molecule data, When filtering for double bonds with carcinogenic compounds, When handling carcinogenic compounds, When handling double bonds",
            "operation": " recognize that \"double-bond\" in the question maps to \"T1.bond_type = '='\" in the schema, not the literal value 'double'."
        },
        "521": {
            "condition": "When answering about \"atoms belonging to molecules\"",
            "operation": " use INNER JOIN between atom AS T1 and molecule AS T2 where T1.molecule_id = T2.molecule_id to combine tables and keep only matching pairs."
        },
        "522": {
            "condition": "When counting atoms",
            "operation": " use COUNT(T1.atom_id) with alias atomnums_h instead of generic COUNT(*)."
        },
        "523": {
            "condition": "When filtering for hydrogen element",
            "operation": " use T1.element = 'h' instead of 'hydrogen'."
        },
        "524": {
            "condition": "When answering about \"atoms belonging to molecules\", When counting atoms, When filtering for hydrogen element, When filtering for carcinogenic compound label",
            "operation": " use T2.label = '+' instead of 'carcinogenic compound'."
        },
        "525": {
            "condition": "When the question mentions \"labeled with carcinogenic compound\"",
            "operation": " the exact literal value in the schema is '+' not 'carcinogenic compound'."
        },
        "526": {
            "condition": "When filtering for hydrogen atoms",
            "operation": " use the exact literal 'h' for the element condition."
        },
        "527": {
            "condition": "When counting atoms",
            "operation": " count using the atom_id column from the atom table (T1.atom_id)."
        },
        "528": {
            "condition": "When the question mentions \"labeled with carcinogenic compound\", When filtering for hydrogen atoms, When counting atoms, When combining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "529": {
            "condition": "When answering about molecule id belonging to a bond",
            "operation": " select T2.molecule_id, T2.bond_id, and T1.atom_id instead of just molecule_id."
        },
        "530": {
            "condition": "When joining tables for bond relationships",
            "operation": " use connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id instead of querying a single bonds table."
        },
        "531": {
            "condition": "When filtering for atom named TR000_1",
            "operation": " use T1.atom_id = 'TR000_1' instead of atom1_name = 'TR000_1'."
        },
        "532": {
            "condition": "When answering about molecule id belonging to a bond, When joining tables for bond relationships, When filtering for atom named TR000_1, When filtering for bond TR000_1_2",
            "operation": " use T2.bond_id = 'TR000_1_2' instead of bond_name = 'TR000_1_2'."
        },
        "533": {
            "condition": "When answering about atoms containing element carbon",
            "operation": " use table \"atom\" as T1 instead of \"atoms\" and select T1.atom_id instead of atom_name."
        },
        "534": {
            "condition": "When the question mentions \"element carbon\"",
            "operation": " \"carbon\" actually means \"c\" in schema, so use T1.element = 'c' exactly."
        },
        "535": {
            "condition": "When checking for compound carcinogenic",
            "operation": " join with table \"molecule\" as T2 using T1.molecule_id = T2.molecule_id and use T2.label = '-' to represent not containing carcinogenic compound."
        },
        "536": {
            "condition": "When answering about atoms containing element carbon, When the question mentions \"element carbon\", When checking for compound carcinogenic, When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id exactly and keep only matching pairs (inner match)."
        },
        "537": {
            "condition": "When calculating percentages",
            "operation": " use CAST with REAL for percentage calculation instead of implicit decimal conversion."
        },
        "538": {
            "condition": "When counting with conditions",
            "operation": " use COUNT(CASE WHEN condition THEN value END) with specific conditions instead of simple COUNT(*)."
        },
        "539": {
            "condition": "When the question mentions \"element is hydrogen\"",
            "operation": " use T1.element = 'h' instead of 'hydrogen'."
        },
        "540": {
            "condition": "When the question mentions \"carcinogenic compounds\"",
            "operation": " use T2.label = '+' instead of is_carcinogenic = 1."
        },
        "541": {
            "condition": "When combining atom and molecule tables",
            "operation": " join atom AS T1 and molecule AS T2 on T1.molecule_id = T2.molecule_id."
        },
        "542": {
            "condition": "When calculating total count for percentage denominator",
            "operation": " use COUNT(T2.molecule_id) instead of a subquery."
        },
        "543": {
            "condition": "When calculating percentages, When counting with conditions, When the question mentions \"element is hydrogen\", When the question mentions \"carcinogenic compounds\", When combining atom and molecule tables, When calculating total count for percentage denominator, When referring to database entities",
            "operation": " use tables atom and molecule instead of molecules and compounds."
        },
        "544": {
            "condition": "When answering about whether a molecule is carcinogenic",
            "operation": " make sure the output order: T.label"
        },
        "545": {
            "condition": "When the question mentions \"TR124\"",
            "operation": " \"TR124\" actually means T.molecule_id in schema"
        },
        "546": {
            "condition": "When querying from the molecule table",
            "operation": " use alias T for the molecule table instead of no alias"
        },
        "547": {
            "condition": "When answering about whether a molecule is carcinogenic, When the question mentions \"TR124\", When querying from the molecule table, When filtering for a specific molecule",
            "operation": " use T.molecule_id = 'TR124' as the filter condition instead of name = 'TR124'"
        },
        "548": {
            "condition": "When answering about \"atoms comprise TR186\"",
            "operation": " make sure the output order: atom_id."
        },
        "549": {
            "condition": "When the question mentions \"TR186\"",
            "operation": " \"TR186\" actually means \"molecule_id = 'TR186'\" in schema."
        },
        "550": {
            "condition": "When selecting from the atom table",
            "operation": " use the exact table name \"atom\" (not \"atoms\") and alias it as \"T\"."
        },
        "551": {
            "condition": "When answering about \"atoms comprise TR186\", When the question mentions \"TR186\", When selecting from the atom table, When returning atom identifiers",
            "operation": " select the exact column \"atom_id\" (not \"atom_name\") from table T."
        },
        "552": {
            "condition": "When answering about \"bond type of TR007_4_19\"",
            "operation": " make sure the output order: bond_type."
        },
        "553": {
            "condition": "When the question mentions \"bond type\"",
            "operation": " \"bond type\" actually means \"bond_type in schema\"."
        },
        "554": {
            "condition": "When the question mentions \"TR007_4_19\"",
            "operation": " use the exact literal 'TR007_4_19' in the condition."
        },
        "555": {
            "condition": "When selecting from the bond table",
            "operation": " use table alias T and reference columns as T.column_name."
        },
        "556": {
            "condition": "When answering about \"bond type of TR007_4_19\", When the question mentions \"bond type\", When the question mentions \"TR007_4_19\", When selecting from the bond table, When filtering for a specific bond",
            "operation": " use the condition T.bond_id = 'TR007_4_19' with exact token matching."
        },
        "557": {
            "condition": "When answering about \"elements that comprise atoms of bond TR001_2_4\"",
            "operation": " make sure the output order: element"
        },
        "558": {
            "condition": "When the question mentions \"elements\"",
            "operation": " \"elements\" actually means \"element in table atom\""
        },
        "559": {
            "condition": "When retrieving distinct values from the element column",
            "operation": " use DISTINCT to get unique element values"
        },
        "560": {
            "condition": "When combining tables atom and connected for shared entities",
            "operation": " link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)"
        },
        "561": {
            "condition": "When filtering for bond TR001_2_4",
            "operation": " apply the filter T2.bond_id = 'TR001_2_4' exactly as specified"
        },
        "562": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "563": {
            "condition": "When answering about \"elements that comprise atoms of bond TR001_2_4\", When the question mentions \"elements\", When retrieving distinct values from the element column, When combining tables atom and connected for shared entities, When filtering for bond TR001_2_4, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'TR001_2_4'"
        },
        "564": {
            "condition": "When the question asks about \"double bonds\" for a molecule",
            "operation": " count the number of bond records using COUNT(T1.bond_id) where T1.bond_type = '='."
        },
        "565": {
            "condition": "When the question asks about \"carcinogenic\" status",
            "operation": " use T2.label from the molecule table instead."
        },
        "566": {
            "condition": "When combining bond and molecule data",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "567": {
            "condition": "When filtering for a specific molecule ID 'TR006'",
            "operation": " use T2.molecule_id = 'TR006' exactly as specified."
        },
        "568": {
            "condition": "When the question asks about \"double bonds\" for a molecule, When the question asks about \"carcinogenic\" status, When combining bond and molecule data, When filtering for a specific molecule ID 'TR006', When producing output for molecule properties",
            "operation": " group the results by T2.label to get per-molecule aggregates."
        },
        "569": {
            "condition": "When answering about \"carcinogenic molecules and their elements\"",
            "operation": " make sure the output order: T2.molecule_id, T1.element"
        },
        "570": {
            "condition": "When the question mentions \"carcinogenic\"",
            "operation": " \"carcinogenic\" actually means \"T2.label = '+' in schema\""
        },
        "571": {
            "condition": "When combining T1 (atom) and T2 (molecule) for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)"
        },
        "572": {
            "condition": "When the question asks for \"distinct molecules\"",
            "operation": " compute the number of unique values of T2.molecule_id"
        },
        "573": {
            "condition": "When answering about \"carcinogenic molecules and their elements\", When the question mentions \"carcinogenic\", When combining T1 (atom) and T2 (molecule) for shared entities, When the question asks for \"distinct molecules\", When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exactly '+' for the carcinogenic label"
        },
        "574": {
            "condition": "When answering about bonds with single bond types",
            "operation": " filter for T1.bond_type = '-' exactly as specified."
        },
        "575": {
            "condition": "When retrieving connected atoms for bonds",
            "operation": " select T2.atom_id and T2.atom_id2 from the connected table T2 instead of joining atoms table multiple times."
        },
        "576": {
            "condition": "When combining bond and connected tables",
            "operation": " link rows where T1.bond_id = T2.bond_id using an inner match."
        },
        "577": {
            "condition": "When referring to the bonds table",
            "operation": " use T1 as the alias instead of b."
        },
        "578": {
            "condition": "When answering about bonds with single bond types, When retrieving connected atoms for bonds, When combining bond and connected tables, When referring to the bonds table, When referring to the connected table",
            "operation": " use T2 as the alias instead of a1 and a2."
        },
        "579": {
            "condition": "When the question asks for bonds with single bond types",
            "operation": " filter bonds where T1.bond_type equals exactly '-'"
        },
        "580": {
            "condition": "When the question asks what atoms are connected to the molecules",
            "operation": " include both atom identification columns T2.atom_id and T2.atom_id2 in the output"
        },
        "581": {
            "condition": "When combining bond and connected tables",
            "operation": " link rows where T1.bond_id equals T2.bond_id and keep only matching pairs (inner match)"
        },
        "582": {
            "condition": "When the question asks for bonds with single bond types, When the question asks what atoms are connected to the molecules, When combining bond and connected tables, When producing output columns",
            "operation": " include only T1.bond_id, T2.atom_id, and T2.atom_id2 in the result, excluding T1.bond_type from the final output"
        },
        "583": {
            "condition": "When answering about molecules with triple bonds",
            "operation": " use table bond as T1 and table atom as T2 with INNER JOIN on T1.molecule_id = T2.molecule_id instead of joining molecules, bonds, and elements separately."
        },
        "584": {
            "condition": "When filtering for triple bonds",
            "operation": " use bond_type = '#' instead of bond_type = 'triple'."
        },
        "585": {
            "condition": "When selecting molecule and element information",
            "operation": " select T1.molecule_id and T2.element instead of name and concatenated elements."
        },
        "586": {
            "condition": "When listing distinct elements per molecule",
            "operation": " use DISTINCT instead of GROUP_CONCAT with grouping."
        },
        "587": {
            "condition": "When answering about molecules with triple bonds, When filtering for triple bonds, When selecting molecule and element information, When listing distinct elements per molecule, When organizing results",
            "operation": " remove the GROUP BY clause instead of grouping by molecule name."
        },
        "588": {
            "condition": "When answering about \"atoms' elements that form bond TR000_2_3\"",
            "operation": " make sure the output order: T2.element"
        },
        "589": {
            "condition": "When the question mentions \"atoms' elements\"",
            "operation": " \"atoms' elements\" actually means \"T2.element in schema\""
        },
        "590": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.atom_id = T2.atom_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "591": {
            "condition": "When filtering for bond TR000_2_3",
            "operation": " use T1.bond_id = 'TR000_2_3' with exact literal 'TR000_2_3'"
        },
        "592": {
            "condition": "When answering about \"atoms' elements that form bond TR000_2_3\", When the question mentions \"atoms' elements\", When combining T1 and T2 for shared entities, When filtering for bond TR000_2_3, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "593": {
            "condition": "When counting bonds created by bonding atoms with chlorine element",
            "operation": " count using T1.bond_id from the connected table instead of counting all rows."
        },
        "594": {
            "condition": "When combining connected and atom tables",
            "operation": " link rows where T1.atom_id = T2.atom_id using an inner join to keep only matching pairs."
        },
        "595": {
            "condition": "When filtering for chlorine element",
            "operation": " use T2.element = 'cl' exactly as specified (lowercase 'cl') instead of 'Cl' or other variations."
        },
        "596": {
            "condition": "When counting bonds created by bonding atoms with chlorine element, When combining connected and atom tables, When filtering for chlorine element, When referencing tables",
            "operation": " use the exact aliases T1 for connected table and T2 for atom table as established in the join structure."
        },
        "597": {
            "condition": "When answering about atoms and bonds",
            "operation": " combine tables atom as T1 and bond as T2 using inner match where T1.molecule_id = T2.molecule_id."
        },
        "598": {
            "condition": "When filtering by molecule",
            "operation": " use T1.molecule_id = 'TR000' instead of molecule_name."
        },
        "599": {
            "condition": "When counting bond types",
            "operation": " count distinct T2.bond_type values."
        },
        "600": {
            "condition": "When grouping results",
            "operation": " group by both T1.atom_id and T2.bond_type."
        },
        "601": {
            "condition": "When selecting output columns",
            "operation": " include T1.atom_id and T1.molecule_id in the results."
        },
        "602": {
            "condition": "When answering about atoms and bonds, When filtering by molecule, When counting bond types, When grouping results, When selecting output columns, When using identifiers",
            "operation": " specify table aliases explicitly as T1.atom_id instead of just atom_id."
        },
        "603": {
            "condition": "When the question asks for atoms belonging to molecule 'TR346'",
            "operation": " use the exact literal value 'TR000' instead of 'TR346' in the filter condition."
        },
        "604": {
            "condition": "When counting distinct bond types created by a molecule",
            "operation": " group by T2.bond_type instead of T1.molecule_id to properly support the COUNT(DISTINCT T2.bond_type) aggregation."
        },
        "605": {
            "condition": "When the question asks for atoms belonging to molecule 'TR346', When counting distinct bond types created by a molecule, When selecting output columns for atom information",
            "operation": " place T1.molecule_id at the end of the SELECT list instead of at the beginning."
        },
        "606": {
            "condition": "When filtering for a specific molecule identifier",
            "operation": " use the exact literal value 'TR000' instead of 'TR346' for the molecule_id condition."
        },
        "607": {
            "condition": "When filtering for a specific molecule identifier, When counting distinct bond types for a molecule",
            "operation": " ensure the molecule filter condition uses the correct literal value specified in the question requirements."
        },
        "608": {
            "condition": "When counting molecules",
            "operation": " use COUNT(DISTINCT T2.molecule_id) instead of COUNT(*) to count unique molecules rather than all bonds."
        },
        "609": {
            "condition": "When combining bond and molecule tables",
            "operation": " use bond AS T1 INNER JOIN molecule AS T2 with join condition ON T1.molecule_id = T2.molecule_id instead of querying a single table."
        },
        "610": {
            "condition": "When checking for carcinogenic compounds",
            "operation": " use T2.label = '+' instead of carcinogenic = 'yes' to use the correct column and value."
        },
        "611": {
            "condition": "When counting molecules, When combining bond and molecule tables, When checking for carcinogenic compounds, When filtering for double bond type",
            "operation": " use T1.bond_type = '=' instead of bond_type = 'double' to use the correct table reference and value syntax."
        },
        "612": {
            "condition": "When counting molecules with double bonds",
            "operation": " use COUNT(DISTINCT T2.molecule_id) to count distinct molecules from the molecule table rather than from the bond table."
        },
        "613": {
            "condition": "When counting carcinogenic compounds among molecules with double bonds",
            "operation": " use SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) to count occurrences rather than distinct molecules, as multiple double bonds per molecule should be handled."
        },
        "614": {
            "condition": "When the question asks about molecules labeled as carcinogenic compounds",
            "operation": " \"labeled as carcinogenic compound\" means T2.label = '+' exactly."
        },
        "615": {
            "condition": "When the question asks about double bond type",
            "operation": " \"double bond type\" means T1.bond_type = '=' exactly."
        },
        "616": {
            "condition": "When combining bond and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "617": {
            "condition": "When counting molecules with double bonds, When counting carcinogenic compounds among molecules with double bonds, When the question asks about molecules labeled as carcinogenic compounds, When the question asks about double bond type, When combining bond and molecule tables, When producing output",
            "operation": " do not include column aliases total_molecules_with_double_bonds and carcinogenic_molecules_with_double_bonds for a concise format."
        },
        "618": {
            "condition": "When counting molecules",
            "operation": " use COUNT(DISTINCT T1.molecule_id) instead of COUNT(*) to count distinct molecules rather than all rows."
        },
        "619": {
            "condition": "When combining atom and bond information",
            "operation": " use atom AS T1 and bond AS T2 as FROM sources and perform INNER JOIN on T1.molecule_id = T2.molecule_id instead of querying a single table."
        },
        "620": {
            "condition": "When filtering for non-sulfur elements",
            "operation": " use T1.element <> 's' instead of element != 'S' for case sensitivity and proper table reference."
        },
        "621": {
            "condition": "When counting molecules, When combining atom and bond information, When filtering for non-sulfur elements, When filtering for single bonds",
            "operation": " use T2.bond_type <> '=' instead of double_bond = 0 to properly identify single bonds."
        },
        "622": {
            "condition": "When answering about \"carcinogenic label for bond TR001_2_4\"",
            "operation": " make sure the output order: T2.label"
        },
        "623": {
            "condition": "When the question mentions \"bond TR001_2_4\"",
            "operation": " \"bond TR001_2_4\" actually means \"T3.bond_id = 'TR001_2_4'\" in schema"
        },
        "624": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)"
        },
        "625": {
            "condition": "When selecting the label",
            "operation": " use DISTINCT modifier to get unique values of T2.label"
        },
        "626": {
            "condition": "When answering about \"carcinogenic label for bond TR001_2_4\", When the question mentions \"bond TR001_2_4\", When combining tables for shared entities, When selecting the label, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for 'TR001_2_4'"
        },
        "627": {
            "condition": "When counting atoms",
            "operation": " use COUNT(T.atom_id) instead of COUNT(*) to count specific non-null values."
        },
        "628": {
            "condition": "When referencing the atom table",
            "operation": " use the exact table name \"atom\" instead of \"atoms\"."
        },
        "629": {
            "condition": "When using table aliases",
            "operation": " always specify the alias \"AS T\" in the FROM clause and use \"T\" to qualify column references."
        },
        "630": {
            "condition": "When counting atoms, When referencing the atom table, When using table aliases, When counting entities",
            "operation": " use the canonical key \"atom_id\" for counting atoms rather than a generic count of all rows."
        },
        "631": {
            "condition": "When answering about \"how many single bonds\"",
            "operation": " make sure the output order: count of bonds with single bond type."
        },
        "632": {
            "condition": "When the question mentions \"single bonds\"",
            "operation": " \"single bonds\" actually means \"bond_type = '-' in schema\"."
        },
        "633": {
            "condition": "When counting bonds",
            "operation": " compute the number of rows using the canonical key token T.bond_id to exclude NULL values."
        },
        "634": {
            "condition": "When answering about \"how many single bonds\", When the question mentions \"single bonds\", When counting bonds, When filtering for bond type",
            "operation": " use the exact literal '-' with single quotes to match the correct bond type criteria."
        },
        "635": {
            "condition": "When answering about molecules containing \"cl\" element",
            "operation": " use table \"atom AS T1\" and filter with exact equality T1.element = 'cl' instead of pattern matching."
        },
        "636": {
            "condition": "When determining carcinogenic status",
            "operation": " use table \"molecule AS T2\" and filter with T2.label = '+' instead of checking a 'carcinogenic' column."
        },
        "637": {
            "condition": "When combining atom and molecule information",
            "operation": " link rows where T1.molecule_id = T2.molecule_id using an inner join to keep only matching pairs."
        },
        "638": {
            "condition": "When answering about molecules containing \"cl\" element, When determining carcinogenic status, When combining atom and molecule information, When selecting output columns",
            "operation": " return only T1.molecule_id with DISTINCT to show unique molecule identifiers instead of all columns."
        },
        "639": {
            "condition": "When answering about molecules containing \"c\" element",
            "operation": " use table atom AS T1 INNER JOIN molecule AS T2 with join condition T1.molecule_id = T2.molecule_id instead of just the molecules table."
        },
        "640": {
            "condition": "When filtering for \"c\" element",
            "operation": " use exact equality T1.element = 'c' instead of pattern matching LIKE '%c%'."
        },
        "641": {
            "condition": "When identifying non-carcinogenic molecules",
            "operation": " use condition T2.label = '-' instead of carcinogenic = 'yes'."
        },
        "642": {
            "condition": "When answering about molecules containing \"c\" element, When filtering for \"c\" element, When identifying non-carcinogenic molecules, When selecting output",
            "operation": " use DISTINCT T1.molecule_id instead of all columns with SELECT *."
        },
        "643": {
            "condition": "When answering about carcinogenic molecules containing Chlorine element",
            "operation": " use tables \"atom AS T1\" and \"molecule AS T2\" with an inner join on T1.molecule_id = T2.molecule_id."
        },
        "644": {
            "condition": "When detecting carcinogenic status",
            "operation": " use T2.label instead of carcinogenic."
        },
        "645": {
            "condition": "When detecting chlorine element",
            "operation": " use exact string comparison T1.element = 'cl' instead of pattern matching."
        },
        "646": {
            "condition": "When counting molecules",
            "operation": " count T2.molecule_id in both numerator and denominator instead of case results."
        },
        "647": {
            "condition": "When answering about carcinogenic molecules containing Chlorine element, When detecting carcinogenic status, When detecting chlorine element, When counting molecules, When calculating percentage",
            "operation": " use integer division without decimal points instead of floating-point division."
        },
        "648": {
            "condition": "When the question asks for percentage of carcinogenic molecules containing Chlorine",
            "operation": " use 'T2.label = '+' to identify carcinogenic molecules instead of 'carcinogenic'."
        },
        "649": {
            "condition": "When counting molecules containing Chlorine element",
            "operation": " use T1.element = 'cl' to identify Chlorine atoms (exact lowercase 'cl')."
        },
        "650": {
            "condition": "When calculating percentage",
            "operation": " count specific molecule occurrences using COUNT(CASE WHEN T2.label = '+' AND T1.element = 'cl' THEN T2.molecule_id ELSE NULL END) rather than distinct values."
        },
        "651": {
            "condition": "When calculating the denominator",
            "operation": " use COUNT(T2.molecule_id) to count all molecule instances rather than unique ones."
        },
        "652": {
            "condition": "When combining atom and molecule tables",
            "operation": " link rows where T1.molecule_id = T2.molecule_id to associate atoms with their molecules."
        },
        "653": {
            "condition": "When the question asks for percentage of carcinogenic molecules containing Chlorine, When counting molecules containing Chlorine element, When calculating percentage, When calculating the denominator, When combining atom and molecule tables, When handling conditional counting",
            "operation": " include all molecules in the calculation and let CASE logic handle the conditional counting instead of pre-filtering with WHERE clause."
        },
        "654": {
            "condition": "When answering about \"molecule id of bond id TR001_1_7\"",
            "operation": " make sure the output order: T1.molecule_id."
        },
        "655": {
            "condition": "When the question mentions \"bond id TR001_1_7\"",
            "operation": " \"bond id\" actually means \"T2.bond_id in schema\" with exact literal value 'TR001_1_7'."
        },
        "656": {
            "condition": "When combining atom table (T1) and connected table (T2) for shared entities",
            "operation": " link rows where T1.atom_id = T2.atom_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "657": {
            "condition": "When the question asks for distinct molecule IDs",
            "operation": " compute the number of unique values of T1.molecule_id using DISTINCT."
        },
        "658": {
            "condition": "When answering about \"molecule id of bond id TR001_1_7\", When the question mentions \"bond id TR001_1_7\", When combining atom table (T1) and connected table (T2) for shared entities, When the question asks for distinct molecule IDs, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T1.molecule_id and T2.bond_id."
        },
        "659": {
            "condition": "When counting elements for a specific bond_id",
            "operation": " use COUNT(DISTINCT T1.element) to count unique elements instead of counting all rows."
        },
        "660": {
            "condition": "When the question mentions bond_id 'TR001_3_4'",
            "operation": " this literal value must be matched exactly as 'TR001_3_4' with the correct case and underscores."
        },
        "661": {
            "condition": "When combining atom and connected tables",
            "operation": " link rows using T1.atom_id = T2.atom_id to create an inner match between the tables."
        },
        "662": {
            "condition": "When filtering by bond_id",
            "operation": " apply the filter condition T2.bond_id = 'TR001_3_4' to the connected table (T2) since bond_id is not available in the atom table."
        },
        "663": {
            "condition": "When counting elements for a specific bond_id, When the question mentions bond_id 'TR001_3_4', When combining atom and connected tables, When filtering by bond_id, When answering about elements contained in a bond",
            "operation": " the query must join atom AS T1 and connected AS T2 tables instead of querying a single elements table."
        },
        "664": {
            "condition": "When answering about bond type between two specific atoms",
            "operation": " use table alias T1 for bond table and T2 for connected table."
        },
        "665": {
            "condition": "When joining bond and connected tables",
            "operation": " link rows where T1.bond_id = T2.bond_id using inner join."
        },
        "666": {
            "condition": "When filtering for bonds connecting both TR000_1 and TR000_2",
            "operation": " use T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2' instead of OR logic."
        },
        "667": {
            "condition": "When answering about bond type between two specific atoms, When joining bond and connected tables, When filtering for bonds connecting both TR000_1 and TR000_2, When selecting the bond type",
            "operation": " use T1.bond_type as the output column."
        },
        "668": {
            "condition": "When answering about molecules containing specific atoms",
            "operation": " query from bond table as T1 and connected table as T2 with an inner join on T1.bond_id = T2.bond_id instead of querying only from molecules table."
        },
        "669": {
            "condition": "When filtering for atom id \"TR000_2\" and atom id 2 \"TR000_4\"",
            "operation": " filter on T2.atom_id = 'TR000_2' and T2.atom_id2 = 'TR000_4' instead of filtering on the same column with conflicting values."
        },
        "670": {
            "condition": "When answering about molecules containing specific atoms, When filtering for atom id \"TR000_2\" and atom id 2 \"TR000_4\", When selecting output columns",
            "operation": " select only T1.molecule_id instead of selecting all columns with *."
        },
        "671": {
            "condition": "When the question asks about \"element of toxicology\" for an atom",
            "operation": " \"element\" actually means column \"element\" in table \"atom\" with alias T."
        },
        "672": {
            "condition": "When the question mentions an atom with ID \"TR000_1\"",
            "operation": " use the exact literal value 'TR000_1' for filtering."
        },
        "673": {
            "condition": "When querying for atom information",
            "operation": " use table \"atom\" with alias T instead of table \"toxicology\"."
        },
        "674": {
            "condition": "When the question asks about \"element of toxicology\" for an atom, When the question mentions an atom with ID \"TR000_1\", When querying for atom information, When filtering by atom_id",
            "operation": " use the qualified column reference T.atom_id instead of unqualified atom_id."
        },
        "675": {
            "condition": "When answering about whether molecule TR000 is carcinogenic",
            "operation": " make sure the output order: label from table molecule."
        },
        "676": {
            "condition": "When the question mentions \"carcinogenic\"",
            "operation": " \"carcinogenic\" actually means \"label in schema\" with values like '+' and '-'."
        },
        "677": {
            "condition": "When filtering for a specific molecule_id",
            "operation": " use exact literal 'TR000' with exact column token T.molecule_id."
        },
        "678": {
            "condition": "When answering about whether molecule TR000 is carcinogenic, When the question mentions \"carcinogenic\", When filtering for a specific molecule_id, When selecting from table molecule",
            "operation": " use table alias T as shown in the amends."
        },
        "679": {
            "condition": "When answering about percentage of atoms with single bond",
            "operation": " use table \"bond\" with alias T instead of \"atoms\" to access the correct data source."
        },
        "680": {
            "condition": "When counting bonds with specific type",
            "operation": " use COUNT(CASE WHEN T.bond_type = '-' THEN T.bond_id ELSE NULL END) to count only bonds where bond_type equals '-' exactly."
        },
        "681": {
            "condition": "When calculating percentage",
            "operation": " use COUNT(T.bond_id) as the denominator to count all bonds in the same table context."
        },
        "682": {
            "condition": "When handling type conversion",
            "operation": " cast the result to REAL instead of using 100.0 for explicit type conversion."
        },
        "683": {
            "condition": "When answering about percentage of atoms with single bond, When counting bonds with specific type, When calculating percentage, When handling type conversion, When producing output",
            "operation": " remove unnecessary column aliases and return only the calculated percentage value."
        },
        "684": {
            "condition": "When counting molecules",
            "operation": " use COUNT(DISTINCT T1.molecule_id) instead of COUNT(*) to count unique molecules."
        },
        "685": {
            "condition": "When the question mentions molecules consisting of Nitrogen",
            "operation": " join molecule AS T1 with atom AS T2 on T1.molecule_id = T2.molecule_id and filter on T2.element = 'n' to specifically find nitrogen atoms."
        },
        "686": {
            "condition": "When filtering for positive-labeled molecules",
            "operation": " add T1.label = '+' condition."
        },
        "687": {
            "condition": "When counting molecules, When the question mentions molecules consisting of Nitrogen, When filtering for positive-labeled molecules, When the question asks about carcinogenic molecules",
            "operation": " do not include carcinogenic = 'yes' condition as it should be removed."
        },
        "688": {
            "condition": "When answering about molecules with specific atoms and bonds",
            "operation": " use tables \"atom AS T1\" and \"bond AS T2\" instead of a single molecules table."
        },
        "689": {
            "condition": "When combining atom and bond information for the same molecule",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match)."
        },
        "690": {
            "condition": "When the question mentions \"Sulphur atom\"",
            "operation": " use exact element matching with T1.element = 's' instead of pattern matching."
        },
        "691": {
            "condition": "When the question mentions \"double bond\"",
            "operation": " use proper bond type syntax with T2.bond_type = '=' instead of text 'double'."
        },
        "692": {
            "condition": "When answering about molecules with specific atoms and bonds, When combining atom and bond information for the same molecule, When the question mentions \"Sulphur atom\", When the question mentions \"double bond\", When selecting output for molecule identification",
            "operation": " return DISTINCT T1.molecule_id instead of all columns to avoid duplicate molecule entries."
        },
        "693": {
            "condition": "When answering about non-carcinogenic molecules",
            "operation": " do not filter by carcinogenic = 0 as this filter should be removed."
        },
        "694": {
            "condition": "When counting atoms per molecule",
            "operation": " use a subquery with molecule AS T1 and atom AS T2 tables instead of a single molecules table."
        },
        "695": {
            "condition": "When joining molecule and atom tables",
            "operation": " use INNER JOIN on T1.molecule_id = T2.molecule_id to link rows where the canonical keys are equal."
        },
        "696": {
            "condition": "When filtering for non-carcinogenic molecules",
            "operation": " add filter T1.label = '-' in WHERE clause instead of carcinogenic = 0."
        },
        "697": {
            "condition": "When grouping results",
            "operation": " use GROUP BY T1.molecule_id to organize results by molecule ID."
        },
        "698": {
            "condition": "When counting atoms per molecule",
            "operation": " compute the number of atoms using COUNT(T2.atom_id) as the counting key."
        },
        "699": {
            "condition": "When filtering by atom count",
            "operation": " move the atom count filter to HAVING COUNT(T2.atom_id) > 5 instead of WHERE atom_count > 5."
        },
        "700": {
            "condition": "When answering about non-carcinogenic molecules, When counting atoms per molecule, When joining molecule and atom tables, When filtering for non-carcinogenic molecules, When grouping results, When counting atoms per molecule, When filtering by atom count, When selecting output columns",
            "operation": " select only T1.molecule_id instead of all columns (*)."
        },
        "701": {
            "condition": "When answering about \"elements with double bond in molecule TR024\"",
            "operation": " make sure the output order: T1.element"
        },
        "702": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)."
        },
        "703": {
            "condition": "When the question mentions \"molecule TR024\"",
            "operation": " \"TR024\" actually means T1.molecule_id = 'TR024' in schema"
        },
        "704": {
            "condition": "When answering about \"elements with double bond in molecule TR024\", When combining T1 and T2 for shared entities, When the question mentions \"molecule TR024\", When the question mentions \"double bond\"",
            "operation": " \"double bond\" actually means T2.bond_type = '=' in schema"
        },
        "705": {
            "condition": "When answering about \"carcinogenic molecule with highest number of atoms\"",
            "operation": " make sure the output order: molecule_id first, then count of atoms."
        },
        "706": {
            "condition": "When the question mentions \"carcinogenic molecule\"",
            "operation": " \"carcinogenic\" actually means \"T2.label = '+'\" in schema."
        },
        "707": {
            "condition": "When combining atom AS T1 and molecule AS T2 for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)."
        },
        "708": {
            "condition": "When counting atoms per molecule",
            "operation": " compute the number of rows using T1.atom_id as the counting key with GROUP BY T2.molecule_id."
        },
        "709": {
            "condition": "When answering about \"carcinogenic molecule with highest number of atoms\", When the question mentions \"carcinogenic molecule\", When combining atom AS T1 and molecule AS T2 for shared entities, When counting atoms per molecule, When the question mentions \"highest number of atoms\"",
            "operation": " rank rows by COUNT(T1.atom_id) in descending direction and keep the first 1 row."
        },
        "710": {
            "condition": "When calculating percentages involving conditional counts",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for conditional counting."
        },
        "711": {
            "condition": "When performing decimal division",
            "operation": " explicitly CAST to REAL instead of relying on implicit decimal conversion."
        },
        "712": {
            "condition": "When calculating percentages",
            "operation": " multiply by 100 after division instead of before division."
        },
        "713": {
            "condition": "When combining data from multiple tables (molecule, atom, bond)",
            "operation": " use INNER JOIN with exact join conditions T1.molecule_id = T2.molecule_id and T1.molecule_id = T3.molecule_id instead of querying a single table."
        },
        "714": {
            "condition": "When filtering for triple-bonded hydrogen atoms",
            "operation": " use WHERE clause with exact conditions T3.bond_type = '#' AND T2.element = 'h' instead of filtering through CASE expressions."
        },
        "715": {
            "condition": "When counting distinct entities in the denominator",
            "operation": " use COUNT(DISTINCT T1.molecule_id) instead of simple COUNT to avoid double-counting."
        },
        "716": {
            "condition": "When calculating percentages involving conditional counts, When performing decimal division, When calculating percentages, When combining data from multiple tables (molecule, atom, bond), When filtering for triple-bonded hydrogen atoms, When counting distinct entities in the denominator, When referring to carcinogenic molecules",
            "operation": " use T1.label = '+' instead of carcinogenic = 1 as the condition."
        },
        "717": {
            "condition": "When counting molecules",
            "operation": " use COUNT(T.molecule_id) to count specific non-null values rather than all rows."
        },
        "718": {
            "condition": "When referencing the molecule table",
            "operation": " use alias T instead of the bare table name for clarity."
        },
        "719": {
            "condition": "When identifying carcinogenic molecules",
            "operation": " filter on T.label = '+' instead of carcinogenic = 'yes' to use the appropriate column and value for positive cases."
        },
        "720": {
            "condition": "When counting molecules, When referencing the molecule table, When identifying carcinogenic molecules, When using table names",
            "operation": " use molecule instead of molecules to match the correct schema."
        },
        "721": {
            "condition": "When counting molecules",
            "operation": " count distinct T.molecule_id instead of counting all rows to get unique molecule counts."
        },
        "722": {
            "condition": "When accessing bond information",
            "operation": " query from bond AS T instead of molecules table to use the correct data source."
        },
        "723": {
            "condition": "When filtering by molecule ID range",
            "operation": " use T.molecule_id BETWEEN 'TR004' AND 'TR010' to select molecules within the specified range."
        },
        "724": {
            "condition": "When filtering by bond type",
            "operation": " use T.bond_type = '-' instead of 'single' to match the correct bond type representation in the schema."
        },
        "725": {
            "condition": "When counting molecules, When accessing bond information, When filtering by molecule ID range, When filtering by bond type, When referencing columns",
            "operation": " always use table alias T with column names (T.molecule_id, T.bond_type) for clarity and to avoid ambiguity."
        },
        "726": {
            "condition": "When answering about \"how many carbons are present in molecule TR008\"",
            "operation": " use the table alias T consistently for the atom table."
        },
        "727": {
            "condition": "When counting atoms",
            "operation": " count using the canonical key T.atom_id instead of counting all columns."
        },
        "728": {
            "condition": "When filtering by molecule",
            "operation": " use the exact literal 'TR008' for T.molecule_id."
        },
        "729": {
            "condition": "When filtering by element type",
            "operation": " use the exact lowercase literal 'c' for T.element instead of 'carbon'."
        },
        "730": {
            "condition": "When answering about \"how many carbons are present in molecule TR008\", When counting atoms, When filtering by molecule, When filtering by element type, When referring to the table",
            "operation": " use the exact table name atom instead of atoms."
        },
        "731": {
            "condition": "When answering about \"element with atom ID of TR004_7 in molecule that is not carcinogenic\"",
            "operation": " make sure the output order: T1.element"
        },
        "732": {
            "condition": "When the question mentions \"atom ID\"",
            "operation": " \"atom ID\" actually means \"T1.atom_id in schema\""
        },
        "733": {
            "condition": "When the question mentions \"not carcinogenic\"",
            "operation": " \"not carcinogenic\" actually means \"T2.label = '-' in schema\""
        },
        "734": {
            "condition": "When combining T1 (atom) and T2 (molecule) for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match)"
        },
        "735": {
            "condition": "When answering about \"element with atom ID of TR004_7 in molecule that is not carcinogenic\", When the question mentions \"atom ID\", When the question mentions \"not carcinogenic\", When combining T1 (atom) and T2 (molecule) for shared entities, When filtering for specific atom ID",
            "operation": " use exact literal value 'TR004_7' for T1.atom_id"
        },
        "736": {
            "condition": "When counting molecules",
            "operation": " count distinct T1.molecule_id instead of counting all rows to get unique molecule counts."
        },
        "737": {
            "condition": "When combining atom and bond tables",
            "operation": " use INNER JOIN between atom AS T1 and bond AS T2 with join condition T1.molecule_id = T2.molecule_id to properly relate atoms to their bonds."
        },
        "738": {
            "condition": "When counting molecules, When combining atom and bond tables, When identifying oxygen atoms with double bonds",
            "operation": " filter using T2.bond_type = '=' AND T1.element = 'o' instead of oxygen_bonds = 'double' to correctly identify oxygen atoms with double bonds through the bond_type column."
        },
        "739": {
            "condition": "When counting molecules",
            "operation": " count distinct T1.molecule_id instead of counting all rows."
        },
        "740": {
            "condition": "When relating molecules to bonds",
            "operation": " join molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id to properly connect molecules with their bonds."
        },
        "741": {
            "condition": "When filtering for triple bonds",
            "operation": " use T2.bond_type = '#' instead of 'triple' to match the correct symbol representation."
        },
        "742": {
            "condition": "When counting molecules, When relating molecules to bonds, When filtering for triple bonds, When identifying carcinogenic molecules",
            "operation": " use T1.label = '-' instead of carcinogenic = 'yes' to use the proper column name and value for carcinogenic identification."
        },
        "743": {
            "condition": "When answering about \"element and bond type included in the molecule\"",
            "operation": " make sure the output order: element, bond_type."
        },
        "744": {
            "condition": "When the question mentions \"molecule with molecule ID of TR002\"",
            "operation": " \"TR002\" actually means T1.molecule_id = 'TR002' in schema."
        },
        "745": {
            "condition": "When combining T1 (atom) and T2 (bond) for shared molecules",
            "operation": " link rows where T1.molecule_id = T2.molecule_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "746": {
            "condition": "When retrieving element and bond_type combinations",
            "operation": " use DISTINCT to return only unique combinations of these two columns."
        },
        "747": {
            "condition": "When answering about \"element and bond type included in the molecule\", When the question mentions \"molecule with molecule ID of TR002\", When combining T1 (atom) and T2 (bond) for shared molecules, When retrieving element and bond_type combinations, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exact value 'TR002'."
        },
        "748": {
            "condition": "When answering about \"atom ID of double bonded carbon in TR012 molecule\"",
            "operation": " make sure the output order: T1.atom_id."
        },
        "749": {
            "condition": "When the question mentions \"TR012 molecule\"",
            "operation": " \"TR012\" actually means \"T2.molecule_id = 'TR012'\" in schema."
        },
        "750": {
            "condition": "When the question mentions \"carbon\"",
            "operation": " \"carbon\" actually means \"T1.element = 'c'\" in schema with lowercase comparison."
        },
        "751": {
            "condition": "When the question mentions \"double bonded\"",
            "operation": " \"double bonded\" actually means \"T3.bond_type = '='\" in schema with equals sign syntax."
        },
        "752": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)."
        },
        "753": {
            "condition": "When answering about \"atom ID of double bonded carbon in TR012 molecule\", When the question mentions \"TR012 molecule\", When the question mentions \"carbon\", When the question mentions \"double bonded\", When combining tables for shared entities, When the question asks for atom ID",
            "operation": " return all matching rows instead of limiting to one result."
        },
        "754": {
            "condition": "When the question asks about a specific molecule by name like 'TR012'",
            "operation": " use the exact literal 'TR012' with the molecule_id column instead of label column to filter molecules."
        },
        "755": {
            "condition": "When joining tables atom, molecule, and bond",
            "operation": " do not include unnecessary joins to the connected table if the relationship can be established through direct foreign key relationships between the core tables."
        },
        "756": {
            "condition": "When filtering for carbon atoms",
            "operation": " use the exact literal 'c' (lowercase) for the element column to match carbon atoms."
        },
        "757": {
            "condition": "When the question asks about a specific molecule by name like 'TR012', When joining tables atom, molecule, and bond, When filtering for carbon atoms, When filtering for double bonds",
            "operation": " use the exact literal '=' for the bond_type column to identify double bonds."
        },
        "758": {
            "condition": "When joining atom and molecule tables",
            "operation": " use T1 for atom and T2 for molecule, and link rows where T1.molecule_id = T2.molecule_id with an inner match."
        },
        "759": {
            "condition": "When filtering for oxygen atoms",
            "operation": " use T1.element = 'o' (lowercase 'o' not uppercase 'O')."
        },
        "760": {
            "condition": "When identifying carcinogenic molecules",
            "operation": " use T2.label = '+' instead of carcinogenic = 1."
        },
        "761": {
            "condition": "When joining atom and molecule tables, When filtering for oxygen atoms, When identifying carcinogenic molecules, When selecting output",
            "operation": " return only the atom_id column from T1."
        }
    },
    "card_games": {
        "0": {
            "condition": "When answering about \"cards that have incredibly powerful foils\"",
            "operation": " make sure the output order: id."
        },
        "1": {
            "condition": "When selecting card identifiers",
            "operation": " use \"id\" instead of all columns with \"*\"."
        },
        "2": {
            "condition": "When filtering for cards with foil versions",
            "operation": " add conditions for \"cardKingdomFoilId IS NOT NULL\" and \"cardKingdomId IS NOT NULL\" instead of filtering on \"foil_power > 1000\"."
        },
        "3": {
            "condition": "When answering about \"cards that have incredibly powerful foils\", When selecting card identifiers, When filtering for cards with foil versions, When the question does not specify ordering",
            "operation": " remove any ORDER BY clause."
        },
        "4": {
            "condition": "When answering about \"borderless cards available without powerful foils\"",
            "operation": " make sure the output order: id."
        },
        "5": {
            "condition": "When the question mentions \"borderless\"",
            "operation": " \"borderless\" actually means \"borderColor = 'borderless'\" in schema."
        },
        "6": {
            "condition": "When the question mentions \"without powerful foils\"",
            "operation": " \"without powerful foils\" actually means \"(cardKingdomId IS NULL OR cardKingdomId IS NULL)\" in schema."
        },
        "7": {
            "condition": "When answering about \"borderless cards available without powerful foils\", When the question mentions \"borderless\", When the question mentions \"without powerful foils\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "8": {
            "condition": "When the question mentions \"borderless cards\"",
            "operation": " use the exact literal 'borderless' for the \"borderColor\" column condition."
        },
        "9": {
            "condition": "When checking for cards available without powerful foils",
            "operation": " verify that either \"cardKingdomId\" is missing (IS NULL) in both conditions of the OR clause, not checking different columns."
        },
        "10": {
            "condition": "When the question mentions \"borderless cards\", When checking for cards available without powerful foils, When producing output",
            "operation": " include only the \"id\" column as specified in the question about available cards."
        },
        "11": {
            "condition": "When answering about \"card names with value that cost more converted mana for the face\"",
            "operation": " make sure the output order includes only \"name\" column instead of both \"card_name\" and \"value\"."
        },
        "12": {
            "condition": "When the question asks for the card with the lowest faceConvertedManaCost value",
            "operation": " remove any WHERE filter conditions and instead order by \"faceConvertedManaCost\" in ascending order."
        },
        "13": {
            "condition": "When answering about \"card names with value that cost more converted mana for the face\", When the question asks for the card with the lowest faceConvertedManaCost value, When the question implies finding a single result",
            "operation": " limit the output to only 1 row using LIMIT 1 instead of returning all matching rows."
        },
        "14": {
            "condition": "When answering about \"cards with 2015 frame style ranking below 100 on EDHRec\"",
            "operation": " make sure the output order: id"
        },
        "15": {
            "condition": "When the question mentions \"frame style\"",
            "operation": " \"frame style\" actually means \"frameVersion in schema\""
        },
        "16": {
            "condition": "When the question mentions \"ranking below 100 on EDHRec\"",
            "operation": " \"ranking below 100\" actually means \"edhrecRank < 100\""
        },
        "17": {
            "condition": "When filtering for frame style",
            "operation": " use numeric value 2015 instead of string literal '2015' for frameVersion"
        },
        "18": {
            "condition": "When answering about \"cards with 2015 frame style ranking below 100 on EDHRec\", When the question mentions \"frame style\", When the question mentions \"ranking below 100 on EDHRec\", When filtering for frame style, When selecting card identifiers",
            "operation": " use column id instead of card_name"
        },
        "19": {
            "condition": "When answering about \"mythic rarity print cards banned in gladiator format\"",
            "operation": " make sure the output order: T1.id"
        },
        "20": {
            "condition": "When the question mentions \"banned in gladiator format\"",
            "operation": " \"banned\" actually means \"status = 'Banned'\" in schema and \"gladiator format\" actually means \"format = 'gladiator'\" in schema"
        },
        "21": {
            "condition": "When combining T1 (cards) and T2 (legalities) for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "22": {
            "condition": "When filtering for mythic rarity",
            "operation": " use T1.rarity = 'mythic' with exact literal 'mythic'"
        },
        "23": {
            "condition": "When answering about \"mythic rarity print cards banned in gladiator format\", When the question mentions \"banned in gladiator format\", When combining T1 (cards) and T2 (legalities) for shared entities, When filtering for mythic rarity, When selecting distinct cards",
            "operation": " use DISTINCT T1.id to get unique card identifiers instead of all columns"
        },
        "24": {
            "condition": "When selecting legalities status",
            "operation": " use T2.status from the legalities table instead of legalities from the cards table."
        },
        "25": {
            "condition": "When combining cards and legalities tables",
            "operation": " join T1 (cards) with T2 (legalities) on T1.uuid = T2.uuid using inner match."
        },
        "26": {
            "condition": "When filtering for artifact type",
            "operation": " use exact matching with T1.type = 'Artifact' instead of pattern matching."
        },
        "27": {
            "condition": "When filtering for vintage format",
            "operation": " use T2.format = 'vintage' for precise format filtering."
        },
        "28": {
            "condition": "When checking for cards without multiple faces",
            "operation": " use T1.side IS NULL instead of faces = 1 for proper side condition checking."
        },
        "29": {
            "condition": "When selecting legalities status, When combining cards and legalities tables, When filtering for artifact type, When filtering for vintage format, When checking for cards without multiple faces, When returning results",
            "operation": " use DISTINCT to eliminate duplicate status values."
        },
        "30": {
            "condition": "When selecting card identifiers and artists",
            "operation": " use T1.id and T1.artist instead of generic card_id and artist columns."
        },
        "31": {
            "condition": "When checking for commander format legality",
            "operation": " join cards table T1 with legalities table T2 using T1.uuid = T2.uuid and require T2.status = 'Legal' and T2.format = 'commander'."
        },
        "32": {
            "condition": "When selecting card identifiers and artists, When checking for commander format legality, When identifying cards with unknown power",
            "operation": " include both T1.power IS NULL and T1.power = '*' conditions to capture all unknown power values."
        },
        "33": {
            "condition": "When selecting card information",
            "operation": " include T1.id and T1.hasContentWarning instead of c.name and a hardcoded 'missing' value."
        },
        "34": {
            "condition": "When joining cards and rulings tables",
            "operation": " use INNER JOIN with the exact join condition T1.uuid = T2.uuid."
        },
        "35": {
            "condition": "When selecting card information, When joining cards and rulings tables, When filtering by artist",
            "operation": " use the exact literal 'Stephen Daniele' for T1.artist instead of 'Stephen Daniel'."
        },
        "36": {
            "condition": "When the question asks for cards illustrated by Stephen Daniel",
            "operation": " filter the cards table where T1.artist equals 'Stephen Daniele' exactly."
        },
        "37": {
            "condition": "When combining cards and rulings tables",
            "operation": " link rows where T1.uuid equals T2.uuid exactly and keep only matching pairs (inner match)."
        },
        "38": {
            "condition": "When selecting output columns",
            "operation": " include T1.id, T1.hasContentWarning, and T2.text without aliasing the text column."
        },
        "39": {
            "condition": "When the question asks for cards illustrated by Stephen Daniel, When combining cards and rulings tables, When selecting output columns, When the question asks about missing or degraded properties",
            "operation": " include T1.hasContentWarning in the output to indicate content warning status."
        },
        "40": {
            "condition": "When answering about \"cards illustrated by Stephen Daniel and their rulings\"",
            "operation": " make sure the output order is T1.id, T2.text, T1.hasContentWarning."
        },
        "41": {
            "condition": "When specifying table aliases",
            "operation": " use the exact syntax \"cards AS T1\" instead of \"cards T1\"."
        },
        "42": {
            "condition": "When the question mentions \"Stephen Daniel\"",
            "operation": " the exact literal value to match is 'Stephen Daniele' (case-sensitive)."
        },
        "43": {
            "condition": "When answering about \"cards illustrated by Stephen Daniel and their rulings\", When specifying table aliases, When the question mentions \"Stephen Daniel\", When combining cards and rulings tables",
            "operation": " link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)."
        },
        "44": {
            "condition": "When answering about rulings for a specific card",
            "operation": " join cards table as T1 to rulings table as T2 using T1.uuid = T2.uuid to link related records."
        },
        "45": {
            "condition": "When filtering for card named 'Sublime Epiphany'",
            "operation": " use T1.name = 'Sublime Epiphany' instead of filtering on rulings table attributes."
        },
        "46": {
            "condition": "When filtering for card number '74s'",
            "operation": " use T1.number = '74s' instead of filtering on rulings table attributes."
        },
        "47": {
            "condition": "When answering about rulings for a specific card, When filtering for card named 'Sublime Epiphany', When filtering for card number '74s', When selecting ruling information",
            "operation": " output only T2.text column instead of all columns with *."
        },
        "48": {
            "condition": "When selecting card information",
            "operation": " use T1.name for card name, T1.artist for artist name, and T1.isPromo for promotional status instead of card_name, artist_name, and is_promotional."
        },
        "49": {
            "condition": "When combining card and ruling information",
            "operation": " link rows using T1.uuid = T2.uuid with an inner join instead of joining on card_id and artist_id."
        },
        "50": {
            "condition": "When filtering for promotional cards",
            "operation": " include only rows where T1.isPromo = 1."
        },
        "51": {
            "condition": "When finding the artist with the most distinct promotional cards",
            "operation": " use a correlated subquery to count distinct promo cards per artist instead of grouping by card attributes and counting rulings."
        },
        "52": {
            "condition": "When selecting card information, When combining card and ruling information, When filtering for promotional cards, When finding the artist with the most distinct promotional cards, When determining the maximum count",
            "operation": " do not use GROUP BY or ORDER BY ruling_count DESC clauses."
        },
        "53": {
            "condition": "When answering about alternative languages for a specific card",
            "operation": " make sure the output order: T2.language"
        },
        "54": {
            "condition": "When the question mentions \"card named Annul numbered 29\"",
            "operation": " \"Annul\" actually means T1.name = 'Annul' and \"29\" actually means T1.number = '29'"
        },
        "55": {
            "condition": "When combining T1 (cards) and T2 (foreign_data) for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)"
        },
        "56": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "57": {
            "condition": "When answering about alternative languages for a specific card, When the question mentions \"card named Annul numbered 29\", When combining T1 (cards) and T2 (foreign_data) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Annul' and '29'"
        },
        "58": {
            "condition": "When answering about \"cards with alternative language in Japanese\"",
            "operation": " select T1.name from the cards table as T1."
        },
        "59": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T1.uuid = T2.uuid using an inner join."
        },
        "60": {
            "condition": "When filtering for Japanese language",
            "operation": " check T2.language = 'Japanese' exactly as written."
        },
        "61": {
            "condition": "When answering about \"cards with alternative language in Japanese\", When combining cards and foreign_data tables, When filtering for Japanese language, When producing output",
            "operation": " return only the card names in the order specified by the query."
        },
        "62": {
            "condition": "When calculating percentages from joined tables",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for accurate summation."
        },
        "63": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid using an inner join and keep only matching pairs."
        },
        "64": {
            "condition": "When referencing columns from joined tables",
            "operation": " use qualified references like T2.language instead of unqualified column names."
        },
        "65": {
            "condition": "When calculating percentage denominators",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count only the canonical entities."
        },
        "66": {
            "condition": "When performing explicit type conversion",
            "operation": " use CAST(... AS REAL) instead of implicit casting with numeric literals like 100.0."
        },
        "67": {
            "condition": "When calculating percentages from joined tables, When combining tables for shared entities, When referencing columns from joined tables, When calculating percentage denominators, When performing explicit type conversion, When the question asks for percentage of cards available in a specific language",
            "operation": " the language 'Chinese Simplified' must be matched exactly with case and spacing as shown in the schema."
        },
        "68": {
            "condition": "When answering about sets available in Italian translation",
            "operation": " select T1.name and T1.totalSetSize as output columns."
        },
        "69": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.code = T2.setCode and keep only matching pairs (inner match)."
        },
        "70": {
            "condition": "When filtering for Italian translation",
            "operation": " include only rows where T2.language = 'Italian' exactly."
        },
        "71": {
            "condition": "When answering about sets available in Italian translation, When combining T1 and T2 for shared entities, When filtering for Italian translation, When the question asks for total number of cards per set",
            "operation": " use T1.totalSetSize instead of counting individual cards."
        },
        "72": {
            "condition": "When counting types of cards",
            "operation": " count the number of non-null values in the \"type\" column instead of counting all rows."
        },
        "73": {
            "condition": "When filtering by artist",
            "operation": " use the exact literal 'Aaron Boyd' for the artist condition."
        },
        "74": {
            "condition": "When counting types of cards, When filtering by artist, When the question asks about cards regardless of art type",
            "operation": " do not include any filter on card_art column."
        },
        "75": {
            "condition": "When the question asks for \"keyword\" from a specific card",
            "operation": " use the exact column name \"keywords\" from the cards table instead of \"keyword\"."
        },
        "76": {
            "condition": "When retrieving values from the keywords column",
            "operation": " apply DISTINCT to ensure only unique values are returned."
        },
        "77": {
            "condition": "When the question asks for \"keyword\" from a specific card, When retrieving values from the keywords column, When filtering by card name",
            "operation": " use the exact literal 'Angel of Mercy' with proper case and punctuation."
        },
        "78": {
            "condition": "When the question asks about cards with \"infinite power\"",
            "operation": " use the exact literal value \"*\" for the power column filter instead of the word \"infinite\""
        },
        "79": {
            "condition": "When the question asks about cards with \"infinite power\", When counting cards that match a specific power condition",
            "operation": " count all rows where the power column equals the exact literal \"*\""
        },
        "80": {
            "condition": "When the question asks about promotion type for a card",
            "operation": " use column \"promoTypes\" from table \"cards\" instead of \"promotion_type\"."
        },
        "81": {
            "condition": "When filtering for card name 'Duress'",
            "operation": " use column \"name\" instead of \"card_name\" while keeping the exact literal value 'Duress'."
        },
        "82": {
            "condition": "When the question asks about promotion type for a card, When filtering for card name 'Duress', When retrieving promotion types",
            "operation": " ensure to filter out null values by adding condition \"promoTypes IS NOT NULL\"."
        },
        "83": {
            "condition": "When the question asks for \"border color\" of a specific card",
            "operation": " use the exact column name \"borderColor\" from the cards table."
        },
        "84": {
            "condition": "When filtering by card name with value \"Ancestor's Chosen\"",
            "operation": " use the exact literal 'Ancestor''s Chosen' with double single quotes for proper SQL string escaping."
        },
        "85": {
            "condition": "When the question asks for \"border color\" of a specific card, When filtering by card name with value \"Ancestor's Chosen\", When selecting from the cards table",
            "operation": " use DISTINCT to eliminate duplicate rows and return unique values only."
        },
        "86": {
            "condition": "When the question asks for \"type of the card\" as originally printed",
            "operation": " select \"originalType\" instead of \"card_type\" from the cards table."
        },
        "87": {
            "condition": "When filtering by card name \"Ancestor's Chosen\"",
            "operation": " use \"name\" = 'Ancestor\\'s Chosen' as the filter condition."
        },
        "88": {
            "condition": "When the question asks for \"type of the card\" as originally printed, When filtering by card name \"Ancestor's Chosen\", When selecting original type information",
            "operation": " include the condition \"originalType\" IS NOT NULL to exclude null values."
        },
        "89": {
            "condition": "Angel of Mercy' is the name of card;",
            "operation": "Angel of Mercy' is the name of card;"
        },
        "90": {
            "condition": "When counting cards",
            "operation": " count distinct card IDs using COUNT(DISTINCT T1.id) instead of counting all rows."
        },
        "91": {
            "condition": "When joining cards and legalities tables",
            "operation": " use INNER JOIN on T1.uuid = T2.uuid to match rows by UUID instead of ID."
        },
        "92": {
            "condition": "When filtering for restricted status",
            "operation": " use T2.status = 'Restricted' with exact case-sensitive matching instead of 'restricted'."
        },
        "93": {
            "condition": "When counting cards, When joining cards and legalities tables, When filtering for restricted status, When checking for cards with text boxes",
            "operation": " use T1.isTextless = 0 to identify non-textless cards instead of checking for text box presence."
        },
        "94": {
            "condition": "When answering about card ruling descriptions",
            "operation": " make sure the output order: T2.text"
        },
        "95": {
            "condition": "When the question mentions \"card 'Condemn'\"",
            "operation": " \"card 'Condemn'\" actually means \"T1.name = 'Condemn'\" in schema"
        },
        "96": {
            "condition": "When combining T1 (cards) and T2 (rulings) for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)"
        },
        "97": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "98": {
            "condition": "When answering about card ruling descriptions, When the question mentions \"card 'Condemn'\", When combining T1 (cards) and T2 (rulings) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - keep 'Condemn' exactly as specified"
        },
        "99": {
            "condition": "When counting cards",
            "operation": " count distinct values of T1.id instead of counting all rows."
        },
        "100": {
            "condition": "When joining cards and legalities tables",
            "operation": " use T1.uuid = T2.uuid for matching instead of id-based joins."
        },
        "101": {
            "condition": "When filtering for restricted status",
            "operation": " use T2.status = 'Restricted' with exact case-sensitive matching instead of 'restricted'."
        },
        "102": {
            "condition": "When checking for starter deck cards",
            "operation": " use T1.isStarter = 1 instead of joining with a decks table."
        },
        "103": {
            "condition": "When counting cards, When joining cards and legalities tables, When filtering for restricted status, When checking for starter deck cards, When the question involves deck types",
            "operation": " do not include unnecessary table joins when direct boolean properties are available."
        },
        "104": {
            "condition": "When answering about card status",
            "operation": " make sure the output order: T2.status"
        },
        "105": {
            "condition": "When the question mentions \"card\"",
            "operation": " \"card\" actually means \"T1.name in schema\""
        },
        "106": {
            "condition": "When combining T1 (cards) and T2 (legalities) for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)"
        },
        "107": {
            "condition": "When filtering for a specific card name",
            "operation": " use the exact literal 'Cloudchaser Eagle' with case and spacing preserved"
        },
        "108": {
            "condition": "When selecting status values",
            "operation": " use T2.status instead of unqualified status to specify the correct table source"
        },
        "109": {
            "condition": "When answering about card status, When the question mentions \"card\", When combining T1 (cards) and T2 (legalities) for shared entities, When filtering for a specific card name, When selecting status values, When retrieving status information",
            "operation": " add DISTINCT modifier to eliminate duplicate values"
        },
        "110": {
            "condition": "When answering about card types",
            "operation": " make sure the output order: T1.type"
        },
        "111": {
            "condition": "When the question mentions \"Benalish Knight\"",
            "operation": " \"Benalish Knight\" actually means T1.name in schema"
        },
        "112": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)"
        },
        "113": {
            "condition": "When answering about card types, When the question mentions \"Benalish Knight\", When combining T1 and T2 for shared entities, When the question asks for distinct values",
            "operation": " compute the number of unique values of the exact token for T1.type"
        },
        "114": {
            "condition": "When answering about \"rule of playing card\"",
            "operation": " make sure the output order: T2.format"
        },
        "115": {
            "condition": "When the question mentions \"Benalish Knight\"",
            "operation": " \"Benalish Knight\" actually means T1.name = 'Benalish Knight' in schema"
        },
        "116": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)"
        },
        "117": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "118": {
            "condition": "When answering about \"rule of playing card\", When the question mentions \"Benalish Knight\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation from 'Benalish Knight'"
        },
        "119": {
            "condition": "When answering about artists who illustrated card art in Phyrexian",
            "operation": " select \"artist\" from the \"cards\" table instead of \"artist_name\" from \"artists\"."
        },
        "120": {
            "condition": "When combining card and language data",
            "operation": " join \"cards\" (as T1) with \"foreign_data\" (as T2) using an INNER JOIN where T1.\"uuid\" = T2.\"uuid\"."
        },
        "121": {
            "condition": "When filtering for Phyrexian language",
            "operation": " apply the condition T2.\"language\" = 'Phyrexian' to the joined \"foreign_data\" table."
        },
        "122": {
            "condition": "When answering about artists who illustrated card art in Phyrexian, When combining card and language data, When filtering for Phyrexian language, When retrieving artist information",
            "operation": " ensure the output column is \"artist\" from the \"cards\" table."
        },
        "123": {
            "condition": "When the question asks for percentage of borderless cards",
            "operation": " use the exact literal 'borderless' to identify borderless cards."
        },
        "124": {
            "condition": "When calculating percentage of borderless cards",
            "operation": " use SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) instead of COUNT(*) with a WHERE filter."
        },
        "125": {
            "condition": "When referencing the border status column",
            "operation": " use borderColor instead of border as the correct column name."
        },
        "126": {
            "condition": "When performing division for percentage calculation",
            "operation": " cast the sum to REAL instead of relying on integer division."
        },
        "127": {
            "condition": "When counting total cards for denominator",
            "operation": " use COUNT(id) instead of a subquery (SELECT COUNT(*) FROM cards)."
        },
        "128": {
            "condition": "When the question asks for percentage of borderless cards, When calculating percentage of borderless cards, When referencing the border status column, When performing division for percentage calculation, When counting total cards for denominator, When formatting output",
            "operation": " omit explicit column naming (remove AS percentage alias)."
        },
        "129": {
            "condition": "When counting cards",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "130": {
            "condition": "When accessing language data",
            "operation": " add INNER JOIN foreign_data AS T2 to access language information."
        },
        "131": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T1.uuid = T2.uuid to properly relate the tables."
        },
        "132": {
            "condition": "When filtering by German language",
            "operation": " use T2.language = 'German' instead of language = 'German' to reference the correct table's column."
        },
        "133": {
            "condition": "When counting cards, When accessing language data, When combining cards and foreign_data tables, When filtering by German language, When filtering for reprinted cards",
            "operation": " use T1.isReprint = 1 instead of reprint = 1 to use the correct column name from the proper table."
        },
        "134": {
            "condition": "When counting cards",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "135": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T1.uuid = T2.uuid using an inner join and keep only matching pairs."
        },
        "136": {
            "condition": "When filtering for borderless cards",
            "operation": " use T1.borderColor = 'borderless' instead of border = 'borderless' to reference the correct column."
        },
        "137": {
            "condition": "When counting cards, When combining cards and foreign_data tables, When filtering for borderless cards, When filtering for Russian language",
            "operation": " use T2.language = 'Russian' instead of language = 'Russian' to reference the joined table's column."
        },
        "138": {
            "condition": "When answering about percentage of cards with French language among Story Spotlight cards",
            "operation": " make sure to join the foreign_data table as T2 using T1.uuid = T2.uuid for language information."
        },
        "139": {
            "condition": "When the question mentions \"language is French\"",
            "operation": " \"French\" actually means T2.language = 'French' with exact case and quotes."
        },
        "140": {
            "condition": "When the question mentions \"Story Spotlight cards\"",
            "operation": " this actually means T1.isStorySpotlight = 1 using the correct boolean value format."
        },
        "141": {
            "condition": "When calculating percentage",
            "operation": " use SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) divided by COUNT(T1.id) and multiply by 100.0 with explicit casting to REAL for precise division."
        },
        "142": {
            "condition": "When combining T1 (cards) and T2 (foreign_data)",
            "operation": " link rows where T1.uuid = T2.uuid exactly and keep only matching pairs (inner match)."
        },
        "143": {
            "condition": "When answering about percentage of cards with French language among Story Spotlight cards, When the question mentions \"language is French\", When the question mentions \"Story Spotlight cards\", When calculating percentage, When combining T1 (cards) and T2 (foreign_data), When producing output",
            "operation": " do not include any column alias for the percentage result."
        },
        "144": {
            "condition": "When the question asks for card names",
            "operation": " use the exact column \"name\" from the cards table instead of \"card_name\"."
        },
        "145": {
            "condition": "When filtering by artist Aaron Boyd",
            "operation": " use the exact column \"artist\" instead of \"illustrator\" while keeping the literal value 'Aaron Boyd' unchanged."
        },
        "146": {
            "condition": "When the question asks for card names, When filtering by artist Aaron Boyd, When retrieving card names",
            "operation": " ensure distinct values are returned to avoid duplicates."
        },
        "147": {
            "condition": "When counting cards",
            "operation": " use the exact column \"id\" instead of counting all columns to avoid counting null values."
        },
        "148": {
            "condition": "When filtering for black border cards",
            "operation": " use the exact column name \"borderColor\" with the exact literal value 'black' instead of 'border_color'."
        },
        "149": {
            "condition": "When filtering for MTGO availability",
            "operation": " use the exact condition \"availability = 'mtgo'\" and do not include redundant conditions like \"availability != 'paper'\" since 'mtgo' already excludes paper."
        },
        "150": {
            "condition": "When counting cards, When filtering for black border cards, When filtering for MTGO availability, When the question asks for cards \"only available on mtgo\"",
            "operation": " ensure the condition specifically checks for availability equal to 'mtgo' without additional redundant filters."
        },
        "151": {
            "condition": "When the question asks for \"card IDs\"",
            "operation": " use the exact column name \"id\" from the cards table to select the card identifiers."
        },
        "152": {
            "condition": "When the question asks for \"card IDs\", When filtering for cards with converted mana cost of 0",
            "operation": " use the exact column name \"convertedManaCost\" and the literal value 0.0 to match cards with zero converted mana cost."
        },
        "153": {
            "condition": "When the question asks for \"card layout of cards with keyword of flying\"",
            "operation": " select only the \"layout\" column instead of all columns."
        },
        "154": {
            "condition": "When the question mentions \"keyword\"",
            "operation": " the exact column name is \"keywords\" (not \"keyword\")."
        },
        "155": {
            "condition": "When the question asks for \"card layout of cards with keyword of flying\", When the question mentions \"keyword\", When filtering for cards with flying keyword",
            "operation": " use the exact string value 'Flying' (with proper capitalization) instead of 'flying'."
        },
        "156": {
            "condition": "When counting cards",
            "operation": " use COUNT(id) instead of COUNT(*) to count specific non-null values."
        },
        "157": {
            "condition": "When the question mentions \"original type\"",
            "operation": " \"original type\" actually means \"originalType\" in schema."
        },
        "158": {
            "condition": "When the question mentions \"subtype\"",
            "operation": " \"subtype\" actually means \"subtypes\" in schema."
        },
        "159": {
            "condition": "When filtering for cards with original type of \"Summon - Angel\"",
            "operation": " use originalType = 'Summon - Angel' exactly as specified."
        },
        "160": {
            "condition": "When counting cards, When the question mentions \"original type\", When the question mentions \"subtype\", When filtering for cards with original type of \"Summon - Angel\", When excluding Angel subtypes",
            "operation": " use subtypes != 'Angel' instead of equality to exclude rather than include Angel subtypes."
        },
        "161": {
            "condition": "When selecting card identifiers",
            "operation": " use \"id\" instead of \"card_id\" as the output column."
        },
        "162": {
            "condition": "When filtering for foiled cards that are incredibly powerful",
            "operation": " use \"cardKingdomId IS NOT NULL\" and \"cardKingdomFoilId IS NOT NULL\" conditions instead of \"foil_status = 'foiled'\" and \"power_level > 9000\"."
        },
        "163": {
            "condition": "When selecting card identifiers, When filtering for foiled cards that are incredibly powerful, When the question mentions pairing with non-foiled cards",
            "operation": " do not use an EXISTS subquery with foil_status correlation as this condition is not needed for the intended behavior."
        },
        "164": {
            "condition": "When the question asks for \"cards belong to duel deck a\"",
            "operation": " filter rows where \"duelDeck\" equals 'a' exactly."
        },
        "165": {
            "condition": "When the question asks for \"ID\" of cards",
            "operation": " select the \"id\" column from the cards table."
        },
        "166": {
            "condition": "When the question asks for \"cards belong to duel deck a\", When the question asks for \"ID\" of cards, When choosing column names",
            "operation": " use exact column name \"duelDeck\" (not \"duel_deck\") for filtering and \"id\" (not \"card_id\") for selection."
        },
        "167": {
            "condition": "When the question mentions \"frame version\"",
            "operation": " use the exact column name \"frameVersion\" from the cards table."
        },
        "168": {
            "condition": "When filtering on numeric values like 2015",
            "operation": " use the integer value 2015 without quotes for proper numeric comparison."
        },
        "169": {
            "condition": "When the question mentions \"frame version\", When filtering on numeric values like 2015, When answering about cards with frame version 2015",
            "operation": " make sure the output includes edhrecRank from the cards table."
        },
        "170": {
            "condition": "When answering about \"artists for cards in Chinese Simplified\"",
            "operation": " make sure the output order: T1.artist"
        },
        "171": {
            "condition": "When the question mentions \"Chinese Simplified\"",
            "operation": " \"Chinese Simplified\" actually means T2.language = 'Chinese Simplified' in schema"
        },
        "172": {
            "condition": "When combining T1 (cards) and T2 (foreign_data) for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "173": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "174": {
            "condition": "When answering about \"artists for cards in Chinese Simplified\", When the question mentions \"Chinese Simplified\", When combining T1 (cards) and T2 (foreign_data) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation from 'Chinese Simplified'"
        },
        "175": {
            "condition": "When answering about \"cards that only available in paper and Japanese language\"",
            "operation": " make sure the output order: T1.name."
        },
        "176": {
            "condition": "When the question mentions \"cards\"",
            "operation": " \"cards\" actually means \"T1 table\" in schema."
        },
        "177": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)."
        },
        "178": {
            "condition": "When filtering for availability",
            "operation": " use T1.availability = 'paper' exactly as specified."
        },
        "179": {
            "condition": "When answering about \"cards that only available in paper and Japanese language\", When the question mentions \"cards\", When combining T1 and T2 for shared entities, When filtering for availability, When filtering for language",
            "operation": " use T2.language = 'Japanese' exactly as specified, matching the exact case and spelling from the question."
        },
        "180": {
            "condition": "When answering about \"banned cards\"",
            "operation": " join cards AS T1 with legalities AS T2 using inner join where T1.uuid = T2.uuid to get proper banned status information."
        },
        "181": {
            "condition": "When counting banned cards",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "182": {
            "condition": "When filtering for banned cards",
            "operation": " use T2.status = 'Banned' instead of banned = 'yes' to use the proper status column and value."
        },
        "183": {
            "condition": "When filtering for white border cards",
            "operation": " use T1.borderColor = 'white' with the exact case and spelling as shown in the schema."
        },
        "184": {
            "condition": "When answering about \"banned cards\", When counting banned cards, When filtering for banned cards, When filtering for white border cards, When combining tables for banned status",
            "operation": " perform an inner match to keep only cards that have corresponding legalities entries with T1.uuid = T2.uuid."
        },
        "185": {
            "condition": "When answering about \"legacy cards\"",
            "operation": " use table \"cards\" as T1 and filter for format = 'legacy' from table \"legalities\" as T2."
        },
        "186": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid and T1.uuid = T3.uuid, keeping only matching pairs (inner match)."
        },
        "187": {
            "condition": "When retrieving foreign language information",
            "operation": " select T3.language from table \"foreign_data\" as T3 instead of from the base table."
        },
        "188": {
            "condition": "When the question asks for \"uuid for legacy cards\"",
            "operation": " select T1.uuid from the cards table."
        },
        "189": {
            "condition": "When answering about \"legacy cards\", When combining tables for shared entities, When retrieving foreign language information, When the question asks for \"uuid for legacy cards\", When the question asks for \"foreign language of these cards\"",
            "operation": " select T3.language from the foreign_data table."
        },
        "190": {
            "condition": "When answering about \"the ruling of Beacon of Immortality\"",
            "operation": " make sure the output order: T2.text"
        },
        "191": {
            "condition": "When the question mentions \"Beacon of Immortality\"",
            "operation": " \"Beacon of Immortality\" actually means T1.name = 'Beacon of Immortality' in schema"
        },
        "192": {
            "condition": "When combining T1 (cards) and T2 (rulings) for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)"
        },
        "193": {
            "condition": "When selecting columns",
            "operation": " do select only T2.text instead of all columns with *"
        },
        "194": {
            "condition": "When filtering",
            "operation": " do filter on T1.name = 'Beacon of Immortality' instead of filtering on both name and type"
        },
        "195": {
            "condition": "When answering about \"the ruling of Beacon of Immortality\", When the question mentions \"Beacon of Immortality\", When combining T1 (cards) and T2 (rulings) for shared entities, When selecting columns, When filtering, When filtering",
            "operation": " do remove the type = 'Instant' filter instead of keeping it"
        },
        "196": {
            "condition": "When counting cards",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "197": {
            "condition": "When incorporating legality data",
            "operation": " add INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid to properly join tables through the uuid key."
        },
        "198": {
            "condition": "When checking frame version",
            "operation": " reference T1.frameVersion instead of frame_version to use the correct column name with proper table alias."
        },
        "199": {
            "condition": "When the question asks for count without grouping by legality status",
            "operation": " remove GROUP BY legality_status and the legality_status column from the SELECT list."
        },
        "200": {
            "condition": "When counting cards, When incorporating legality data, When checking frame version, When the question asks for count without grouping by legality status, When producing count results",
            "operation": " omit the card_count alias since the count result doesn't require an alias in this context."
        },
        "201": {
            "condition": "When the question asks for cards from set \"OGW\"",
            "operation": " filter cards using a subquery that selects \"id\" from \"set_translations\" where \"setCode\" equals 'OGW' exactly."
        },
        "202": {
            "condition": "When selecting card information",
            "operation": " output \"id\" and \"colors\" columns instead of \"name\" and \"color\"."
        },
        "203": {
            "condition": "When the question asks for cards from set \"OGW\", When selecting card information, When combining card and set information",
            "operation": " use the \"id\" column from \"cards\" to match against the subquery results from \"set_translations\"."
        },
        "204": {
            "condition": "When answering about cards with specific converted mana cost and set",
            "operation": " use set_translations as the main table instead of joining cards and translations tables directly."
        },
        "205": {
            "condition": "When filtering for set '10E'",
            "operation": " use setCode = '10E' exactly as specified."
        },
        "206": {
            "condition": "When filtering for converted mana cost of 5",
            "operation": " use a subquery (SELECT id FROM cards WHERE convertedManaCost ="
        },
        "207": {
            "condition": "to correlate through the main query.",
            "operation": "to correlate through the main query."
        },
        "208": {
            "condition": "When selecting output columns",
            "operation": " return id and language instead of name and language."
        },
        "209": {
            "condition": "When answering about cards with specific converted mana cost and set, When filtering for set '10E', When filtering for converted mana cost of 5, to correlate through the main query., When selecting output columns, When handling identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for any identifiers."
        },
        "210": {
            "condition": "When answering about \"name of cards with original types of Creature - Elf and the date of rulings\"",
            "operation": " make sure the output order: T1.id, T2.date"
        },
        "211": {
            "condition": "When the question mentions \"name of cards\"",
            "operation": " \"name\" actually means \"T1.id in schema\""
        },
        "212": {
            "condition": "When the question mentions \"date of rulings\"",
            "operation": " \"date\" actually means \"T2.date in schema\""
        },
        "213": {
            "condition": "When combining T1 (cards) and T2 (rulings) for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "214": {
            "condition": "When answering about \"name of cards with original types of Creature - Elf and the date of rulings\", When the question mentions \"name of cards\", When the question mentions \"date of rulings\", When combining T1 (cards) and T2 (rulings) for shared entities, When filtering for cards with original type of Creature - Elf",
            "operation": " use T1.originalType = 'Creature - Elf' with exact case and spacing"
        },
        "215": {
            "condition": "When answering about card colors and formats for IDs 1-20",
            "operation": " make sure the output order: T1.colors, T2.format"
        },
        "216": {
            "condition": "When the question mentions \"colors\"",
            "operation": " \"colors\" actually means \"T1.colors in schema\""
        },
        "217": {
            "condition": "When the question mentions \"format\"",
            "operation": " \"format\" actually means \"T2.format in schema\""
        },
        "218": {
            "condition": "When combining cards and legalities tables",
            "operation": " link rows where T1.uuid = T2.uuid exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "219": {
            "condition": "When answering about card colors and formats for IDs 1-20, When the question mentions \"colors\", When the question mentions \"format\", When combining cards and legalities tables, When filtering by card IDs 1-20",
            "operation": " apply the condition T1.id BETWEEN 1 AND 20 to select only those specific records"
        },
        "220": {
            "condition": "When answering about \"Artifact cards\"",
            "operation": " make sure to filter using T1.originalType = 'Artifact' to identify artifact cards specifically."
        },
        "221": {
            "condition": "When the question mentions \"black color\"",
            "operation": " use T1.colors = 'B' to match the color coding convention for black."
        },
        "222": {
            "condition": "When the question mentions \"foreign language translation\"",
            "operation": " use the foreign_data table (T2) and join with T1 on T1.uuid = T2.uuid to access translation data."
        },
        "223": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid exactly and keep only matching pairs (inner match)."
        },
        "224": {
            "condition": "When answering about \"Artifact cards\", When the question mentions \"black color\", When the question mentions \"foreign language translation\", When combining T1 and T2 for shared entities, When selecting output",
            "operation": " use DISTINCT T1.name instead of all columns to return only unique card names."
        },
        "225": {
            "condition": "When the question asks for cards with rarity of 'uncommon'",
            "operation": " filter rows where T1.rarity equals exactly 'uncommon'."
        },
        "226": {
            "condition": "When combining cards and rulings tables",
            "operation": " link rows where T1.uuid equals T2.uuid and keep only matching pairs (inner match)."
        },
        "227": {
            "condition": "When the question asks for distinct card names",
            "operation": " ensure only unique values of T1.name are returned."
        },
        "228": {
            "condition": "When the question requires ascending order of ruling date",
            "operation": " sort results by T2.date in ascending order."
        },
        "229": {
            "condition": "When the question asks for top 3 cards",
            "operation": " keep only the first 3 rows after sorting."
        },
        "230": {
            "condition": "When the question asks for cards with rarity of 'uncommon', When combining cards and rulings tables, When the question asks for distinct card names, When the question requires ascending order of ruling date, When the question asks for top 3 cards, When producing output",
            "operation": " return T1.name as the result column."
        },
        "231": {
            "condition": "When the question asks about cards designed by John Avon",
            "operation": " filter the cards table where the artist column equals 'John Avon' exactly."
        },
        "232": {
            "condition": "When the question asks about cards with non-powerful foil",
            "operation": " check for missing marketplace identifiers using the condition (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) instead of foil_powerful."
        },
        "233": {
            "condition": "When counting cards",
            "operation": " use COUNT(id) to count specific non-null identifiers rather than COUNT(*) for all rows."
        },
        "234": {
            "condition": "When the question asks about cards designed by John Avon, When the question asks about cards with non-powerful foil, When counting cards, When handling designer information",
            "operation": " use the artist column directly in the cards table instead of joining to a separate designers table."
        },
        "235": {
            "condition": "When counting cards",
            "operation": " count using the canonical key \"id\" instead of all columns to avoid counting NULL values."
        },
        "236": {
            "condition": "When the question mentions \"white bordered cards\"",
            "operation": " \"white\" actually means \"borderColor\" = 'white' in the schema."
        },
        "237": {
            "condition": "When filtering for powerful cards",
            "operation": " add conditions \"cardKingdomId IS NOT NULL\" and \"cardKingdomFoilId IS NOT NULL\" instead of using a power filter."
        },
        "238": {
            "condition": "When counting cards, When the question mentions \"white bordered cards\", When filtering for powerful cards, When the question asks about \"powerful\" cards",
            "operation": " remove any power-related filters entirely as they are not part of the correct criteria."
        },
        "239": {
            "condition": "When counting cards",
            "operation": " count using the canonical key \"id\" instead of counting all columns."
        },
        "240": {
            "condition": "When the question mentions \"designed by UDON\"",
            "operation": " \"designed by\" actually means \"artist = 'UDON'\" in the schema."
        },
        "241": {
            "condition": "When the question mentions \"available in mtgo print type\"",
            "operation": " \"mtgo print type\" actually means \"Availability = 'mtgo'\" in the schema."
        },
        "242": {
            "condition": "When counting cards, When the question mentions \"designed by UDON\", When the question mentions \"available in mtgo print type\", When the question mentions \"starting maximum hand size of -1\"",
            "operation": " \"starting maximum hand size\" actually means \"hAND = '-1'\" in the schema."
        },
        "243": {
            "condition": "When counting cards",
            "operation": " count using the canonical key \"id\" instead of counting all columns to avoid null values."
        },
        "244": {
            "condition": "When filtering by frame version",
            "operation": " use column \"frameVersion\" with integer value 1993 instead of string '1993' for proper data type matching."
        },
        "245": {
            "condition": "When filtering by availability",
            "operation": " use column \"availability\" with string value 'paper' instead of boolean 1 to use the correct column name and value format."
        },
        "246": {
            "condition": "When counting cards, When filtering by frame version, When filtering by availability, When filtering for content warnings",
            "operation": " use column \"hasContentWarning\" with value 1 instead of 0 to properly identify cards with content warnings using the correct boolean logic."
        },
        "247": {
            "condition": "When the question asks for mana cost",
            "operation": " use column name \"manaCost\" instead of \"mana_cost\" to match the schema."
        },
        "248": {
            "condition": "When filtering for border color",
            "operation": " use column name \"borderColor\" instead of \"border_color\" and filter for exact value 'black'."
        },
        "249": {
            "condition": "When filtering for frame version",
            "operation": " use column name \"frameVersion\" instead of \"frame_version\" and filter for exact value '2003' without quotes."
        },
        "250": {
            "condition": "When filtering for availability in both paper and mtgo",
            "operation": " use filter \"availability = 'mtgo,paper'\" instead of OR conditions to handle comma-separated values properly."
        },
        "251": {
            "condition": "When the question asks for mana cost, When filtering for border color, When filtering for frame version, When filtering for availability in both paper and mtgo, When answering about cards with normal layout",
            "operation": " filter layout = 'normal' using exact string literal."
        },
        "252": {
            "condition": "When the question asks about \"mana cost\" of cards",
            "operation": " use the exact column token \"manaCost\" from the cards table to retrieve individual mana cost values."
        },
        "253": {
            "condition": "When the question mentions cards \"created by Rob Alexander\"",
            "operation": " filter using the exact condition \"artist = 'Rob Alexander'\" to match cards by this specific artist."
        },
        "254": {
            "condition": "When retrieving mana cost values",
            "operation": " do not apply aggregation functions like SUM() since the question asks for individual values rather than a total sum."
        },
        "255": {
            "condition": "When the question asks about \"mana cost\" of cards, When the question mentions cards \"created by Rob Alexander\", When retrieving mana cost values, When filtering for artist",
            "operation": " do not include additional conditions about converted mana cost being NULL, as the question includes all cards by the specified artist regardless of mana cost values."
        },
        "256": {
            "condition": "When selecting card types from the cards table",
            "operation": " return only the specific columns \"subtypes\" and \"supertypes\" instead of all columns."
        },
        "257": {
            "condition": "When listing all types of cards",
            "operation": " remove duplicate rows by using DISTINCT on the combination of \"subtypes\" and \"supertypes\"."
        },
        "258": {
            "condition": "When filtering for Arena availability",
            "operation": " use the column \"availability\" with the exact literal value 'arena' instead of filtering on column \"arena\"."
        },
        "259": {
            "condition": "When selecting card types from the cards table, When listing all types of cards, When filtering for Arena availability, When ensuring valid card type classifications",
            "operation": " add explicit filters for \"subtypes IS NOT NULL\" and \"supertypes IS NOT NULL\" to exclude null values."
        },
        "260": {
            "condition": "When answering about \"set code of all cards translated into Spanish\"",
            "operation": " select \"setCode\" from the \"set_translations\" table."
        },
        "261": {
            "condition": "When filtering for Spanish translations",
            "operation": " apply the condition language = 'Spanish' to the \"set_translations\" table."
        },
        "262": {
            "condition": "When answering about \"set code of all cards translated into Spanish\", When filtering for Spanish translations, When the question mentions \"translated into Spanish\"",
            "operation": " this means filtering for records where the language column equals 'Spanish' exactly as specified."
        },
        "263": {
            "condition": "When the question asks for percentage of legendary frame effect cards that are only available in online game variations",
            "operation": " use SUM(CASE WHEN isOnlineOnly = 1 THEN 1.0 ELSE 0 END) / COUNT(id) * 100 for the percentage calculation."
        },
        "264": {
            "condition": "When determining if a card is online-only",
            "operation": " reference column isOnlineOnly with boolean logic instead of parsing games with LIKE patterns."
        },
        "265": {
            "condition": "When counting total legendary cards for the denominator",
            "operation": " use COUNT(id) instead of conditional counting based on frame effect."
        },
        "266": {
            "condition": "When the question asks for percentage of legendary frame effect cards that are only available in online game variations, When determining if a card is online-only, When counting total legendary cards for the denominator, When filtering for legendary frame effect cards",
            "operation": " use WHERE frameEffects = 'legendary' with the exact column name 'frameEffects' and literal value 'legendary'."
        },
        "267": {
            "condition": "When the question asks for percentage of Story Spotlight cards that do not have a text box",
            "operation": " use boolean column \"isStorySpotlight\" = 1 to identify Story Spotlight cards instead of string column \"type\" = 'Story Spotlight'."
        },
        "268": {
            "condition": "When counting cards without text boxes",
            "operation": " use boolean column \"isTextless\" = 0 to identify non-textless cards instead of checking \"text IS NULL\"."
        },
        "269": {
            "condition": "When calculating percentage",
            "operation": " compute (SUM(CASE WHEN \"isTextless\" = 0 THEN 1 ELSE 0 END) * 100 / COUNT(\"id\")) with CAST to REAL for precise division instead of implicit casting with 100.0."
        },
        "270": {
            "condition": "When the question asks for overall percentage",
            "operation": " aggregate at the overall level without GROUP BY \"id\" instead of grouping by individual IDs."
        },
        "271": {
            "condition": "When the question asks for percentage of Story Spotlight cards that do not have a text box, When counting cards without text boxes, When calculating percentage, When the question asks for overall percentage, When combining conditions",
            "operation": " filter with WHERE \"isStorySpotlight\" = 1 instead of WHERE \"type\" = 'Story Spotlight' AND \"text IS NULL\"."
        },
        "272": {
            "condition": "When answering about percentage of cards in Spanish",
            "operation": " use the \"foreign_data\" table instead of the \"cards\" table."
        },
        "273": {
            "condition": "When calculating percentage",
            "operation": " use SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100 / COUNT(*) instead of COUNT(*) * 100 / subquery."
        },
        "274": {
            "condition": "When performing division",
            "operation": " cast the result as REAL to avoid integer division."
        },
        "275": {
            "condition": "When including name in results",
            "operation": " place \"name\" directly in the SELECT list without GROUP BY."
        },
        "276": {
            "condition": "When answering about percentage of cards in Spanish, When calculating percentage, When performing division, When including name in results, When filtering for Spanish language",
            "operation": " apply WHERE language = 'Spanish' to the main query instead of using conditional aggregates."
        },
        "277": {
            "condition": "When calculating percentages for a specific language condition",
            "operation": " compute SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) * 100 / COUNT(*) without decimal points in the multiplier."
        },
        "278": {
            "condition": "When casting percentage results",
            "operation": " cast only the SUM result as REAL instead of the entire percentage expression."
        },
        "279": {
            "condition": "When ordering output columns",
            "operation": " place the percentage calculation before the name column in the SELECT list."
        },
        "280": {
            "condition": "When calculating percentages for a specific language condition, When casting percentage results, When ordering output columns, When filtering for Spanish language records",
            "operation": " use the exact literal 'Spanish' with proper case and spelling."
        },
        "281": {
            "condition": "When answering about languages for sets with specific card counts",
            "operation": " use table aliases T1 for \"sets\" and T2 for \"set_translations\""
        },
        "282": {
            "condition": "When combining sets and set_translations tables",
            "operation": " link rows where T1.code equals T2.setCode using inner join"
        },
        "283": {
            "condition": "When filtering for sets with exactly 309 cards",
            "operation": " use condition T1.baseSetSize = 309"
        },
        "284": {
            "condition": "When answering about languages for sets with specific card counts, When combining sets and set_translations tables, When filtering for sets with exactly 309 cards, When selecting language information",
            "operation": " output T2.language instead of language_name"
        },
        "285": {
            "condition": "When counting translated sets",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific records."
        },
        "286": {
            "condition": "When the question mentions \"Brazilian Portuguese\"",
            "operation": " this actually means \"Portuguese (Brazil)\" in the schema, so use T2.language = 'Portuguese (Brazil)' exactly."
        },
        "287": {
            "condition": "When combining sets and set_translations tables",
            "operation": " link rows where T1.code = T2.setCode and keep only matching pairs (inner match)."
        },
        "288": {
            "condition": "When referencing the block column",
            "operation": " use T1.block to properly qualify the column from the joined table."
        },
        "289": {
            "condition": "When counting translated sets, When the question mentions \"Brazilian Portuguese\", When combining sets and set_translations tables, When referencing the block column, When answering about \"Commander block\"",
            "operation": " use T1.block = 'Commander' exactly as specified."
        },
        "290": {
            "condition": "When answering about \"Creature-type cards with legal status\"",
            "operation": " make sure the output order: T1.id"
        },
        "291": {
            "condition": "When the question mentions \"Creature-type cards\"",
            "operation": " \"Creature\" actually means \"T1.types = 'Creature'\" in schema"
        },
        "292": {
            "condition": "When the question mentions \"legal status\"",
            "operation": " \"legal\" actually means \"T3.status = 'Legal'\" in schema"
        },
        "293": {
            "condition": "When combining T1 (cards) and T2 (rulings) for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)"
        },
        "294": {
            "condition": "When combining T1 (cards) and T3 (legalities) for shared entities",
            "operation": " link rows where T1.uuid = T3.uuid and keep only matching pairs (inner match)"
        },
        "295": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "296": {
            "condition": "When answering about \"Creature-type cards with legal status\", When the question mentions \"Creature-type cards\", When the question mentions \"legal status\", When combining T1 (cards) and T2 (rulings) for shared entities, When combining T1 (cards) and T3 (legalities) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation (e.g., use 'Legal' not 'legal')"
        },
        "297": {
            "condition": "When answering about \"types of cards in German\"",
            "operation": " make sure the output order: T1.subtypes, T1.supertypes."
        },
        "298": {
            "condition": "When the question mentions \"German\"",
            "operation": " \"German\" actually means T2.language = 'German' in schema."
        },
        "299": {
            "condition": "When combining cards as T1 and foreign_data as T2",
            "operation": " link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)."
        },
        "300": {
            "condition": "When answering about \"types of cards in German\", When the question mentions \"German\", When combining cards as T1 and foreign_data as T2, When selecting card type information",
            "operation": " ensure T1.subtypes IS NOT NULL and T1.supertypes IS NOT NULL to exclude null values."
        },
        "301": {
            "condition": "When answering about \"unknown power cards\"",
            "operation": " include cards where T1.power IS NULL OR T1.power = '*' to cover both null and asterisk power values."
        },
        "302": {
            "condition": "When the question mentions \"contain info about the triggered ability\"",
            "operation": " search for '%triggered ability%' in T2.text rather than card text."
        },
        "303": {
            "condition": "When combining cards and rulings tables",
            "operation": " link rows where T1.uuid = T2.uuid using an inner match to find corresponding rulings for each card."
        },
        "304": {
            "condition": "When answering about \"unknown power cards\", When the question mentions \"contain info about the triggered ability\", When combining cards and rulings tables, When the question asks for actual ruling text",
            "operation": " return T2.text instead of counting results."
        },
        "305": {
            "condition": "When answering about cards with specific format and ruling text",
            "operation": " join the cards table (T1) with legalities table (T2) using T1.uuid = T2.uuid and with rulings table (T3) using T1.uuid = T3.uuid, keeping only matching rows from all three tables."
        },
        "306": {
            "condition": "When the question mentions \"pre-modern format\"",
            "operation": " use the exact literal 'premodern' (without hyphen) for T2.format comparison."
        },
        "307": {
            "condition": "When the question mentions ruling text \"This is a triggered mana ability.\"",
            "operation": " use the exact literal 'This is a triggered mana ability.' for T3.text comparison."
        },
        "308": {
            "condition": "When the question asks for cards that do not have multiple faces",
            "operation": " check that T1.Side IS NULL instead of using a multiple_faces column."
        },
        "309": {
            "condition": "When answering about cards with specific format and ruling text, When the question mentions \"pre-modern format\", When the question mentions ruling text \"This is a triggered mana ability.\", When the question asks for cards that do not have multiple faces, When counting cards",
            "operation": " count T1.id instead of using COUNT(*)."
        },
        "310": {
            "condition": "When answering about cards from a specific artist",
            "operation": " use T1.artist with the exact literal 'Erica Yang' to filter cards."
        },
        "311": {
            "condition": "When checking format legality",
            "operation": " join cards table T1 with legalities table T2 using T1.uuid = T2.uuid to ensure inner matching."
        },
        "312": {
            "condition": "When specifying format condition",
            "operation": " use T2.format with the exact literal 'pauper' instead of the cards table format."
        },
        "313": {
            "condition": "When checking availability",
            "operation": " use T1.availability with the exact literal 'paper' from the cards table."
        },
        "314": {
            "condition": "When answering about cards from a specific artist, When checking format legality, When specifying format condition, When checking availability, When selecting the card identifier",
            "operation": " output T1.id instead of card_id as the result column."
        },
        "315": {
            "condition": "When the question asks about cards from artist 'Erica Yang'",
            "operation": " filter rows where T1.artist equals 'Erica Yang' exactly."
        },
        "316": {
            "condition": "When the question specifies 'pauper format'",
            "operation": " filter rows where T2.format equals 'pauper' exactly."
        },
        "317": {
            "condition": "When the question asks about cards 'available in paper'",
            "operation": " filter rows where T1.availability equals 'paper' exactly (not pattern matching)."
        },
        "318": {
            "condition": "When combining cards and legalities tables",
            "operation": " link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)."
        },
        "319": {
            "condition": "When the question asks about cards from artist 'Erica Yang', When the question specifies 'pauper format', When the question asks about cards 'available in paper', When combining cards and legalities tables, When the question asks for card IDs",
            "operation": " output T1.id as the result."
        },
        "320": {
            "condition": "When the question asks about artist for a card with specific text",
            "operation": " use DISTINCT T1.artist to select unique artist values from the main table."
        },
        "321": {
            "condition": "When combining card information with foreign data",
            "operation": " perform an inner join between the main table and foreign_data AS T2 using T1.uuid = T2.uuid to link matching rows."
        },
        "322": {
            "condition": "When the question asks about artist for a card with specific text, When combining card information with foreign data, When searching for flavor text containing specific German text",
            "operation": " use T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%' to perform a case-insensitive partial string match instead of exact equality."
        },
        "323": {
            "condition": "When the question asks for \"foreign name of the card in French\"",
            "operation": " select \"name\" from the \"foreign_data\" table instead of \"foreign_name\" from the \"cards\" table."
        },
        "324": {
            "condition": "When filtering cards by type, layout, border color, and artist",
            "operation": " use a subquery to filter \"uuid\" values from the \"cards\" table with conditions on \"types\", \"layout\", \"borderColor\", and \"artist\"."
        },
        "325": {
            "condition": "When referencing card attributes",
            "operation": " use \"types\" instead of \"type\" and \"borderColor\" instead of \"border_color\" in the subquery predicates."
        },
        "326": {
            "condition": "When filtering for French language",
            "operation": " apply the \"language\" filter to the main query on \"foreign_data\" table instead of the \"cards\" table."
        },
        "327": {
            "condition": "When the question asks for \"foreign name of the card in French\", When filtering cards by type, layout, border color, and artist, When referencing card attributes, When filtering for French language, When joining cards and foreign_data tables",
            "operation": " link rows where the canonical keys match through the \"uuid\" relationship between the tables."
        },
        "328": {
            "condition": "When the question asks for \"type Creature\"",
            "operation": " use exact equality comparison with 'Creature' instead of partial string matching."
        },
        "329": {
            "condition": "When ordering WHERE clause conditions",
            "operation": " place language filters like 'language = \\\"French\\\"' at the end of the WHERE clause for consistent structure."
        },
        "330": {
            "condition": "When the question asks for \"type Creature\", When ordering WHERE clause conditions, When selecting columns",
            "operation": " do not use table aliases in the SELECT clause for cleaner syntax."
        },
        "331": {
            "condition": "When counting cards",
            "operation": " count distinct T1.id values rather than all rows."
        },
        "332": {
            "condition": "When joining cards and rulings tables",
            "operation": " use inner join with T1.uuid = T2.uuid to match on UUID columns."
        },
        "333": {
            "condition": "When filtering for print rarity",
            "operation": " use T1.rarity = 'rare' to specifically target rare cards."
        },
        "334": {
            "condition": "When filtering for ruling date",
            "operation": " use T2.date = '2007-02-01' to match the exact date value."
        },
        "335": {
            "condition": "When counting cards, When joining cards and rulings tables, When filtering for print rarity, When filtering for ruling date, When referring to tables",
            "operation": " use aliases T1 for cards and T2 for rulings consistently."
        },
        "336": {
            "condition": "When answering about language translations for card sets",
            "operation": " select T2.language from the set_translations table instead of language from the cards table."
        },
        "337": {
            "condition": "When combining sets and set_translations tables",
            "operation": " link rows where T1.code = T2.setCode and keep only matching pairs (inner match)."
        },
        "338": {
            "condition": "When filtering for the Ravnica block",
            "operation": " use T1.block = 'Ravnica' with exact case and quotes."
        },
        "339": {
            "condition": "When answering about language translations for card sets, When combining sets and set_translations tables, When filtering for the Ravnica block, When filtering for sets with 180 cards",
            "operation": " use T1.baseSetSize = 180 instead of card_count = 180."
        },
        "340": {
            "condition": "When the question asks about cards with format 'commander' and legal status",
            "operation": " join cards table as T1 with legalities table as T2 using T1.uuid = T2.uuid to combine card and legality information."
        },
        "341": {
            "condition": "When filtering for commander format",
            "operation": " use T2.format = 'commander' instead of filtering on the cards table."
        },
        "342": {
            "condition": "When filtering for legal status",
            "operation": " use T2.status = 'Legal' (with exact case) instead of legal_status = 'legal'."
        },
        "343": {
            "condition": "When counting cards without content warnings",
            "operation": " use SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) to properly handle boolean flags instead of checking for NULL values."
        },
        "344": {
            "condition": "When calculating percentages",
            "operation": " use CAST to REAL for proper decimal conversion instead of implicit conversion."
        },
        "345": {
            "condition": "When the question asks about cards with format 'commander' and legal status, When filtering for commander format, When filtering for legal status, When counting cards without content warnings, When calculating percentages, When counting total cards",
            "operation": " use T1.id as the counting key instead of COUNT(*) to ensure accurate row counting."
        },
        "346": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T1.uuid = T2.uuid using an inner join to keep only matching pairs."
        },
        "347": {
            "condition": "When identifying cards without power",
            "operation": " use the condition T1.power IS NULL OR T1.power = '*' instead of just checking for null values."
        },
        "348": {
            "condition": "When calculating percentage of French cards",
            "operation": " compute (number of French cards without power) divided by (total number of cards) using CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id)."
        },
        "349": {
            "condition": "When counting cards",
            "operation": " use T1.id as the counting key instead of counting all rows with COUNT(*)."
        },
        "350": {
            "condition": "When combining cards and foreign_data tables, When identifying cards without power, When calculating percentage of French cards, When counting cards, When handling French language cards",
            "operation": " use the exact literal 'French' for T2.language comparisons."
        },
        "351": {
            "condition": "When combining sets and set_translations tables",
            "operation": " link rows where T1.code = T2.setCode and keep only matching pairs (inner match)."
        },
        "352": {
            "condition": "When calculating percentage of Japanese translated expansion sets",
            "operation": " compute (number of Japanese translations for expansion sets) divided by (total number of expansion sets), guarding division by zero."
        },
        "353": {
            "condition": "When counting Japanese translations for expansion sets",
            "operation": " use SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) where T1.type = 'expansion'."
        },
        "354": {
            "condition": "When counting total expansion sets",
            "operation": " use COUNT(T1.id) where T1.type = 'expansion'."
        },
        "355": {
            "condition": "When handling division for percentages",
            "operation": " use explicit casting to REAL instead of implicit casting with 100.0."
        },
        "356": {
            "condition": "When filtering for Japanese language",
            "operation": " move the language filter to the CASE expression instead of the WHERE clause."
        },
        "357": {
            "condition": "When referring to expansion sets",
            "operation": " use T1.type = 'expansion' exactly as specified."
        },
        "358": {
            "condition": "When combining sets and set_translations tables, When calculating percentage of Japanese translated expansion sets, When counting Japanese translations for expansion sets, When counting total expansion sets, When handling division for percentages, When filtering for Japanese language, When referring to expansion sets, When referring to Japanese language",
            "operation": " use T2.language = 'Japanese' exactly as specified with the exact case and quotes."
        },
        "359": {
            "condition": "When the question asks about \"printing\" on a card",
            "operation": " \"printing\" actually means \"availability\" in the schema."
        },
        "360": {
            "condition": "When the question mentions \"Daren Bader created\"",
            "operation": " \"created\" actually means \"artist = 'Daren Bader'\" in the schema."
        },
        "361": {
            "condition": "When the question asks about \"printing\" on a card, When the question mentions \"Daren Bader created\", When retrieving values for a specific artist",
            "operation": " use DISTINCT to get unique values only."
        },
        "362": {
            "condition": "When counting cards",
            "operation": " count using the canonical key \"id\" instead of counting all rows to avoid null values."
        },
        "363": {
            "condition": "When the question mentions \"ranked higher than 12000 on EDHRec\"",
            "operation": " use the exact column \"edhrecRank\" with comparison > 12000."
        },
        "364": {
            "condition": "When the question mentions \"no borders\"",
            "operation": " use the exact condition \"borderColor = 'borderless'\" with the literal value 'borderless'."
        },
        "365": {
            "condition": "When counting cards, When the question mentions \"ranked higher than 12000 on EDHRec\", When the question mentions \"no borders\", When the question mentions \"color cards\"",
            "operation": " do not include any filter on color columns as the question does not specify a particular color."
        },
        "366": {
            "condition": "When counting cards",
            "operation": " use COUNT(id) instead of COUNT(*) to count specific non-null values."
        },
        "367": {
            "condition": "When checking if a card is oversized",
            "operation": " use column \"isOversized\" = 1 instead of \"is_oversized\"."
        },
        "368": {
            "condition": "When checking if a card is reprinted",
            "operation": " use column \"isReprint\" = 1 instead of \"is_reprinted\"."
        },
        "369": {
            "condition": "When counting cards, When checking if a card is oversized, When checking if a card is reprinted, When checking if a card is printed for promotions",
            "operation": " use column \"isPromo\" = 1 instead of \"is_promotional\"."
        },
        "370": {
            "condition": "When answering about \"top three unknown power cards that have promotional types for arena league\"",
            "operation": " make sure the output order: \"name\" in alphabetical order."
        },
        "371": {
            "condition": "When the question mentions \"unknown power cards\"",
            "operation": " \"unknown power\" actually means \"(power IS NULL OR power LIKE '%*%')\" in schema."
        },
        "372": {
            "condition": "When the question mentions \"promotional types for arena league\"",
            "operation": " \"arena league\" actually means \"promoTypes = 'arenaleague'\" in schema."
        },
        "373": {
            "condition": "When the question asks for \"top three\"",
            "operation": " rank rows by alphabetical order of \"name\" and keep the first 3 rows."
        },
        "374": {
            "condition": "When answering about \"top three unknown power cards that have promotional types for arena league\", When the question mentions \"unknown power cards\", When the question mentions \"promotional types for arena league\", When the question asks for \"top three\", When querying the database",
            "operation": " use the \"cards\" table instead of \"power_cards\" table."
        },
        "375": {
            "condition": "When answering about \"top three unknown power cards that have promotional types for arena league in alphabetical order\"",
            "operation": " make sure the output order: name only."
        },
        "376": {
            "condition": "When filtering for unknown power",
            "operation": " use condition (power IS NULL OR power LIKE '%*%') to identify cards with unknown power values."
        },
        "377": {
            "condition": "When filtering for arena league promotional types",
            "operation": " use condition promoTypes = 'arenaleague' exactly as specified."
        },
        "378": {
            "condition": "When combining filtering conditions",
            "operation": " apply both (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' in that order."
        },
        "379": {
            "condition": "When ordering results alphabetically",
            "operation": " sort by name in ascending order (default, no need to specify ASC)."
        },
        "380": {
            "condition": "When answering about \"top three unknown power cards that have promotional types for arena league in alphabetical order\", When filtering for unknown power, When filtering for arena league promotional types, When combining filtering conditions, When ordering results alphabetically, When limiting to top three results",
            "operation": " take the first 3 rows after sorting."
        },
        "381": {
            "condition": "When answering about the language of a card with a specific multiverse number",
            "operation": " query the \"foreign_data\" table instead of the \"cards\" table."
        },
        "382": {
            "condition": "When the question mentions \"multiverse number\"",
            "operation": " use the column name \"multiverseid\" (without quotes) instead of \"multiverse_id\"."
        },
        "383": {
            "condition": "When answering about the language of a card with a specific multiverse number, When the question mentions \"multiverse number\", When searching for a numeric multiverseid value like \"149934\"",
            "operation": " use the numeric value 149934 without quotes instead of treating it as a string."
        },
        "384": {
            "condition": "When answering about \"top three powerful pairs of Kingdom Foil and Kingdom Cards\"",
            "operation": " select the exact columns \"cardKingdomFoilId\" and \"cardKingdomId\" from the \"cards\" table."
        },
        "385": {
            "condition": "When filtering for valid pairs",
            "operation": " ensure both \"cardKingdomFoilId IS NOT NULL\" and \"cardKingdomId IS NOT NULL\" to exclude null values."
        },
        "386": {
            "condition": "When ordering results alphabetically by Kingdom Foil id",
            "operation": " sort by \"cardKingdomFoilId\" in ascending order."
        },
        "387": {
            "condition": "When answering about \"top three powerful pairs of Kingdom Foil and Kingdom Cards\", When filtering for valid pairs, When ordering results alphabetically by Kingdom Foil id, When limiting to top three results",
            "operation": " keep only the first 3 rows after ordering."
        },
        "388": {
            "condition": "When the question asks for proportion of cards without a text box with normal layout",
            "operation": " use the exact condition where \"isTextless\" = 1 and \"layout\" = 'normal' instead of just checking layout."
        },
        "389": {
            "condition": "When calculating proportion as a percentage",
            "operation": " multiply the ratio by 100 instead of keeping it as a decimal fraction."
        },
        "390": {
            "condition": "When performing division to calculate proportion",
            "operation": " cast the numerator to REAL type to avoid integer division."
        },
        "391": {
            "condition": "When counting cards that meet specific conditions",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(*) with WHERE filter."
        },
        "392": {
            "condition": "When referencing layout information",
            "operation": " use the exact column name \"layout\" instead of \"text_box_layout\"."
        },
        "393": {
            "condition": "When the question asks for proportion of cards without a text box with normal layout, When calculating proportion as a percentage, When performing division to calculate proportion, When counting cards that meet specific conditions, When referencing layout information, When calculating the denominator for proportion",
            "operation": " use COUNT(*) from the main query scope instead of a subquery."
        },
        "394": {
            "condition": "When selecting card identifiers from the cards table",
            "operation": " use the exact column name \"id\" instead of \"card_number\"."
        },
        "395": {
            "condition": "When filtering for cards with both Angel and Wizard subtypes",
            "operation": " use exact equality comparison subtypes = 'Angel,Wizard' instead of multiple LIKE conditions."
        },
        "396": {
            "condition": "When filtering for cards without multiple faces",
            "operation": " include the condition side IS NULL to ensure single-face cards."
        },
        "397": {
            "condition": "When selecting card identifiers from the cards table, When filtering for cards with both Angel and Wizard subtypes, When filtering for cards without multiple faces, When the question asks for cards that don't have multiple faces",
            "operation": " do not use unnecessary GROUP BY and HAVING COUNT(*) = 1 aggregation - simple filtering with side IS NULL is sufficient."
        },
        "398": {
            "condition": "When filtering for sets that don't appear in Magic",
            "operation": " The Gathering Online: use the condition \"mtgoCode IS NULL\" instead of checking online status."
        },
        "399": {
            "condition": "When ordering set names alphabetically",
            "operation": " order by the \"name\" column without specifying ASC direction (default ascending order)."
        },
        "400": {
            "condition": "When filtering for sets that don't appear in Magic, When ordering set names alphabetically, When retrieving the top three sets",
            "operation": " limit the results to exactly 3 rows after applying all filters and ordering."
        },
        "401": {
            "condition": "When answering about languages available in a set",
            "operation": " use the set_translations table (T2) to access language information instead of the cards table."
        },
        "402": {
            "condition": "When combining set information with translations",
            "operation": " join sets AS T1 and set_translations AS T2 using T1.code = T2.setCode with an inner match."
        },
        "403": {
            "condition": "When filtering for the set known as Archenemy on the magic card market",
            "operation": " use T1.mcmName = 'Archenemy' instead of set_name = 'Archenemy'."
        },
        "404": {
            "condition": "When filtering for set code 'ARC'",
            "operation": " use T2.setCode = 'ARC' with proper table qualification."
        },
        "405": {
            "condition": "When selecting languages",
            "operation": " use T2.language instead of unqualified language."
        },
        "406": {
            "condition": "When answering about languages available in a set, When combining set information with translations, When filtering for the set known as Archenemy on the magic card market, When filtering for set code 'ARC', When selecting languages, When the join and filters ensure uniqueness",
            "operation": " do not use DISTINCT as it is redundant."
        },
        "407": {
            "condition": "When answering about \"set number 5 and its translation\"",
            "operation": " make sure the output order: T1.name, T2.translation."
        },
        "408": {
            "condition": "When the question mentions \"set number 5\"",
            "operation": " \"set number 5\" actually means \"T2.id = 5\" in schema."
        },
        "409": {
            "condition": "When combining T1 (sets) and T2 (set_translations) for shared entities",
            "operation": " link rows where T1.code = T2.setCode exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "410": {
            "condition": "When the question asks for \"name of set\" and \"translation\"",
            "operation": " use T1.name for the set name and T2.translation for the translation."
        },
        "411": {
            "condition": "When answering about \"set number 5 and its translation\", When the question mentions \"set number 5\", When combining T1 (sets) and T2 (set_translations) for shared entities, When the question asks for \"name of set\" and \"translation\", When grouping results",
            "operation": " organize results by T1.name and T2.translation to ensure proper aggregation."
        },
        "412": {
            "condition": "When answering about \"language and expansion type of set number 206\"",
            "operation": " make sure the output order: T2.language, T1.type."
        },
        "413": {
            "condition": "When the question mentions \"set number 206\"",
            "operation": " \"set number 206\" actually means \"T2.id = 206\" in schema."
        },
        "414": {
            "condition": "When combining T1 (sets) and T2 (set_translations) for shared entities",
            "operation": " link rows where T1.code = T2.setCode exactly as shown; keep only matching pairs (inner match)."
        },
        "415": {
            "condition": "When answering about \"language and expansion type of set number 206\", When the question mentions \"set number 206\", When combining T1 (sets) and T2 (set_translations) for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "416": {
            "condition": "When answering about \"top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block\"",
            "operation": " make sure the output order: T1.name, T1.id"
        },
        "417": {
            "condition": "When the question mentions \"Italian-language cards\"",
            "operation": " \"Italian\" actually means T2.language = 'Italian' in schema"
        },
        "418": {
            "condition": "When the question mentions \"located in the Shadowmoor block\"",
            "operation": " \"Shadowmoor\" actually means T1.block = 'Shadowmoor' in schema"
        },
        "419": {
            "condition": "When combining sets AS T1 and set_translations AS T2 for shared entities",
            "operation": " link rows where T1.code = T2.setCode exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "420": {
            "condition": "When the question asks for \"top two sets\"",
            "operation": " rank rows by T1.id in alphabetical order and keep the first 2 rows"
        },
        "421": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "422": {
            "condition": "When answering about \"top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block\", When the question mentions \"Italian-language cards\", When the question mentions \"located in the Shadowmoor block\", When combining sets AS T1 and set_translations AS T2 for shared entities, When the question asks for \"top two sets\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Italian' or 'Shadowmoor'"
        },
        "423": {
            "condition": "When answering about sets not available outside the United States with Japanese foil cards",
            "operation": " make sure the output order includes both T1.name and T1.id."
        },
        "424": {
            "condition": "When the question mentions \"foil cards with Japanese writing\"",
            "operation": " \"foil cards\" actually means \"T1.isFoilOnly = 1\" in schema and \"Japanese writing\" actually means \"T2.language = 'Japanese'\" in schema."
        },
        "425": {
            "condition": "When the question mentions \"not available outside of the United States\"",
            "operation": " this actually means \"T1.isForeignOnly = 0\" in schema."
        },
        "426": {
            "condition": "When answering about sets not available outside the United States with Japanese foil cards, When the question mentions \"foil cards with Japanese writing\", When the question mentions \"not available outside of the United States\", When combining T1 (sets) and T2 (set_translations) for shared entities",
            "operation": " link rows where T1.code = T2.setCode exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "427": {
            "condition": "When answering about \"Russian set of cards\"",
            "operation": " use tables \"sets\" as T1 and \"set_translations\" as T2 with inner join condition T1.code = T2.setCode."
        },
        "428": {
            "condition": "When filtering for Russian language",
            "operation": " apply exact literal filter T2.language = 'Russian'."
        },
        "429": {
            "condition": "When counting cards in a set",
            "operation": " use T1.baseSetSize instead of counting individual cards."
        },
        "430": {
            "condition": "When ordering by card count",
            "operation": " order by T1.baseSetSize in descending direction."
        },
        "431": {
            "condition": "When answering about \"Russian set of cards\", When filtering for Russian language, When counting cards in a set, When ordering by card count, When selecting output",
            "operation": " return T1.id as the set identifier."
        },
        "432": {
            "condition": "When calculating percentages with conditional counting",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for proper conditional aggregation."
        },
        "433": {
            "condition": "When referencing language information",
            "operation": " use T2.language instead of language to match the correct table alias from the join."
        },
        "434": {
            "condition": "When referencing online-only status",
            "operation": " use T1.isOnlineOnly instead of online_only to match the correct table alias and column name."
        },
        "435": {
            "condition": "When performing floating-point division",
            "operation": " use explicit CAST(... AS REAL) instead of implicit decimal conversion to ensure proper numeric precision."
        },
        "436": {
            "condition": "When combining set information with translations",
            "operation": " join sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode instead of querying a single table to establish the correct relationship between sets and their translations."
        },
        "437": {
            "condition": "When calculating percentages with conditional counting, When referencing language information, When referencing online-only status, When performing floating-point division, When combining set information with translations, When filtering for specific conditions within aggregate calculations",
            "operation": " handle the condition within the CASE expression instead of using a WHERE clause to avoid prematurely filtering the dataset."
        },
        "438": {
            "condition": "When counting sets",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific records."
        },
        "439": {
            "condition": "When the question mentions \"Japanese\"",
            "operation": " filter on T2.language = 'Japanese' exactly as written."
        },
        "440": {
            "condition": "When identifying sets not in Magic",
            "operation": " The Gathering Online: use (T1.mtgoCode IS NULL OR T1.mtgoCode = '') instead of online_only = 0."
        },
        "441": {
            "condition": "When counting sets, When the question mentions \"Japanese\", When identifying sets not in Magic, When combining set data with translation data",
            "operation": " perform an INNER JOIN between T1 (sets) and T2 (set_translations) where T2.setCode = T1.code to link translations to their corresponding sets."
        },
        "442": {
            "condition": "When selecting card identifiers from the cards table",
            "operation": " use the exact column name \"id\" instead of \"card_id\"."
        },
        "443": {
            "condition": "When filtering cards by border color",
            "operation": " use the exact column name \"borderColor\" instead of \"border_color\"."
        },
        "444": {
            "condition": "When the question asks for card border with black color",
            "operation": " use the exact literal value 'black' for the borderColor filter condition."
        },
        "445": {
            "condition": "When selecting card identifiers from the cards table, When filtering cards by border color, When the question asks for card border with black color, When grouping results from the cards table",
            "operation": " include a grouping by the \"id\" column to ensure proper aggregation."
        },
        "446": {
            "condition": "When the question asks for \"id of those cards\"",
            "operation": " select the exact column \"id\" from table \"cards\" instead of using COUNT(*)."
        },
        "447": {
            "condition": "When the question mentions \"frame effect as extendedart\"",
            "operation": " the exact literal value to match is 'extendedart' and the correct column name is \"frameEffects\" (not \"frame_effect\")."
        },
        "448": {
            "condition": "When the question asks for \"id of those cards\", When the question mentions \"frame effect as extendedart\", When returning individual identifiers for cards with specific frame effects",
            "operation": " ensure proper grouping by including GROUP BY \"id\" to return distinct card IDs."
        },
        "449": {
            "condition": "When selecting columns from the cards table",
            "operation": " choose only the \"id\" column instead of all columns."
        },
        "450": {
            "condition": "When filtering for black border cards",
            "operation": " use the exact column name \"borderColor\" with literal value 'black'."
        },
        "451": {
            "condition": "When selecting columns from the cards table, When filtering for black border cards, When filtering for full artwork cards",
            "operation": " use the exact column name \"isFullArt\" with integer value 1 instead of text value 'full'."
        },
        "452": {
            "condition": "When answering about language data for a set id",
            "operation": " query the \"set_translations\" table instead of the \"sets\" table."
        },
        "453": {
            "condition": "When comparing set id values",
            "operation": " use numeric comparison with value 174 instead of string literal '174'."
        },
        "454": {
            "condition": "When answering about language data for a set id, When comparing set id values, When retrieving language information",
            "operation": " select the \"language\" column from the \"set_translations\" table."
        },
        "455": {
            "condition": "When the question asks for \"set name\" of a set code",
            "operation": " use column \"name\" from table sets instead of \"set_name\"."
        },
        "456": {
            "condition": "When the question asks for \"set name\" of a set code, When filtering by set code value \"ALL\"",
            "operation": " use column \"code\" from table sets instead of \"set_code\" and match the exact literal value 'ALL'."
        },
        "457": {
            "condition": "When the question asks about foreign language usage by a specific artist",
            "operation": " query the \"foreign_data\" table instead of the \"artists\" table."
        },
        "458": {
            "condition": "When retrieving language values for a specific artist",
            "operation": " use DISTINCT to return only unique language values and avoid duplicates."
        },
        "459": {
            "condition": "When the question asks about foreign language usage by a specific artist, When retrieving language values for a specific artist, When filtering for a specific artist name",
            "operation": " use the exact literal 'A Pedra Fellwar' with the condition name = 'A Pedra Fellwar' to identify the correct record."
        },
        "460": {
            "condition": "When querying for set codes with a specific release date",
            "operation": " join set_translations as T2 on T2.setCode = T1.code instead of querying only the sets table."
        },
        "461": {
            "condition": "When selecting the set code",
            "operation": " select T2.setCode instead of set_code from the original table."
        },
        "462": {
            "condition": "When referencing the sets table",
            "operation": " use table alias T1 instead of referencing it directly."
        },
        "463": {
            "condition": "When querying for set codes with a specific release date, When selecting the set code, When referencing the sets table, When filtering by release date",
            "operation": " reference T1.releaseDate instead of release_date to match the joined table structure."
        },
        "464": {
            "condition": "When filtering by date '07/13/2007' from the question",
            "operation": " use the exact date format '2007-07-13' instead of '07/13/2007'."
        },
        "465": {
            "condition": "When filtering by date '07/13/2007' from the question, When joining tables sets and set_translations",
            "operation": " explicitly specify INNER JOIN instead of just JOIN to maintain the same join logic and result behavior."
        },
        "466": {
            "condition": "When the question asks for \"base set size and set code\"",
            "operation": " use the exact column tokens \"T1.baseSetSize\" and \"T2.setCode\" instead of \"base_set_size\" and \"set_code\"."
        },
        "467": {
            "condition": "When the question mentions sets in blocks named \"Masques\" and \"Mirage\"",
            "operation": " filter using \"T1.block IN ('Masques', 'Mirage')\" instead of contradictory equality conditions."
        },
        "468": {
            "condition": "When combining set information with translation data",
            "operation": " perform an inner join between \"sets\" as T1 and \"set_translations\" as T2 where \"T2.setCode = T1.code\"."
        },
        "469": {
            "condition": "When selecting from multiple tables",
            "operation": " use table aliases T1 for the \"sets\" table and T2 for the \"set_translations\" table."
        },
        "470": {
            "condition": "When the question asks for \"base set size and set code\", When the question mentions sets in blocks named \"Masques\" and \"Mirage\", When combining set information with translation data, When selecting from multiple tables, When retrieving set information",
            "operation": " include DISTINCT to eliminate duplicate rows from the result set."
        },
        "471": {
            "condition": "When the question asks for \"code of sets\"",
            "operation": " use \"T2.setCode\" instead of \"code\" from the sets table."
        },
        "472": {
            "condition": "When combining sets and set_translations tables",
            "operation": " link rows where \"T2.setCode = T1.code\" and keep only matching pairs (inner match)."
        },
        "473": {
            "condition": "When filtering for expansion type",
            "operation": " use \"T1.type = 'expansion'\" instead of \"expansion_type = 'expansion'\"."
        },
        "474": {
            "condition": "When the question asks for \"code of sets\", When combining sets and set_translations tables, When filtering for expansion type, When grouping results",
            "operation": " organize by \"T2.setCode\" to return unique set codes instead of individual records."
        },
        "475": {
            "condition": "When the question asks for \"foreign name of the card\"",
            "operation": " select T1.name from the cards table instead of foreign_name."
        },
        "476": {
            "condition": "When the question asks for \"type of this card\"",
            "operation": " select T1.type from the cards table with explicit table qualification."
        },
        "477": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T2.uuid = T1.uuid using an inner match."
        },
        "478": {
            "condition": "When filtering for \"boros watermark\"",
            "operation": " use the exact literal 'boros' with the qualified column T1.watermark."
        },
        "479": {
            "condition": "When the question asks for \"foreign name of the card\", When the question asks for \"type of this card\", When combining cards and foreign_data tables, When filtering for \"boros watermark\", When eliminating duplicate rows",
            "operation": " use DISTINCT to return only unique combinations of T1.name and T1.type."
        },
        "480": {
            "condition": "When selecting attributes for cards with specific watermarks",
            "operation": " use columns from the cards table (T1.name and T1.type) rather than from joined foreign_data table (T2.name and T2.type)."
        },
        "481": {
            "condition": "When the question asks for \"foreign name\" and \"type\" of cards",
            "operation": " these attributes are stored in the cards table itself, not in the foreign_data table."
        },
        "482": {
            "condition": "When selecting attributes for cards with specific watermarks, When the question asks for \"foreign name\" and \"type\" of cards, When filtering cards by watermark",
            "operation": " use the exact literal 'boros' with the correct case and spelling as shown in the schema."
        },
        "483": {
            "condition": "When the question asks for \"language and flavor text of the card\"",
            "operation": " select T2.language and T2.flavorText from the foreign_data table instead of language and flavor_text from the cards table."
        },
        "484": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match)."
        },
        "485": {
            "condition": "When filtering for cards with colorpie watermark",
            "operation": " use T1.watermark = 'colorpie' with exact literal 'colorpie'."
        },
        "486": {
            "condition": "When eliminating duplicate results",
            "operation": " use DISTINCT to return only unique combinations of language and flavorText."
        },
        "487": {
            "condition": "When the question asks for \"language and flavor text of the card\", When combining cards and foreign_data tables, When filtering for cards with colorpie watermark, When eliminating duplicate results, When the question mentions \"type of this card\"",
            "operation": " do not include the type column in the output as it's not requested in the final result."
        },
        "488": {
            "condition": "When calculating percentage of cards with converted mana cost 10 in a specific set",
            "operation": " use CAST(SUM(CASE WHEN convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) instead of COUNT(*) * 100.0 / subquery."
        },
        "489": {
            "condition": "When joining cards and sets tables",
            "operation": " use INNER JOIN sets AS T2 ON T2.code = T1.setCode to properly link the tables."
        },
        "490": {
            "condition": "When filtering by set name 'Abyssal Horror'",
            "operation": " use T1.name = 'Abyssal Horror' instead of set_name = 'Abyssal Horror' to reference the correct column."
        },
        "491": {
            "condition": "When selecting output columns",
            "operation": " include T1.name in the SELECT list."
        },
        "492": {
            "condition": "When calculating percentage of cards with converted mana cost 10 in a specific set, When joining cards and sets tables, When filtering by set name 'Abyssal Horror', When selecting output columns, When referencing converted mana cost column",
            "operation": " use convertedManaCost instead of converted_mana_cost for the correct column name."
        },
        "493": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror",
            "operation": " make sure the output order: T1.name, percentage"
        },
        "494": {
            "condition": "When the question mentions \"Abyssal Horror\"",
            "operation": " \"Abyssal Horror\" actually means T1.name = 'Abyssal Horror' in the cards table"
        },
        "495": {
            "condition": "When calculating percentage of cards with convertedManaCost = 10",
            "operation": " compute (number of rows where T1.convertedManaCost ="
        },
        "496": {
            "condition": "divided by (total number of rows where T1.name = 'Abyssal Horror'), guarding division by zero",
            "operation": "divided by (total number of rows where T1.name = 'Abyssal Horror'), guarding division by zero"
        },
        "497": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror, When the question mentions \"Abyssal Horror\", When calculating percentage of cards with convertedManaCost = 10, divided by (total number of rows where T1.name = 'Abyssal Horror'), guarding division by zero, When selecting columns",
            "operation": " include T1.name in the output to identify the card being analyzed"
        },
        "498": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror",
            "operation": " make sure the output order starts with the aggregate expression first instead of T1.name."
        },
        "499": {
            "condition": "When counting cards",
            "operation": " use T1.id as the counting key instead of unqualified id."
        },
        "500": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror, When counting cards, When the WHERE filter T1.name = 'Abyssal Horror' already restricts to a single name value",
            "operation": " do not include an explicit GROUP BY clause as it becomes redundant."
        },
        "501": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror",
            "operation": " make sure the output order includes T1.name as the first column."
        },
        "502": {
            "condition": "When combining cards table T1 and sets table T2",
            "operation": " link rows where T2.code = T1.setCode and keep only matching pairs (inner match)."
        },
        "503": {
            "condition": "When qualifying column references",
            "operation": " always use T1.convertedManaCost instead of unqualified convertedManaCost."
        },
        "504": {
            "condition": "When the question asks for percentage of cards with converted Mana Cost of 10",
            "operation": " compute (number of rows where T1.convertedManaCost ="
        },
        "505": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror, When combining cards table T1 and sets table T2, When qualifying column references, When the question asks for percentage of cards with converted Mana Cost of 10, divided by (total number of rows) multiplied by 100, using T1.id as the counting key.",
            "operation": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror, When combining cards table T1 and sets table T2, When qualifying column references, When the question asks for percentage of cards with converted Mana Cost of 10, divided by (total number of rows) multiplied by 100, using T1.id as the counting key."
        },
        "506": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror",
            "operation": " make sure the output order is percentage calculation first, then T1.name at the end."
        },
        "507": {
            "condition": "When combining cards table T1 and sets table T2",
            "operation": " link rows where T2.code = T1.setCode and keep only matching pairs (inner match)."
        },
        "508": {
            "condition": "When filtering for the set of Abyssal Horror",
            "operation": " use exact literal 'Abyssal Horror' for T1.name condition."
        },
        "509": {
            "condition": "When calculating percentage of cards with converted Mana Cost of 10",
            "operation": " compute (number of rows where T1.convertedManaCost ="
        },
        "510": {
            "condition": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror, When combining cards table T1 and sets table T2, When filtering for the set of Abyssal Horror, When calculating percentage of cards with converted Mana Cost of 10, divided by (total number of rows using T1.id as counting key), then multiply by 100.",
            "operation": "When answering about percentage of cards with converted Mana Cost of 10 in set of Abyssal Horror, When combining cards table T1 and sets table T2, When filtering for the set of Abyssal Horror, When calculating percentage of cards with converted Mana Cost of 10, divided by (total number of rows using T1.id as counting key), then multiply by 100."
        },
        "511": {
            "condition": "When answering about \"code of sets with expansion commander type\"",
            "operation": " make sure the output order: T2.setCode."
        },
        "512": {
            "condition": "When the question mentions \"sets\"",
            "operation": " combine tables \"sets AS T1\" with \"set_translations AS T2\" using inner match where T2.setCode = T1.code."
        },
        "513": {
            "condition": "When filtering for commander type sets",
            "operation": " use T1.type = 'commander' instead of type = 'expansion' AND commander = 'true'."
        },
        "514": {
            "condition": "When answering about \"code of sets with expansion commander type\", When the question mentions \"sets\", When filtering for commander type sets, When selecting the set code",
            "operation": " use T2.setCode instead of code from the sets table."
        },
        "515": {
            "condition": "When the question asks for \"foreign name\" of a card",
            "operation": " use \"T2.name\" from the foreign_data table instead of \"foreign_name\" from the cards table."
        },
        "516": {
            "condition": "When joining cards and foreign_data tables",
            "operation": " link rows where \"T2.uuid = T1.uuid\" and keep only matching pairs (inner match)."
        },
        "517": {
            "condition": "When filtering by watermark",
            "operation": " use the exact token \"T1.watermark\" with the literal value 'abzan' exactly as specified."
        },
        "518": {
            "condition": "When selecting results",
            "operation": " use DISTINCT to return unique rows only."
        },
        "519": {
            "condition": "When the question asks for \"foreign name\" of a card, When joining cards and foreign_data tables, When filtering by watermark, When selecting results, When outputting columns",
            "operation": " return \"T2.name\" (foreign name) first, then \"T1.type\" (card type) second, in that exact order."
        },
        "520": {
            "condition": "When the question asks for the foreign name and type of a card",
            "operation": " select T1.name and T1.type from the cards table instead of T2.name and T2.type from foreign_data table."
        },
        "521": {
            "condition": "When joining cards (T1) and foreign_data (T2) tables",
            "operation": " use INNER JOIN on T2.uuid = T1.uuid to link matching rows."
        },
        "522": {
            "condition": "When filtering for cards with abzan watermark",
            "operation": " use WHERE T1.watermark = 'abzan' with exact literal value 'abzan'."
        },
        "523": {
            "condition": "When the question asks for the foreign name and type of a card, When joining cards (T1) and foreign_data (T2) tables, When filtering for cards with abzan watermark, When ensuring unique results",
            "operation": " apply DISTINCT to eliminate duplicate rows in the output."
        },
        "524": {
            "condition": "When the question asks for \"language of the card\" and \"type of this card\"",
            "operation": " select both T2.language and T1.type as output columns."
        },
        "525": {
            "condition": "When the question mentions \"azorius watermark\"",
            "operation": " filter for rows where T1.watermark equals exactly 'azorius'."
        },
        "526": {
            "condition": "When combining cards and foreign_data tables",
            "operation": " link rows where T2.uuid equals T1.uuid and keep only matching pairs (inner match)."
        },
        "527": {
            "condition": "When selecting from multiple tables",
            "operation": " qualify columns with their table aliases (T1 for cards, T2 for foreign_data)."
        },
        "528": {
            "condition": "When the question asks for \"language of the card\" and \"type of this card\", When the question mentions \"azorius watermark\", When combining cards and foreign_data tables, When selecting from multiple tables, When the question asks for distinct language-type pairs",
            "operation": " return only unique combinations of T2.language and T1.type values."
        },
        "529": {
            "condition": "When the question mentions \"designed by Aaron Miller\"",
            "operation": " \"designed by\" actually means \"artist = 'Aaron Miller'\" in the schema."
        },
        "530": {
            "condition": "When counting cards that meet specific conditions",
            "operation": " use SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) instead of COUNT(*) to count only rows satisfying all specified conditions."
        },
        "531": {
            "condition": "When checking for card availability",
            "operation": " ensure both cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL conditions are included to verify both ID fields are present."
        },
        "532": {
            "condition": "When the question mentions \"designed by Aaron Miller\", When counting cards that meet specific conditions, When checking for card availability, When the question asks about \"incredibly powerful\" cards",
            "operation": " do not include power_level = 'incredibly powerful' filter as this condition is not part of the intended logic."
        },
        "533": {
            "condition": "When the question asks for cards with availability 'paper'",
            "operation": " use the exact literal 'paper' with lowercase letters and no quotes in the condition."
        },
        "534": {
            "condition": "When the question mentions \"positive starting maximum hand size\"",
            "operation": " this actually means hand = '3' in the schema."
        },
        "535": {
            "condition": "When counting cards that meet specific conditions",
            "operation": " use SUM(CASE WHEN availability = 'paper' AND hand = '3' THEN 1 ELSE 0 END) to conditionally count only records matching both criteria."
        },
        "536": {
            "condition": "When the question asks for cards with availability 'paper', When the question mentions \"positive starting maximum hand size\", When counting cards that meet specific conditions, When handling the hand condition",
            "operation": " use the exact literal '3' with single quotes as shown in the schema."
        },
        "537": {
            "condition": "When the question asks for \"names of the cards that have a text box\"",
            "operation": " filter rows where \"isTextless\" equals 0 to identify cards that are not textless."
        },
        "538": {
            "condition": "When selecting card names",
            "operation": " use DISTINCT to eliminate duplicate results and return only unique names."
        },
        "539": {
            "condition": "When the question asks for \"names of the cards that have a text box\", When selecting card names, When handling the table reference",
            "operation": " do not include unnecessary table references for simple query structures."
        },
        "540": {
            "condition": "When the question asks for mana cost of a specific card",
            "operation": " use column \"manaCost\" from table \"cards\" instead of \"mana_cost\"."
        },
        "541": {
            "condition": "When retrieving values for a specific card name",
            "operation": " use exact string literal 'Ancestor''s Chosen' with proper escaped quotes."
        },
        "542": {
            "condition": "When the question asks for mana cost of a specific card, When retrieving values for a specific card name, When querying for card information",
            "operation": " ensure results are distinct to eliminate duplicate entries."
        },
        "543": {
            "condition": "When the question mentions \"white border color\"",
            "operation": " use the exact column token \"borderColor\" with literal value 'white' for filtering."
        },
        "544": {
            "condition": "When counting cards with unknown power",
            "operation": " use SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) instead of COUNT(*) to capture both NULL values and asterisk patterns."
        },
        "545": {
            "condition": "When filtering for border color",
            "operation": " do not include power conditions in the WHERE clause as they are handled within the CASE expression."
        },
        "546": {
            "condition": "When the question mentions \"white border color\", When counting cards with unknown power, When filtering for border color, When handling unknown power values",
            "operation": " include both NULL values and values containing asterisks ('%*%') to capture all unknown power cases."
        },
        "547": {
            "condition": "When the question asks for cards that are promotional",
            "operation": " filter using \"isPromo = 1\" instead of string matching on type."
        },
        "548": {
            "condition": "When the question asks for cards with multiple faces",
            "operation": " filter using \"side IS NOT NULL\" instead of numeric comparison on face_count."
        },
        "549": {
            "condition": "When the question asks for cards that are promotional, When the question asks for cards with multiple faces, When listing card names",
            "operation": " use DISTINCT to ensure each name appears only once in the results."
        },
        "550": {
            "condition": "When answering about \"types for the card 'Molimo, Maro-Sorcerer'\"",
            "operation": " make sure to select both \"subtypes\" and \"supertypes\" columns instead of just \"type\"."
        },
        "551": {
            "condition": "When retrieving type classifications for a specific card",
            "operation": " use DISTINCT on both \"subtypes\" and \"supertypes\" to get unique type combinations."
        },
        "552": {
            "condition": "When filtering for a specific card name",
            "operation": " use the exact literal 'Molimo, Maro-Sorcerer' with the correct case and punctuation."
        },
        "553": {
            "condition": "When answering about \"types for the card 'Molimo, Maro-Sorcerer'\", When retrieving type classifications for a specific card, When filtering for a specific card name, When the question asks for \"all types\" of a card",
            "operation": " include both subtype classifications (from \"subtypes\") and supertype classifications (from \"supertypes\") as they represent the complete type information."
        },
        "554": {
            "condition": "When the question asks for websites to purchase cards",
            "operation": " select the exact column \"purchaseUrls\" from table \"cards\" instead of any other column name like \"website_name\"."
        },
        "555": {
            "condition": "When filtering for promotional type \"bundle\"",
            "operation": " use the exact filter condition \"promoTypes = 'bundle'\" with the exact literal value 'bundle' and exact column name \"promoTypes\"."
        },
        "556": {
            "condition": "When the question asks for websites to purchase cards, When filtering for promotional type \"bundle\", When listing distinct websites",
            "operation": " ensure the result contains only unique values by applying DISTINCT to the \"purchaseUrls\" column."
        },
        "557": {
            "condition": "When answering about artists who designed cards with specific border color and availability",
            "operation": " use the cards table directly instead of joining with artists and printings tables."
        },
        "558": {
            "condition": "When the question mentions \"black border color\"",
            "operation": " use the exact column token \"borderColor\" with literal value 'black'."
        },
        "559": {
            "condition": "When the question mentions \"available in both 'arena' and 'mtgo' printing type\"",
            "operation": " use the exact column token \"availability\" with pattern matching '%arena,mtgo%'."
        },
        "560": {
            "condition": "When counting distinct artists",
            "operation": " use COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) instead of complex joins and grouping."
        },
        "561": {
            "condition": "When answering about artists who designed cards with specific border color and availability, When the question mentions \"black border color\", When the question mentions \"available in both 'arena' and 'mtgo' printing type\", When counting distinct artists, When filtering for specific conditions",
            "operation": " apply the conditions directly in the CASE expression rather than using separate WHERE clauses with GROUP BY and HAVING."
        },
        "562": {
            "condition": "When counting artists who designed cards with specific attributes",
            "operation": " use COUNT(CASE WHEN availability LIKE '%arena,mtgo%' AND borderColor = 'black' THEN 1 ELSE NULL END) instead of COUNT(DISTINCT artist)."
        },
        "563": {
            "condition": "When checking for cards available in both \"arena\" and \"mtgo\" printing types",
            "operation": " use a single pattern '%arena,mtgo%' instead of separate LIKE conditions for '%arena%' and '%mtgo%'."
        },
        "564": {
            "condition": "When filtering for black border color",
            "operation": " use exact literal 'black' for borderColor comparison."
        },
        "565": {
            "condition": "When counting artists who designed cards with specific attributes, When checking for cards available in both \"arena\" and \"mtgo\" printing types, When filtering for black border color, When handling NULL values in artist field",
            "operation": " do not include explicit artist IS NOT NULL filter as the CASE expression handles NULL values appropriately."
        },
        "566": {
            "condition": "When the question asks about specific card names like \"Serra Angel\" and \"Shrine Keeper\"",
            "operation": " filter the cards table using name IN ('Serra Angel', 'Shrine Keeper') with exact case and spacing."
        },
        "567": {
            "condition": "When comparing converted mana costs between cards",
            "operation": " order the results by convertedManaCost in descending order to find the highest cost card."
        },
        "568": {
            "condition": "When the question asks which card costs more",
            "operation": " return only the top result using LIMIT 1 to get the single highest cost card."
        },
        "569": {
            "condition": "When the question asks about specific card names like \"Serra Angel\" and \"Shrine Keeper\", When comparing converted mana costs between cards, When the question asks which card costs more, When selecting output columns",
            "operation": " only include the name column instead of multiple columns with aliases like card1, card2, cost1, and cost2."
        },
        "570": {
            "condition": "When the question mentions \"promotional name\"",
            "operation": " \"promotional name\" actually means \"flavorName in schema\"."
        },
        "571": {
            "condition": "When the question mentions \"promotional name\", When filtering for a specific card flavor name",
            "operation": " use the exact literal \"Battra, Dark Destroyer\" with the correct column name \"flavorName\"."
        },
        "572": {
            "condition": "When the question mentions \"2003 card frame style\"",
            "operation": " use the exact column \"frameVersion\" with numeric value 2003 instead of the string column \"frame\" with literal '2003'."
        },
        "573": {
            "condition": "When filtering for frame version",
            "operation": " use the exact numeric value 2003 without quotes or string conversion."
        },
        "574": {
            "condition": "When the question mentions \"2003 card frame style\", When filtering for frame version, When answering about \"top 3 cards with highest converted mana cost\"",
            "operation": " rank cards by \"convertedManaCost\" in descending order and keep the first 3 rows."
        },
        "575": {
            "condition": "When the question asks for Italian translations of sets containing a specific card",
            "operation": " use the set_translations table instead of the sets table."
        },
        "576": {
            "condition": "When selecting the Italian name",
            "operation": " select the translation column instead of the name column."
        },
        "577": {
            "condition": "When filtering for sets containing \"Ancestor's Chosen\"",
            "operation": " use a subquery to get setCode values from the cards table where name = 'Ancestor''s Chosen' instead of using a LIKE pattern match."
        },
        "578": {
            "condition": "When filtering by language",
            "operation": " apply language = 'Italian' in the outer query on set_translations instead of in a subquery."
        },
        "579": {
            "condition": "When the question asks for Italian translations of sets containing a specific card, When selecting the Italian name, When filtering for sets containing \"Ancestor's Chosen\", When filtering by language, When combining set_translations with cards data",
            "operation": " link through setCode values obtained from the cards table subquery."
        },
        "580": {
            "condition": "When answering about translations for cards with \"Angel of Mercy\"",
            "operation": " query the \"set_translations\" table instead of the \"translations\" table."
        },
        "581": {
            "condition": "When counting translations",
            "operation": " count distinct values of the \"translation\" column instead of counting all rows."
        },
        "582": {
            "condition": "When filtering for cards with \"Angel of Mercy\"",
            "operation": " use a subquery to filter by \"setCode IN (SELECT setCode FROM cards WHERE name = 'Angel of Mercy')\" instead of directly filtering by card_name."
        },
        "583": {
            "condition": "When handling null values",
            "operation": " exclude null translations by adding \"AND translation IS NOT NULL\" to the conditions."
        },
        "584": {
            "condition": "When answering about translations for cards with \"Angel of Mercy\", When counting translations, When filtering for cards with \"Angel of Mercy\", When handling null values, When combining tables for this relationship",
            "operation": " use the \"setCode\" column to link \"set_translations\" with \"cards\" table through the subquery relationship."
        },
        "585": {
            "condition": "When answering about \"cards in the set 'Hauptset Zehnte Edition'\"",
            "operation": " make sure the output order: T1.name"
        },
        "586": {
            "condition": "When the question mentions \"cards\"",
            "operation": " \"cards\" actually means \"T1.name in schema\""
        },
        "587": {
            "condition": "When the question mentions \"set 'Hauptset Zehnte Edition'\"",
            "operation": " use T2.translation = 'Hauptset Zehnte Edition' to filter by the exact German translation"
        },
        "588": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.setCode = T1.setCode exactly as shown; keep only matching pairs (inner match)"
        },
        "589": {
            "condition": "When answering about \"cards in the set 'Hauptset Zehnte Edition'\", When the question mentions \"cards\", When the question mentions \"set 'Hauptset Zehnte Edition'\", When combining T1 and T2 for shared entities, When selecting card names",
            "operation": " use DISTINCT T1.name to get unique card names from the cards table"
        },
        "590": {
            "condition": "When answering about whether a Korean version exists for cards with \"Ancestor's Chosen\"",
            "operation": " use conditional logic to return 'YES' or 'NO' based on translation existence instead of selecting all columns."
        },
        "591": {
            "condition": "When the question mentions \"cards with 'Ancestor's Chosen' in it\"",
            "operation": " filter using T1.name = 'Ancestor''s Chosen' with proper string escaping."
        },
        "592": {
            "condition": "When combining cards table (T1) and set_translations table (T2)",
            "operation": " link rows where T2.setCode = T1.setCode using an inner join."
        },
        "593": {
            "condition": "When checking for Korean translations",
            "operation": " use the condition T2.language = 'Korean' AND T2.translation IS NOT NULL within the aggregation logic."
        },
        "594": {
            "condition": "When answering about whether a Korean version exists for cards with \"Ancestor's Chosen\", When the question mentions \"cards with 'Ancestor's Chosen' in it\", When combining cards table (T1) and set_translations table (T2), When checking for Korean translations, When determining if Korean translations exist",
            "operation": " count using SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0 and return 'YES' if true, 'NO' if false."
        },
        "595": {
            "condition": "When answering about cards in a specific set",
            "operation": " join cards AS T1 with set_translations AS T2 on T2.setCode = T1.setCode to resolve set names."
        },
        "596": {
            "condition": "When filtering for set name \"Hauptset Zehnte Edition\"",
            "operation": " use T2.translation = 'Hauptset Zehnte Edition' instead of directly filtering set_name in the cards table."
        },
        "597": {
            "condition": "When filtering for cards designed by Adam Rex",
            "operation": " use T1.artist = 'Adam Rex' instead of designer column."
        },
        "598": {
            "condition": "When answering about cards in a specific set, When filtering for set name \"Hauptset Zehnte Edition\", When filtering for cards designed by Adam Rex, When counting cards",
            "operation": " count T1.id instead of using COUNT(*) to ensure accurate counting of specific records."
        },
        "599": {
            "condition": "When answering about \"How many cards are there in the base set\"",
            "operation": " make sure the output order: T1.baseSetSize"
        },
        "600": {
            "condition": "When the question mentions \"Hauptset Zehnte Edition\"",
            "operation": " \"Hauptset Zehnte Edition\" actually means \"T2.translation\" in schema"
        },
        "601": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "602": {
            "condition": "When answering about \"How many cards are there in the base set\", When the question mentions \"Hauptset Zehnte Edition\", When combining T1 and T2 for shared entities, When filtering for the specific set translation",
            "operation": " use T2.translation = 'Hauptset Zehnte Edition' exactly as specified with the exact case and spacing"
        },
        "603": {
            "condition": "When answering about Simplified Chinese translation of a set name",
            "operation": " make sure the output order: T2.translation"
        },
        "604": {
            "condition": "When the question mentions \"Simplified Chinese\"",
            "operation": " \"Simplified Chinese\" actually means \"T2.language = 'Chinese Simplified'\" in schema"
        },
        "605": {
            "condition": "When the question mentions \"set name 'Eighth Edition'\"",
            "operation": " \"Eighth Edition\" actually means \"T1.name = 'Eighth Edition'\" in schema"
        },
        "606": {
            "condition": "When answering about Simplified Chinese translation of a set name, When the question mentions \"Simplified Chinese\", When the question mentions \"set name 'Eighth Edition'\", When combining T1 (sets) and T2 (set_translations) for shared entities",
            "operation": " link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "607": {
            "condition": "When answering about whether cards with a specific name appeared online",
            "operation": " use IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') to return availability status instead of selecting all columns."
        },
        "608": {
            "condition": "When the question mentions \"Angel of Mercy\"",
            "operation": " use T1.name = 'Angel of Mercy' with exact case and spacing in the WHERE clause."
        },
        "609": {
            "condition": "When combining cards and sets tables",
            "operation": " link rows using T2.code = T1.setCode with an inner join to only keep matching pairs."
        },
        "610": {
            "condition": "When answering about whether cards with a specific name appeared online, When the question mentions \"Angel of Mercy\", When combining cards and sets tables, When determining online availability",
            "operation": " check for the presence of T2.mtgoCode instead of using a static value like 'Yes'."
        },
        "611": {
            "condition": "When answering about release dates for cards with a specific name",
            "operation": " make sure the output order: T2.releaseDate."
        },
        "612": {
            "condition": "When the question mentions \"cards with 'Ancestor's Chosen'\"",
            "operation": " \"cards\" actually means \"T1.name in schema\" and the literal must be exactly 'Ancestor''s Chosen'."
        },
        "613": {
            "condition": "When combining T1 (cards) and T2 (sets) for shared entities",
            "operation": " link rows where T2.code = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "614": {
            "condition": "When answering about release dates for cards with a specific name, When the question mentions \"cards with 'Ancestor's Chosen'\", When combining T1 (cards) and T2 (sets) for shared entities, When selecting release dates",
            "operation": " use DISTINCT T2.releaseDate instead of release_date to select the correct column with deduplication."
        },
        "615": {
            "condition": "When the question asks about expansion type for a specific set name",
            "operation": " use T1.type from the sets table as the output column instead of expansion_type."
        },
        "616": {
            "condition": "When matching a set by translated name 'Hauptset Zehnte Edition'",
            "operation": " join sets table T1 with set_translations table T2 using T2.setCode = T1.code instead of querying only the sets table."
        },
        "617": {
            "condition": "When the question asks about expansion type for a specific set name, When matching a set by translated name 'Hauptset Zehnte Edition', When filtering for the exact translation 'Hauptset Zehnte Edition'",
            "operation": " use T2.translation = 'Hauptset Zehnte Edition' instead of set_name = 'Hauptset Zehnte Edition' to properly match the translated set name."
        },
        "618": {
            "condition": "When answering about \"sets in the block 'Ice Age' with Italian translation\"",
            "operation": " make sure the output order: count of distinct sets"
        },
        "619": {
            "condition": "When the question mentions \"sets in the block 'Ice Age'\"",
            "operation": " \"block\" actually means \"T1.block in schema\" and use literal 'Ice Age'"
        },
        "620": {
            "condition": "When the question mentions \"Italian translation\"",
            "operation": " \"Italian\" actually means \"T2.language = 'Italian' in schema\""
        },
        "621": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "622": {
            "condition": "When counting sets",
            "operation": " compute the number of distinct values using T1.id as the counting key"
        },
        "623": {
            "condition": "When handling translations",
            "operation": " include only rows where T2.translation IS NOT NULL to exclude untranslated records"
        },
        "624": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "625": {
            "condition": "When answering about \"sets in the block 'Ice Age' with Italian translation\", When the question mentions \"sets in the block 'Ice Age'\", When the question mentions \"Italian translation\", When combining T1 and T2 for shared entities, When counting sets, When handling translations, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Ice Age' or 'Italian'"
        },
        "626": {
            "condition": "When answering about availability of cards with specific names",
            "operation": " join the cards table (T1) with the sets table (T2) using T1.setCode = T2.code to access set information."
        },
        "627": {
            "condition": "When the question asks about cards being \"only available outside the United States\"",
            "operation": " check the isForeignOnly column from the sets table and return 'YES' when isForeignOnly = 1, otherwise return 'NO'."
        },
        "628": {
            "condition": "When filtering for a specific card name",
            "operation": " use the exact literal 'Adarkar Valkyrie' with the name column from the cards table."
        },
        "629": {
            "condition": "When answering about availability of cards with specific names, When the question asks about cards being \"only available outside the United States\", When filtering for a specific card name, When producing output",
            "operation": " return only the conditional flag indicating foreign-only status rather than all columns."
        },
        "630": {
            "condition": "When counting cards with Italian translations",
            "operation": " count using T1.id from the sets table instead of counting all rows from the cards table."
        },
        "631": {
            "condition": "When combining set information with translations",
            "operation": " link rows where T2.setCode = T1.code using an inner join between sets table (T1) and set_translations table (T2)."
        },
        "632": {
            "condition": "When filtering for Italian translations",
            "operation": " use T2.translation IS NOT NULL and T2.language = 'Italian' instead of checking italian_translation."
        },
        "633": {
            "condition": "When counting cards with Italian translations, When combining set information with translations, When filtering for Italian translations, When filtering for base set number under 100",
            "operation": " use T1.baseSetSize < 100 instead of base_set_number < 100."
        },
        "634": {
            "condition": "When the question asks about cards in a specific set",
            "operation": " combine the cards table (T1) and sets table (T2) by linking rows where T2.code equals T1.setCode, keeping only matching pairs."
        },
        "635": {
            "condition": "When filtering by set name 'Coldsnap'",
            "operation": " use T2.name = 'Coldsnap' exactly as written."
        },
        "636": {
            "condition": "When counting cards with black border color",
            "operation": " use SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) to count only rows where T1.borderColor equals 'black' exactly."
        },
        "637": {
            "condition": "When the question asks about cards in a specific set, When filtering by set name 'Coldsnap', When counting cards with black border color, When referencing border color column",
            "operation": " use T1.borderColor instead of border_color to match the exact column name."
        },
        "638": {
            "condition": "When the question mentions \"set Coldsnap\"",
            "operation": " \"Coldsnap\" actually means \"T2.name = 'Coldsnap'\" in schema."
        },
        "639": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.code = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "640": {
            "condition": "When the question asks for \"name of the cards\"",
            "operation": " reference T1.name instead of just name."
        },
        "641": {
            "condition": "When the question asks for \"highest converted mana cost\"",
            "operation": " rank rows by T1.convertedManaCost in descending direction and keep the first 1 row."
        },
        "642": {
            "condition": "When the question mentions \"set Coldsnap\", When combining T1 and T2 for shared entities, When the question asks for \"name of the cards\", When the question asks for \"highest converted mana cost\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "643": {
            "condition": "When answering about artists who designed cards in a specific set",
            "operation": " combine the cards and sets tables using an inner match where T2.code equals T1.setCode."
        },
        "644": {
            "condition": "When the question mentions \"set Coldsnap\"",
            "operation": " filter for T2.name exactly equal to 'Coldsnap'."
        },
        "645": {
            "condition": "When the question asks about specific artists Jeremy Jarvis, Aaron Miller, or Chippy",
            "operation": " check if T1.artist equals 'Jeremy Jarvis' OR T1.artist equals 'Aaron Miller' OR T1.artist equals 'Chippy'."
        },
        "646": {
            "condition": "When grouping results by artist",
            "operation": " organize the output by T1.artist."
        },
        "647": {
            "condition": "When answering about artists who designed cards in a specific set, When the question mentions \"set Coldsnap\", When the question asks about specific artists Jeremy Jarvis, Aaron Miller, or Chippy, When grouping results by artist, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "648": {
            "condition": "When answering about \"card number 4 in the set Coldsnap\"",
            "operation": " make sure the output order: T1.name."
        },
        "649": {
            "condition": "When combining cards table T1 and sets table T2",
            "operation": " link rows where T2.code = T1.setCode and keep only matching pairs (inner match)."
        },
        "650": {
            "condition": "When the question mentions \"set Coldsnap\"",
            "operation": " \"Coldsnap\" actually means T2.name = 'Coldsnap' in schema."
        },
        "651": {
            "condition": "When answering about \"card number 4 in the set Coldsnap\", When combining cards table T1 and sets table T2, When the question mentions \"set Coldsnap\", When the question mentions \"card number 4\"",
            "operation": " \"card number 4\" actually means T1.number = 4 in schema."
        },
        "652": {
            "condition": "When joining cards and sets tables",
            "operation": " link rows where T1.setCode = T2.code and keep only matching pairs (inner match)."
        },
        "653": {
            "condition": "When filtering for the Coldsnap set",
            "operation": " use T2.name = 'Coldsnap' exactly as specified."
        },
        "654": {
            "condition": "When filtering for converted mana cost higher than 5",
            "operation": " use T1.convertedManaCost > 5 with exact column naming."
        },
        "655": {
            "condition": "When counting cards with unknown power",
            "operation": " count rows where T1.power LIKE '*' OR T1.power IS NULL using SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END)."
        },
        "656": {
            "condition": "When joining cards and sets tables, When filtering for the Coldsnap set, When filtering for converted mana cost higher than 5, When counting cards with unknown power, When handling power conditions",
            "operation": " do not include explicit power filters in WHERE clause since counting logic is handled in the CASE expression."
        },
        "657": {
            "condition": "When answering about \"Italian flavor text of the card 'Ancestor's Chosen'\"",
            "operation": " make sure the output order: T2.flavorText."
        },
        "658": {
            "condition": "When the question mentions \"flavor text\"",
            "operation": " \"flavor text\" actually means \"T2.flavorText in schema\"."
        },
        "659": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.uuid = T1.uuid exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "660": {
            "condition": "When filtering for the specific card name",
            "operation": " use T1.name = 'Ancestor''s Chosen' with the exact string literal and proper escaping."
        },
        "661": {
            "condition": "When answering about \"Italian flavor text of the card 'Ancestor's Chosen'\", When the question mentions \"flavor text\", When combining T1 and T2 for shared entities, When filtering for the specific card name, When filtering for Italian language",
            "operation": " use T2.language = 'Italian' with the exact string literal."
        },
        "662": {
            "condition": "When answering about foreign languages for a specific card",
            "operation": " join foreign_data as T2 on T2.uuid = T1.uuid to access language data."
        },
        "663": {
            "condition": "When filtering for card \"Ancestor's Chosen\"",
            "operation": " use T1.name = 'Ancestor''s Chosen' with exact table qualification and literal value."
        },
        "664": {
            "condition": "When checking for flavor text existence",
            "operation": " use T2.flavorText IS NOT NULL to reference the correct column from the joined table."
        },
        "665": {
            "condition": "When retrieving languages",
            "operation": " reference T2.language instead of language from the original table."
        },
        "666": {
            "condition": "When answering about foreign languages for a specific card, When filtering for card \"Ancestor's Chosen\", When checking for flavor text existence, When retrieving languages, When ensuring unique results",
            "operation": " do not use DISTINCT since the join relationship ensures uniqueness."
        },
        "667": {
            "condition": "When the question asks about German card types",
            "operation": " join the cards table (T1) with the foreign_data table (T2) using an inner match where T2.uuid = T1.uuid."
        },
        "668": {
            "condition": "When filtering for German language data",
            "operation": " add condition T2.language = 'German' exactly as specified."
        },
        "669": {
            "condition": "When selecting card type information for a specific card name",
            "operation": " use T1.type instead of german_type and apply DISTINCT to eliminate duplicates."
        },
        "670": {
            "condition": "When the question asks about German card types, When filtering for German language data, When selecting card type information for a specific card name, When filtering by card name",
            "operation": " use T1.name = 'Ancestor\\'s Chosen' with exact spelling and punctuation."
        },
        "671": {
            "condition": "When answering about \"Italian text ruling of cards in set Coldsnap\"",
            "operation": " make sure the output order: T1.text"
        },
        "672": {
            "condition": "When the question mentions \"Italian text\"",
            "operation": " \"Italian text\" actually means \"T1.text in foreign_data table where T1.language = 'Italian'\""
        },
        "673": {
            "condition": "When the question mentions \"cards in the set Coldsnap\"",
            "operation": " this requires joining T1 (foreign_data) with T2 (cards) on T2.uuid = T1.uuid, then joining T2 with T3 (sets) on T3.code = T2.setCode, and filtering where T3.name = 'Coldsnap'"
        },
        "674": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where T2.uuid = T1.uuid and T3.code = T2.setCode; keep only matching pairs (inner match)"
        },
        "675": {
            "condition": "When eliminating duplicate results",
            "operation": " use DISTINCT on the output to ensure unique T1.text values"
        },
        "676": {
            "condition": "When answering about \"Italian text ruling of cards in set Coldsnap\", When the question mentions \"Italian text\", When the question mentions \"cards in the set Coldsnap\", When combining tables for shared entities, When eliminating duplicate results, When handling text literals",
            "operation": " use exact literal 'Italian' for language and 'Coldsnap' for set name with exact case and spelling"
        },
        "677": {
            "condition": "When answering about cards in a specific set",
            "operation": " join foreign_data as T1 and sets as T3 using INNER JOIN on T2.uuid = T1.uuid and T3.code = T2.setCode instead of querying only the cards table."
        },
        "678": {
            "condition": "When the question mentions \"Italian names\"",
            "operation": " filter on T1.language = 'Italian' instead of language = 'Italian'."
        },
        "679": {
            "condition": "When the question mentions \"set Coldsnap\"",
            "operation": " filter on T3.name = 'Coldsnap' instead of set_name = 'Coldsnap'."
        },
        "680": {
            "condition": "When the question asks for \"highest converted mana cost\"",
            "operation": " order by T2.convertedManaCost in descending direction instead of converted_mana_cost."
        },
        "681": {
            "condition": "When the question asks to \"list the Italian names\" without specifying a limit",
            "operation": " remove LIMIT 1 instead of keeping it."
        },
        "682": {
            "condition": "When answering about cards in a specific set, When the question mentions \"Italian names\", When the question mentions \"set Coldsnap\", When the question asks for \"highest converted mana cost\", When the question asks to \"list the Italian names\" without specifying a limit, When referencing card names in foreign languages",
            "operation": " reference T2.name instead of just name."
        },
        "683": {
            "condition": "When retrieving card names from the database schema",
            "operation": " use T2.name instead of T1.name to get the card name from the correct table."
        },
        "684": {
            "condition": "When filtering for cards in the Coldsnap set",
            "operation": " do not include a subquery comparison for maximum converted mana cost, as this incorrectly restricts results."
        },
        "685": {
            "condition": "When retrieving card names from the database schema, When filtering for cards in the Coldsnap set, When the question asks for cards with the highest converted mana cost",
            "operation": " remove any subquery that compares convertedManaCost to a maximum value, as this filtering approach is unnecessary and restrictive."
        },
        "686": {
            "condition": "When the question asks for Italian names of cards",
            "operation": " select the name from the cards table (T2.name) rather than from the foreign_data table."
        },
        "687": {
            "condition": "When filtering for cards in the Coldsnap set",
            "operation": " use T3.name = 'Coldsnap' exactly as specified."
        },
        "688": {
            "condition": "When filtering for Italian language cards",
            "operation": " use T1.language = 'Italian' exactly as specified."
        },
        "689": {
            "condition": "When joining cards and foreign_data tables",
            "operation": " link rows where T2.uuid = T1.uuid exactly."
        },
        "690": {
            "condition": "When joining cards and sets tables",
            "operation": " link rows where T3.code = T2.setCode exactly."
        },
        "691": {
            "condition": "When ordering by highest converted mana cost",
            "operation": " sort by T2.convertedManaCost in descending order."
        },
        "692": {
            "condition": "When the question asks for Italian names of cards, When filtering for cards in the Coldsnap set, When filtering for Italian language cards, When joining cards and foreign_data tables, When joining cards and sets tables, When ordering by highest converted mana cost, When the question asks for the highest converted mana cost cards",
            "operation": " return all cards with the maximum converted mana cost value (not just one card)."
        },
        "693": {
            "condition": "When answering about \"When was the ruling for the card 'Reminisce' created\"",
            "operation": " make sure the output order: T2.date"
        },
        "694": {
            "condition": "When the question mentions \"card 'Reminisce'\"",
            "operation": " \"card 'Reminisce'\" actually means \"T1.name = 'Reminisce'\" in schema"
        },
        "695": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.uuid = T1.uuid exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "696": {
            "condition": "When answering about \"When was the ruling for the card 'Reminisce' created\", When the question mentions \"card 'Reminisce'\", When combining T1 and T2 for shared entities, When the question asks for ruling date",
            "operation": " use T2.date from the rulings table instead of created_date"
        },
        "697": {
            "condition": "When calculating percentage of cards with converted mana cost 7 in a specific set",
            "operation": " use CAST(SUM(CASE WHEN convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) instead of COUNT(*) * 100.0 / subquery."
        },
        "698": {
            "condition": "When filtering by set name 'Coldsnap'",
            "operation": " join sets AS T2 on T2.code = T1.setCode and filter on T2.name = 'Coldsnap' instead of using set_name directly."
        },
        "699": {
            "condition": "When handling converted mana cost condition",
            "operation": " remove converted_mana_cost = 7 from WHERE clause since it's handled in the CASE expression within aggregate calculation."
        },
        "700": {
            "condition": "When calculating percentage of cards with converted mana cost 7 in a specific set, When filtering by set name 'Coldsnap', When handling converted mana cost condition, When counting cards",
            "operation": " use COUNT(id) as the denominator for percentage calculation to count all cards in the specified set."
        },
        "701": {
            "condition": "When calculating percentage of cards with both cardKingdomFoilId and cardKingdomId",
            "operation": " use CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) instead of simple count ratios."
        },
        "702": {
            "condition": "When querying for cards from a specific set",
            "operation": " join sets AS T2 with INNER JOIN on T2.code = T1.setCode instead of filtering directly on set_name."
        },
        "703": {
            "condition": "When filtering for the Coldsnap set",
            "operation": " use T2.name = 'Coldsnap' instead of set_name = 'Coldsnap'."
        },
        "704": {
            "condition": "When calculating percentage of cards with both cardKingdomFoilId and cardKingdomId, When querying for cards from a specific set, When filtering for the Coldsnap set, When the question asks about incredibly powerful cards",
            "operation": " this actually means cards where both cardKingdomFoilId and cardKingdomId are present (not power > 9000)."
        },
        "705": {
            "condition": "When the question mentions \"released on 2017/7/14\"",
            "operation": " use the exact date literal '2017-07-14' for comparison."
        },
        "706": {
            "condition": "When filtering by release date in the sets table",
            "operation": " use the column name \"releaseDate\" exactly as shown in the schema, not \"release_date\"."
        },
        "707": {
            "condition": "When the question mentions \"released on 2017/7/14\", When filtering by release date in the sets table, When selecting the code for a specific release date",
            "operation": " include both \"releaseDate\" and \"code\" in the grouping to ensure correct behavior."
        },
        "708": {
            "condition": "When the question asks for a specific date like \"2017/7/14\"",
            "operation": " use the ISO date format '2017-07-14' instead of the non-standard format to ensure proper date comparison and avoid parsing errors."
        },
        "709": {
            "condition": "When filtering by releaseDate in the sets table",
            "operation": " use the exact column name \"releaseDate\" with the ISO formatted date literal '2017-07-14' for accurate date matching."
        },
        "710": {
            "condition": "When the question asks for a specific date like \"2017/7/14\", When filtering by releaseDate in the sets table, When selecting the code from sets table",
            "operation": " use the exact column name \"code\" to return the set codes that match the specified release date."
        },
        "711": {
            "condition": "When the question asks for \"keyrune code\" from the sets table",
            "operation": " use the exact column name \"keyruneCode\" (not \"keyrune_code\") from table sets."
        },
        "712": {
            "condition": "When filtering for sets with code equal to 'PKHC'",
            "operation": " use the exact literal value 'PKHC' with the correct case and no quotes in the condition."
        },
        "713": {
            "condition": "When the question asks for \"keyrune code\" from the sets table, When filtering for sets with code equal to 'PKHC', When selecting output columns",
            "operation": " return only the \"keyruneCode\" column in the result."
        },
        "714": {
            "condition": "When the question asks for 'magic card market id'",
            "operation": " use the exact column name \"mcmId\" from the sets table."
        },
        "715": {
            "condition": "When filtering for sets with code 'SS2'",
            "operation": " use the exact literal value 'SS2' in the WHERE clause condition."
        },
        "716": {
            "condition": "When the question asks for 'magic card market id', When filtering for sets with code 'SS2', When selecting from the sets table",
            "operation": " only retrieve the \"mcmId\" column as output."
        },
        "717": {
            "condition": "When the question asks for \"magic card market name\"",
            "operation": " use the exact column \"mcmName\" from table \"sets\" instead of \"name\"."
        },
        "718": {
            "condition": "When filtering by release date",
            "operation": " use the exact column \"releaseDate\" from table \"sets\" with date format 'YYYY-MM-DD' and proper zero-padding."
        },
        "719": {
            "condition": "When the question asks for \"magic card market name\", When filtering by release date, When the date in the question is '2017/6/9'",
            "operation": " convert it to the exact literal '2017-06-09' with hyphens and consistent zero-padding for month and day."
        },
        "720": {
            "condition": "When the question asks about \"expansion type\" for a Magic",
            "operation": " The Gathering set: use the column \"type\" from the sets table instead of \"expansion_type\"."
        },
        "721": {
            "condition": "When the question asks about \"expansion type\" for a Magic, When matching set names like \"From the Vault",
            "operation": " Lore\": use pattern matching with LIKE '%FROM the Vault: Lore%' instead of exact equality to allow for case-insensitive matching and potential text variations."
        },
        "722": {
            "condition": "When the question asks for \"parent code\" of a specific set",
            "operation": " use the exact column name \"parentCode\" from the sets table."
        },
        "723": {
            "condition": "When filtering by set name with literal \"Commander 2014 Oversized\"",
            "operation": " match the exact string literal 'Commander 2014 Oversized' with correct case and spacing."
        },
        "724": {
            "condition": "When the question asks for \"parent code\" of a specific set, When filtering by set name with literal \"Commander 2014 Oversized\", When retrieving information about sets",
            "operation": " ensure the output column order is parentCode as the single result column."
        },
        "725": {
            "condition": "When answering about cards illustrated by Jim Pavelec",
            "operation": " use T1 as the base table for cards and T2 as the related table for rulings."
        },
        "726": {
            "condition": "When joining cards and rulings tables",
            "operation": " link rows where T2.uuid = T1.uuid using an inner join instead of a left join."
        },
        "727": {
            "condition": "When selecting output columns",
            "operation": " select T2.text instead of c.name and r.text."
        },
        "728": {
            "condition": "When checking for missing or degraded properties",
            "operation": " use a CASE expression checking T1.hasContentWarning instead of checking mana_cost, power, toughness, and cmc properties."
        },
        "729": {
            "condition": "When answering about cards illustrated by Jim Pavelec, When joining cards and rulings tables, When selecting output columns, When checking for missing or degraded properties, When ordering results",
            "operation": " do not include any ORDER BY clause instead of ordering by c.name."
        },
        "730": {
            "condition": "When the question asks about cards illustrated by \"Jim Pavelec\"",
            "operation": " filter rows where T1.artist equals exactly 'Jim Pavelec'."
        },
        "731": {
            "condition": "When combining cards table (T1) and rulings table (T2)",
            "operation": " link rows where T2.uuid equals T1.uuid exactly and keep only matching pairs (inner match)."
        },
        "732": {
            "condition": "When outputting whether cards have missing or degraded properties",
            "operation": " use uppercase 'YES' when T1.hasContentWarning equals 1, otherwise use 'NO'."
        },
        "733": {
            "condition": "When the question asks about cards illustrated by \"Jim Pavelec\", When combining cards table (T1) and rulings table (T2), When outputting whether cards have missing or degraded properties, When answering about cards illustrated by Jim Pavelec",
            "operation": " make sure the output order: T2.text first, followed by the case expression result without any alias."
        },
        "734": {
            "condition": "When answering about \"release date for the set containing card 'Evacuation'\"",
            "operation": " make sure the output order: T2.releaseDate"
        },
        "735": {
            "condition": "When the question mentions \"card 'Evacuation'\"",
            "operation": " \"card 'Evacuation'\" actually means \"T1.name = 'Evacuation'\" in schema"
        },
        "736": {
            "condition": "When combining T1 (cards) and T2 (sets) for shared entities",
            "operation": " link rows where T2.code = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "737": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for literal 'Evacuation'"
        },
        "738": {
            "condition": "When answering about \"release date for the set containing card 'Evacuation'\", When the question mentions \"card 'Evacuation'\", When combining T1 (cards) and T2 (sets) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Evacuation'"
        },
        "739": {
            "condition": "When answering about \"number of cards in the set of 'Rinascita di Alara'\"",
            "operation": " make sure the output order: T1.baseSetSize"
        },
        "740": {
            "condition": "When the question mentions \"Rinascita di Alara\"",
            "operation": " \"Rinascita di Alara\" actually means \"T2.translation = 'Rinascita di Alara'\" in schema"
        },
        "741": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.setCode = T1.code; keep only matching pairs (inner match)"
        },
        "742": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "743": {
            "condition": "When answering about \"number of cards in the set of 'Rinascita di Alara'\", When the question mentions \"Rinascita di Alara\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Rinascita di Alara'"
        },
        "744": {
            "condition": "When the question asks for \"expansion type\" of a set",
            "operation": " use the column \"type\" from the \"sets\" table instead of \"expansion_type\"."
        },
        "745": {
            "condition": "When the question mentions a set name like \"Huiti\u00e8me \u00e9dition\"",
            "operation": " this refers to the \"translation\" column in the \"set_translations\" table, not the \"set_name\" column."
        },
        "746": {
            "condition": "When filtering for a specific set translation",
            "operation": " use a subquery condition where \"code IN (SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition')\" to properly link the sets and set_translations tables."
        },
        "747": {
            "condition": "When the question asks for \"expansion type\" of a set, When the question mentions a set name like \"Huiti\u00e8me \u00e9dition\", When filtering for a specific set translation, When combining sets and set_translations tables",
            "operation": " link them through the relationship where sets.\"code\" equals set_translations.\"setCode\" as implied by the subquery filter."
        },
        "748": {
            "condition": "When the question asks for the French name of a set containing a specific card",
            "operation": " select T2.translation instead of french_name from the result set."
        },
        "749": {
            "condition": "When combining cards and set_translations tables",
            "operation": " link rows where T2.setCode = T1.setCode using an inner join."
        },
        "750": {
            "condition": "When filtering for French translations",
            "operation": " add conditions T2.language = 'French' and T2.translation IS NOT NULL."
        },
        "751": {
            "condition": "When the question asks for the French name of a set containing a specific card, When combining cards and set_translations tables, When filtering for French translations, When filtering for a specific card name",
            "operation": " use T1.name = 'Tendo Ice Bridge' instead of card_name = 'Tendo Ice Bridge'."
        },
        "752": {
            "condition": "When answering about \"translations of the name of the set 'Tenth Edition'\"",
            "operation": " make sure the output order: count of distinct translations."
        },
        "753": {
            "condition": "When the question mentions \"translations\"",
            "operation": " \"translations\" actually means \"T2.translation in schema\"."
        },
        "754": {
            "condition": "When the question asks for \"count of translations\"",
            "operation": " compute the number of unique values of T2.translation."
        },
        "755": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.setCode = T1.code exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "756": {
            "condition": "When filtering for the set name \"Tenth Edition\"",
            "operation": " use T1.name = 'Tenth Edition' exactly with the literal 'Tenth Edition'."
        },
        "757": {
            "condition": "When answering about \"translations of the name of the set 'Tenth Edition'\", When the question mentions \"translations\", When the question asks for \"count of translations\", When combining T1 and T2 for shared entities, When filtering for the set name \"Tenth Edition\", When handling translation data",
            "operation": " exclude null values by adding T2.translation IS NOT NULL condition."
        },
        "758": {
            "condition": "When answering about \"Japanese name of the set containing card 'Fellwar Stone'\"",
            "operation": " make sure the output order: T2.translation."
        },
        "759": {
            "condition": "When the question mentions \"Japanese name\"",
            "operation": " \"Japanese name\" actually means \"T2.translation in schema where T2.language = 'Japanese'\"."
        },
        "760": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.setCode = T1.setCode exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "761": {
            "condition": "When filtering for card \"Fellwar Stone\"",
            "operation": " use exact literal T1.name = 'Fellwar Stone' with case and spacing preserved."
        },
        "762": {
            "condition": "When answering about \"Japanese name of the set containing card 'Fellwar Stone'\", When the question mentions \"Japanese name\", When combining T1 and T2 for shared entities, When filtering for card \"Fellwar Stone\", When retrieving translations",
            "operation": " ensure T2.translation IS NOT NULL to exclude missing translations."
        },
        "763": {
            "condition": "When answering about card names in a specific set",
            "operation": " join the sets table (T2) with the cards table (T1) using an inner match where T2.code equals T1.setCode."
        },
        "764": {
            "condition": "When filtering by set name 'Journey into Nyx Hero's Path'",
            "operation": " apply the filter condition to T2.name with the exact literal 'Journey into Nyx Hero's Path'."
        },
        "765": {
            "condition": "When selecting the card name",
            "operation": " use T1.name instead of card_name."
        },
        "766": {
            "condition": "When ordering by converted mana cost",
            "operation": " use T1.convertedManaCost instead of converted_mana_cost and sort in descending order."
        },
        "767": {
            "condition": "When answering about card names in a specific set, When filtering by set name 'Journey into Nyx Hero's Path', When selecting the card name, When ordering by converted mana cost, When finding the highest value",
            "operation": " take only the top 1 row after descending ordering."
        },
        "768": {
            "condition": "When the question asks about a set name in Spanish like \"Ola de fr\u00edo\"",
            "operation": " use the set_translations table (T2) to find the translation instead of the sets table (T1) name column."
        },
        "769": {
            "condition": "When joining sets (T1) and set_translations (T2)",
            "operation": " link rows where T2.setCode equals T1.code and keep only matching pairs (inner match)."
        },
        "770": {
            "condition": "When filtering for a specific translation",
            "operation": " use T2.translation = 'Ola de fr\u00edo' exactly as specified with the exact case and punctuation."
        },
        "771": {
            "condition": "When the question asks about a set name in Spanish like \"Ola de fr\u00edo\", When joining sets (T1) and set_translations (T2), When filtering for a specific translation, When selecting the release date",
            "operation": " use T1.releaseDate (not release_date) as the correct column name."
        },
        "772": {
            "condition": "When the question asks for expansion type",
            "operation": " use column \"type\" from table \"sets\" instead of \"expansion_type\"."
        },
        "773": {
            "condition": "When filtering for a specific card name like \"Samite Pilgrim\"",
            "operation": " first find the set codes in table \"cards\" where \"name\" equals 'Samite Pilgrim', then use those set codes to filter the \"sets\" table."
        },
        "774": {
            "condition": "When combining card information with set information",
            "operation": " use the relationship where \"cards.setCode\" matches \"sets.code\" through a subquery approach."
        },
        "775": {
            "condition": "When the question asks for expansion type, When filtering for a specific card name like \"Samite Pilgrim\", When combining card information with set information, When selecting the final result",
            "operation": " output only the \"type\" column from the \"sets\" table."
        },
        "776": {
            "condition": "When counting cards",
            "operation": " count using the \"id\" column instead of counting all columns to avoid counting null values."
        },
        "777": {
            "condition": "When filtering by set name 'World Championship Decks 2004'",
            "operation": " use a subquery with \"setCode IN\" to properly reference the sets table relationship instead of direct \"set_name\" comparison."
        },
        "778": {
            "condition": "When filtering by converted mana cost of 3",
            "operation": " use \"convertedManaCost = 3\" to compare numeric values instead of \"mana_cost = '3'\" which compares string literals."
        },
        "779": {
            "condition": "When counting cards, When filtering by set name 'World Championship Decks 2004', When filtering by converted mana cost of 3, When comparing mana costs",
            "operation": " reference the numeric column \"convertedManaCost\" instead of the string column \"mana_cost\" for proper cost comparison."
        },
        "780": {
            "condition": "When the question asks for a Simplified Chinese translation",
            "operation": " use the column \"translation\" from table \"set_translations\" instead of \"english_name\" from \"sets\"."
        },
        "781": {
            "condition": "When retrieving translations for a specific language",
            "operation": " filter by \"language = 'Chinese Simplified'\" exactly as specified."
        },
        "782": {
            "condition": "When looking up translations for a set by name",
            "operation": " use a subquery condition \"setCode IN (SELECT code FROM sets WHERE name = 'Mirrodin')\" instead of direct filtering on set_name."
        },
        "783": {
            "condition": "When the question asks for a Simplified Chinese translation, When retrieving translations for a specific language, When looking up translations for a set by name, When the question mentions the set \"Mirrodin\"",
            "operation": " use the exact literal 'Mirrodin' for the name filter in the subquery."
        },
        "784": {
            "condition": "When answering about percentage of non-foil only sets with Japanese translations",
            "operation": " calculate using (number of sets where isNonFoilOnly ="
        },
        "785": {
            "condition": "divided by (total sets) multiplied by 100.",
            "operation": "divided by (total sets) multiplied by 100."
        },
        "786": {
            "condition": "When the question mentions \"cards that has Japanese translation\"",
            "operation": " this actually means sets where code exists in set_translations with language = 'Japanese'."
        },
        "787": {
            "condition": "When computing the percentage",
            "operation": " use CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) as the calculation formula."
        },
        "788": {
            "condition": "When querying for sets with Japanese translations",
            "operation": " filter using WHERE code IN (SELECT setCode FROM set_translations WHERE language = 'Japanese')."
        },
        "789": {
            "condition": "When answering about percentage of non-foil only sets with Japanese translations, divided by (total sets) multiplied by 100., When the question mentions \"cards that has Japanese translation\", When computing the percentage, When querying for sets with Japanese translations, When producing output",
            "operation": " do not include explicit column aliases in the final result."
        },
        "790": {
            "condition": "When answering about \"percentage of online-only sets for Brazilian Portuguese translations\"",
            "operation": " make sure the output order: percentage calculation as the single result."
        },
        "791": {
            "condition": "When the question mentions \"cards that has Brazil Portuguese translation\"",
            "operation": " \"Brazil Portuguese translation\" actually means \"sets with code matching set_translations where language = 'Portuguese (Brazil)'\" in schema."
        },
        "792": {
            "condition": "When querying from the sets table",
            "operation": " use T1 as the alias for the sets table."
        },
        "793": {
            "condition": "When counting online-only sets",
            "operation": " use SUM(CASE WHEN T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) to properly count boolean flags."
        },
        "794": {
            "condition": "When calculating percentage",
            "operation": " use CAST(SUM(CASE WHEN T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) for precise floating-point division."
        },
        "795": {
            "condition": "When filtering for Brazilian Portuguese translations",
            "operation": " use WHERE T1.code IN (SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)') instead of direct translation column comparison."
        },
        "796": {
            "condition": "When answering about \"percentage of online-only sets for Brazilian Portuguese translations\", When the question mentions \"cards that has Brazil Portuguese translation\", When querying from the sets table, When counting online-only sets, When calculating percentage, When filtering for Brazilian Portuguese translations, When combining sets and set_translations",
            "operation": " link rows where T1.code equals set_translations.setCode for the subquery condition."
        },
        "797": {
            "condition": "When the question asks for \"available printing types\"",
            "operation": " actually select the \"availability\" column from the cards table instead of \"printing_type\"."
        },
        "798": {
            "condition": "When filtering for cards created by Aleksi Briclot",
            "operation": " use the condition \"artist = 'Aleksi Briclot'\" instead of filtering on text_box_creator."
        },
        "799": {
            "condition": "When looking for cards that don't have a text box",
            "operation": " include the condition \"isTextless = 1\" to filter for textless cards."
        },
        "800": {
            "condition": "When the question asks for \"available printing types\", When filtering for cards created by Aleksi Briclot, When looking for cards that don't have a text box, When answering about available printing types of cards",
            "operation": " make sure the output order shows distinct availability values."
        },
        "801": {
            "condition": "When the question asks for the \"unique id of the set that has the highest number of cards\"",
            "operation": " use the column \"id\" from table \"sets\" as the output."
        },
        "802": {
            "condition": "When the question mentions \"highest number of cards\"",
            "operation": " this actually means ordering by \"baseSetSize\" in descending order."
        },
        "803": {
            "condition": "When the question asks for the \"unique id of the set that has the highest number of cards\", When the question mentions \"highest number of cards\", When the question asks for the highest ranked item",
            "operation": " return only the top 1 row after ordering by \"baseSetSize DESC\"."
        },
        "804": {
            "condition": "When answering about \"the unique id of the set that has the highest number of cards\"",
            "operation": " make sure the output order: id."
        },
        "805": {
            "condition": "When the question mentions \"unique id\"",
            "operation": " \"unique id\" actually means \"id in schema\"."
        },
        "806": {
            "condition": "When the question mentions \"highest number of cards\"",
            "operation": " \"highest number of cards\" actually means \"baseSetSize in schema\"."
        },
        "807": {
            "condition": "When answering about \"the unique id of the set that has the highest number of cards\", When the question mentions \"unique id\", When the question mentions \"highest number of cards\", When the question mentions \"highest\"",
            "operation": " rank rows by baseSetSize in descending direction and keep the first 1 row."
        },
        "808": {
            "condition": "When the question asks for \"illustrator\"",
            "operation": " use the exact column token \"artist\" from the cards table instead."
        },
        "809": {
            "condition": "When filtering for cards that don't have multiple faces on the same card",
            "operation": " use the condition \"side IS NULL\" instead of \"faces = 1\"."
        },
        "810": {
            "condition": "When ordering by converted mana cost",
            "operation": " use the exact column token \"convertedManaCost\" with descending order."
        },
        "811": {
            "condition": "When the question asks for \"illustrator\", When filtering for cards that don't have multiple faces on the same card, When ordering by converted mana cost, When finding the highest cost",
            "operation": " take only the top 1 result after ordering by \"convertedManaCost\" in descending order."
        },
        "812": {
            "condition": "When answering about \"most common visual frame effects among the incredibly powerful foils\"",
            "operation": " make sure the output order: frameEffects first, then the count."
        },
        "813": {
            "condition": "When the question mentions \"visual frame effects\"",
            "operation": " \"visual frame effects\" actually means \"frameEffects in schema\"."
        },
        "814": {
            "condition": "When the question mentions \"foils\"",
            "operation": " \"foils\" actually means \"cards with both cardKingdomFoilId IS NOT NULL and cardKingdomId IS NOT NULL in schema\"."
        },
        "815": {
            "condition": "When the question asks for \"most common\"",
            "operation": " rank rows by COUNT(frameEffects) in descending order and keep the first 1 row."
        },
        "816": {
            "condition": "When the question asks for \"count of frame effects\"",
            "operation": " compute the number of rows using the exact token frameEffects without an alias."
        },
        "817": {
            "condition": "When answering about \"most common visual frame effects among the incredibly powerful foils\", When the question mentions \"visual frame effects\", When the question mentions \"foils\", When the question asks for \"most common\", When the question asks for \"count of frame effects\", When filtering for foils",
            "operation": " apply both conditions cardKingdomFoilId IS NOT NULL and cardKingdomId IS NOT NULL instead of any power level condition."
        },
        "818": {
            "condition": "When answering about \"most common visual frame effects among the incredibly powerful foils\"",
            "operation": " make sure the output order: frameEffects only (without the count)."
        },
        "819": {
            "condition": "When the question mentions \"incredibly powerful foils\"",
            "operation": " \"incredibly powerful foils\" actually means records where both cardKingdomFoilId and cardKingdomId are not null in schema."
        },
        "820": {
            "condition": "When the question asks for \"most common\" frame effects",
            "operation": " rank rows by count of frameEffects in descending order and keep the first 1 row."
        },
        "821": {
            "condition": "When counting frame effects occurrences",
            "operation": " compute the number of rows using the frameEffects column for grouping and counting."
        },
        "822": {
            "condition": "When answering about \"most common visual frame effects among the incredibly powerful foils\", When the question mentions \"incredibly powerful foils\", When the question asks for \"most common\" frame effects, When counting frame effects occurrences, When producing output for \"most common\" queries",
            "operation": " return only the value column (frameEffects) without the count column."
        },
        "823": {
            "condition": "When counting cards with unknown power",
            "operation": " use SUM(CASE WHEN power = '*' OR power IS NULL THEN 1 ELSE 0 END) instead of COUNT(*) to count only specific power values."
        },
        "824": {
            "condition": "When filtering for cards that can't be found in foil",
            "operation": " filter on hasFoil = 0 instead of foil = 0 for the correct column name."
        },
        "825": {
            "condition": "When filtering for duel deck A",
            "operation": " filter on duelDeck = 'a' instead of duel_deck = 'A' for the correct column name and case sensitivity."
        },
        "826": {
            "condition": "When counting cards with unknown power, When filtering for cards that can't be found in foil, When filtering for duel deck A, When handling null power values",
            "operation": " remove the explicit power IS NULL filter from the WHERE clause since the null check is handled within the CASE expression."
        },
        "827": {
            "condition": "When the question asks about sets with expansion type 'Commander'",
            "operation": " filter sets where \"type\" equals 'commander' exactly (case-sensitive)."
        },
        "828": {
            "condition": "When the question asks for the set with highest total number of cards including promotional and related supplemental products",
            "operation": " order sets by \"totalSetSize\" in descending order and take the first result."
        },
        "829": {
            "condition": "When the question asks to indicate the id of the set",
            "operation": " select only the \"id\" column from the sets table."
        },
        "830": {
            "condition": "When working with the sets table",
            "operation": " use the base table directly without joining to other tables like cards."
        },
        "831": {
            "condition": "When the question asks about sets with expansion type 'Commander', When the question asks for the set with highest total number of cards including promotional and related supplemental products, When the question asks to indicate the id of the set, When working with the sets table, When retrieving the largest total set size",
            "operation": " do not perform aggregation or grouping since the totalSetSize column already contains the pre-calculated value."
        },
        "832": {
            "condition": "When the question asks about \"duels\"",
            "operation": " filter cards to only those where the card's uuid appears in the legalities table with format exactly equal to 'duel'."
        },
        "833": {
            "condition": "When selecting card names",
            "operation": " use the exact column name \"name\" instead of \"card_name\"."
        },
        "834": {
            "condition": "When ordering by mana cost",
            "operation": " use the exact column name \"manaCost\" instead of \"mana_cost\"."
        },
        "835": {
            "condition": "When retrieving top 10 cards",
            "operation": " use LIMIT 0, 10 to get the first 10 rows starting from position 0."
        },
        "836": {
            "condition": "When selecting distinct card names",
            "operation": " include DISTINCT to return only unique card names."
        },
        "837": {
            "condition": "When the question asks about \"duels\", When selecting card names, When ordering by mana cost, When retrieving top 10 cards, When selecting distinct card names, When combining cards and legalities tables",
            "operation": " link rows where cards.uuid = legalities.uuid to find duel-legal cards."
        },
        "838": {
            "condition": "When answering about \"top 10 cards with highest unconverted mana cost\"",
            "operation": " make sure the output order includes only the card name and excludes the manaCost column from the final results."
        },
        "839": {
            "condition": "When the question mentions \"highest unconverted mana cost\"",
            "operation": " use the \"manaCost\" column from table \"cards\" for ordering in descending direction."
        },
        "840": {
            "condition": "When the question asks for \"top 10 cards\"",
            "operation": " rank rows by \"manaCost\" in descending order and keep the first 10 rows."
        },
        "841": {
            "condition": "When filtering for \"duels\" format",
            "operation": " ensure cards are filtered using the condition where \"format\" equals 'duel' in the \"legalities\" table."
        },
        "842": {
            "condition": "When answering about \"top 10 cards with highest unconverted mana cost\", When the question mentions \"highest unconverted mana cost\", When the question asks for \"top 10 cards\", When filtering for \"duels\" format, When combining cards and legalities tables",
            "operation": " link rows where the canonical key \"uuid\" from both tables are equal and keep only matching pairs (inner match)."
        },
        "843": {
            "condition": "When answering about \"oldest mythic card\"",
            "operation": " make sure the output order: \"originalReleaseDate\" then \"format\"."
        },
        "844": {
            "condition": "When the question mentions \"mythic card\"",
            "operation": " \"mythic\" actually means \"rarity = 'mythic'\" in schema."
        },
        "845": {
            "condition": "When combining T1 (cards) and T2 (legalities) for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid and keep only matching pairs (inner match)."
        },
        "846": {
            "condition": "When filtering for legal play formats",
            "operation": " include only rows where T2.status = 'Legal'."
        },
        "847": {
            "condition": "When handling date filtering",
            "operation": " exclude rows where T1.originalReleaseDate IS NOT NULL."
        },
        "848": {
            "condition": "When ordering by release date",
            "operation": " sort by T1.originalReleaseDate in ascending order to find the oldest card."
        },
        "849": {
            "condition": "When answering about \"oldest mythic card\", When the question mentions \"mythic card\", When combining T1 (cards) and T2 (legalities) for shared entities, When filtering for legal play formats, When handling date filtering, When ordering by release date, When selecting the oldest card",
            "operation": " take only the first row after ordering by T1.originalReleaseDate."
        },
        "850": {
            "condition": "When counting cards",
            "operation": " use COUNT(T3.id) to count distinct card IDs instead of COUNT(*)"
        },
        "851": {
            "condition": "When joining cards and foreign_data tables",
            "operation": " link rows where T2.uuid = T1.uuid using an inner match"
        },
        "852": {
            "condition": "When filtering for artist Volkan Ba\u01f5a",
            "operation": " use T1.artist = 'Volkan Ba\u01f5a' with the correct character encoding"
        },
        "853": {
            "condition": "When filtering for French language",
            "operation": " use T2.language = 'French' from the foreign_data table"
        },
        "854": {
            "condition": "When counting cards, When joining cards and foreign_data tables, When filtering for artist Volkan Ba\u01f5a, When filtering for French language, When ensuring distinct card counting",
            "operation": " add GROUP BY T1.id to group by card IDs"
        },
        "855": {
            "condition": "When counting cards",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "856": {
            "condition": "When the question mentions \"play format status\"",
            "operation": " this actually means T2.status in the legalities table."
        },
        "857": {
            "condition": "When filtering for legal status",
            "operation": " use T2.status = 'Legal' with exact case matching."
        },
        "858": {
            "condition": "When filtering for card type",
            "operation": " use T1.types = 'Enchantment' with exact case matching instead of 'enchantment'."
        },
        "859": {
            "condition": "When combining cards and legalities tables",
            "operation": " link rows where T2.uuid = T1.uuid using inner join to keep only matching pairs."
        },
        "860": {
            "condition": "When counting cards, When the question mentions \"play format status\", When filtering for legal status, When filtering for card type, When combining cards and legalities tables, When the question asks about cards with specific properties",
            "operation": " include filters for T1.rarity = 'rare' and T1.name = 'Abundance'."
        },
        "861": {
            "condition": "When the question mentions \"rare\" rarity",
            "operation": " use the exact literal value 'rare' (lowercase) for rarity comparison."
        },
        "862": {
            "condition": "When the question mentions \"enchantment\" type",
            "operation": " use exact string equality comparison with T1.types = 'Enchantment' instead of pattern matching."
        },
        "863": {
            "condition": "When combining cards (T1) and legalities (T2) tables",
            "operation": " link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match)."
        },
        "864": {
            "condition": "When filtering for cards named 'Abundance'",
            "operation": " use exact string equality T1.name = 'Abundance'."
        },
        "865": {
            "condition": "When the question mentions \"rare\" rarity, When the question mentions \"enchantment\" type, When combining cards (T1) and legalities (T2) tables, When filtering for cards named 'Abundance', When filtering for legal status",
            "operation": " use exact string equality T2.status = 'Legal'."
        },
        "866": {
            "condition": "When answering about \"play format with highest number of banned status\"",
            "operation": " use a CTE named MaxBanned to find the format with the most banned cards instead of querying directly from the cards table."
        },
        "867": {
            "condition": "When selecting data for banned cards",
            "operation": " select from the legalities table instead of the cards table for the main query."
        },
        "868": {
            "condition": "When combining legalities and cards tables",
            "operation": " use INNER JOIN between legalities and cards on uuid instead of querying only the cards table."
        },
        "869": {
            "condition": "When joining to the MaxBanned CTE",
            "operation": " add a second INNER JOIN to the MaxBanned CTE on format instead of not joining to the CTE."
        },
        "870": {
            "condition": "When filtering for banned status",
            "operation": " filter on T2.status = 'Banned' in the WHERE clause instead of filtering only on the cards table."
        },
        "871": {
            "condition": "When selecting output columns",
            "operation": " select specific columns T2.format and T1.name instead of aggregating with COUNT and GROUP_CONCAT."
        },
        "872": {
            "condition": "When answering about \"play format with highest number of banned status\", When selecting data for banned cards, When combining legalities and cards tables, When joining to the MaxBanned CTE, When filtering for banned status, When selecting output columns, When handling grouping and ordering",
            "operation": " remove the GROUP BY play_format and ORDER BY banned_count DESC LIMIT 1 from the main query, as the limiting logic is handled in the CTE."
        },
        "873": {
            "condition": "When answering about the language of a specific set",
            "operation": " query the \"set_translations\" table instead of the \"sets\" table."
        },
        "874": {
            "condition": "When filtering by set name \"Battlebond\"",
            "operation": " use a subquery to filter by id IN (SELECT id FROM sets WHERE name = 'Battlebond') instead of directly filtering the sets table."
        },
        "875": {
            "condition": "When answering about the language of a specific set, When filtering by set name \"Battlebond\", When retrieving language information",
            "operation": " get the \"language\" column from \"set_translations\" instead of from \"sets\"."
        },
        "876": {
            "condition": "When joining set_translations and sets tables",
            "operation": " use the foreign key relationship where set_translations.setCode equals sets.code to link the tables correctly."
        },
        "877": {
            "condition": "When filtering for the 'Battlebond' set",
            "operation": " use the exact literal 'Battlebond' with the correct case and spelling in the condition."
        },
        "878": {
            "condition": "When selecting the language from set_translations",
            "operation": " ensure the output column is language from the set_translations table."
        },
        "879": {
            "condition": "When joining set_translations and sets tables, When filtering for the 'Battlebond' set, When selecting the language from set_translations, When using subqueries for filtering",
            "operation": " reference the correct identifier columns where the subquery should return sets.code values that match set_translations.setCode values for proper correlation."
        },
        "880": {
            "condition": "When the question asks about \"illustrator\"",
            "operation": " use the exact column token \"artist\" from the cards table instead."
        },
        "881": {
            "condition": "When counting cards illustrated by an artist",
            "operation": " count using the canonical key \"id\" from the cards table (COUNT(id)) rather than counting all columns."
        },
        "882": {
            "condition": "When combining card and legality information",
            "operation": " perform an inner join between cards table (T1) and legalities table (T2) where T1.uuid = T2.uuid to match related data."
        },
        "883": {
            "condition": "When accessing format of play information",
            "operation": " retrieve the \"format\" column from the legalities table (T2) rather than from the cards table."
        },
        "884": {
            "condition": "When grouping results by artist",
            "operation": " group by the \"artist\" column from the cards table."
        },
        "885": {
            "condition": "When the question asks about \"illustrator\", When counting cards illustrated by an artist, When combining card and legality information, When accessing format of play information, When grouping results by artist, When finding the illustrator with the least amount of cards",
            "operation": " order by the count of cards (COUNT(id)) in ascending order and take only the first result."
        },
        "886": {
            "condition": "When finding the illustrator with the least amount of cards",
            "operation": " rank artists by the count of their cards in ascending order and keep only the first artist (lowest count)."
        },
        "887": {
            "condition": "When combining cards and legalities tables",
            "operation": " link rows where T2.uuid = T1.uuid exactly and keep only matching pairs (inner match)."
        },
        "888": {
            "condition": "When the question asks for the format of play of cards",
            "operation": " include T2.format in the output columns."
        },
        "889": {
            "condition": "When organizing results for the artist with fewest cards",
            "operation": " group by T1.artist only, not by format."
        },
        "890": {
            "condition": "When finding the illustrator with the least amount of cards, When combining cards and legalities tables, When the question asks for the format of play of cards, When organizing results for the artist with fewest cards, When answering about the illustrator and their card formats",
            "operation": " make sure the output order includes T1.artist and T2.format."
        },
        "891": {
            "condition": "When answering about \"the illustrator that illustrated the least amount of cards\"",
            "operation": " rank artists by the count of cards they illustrated in ascending order and keep only the top 1 artist."
        },
        "892": {
            "condition": "When counting cards per artist",
            "operation": " use T1.id as the counting key to determine how many cards each artist illustrated."
        },
        "893": {
            "condition": "When the question asks for format of play information",
            "operation": " do not include T2.format in the output columns since the question only asks for the illustrator, not the card formats."
        },
        "894": {
            "condition": "When grouping results by artist",
            "operation": " group only by T1.artist without including additional grouping columns."
        },
        "895": {
            "condition": "When answering about \"the illustrator that illustrated the least amount of cards\", When counting cards per artist, When the question asks for format of play information, When grouping results by artist, When ordering results by card count",
            "operation": " use ORDER BY COUNT(T1.id) ASC to sort artists from fewest to most cards illustrated."
        },
        "896": {
            "condition": "When answering about \"the illustrator that illustrated the least amount of cards\"",
            "operation": " count the number of cards using T1.id as the counting key for each T1.artist, then rank artists by this count in ascending order and keep the first 1 row."
        },
        "897": {
            "condition": "When the question asks to \"list the format of play of the cards that he/she illustrated\"",
            "operation": " include T2.format in the output columns and group by both T1.artist and T2.format to ensure proper aggregation."
        },
        "898": {
            "condition": "When answering about \"the illustrator that illustrated the least amount of cards\", When the question asks to \"list the format of play of the cards that he/she illustrated\", When combining cards T1 and legalities T2",
            "operation": " link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match)."
        },
        "899": {
            "condition": "When counting the number of cards illustrated by each artist",
            "operation": " count using the canonical key T1.id for cards."
        },
        "900": {
            "condition": "When grouping by artist to find who illustrated the least amount of cards",
            "operation": " group only by T1.artist without including T2.format in the grouping."
        },
        "901": {
            "condition": "When the question asks for the format of play of cards illustrated by the artist with the least illustrations",
            "operation": " include T2.format in the output columns but do not aggregate or group by it."
        },
        "902": {
            "condition": "When counting the number of cards illustrated by each artist, When grouping by artist to find who illustrated the least amount of cards, When the question asks for the format of play of cards illustrated by the artist with the least illustrations, When ordering results to find the illustrator with the least amount of cards",
            "operation": " order by the count of T1.id in ascending order and take only the first result."
        },
        "903": {
            "condition": "When answering about card status in legacy format",
            "operation": " make sure the output order: T2.status"
        },
        "904": {
            "condition": "When the question mentions \"version of frame style is 1997\"",
            "operation": " \"frame style\" actually means \"T1.frameVersion in schema\" and use numeric comparison without quotes"
        },
        "905": {
            "condition": "When the question mentions \"illustrated by D. Alexander Gregory\"",
            "operation": " \"illustrated by\" actually means \"T1.artist in schema\" with exact literal 'D. Alexander Gregory'"
        },
        "906": {
            "condition": "When the question mentions \"sensitive content or Wizards of the Coast\"",
            "operation": " this actually means \"T1.hasContentWarning = 1\" in schema"
        },
        "907": {
            "condition": "When the question asks about \"legacy play format\"",
            "operation": " this actually means filtering on \"T2.format = 'legacy'\" in the legalities table"
        },
        "908": {
            "condition": "When combining cards and legalities tables",
            "operation": " link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match)"
        },
        "909": {
            "condition": "When answering about card status in legacy format, When the question mentions \"version of frame style is 1997\", When the question mentions \"illustrated by D. Alexander Gregory\", When the question mentions \"sensitive content or Wizards of the Coast\", When the question asks about \"legacy play format\", When combining cards and legalities tables, When selecting status from legalities",
            "operation": " use SELECT DISTINCT T2.status to get unique status values"
        },
        "910": {
            "condition": "When answering about \"cards ranked 1st on EDHRec\"",
            "operation": " make sure the output order: T1.name, T2.format"
        },
        "911": {
            "condition": "When the question mentions \"cards name\"",
            "operation": " \"cards name\" actually means \"T1.name in schema\""
        },
        "912": {
            "condition": "When the question mentions \"banned play format\"",
            "operation": " \"banned play format\" actually means \"T2.format where T2.status = 'Banned'\""
        },
        "913": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match)"
        },
        "914": {
            "condition": "When filtering for rank 1 on EDHRec",
            "operation": " use T1.edhrecRank = 1 instead of generic rank"
        },
        "915": {
            "condition": "When grouping results",
            "operation": " organize by T1.name and T2.format to show each card's banned formats"
        },
        "916": {
            "condition": "When answering about \"cards ranked 1st on EDHRec\", When the question mentions \"cards name\", When the question mentions \"banned play format\", When combining T1 and T2 for shared entities, When filtering for rank 1 on EDHRec, When grouping results, When producing output",
            "operation": " do not include ORDER BY clause as the question doesn't specify ordering"
        },
        "917": {
            "condition": "When calculating the annual average number of sets",
            "operation": " use (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4 instead of AVG(num_parts)."
        },
        "918": {
            "condition": "When combining data from sets and set_translations tables",
            "operation": " perform an INNER JOIN between T1 (sets) and T2 (set_translations) using T1.id = T2.id."
        },
        "919": {
            "condition": "When filtering by release date range",
            "operation": " use T1.releaseDate instead of release_date with the range '2012-01-01' to '2015-12-31'."
        },
        "920": {
            "condition": "When grouping results",
            "operation": " group by T1.releaseDate instead of language."
        },
        "921": {
            "condition": "When ordering and limiting results",
            "operation": " order by COUNT(T2.language) in descending order and keep only the top 1 result."
        },
        "922": {
            "condition": "When calculating the annual average number of sets, When combining data from sets and set_translations tables, When filtering by release date range, When grouping results, When ordering and limiting results, When presenting output",
            "operation": " do not use the alias avg_sets for the calculated result."
        },
        "923": {
            "condition": "When the question asks for artists who illustrated cards",
            "operation": " select the exact column \"artist\" from the \"cards\" table instead of joining to an \"artists\" table."
        },
        "924": {
            "condition": "When filtering for black border cards",
            "operation": " use the exact condition \"BorderColor = 'black'\" with the literal value 'black' exactly as specified."
        },
        "925": {
            "condition": "When filtering for arena-only availability",
            "operation": " use the exact condition \"availability = 'arena'\" with the literal value 'arena' exactly as specified."
        },
        "926": {
            "condition": "When the question asks for artists who illustrated cards, When filtering for black border cards, When filtering for arena-only availability, When answering about card illustrations",
            "operation": " query only the \"cards\" table directly instead of joining to other tables like \"artists\" or \"sets\"."
        },
        "927": {
            "condition": "When answering about \"uuid of cards in which the old school format is restricted or banned\"",
            "operation": " make sure the output order: uuid from the legalities table."
        },
        "928": {
            "condition": "When the question mentions \"old school format\"",
            "operation": " \"old school format\" actually means \"format = 'oldschool' in the legalities table\"."
        },
        "929": {
            "condition": "When the question mentions \"restricted or banned\"",
            "operation": " \"restricted or banned\" actually means \"status values 'Banned' and 'Restricted' in the legalities table\"."
        },
        "930": {
            "condition": "When filtering for format and status conditions",
            "operation": " use AND logic to combine format = 'oldschool' with status IN ('Banned', 'Restricted') instead of OR between different format values."
        },
        "931": {
            "condition": "When answering about \"uuid of cards in which the old school format is restricted or banned\", When the question mentions \"old school format\", When the question mentions \"restricted or banned\", When filtering for format and status conditions, When handling text literals",
            "operation": " use exact values 'oldschool' for format, 'Banned' and 'Restricted' for status with exact case and spelling as shown in the amends."
        },
        "932": {
            "condition": "When the question mentions \"card designed by Matthew D. Wilson\"",
            "operation": " \"designed by Matthew D. Wilson\" actually means \"artist = 'Matthew D. Wilson' in schema\" using exact literal value."
        },
        "933": {
            "condition": "When counting cards",
            "operation": " compute the number of rows using the canonical key token \"id\" instead of counting all columns to avoid counting null values."
        },
        "934": {
            "condition": "When the question mentions \"card designed by Matthew D. Wilson\", When counting cards, When filtering for availability \"only in the paper\"",
            "operation": " use exact literal value \"paper\" for the availability condition."
        },
        "935": {
            "condition": "When answering about rulings for cards by a specific artist",
            "operation": " join cards table as T1 with rulings table as T2 using T2.uuid = T1.uuid to link cards to their rulings."
        },
        "936": {
            "condition": "When the question mentions \"card named and designed by Kev Walker\"",
            "operation": " filter on T1.artist = 'Kev Walker' to find cards created by that artist."
        },
        "937": {
            "condition": "When selecting ruling information",
            "operation": " output T2.text as the ruling content instead of separate date and text columns."
        },
        "938": {
            "condition": "When ordering by dates in descending order",
            "operation": " sort by T2.date DESC to show most recent rulings first."
        },
        "939": {
            "condition": "When answering about rulings for cards by a specific artist, When the question mentions \"card named and designed by Kev Walker\", When selecting ruling information, When ordering by dates in descending order, When combining cards and rulings tables",
            "operation": " use inner join on T2.uuid = T1.uuid to ensure only matching card-ruling pairs are included."
        },
        "940": {
            "condition": "When answering about cards in a specific set",
            "operation": " filter cards using the set code from the sets table where the set name matches 'Hour of Devastation' exactly."
        },
        "941": {
            "condition": "When joining legalities and cards tables",
            "operation": " link rows where T2.uuid = T1.uuid exactly as shown in the schema."
        },
        "942": {
            "condition": "When determining legal formats",
            "operation": " use a CASE expression that returns T1.format only when T1.status equals 'Legal' exactly."
        },
        "943": {
            "condition": "When selecting card names and formats",
            "operation": " use SELECT DISTINCT to return unique combinations of T2.name and the CASE expression result."
        },
        "944": {
            "condition": "When answering about cards in a specific set, When joining legalities and cards tables, When determining legal formats, When selecting card names and formats, When filtering by set name",
            "operation": " use a subquery with T2.setCode IN (SELECT code FROM sets WHERE name = 'Hour of Devastation') instead of direct set_name comparison."
        },
        "945": {
            "condition": "When answering about sets with Korean translation but no Japanese translation",
            "operation": " use a subquery to filter sets based on translation metadata instead of direct column checks."
        },
        "946": {
            "condition": "When filtering sets by translation availability",
            "operation": " check for sets where code exists in the subquery results from set_translations where language equals 'Korean' and language does not contain 'Japanese'."
        },
        "947": {
            "condition": "When handling translation metadata",
            "operation": " use the exact literal 'Korean' for Korean translations and the pattern '%Japanese%' to exclude Japanese translations."
        },
        "948": {
            "condition": "When answering about sets with Korean translation but no Japanese translation, When filtering sets by translation availability, When handling translation metadata, When selecting output",
            "operation": " return only the name column from the sets table."
        },
        "949": {
            "condition": "When answering about \"sets which doesn't have Japanese translation but have Korean translation\"",
            "operation": " make sure the output order: s.name only."
        },
        "950": {
            "condition": "When the question mentions \"sets\"",
            "operation": " \"sets\" actually means \"s.name in schema\"."
        },
        "951": {
            "condition": "When filtering for Korean translations",
            "operation": " use exact literal 'Korean' for st.language."
        },
        "952": {
            "condition": "When excluding Japanese translations",
            "operation": " use condition language NOT LIKE '%Japanese%' within the same subquery."
        },
        "953": {
            "condition": "When combining set and translation information",
            "operation": " link rows where st.setCode matches s.code."
        },
        "954": {
            "condition": "When answering about \"sets which doesn't have Japanese translation but have Korean translation\", When the question mentions \"sets\", When filtering for Korean translations, When excluding Japanese translations, When combining set and translation information, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Korean' or '%Japanese%'."
        },
        "955": {
            "condition": "When answering about sets with Korean translation but no Japanese translation",
            "operation": " use a single subquery to filter set_translations where language equals 'Korean' and language does not contain 'Japanese'"
        },
        "956": {
            "condition": "When filtering set translations",
            "operation": " check for exact language match to 'Korean' and use pattern matching with NOT LIKE '%Japanese%' to exclude Japanese translations"
        },
        "957": {
            "condition": "When selecting set names",
            "operation": " maintain the SELECT name FROM sets structure and filter using the optimized subquery approach"
        },
        "958": {
            "condition": "When answering about sets with Korean translation but no Japanese translation, When filtering set translations, When selecting set names, When combining conditions for language filtering",
            "operation": " place both language = 'Korean' and language NOT LIKE '%Japanese%' conditions at the same subquery level instead of using nested NOT IN structures"
        },
        "959": {
            "condition": "When answering about \"frame styles and cards Allen Williams worked on\"",
            "operation": " make sure the output order: T1.frameVersion, T1.name, and a conditional expression for banned status."
        },
        "960": {
            "condition": "When the question mentions \"frame styles\"",
            "operation": " \"frame styles\" actually means \"T1.frameVersion in schema\"."
        },
        "961": {
            "condition": "When the question mentions \"cards\"",
            "operation": " \"cards\" actually means \"T1.name in schema\"."
        },
        "962": {
            "condition": "When the question asks about \"banned cards\"",
            "operation": " use a conditional expression IIF(T2.status = 'Banned', T1.name, 'NO') to determine banned status."
        },
        "963": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.uuid = T2.uuid exactly as shown; keep only matching pairs (inner match)."
        },
        "964": {
            "condition": "When filtering for Allen Williams",
            "operation": " use T1.artist = 'Allen Williams' with exact literal 'Allen Williams'."
        },
        "965": {
            "condition": "When returning results",
            "operation": " use DISTINCT to remove duplicate rows."
        },
        "966": {
            "condition": "When answering about \"frame styles and cards Allen Williams worked on\", When the question mentions \"frame styles\", When the question mentions \"cards\", When the question asks about \"banned cards\", When combining T1 and T2 for shared entities, When filtering for Allen Williams, When returning results, When producing output",
            "operation": " do not include any ORDER BY clause as the question does not require ordering."
        }
    },
    "codebase_community": {
        "0": {
            "condition": "When the question asks about user names and reputation",
            "operation": " use \"DisplayName\" instead of \"name\" and \"Reputation\" instead of \"reputation\" with exact case sensitivity."
        },
        "1": {
            "condition": "When filtering for specific user names like 'Harlan' or 'Jarrod Dixon'",
            "operation": " use IN with a list of exact string literals instead of multiple OR conditions."
        },
        "2": {
            "condition": "When finding the user with the highest reputation among specified names",
            "operation": " compute the maximum reputation value using MAX(Reputation) and then filter for users matching that maximum value."
        },
        "3": {
            "condition": "When the question asks about user names and reputation, When filtering for specific user names like 'Harlan' or 'Jarrod Dixon', When finding the user with the highest reputation among specified names, When outputting results",
            "operation": " only show the DisplayName column and remove explicit reputation output since the question only asks which user has higher reputation."
        },
        "4": {
            "condition": "When the question asks for \"display names\"",
            "operation": " use the exact column token \"DisplayName\" from the users table."
        },
        "5": {
            "condition": "When filtering by year of account creation",
            "operation": " extract the year from the \"CreationDate\" column using STRFTIME('%Y', CreationDate) function."
        },
        "6": {
            "condition": "When comparing the extracted year to 2011",
            "operation": " use the string literal '2011' instead of integer 2011 for proper type matching."
        },
        "7": {
            "condition": "When the question asks for \"display names\", When filtering by year of account creation, When comparing the extracted year to 2011, When answering about users created in a specific year",
            "operation": " ensure the output order includes only the DisplayName column as requested."
        },
        "8": {
            "condition": "When counting users",
            "operation": " use COUNT(Id) instead of COUNT(*) to count only non-null user IDs."
        },
        "9": {
            "condition": "When referencing the last access date column",
            "operation": " use the exact column name \"LastAccessDate\" instead of \"last_access_date\"."
        },
        "10": {
            "condition": "When comparing date values",
            "operation": " apply the date() function to \"LastAccessDate\" instead of comparing the raw timestamp value directly."
        },
        "11": {
            "condition": "When counting users, When referencing the last access date column, When comparing date values, When specifying date literals",
            "operation": " use ISO date format '2014-09-01' instead of '2014/9/1' for proper date comparison semantics."
        },
        "12": {
            "condition": "When answering about \"the user who has the most number of views\"",
            "operation": " use the exact column token \"DisplayName\" from the users table to return the display name."
        },
        "13": {
            "condition": "When finding the user with maximum views",
            "operation": " compare each user's \"Views\" value against the maximum value calculated from the entire users table using a subquery."
        },
        "14": {
            "condition": "When handling ties for maximum views",
            "operation": " use a correlated subquery approach that will return all users who have the maximum views value rather than limiting to just one row."
        },
        "15": {
            "condition": "When answering about \"the user who has the most number of views\", When finding the user with maximum views, When handling ties for maximum views, When selecting output columns",
            "operation": " ensure the output order contains only \"DisplayName\" as specified in the question."
        },
        "16": {
            "condition": "When counting users",
            "operation": " use COUNT(id) instead of COUNT(*) to count non-null IDs rather than all rows."
        },
        "17": {
            "condition": "When filtering by creation year",
            "operation": " use STRFTIME('%Y', CreationDate) > '2013' instead of direct date comparison to filter by year rather than specific date."
        },
        "18": {
            "condition": "When referencing the views column",
            "operation": " use Views instead of views with proper column name casing."
        },
        "19": {
            "condition": "When counting users, When filtering by creation year, When referencing the views column, When referencing the creation date column",
            "operation": " use CreationDate instead of created_at as the column name."
        },
        "20": {
            "condition": "When counting posts",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "21": {
            "condition": "When answering about posts owned by a user",
            "operation": " add INNER JOIN users AS T2 to combine the posts and users tables."
        },
        "22": {
            "condition": "When combining posts and users tables",
            "operation": " link rows where T1.OwnerUserId = T2.Id exactly and keep only matching pairs (inner match)."
        },
        "23": {
            "condition": "When counting posts, When answering about posts owned by a user, When combining posts and users tables, When filtering by username 'csgillespie'",
            "operation": " use WHERE T2.DisplayName = 'csgillespie' to properly reference the joined users table instead of filtering by username directly."
        },
        "24": {
            "condition": "When answering about \"posts owned by user csgillespie\"",
            "operation": " make sure to join posts AS T1 with users AS T2 on T1.OwnerUserId = T2.Id and keep only matching pairs (inner match)."
        },
        "25": {
            "condition": "When the question mentions \"user csgillespie\"",
            "operation": " \"csgillespie\" actually means T2.DisplayName = 'csgillespie' in schema."
        },
        "26": {
            "condition": "When selecting post titles",
            "operation": " use T1.Title with proper table alias instead of unqualified title."
        },
        "27": {
            "condition": "When answering about \"posts owned by user csgillespie\", When the question mentions \"user csgillespie\", When selecting post titles, When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.OwnerUserId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "28": {
            "condition": "When the question asks for \"owner\" of a post",
            "operation": " use \"T2.DisplayName\" instead of \"owner\" to get the user's display name."
        },
        "29": {
            "condition": "When joining posts table (T1) with users table (T2)",
            "operation": " link rows where \"T1.OwnerUserId = T2.Id\" using an inner join."
        },
        "30": {
            "condition": "When the question asks for \"owner\" of a post, When joining posts table (T1) with users table (T2), When filtering by post title",
            "operation": " use exact literal match with \"title = 'Eliciting priors from experts'\" including the exact case and spacing of the title."
        },
        "31": {
            "condition": "When answering about \"posts owned by csgillespie\"",
            "operation": " join table \"posts AS T1\" with table \"users AS T2\" where T1.OwnerUserId equals T2.Id and keep only matching pairs (inner match)."
        },
        "32": {
            "condition": "When the question mentions \"csgillespie\"",
            "operation": " \"csgillespie\" actually means \"T2.DisplayName = 'csgillespie'\" in schema."
        },
        "33": {
            "condition": "When the question asks for \"title of the post\"",
            "operation": " select T1.Title as the output column."
        },
        "34": {
            "condition": "When answering about \"posts owned by csgillespie\", When the question mentions \"csgillespie\", When the question asks for \"title of the post\", When the question mentions \"highest popularity\"",
            "operation": " \"popularity\" actually means \"T1.ViewCount\" in schema, and rank rows by T1.ViewCount in descending order and keep the first 1 row."
        },
        "35": {
            "condition": "When combining posts and users tables",
            "operation": " link rows where T1.OwnerUserId = T2.Id and keep only matching pairs (inner match)."
        },
        "36": {
            "condition": "When the question asks for the \"most valuable post\"",
            "operation": " rank posts by T1.FavoriteCount in descending order and keep the first 1 row."
        },
        "37": {
            "condition": "When the question asks for \"display name of the user\"",
            "operation": " select T2.DisplayName as the output column."
        },
        "38": {
            "condition": "When combining posts and users tables, When the question asks for the \"most valuable post\", When the question asks for \"display name of the user\", When producing output",
            "operation": " return only the single row with the highest T1.FavoriteCount value."
        },
        "39": {
            "condition": "When answering about \"total number of comments of all the posts owned by csgillespie\"",
            "operation": " make sure the output order: SUM(T1.CommentCount)."
        },
        "40": {
            "condition": "When the question mentions \"csgillespie\"",
            "operation": " \"csgillespie\" actually means \"T2.DisplayName = 'csgillespie'\" in schema."
        },
        "41": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.OwnerUserId = T2.Id; keep only matching pairs (inner match)."
        },
        "42": {
            "condition": "When answering about \"total number of comments of all the posts owned by csgillespie\", When the question mentions \"csgillespie\", When combining T1 and T2 for shared entities, When calculating total comments",
            "operation": " use SUM(T1.CommentCount) to sum existing comment counts rather than counting comment rows."
        },
        "43": {
            "condition": "When answering about \"the post that got the most number of answers owned by csgillespie\"",
            "operation": " use MAX(T1.AnswerCount) instead of COUNT(*) to find the maximum answer count."
        },
        "44": {
            "condition": "When the question mentions \"posts\"",
            "operation": " use \"posts AS T1\" as the primary table source instead of answers."
        },
        "45": {
            "condition": "When combining posts and users for shared entities",
            "operation": " link rows where T1.OwnerUserId = T2.Id using INNER JOIN users AS T2."
        },
        "46": {
            "condition": "When filtering for user csgillespie",
            "operation": " use WHERE T2.DisplayName = 'csgillespie' exactly as specified."
        },
        "47": {
            "condition": "When answering about \"the post that got the most number of answers owned by csgillespie\", When the question mentions \"posts\", When combining posts and users for shared entities, When filtering for user csgillespie, When finding the maximum value",
            "operation": " remove ORDER BY and LIMIT clauses as MAX function achieves the same result more efficiently."
        },
        "48": {
            "condition": "When combining posts and users tables",
            "operation": " link rows where T1.LastEditorUserId equals T2.Id exactly as shown in the amends and keep only matching pairs (inner match)."
        },
        "49": {
            "condition": "When selecting the display name",
            "operation": " use T2.DisplayName instead of display_name from the base table."
        },
        "50": {
            "condition": "When the question asks for the user who last edited a specific post",
            "operation": " filter posts where T1.title equals 'Examples for teaching: Correlation does not mean causation' exactly as specified."
        },
        "51": {
            "condition": "When using table aliases",
            "operation": " assign posts as T1 and users as T2 exactly as shown in the amends."
        },
        "52": {
            "condition": "When combining posts and users tables, When selecting the display name, When the question asks for the user who last edited a specific post, When using table aliases, When retrieving the last editor",
            "operation": " do not use ORDER BY creation_date DESC LIMIT 1 subquery logic, instead use the direct join relationship between posts and users tables."
        },
        "53": {
            "condition": "When answering about posts owned by a specific user",
            "operation": " join the posts table (T1) with the users table (T2) where T1.OwnerUserId equals T2.Id to correctly link posts to users."
        },
        "54": {
            "condition": "When filtering for posts owned by 'csgillespie'",
            "operation": " use T2.DisplayName = 'csgillespie' instead of directly filtering on owner field."
        },
        "55": {
            "condition": "When counting posts",
            "operation": " count T1.Id instead of using COUNT(*) for more precise counting."
        },
        "56": {
            "condition": "When answering about posts owned by a specific user, When filtering for posts owned by 'csgillespie', When counting posts, When identifying root posts",
            "operation": " check if T1.ParentId is NULL to find posts without parent posts."
        },
        "57": {
            "condition": "When selecting display names from users",
            "operation": " use \"T2.DisplayName\" as the output column."
        },
        "58": {
            "condition": "When combining posts and users tables",
            "operation": " use aliases \"posts AS T1\" and \"users AS T2\"."
        },
        "59": {
            "condition": "When joining posts and users tables",
            "operation": " link rows where \"T1.OwnerUserId = T2.Id\" exactly."
        },
        "60": {
            "condition": "When filtering for well-finished posts",
            "operation": " use condition \"T1.ClosedDate IS NOT NULL\" instead of status values."
        },
        "61": {
            "condition": "When selecting display names from users, When combining posts and users tables, When joining posts and users tables, When filtering for well-finished posts, When answering about users who own posts",
            "operation": " ensure the join is an inner match keeping only users with matching posts."
        },
        "62": {
            "condition": "When counting posts",
            "operation": " use COUNT(T1.Id) instead of COUNT(*) to count specific non-null values."
        },
        "63": {
            "condition": "When combining posts and users tables",
            "operation": " link rows using INNER JOIN where T1.OwnerUserId = T2.Id and keep only matching pairs."
        },
        "64": {
            "condition": "When filtering for elder users",
            "operation": " use T2.Age > 65 to identify users over 65 years old."
        },
        "65": {
            "condition": "When filtering for high-scoring posts",
            "operation": " use T1.Score >= 20 to include posts with scores of 20 or higher."
        },
        "66": {
            "condition": "When counting posts, When combining posts and users tables, When filtering for elder users, When filtering for high-scoring posts, When referencing columns from joined tables",
            "operation": " use the exact column tokens T1.OwnerUserId and T2.Id for the join condition."
        },
        "67": {
            "condition": "When the question asks for the location of the owner of a specific post",
            "operation": " select \"T2.Location\" from the users table instead of \"location\" from the users table."
        },
        "68": {
            "condition": "When combining posts and users tables",
            "operation": " add a posts table as T1 and join it with users as T2 using inner join on T1.OwnerUserId = T2.Id instead of querying only the users table without any join."
        },
        "69": {
            "condition": "When filtering by post title",
            "operation": " filter on T1.Title instead of post_title since the title column exists in the posts table rather than the users table."
        },
        "70": {
            "condition": "When the question asks for the location of the owner of a specific post, When combining posts and users tables, When filtering by post title, When matching a specific post title",
            "operation": " use the exact literal 'Eliciting priors from experts' with the correct case and spacing."
        },
        "71": {
            "condition": "When the question asks about a tag excerpted from a post",
            "operation": " use \"tags\" as T1 and \"posts\" as T2 with an inner join on T2.Id = T1.ExcerptPostId."
        },
        "72": {
            "condition": "When filtering for the tag \"bayesian\"",
            "operation": " use T1.TagName = 'bayesian' exactly as specified."
        },
        "73": {
            "condition": "When selecting the post body",
            "operation": " use T2.Body as the output column."
        },
        "74": {
            "condition": "When the question asks about a tag excerpted from a post, When filtering for the tag \"bayesian\", When selecting the post body, When the question asks for the post from which a tag is excerpted",
            "operation": " do not apply any row limits since there should be exactly one matching post per tag."
        },
        "75": {
            "condition": "When answering about \"the most popular tag excerpted from\"",
            "operation": " make sure the output order: \"Body\" from posts table."
        },
        "76": {
            "condition": "When the question mentions \"most popular tag excerpted from\"",
            "operation": " \"most popular\" actually means \"highest count of tags per ExcerptPostId\" in schema."
        },
        "77": {
            "condition": "When the question asks for the post with the highest tag count",
            "operation": " use a subquery to find the ExcerptPostId with the maximum count of tags instead of joining tables."
        },
        "78": {
            "condition": "When filtering posts by id",
            "operation": " filter where posts.id equals the ExcerptPostId from the subquery result instead of joining on p.id = t.post_id."
        },
        "79": {
            "condition": "When counting tags for popularity",
            "operation": " count using the ExcerptPostId column as the grouping key in the subquery."
        },
        "80": {
            "condition": "When ordering by popularity in the subquery",
            "operation": " order by the count of tags in descending order to find the highest count."
        },
        "81": {
            "condition": "When selecting the top result",
            "operation": " take only the first result (limit"
        },
        "82": {
            "condition": "When answering about \"the most popular tag excerpted from\", When the question mentions \"most popular tag excerpted from\", When the question asks for the post with the highest tag count, When filtering posts by id, When counting tags for popularity, When ordering by popularity in the subquery, When selecting the top result, from the ordered subquery to get the ExcerptPostId with the highest tag count.",
            "operation": "When answering about \"the most popular tag excerpted from\", When the question mentions \"most popular tag excerpted from\", When the question asks for the post with the highest tag count, When filtering posts by id, When counting tags for popularity, When ordering by popularity in the subquery, When selecting the top result, from the ordered subquery to get the ExcerptPostId with the highest tag count."
        },
        "83": {
            "condition": "When answering about \"badges obtained by user csgillespie\"",
            "operation": " make sure to join badges table (T1) with users table (T2) using T1.UserId = T2.Id to properly link user records."
        },
        "84": {
            "condition": "When the question mentions \"user csgillespie\"",
            "operation": " \"csgillespie\" actually means T2.DisplayName = 'csgillespie' in the schema."
        },
        "85": {
            "condition": "When counting badges",
            "operation": " compute the number of rows using the canonical key token T1.Id for precise badge counting."
        },
        "86": {
            "condition": "When answering about \"badges obtained by user csgillespie\", When the question mentions \"user csgillespie\", When counting badges, When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.UserId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "87": {
            "condition": "When answering about \"badges obtained by csgillespie\"",
            "operation": " make sure the output order: T1.Name"
        },
        "88": {
            "condition": "When the question mentions \"csgillespie\"",
            "operation": " \"csgillespie\" actually means \"T2.DisplayName = 'csgillespie'\" in schema"
        },
        "89": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.UserId = T2.Id; keep only matching pairs (inner match)"
        },
        "90": {
            "condition": "When answering about \"badges obtained by csgillespie\", When the question mentions \"csgillespie\", When combining T1 and T2 for shared entities, When selecting badge names",
            "operation": " use T1.Name instead of badge_name to use the proper column name"
        },
        "91": {
            "condition": "When answering about badges obtained by a specific user",
            "operation": " join the badges table (T1) with the users table (T2) where T1.UserId equals T2.Id to properly link user information."
        },
        "92": {
            "condition": "When the question mentions a username like \"csgillespie\"",
            "operation": " use T2.DisplayName = 'csgillespie' exactly to identify the user by their display name."
        },
        "93": {
            "condition": "When filtering for a specific year like 2011",
            "operation": " use STRFTIME('%Y', T1.Date) = '2011' to extract and compare the year portion of dates in SQLite-compatible format."
        },
        "94": {
            "condition": "When answering about badges obtained by a specific user, When the question mentions a username like \"csgillespie\", When filtering for a specific year like 2011, When counting badges",
            "operation": " use COUNT(T1.Id) to count specific badge IDs rather than counting all rows."
        },
        "95": {
            "condition": "When counting badges per user",
            "operation": " use COUNT(T1.Id) to count the number of badges for each user."
        },
        "96": {
            "condition": "When combining users and badges tables",
            "operation": " link rows where T1.UserId = T2.Id using an inner join to keep only users with badges."
        },
        "97": {
            "condition": "When grouping results by user",
            "operation": " use GROUP BY T2.DisplayName to organize results by each user's display name."
        },
        "98": {
            "condition": "When selecting the user with the most badges",
            "operation": " order results by the badge count in descending order and take the first result."
        },
        "99": {
            "condition": "When counting badges per user, When combining users and badges tables, When grouping results by user, When selecting the user with the most badges, When outputting the result",
            "operation": " return T2.DisplayName as the display name of the user."
        },
        "100": {
            "condition": "When combining posts and users tables",
            "operation": " link rows where T1.OwnerUserId = T2.Id using an inner join and keep only matching pairs."
        },
        "101": {
            "condition": "When the question mentions \"user csgillespie\"",
            "operation": " \"csgillespie\" actually means T2.DisplayName = 'csgillespie' in the schema."
        },
        "102": {
            "condition": "When answering about \"average score of the posts\"",
            "operation": " compute the average of T1.Score for rows that match the specified user condition."
        },
        "103": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for column names like Score and DisplayName."
        },
        "104": {
            "condition": "When combining posts and users tables, When the question mentions \"user csgillespie\", When answering about \"average score of the posts\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for the value 'csgillespie'."
        },
        "105": {
            "condition": "When calculating average badges per user",
            "operation": " use the formula (number of badges) divided by (number of distinct users) with CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName)."
        },
        "106": {
            "condition": "When combining badges and users tables",
            "operation": " link rows where T1.UserId = T2.Id using an inner join to keep only matching pairs."
        },
        "107": {
            "condition": "When filtering users by view count",
            "operation": " apply the condition T2.Views > 200 to select users with more than 200 views."
        },
        "108": {
            "condition": "When counting badges",
            "operation": " use T1.Id from the badges table as the counting key."
        },
        "109": {
            "condition": "When calculating average badges per user, When combining badges and users tables, When filtering users by view count, When counting badges, When counting distinct users",
            "operation": " use T2.DisplayName from the users table as the distinct identifier."
        },
        "110": {
            "condition": "When counting posts with scores over 5",
            "operation": " use T1.Id as the counting key instead of counting all rows."
        },
        "111": {
            "condition": "When determining if a user is elderly",
            "operation": " use T2.Age > 65 instead of >= 65 to exclude the exact age of 65."
        },
        "112": {
            "condition": "When performing conditional counting of elderly users",
            "operation": " use SUM(IIF(T2.Age > 65, 1, 0)) instead of COUNT(CASE WHEN...)."
        },
        "113": {
            "condition": "When calculating percentages",
            "operation": " cast the sum to REAL instead of using 100.0 for floating-point division."
        },
        "114": {
            "condition": "When joining tables",
            "operation": " use INNER JOIN explicitly between T1 and T2 where T1.OwnerUserId = T2.Id."
        },
        "115": {
            "condition": "When counting posts with scores over 5, When determining if a user is elderly, When performing conditional counting of elderly users, When calculating percentages, When joining tables, When filtering posts",
            "operation": " only include rows where T1.Score > 5."
        },
        "116": {
            "condition": "When counting votes",
            "operation": " count non-null values of the \"Id\" column instead of counting all rows."
        },
        "117": {
            "condition": "When filtering by user identifier",
            "operation": " use column name \"UserId\" instead of \"user_id\"."
        },
        "118": {
            "condition": "When filtering by date",
            "operation": " use column name \"CreationDate\" instead of \"vote_date\"."
        },
        "119": {
            "condition": "When counting votes, When filtering by user identifier, When filtering by date, When specifying date values",
            "operation": " use format '2010-07-19' with hyphens and zero-padded month instead of '2010/7/19' with slashes and unpadded month."
        },
        "120": {
            "condition": "When the question mentions \"creation date\"",
            "operation": " use the exact column name \"CreationDate\" with proper case sensitivity."
        },
        "121": {
            "condition": "When counting votes",
            "operation": " count using the canonical key \"Id\" column to count specific non-null identifiers rather than all rows."
        },
        "122": {
            "condition": "When the question mentions \"creation date\", When counting votes, When answering about the maximum number of votes",
            "operation": " rank rows by the count of votes in descending order and keep only the first row."
        },
        "123": {
            "condition": "When answering about \"the creation date of the maximum number of votes\"",
            "operation": " make sure the output order: CreationDate only."
        },
        "124": {
            "condition": "When counting votes",
            "operation": " use COUNT(Id) as the counting function but do not include it in the final output."
        },
        "125": {
            "condition": "When finding the maximum count",
            "operation": " order the results by COUNT(Id) in descending direction and keep only the first 1 row."
        },
        "126": {
            "condition": "When answering about \"the creation date of the maximum number of votes\", When counting votes, When finding the maximum count, When grouping by creation date",
            "operation": " organize results by CreationDate and compute the vote count per each CreationDate."
        },
        "127": {
            "condition": "When the question asks for the title of a post",
            "operation": " use the exact column name \"Title\" from the posts table."
        },
        "128": {
            "condition": "When the question mentions \"highest score comment\"",
            "operation": " use the exact column name \"Score\" from the comments table to determine the maximum value."
        },
        "129": {
            "condition": "When matching posts to comments",
            "operation": " use the exact column name \"Id\" from the posts table and \"PostId\" from the comments table to link the tables."
        },
        "130": {
            "condition": "When the question asks for the title of a post, When the question mentions \"highest score comment\", When matching posts to comments, When ordering comments by score to find the highest",
            "operation": " sort comments by \"Score\" in descending order and take the first result."
        },
        "131": {
            "condition": "When combining posts and comments tables",
            "operation": " link rows where T1.Id equals T2.PostId exactly and keep only matching pairs (inner join)."
        },
        "132": {
            "condition": "When filtering for posts with 1910 view counts",
            "operation": " include only rows where T1.ViewCount equals 1910 exactly."
        },
        "133": {
            "condition": "When counting comments for the specified post",
            "operation": " compute the number of rows using T1.Id as the counting key instead of counting all columns."
        },
        "134": {
            "condition": "When combining posts and comments tables, When filtering for posts with 1910 view counts, When counting comments for the specified post, When answering about comments for a post with specific view count",
            "operation": " make sure to use explicit table aliases T1 for posts and T2 for comments as established in the join condition."
        },
        "135": {
            "condition": "When answering about favorite counts for a post",
            "operation": " select \"T1.FavoriteCount\" from the \"posts\" table instead of from the \"comments\" table."
        },
        "136": {
            "condition": "When combining posts and comments tables",
            "operation": " link rows where \"T1.Id\" equals \"T2.PostId\" using an inner join between \"posts AS T1\" and \"comments AS T2\"."
        },
        "137": {
            "condition": "When filtering by user and datetime",
            "operation": " apply \"T2.UserId = 3025\" and \"T2.CreationDate = '2014-04-23 20:29:39.0'\" filters to the joined table."
        },
        "138": {
            "condition": "When answering about favorite counts for a post, When combining posts and comments tables, When filtering by user and datetime, When handling datetime values",
            "operation": " use the combined datetime format '2014-04-23 20:29:39.0' instead of separate date and time columns."
        },
        "139": {
            "condition": "When answering about \"comment text of the post with parent id 107829\"",
            "operation": " make sure the output order: T2.Text"
        },
        "140": {
            "condition": "When the question mentions \"comment text\"",
            "operation": " \"comment text\" actually means \"Text in schema\" from table comments as T2"
        },
        "141": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.Id = T2.PostId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "142": {
            "condition": "When filtering for posts with parent id 107829",
            "operation": " use exact literal value 107829 for T1.ParentId"
        },
        "143": {
            "condition": "When ensuring only one comment exists",
            "operation": " use exact condition T1.CommentCount = 1 to filter for posts with exactly one comment"
        },
        "144": {
            "condition": "When answering about \"comment text of the post with parent id 107829\", When the question mentions \"comment text\", When combining T1 and T2 for shared entities, When filtering for posts with parent id 107829, When ensuring only one comment exists, When the question asks for \"the only one comment text\"",
            "operation": " do not use LIMIT 1 clause as the CommentCount = 1 condition ensures only one result"
        },
        "145": {
            "condition": "When answering about whether a post is well-finished",
            "operation": " use conditional logic to return 'well-finished' if T2.ClosedDate IS NULL, otherwise 'NOT well-finished' as the result."
        },
        "146": {
            "condition": "When the question mentions a user comment",
            "operation": " query the comments table as T1 instead of posts, and filter on T1.UserId = 23853 instead of user_id."
        },
        "147": {
            "condition": "When the question specifies a comment time",
            "operation": " use the exact timestamp literal '2013-07-12 09:08:18.0' for T1.CreationDate instead of '2013-07-12 09:08:18'."
        },
        "148": {
            "condition": "When combining comments and posts tables",
            "operation": " link rows where T1.PostId = T2.Id using an inner join, and do not use the is_finished filter."
        },
        "149": {
            "condition": "When answering about whether a post is well-finished, When the question mentions a user comment, When the question specifies a comment time, When combining comments and posts tables, When determining post completion status",
            "operation": " check if T2.ClosedDate IS NULL to determine if the post is well-finished, rather than using a direct boolean field."
        },
        "150": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id equals T2.OwnerUserId exactly as shown and keep only matching pairs (inner match)."
        },
        "151": {
            "condition": "When filtering for a specific post",
            "operation": " use T2.Id = 65041 to identify the exact post."
        },
        "152": {
            "condition": "When selecting reputation points",
            "operation": " use T1.Reputation with proper table qualification instead of just reputation."
        },
        "153": {
            "condition": "When combining users and posts tables, When filtering for a specific post, When selecting reputation points, When answering about the owner user of post No. 65041",
            "operation": " make sure the output order includes only the reputation points value."
        },
        "154": {
            "condition": "When answering about posts owned by a user with a specific display name",
            "operation": " join users AS T1 with posts AS T2 on T1.Id = T2.OwnerUserId to link user records with their owned posts."
        },
        "155": {
            "condition": "When filtering for a user with display name \"Tiago Pasqualini\"",
            "operation": " use T1.DisplayName = 'Tiago Pasqualini' exactly as specified."
        },
        "156": {
            "condition": "When answering about posts owned by a user with a specific display name, When filtering for a user with display name \"Tiago Pasqualini\", When counting posts owned by a user",
            "operation": " count using the canonical key T1.Id instead of counting all rows with COUNT(*)."
        },
        "157": {
            "condition": "When answering about \"the user who made vote No.6347\"",
            "operation": " make sure to combine information from both users and votes tables using an inner match."
        },
        "158": {
            "condition": "When combining users table (T1) and votes table (T2)",
            "operation": " link rows where T1.Id equals T2.UserId exactly as shown in the amends."
        },
        "159": {
            "condition": "When the question mentions \"vote No.6347\"",
            "operation": " this actually means T2.Id = 6347 in the schema."
        },
        "160": {
            "condition": "When the question asks for \"display name\"",
            "operation": " this actually means T1.DisplayName in the schema."
        },
        "161": {
            "condition": "When answering about \"the user who made vote No.6347\", When combining users table (T1) and votes table (T2), When the question mentions \"vote No.6347\", When the question asks for \"display name\", When producing output",
            "operation": " return only the T1.DisplayName column."
        },
        "162": {
            "condition": "When answering about \"number of votes for the post about data visualization\"",
            "operation": " make sure the output order: count of posts with matching titles that have associated votes."
        },
        "163": {
            "condition": "When the question mentions \"post about data visualization\"",
            "operation": " \"data visualization\" actually means \"T1.Title LIKE '%data visualization%' in schema\"."
        },
        "164": {
            "condition": "When combining T1 (posts) and T2 (votes) for shared entities",
            "operation": " link rows where T1.Id = T2.PostId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "165": {
            "condition": "When the question asks for \"number of votes\"",
            "operation": " compute the count using the canonical key token T1.Id from the posts table instead of counting all rows from votes."
        },
        "166": {
            "condition": "When answering about \"number of votes for the post about data visualization\", When the question mentions \"post about data visualization\", When combining T1 (posts) and T2 (votes) for shared entities, When the question asks for \"number of votes\", When filtering for specific content",
            "operation": " place the title filter T1.Title LIKE '%data visualization%' in the WHERE clause instead of using a subquery."
        },
        "167": {
            "condition": "When the question asks about a user's badge name",
            "operation": " select \"T2\".\"Name\" from the badges table instead of badge_name from the users table."
        },
        "168": {
            "condition": "When combining users and badges tables",
            "operation": " link rows where \"T1\".\"Id\" = \"T2\".\"UserId\" using an inner join."
        },
        "169": {
            "condition": "When the question asks about a user's badge name, When combining users and badges tables, When filtering by display name",
            "operation": " use the exact column name \"DisplayName\" instead of display_name and the exact literal value 'DatEpicCoderGuyWhoPrograms'."
        },
        "170": {
            "condition": "When calculating the ratio of posts to votes for a specific user",
            "operation": " use INNER JOIN between votes and posts tables instead of LEFT JOIN from users to both tables."
        },
        "171": {
            "condition": "When joining votes and posts tables",
            "operation": " link rows where T1.UserId = T2.OwnerUserId instead of joining both tables to users.id."
        },
        "172": {
            "condition": "When calculating the posts-to-votes ratio",
            "operation": " compute CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) instead of COUNT(posts.id) / COUNT(votes.id)."
        },
        "173": {
            "condition": "When filtering for a specific user",
            "operation": " use WHERE T1.UserId = 24 instead of WHERE users.id = 24."
        },
        "174": {
            "condition": "When structuring the query",
            "operation": " remove the users table entirely instead of including it as the primary source."
        },
        "175": {
            "condition": "When counting votes",
            "operation": " use COUNT(DISTINCT T1.Id) instead of simple counts without deduplication."
        },
        "176": {
            "condition": "When calculating the ratio of posts to votes for a specific user, When joining votes and posts tables, When calculating the posts-to-votes ratio, When filtering for a specific user, When structuring the query, When counting votes, When performing division",
            "operation": " cast the numerator to REAL instead of performing integer division."
        },
        "177": {
            "condition": "When answering about \"number of posts compared to votes for user No.24\"",
            "operation": " make sure the output order: posts_to_votes_ratio."
        },
        "178": {
            "condition": "When counting posts",
            "operation": " use COUNT(T2.Id) instead of COUNT(DISTINCT T2.Id) since post IDs are unique."
        },
        "179": {
            "condition": "When combining votes and posts tables",
            "operation": " link rows where T1.UserId = T2.OwnerUserId and keep only matching pairs (inner match)."
        },
        "180": {
            "condition": "When filtering for user No.24",
            "operation": " apply the condition T1.UserId = 24 exactly as specified."
        },
        "181": {
            "condition": "When answering about \"number of posts compared to votes for user No.24\", When counting posts, When combining votes and posts tables, When filtering for user No.24, When calculating the ratio of posts to votes",
            "operation": " compute (COUNT(T2.Id)) divided by (COUNT(T1.Id)) and cast the result to REAL to handle decimal values."
        },
        "182": {
            "condition": "When the question asks for \"how many views\" a post got",
            "operation": " retrieve the exact value from the \"ViewCount\" column instead of counting rows."
        },
        "183": {
            "condition": "When the question specifies a post title",
            "operation": " match the exact title text 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' using the \"Title\" column with exact case sensitivity."
        },
        "184": {
            "condition": "When the question asks for \"how many views\" a post got, When the question specifies a post title, When selecting output columns",
            "operation": " return only the \"ViewCount\" value for the matching post."
        },
        "185": {
            "condition": "When answering about \"comments with a score of 17\"",
            "operation": " make sure the output order: Text."
        },
        "186": {
            "condition": "When the question mentions \"comments\"",
            "operation": " \"comments\" actually means \"posts\" in schema."
        },
        "187": {
            "condition": "When filtering for score value 17",
            "operation": " use exact literal 17 and exact column name \"Score\" with proper case sensitivity."
        },
        "188": {
            "condition": "When answering about \"comments with a score of 17\", When the question mentions \"comments\", When filtering for score value 17, When selecting columns",
            "operation": " specify only the \"Text\" column instead of using wildcard selection."
        },
        "189": {
            "condition": "When the question asks about \"user\" with a specific website URL",
            "operation": " use the \"DisplayName\" column from the \"users\" table to return the user's display name."
        },
        "190": {
            "condition": "When filtering for website URLs",
            "operation": " use the \"WebsiteUrl\" column from the \"users\" table and match the exact literal value 'http://stackoverflow.com' with correct case and punctuation."
        },
        "191": {
            "condition": "When the question asks about \"user\" with a specific website URL, When filtering for website URLs, When selecting output columns",
            "operation": " return only the \"DisplayName\" column instead of all columns (*) to provide the specific information requested."
        },
        "192": {
            "condition": "When answering about \"badge name that user 'SilentGhost' obtained\"",
            "operation": " make sure the output order: T2.Name."
        },
        "193": {
            "condition": "When the question mentions \"user 'SilentGhost'\"",
            "operation": " \"SilentGhost\" actually means T1.DisplayName in schema."
        },
        "194": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "195": {
            "condition": "When answering about \"badge name that user 'SilentGhost' obtained\", When the question mentions \"user 'SilentGhost'\", When combining T1 and T2 for shared entities, When filtering for a specific user by display name",
            "operation": " use T1.DisplayName = 'SilentGhost' exactly with the literal 'SilentGhost' including case and no quotes around the column name."
        },
        "196": {
            "condition": "When the question asks for the name of a user who made a specific comment",
            "operation": " select \"T1.DisplayName\" instead of \"username\" as the output column."
        },
        "197": {
            "condition": "When combining user and comment information",
            "operation": " perform an inner join between \"users\" as T1 and \"comments\" as T2 using the condition T1.Id = T2.UserId to link users to their comments."
        },
        "198": {
            "condition": "When filtering for a specific comment text",
            "operation": " use the exact literal 'thank you user93!' and apply the filter to T2.Text column instead of a non-existent comment column."
        },
        "199": {
            "condition": "When the question asks for the name of a user who made a specific comment, When combining user and comment information, When filtering for a specific comment text, When answering about user identification",
            "operation": " ensure the output order contains only the DisplayName column from the users table."
        },
        "200": {
            "condition": "When the question asks for comments made by a specific user",
            "operation": " join users AS T1 with comments AS T2 on T1.Id = T2.UserId to properly relate users to their comments."
        },
        "201": {
            "condition": "When filtering for user 'A Lion'",
            "operation": " use T1.DisplayName = 'A Lion' to match the exact display name field from the users table."
        },
        "202": {
            "condition": "When the question asks for comments made by a specific user, When filtering for user 'A Lion', When selecting comment text",
            "operation": " return only T2.Text instead of all columns to show only the comment content."
        },
        "203": {
            "condition": "When the question asks about a user who made a specific post",
            "operation": " use T1 for the users table and T2 for the posts table with aliases as established in the amends."
        },
        "204": {
            "condition": "When referencing user display name and reputation",
            "operation": " use exact column tokens \"T1.DisplayName\" and \"T1.Reputation\" as shown in the schema."
        },
        "205": {
            "condition": "When joining users and posts tables",
            "operation": " use an INNER JOIN with the exact condition \"T1.Id = T2.OwnerUserId\" to match rows where the user ID equals the post's owner user ID."
        },
        "206": {
            "condition": "When filtering for a specific post title",
            "operation": " use the exact literal string 'Understanding what Dassault iSight is doing?' with proper case and punctuation."
        },
        "207": {
            "condition": "When the question asks about a user who made a specific post, When referencing user display name and reputation, When joining users and posts tables, When filtering for a specific post title, When selecting output columns",
            "operation": " maintain the order of DisplayName followed by Reputation as specified in the question."
        },
        "208": {
            "condition": "When answering about \"comments made on a specific post\"",
            "operation": " make sure the output order: T1.Text"
        },
        "209": {
            "condition": "When the question mentions \"post titled 'How does gentle boosting differ from AdaBoost?'\"",
            "operation": " \"post title\" actually means \"T2.Title in schema\" with exact literal 'How does gentle boosting differ from AdaBoost?'"
        },
        "210": {
            "condition": "When combining T1 (comments) and T2 (posts) for shared entities",
            "operation": " link rows where T1.PostId = T2.Id; keep only matching pairs (inner match)"
        },
        "211": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "212": {
            "condition": "When answering about \"comments made on a specific post\", When the question mentions \"post titled 'How does gentle boosting differ from AdaBoost?'\", When combining T1 (comments) and T2 (posts) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'How does gentle boosting differ from AdaBoost?'"
        },
        "213": {
            "condition": "When the question asks for \"editor\" of a post",
            "operation": " \"editor\" actually means \"T2.DisplayName\" from the users table."
        },
        "214": {
            "condition": "When combining posts and users tables",
            "operation": " link rows where T1.OwnerUserId = T2.Id and keep only matching pairs (inner match)."
        },
        "215": {
            "condition": "When the question asks for \"editor\" of a post, When combining posts and users tables, When filtering by post title",
            "operation": " use T1.Title = 'Open source tools for visualizing multi-dimensional data?' exactly as specified with the exact case, spacing, and punctuation."
        },
        "216": {
            "condition": "When the question asks about the \"editor\" of a post",
            "operation": " use the \"OwnerUserId\" column from the posts table (T1) instead of \"LastEditorUserId\" to correctly identify the original post creator."
        },
        "217": {
            "condition": "When joining posts (T1) and users (T2) tables",
            "operation": " link rows where T1.OwnerUserId = T2.Id to associate posts with their original owners."
        },
        "218": {
            "condition": "When the question asks about the \"editor\" of a post, When joining posts (T1) and users (T2) tables, When filtering for a specific post title",
            "operation": " use the exact literal 'Open source tools for visualizing multi-dimensional data?' with the exact case, spacing, and punctuation as shown in the question."
        },
        "219": {
            "condition": "When answering about \"posts edited by Vebjorn Ljosa\"",
            "operation": " make sure to join posts AS T1 with users AS T2 on T1.OwnerUserId = T2.Id to link user information."
        },
        "220": {
            "condition": "When the question mentions \"Vebjorn Ljosa\"",
            "operation": " \"Vebjorn Ljosa\" actually means T2.DisplayName = 'Vebjorn Ljosa' in the schema."
        },
        "221": {
            "condition": "When answering about \"posts edited by Vebjorn Ljosa\", When the question mentions \"Vebjorn Ljosa\", When selecting the title of posts",
            "operation": " use T1.Title instead of title to use the table alias correctly."
        },
        "222": {
            "condition": "When the question asks for \"total score of posts\"",
            "operation": " use T1.Score for aggregation instead of p.score."
        },
        "223": {
            "condition": "When joining posts and users tables",
            "operation": " link rows where T1.LastEditorUserId = T2.Id instead of p.user_id = u.id."
        },
        "224": {
            "condition": "When filtering for user named Yevgeny",
            "operation": " use T2.DisplayName = 'Yevgeny' instead of u.name = 'Yevgeny'."
        },
        "225": {
            "condition": "When including the user's website URL in results",
            "operation": " add GROUP BY T2.WebsiteUrl to properly group aggregated results by website URL."
        },
        "226": {
            "condition": "When the question asks for \"total score of posts\", When joining posts and users tables, When filtering for user named Yevgeny, When including the user's website URL in results, When computing total score",
            "operation": " remove the total_score alias from the output column."
        },
        "227": {
            "condition": "When answering about comments left by users who edited a specific post",
            "operation": " select only the \"Comment\" column from the postHistory table (as T2.Comment) instead of all columns."
        },
        "228": {
            "condition": "When joining tables to find post-related information",
            "operation": " use an INNER JOIN between posts (as T1) and postHistory (as T2) instead of joining with the posts table directly."
        },
        "229": {
            "condition": "When linking posts with their history",
            "operation": " match rows where T1.Id equals T2.PostId exactly."
        },
        "230": {
            "condition": "When answering about comments left by users who edited a specific post, When joining tables to find post-related information, When linking posts with their history, When filtering by post title",
            "operation": " reference T1.Title with the exact literal 'Why square the difference instead of taking the absolute value in standard deviation?' maintaining the same filter condition."
        },
        "231": {
            "condition": "When answering about \"total bounty amount of posts titled about 'data'\"",
            "operation": " make sure to sum T2.BountyAmount from the votes table instead of bounty_amount from the posts table."
        },
        "232": {
            "condition": "When combining posts and votes tables",
            "operation": " link rows where T1.Id = T2.PostId and keep only matching pairs (inner match)."
        },
        "233": {
            "condition": "When filtering posts by title containing 'data'",
            "operation": " use T1.Title LIKE '%data%' with exact case and spacing."
        },
        "234": {
            "condition": "When answering about \"total bounty amount of posts titled about 'data'\", When combining posts and votes tables, When filtering posts by title containing 'data', When using table aliases",
            "operation": " refer to posts as T1 and votes as T2 as established in the join condition."
        },
        "235": {
            "condition": "When answering about \"which user added a bounty amount of 50 to the post title mentioning variance\"",
            "operation": " make sure the output order: T3.DisplayName, T1.Title."
        },
        "236": {
            "condition": "When the question mentions \"bounty amount of 50\"",
            "operation": " \"bounty amount\" actually means \"T2.BountyAmount = 50\" in schema."
        },
        "237": {
            "condition": "When the question mentions \"post title mentioning variance\"",
            "operation": " \"post title\" actually means \"T1.Title LIKE '%variance%'\" in schema."
        },
        "238": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.Id = T2.PostId and T3.Id = T2.UserId; keep only matching pairs (inner match)."
        },
        "239": {
            "condition": "When answering about \"which user added a bounty amount of 50 to the post title mentioning variance\", When the question mentions \"bounty amount of 50\", When the question mentions \"post title mentioning variance\", When combining T1, T2, and T3 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T3.DisplayName, T1.Title, T2.BountyAmount, T1.Id, T2.PostId, T3.Id, and T2.UserId."
        },
        "240": {
            "condition": "When answering about \"average view count of posts tagged as 'humor' with title and comment\"",
            "operation": " make sure the output order: T2.Title, T1.Text, AVG(T2.ViewCount)"
        },
        "241": {
            "condition": "When the question mentions \"post tagged as 'humor'\"",
            "operation": " \"humor\" actually means \"T2.Tags = '<humor>'\" in schema"
        },
        "242": {
            "condition": "When combining comments and posts tables",
            "operation": " link rows where T2.Id = T1.PostId and keep only matching pairs (inner match)"
        },
        "243": {
            "condition": "When calculating average view count",
            "operation": " use AVG(T2.ViewCount) instead of view_count"
        },
        "244": {
            "condition": "When answering about \"average view count of posts tagged as 'humor' with title and comment\", When the question mentions \"post tagged as 'humor'\", When combining comments and posts tables, When calculating average view count, When grouping results",
            "operation": " organize by T2.Title, T1.Text instead of title, comment"
        },
        "245": {
            "condition": "When counting comments",
            "operation": " use COUNT(\"Id\") instead of COUNT(*) to count only non-null values in the Id column."
        },
        "246": {
            "condition": "When referencing user ID columns",
            "operation": " use exact column name \"UserId\" with proper casing instead of \"user_id\"."
        },
        "247": {
            "condition": "When counting comments, When referencing user ID columns, When filtering by user ID 13",
            "operation": " use the exact literal value 13 without quotes for numeric comparison."
        },
        "248": {
            "condition": "When answering about \"which user ID has the highest reputation\"",
            "operation": " select \"Id\" from the users table instead of \"user_id\"."
        },
        "249": {
            "condition": "When finding the maximum reputation value",
            "operation": " use MAX(\"Reputation\") in a subquery to determine the highest reputation value."
        },
        "250": {
            "condition": "When identifying the user with the highest reputation",
            "operation": " use a WHERE filter comparing \"Reputation\" to the result of the MAX(\"Reputation\") subquery instead of using ORDER BY and LIMIT."
        },
        "251": {
            "condition": "When answering about \"which user ID has the highest reputation\", When finding the maximum reputation value, When identifying the user with the highest reputation, When handling potential ties in reputation values",
            "operation": " use a correlated subquery approach that compares against the maximum value rather than relying on ordering which could be unreliable for ties."
        },
        "252": {
            "condition": "When the question asks for \"user ID\"",
            "operation": " use \"Id\" from the \"users\" table instead of \"user_id\" from \"views\"."
        },
        "253": {
            "condition": "When finding the user with the lowest view count",
            "operation": " use a WHERE filter with a subquery to find the minimum \"Views\" value instead of ordering by \"view_count\" and limiting to one row."
        },
        "254": {
            "condition": "When referencing view counts",
            "operation": " use the \"Views\" column instead of \"view_count\"."
        },
        "255": {
            "condition": "When the question asks for \"user ID\", When finding the user with the lowest view count, When referencing view counts, When identifying minimum values",
            "operation": " remove ORDER BY and LIMIT clauses and use a correlated subquery approach instead."
        },
        "256": {
            "condition": "When counting users awarded with supporter badges",
            "operation": " count the number of rows in the badges table using the exact token \"Id\" as the counting key instead of counting all rows."
        },
        "257": {
            "condition": "When filtering for supporter badges",
            "operation": " use the exact literal 'Supporter' (with capital S) for the Name column instead of 'supporter'."
        },
        "258": {
            "condition": "When filtering for year 2011",
            "operation": " extract the year from the Date column using STRFTIME('%Y', Date) and compare to the exact string '2011' instead of using a numeric year column."
        },
        "259": {
            "condition": "When counting users awarded with supporter badges, When filtering for supporter badges, When filtering for year 2011, When answering about users awarded with badges",
            "operation": " query the badges table directly instead of the users table, as badge awards are stored in the badges table."
        },
        "260": {
            "condition": "When counting users with more than 5 badges",
            "operation": " count distinct UserId values instead of all rows from the base table."
        },
        "261": {
            "condition": "When aggregating badge counts per user",
            "operation": " group by UserId and count the Name column from the badges table to get the number of badges per user."
        },
        "262": {
            "condition": "When filtering for users with more than 5 badges",
            "operation": " apply the condition num > 5 on the aggregated count result instead of filtering on a non-aggregated column."
        },
        "263": {
            "condition": "When counting users with more than 5 badges, When aggregating badge counts per user, When filtering for users with more than 5 badges, When the question asks for \"users awarded with more than 5 badges\"",
            "operation": " this means counting UserId values where the count of Name from badges table grouped by UserId is greater than 5."
        },
        "264": {
            "condition": "When counting users",
            "operation": " use COUNT(DISTINCT T1.Id) to count unique users instead of COUNT(*) for all rows."
        },
        "265": {
            "condition": "When combining badges and users tables",
            "operation": " join badges AS T1 with users AS T2 on T1.UserId = T2.Id to link badge assignments to user information."
        },
        "266": {
            "condition": "When filtering for specific badges",
            "operation": " use T1.Name IN ('Supporter', 'Teacher') to find users with either badge instead of requiring both badges simultaneously."
        },
        "267": {
            "condition": "When counting users, When combining badges and users tables, When filtering for specific badges, When filtering for location",
            "operation": " use T2.Location = 'New York' to find users from New York instead of city = 'New York'."
        },
        "268": {
            "condition": "When counting distinct badge IDs from users",
            "operation": " use T1.Id as the counting key instead of T1.UserId."
        },
        "269": {
            "condition": "When combining badges and users tables",
            "operation": " use explicit INNER JOIN syntax to link rows where T1.UserId = T2.Id."
        },
        "270": {
            "condition": "When filtering for users from New York",
            "operation": " use the exact literal 'New York' for T2.Location comparison."
        },
        "271": {
            "condition": "When filtering for specific badge types",
            "operation": " use the exact literals 'Supporter' and 'Teacher' in the IN condition for T1.Name."
        },
        "272": {
            "condition": "When counting distinct badge IDs from users, When combining badges and users tables, When filtering for users from New York, When filtering for specific badge types, When organizing the WHERE clause",
            "operation": " maintain both conditions T1.Name IN ('Supporter', 'Teacher') and T2.Location = 'New York' with proper logical ordering."
        },
        "273": {
            "condition": "When the question asks about a user who created a post",
            "operation": " use the comments table (T1) instead of the posts table to find user information."
        },
        "274": {
            "condition": "When joining tables for user information",
            "operation": " use INNER JOIN users AS T2 with join condition T1.UserId = T2.Id."
        },
        "275": {
            "condition": "When filtering for post ID 1",
            "operation": " use T1.PostId = 1 instead of posts.id = 1."
        },
        "276": {
            "condition": "When the question asks about a user who created a post, When joining tables for user information, When filtering for post ID 1, When selecting user information",
            "operation": " select T2.Id and T2.Reputation instead of users.name and users.reputation."
        },
        "277": {
            "condition": "When answering about \"users with only one post history per post and at least 1000 views\"",
            "operation": " make sure to join tables users AS T1, postHistory AS T2, and posts AS T3 using T1.Id = T2.UserId and T2.PostId = T3.Id."
        },
        "278": {
            "condition": "When filtering for view count",
            "operation": " apply T3.ViewCount >= 1000 in the WHERE clause before aggregation."
        },
        "279": {
            "condition": "When grouping results",
            "operation": " group by T2.UserId to organize by user."
        },
        "280": {
            "condition": "When counting distinct post history types per user",
            "operation": " compute COUNT(DISTINCT T2.PostHistoryTypeId) = 1 to ensure only one post history type per post."
        },
        "281": {
            "condition": "When answering about \"users with only one post history per post and at least 1000 views\", When filtering for view count, When grouping results, When counting distinct post history types per user, When selecting output",
            "operation": " return T2.UserId as the user identifier."
        },
        "282": {
            "condition": "When the question asks for \"user's badge\"",
            "operation": " select \"Name\" from the \"badges\" table instead of any badge column from a users table."
        },
        "283": {
            "condition": "When combining \"badges\" and \"comments\" tables",
            "operation": " link rows where \"T1.UserId\" = \"T2.UserId\" and keep only matching pairs (inner match)."
        },
        "284": {
            "condition": "When counting comments per user",
            "operation": " count using \"T2.UserId\" as the counting key."
        },
        "285": {
            "condition": "When grouping for aggregation",
            "operation": " organize results by \"T2.UserId\" to compute counts per user."
        },
        "286": {
            "condition": "When finding the user with the most comments",
            "operation": " rank rows by comment count in descending order and keep the first 1 row."
        },
        "287": {
            "condition": "When the question asks for \"user's badge\", When combining \"badges\" and \"comments\" tables, When counting comments per user, When grouping for aggregation, When finding the user with the most comments, When answering about \"which users have posted the most comments\"",
            "operation": " make sure the output order: \"Name\" from badges table."
        },
        "288": {
            "condition": "When answering about \"users who have posted the most comments\"",
            "operation": " make sure the output order: T1.Name only, without including the comment count."
        },
        "289": {
            "condition": "When the question asks for \"most comments\"",
            "operation": " rank users by comment count in descending order and keep only the top 1 result."
        },
        "290": {
            "condition": "When combining badges table T1 and comments table T2",
            "operation": " link rows where T1.UserId = T2.UserId using an inner join and keep only matching pairs."
        },
        "291": {
            "condition": "When answering about \"users who have posted the most comments\", When the question asks for \"most comments\", When combining badges table T1 and comments table T2, When counting comments per user",
            "operation": " compute the number of rows using T2.UserId as the counting key for each user group."
        },
        "292": {
            "condition": "When counting users with badges",
            "operation": " count using T1.Id from the badges table instead of counting all rows from the users table."
        },
        "293": {
            "condition": "When combining badges and users tables",
            "operation": " link rows where T1.UserId = T2.Id using an inner join to keep only matching pairs."
        },
        "294": {
            "condition": "When filtering for users from India",
            "operation": " use T2.Location = 'India' instead of country = 'India'."
        },
        "295": {
            "condition": "When counting users with badges, When combining badges and users tables, When filtering for users from India, When filtering for teacher badges",
            "operation": " use T1.Name = 'Teacher' instead of badge = 'teacher'."
        },
        "296": {
            "condition": "When the question asks about \"student badges\"",
            "operation": " filter records where \"Name\" equals exactly 'Student'."
        },
        "297": {
            "condition": "When calculating percentages for different years",
            "operation": " compute each year's percentage separately by dividing the count of badges for that year by the total count of all badges (using \"Id\" as the counting key)."
        },
        "298": {
            "condition": "When calculating percentage difference between two years",
            "operation": " subtract the individual year percentages (2011 percentage minus 2010 percentage) rather than computing a single ratio."
        },
        "299": {
            "condition": "When counting conditional occurrences",
            "operation": " use SUM(IIF(condition, 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN condition THEN 1 END)."
        },
        "300": {
            "condition": "When the question asks about \"student badges\", When calculating percentages for different years, When calculating percentage difference between two years, When counting conditional occurrences, When filtering by year",
            "operation": " use the exact year values '2010' and '2011' as specified in the question."
        },
        "301": {
            "condition": "When calculating percentage difference between years",
            "operation": " include all records in the denominator count for accurate percentage calculations."
        },
        "302": {
            "condition": "When filtering for specific badge types like 'Student'",
            "operation": " apply the filter within conditional aggregation expressions instead of at the table level to avoid excluding records from the denominator."
        },
        "303": {
            "condition": "When performing floating-point division",
            "operation": " explicitly cast numerator sums to REAL type to ensure proper division."
        },
        "304": {
            "condition": "When handling year-based filtering",
            "operation": " use conditional aggregation for year filtering instead of WHERE clause filters to maintain complete denominator counts."
        },
        "305": {
            "condition": "When calculating percentage difference between years, When filtering for specific badge types like 'Student', When performing floating-point division, When handling year-based filtering, When computing percentage difference",
            "operation": " simplify the calculation by removing unnecessary parentheses around percentage terms."
        },
        "306": {
            "condition": "When the question asks about \"student badges\"",
            "operation": " filter rows where \"Name\" equals exactly 'Student' before any calculations."
        },
        "307": {
            "condition": "When calculating percentage difference between years 2010 and 2011",
            "operation": " compute (number of badges in 2010 divided by total badges) minus (number of badges in 2011 divided by total badges) then multiply by 100."
        },
        "308": {
            "condition": "When extracting year from date values",
            "operation": " use the exact year extraction method shown in the schema (strftime with '%Y' format)."
        },
        "309": {
            "condition": "When the question asks about \"student badges\", When calculating percentage difference between years 2010 and 2011, When extracting year from date values, When the question asks for an unnamed result",
            "operation": " do not include any column alias in the output."
        },
        "310": {
            "condition": "When answering about posts related to post ID 61217",
            "operation": " use INNER JOIN to combine posts table as T1 with postLinks table as T2."
        },
        "311": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.Id = T2.PostId exactly and keep only matching pairs (inner match)."
        },
        "312": {
            "condition": "When filtering for posts related to post ID 61217",
            "operation": " filter on T2.PostId = 61217 to identify posts linked to the specified post ID."
        },
        "313": {
            "condition": "When retrieving popularity information",
            "operation": " select T1.ViewCount instead of all columns to get the specific popularity metric."
        },
        "314": {
            "condition": "When answering about posts related to post ID 61217, When combining T1 and T2 for shared entities, When filtering for posts related to post ID 61217, When retrieving popularity information, When handling the post ID value",
            "operation": " use the exact literal value 61217 without quotes as it appears to be a numeric identifier."
        },
        "315": {
            "condition": "When answering about \"score and link type ID for post ID 395\"",
            "operation": " make sure the output order: T1.Score, T2.LinkTypeId."
        },
        "316": {
            "condition": "When combining posts and postLinks tables",
            "operation": " link rows where T1.Id = T2.PostId and keep only matching pairs (inner match)."
        },
        "317": {
            "condition": "When filtering for post ID 395",
            "operation": " use T2.PostId = 395 to correctly target the joined table's condition."
        },
        "318": {
            "condition": "When referring to score",
            "operation": " use T1.Score from the posts table."
        },
        "319": {
            "condition": "When answering about \"score and link type ID for post ID 395\", When combining posts and postLinks tables, When filtering for post ID 395, When referring to score, When referring to link type ID",
            "operation": " use T2.LinkTypeId from the postLinks table."
        },
        "320": {
            "condition": "When the question asks for \"post ID\" and \"user ID\"",
            "operation": " use the exact column tokens \"PostId\" and \"UserId\" from the postHistory table."
        },
        "321": {
            "condition": "When filtering posts by score greater than 60",
            "operation": " use a subquery that selects \"Id\" from the posts table where \"Score\" > 60, then filter postHistory records where \"PostId\" matches those IDs."
        },
        "322": {
            "condition": "When querying from the postHistory table",
            "operation": " use the postHistory table as the main data source instead of the posts table."
        },
        "323": {
            "condition": "When referencing score values",
            "operation": " use the exact column name \"Score\" (not \"score\") from the posts table."
        },
        "324": {
            "condition": "When the question asks for \"post ID\" and \"user ID\", When filtering posts by score greater than 60, When querying from the postHistory table, When referencing score values, When referencing post identifiers",
            "operation": " use \"Id\" as the key column in the posts table for the subquery filter."
        },
        "325": {
            "condition": "When answering about \"sum of favourite count\"",
            "operation": " use SUM(DISTINCT FavoriteCount) instead of SUM(favorite_count) to eliminate duplicate values."
        },
        "326": {
            "condition": "When querying for user posts",
            "operation": " use the posts table instead of tweets table as the correct data source."
        },
        "327": {
            "condition": "When filtering by user ID",
            "operation": " use a subquery with Id IN (SELECT PostId FROM postHistory) instead of directly filtering user_id to properly correlate posts with their history."
        },
        "328": {
            "condition": "When specifying user ID 686",
            "operation": " reference UserId = 686 in the subquery's WHERE clause instead of the main query's filter."
        },
        "329": {
            "condition": "When filtering by year 2011",
            "operation": " use STRFTIME('%Y', CreationDate) = '2011' in the subquery instead of the main query to filter by creation year."
        },
        "330": {
            "condition": "When answering about \"sum of favourite count\", When querying for user posts, When filtering by user ID, When specifying user ID 686, When filtering by year 2011, When referencing schema columns",
            "operation": " use FavoriteCount column instead of favorite_count and CreationDate instead of created_at to match the correct schema."
        },
        "331": {
            "condition": "When the question asks for \"average of the up votes\" and \"average user age\"",
            "operation": " use \"AVG(T1.UpVotes)\" and \"AVG(T1.Age)\" exactly as specified in the schema instead of incorrect column names \"up_votes\" and \"user_age\"."
        },
        "332": {
            "condition": "When calculating post count for users",
            "operation": " compute it from the \"posts\" table using a subquery that counts posts per user instead of using a non-existent \"post_count\" column in the \"users\" table."
        },
        "333": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where \"T1.Id = T2.OwnerUserId\" to establish the relationship between users and their posts."
        },
        "334": {
            "condition": "When filtering for users with more than 10 posts",
            "operation": " apply the condition \"HAVING post_count > 10\" in the subquery that calculates post counts instead of using a WHERE clause against a non-existent column."
        },
        "335": {
            "condition": "When the question asks for \"average of the up votes\" and \"average user age\", When calculating post count for users, When combining users and posts tables, When filtering for users with more than 10 posts, When the question asks about users creating posts",
            "operation": " perform an inner join between users and posts tables to ensure only users with posts are considered."
        },
        "336": {
            "condition": "When counting entities from the badges table",
            "operation": " use COUNT(\"id\") instead of COUNT(*) to count the canonical key."
        },
        "337": {
            "condition": "When filtering for the \"Announcer\" badge",
            "operation": " use the exact condition Name = 'Announcer' with the exact literal 'Announcer' (case-sensitive)."
        },
        "338": {
            "condition": "When counting entities from the badges table, When filtering for the \"Announcer\" badge, When answering about badge counts",
            "operation": " query the badges table directly instead of the users table."
        },
        "339": {
            "condition": "When the question asks for badge names",
            "operation": " use the exact column \"Name\" from the badges table in the SELECT list."
        },
        "340": {
            "condition": "When filtering by date obtained",
            "operation": " use the exact column \"Date\" from the badges table in the WHERE condition."
        },
        "341": {
            "condition": "When the question asks for badge names, When filtering by date obtained, When comparing against the timestamp '7/19/2010 7",
            "operation": "39:08 PM': convert it to the ISO 8601 format '2010-07-19 19:39:08.0' for proper date comparison."
        },
        "342": {
            "condition": "When counting comments",
            "operation": " count the \"id\" column instead of all columns to exclude null values."
        },
        "343": {
            "condition": "When filtering for positive comments",
            "operation": " use the condition \"score > 60\" instead of text pattern matching on comment_text."
        },
        "344": {
            "condition": "When counting comments, When filtering for positive comments, When the question asks for \"positive comments\"",
            "operation": " this means comments where the score exceeds 60."
        },
        "345": {
            "condition": "When the question asks for \"detailed content of the comment\"",
            "operation": " select the exact column \"Text\" instead of all columns."
        },
        "346": {
            "condition": "When filtering by creation date",
            "operation": " use the exact column name \"CreationDate\" instead of \"created_at\"."
        },
        "347": {
            "condition": "When the question asks for \"detailed content of the comment\", When filtering by creation date, When specifying the timestamp '7/19/2010 7",
            "operation": "25:47 PM': convert it to the ISO format literal '2010-07-19 19:16:14.0' for proper datetime comparison."
        },
        "348": {
            "condition": "When the question asks for a comment created on 7/19/2010 7",
            "operation": "25:47 PM: use the timestamp literal '2010-07-19 19:16:14.0' exactly as specified in the amends for filtering the CreationDate column."
        },
        "349": {
            "condition": "When filtering by datetime in the comments table",
            "operation": " ensure the timestamp format matches exactly '2010-07-19 19:16:14.0' including the .0 millisecond precision."
        },
        "350": {
            "condition": "When the question asks for a comment created on 7/19/2010 7, When filtering by datetime in the comments table, When querying for comment text content",
            "operation": " select the Text column from the comments table using the exact timestamp filter '2010-07-19 19:16:14.0'."
        },
        "351": {
            "condition": "When joining users and badges tables",
            "operation": " link rows where T1.Id equals T2.UserId exactly as shown in the amends (T1.Id = T2.UserId) and keep only matching pairs (inner match)."
        },
        "352": {
            "condition": "When the question asks for the highest reputation user's badge",
            "operation": " rank users by T1.Reputation in descending order and keep the first 1 row."
        },
        "353": {
            "condition": "When selecting badge name",
            "operation": " output T2.name from the badges table (using the exact token T2.name as shown in the amends)."
        },
        "354": {
            "condition": "When joining users and badges tables, When the question asks for the highest reputation user's badge, When selecting badge name, When handling ordering ties",
            "operation": " break ties using the canonical key T1.Id if needed, though the amends specify only LIMIT 1 without explicit tie-breaking."
        },
        "355": {
            "condition": "When answering about users who obtained badges on a specific date",
            "operation": " combine the users table (T1) and badges table (T2) by linking rows where T1.Id equals T2.UserId, keeping only matching pairs."
        },
        "356": {
            "condition": "When the question mentions a specific timestamp like '7/19/2010 7",
            "operation": "39:08 PM': convert it to the standardized format '2010-07-19 19:39:08.0' for comparison with T2.Date."
        },
        "357": {
            "condition": "When selecting reputation information",
            "operation": " use T1.Reputation as the output column."
        },
        "358": {
            "condition": "When answering about users who obtained badges on a specific date, When the question mentions a specific timestamp like '7/19/2010 7, When selecting reputation information, When filtering by badge creation date",
            "operation": " apply the condition to T2.Date using the converted timestamp format."
        },
        "359": {
            "condition": "When the question asks about badges obtained by a user with display name \"Pierre\"",
            "operation": " use an inner join between users table (T1) and badges table (T2) instead of subqueries."
        },
        "360": {
            "condition": "When combining users and badges tables",
            "operation": " link rows where T1.Id equals T2.UserId and keep only matching pairs (inner match)."
        },
        "361": {
            "condition": "When selecting badge names",
            "operation": " use T2.Name instead of badge_name from the badges table."
        },
        "362": {
            "condition": "When the question asks about badges obtained by a user with display name \"Pierre\", When combining users and badges tables, When selecting badge names, When filtering by user display name",
            "operation": " use T1.DisplayName instead of display_name in the WHERE clause with the exact literal value \"Pierre\"."
        },
        "363": {
            "condition": "When answering about \"dates that users obtained badges\"",
            "operation": " make sure the output order: T2.Date."
        },
        "364": {
            "condition": "When combining users table (T1) and badges table (T2)",
            "operation": " link rows where T1.Id = T2.UserId and keep only matching pairs (inner match)."
        },
        "365": {
            "condition": "When the question mentions \"users who are located in Rochester, NY\"",
            "operation": " filter rows where T1.Location = 'Rochester, NY' exactly as specified."
        },
        "366": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "367": {
            "condition": "When answering about \"dates that users obtained badges\", When combining users table (T1) and badges table (T2), When the question mentions \"users who are located in Rochester, NY\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Rochester, NY'."
        },
        "368": {
            "condition": "When calculating percentages of users who are teenagers",
            "operation": " use age range BETWEEN 13 AND 18 instead of 13 AND 19 to correctly identify teenagers."
        },
        "369": {
            "condition": "When performing conditional counting",
            "operation": " use SUM(IIF(condition, 1, 0)) instead of COUNT(CASE WHEN condition THEN 1 END)."
        },
        "370": {
            "condition": "When calculating percentages with division",
            "operation": " cast the sum to REAL instead of using 100.0 for proper floating-point division."
        },
        "371": {
            "condition": "When joining users and badges tables",
            "operation": " use join condition T1.UserId = T2.Id with proper table aliases."
        },
        "372": {
            "condition": "When filtering for \"Organizer\" badges",
            "operation": " use T1.Name = 'Organizer' with proper table reference."
        },
        "373": {
            "condition": "When calculating percentages of users who are teenagers, When performing conditional counting, When calculating percentages with division, When joining users and badges tables, When filtering for \"Organizer\" badges, When calculating percentage formulas",
            "operation": " use SUM(...) * 100 / COUNT(...) instead of COUNT(...) * 100.0 / COUNT(*) for accurate computation."
        },
        "374": {
            "condition": "When answering about comment rating score for a specific post creation date",
            "operation": " make sure the output order: T1.Score"
        },
        "375": {
            "condition": "When the question mentions \"comment's rating score\"",
            "operation": " \"rating\" actually means \"T1.Score\" in schema"
        },
        "376": {
            "condition": "When the question mentions \"post which was created on 7/19/2010 7",
            "operation": "19:56 PM\": filter using T2.CreationDate with exact ISO format timestamp '2010-07-19 19:19:56.0' instead of '7/19/2010 7:19:56 PM'"
        },
        "377": {
            "condition": "When combining comments table T1 and posts table T2",
            "operation": " link rows where T1.PostId = T2.Id and keep only matching pairs (inner match)"
        },
        "378": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "379": {
            "condition": "When answering about comment rating score for a specific post creation date, When the question mentions \"comment's rating score\", When the question mentions \"post which was created on 7/19/2010 7, When combining comments table T1 and posts table T2, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of timestamp '2010-07-19 19:19:56.0'"
        },
        "380": {
            "condition": "When the question asks about a comment's rating score for a post created on a specific date",
            "operation": " filter on the comment's creation date (T1.CreationDate) rather than the post's creation date (T2.CreationDate) to correctly identify comments created on the specified date."
        },
        "381": {
            "condition": "When filtering by date '7/19/2010 7",
            "operation": "19:56 PM': use the exact literal value '2010-07-19 19:19:56.0' as shown in the amends, preserving the exact timestamp format."
        },
        "382": {
            "condition": "When the question asks about a comment's rating score for a post created on a specific date, When filtering by date '7/19/2010 7, When joining comments (T1) and posts (T2)",
            "operation": " use the exact join condition T1.PostId = T2.Id to link comments to their corresponding posts."
        },
        "383": {
            "condition": "When the question asks for detailed content of a comment",
            "operation": " select only the \"Text\" column from the comments table (T1.Text) instead of all columns."
        },
        "384": {
            "condition": "When combining comments and posts tables",
            "operation": " use an inner join where T1.PostId equals T2.Id (T1.PostId = T2.Id) to properly relate the tables."
        },
        "385": {
            "condition": "When filtering by creation date '7/19/2010 7",
            "operation": "37:33 PM': use the standardized timestamp format '2010-07-19 19:37:33.0' instead of the non-standard format."
        },
        "386": {
            "condition": "When referring to tables in the query",
            "operation": " use proper aliases T1 for comments and T2 for posts for clarity."
        },
        "387": {
            "condition": "When the question asks for detailed content of a comment, When combining comments and posts tables, When filtering by creation date '7/19/2010 7, When referring to tables in the query, When the question asks about comment content for a specific post creation time",
            "operation": " filter on the comment's CreationDate (T1.CreationDate) rather than the post's creation date."
        },
        "388": {
            "condition": "When the question asks for comments created at a specific timestamp",
            "operation": " filter on T1.CreationDate using the exact timestamp '2010-07-19 19:37:33.0'"
        },
        "389": {
            "condition": "When joining comments and posts tables",
            "operation": " link rows where T1.PostId equals T2.Id to connect comments to their parent posts"
        },
        "390": {
            "condition": "When the question asks for comments created at a specific timestamp, When joining comments and posts tables, When answering about detailed comment content",
            "operation": " output the T1.Text column to show the comment text"
        },
        "391": {
            "condition": "When answering about \"users who located in Vienna, Austria obtained the badge\"",
            "operation": " make sure to combine the users table (T1) and badges table (T2) using an inner match where T1.Id equals T2.UserId."
        },
        "392": {
            "condition": "When the question mentions \"age of users\"",
            "operation": " use the exact column token T1.Age for output."
        },
        "393": {
            "condition": "When filtering for users located in Vienna, Austria",
            "operation": " use the exact literal 'Vienna, Austria' for the location condition."
        },
        "394": {
            "condition": "When answering about \"users who located in Vienna, Austria obtained the badge\", When the question mentions \"age of users\", When filtering for users located in Vienna, Austria, When determining which users obtained badges",
            "operation": " rely on the inner join with badges table (T2) instead of using a badge_obtained column condition."
        },
        "395": {
            "condition": "When counting users who obtained a badge",
            "operation": " count using the canonical key T1.Id from the users table instead of counting all rows."
        },
        "396": {
            "condition": "When combining user and badge information",
            "operation": " link rows where T1.Id = T2.UserId using an inner join between users table (T1) and badges table (T2)."
        },
        "397": {
            "condition": "When filtering for users with a specific badge",
            "operation": " use the exact literal 'Supporter' for T2.Name."
        },
        "398": {
            "condition": "When counting users who obtained a badge, When combining user and badge information, When filtering for users with a specific badge, When identifying adult users",
            "operation": " filter for users where T1.Age is between 19 and 65 inclusive."
        },
        "399": {
            "condition": "When answering about \"number of views of users who obtained the badge on 7/19/2010 7",
            "operation": "39:08 PM\": make sure the output order: T1.Views."
        },
        "400": {
            "condition": "When the question mentions \"number of views\"",
            "operation": " \"number of views\" actually means \"T1.Views in schema\"."
        },
        "401": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "402": {
            "condition": "When answering about \"number of views of users who obtained the badge on 7/19/2010 7, When the question mentions \"number of views\", When combining T1 and T2 for shared entities, When the question specifies a timestamp \"7/19/2010 7",
            "operation": "39:08 PM\": use the exact timestamp format including milliseconds as referenced in T2.Date."
        },
        "403": {
            "condition": "When the question asks for views of users who obtained a badge on a specific timestamp",
            "operation": " use the exact timestamp format '2010-07-19 19:39:08.0' with the .0 suffix for precise matching."
        },
        "404": {
            "condition": "When combining users table (T1) and badges table (T2)",
            "operation": " link rows where T1.Id = T2.UserId to find users who obtained badges."
        },
        "405": {
            "condition": "When filtering for badges obtained on 7/19/2010 7",
            "operation": "39:08 PM: use the condition T2.Date = '2010-07-19 19:39:08.0' exactly as specified."
        },
        "406": {
            "condition": "When the question asks for views of users who obtained a badge on a specific timestamp, When combining users table (T1) and badges table (T2), When filtering for badges obtained on 7/19/2010 7, When selecting output",
            "operation": " return T1.Views column from the users table for matching users."
        },
        "407": {
            "condition": "When selecting badge names",
            "operation": " use T2.Name as the output column."
        },
        "408": {
            "condition": "When joining users and badges tables",
            "operation": " use INNER JOIN with the condition T1.Id = T2.UserId."
        },
        "409": {
            "condition": "When filtering for users with minimum reputation",
            "operation": " use T1.Reputation = (SELECT MIN(T1.Reputation) FROM T1)."
        },
        "410": {
            "condition": "When selecting badge names, When joining users and badges tables, When filtering for users with minimum reputation, When referring to table aliases",
            "operation": " use T1 for users table and T2 for badges table."
        },
        "411": {
            "condition": "When combining users and badges tables",
            "operation": " link rows where T1.Id = T2.UserId and keep only matching pairs (inner match)."
        },
        "412": {
            "condition": "When filtering for a specific display name",
            "operation": " use T1.DisplayName = 'Sharpie' exactly as specified."
        },
        "413": {
            "condition": "When selecting badge information",
            "operation": " reference the badge name column as T2.Name."
        },
        "414": {
            "condition": "When combining users and badges tables, When filtering for a specific display name, When selecting badge information, When answering about badge names for a specific user",
            "operation": " make sure the output order includes only the badge name column."
        },
        "415": {
            "condition": "When answering about \"how many elders obtained the Supporter badge\"",
            "operation": " make sure the output order: COUNT(T1.Id)."
        },
        "416": {
            "condition": "When the question mentions \"elders\"",
            "operation": " \"elders\" actually means \"users with Age > 65\" in schema."
        },
        "417": {
            "condition": "When the question mentions \"Supporter badge\"",
            "operation": " \"Supporter badge\" actually means \"badges with Name = 'Supporter'\" in schema."
        },
        "418": {
            "condition": "When combining T1 (users) and T2 (badges) for shared entities",
            "operation": " link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "419": {
            "condition": "When answering about \"how many elders obtained the Supporter badge\", When the question mentions \"elders\", When the question mentions \"Supporter badge\", When combining T1 (users) and T2 (badges) for shared entities, When counting users",
            "operation": " compute the number of rows using the canonical key token T1.Id for users."
        },
        "420": {
            "condition": "When the question asks for the name of a user",
            "operation": " use the exact column token \"DisplayName\" from the users table instead of \"name\"."
        },
        "421": {
            "condition": "When filtering by user ID",
            "operation": " use the exact column token \"Id\" from the users table instead of \"user_id\"."
        },
        "422": {
            "condition": "When the question asks for the name of a user, When filtering by user ID, When the question specifies a user ID value of 30",
            "operation": " use the exact literal value 30 without quotes for numeric comparison."
        },
        "423": {
            "condition": "When counting users",
            "operation": " count the \"Id\" column instead of all columns to exclude null values."
        },
        "424": {
            "condition": "When filtering by location",
            "operation": " use the \"Location\" column instead of \"city\" to match the correct schema column."
        },
        "425": {
            "condition": "When counting users, When filtering by location, When querying for New York users",
            "operation": " filter for the exact literal 'New York' instead of 'California' to match the question requirement."
        },
        "426": {
            "condition": "When counting votes",
            "operation": " count the \"id\" column instead of all columns to avoid counting NULL values."
        },
        "427": {
            "condition": "When filtering by year 2010",
            "operation": " use STRFTIME('%Y', \"CreationDate\") = '2010' to extract the year from the timestamp field rather than using a non-existent \"year\" column."
        },
        "428": {
            "condition": "When counting votes, When filtering by year 2010, When answering about votes in 2010",
            "operation": " make sure the output order: count of vote \"id\" values from records where the year portion of \"CreationDate\" equals '2010'."
        },
        "429": {
            "condition": "When counting users",
            "operation": " use COUNT(\"id\") to count specific non-null values rather than all rows."
        },
        "430": {
            "condition": "When counting users, When filtering for adult users",
            "operation": " use age BETWEEN 19 AND 65 to filter for adult working age range instead of minors."
        },
        "431": {
            "condition": "When answering about \"users with the highest number of views\"",
            "operation": " make sure the output order: Id, DisplayName."
        },
        "432": {
            "condition": "When the question mentions \"users\"",
            "operation": " use the \"users\" table as T1."
        },
        "433": {
            "condition": "When the question asks for \"highest number of views\"",
            "operation": " filter to only include rows where Views equals the maximum Views value from the users table."
        },
        "434": {
            "condition": "When selecting columns",
            "operation": " use the exact tokens \"Id\" and \"DisplayName\" from the users table."
        },
        "435": {
            "condition": "When answering about \"users with the highest number of views\", When the question mentions \"users\", When the question asks for \"highest number of views\", When selecting columns, When computing maximum views",
            "operation": " use the exact column token \"Views\" from the users table in the subquery SELECT MAX(Views) FROM users."
        },
        "436": {
            "condition": "When the question asks about votes in specific years",
            "operation": " extract the year from \"CreationDate\" column using STRFTIME('%Y', CreationDate) instead of assuming a separate \"year\" column exists."
        },
        "437": {
            "condition": "When calculating counts for specific years",
            "operation": " use SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) for 2010 votes and SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) for 2011 votes instead of separate subqueries."
        },
        "438": {
            "condition": "When computing a ratio between two counts",
            "operation": " cast the numerator as REAL to prevent integer division issues."
        },
        "439": {
            "condition": "When the question asks about votes in specific years, When calculating counts for specific years, When computing a ratio between two counts, When the question asks for a single ratio result",
            "operation": " do not use LIMIT 1 or unnecessary column aliases, perform the calculation in a single SELECT expression."
        },
        "440": {
            "condition": "When answering about \"tags used by John Salvatier's\"",
            "operation": " make sure the output order: T3.Tags"
        },
        "441": {
            "condition": "When the question mentions \"John Salvatier's\"",
            "operation": " \"John Salvatier's\" actually means \"T1.DisplayName = 'John Salvatier'\" in schema"
        },
        "442": {
            "condition": "When combining T1 (users), T2 (postHistory), and T3 (posts) for shared entities",
            "operation": " link rows where T1.Id = T2.UserId and T2.PostId = T3.Id; keep only matching pairs (inner match)"
        },
        "443": {
            "condition": "When answering about \"tags used by John Salvatier's\", When the question mentions \"John Salvatier's\", When combining T1 (users), T2 (postHistory), and T3 (posts) for shared entities, When selecting tags",
            "operation": " use T3.Tags from the posts table instead of tag_name from a tags table"
        },
        "444": {
            "condition": "When answering about \"tags used by John Salvatier's\"",
            "operation": " make sure the output order: T3.Tags"
        },
        "445": {
            "condition": "When the question mentions \"John Salvatier's\"",
            "operation": " \"John Salvatier's\" actually means \"T1.DisplayName = 'John Salvatier'\" in schema"
        },
        "446": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.Id = T2.UserId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "447": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.PostId = T3.Id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "448": {
            "condition": "When selecting tags from posts",
            "operation": " do not include DISTINCT filtering as it is unnecessary for this query"
        },
        "449": {
            "condition": "When answering about \"tags used by John Salvatier's\", When the question mentions \"John Salvatier's\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When selecting tags from posts, When checking for tags",
            "operation": " do not include T3.Tags IS NOT NULL filter as it is redundant for this query"
        },
        "450": {
            "condition": "When counting posts created by a specific user",
            "operation": " count using T1.Id from the users table instead of counting all rows from the posts table."
        },
        "451": {
            "condition": "When the question mentions \"Daniel Vassallo\"",
            "operation": " this refers to T1.DisplayName = 'Daniel Vassallo' exactly as written."
        },
        "452": {
            "condition": "When combining user information with post history",
            "operation": " link rows where T1.Id = T2.UserId using an inner join between users table (T1) and postHistory table (T2)."
        },
        "453": {
            "condition": "When counting posts created by a specific user, When the question mentions \"Daniel Vassallo\", When combining user information with post history, When answering about posts created by a user",
            "operation": " make sure to join the users table with postHistory table to correctly associate users with their posts."
        },
        "454": {
            "condition": "When counting votes",
            "operation": " use COUNT(T1.Id) to count specific user IDs rather than all rows."
        },
        "455": {
            "condition": "When identifying a user by name",
            "operation": " use T1.DisplayName = 'Harlan' instead of voter_name to correctly identify the user by display name."
        },
        "456": {
            "condition": "When counting votes, When identifying a user by name, When combining user and vote data",
            "operation": " join users AS T1 to postHistory AS T2 using T1.Id = T2.UserId, then join to votes AS T3 using T3.PostId = T2.PostId to properly link votes to posts created by the user."
        },
        "457": {
            "condition": "When answering about \"post by slashnick with most answers\"",
            "operation": " make sure the output order: T2.PostId."
        },
        "458": {
            "condition": "When the question mentions \"slashnick\"",
            "operation": " \"slashnick\" actually means \"T1.DisplayName = 'slashnick'\" in schema."
        },
        "459": {
            "condition": "When combining T1 (users) and T2 (postHistory) for shared entities",
            "operation": " link rows where T1.Id = T2.UserId and keep only matching pairs (inner match)."
        },
        "460": {
            "condition": "When combining T2 (postHistory) and T3 (posts) for shared entities",
            "operation": " link rows where T2.PostId = T3.Id and keep only matching pairs (inner match)."
        },
        "461": {
            "condition": "When the question mentions \"most answers count\" or \"highest answer count\"",
            "operation": " rank rows by T3.AnswerCount in descending direction and keep the first 1 row."
        },
        "462": {
            "condition": "When answering about \"post by slashnick with most answers\", When the question mentions \"slashnick\", When combining T1 (users) and T2 (postHistory) for shared entities, When combining T2 (postHistory) and T3 (posts) for shared entities, When the question mentions \"most answers count\" or \"highest answer count\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "463": {
            "condition": "When answering about user popularity based on posts",
            "operation": " use users as the main table (T1) instead of posts directly."
        },
        "464": {
            "condition": "When combining user information with post data",
            "operation": " link users to postHistory using T1.Id = T2.UserId (inner match) and link postHistory to posts using T2.PostId = T3.Id (inner match)."
        },
        "465": {
            "condition": "When the question mentions authors \"Harvey Motulsky\" and \"Noah Snyder\"",
            "operation": " filter on T1.DisplayName with OR conditions for exactly 'Harvey Motulsky' and 'Noah Snyder' instead of using IN clause."
        },
        "466": {
            "condition": "When computing popularity per user",
            "operation": " group results by T1.DisplayName and calculate SUM(T3.ViewCount) as the popularity metric."
        },
        "467": {
            "condition": "When determining which user has higher popularity",
            "operation": " order results by SUM(T3.ViewCount) in descending direction and keep only the top 1 row."
        },
        "468": {
            "condition": "When answering about user popularity based on posts, When combining user information with post data, When the question mentions authors \"Harvey Motulsky\" and \"Noah Snyder\", When computing popularity per user, When determining which user has higher popularity, When selecting output",
            "operation": " return only T1.DisplayName instead of multiple columns."
        },
        "469": {
            "condition": "When answering about \"posts by Matt Parker\"",
            "operation": " make sure to join tables users (T1), posts (T2), postHistory (T3), and votes (T4) using the relationships implied by the schema."
        },
        "470": {
            "condition": "When the question mentions \"Matt Parker\"",
            "operation": " use T1.DisplayName = 'Matt Parker' exactly to filter by user display name."
        },
        "471": {
            "condition": "When counting posts",
            "operation": " count using T1.Id (the user's canonical key) instead of counting all rows."
        },
        "472": {
            "condition": "When filtering for posts with more than 4 votes",
            "operation": " use HAVING COUNT(T4.Id) > 4 instead of a WHERE clause condition on votes."
        },
        "473": {
            "condition": "When answering about \"posts by Matt Parker\", When the question mentions \"Matt Parker\", When counting posts, When filtering for posts with more than 4 votes, When grouping results",
            "operation": " use GROUP BY T2.PostId, T4.Id to organize the count properly by post and vote identifiers."
        },
        "474": {
            "condition": "When answering about \"posts by Matt Parker\"",
            "operation": " make sure to include the posts table (T3) in the FROM clause and join it between postHistory and votes tables."
        },
        "475": {
            "condition": "When joining tables",
            "operation": " link postHistory (T2) to posts (T3) using T2.PostId = T3.Id, and link votes (T4) to posts (T3) using T4.PostId = T3.Id."
        },
        "476": {
            "condition": "When counting posts with more than 4 votes",
            "operation": " use COUNT(T1.Id) instead of COUNT(DISTINCT T2.PostId) to count the correct entities."
        },
        "477": {
            "condition": "When grouping for the HAVING condition",
            "operation": " include both T2.PostId and T4.Id in the GROUP BY clause instead of just T2.PostId."
        },
        "478": {
            "condition": "When answering about \"posts by Matt Parker\", When joining tables, When counting posts with more than 4 votes, When grouping for the HAVING condition, When filtering for Matt Parker's posts",
            "operation": " use T1.DisplayName = 'Matt Parker' exactly as specified with the exact case and spacing."
        },
        "479": {
            "condition": "When the question asks about comments for a specific user",
            "operation": " join users as T1 with posts as T2 using T1.Id = T2.OwnerUserId, then join comments as T3 with T2 using T2.Id = T3.PostId to establish the proper relationships between users, their posts, and comments on those posts."
        },
        "480": {
            "condition": "When filtering for a user named 'Neil McGuigan'",
            "operation": " use T1.DisplayName = 'Neil McGuigan' instead of an author field in the comments table."
        },
        "481": {
            "condition": "When identifying negative comments",
            "operation": " use T3.Score < 60 instead of a sentiment field, as low scores indicate negative feedback."
        },
        "482": {
            "condition": "When the question asks about comments for a specific user, When filtering for a user named 'Neil McGuigan', When identifying negative comments, When counting comments",
            "operation": " count T3.Id to accurately count comment records rather than using COUNT(*) which might include non-comment rows."
        },
        "483": {
            "condition": "When answering about tags used by a specific user in posts without comments",
            "operation": " make sure the output order: T3.Tags"
        },
        "484": {
            "condition": "When the question mentions \"Mark Meckes\"",
            "operation": " \"Mark Meckes\" actually means \"T1.DisplayName = 'Mark Meckes'\" in schema"
        },
        "485": {
            "condition": "When the question mentions \"doesn't have comments\"",
            "operation": " \"doesn't have comments\" actually means \"T3.CommentCount = 0\" in schema"
        },
        "486": {
            "condition": "When combining T1 (users) and T2 (postHistory) for shared entities",
            "operation": " link rows where T1.Id = T2.UserId and keep only matching pairs (inner match)"
        },
        "487": {
            "condition": "When combining T2 (postHistory) and T3 (posts) for shared entities",
            "operation": " link rows where T3.Id = T2.PostId and keep only matching pairs (inner match)"
        },
        "488": {
            "condition": "When selecting tags from posts",
            "operation": " use T3.Tags instead of tags from a separate tags table"
        },
        "489": {
            "condition": "When answering about tags used by a specific user in posts without comments, When the question mentions \"Mark Meckes\", When the question mentions \"doesn't have comments\", When combining T1 (users) and T2 (postHistory) for shared entities, When combining T2 (postHistory) and T3 (posts) for shared entities, When selecting tags from posts, When retrieving all tags without duplicates",
            "operation": " do not use DISTINCT to remove duplicates"
        },
        "490": {
            "condition": "When answering about \"users that obtained the Organizer Badges\"",
            "operation": " make sure to combine the users table (as T1) and badges table (as T2) by linking rows where T1.Id equals T2.UserId, keeping only matching pairs."
        },
        "491": {
            "condition": "When the question mentions \"name of users\"",
            "operation": " \"name\" actually means \"T1.DisplayName\" in the schema."
        },
        "492": {
            "condition": "When filtering for Organizer Badges",
            "operation": " use the exact literal 'Organizer' for T2.Name instead of badge_type."
        },
        "493": {
            "condition": "When answering about \"users that obtained the Organizer Badges\", When the question mentions \"name of users\", When filtering for Organizer Badges, When producing output",
            "operation": " return only T1.DisplayName in the results."
        },
        "494": {
            "condition": "When answering about posts by Community",
            "operation": " use T1.DisplayName = 'Community' to identify the Community user instead of author = 'Community'."
        },
        "495": {
            "condition": "When calculating percentage of posts using R language",
            "operation": " use SUM(IIF(T3.TagName = 'r', 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN language = 'R' THEN 1 END)."
        },
        "496": {
            "condition": "When combining data from multiple tables",
            "operation": " join users AS T1, postHistory AS T2, and tags AS T3 using INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId and INNER JOIN tags AS T3 ON T3.ExcerptPostId = T2.PostId instead of using a single posts table."
        },
        "497": {
            "condition": "When answering about posts by Community, When calculating percentage of posts using R language, When combining data from multiple tables, When filtering for specific user",
            "operation": " incorporate the filter T1.DisplayName = 'Community' into the join structure instead of using a standalone WHERE clause."
        },
        "498": {
            "condition": "When answering about view count difference between posts by Mornington and Amos",
            "operation": " use a single query with INNER JOIN operations on users, postHistory, and posts tables instead of separate subqueries."
        },
        "499": {
            "condition": "When identifying authors",
            "operation": " use T1.DisplayName for author identification instead of the non-existent author column."
        },
        "500": {
            "condition": "When calculating separate sums for different authors",
            "operation": " use conditional aggregation with IIF functions to calculate sums for 'Mornington' and 'Amos' instead of subtracting results from independent subqueries."
        },
        "501": {
            "condition": "When answering about view count difference between posts by Mornington and Amos, When identifying authors, When calculating separate sums for different authors, When joining tables through the user-post relationship hierarchy",
            "operation": " use the proper relationship chain with T1.Id = T2.UserId and T3.Id = T2.PostId instead of assuming direct author relationships in the posts table."
        },
        "502": {
            "condition": "When calculating view count differences between specific users",
            "operation": " traverse the user-post relationship through postHistory table using T1.Id = T2.UserId and T3.Id = T2.PostId instead of direct user-post joins."
        },
        "503": {
            "condition": "When filtering for specific users 'Mornington' and 'Amos'",
            "operation": " use conditional aggregation with IIF(T1.DisplayName = 'Mornington', T3.ViewCount,"
        },
        "504": {
            "condition": "and IIF(T1.DisplayName = 'Amos', T3.ViewCount,",
            "operation": "and IIF(T1.DisplayName = 'Amos', T3.ViewCount,"
        },
        "505": {
            "condition": "instead of WHERE clause filtering.",
            "operation": "instead of WHERE clause filtering."
        },
        "506": {
            "condition": "When computing the difference between two aggregated values",
            "operation": " subtract the sum for 'Amos' from the sum for 'Mornington' and alias the result as 'diff' exactly."
        },
        "507": {
            "condition": "When calculating view count differences between specific users, When filtering for specific users 'Mornington' and 'Amos', and IIF(T1.DisplayName = 'Amos', T3.ViewCount,, instead of WHERE clause filtering., When computing the difference between two aggregated values, When joining tables in this schema",
            "operation": " perform inner joins only and ensure proper key relationships between users (T1), postHistory (T2), and posts (T3) tables."
        },
        "508": {
            "condition": "When counting users who received badges",
            "operation": " use COUNT(Id) instead of COUNT(*) to count specific non-null values."
        },
        "509": {
            "condition": "When referencing the badge name column",
            "operation": " use exact column name \"Name\" with proper case sensitivity instead of \"name\"."
        },
        "510": {
            "condition": "When referencing the badge date column",
            "operation": " use exact column name \"Date\" with proper case sensitivity instead of \"date\"."
        },
        "511": {
            "condition": "When extracting year from date values",
            "operation": " use STRFTIME('%Y', Date) = '2014' instead of YEAR(date) = 2014 to properly handle SQLite date functions and compare against string literal '2014'."
        },
        "512": {
            "condition": "When counting users who received badges, When referencing the badge name column, When referencing the badge date column, When extracting year from date values, When filtering for Commentator badges",
            "operation": " use exact literal value 'Commentator' for the Name column comparison."
        },
        "513": {
            "condition": "When the question asks about posts created on a specific date",
            "operation": " use table \"postHistory\" instead of \"posts\" and column \"CreationDate\" instead of \"created_at\"."
        },
        "514": {
            "condition": "When comparing date values from timestamp columns",
            "operation": " apply the date() function to \"CreationDate\" to extract the date portion before comparison."
        },
        "515": {
            "condition": "When counting posts",
            "operation": " count the \"id\" column for precise counting instead of using COUNT(*)."
        },
        "516": {
            "condition": "When specifying date literals",
            "operation": " use the exact format '2010-07-21' with dashes and no time component."
        },
        "517": {
            "condition": "When the question asks about posts created on a specific date, When comparing date values from timestamp columns, When counting posts, When specifying date literals, When the question asks about posts created on July 21st, 2010",
            "operation": " filter where date(\"CreationDate\") equals '2010-07-21'."
        },
        "518": {
            "condition": "When the question asks for \"display names and ages\"",
            "operation": " select \"DisplayName\" and \"Age\" from table users."
        },
        "519": {
            "condition": "When the question asks for users with the \"highest in views\"",
            "operation": " filter rows where \"Views\" equals the maximum value of \"Views\" from the same table."
        },
        "520": {
            "condition": "When the question asks for \"display names and ages\", When the question asks for users with the \"highest in views\", When computing maximum views",
            "operation": " calculate the maximum value of \"Views\" column from all rows in the users table."
        },
        "521": {
            "condition": "When selecting the last edit date",
            "operation": " use column \"LastEditDate\" instead of \"last_edit_date\"."
        },
        "522": {
            "condition": "When selecting the last edit user ID",
            "operation": " use column \"LastEditorUserId\" instead of \"last_edit_user_id\"."
        },
        "523": {
            "condition": "When selecting the last edit date, When selecting the last edit user ID, When filtering by post title",
            "operation": " use column \"Title\" instead of \"title\" and match the exact literal value 'Detecting a given face in a database of facial images'."
        },
        "524": {
            "condition": "When counting entities from the votes table",
            "operation": " use the \"Id\" column instead of counting all columns to exclude null values."
        },
        "525": {
            "condition": "When filtering for negative comments",
            "operation": " use the condition \"Score < 60\" instead of text pattern matching to apply a numeric threshold."
        },
        "526": {
            "condition": "When referencing user identification",
            "operation": " use the exact column name \"UserId\" instead of \"user_id\" to match the schema."
        },
        "527": {
            "condition": "When counting entities from the votes table, When filtering for negative comments, When referencing user identification, When counting comments for a specific user",
            "operation": " filter using \"UserId = 13\" to find comments by user ID 13."
        },
        "528": {
            "condition": "When selecting post titles and user display names",
            "operation": " use exact column names \"Title\" and \"UserDisplayName\" instead of \"title\" and \"display_name\"."
        },
        "529": {
            "condition": "When joining tables",
            "operation": " use INNER JOIN with comments table as T2 instead of joining both comments and users tables."
        },
        "530": {
            "condition": "When linking posts and comments",
            "operation": " join on T2.PostId = T2.Id instead of p.post_id = c.post_id and c.user_id = u.user_id."
        },
        "531": {
            "condition": "When filtering for positive engagement",
            "operation": " use T1.Score > 60 instead of sentiment-based filtering."
        },
        "532": {
            "condition": "When selecting post titles and user display names, When joining tables, When linking posts and comments, When filtering for positive engagement, When the question involves user information from comments",
            "operation": " do not join the users table directly as the user display name is available in the comments table as \"UserDisplayName\"."
        },
        "533": {
            "condition": "When combining posts and comments tables",
            "operation": " link rows where T2.PostId = T2.Id to properly relate the tables and keep only matching pairs (inner match)."
        },
        "534": {
            "condition": "When filtering for positive comments",
            "operation": " use T1.Score > 60 to filter on the posts table score instead of comments score."
        },
        "535": {
            "condition": "When combining posts and comments tables, When filtering for positive comments, When answering about post titles and user display names",
            "operation": " make sure the output order: T1.Title, T2.UserDisplayName."
        },
        "536": {
            "condition": "When joining comments table T2 to posts table T1",
            "operation": " use the join condition T2.PostId = T1.Id to correctly link comments to their parent posts."
        },
        "537": {
            "condition": "When filtering for positive comments",
            "operation": " use the condition T2.Score > 0 to identify comments with positive scores."
        },
        "538": {
            "condition": "When joining comments table T2 to posts table T1, When filtering for positive comments, When answering about post titles and user display names",
            "operation": " make sure the output order is T1.Title followed by T2.UserDisplayName."
        },
        "539": {
            "condition": "When joining comments table (T2) to posts table (T1)",
            "operation": " use the join condition T2.PostId = T2.Id to correctly link comments to their own ID rather than incorrectly joining comments to posts via the wrong column reference."
        },
        "540": {
            "condition": "When the question asks for \"positive comments\"",
            "operation": " use the condition T1.Score > 60 to identify posts with positive scores."
        },
        "541": {
            "condition": "When joining comments table (T2) to posts table (T1), When the question asks for \"positive comments\", When answering about \"post title which got positive comments and display names of the users who posted those comments\"",
            "operation": " make sure the output order: T1.Title, T2.UserDisplayName."
        },
        "542": {
            "condition": "When answering about badge names for users from a specific location",
            "operation": " join users table as T1 with badges table as T2 on T1.Id = T2.UserId to link user information with their badges."
        },
        "543": {
            "condition": "When filtering by year 2011",
            "operation": " extract the year from T2.Date column using STRFTIME('%Y', T2.Date) = '2011' instead of using a simple year column."
        },
        "544": {
            "condition": "When filtering by location 'North Pole'",
            "operation": " use T1.Location = 'North Pole' from the users table instead of location from the badges table."
        },
        "545": {
            "condition": "When answering about badge names for users from a specific location, When filtering by year 2011, When filtering by location 'North Pole', When selecting badge names",
            "operation": " use T2.Name from the badges table instead of badge_name."
        },
        "546": {
            "condition": "When answering about \"users' display names and available website URLs of the post with favorite count of more than 150\"",
            "operation": " make sure the output order: T1.DisplayName, T1.WebsiteUrl."
        },
        "547": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.Id = T2.OwnerUserId; keep only matching pairs (inner match)."
        },
        "548": {
            "condition": "When answering about \"users' display names and available website URLs of the post with favorite count of more than 150\", When combining T1 and T2 for shared entities, When filtering for posts with favorite count more than 150",
            "operation": " include only rows where T2.FavoriteCount > 150."
        },
        "549": {
            "condition": "When answering about post history counts and last edit date",
            "operation": " make sure the output order: post history ID and last edit date."
        },
        "550": {
            "condition": "When the question mentions \"post title\"",
            "operation": " \"post title\" actually means \"T2.Title in schema\"."
        },
        "551": {
            "condition": "When filtering for the specific post title \"What is the best introductory Bayesian statistics textbook?\"",
            "operation": " use the exact literal 'What is the best introductory Bayesian statistics textbook?' with T2.Title."
        },
        "552": {
            "condition": "When combining post history and posts tables",
            "operation": " link rows where T1.PostId = T2.Id and keep only matching pairs (inner match)."
        },
        "553": {
            "condition": "When answering about post history counts and last edit date, When the question mentions \"post title\", When filtering for the specific post title \"What is the best introductory Bayesian statistics textbook?\", When combining post history and posts tables, When selecting columns",
            "operation": " use T1.Id for post history identification and T2.LastEditDate for the last edit date instead of using aggregate functions."
        },
        "554": {
            "condition": "When the question asks about \"last accessed date\" and \"location\" of users",
            "operation": " use columns \"T1.LastAccessDate\" and \"T1.Location\" exactly as specified in the schema."
        },
        "555": {
            "condition": "When combining user and badge information",
            "operation": " perform an inner join where \"T1.Id = T2.UserId\" to match users with their badges."
        },
        "556": {
            "condition": "When filtering for users who received the 'outliers' badge",
            "operation": " use the exact literal 'outliers' and filter on \"T2.Name = 'outliers'\"."
        },
        "557": {
            "condition": "When the question asks about \"last accessed date\" and \"location\" of users, When combining user and badge information, When filtering for users who received the 'outliers' badge, When the question describes user details without ordering or limiting",
            "operation": " do not apply any ORDER BY or LIMIT clauses to the results."
        },
        "558": {
            "condition": "When the question asks for \"related post title\" of a specific post",
            "operation": " use the postLinks table (T1) to find relationships between posts."
        },
        "559": {
            "condition": "When joining postLinks (T1) with posts",
            "operation": " perform an inner join where T1.PostId = T2.Id to connect the linking record to the source post."
        },
        "560": {
            "condition": "When joining to get the related post",
            "operation": " perform another inner join where T1.RelatedPostId = T3.Id to connect to the target related post."
        },
        "561": {
            "condition": "When filtering for a specific post title",
            "operation": " use exact equality match T2.Title = 'How to tell if something happened in a data set which monitors a value over time' instead of content search."
        },
        "562": {
            "condition": "When the question asks for \"related post title\" of a specific post, When joining postLinks (T1) with posts, When joining to get the related post, When filtering for a specific post title, When selecting the output",
            "operation": " retrieve T3.Title from the related post table rather than title from the source post."
        },
        "563": {
            "condition": "When answering about \"post IDs and badge names of the user Samuel in 2013\"",
            "operation": " make sure the output order: T1.PostId, T2.Name"
        },
        "564": {
            "condition": "When the question mentions \"post IDs\"",
            "operation": " \"post IDs\" actually means \"T1.PostId in schema\""
        },
        "565": {
            "condition": "When the question mentions \"badge names\"",
            "operation": " \"badge names\" actually means \"T2.Name in schema\""
        },
        "566": {
            "condition": "When the question mentions \"user Samuel\"",
            "operation": " \"Samuel\" actually means \"T1.UserDisplayName = 'Samuel'\" with exact literal 'Samuel'"
        },
        "567": {
            "condition": "When the question mentions \"in 2013\"",
            "operation": " filter both T1 and T2 by their respective date fields using STRFTIME('%Y', T1.CreationDate) = '2013' and STRFTIME('%Y', T2.Date) = '2013'"
        },
        "568": {
            "condition": "When combining postHistory AS T1 and badges AS T2",
            "operation": " link rows where T1.UserId = T2.UserId and keep only matching pairs (inner match)"
        },
        "569": {
            "condition": "When answering about \"post IDs and badge names of the user Samuel in 2013\", When the question mentions \"post IDs\", When the question mentions \"badge names\", When the question mentions \"user Samuel\", When the question mentions \"in 2013\", When combining postHistory AS T1 and badges AS T2, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T1.PostId, T2.Name, T1.UserId, T2.UserId, T1.UserDisplayName, T1.CreationDate, T2.Date"
        },
        "570": {
            "condition": "When the question asks for the owner's display name of the most popular post",
            "operation": " use \"DisplayName\" from the \"users\" table instead of \"owner_display_name\" from \"posts\"."
        },
        "571": {
            "condition": "When finding the most popular post",
            "operation": " identify the post with the highest \"ViewCount\" value."
        },
        "572": {
            "condition": "When linking posts to their owners",
            "operation": " use the relationship where \"posts\".\"OwnerUserId\" equals \"users\".\"Id\"."
        },
        "573": {
            "condition": "When selecting the top result",
            "operation": " use a subquery to find the \"OwnerUserId\" with the maximum \"ViewCount\" first, then match it to the user's \"Id\"."
        },
        "574": {
            "condition": "When the question asks for the owner's display name of the most popular post, When finding the most popular post, When linking posts to their owners, When selecting the top result, When ordering results by popularity",
            "operation": " sort by \"ViewCount\" in descending order and take only the first result."
        },
        "575": {
            "condition": "When answering about \"display name and location of the user who owned the excerpt post with hypothesis-testing tag\"",
            "operation": " make sure the output order: DisplayName, Location."
        },
        "576": {
            "condition": "When the question mentions \"display name\"",
            "operation": " \"display name\" actually means \"DisplayName in users table\"."
        },
        "577": {
            "condition": "When the question mentions \"location\"",
            "operation": " \"location\" actually means \"Location in users table\"."
        },
        "578": {
            "condition": "When combining tags and posts for excerpt posts",
            "operation": " link rows where tags.ExcerptPostId = posts.Id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "579": {
            "condition": "When combining posts and users for ownership",
            "operation": " link rows where users.Id = posts.OwnerUserId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "580": {
            "condition": "When filtering for the hypothesis-testing tag",
            "operation": " include only rows where tags.tag_name = 'hypothesis-testing' exactly as specified."
        },
        "581": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "582": {
            "condition": "When answering about \"display name and location of the user who owned the excerpt post with hypothesis-testing tag\", When the question mentions \"display name\", When the question mentions \"location\", When combining tags and posts for excerpt posts, When combining posts and users for ownership, When filtering for the hypothesis-testing tag, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'hypothesis-testing'."
        },
        "583": {
            "condition": "When answering about related posts for a specific post title",
            "operation": " join the posts table as T1 with postLinks as T2 using T1.Id = T2.PostId, then join with posts as T3 using T2.RelatedPostId = T3.Id to get related post information."
        },
        "584": {
            "condition": "When the question asks for related post titles and link type IDs",
            "operation": " select T3.Title and T2.LinkTypeId from the joined tables."
        },
        "585": {
            "condition": "When answering about related posts for a specific post title, When the question asks for related post titles and link type IDs, When filtering for the specific post \"What are principal component scores?\"",
            "operation": " apply the condition T1.Title = 'What are principal component scores?' to the source post table T1, not the related post table T3."
        },
        "586": {
            "condition": "When the question asks for the display name of a user",
            "operation": " select \"DisplayName\" from the \"users\" table."
        },
        "587": {
            "condition": "When finding the highest-scoring child post",
            "operation": " use ORDER BY Score DESC LIMIT 1 instead of equality comparison with maximum score."
        },
        "588": {
            "condition": "When identifying the owner of a post",
            "operation": " use the \"OwnerUserId\" column from the \"posts\" table to link to the \"users\" table."
        },
        "589": {
            "condition": "When filtering for child posts",
            "operation": " use ParentId IS NOT NULL condition to identify posts that are replies."
        },
        "590": {
            "condition": "When the question asks for the display name of a user, When finding the highest-scoring child post, When identifying the owner of a post, When filtering for child posts, When joining user information for a post owner",
            "operation": " filter the \"users\" table where \"Id\" equals the \"OwnerUserId\" from the subquery result."
        },
        "591": {
            "condition": "When the question asks for display names and website URLs",
            "operation": " select \"DisplayName\" and \"WebsiteUrl\" from the users table."
        },
        "592": {
            "condition": "When the question mentions vote type of 8",
            "operation": " filter votes where \"VoteTypeId\" = 8."
        },
        "593": {
            "condition": "When the question asks for the highest bounty amount",
            "operation": " order votes by \"BountyAmount\" in descending order and take the first row."
        },
        "594": {
            "condition": "When combining user information with vote data",
            "operation": " link rows where users.\"Id\" equals the \"UserId\" from the votes table."
        },
        "595": {
            "condition": "When the question asks for display names and website URLs, When the question mentions vote type of 8, When the question asks for the highest bounty amount, When combining user information with vote data, When finding the user with specific vote criteria",
            "operation": " use a subquery to first identify the \"UserId\" with the highest bounty amount for vote type 8, then filter users where \"Id\" matches that subquery result."
        },
        "596": {
            "condition": "When the question asks for \"titles\"",
            "operation": " use the exact column name \"Title\" from the posts table."
        },
        "597": {
            "condition": "When the question mentions \"top 5\" and \"highest popularity\"",
            "operation": " rank rows by \"ViewCount\" in descending order and keep the first 5 rows."
        },
        "598": {
            "condition": "When the question asks for \"titles\", When the question mentions \"top 5\" and \"highest popularity\", When producing output",
            "operation": " make sure the output order includes only \"Title\" column."
        },
        "599": {
            "condition": "When counting tags",
            "operation": " use COUNT(\"Id\") instead of COUNT(*) to count specific non-null values rather than all rows."
        },
        "600": {
            "condition": "When the question mentions \"post count\"",
            "operation": " \"post count\" actually means \"Count\" in the schema."
        },
        "601": {
            "condition": "When counting tags, When the question mentions \"post count\", When filtering for values between 5,000 to 7,000",
            "operation": " use BETWEEN 5000 AND 7000 instead of separate >= 5000 AND <= 7000 conditions for more concise range filtering."
        },
        "602": {
            "condition": "When the question asks for \"owner user id\"",
            "operation": " select \"OwnerUserId\" from the \"posts\" table instead of \"user_id\"."
        },
        "603": {
            "condition": "When the question asks for the \"most valuable post\" based on \"FavoriteCount\"",
            "operation": " use a subquery with MAX(\"FavoriteCount\") to find the maximum value instead of ordering by \"value\"."
        },
        "604": {
            "condition": "When identifying the most valuable post",
            "operation": " use a WHERE filter comparing \"FavoriteCount\" to the maximum value from the subquery instead of using ORDER BY and LIMIT 1."
        },
        "605": {
            "condition": "When the question asks for \"owner user id\", When the question asks for the \"most valuable post\" based on \"FavoriteCount\", When identifying the most valuable post, When handling ties for maximum \"FavoriteCount\"",
            "operation": " the correlated subquery approach ensures all posts with the maximum favorite count are considered, not just one arbitrary row."
        },
        "606": {
            "condition": "When the question asks about \"most influential user\"",
            "operation": " use the column \"Reputation\" instead of \"influence_score\" to identify the user with maximum influence."
        },
        "607": {
            "condition": "When returning the age of the most influential user",
            "operation": " select the actual \"Age\" value rather than using MIN(age) aggregation."
        },
        "608": {
            "condition": "When the question asks about \"most influential user\", When returning the age of the most influential user, When filtering for the user with maximum reputation",
            "operation": " use the exact column name \"Reputation\" in both the main query and subquery for consistency."
        },
        "609": {
            "condition": "When counting posts with votes",
            "operation": " count using T1.Id instead of all columns to avoid counting null votes."
        },
        "610": {
            "condition": "When combining posts and votes tables",
            "operation": " use INNER JOIN with alias T1 for posts and T2 for votes, linking rows where T1.Id = T2.PostId."
        },
        "611": {
            "condition": "When filtering by bounty amount",
            "operation": " apply BountyAmount = 50 filter on T2 (votes table) since bounty amount belongs to votes."
        },
        "612": {
            "condition": "When filtering by creation year 2011",
            "operation": " use STRFTIME on T2.CreationDate instead of post creation date to filter by vote creation year."
        },
        "613": {
            "condition": "When counting posts with votes, When combining posts and votes tables, When filtering by bounty amount, When filtering by creation year 2011, When answering about posts with votes",
            "operation": " ensure the query counts posts that have matching votes with the specified conditions rather than counting all posts or votes."
        },
        "614": {
            "condition": "When the question asks for the youngest user",
            "operation": " use the minimum value of the \"Age\" column to identify users with the minimum age."
        },
        "615": {
            "condition": "When finding users with a specific age value",
            "operation": " use a WHERE filter with a subquery condition \"Age = (SELECT MIN(Age) FROM users)\" instead of ordering and limiting."
        },
        "616": {
            "condition": "When referencing the user identifier column",
            "operation": " use the exact case-sensitive column name \"Id\" instead of \"id\"."
        },
        "617": {
            "condition": "When the question asks for the youngest user, When finding users with a specific age value, When referencing the user identifier column, When the question asks for all users sharing the minimum age",
            "operation": " return all matching records rather than just one arbitrary record with that age value."
        },
        "618": {
            "condition": "When the question asks for sum of score",
            "operation": " use the exact column name \"Score\" from the posts table."
        },
        "619": {
            "condition": "When filtering by date '2010-07-19'",
            "operation": " use the column \"LasActivityDate\" with a pattern match using '2010-07-19%' to capture all records from that date regardless of time component."
        },
        "620": {
            "condition": "When the question asks for sum of score, When filtering by date '2010-07-19', When computing aggregates on posts",
            "operation": " ensure the query uses the correct column identifiers as specified in the schema without case or spelling variations."
        },
        "621": {
            "condition": "When calculating average monthly count for a year",
            "operation": " compute total annual count divided by 12 using CAST(COUNT(T1.Id) AS REAL) / 12 instead of averaging monthly counts."
        },
        "622": {
            "condition": "When referencing the postLinks table",
            "operation": " use alias T1 instead of links l."
        },
        "623": {
            "condition": "When referencing the posts table",
            "operation": " use alias T2 instead of posts p."
        },
        "624": {
            "condition": "When joining T1 and T2",
            "operation": " use INNER JOIN with T1.PostId = T2.Id instead of l.post_id = p.id."
        },
        "625": {
            "condition": "When filtering by year 2010",
            "operation": " use strftime('%Y', T1.CreationDate) = '2010' in the main WHERE clause."
        },
        "626": {
            "condition": "When filtering posts by answer count",
            "operation": " use T2.AnswerCount <= 2 instead of p.answer_count <= 2."
        },
        "627": {
            "condition": "When counting links",
            "operation": " use T1.Id as the counting key instead of generic COUNT(*)."
        },
        "628": {
            "condition": "When calculating average monthly count for a year, When referencing the postLinks table, When referencing the posts table, When joining T1 and T2, When filtering by year 2010, When filtering posts by answer count, When counting links, When grouping is not required for monthly average calculation",
            "operation": " remove GROUP BY strftime('%m', l.creation_date) clause."
        },
        "629": {
            "condition": "When answering about \"posts voted by user 1465\"",
            "operation": " combine tables T1 (votes) and T2 (posts) using inner match where T1.PostId = T2.Id."
        },
        "630": {
            "condition": "When filtering for user 1465",
            "operation": " include only rows where T1.UserId = 1465."
        },
        "631": {
            "condition": "When determining the most valuable post",
            "operation": " rank posts by T2.FavoriteCount in descending order."
        },
        "632": {
            "condition": "When selecting the top post",
            "operation": " take the first row after ranking by T2.FavoriteCount DESC."
        },
        "633": {
            "condition": "When answering about \"posts voted by user 1465\", When filtering for user 1465, When determining the most valuable post, When selecting the top post, When outputting results",
            "operation": " return T2.Id as the post identifier."
        },
        "634": {
            "condition": "When answering about \"the title of the post with the oldest post link\"",
            "operation": " make sure the output order: T1.Title."
        },
        "635": {
            "condition": "When combining posts table (T1) and postLinks table (T2)",
            "operation": " link rows where T2.PostId = T1.Id exactly as shown; keep only matching pairs (inner match)."
        },
        "636": {
            "condition": "When answering about \"the title of the post with the oldest post link\", When combining posts table (T1) and postLinks table (T2), When the question mentions \"oldest\"",
            "operation": " sort rows by T1.CreationDate in ascending order and keep the first 1 row."
        },
        "637": {
            "condition": "When the question asks for the \"oldest post link\"",
            "operation": " order by the exact column \"T1.CreaionDate\" in ascending order (oldest first) instead of the misspelled \"T1.CreationDate\"."
        },
        "638": {
            "condition": "When ordering by date to find the oldest",
            "operation": " do not include the \"ASC\" keyword as ascending order is the default behavior."
        },
        "639": {
            "condition": "When the question asks for the \"oldest post link\", When ordering by date to find the oldest, When answering about the title of the post with the oldest post link",
            "operation": " make sure the output order includes only \"T1.Title\" as the result."
        },
        "640": {
            "condition": "When answering about \"user who acquired the highest amount of badges\"",
            "operation": " make sure the output order: T1.DisplayName."
        },
        "641": {
            "condition": "When the question mentions \"highest amount of badges\"",
            "operation": " count the number of badges per user using COUNT(T1.Id) and order in descending direction to find the maximum."
        },
        "642": {
            "condition": "When combining users and badges tables",
            "operation": " link rows where T1.Id = T2.UserId and keep only matching pairs (inner match)."
        },
        "643": {
            "condition": "When grouping by user",
            "operation": " organize results by T1.DisplayName and compute the badge count per group."
        },
        "644": {
            "condition": "When answering about \"user who acquired the highest amount of badges\", When the question mentions \"highest amount of badges\", When combining users and badges tables, When grouping by user, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "645": {
            "condition": "When the question asks about a user by display name 'chl'",
            "operation": " use the exact literal 'chl' to filter the DisplayName column from the users table."
        },
        "646": {
            "condition": "When combining users and votes tables",
            "operation": " link rows where users.Id equals votes.UserId using an inner join to maintain proper table relationships."
        },
        "647": {
            "condition": "When finding the first vote date for a user",
            "operation": " order the results by CreationDate in ascending order and take only the first row instead of using MIN() aggregate function."
        },
        "648": {
            "condition": "When selecting the vote creation date",
            "operation": " use the exact column name CreationDate from the votes table."
        },
        "649": {
            "condition": "When the question asks about a user by display name 'chl', When combining users and votes tables, When finding the first vote date for a user, When selecting the vote creation date, When the question asks about votes in posts",
            "operation": " do not apply post_id IS NOT NULL filter as the question does not specify this condition."
        },
        "650": {
            "condition": "When answering about the date when the youngest user made their first post",
            "operation": " make sure the output order includes T2.CreaionDate."
        },
        "651": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match)."
        },
        "652": {
            "condition": "When filtering for users with known age",
            "operation": " include only rows where T1.Age IS NOT NULL."
        },
        "653": {
            "condition": "When finding the youngest user's first post",
            "operation": " order rows by T1.Age (ascending for youngest) and T2.CreaionDate (ascending for earliest), then keep only the first row."
        },
        "654": {
            "condition": "When answering about the date when the youngest user made their first post, When combining users and posts tables, When filtering for users with known age, When finding the youngest user's first post, When selecting the creation date",
            "operation": " use T2.CreaionDate instead of MIN(created_at) aggregation."
        },
        "655": {
            "condition": "When counting users",
            "operation": " use COUNT(T1.Id) instead of COUNT(*) to count specific non-null values."
        },
        "656": {
            "condition": "When referencing tables",
            "operation": " use T1 for users table and T2 for posts table."
        },
        "657": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId using an inner join."
        },
        "658": {
            "condition": "When filtering by location",
            "operation": " use T1.Location = 'United Kingdom' exactly as specified."
        },
        "659": {
            "condition": "When counting users, When referencing tables, When combining users and posts tables, When filtering by location, When filtering by favorite count",
            "operation": " use T2.FavoriteCount >= 4 to filter individual posts with 4 or more favorites."
        },
        "660": {
            "condition": "When answering about \"average number of posts voted by the oldest users\"",
            "operation": " calculate the average of PostId from the votes table."
        },
        "661": {
            "condition": "When identifying the oldest users",
            "operation": " select users where Age equals the maximum Age value from all users."
        },
        "662": {
            "condition": "When filtering votes by the oldest users",
            "operation": " include only votes where UserId matches the Id of users with maximum Age."
        },
        "663": {
            "condition": "When answering about \"average number of posts voted by the oldest users\", When identifying the oldest users, When filtering votes by the oldest users, When computing the average",
            "operation": " use AVG(PostId) instead of any other aggregate function or column name."
        },
        "664": {
            "condition": "When the question asks for \"display name\"",
            "operation": " use the exact column token \"DisplayName\" from the users table."
        },
        "665": {
            "condition": "When the question asks for the \"highest reputation\"",
            "operation": " find the maximum value of the \"Reputation\" column using MAX(Reputation) instead of ordering and limiting."
        },
        "666": {
            "condition": "When the question asks for \"display name\", When the question asks for the \"highest reputation\", When identifying users with the highest reputation",
            "operation": " use a WHERE filter with a subquery that matches users whose Reputation equals the maximum Reputation value."
        },
        "667": {
            "condition": "When counting users",
            "operation": " count using the exact token \"id\" instead of counting all columns to avoid including NULL values."
        },
        "668": {
            "condition": "When the question asks for users with \"number of views is higher than 1000\"",
            "operation": " use the exact condition \"Views > 1000\" with the exact column name \"Views\" (case-sensitive)."
        },
        "669": {
            "condition": "When counting users, When the question asks for users with \"number of views is higher than 1000\", When the question asks for users with \"reputations are higher than 2000\"",
            "operation": " use the exact condition \"reputation > 2000\" with the exact column name \"reputation\" (lowercase)."
        },
        "670": {
            "condition": "When selecting display names from the users table",
            "operation": " use the exact column name \"DisplayName\" as shown in the schema."
        },
        "671": {
            "condition": "When filtering for adult users",
            "operation": " use the age range condition Age BETWEEN 19 AND 65 to include users from 19 to 65 years old inclusive."
        },
        "672": {
            "condition": "When selecting display names from the users table, When filtering for adult users, When the question asks for \"display names of users who are adults\"",
            "operation": " ensure the output contains only the DisplayName column with the specified age filter applied."
        },
        "673": {
            "condition": "DisplayName = 'Jay Stevens'; in 2010 refers to YEAR(CreationDate) = 2010;",
            "operation": "DisplayName = 'Jay Stevens'; in 2010 refers to YEAR(CreationDate) = 2010;"
        },
        "674": {
            "condition": "When answering about \"posts by Harvey Motulsky\"",
            "operation": " join users AS T1 with posts AS T2 on T1.Id = T2.OwnerUserId to establish the relationship between users and their posts."
        },
        "675": {
            "condition": "When filtering for posts by Harvey Motulsky",
            "operation": " use T1.DisplayName = 'Harvey Motulsky' instead of filtering directly on posts.author."
        },
        "676": {
            "condition": "When selecting post information",
            "operation": " use T2.Id and T2.Title instead of unqualified id and title."
        },
        "677": {
            "condition": "When finding the post with most views",
            "operation": " order by T2.ViewCount DESC instead of views ASC to get the highest value first."
        },
        "678": {
            "condition": "When answering about \"posts by Harvey Motulsky\", When filtering for posts by Harvey Motulsky, When selecting post information, When finding the post with most views, When limiting to the top result",
            "operation": " keep only the first row after descending ordering by view count."
        },
        "679": {
            "condition": "When answering about \"highest score post\"",
            "operation": " make sure the output order: T1.Id, T2.Title."
        },
        "680": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match)."
        },
        "681": {
            "condition": "When the question mentions \"highest score\"",
            "operation": " rank rows by T2.Score in descending order and keep the first 1 row."
        },
        "682": {
            "condition": "When answering about \"highest score post\", When combining users and posts tables, When the question mentions \"highest score\", When the question asks for \"id and title's name\"",
            "operation": " select T1.Id and T2.Title using the exact identifier tokens from the joined tables."
        },
        "683": {
            "condition": "When answering about \"which post has the highest score\"",
            "operation": " make sure the output order: post id and title name."
        },
        "684": {
            "condition": "When the question asks for \"post id and title's name\"",
            "operation": " use \"T2.Id\" for post id and \"T2.Title\" for title name from the posts table."
        },
        "685": {
            "condition": "When the question mentions \"highest score\"",
            "operation": " rank rows by \"T2.Score\" in descending order and keep the first 1 row."
        },
        "686": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where \"T1.Id = T2.OwnerUserId\" exactly as shown; keep only matching pairs (inner match)."
        },
        "687": {
            "condition": "When answering about \"which post has the highest score\", When the question asks for \"post id and title's name\", When the question mentions \"highest score\", When combining users and posts tables, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "688": {
            "condition": "When answering about \"average score of Stephen Turner's posts\"",
            "operation": " make sure the output order: average of T2.Score."
        },
        "689": {
            "condition": "When the question mentions \"Stephen Turner\"",
            "operation": " \"Stephen Turner\" actually means T1.DisplayName = 'Stephen Turner' in schema."
        },
        "690": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId and keep only matching pairs (inner match)."
        },
        "691": {
            "condition": "When answering about \"average score of Stephen Turner's posts\", When the question mentions \"Stephen Turner\", When combining users and posts tables, When computing average score",
            "operation": " calculate the average of T2.Score values for the filtered results."
        },
        "692": {
            "condition": "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;",
            "operation": "had over 20000 views in 2011 refers to ViewCount > 20000 where YEAR(CreationDate) = 2011;"
        },
        "693": {
            "condition": "When joining users and posts tables",
            "operation": " link rows where T1.Id equals T2.OwnerUserId and keep only matching pairs (inner match)."
        },
        "694": {
            "condition": "When filtering by year 2010",
            "operation": " use STRFTIME('%Y', T1.CreationDate) = '2010' exactly as specified."
        },
        "695": {
            "condition": "When ordering by value to find the most valuable post",
            "operation": " sort by T2.FavoriteCount in descending order."
        },
        "696": {
            "condition": "When selecting output columns",
            "operation": " return T2.OwnerUserId and T1.DisplayName in that order."
        },
        "697": {
            "condition": "When joining users and posts tables, When filtering by year 2010, When ordering by value to find the most valuable post, When selecting output columns, When limiting to the top result",
            "operation": " keep only the first row after ordering."
        },
        "698": {
            "condition": "When answering about \"most valuable post in 2010\"",
            "operation": " make sure the output order: T2.OwnerUserId, T1.DisplayName"
        },
        "699": {
            "condition": "When combining users as T1 and posts as T2",
            "operation": " link rows where T1.Id = T2.OwnerUserId exactly and keep only matching pairs (inner match)"
        },
        "700": {
            "condition": "When filtering for year 2010",
            "operation": " use STRFTIME('%Y', T1.CreationDate) = '2010' with exact literal '2010'"
        },
        "701": {
            "condition": "When determining \"most valuable\" by favorite count",
            "operation": " rank rows by T2.FavoriteCount in descending order and keep the first 1 row"
        },
        "702": {
            "condition": "When selecting the post owner's display name",
            "operation": " use T1.DisplayName for the owner's display name"
        },
        "703": {
            "condition": "When answering about \"most valuable post in 2010\", When combining users as T1 and posts as T2, When filtering for year 2010, When determining \"most valuable\" by favorite count, When selecting the post owner's display name, When selecting the post identifier",
            "operation": " use T2.OwnerUserId for the post owner's user ID rather than the post ID"
        },
        "704": {
            "condition": "When calculating percentages",
            "operation": " use SUM(IIF(condition, 1, 0)) with explicit CAST to REAL instead of COUNT(CASE WHEN condition THEN 1 END)."
        },
        "705": {
            "condition": "When filtering by year for percentage denominators",
            "operation": " apply the year condition STRFTIME('%Y', T2.CreationDate) = '2011' within the conditional aggregate instead of in the WHERE clause."
        },
        "706": {
            "condition": "When counting distinct entities",
            "operation": " use COUNT(T1.Id) instead of COUNT(*) to count distinct users."
        },
        "707": {
            "condition": "When joining tables",
            "operation": " use explicit INNER JOIN syntax with table aliases T1 for users and T2 for posts."
        },
        "708": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId to ensure proper user-post relationships."
        },
        "709": {
            "condition": "When handling year 2011 data",
            "operation": " use the exact literal '2011' with the format string '%Y' in STRFTIME function."
        },
        "710": {
            "condition": "When calculating percentages, When filtering by year for percentage denominators, When counting distinct entities, When joining tables, When combining users and posts tables, When handling year 2011 data, When checking reputation thresholds",
            "operation": " use the exact comparison T1.Reputation > 1000 for reputation over 1000."
        },
        "711": {
            "condition": "When calculating percentage of posts whose owners had reputation over 1000 in 2011",
            "operation": " use T2.CreationDate (not T2.CreaionDate) for the date filtering."
        },
        "712": {
            "condition": "When filtering for posts from 2011",
            "operation": " apply the date condition STRFTIME('%Y', T2.CreationDate) = '2011' within the conditional count instead of globally in WHERE clause."
        },
        "713": {
            "condition": "When computing the percentage",
            "operation": " cast the result to REAL type explicitly instead of relying on implicit conversion."
        },
        "714": {
            "condition": "When counting posts from users with reputation over 1000",
            "operation": " use the exact literal value 1000 for the reputation threshold."
        },
        "715": {
            "condition": "When calculating percentage of posts whose owners had reputation over 1000 in 2011, When filtering for posts from 2011, When computing the percentage, When counting posts from users with reputation over 1000, When joining users and posts",
            "operation": " use the exact join condition T1.Id = T2.OwnerUserId to link posts to their owners."
        },
        "716": {
            "condition": "When calculating a percentage ratio",
            "operation": " compute (rows satisfying both conditions) divided by (rows satisfying the denominator condition) and then multiply by 100.0."
        },
        "717": {
            "condition": "When filtering by year from a datetime column",
            "operation": " use STRFTIME('%Y', T2.CreationDate) = '2011' to extract the year 2011."
        },
        "718": {
            "condition": "When checking reputation condition",
            "operation": " use T1.Reputation > 1000 to identify users with reputation over 1000."
        },
        "719": {
            "condition": "When counting rows for the denominator",
            "operation": " use COUNT(T1.Id) to count all relevant rows rather than using IIF within COUNT."
        },
        "720": {
            "condition": "When calculating a percentage ratio, When filtering by year from a datetime column, When checking reputation condition, When counting rows for the denominator, When combining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId to connect posts with their owners."
        },
        "721": {
            "condition": "When the question asks about posts from 2011",
            "operation": " use the exact column name \"CreaionDate\" (not \"CreationDate\") from the posts table to filter for year 2011."
        },
        "722": {
            "condition": "When calculating a percentage",
            "operation": " perform the division first, then multiply by 100 to get the correct percentage value."
        },
        "723": {
            "condition": "When filtering conditions are already handled in conditional logic",
            "operation": " avoid redundant WHERE clause filters that duplicate the same condition."
        },
        "724": {
            "condition": "When the question asks about posts from 2011, When calculating a percentage, When filtering conditions are already handled in conditional logic, When joining users and posts tables",
            "operation": " link rows where T1.Id = T2.OwnerUserId to connect posts with their owners."
        },
        "725": {
            "condition": "When counting teenage users",
            "operation": " use SUM(IIF(Age BETWEEN 13 AND 18, 1, 0)) instead of COUNT(*) with string comparison."
        },
        "726": {
            "condition": "When calculating percentages",
            "operation": " cast the result to REAL for proper division instead of implicit casting."
        },
        "727": {
            "condition": "When counting total users",
            "operation": " use COUNT(Id) instead of COUNT(*) in a subquery."
        },
        "728": {
            "condition": "When counting teenage users, When calculating percentages, When counting total users, When filtering by age",
            "operation": " use numeric range check Age BETWEEN 13 AND 18 instead of string comparison age = 'teenage'."
        },
        "729": {
            "condition": "When answering about \"total views on the post 'Computer Game Datasets'\"",
            "operation": " select T2.\"ViewCount\" as total_views instead of SUM(views)."
        },
        "730": {
            "condition": "When answering about \"the user who posted it last time\"",
            "operation": " select T3.\"DisplayName\" instead of username."
        },
        "731": {
            "condition": "When combining tables for this question",
            "operation": " link postHistory as T1 with posts as T2 where T1.\"PostId\" = T2.\"Id\", and link posts as T2 with users as T3 where T2.\"LastEditorUserId\" = T3.\"Id\"."
        },
        "732": {
            "condition": "When filtering for the post 'Computer Game Datasets'",
            "operation": " use T1.\"Text\" = 'Computer Game Datasets' instead of title = 'Computer Game Datasets'."
        },
        "733": {
            "condition": "When answering about \"total views on the post 'Computer Game Datasets'\", When answering about \"the user who posted it last time\", When combining tables for this question, When filtering for the post 'Computer Game Datasets', When the question does not require grouping or ordering",
            "operation": " do not include GROUP BY, ORDER BY, or LIMIT clauses."
        },
        "734": {
            "condition": "When the question asks for posts with views above average",
            "operation": " use \"ViewCount\" instead of \"views\" as the exact column name from the schema."
        },
        "735": {
            "condition": "When counting posts",
            "operation": " use the \"Id\" column from the posts table as the counting key instead of COUNT(*)."
        },
        "736": {
            "condition": "When the question asks for posts with views above average, When counting posts, When comparing against average view count",
            "operation": " maintain the subquery structure that calculates AVG(\"ViewCount\") from the posts table and compare each post's \"ViewCount\" against this average value."
        },
        "737": {
            "condition": "When combining posts and comments tables",
            "operation": " link rows where T1.Id equals T2.PostId exactly and keep only matching pairs (inner join)."
        },
        "738": {
            "condition": "When counting comments",
            "operation": " compute the number of rows using T2.Id as the counting key instead of counting all columns."
        },
        "739": {
            "condition": "When organizing results by post",
            "operation": " group by T1.Id to compute aggregates per post."
        },
        "740": {
            "condition": "When finding the post with the highest score",
            "operation": " rank posts by SUM(T1.Score) in descending order and keep only the first row."
        },
        "741": {
            "condition": "When combining posts and comments tables, When counting comments, When organizing results by post, When finding the post with the highest score, When answering about comments for the highest-scoring post",
            "operation": " make sure the output order shows only the comment count for that single post."
        },
        "742": {
            "condition": "When counting posts",
            "operation": " use COUNT(\"Id\") instead of COUNT(*) to count specific non-null values."
        },
        "743": {
            "condition": "When the question mentions \"viewed over 35000 times\"",
            "operation": " this means \"ViewCount\" > 35000 using the exact column name from the schema."
        },
        "744": {
            "condition": "When the question mentions \"no comments from other users\"",
            "operation": " this means \"CommentCount\" = 0 using the exact column name from the schema."
        },
        "745": {
            "condition": "When counting posts, When the question mentions \"viewed over 35000 times\", When the question mentions \"no comments from other users\", When answering about posts with specific view and comment conditions",
            "operation": " filter rows where both \"ViewCount\" > 35000 and \"CommentCount\" = 0 are true simultaneously."
        },
        "746": {
            "condition": "When combining posts and users tables",
            "operation": " link rows where T1.OwnerUserId = T2.Id and keep only matching pairs (inner join)."
        },
        "747": {
            "condition": "When filtering for a specific post",
            "operation": " apply the condition T1.Id = 183 directly on the posts table."
        },
        "748": {
            "condition": "When ordering by edit date to find the last editor",
            "operation": " sort by T1.LastEditDate in descending order."
        },
        "749": {
            "condition": "When selecting user information",
            "operation": " retrieve T2.DisplayName and T2.Location from the users table."
        },
        "750": {
            "condition": "When combining posts and users tables, When filtering for a specific post, When ordering by edit date to find the last editor, When selecting user information, When the question asks for the last editor of a post",
            "operation": " use the OwnerUserId to Id relationship between posts and users tables to identify the user."
        },
        "751": {
            "condition": "When the question asks about the user who was the last to edit a post",
            "operation": " use the LastEditorUserId column to identify the user, not the OwnerUserId column."
        },
        "752": {
            "condition": "When joining the posts table (T1) with the users table (T2) to find user information",
            "operation": " link rows where T1.LastEditorUserId = T2.Id to correctly identify the last editor user."
        },
        "753": {
            "condition": "When filtering for a specific post by ID",
            "operation": " use the exact literal value 183 for T1.Id."
        },
        "754": {
            "condition": "When the question asks about the user who was the last to edit a post, When joining the posts table (T1) with the users table (T2) to find user information, When filtering for a specific post by ID, When identifying the last editor",
            "operation": " order by T1.LastEditDate in descending order and take the first result to get the most recent edit."
        },
        "755": {
            "condition": "When answering about \"latest badge awarded to a user\"",
            "operation": " make sure the output order includes only the badge name column \"T1.Name\"."
        },
        "756": {
            "condition": "When the question mentions \"user with display name Emmett\"",
            "operation": " \"Emmett\" actually means \"T2.DisplayName = 'Emmett'\" in schema."
        },
        "757": {
            "condition": "When combining badges table T1 and users table T2",
            "operation": " link rows where T1.UserId = T2.Id and keep only matching pairs (inner match)."
        },
        "758": {
            "condition": "When answering about \"latest badge awarded to a user\", When the question mentions \"user with display name Emmett\", When combining badges table T1 and users table T2, When ordering by date to find the latest badge",
            "operation": " order by T1.Date in descending direction and keep the first 1 row."
        },
        "759": {
            "condition": "When the question asks about time duration between a user's account creation and badge date",
            "operation": " calculate the difference using direct date subtraction T1.Date - T2.CreationDate instead of date conversion functions."
        },
        "760": {
            "condition": "When joining the Users and Badges tables",
            "operation": " use INNER JOIN explicitly and link rows where T1.UserId = T2.Id."
        },
        "761": {
            "condition": "When filtering for a specific user by display name",
            "operation": " use the exact literal 'Zolomon' with the correct case and quotes."
        },
        "762": {
            "condition": "When the question asks for all matching records",
            "operation": " do not apply any row limiting clauses like LIMIT 1."
        },
        "763": {
            "condition": "When the question asks about time duration between a user's account creation and badge date, When joining the Users and Badges tables, When filtering for a specific user by display name, When the question asks for all matching records, When using table aliases throughout the query",
            "operation": " refer to Badges as T1 and Users as T2 consistently."
        },
        "764": {
            "condition": "When counting posts for a user",
            "operation": " use COUNT(T2.Id) to count posts rather than counting both posts and comments."
        },
        "765": {
            "condition": "When joining users to posts",
            "operation": " use INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId to join on the correct owner relationship with proper aliasing."
        },
        "766": {
            "condition": "When joining comments to posts",
            "operation": " use INNER JOIN comments AS T3 ON T3.PostId = T2.Id to join comments to posts rather than directly to users."
        },
        "767": {
            "condition": "When finding the user with the latest created account",
            "operation": " use ORDER BY T1.CreationDate DESC LIMIT 1 instead of filtering with a subquery, to get only the most recent user."
        },
        "768": {
            "condition": "When counting posts for a user, When joining users to posts, When joining comments to posts, When finding the user with the latest created account, When the question asks for both posts and comments by the latest user",
            "operation": " count posts using T2.Id and comments using T3.Id after properly joining through the post relationship."
        },
        "769": {
            "condition": "When the question asks for comments to a post with specific title 'Analysing wind data with R'",
            "operation": " join posts to users on users.Id = posts.OwnerUserId to connect post owners."
        },
        "770": {
            "condition": "When retrieving comments for posts",
            "operation": " join comments to posts on posts.Id = comments.PostId to link comments to their respective posts."
        },
        "771": {
            "condition": "When selecting output columns",
            "operation": " include comments.Text and users.DisplayName exactly as specified."
        },
        "772": {
            "condition": "When ordering results for \"latest\" comments",
            "operation": " sort by users.CreationDate in descending order instead of comments.CreationDate."
        },
        "773": {
            "condition": "When the question asks for comments to a post with specific title 'Analysing wind data with R', When retrieving comments for posts, When selecting output columns, When ordering results for \"latest\" comments, When limiting to the latest 10 results",
            "operation": " take the first 10 rows after ordering by user creation date descending."
        },
        "774": {
            "condition": "When answering about \"users awarded with 'Citizen Patrol' badge\"",
            "operation": " query the \"badges\" table instead of the \"users\" table."
        },
        "775": {
            "condition": "When filtering for badge names",
            "operation": " use the \"Name\" column for filtering instead of \"badge_name\"."
        },
        "776": {
            "condition": "When counting badges",
            "operation": " count \"id\" values instead of using COUNT(*)."
        },
        "777": {
            "condition": "When answering about \"users awarded with 'Citizen Patrol' badge\", When filtering for badge names, When counting badges, When filtering for specific badge names",
            "operation": " filter for exact literal 'Citizen Patrol' instead of maintaining the same filter condition."
        },
        "778": {
            "condition": "When the question asks about posts with a specific tag",
            "operation": " query the \"tags\" table instead of the \"posts\" table."
        },
        "779": {
            "condition": "When filtering for tags specified as 'careers'",
            "operation": " use the exact literal 'careers' and filter on \"TagName = 'careers'\" instead of 'career'."
        },
        "780": {
            "condition": "When the question asks about posts with a specific tag, When filtering for tags specified as 'careers', When counting the number of posts with a tag",
            "operation": " count the \"Id\" column from the \"tags\" table instead of using COUNT(*)."
        },
        "781": {
            "condition": "When the question asks for reputation and view count",
            "operation": " use column names \"Reputation\" and \"Views\" exactly as shown in the schema."
        },
        "782": {
            "condition": "When filtering by display name 'Jarrod Dixon'",
            "operation": " use the exact literal 'Jarrod Dixon' with the column name \"DisplayName\" exactly as specified in the amends."
        },
        "783": {
            "condition": "When the question asks for reputation and view count, When filtering by display name 'Jarrod Dixon', When selecting from the users table",
            "operation": " ensure the output columns are ordered as \"Reputation\" followed by \"Views\" to match the question's request order."
        },
        "784": {
            "condition": "When the question asks for comment and answer counts for a specific post",
            "operation": " select the exact columns \"CommentCount\" and \"AnswerCount\" from the posts table instead of performing aggregation."
        },
        "785": {
            "condition": "When filtering for a post with a specific title",
            "operation": " use the exact column name \"Title\" with the exact literal value 'Clustering 1D data' for the filter condition."
        },
        "786": {
            "condition": "When retrieving pre-calculated counts from the posts table",
            "operation": " query directly from the posts table without joining to comments or answers tables, as the counts are already stored as columns."
        },
        "787": {
            "condition": "When the question asks for comment and answer counts for a specific post, When filtering for a post with a specific title, When retrieving pre-calculated counts from the posts table, When the question asks about comments and answers left by users on a post",
            "operation": " recognize that the posts table contains pre-calculated \"CommentCount\" and \"AnswerCount\" columns that directly provide this information without needing to join to other tables."
        },
        "788": {
            "condition": "When the question asks about account creation date",
            "operation": " use the \"CreationDate\" column from the users table instead of \"created_at\"."
        },
        "789": {
            "condition": "When filtering for a specific username",
            "operation": " use the \"DisplayName\" column with exact literal value 'IrishStat' instead of the \"username\" column."
        },
        "790": {
            "condition": "When the question asks about account creation date, When filtering for a specific username, When retrieving creation date information",
            "operation": " ensure the output column is \"CreationDate\" from the users table."
        },
        "791": {
            "condition": "When counting posts that offer a bounty amount",
            "operation": " count using the \"id\" column from the \"votes\" table instead of counting all rows from the \"posts\" table."
        },
        "792": {
            "condition": "When checking for bounty amount over 30",
            "operation": " use the condition \"BountyAmount\" >= 30 instead of bounty_amount > 30 to include values of exactly 30."
        },
        "793": {
            "condition": "When counting posts that offer a bounty amount, When checking for bounty amount over 30, When answering about bounty amounts",
            "operation": " \"BountyAmount\" in the \"votes\" table is the correct column to reference, not bounty_amount from the \"posts\" table."
        },
        "794": {
            "condition": "When identifying the most influential user",
            "operation": " use the user with maximum reputation value from T1 (users table) instead of ordering by followers."
        },
        "795": {
            "condition": "When combining users and posts tables",
            "operation": " link rows where T1.Id equals T2.OwnerUserId using an inner join."
        },
        "796": {
            "condition": "When counting posts with score above 50",
            "operation": " use SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) with explicit ELSE 0 instead of COUNT."
        },
        "797": {
            "condition": "When calculating percentage",
            "operation": " use CAST(... AS REAL) for floating-point division instead of implicit conversion with 100.0."
        },
        "798": {
            "condition": "When identifying the most influential user, When combining users and posts tables, When counting posts with score above 50, When calculating percentage, When referencing columns",
            "operation": " always use table aliases T1 and T2 with exact column names T1.Id, T2.Score, and T2.OwnerUserId."
        },
        "799": {
            "condition": "When counting posts",
            "operation": " use COUNT(\"id\") instead of COUNT(*) to count only non-null id values."
        },
        "800": {
            "condition": "When counting posts, When filtering for posts with score less than 20",
            "operation": " use \"Score\" < 20 instead of score > 20 to capture posts with scores below the threshold."
        },
        "801": {
            "condition": "When counting entities in the tags table",
            "operation": " use COUNT(\"Id\") to count specific non-null values rather than all rows."
        },
        "802": {
            "condition": "When filtering by tag ID below 15",
            "operation": " use \"Id\" < 15 instead of tag_id."
        },
        "803": {
            "condition": "When filtering by count of posts 20 and below",
            "operation": " use \"Count\" <= 20 instead of post_count."
        },
        "804": {
            "condition": "When counting entities in the tags table, When filtering by tag ID below 15, When filtering by count of posts 20 and below, When ordering conditions in WHERE clause",
            "operation": " place \"Count\" <= 20 condition before \"Id\" < 15 condition, though this ordering difference is functionally equivalent."
        },
        "805": {
            "condition": "When selecting columns from the tags table",
            "operation": " use exact column names \"ExcerptPostId\" and \"WikiPostId\" instead of lowercase versions."
        },
        "806": {
            "condition": "When filtering by tag name",
            "operation": " use the exact column name \"TagName\" instead of \"name\" and match the literal value 'sample' exactly as specified in the question."
        },
        "807": {
            "condition": "When selecting columns from the tags table, When filtering by tag name, When answering about excerpt post ID and wiki post ID of a specific tag",
            "operation": " ensure the output order is \"ExcerptPostId\" first, then \"WikiPostId\"."
        },
        "808": {
            "condition": "When the question asks for user attributes based on a specific comment text",
            "operation": " join comments table as T1 with users table as T2 using T1.UserId = T2.Id to connect comment authors to their user profiles."
        },
        "809": {
            "condition": "When filtering for a specific comment text",
            "operation": " use T1.Text = 'fine, you win :)' exactly as written with the same case, spacing, and punctuation."
        },
        "810": {
            "condition": "When selecting user reputation and upvotes",
            "operation": " output T2.Reputation and T2.UpVotes in that order, using the exact column names with proper casing."
        },
        "811": {
            "condition": "When the question asks for user attributes based on a specific comment text, When filtering for a specific comment text, When selecting user reputation and upvotes, When combining tables for this query",
            "operation": " perform an inner match where T1.UserId equals T2.Id to ensure only matching comment-user pairs are included."
        },
        "812": {
            "condition": "When the question asks for texts commented on a post about \"linear regression\"",
            "operation": " use a partial match condition with LIKE '%linear regression%' instead of exact equality match."
        },
        "813": {
            "condition": "When combining comments and posts tables",
            "operation": " link rows using INNER JOIN where T1.PostId = T2.Id to find matching pairs."
        },
        "814": {
            "condition": "When selecting the text column from comments",
            "operation": " reference it as T1.Text with proper table alias qualification."
        },
        "815": {
            "condition": "When the question asks for texts commented on a post about \"linear regression\", When combining comments and posts tables, When selecting the text column from comments, When filtering post titles",
            "operation": " use the pattern '%linear regression%' to match titles containing the phrase \"linear regression\" anywhere in the text."
        },
        "816": {
            "condition": "When the question asks for a comment with the highest score among posts with specific view counts",
            "operation": " select \"Text\" from the \"comments\" table instead of selecting from \"posts\" table."
        },
        "817": {
            "condition": "When filtering posts by view count range 100 to 150",
            "operation": " use a subquery with \"PostId IN\" and filter by \"ViewCount BETWEEN 100 AND 150\" in the subquery."
        },
        "818": {
            "condition": "When finding the highest-scoring comment",
            "operation": " use \"ORDER BY Score DESC LIMIT 1\" instead of MAX(score) aggregation."
        },
        "819": {
            "condition": "When the question asks for a comment with the highest score among posts with specific view counts, When filtering posts by view count range 100 to 150, When finding the highest-scoring comment, When combining posts and comments data",
            "operation": " ensure proper table separation and remove incorrect column references that mix data from different tables."
        },
        "820": {
            "condition": "When answering about \"creation date and age of the user that commented with website\"",
            "operation": " make sure the output order: T2.CreationDate, T2.Age"
        },
        "821": {
            "condition": "When the question mentions \"commented with website\"",
            "operation": " \"website\" actually means \"text containing HTTP links in comments\" in schema, specifically filter on T1.text LIKE '%http://%'"
        },
        "822": {
            "condition": "When combining comments and users tables",
            "operation": " link rows where T1.UserId = T2.Id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "823": {
            "condition": "When answering about \"creation date and age of the user that commented with website\", When the question mentions \"commented with website\", When combining comments and users tables, When selecting columns",
            "operation": " use T2.CreationDate and T2.Age instead of creation_date and age"
        },
        "824": {
            "condition": "When answering about comments from posts with specific attributes",
            "operation": " join the comments table as T1 with the posts table as T2 using the condition T1.PostId = T2.Id to link comments to their corresponding posts."
        },
        "825": {
            "condition": "When filtering for posts with score of 0",
            "operation": " use the exact literal value 0 and filter on T2.Score = 0."
        },
        "826": {
            "condition": "When filtering for posts with view count lower than 5",
            "operation": " use the exact literal value 5 and filter on T2.ViewCount < 5."
        },
        "827": {
            "condition": "When counting comments",
            "operation": " count using the canonical key T1.Id instead of counting all rows."
        },
        "828": {
            "condition": "When the question asks about \"comments with 0 score\"",
            "operation": " recognize that score refers to post score (T2.Score) rather than comment score."
        },
        "829": {
            "condition": "When answering about comments from posts with specific attributes, When filtering for posts with score of 0, When filtering for posts with view count lower than 5, When counting comments, When the question asks about \"comments with 0 score\", When the question asks about \"view count lower than 5\"",
            "operation": " recognize that view count refers to post view count (T2.ViewCount) rather than comment view count."
        },
        "830": {
            "condition": "When counting comments",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific column values."
        },
        "831": {
            "condition": "When combining posts and comments tables",
            "operation": " use INNER JOIN on T1.PostId = T2.Id instead of subqueries."
        },
        "832": {
            "condition": "When filtering for posts with exactly one comment",
            "operation": " use T2.CommentCount = 1 with exact case sensitivity."
        },
        "833": {
            "condition": "When filtering for comments with zero score",
            "operation": " apply T1.Score = 0 filter to the comments table (T1) instead of the posts table."
        },
        "834": {
            "condition": "When counting comments, When combining posts and comments tables, When filtering for posts with exactly one comment, When filtering for comments with zero score, When answering about comments from posts with 1 comment having 0 score",
            "operation": " ensure the query counts comments that meet both conditions through proper table joining and filtering."
        },
        "835": {
            "condition": "When the question asks about \"posts with 1 comment\"",
            "operation": " filter posts where \"CommentCount\" equals 1 exactly."
        },
        "836": {
            "condition": "When the question asks about \"comments have 0 score\"",
            "operation": " filter posts where \"Score\" equals 0 exactly."
        },
        "837": {
            "condition": "When counting comments on qualifying posts",
            "operation": " count using the exact identifier \"T1.id\" in lowercase."
        },
        "838": {
            "condition": "When the question asks about \"posts with 1 comment\", When the question asks about \"comments have 0 score\", When counting comments on qualifying posts, When combining comments and posts tables",
            "operation": " link rows where \"T1.PostId\" equals \"T2.Id\" exactly and keep only matching pairs (inner match)."
        },
        "839": {
            "condition": "When counting comments",
            "operation": " use COUNT(DISTINCT T1.id) to count distinct comment IDs rather than all rows."
        },
        "840": {
            "condition": "When combining comments and users tables",
            "operation": " perform an INNER JOIN where T1.UserId = T2.Id to link comments to their users."
        },
        "841": {
            "condition": "When filtering for zero-score comments",
            "operation": " use T1.Score = 0 to select comments with score of 0."
        },
        "842": {
            "condition": "When filtering for users aged 40",
            "operation": " use T2.Age = 40 to select users who are 40 years old."
        },
        "843": {
            "condition": "When counting comments, When combining comments and users tables, When filtering for zero-score comments, When filtering for users aged 40, When assigning table aliases",
            "operation": " use T1 for the comments table and T2 for the users table."
        },
        "844": {
            "condition": "When answering about \"post ID and comments for a specific post title\"",
            "operation": " make sure the output order: T2.Id, T1.Text"
        },
        "845": {
            "condition": "When the question mentions \"post titled by 'Group differences on a five point Likert item'\"",
            "operation": " filter rows where T2.Title equals exactly 'Group differences on a five point Likert item'"
        },
        "846": {
            "condition": "When combining comments (T1) and posts (T2) tables",
            "operation": " link rows where T1.PostId equals T2.Id and keep only matching pairs (inner match)"
        },
        "847": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "848": {
            "condition": "When answering about \"post ID and comments for a specific post title\", When the question mentions \"post titled by 'Group differences on a five point Likert item'\", When combining comments (T1) and posts (T2) tables, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Group differences on a five point Likert item'"
        },
        "849": {
            "condition": "When the question asks for up vote number of a user who made a specific comment",
            "operation": " select \"T2.UpVotes\" from the users table instead of \"up_votes\"."
        },
        "850": {
            "condition": "When combining comments and users tables",
            "operation": " join \"comments AS T1\" with \"users AS T2\" using inner join where \"T1.UserId = T2.Id\" to link comments to their authors."
        },
        "851": {
            "condition": "When filtering for a specific comment text",
            "operation": " use \"T1.Text = 'R is also lazy evaluated.'\" instead of filtering on users table since comment text is stored in comments table."
        },
        "852": {
            "condition": "When the question asks for up vote number of a user who made a specific comment, When combining comments and users tables, When filtering for a specific comment text, When answering about user attributes based on comment content",
            "operation": " retrieve user information from the users table (T2) after joining with comments table (T1) where the comment text matches exactly."
        },
        "853": {
            "condition": "When selecting comments for a specific user",
            "operation": " return only the \"Text\" column from the comments table instead of all columns."
        },
        "854": {
            "condition": "When joining comments and users tables",
            "operation": " use an inner join where T1.UserId equals T2.Id to properly link the tables."
        },
        "855": {
            "condition": "When filtering by username",
            "operation": " use T2.DisplayName = 'Harvey Motulsky' instead of username to match the correct column name."
        },
        "856": {
            "condition": "When selecting comments for a specific user, When joining comments and users tables, When filtering by username, When referring to tables",
            "operation": " use T1 as the alias for comments table and T2 as the alias for users table for consistency."
        },
        "857": {
            "condition": "When answering about \"users with comments having score between 1 to 5 and 0 down votes\"",
            "operation": " make sure to combine comments table as T1 and users table as T2 using an inner match where T1.UserId equals T2.Id."
        },
        "858": {
            "condition": "When the question mentions \"display names\"",
            "operation": " \"display names\" actually means T2.DisplayName in schema."
        },
        "859": {
            "condition": "When filtering for comments with score between 1 and 5",
            "operation": " apply the condition T1.Score BETWEEN 1 AND 5."
        },
        "860": {
            "condition": "When filtering for users with 0 down votes",
            "operation": " apply the condition T2.DownVotes = 0."
        },
        "861": {
            "condition": "When answering about \"users with comments having score between 1 to 5 and 0 down votes\", When the question mentions \"display names\", When filtering for comments with score between 1 and 5, When filtering for users with 0 down votes, When producing output",
            "operation": " return only T2.DisplayName as the result."
        }
    },
    "superhero": {
        "0": {
            "condition": "When answering about \"superpowers of 3-D Man\"",
            "operation": " make sure the output order: T3.power_name."
        },
        "1": {
            "condition": "When the question mentions \"superpowers\"",
            "operation": " \"superpowers\" actually means \"power_name in superpower table T3\" through proper relationships."
        },
        "2": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match)."
        },
        "3": {
            "condition": "When filtering for \"3-D Man\"",
            "operation": " use T1.superhero_name = '3-D Man' exactly as specified."
        },
        "4": {
            "condition": "When answering about \"superpowers of 3-D Man\", When the question mentions \"superpowers\", When combining T1, T2, and T3 for shared entities, When filtering for \"3-D Man\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "5": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.hero_id) instead of COUNT(*) to count specific hero instances."
        },
        "6": {
            "condition": "When the question mentions \"super power\"",
            "operation": " \"Super Strength\" actually means T2.power_name = 'Super Strength' in the schema."
        },
        "7": {
            "condition": "When counting superheroes, When the question mentions \"super power\", When combining hero_power and superpower tables",
            "operation": " link rows where T1.power_id = T2.id and keep only matching pairs (inner match)."
        },
        "8": {
            "condition": "When answering about superheroes with super power \"Super Strength\"",
            "operation": " join tables hero_power as T2 on T1.id = T2.hero_id and superpower as T3 on T2.power_id = T3.id to connect superheroes to their powers."
        },
        "9": {
            "condition": "When filtering for super power \"Super Strength\"",
            "operation": " use T3.power_name = 'Super Strength' exactly as specified."
        },
        "10": {
            "condition": "When filtering for height over 200cm",
            "operation": " use T1.height_cm > 200 to reference the correct column with unit specification."
        },
        "11": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific entities using the canonical key."
        },
        "12": {
            "condition": "When answering about superheroes with super power \"Super Strength\", When filtering for super power \"Super Strength\", When filtering for height over 200cm, When counting superheroes, When combining tables for shared entities",
            "operation": " perform inner matches using the exact key equalities T1.id = T2.hero_id and T2.power_id = T3.id as shown in the amends."
        },
        "13": {
            "condition": "When answering about \"superheroes with over 15 super powers\"",
            "operation": " make sure the output order: T1.full_name."
        },
        "14": {
            "condition": "When the question mentions \"superheroes\"",
            "operation": " \"superheroes\" actually means \"superhero AS T1\" in schema."
        },
        "15": {
            "condition": "When the question mentions \"super powers\"",
            "operation": " \"super powers\" actually means \"hero_power AS T2\" with power_id in schema."
        },
        "16": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id exactly as shown; keep only matching pairs (inner match)."
        },
        "17": {
            "condition": "When the question asks for \"count of super powers per hero\"",
            "operation": " compute the number of rows using T2.power_id per T1.full_name group."
        },
        "18": {
            "condition": "When filtering for heroes with over 15 super powers",
            "operation": " apply the condition COUNT(T2.power_id) > 15 after grouping instead of before aggregation."
        },
        "19": {
            "condition": "When answering about \"superheroes with over 15 super powers\", When the question mentions \"superheroes\", When the question mentions \"super powers\", When combining T1 and T2 for shared entities, When the question asks for \"count of super powers per hero\", When filtering for heroes with over 15 super powers, When producing distinct hero names",
            "operation": " use DISTINCT T1.full_name to avoid duplicate entries."
        },
        "20": {
            "condition": "When answering about \"how many superheroes have blue eyes\"",
            "operation": " make sure the output order: count of superheroes with blue eyes."
        },
        "21": {
            "condition": "When the question mentions \"superheroes\"",
            "operation": " \"superheroes\" actually means \"T1.id in schema\" for counting purposes."
        },
        "22": {
            "condition": "When the question mentions \"blue eyes\"",
            "operation": " \"blue eyes\" actually means \"T2.colour = 'Blue'\" in schema after joining through the colour table."
        },
        "23": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.eye_colour_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "24": {
            "condition": "When counting superheroes",
            "operation": " compute the number of rows using the canonical key token T1.id instead of counting all columns."
        },
        "25": {
            "condition": "When answering about \"how many superheroes have blue eyes\", When the question mentions \"superheroes\", When the question mentions \"blue eyes\", When combining T1 and T2 for shared entities, When counting superheroes, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exactly 'Blue' not 'blue' or 'BLUE'."
        },
        "26": {
            "condition": "When the question asks about a character's color",
            "operation": " use the colour table (T2) instead of the characters table."
        },
        "27": {
            "condition": "When joining superhero table (T1) with colour table (T2)",
            "operation": " link rows where T1.skin_colour_id = T2.id."
        },
        "28": {
            "condition": "When filtering for a specific superhero",
            "operation": " use T1.superhero_name = 'Apocalypse' instead of name = 'Apocalypse'."
        },
        "29": {
            "condition": "When the question asks about a character's color, When joining superhero table (T1) with colour table (T2), When filtering for a specific superhero, When selecting color information",
            "operation": " select T2.colour instead of skin_color from the characters table."
        },
        "30": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) to count specific hero IDs rather than all rows."
        },
        "31": {
            "condition": "When the question mentions superheroes with blue eyes",
            "operation": " join colour table T4 on T1.eye_colour_id = T4.id and filter on T4.colour = 'Blue' with exact case."
        },
        "32": {
            "condition": "When the question mentions super power of \"Agility\"",
            "operation": " join superpower table T3 through hero_power table T2 on T2.power_id = T3.id and filter on T3.power_name = 'Agility' with exact spelling."
        },
        "33": {
            "condition": "When counting superheroes, When the question mentions superheroes with blue eyes, When the question mentions super power of \"Agility\", When combining superhero, hero_power, superpower, and colour tables",
            "operation": " use INNER JOIN on T1.id = T2.hero_id and T2.power_id = T3.id and T1.eye_colour_id = T4.id to establish proper relationships between heroes, their powers, and eye colors."
        },
        "34": {
            "condition": "When answering about superhero names",
            "operation": " make sure the output order: T1.superhero_name"
        },
        "35": {
            "condition": "When the question mentions \"blue eyes\"",
            "operation": " \"blue eyes\" actually means T2.colour = 'Blue' in schema through T1.eye_colour_id = T2.id join"
        },
        "36": {
            "condition": "When the question mentions \"blond hair\"",
            "operation": " \"blond hair\" actually means T3.colour = 'Blond' in schema through T1.hair_colour_id = T3.id join"
        },
        "37": {
            "condition": "When combining T1 and T2 for eye color",
            "operation": " link rows where T1.eye_colour_id = T2.id and keep only matching pairs (inner match)"
        },
        "38": {
            "condition": "When combining T1 and T3 for hair color",
            "operation": " link rows where T1.hair_colour_id = T3.id and keep only matching pairs (inner match)"
        },
        "39": {
            "condition": "When answering about superhero names, When the question mentions \"blue eyes\", When the question mentions \"blond hair\", When combining T1 and T2 for eye color, When combining T1 and T3 for hair color, When filtering for both blue eyes and blond hair",
            "operation": " require T2.colour = 'Blue' AND T3.colour = 'Blond' instead of using OR condition"
        },
        "40": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "41": {
            "condition": "When answering about superheroes published by a specific publisher",
            "operation": " join superhero AS T1 with publisher AS T2 using the condition T1.publisher_id = T2.id instead of querying only the superheroes table."
        },
        "42": {
            "condition": "When filtering for Marvel Comics publisher",
            "operation": " use T2.publisher_name = 'Marvel Comics' instead of publisher = 'DC Comics' to correctly reference the publisher table with the exact literal value."
        },
        "43": {
            "condition": "When counting superheroes, When answering about superheroes published by a specific publisher, When filtering for Marvel Comics publisher, When combining superhero and publisher tables",
            "operation": " link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match)."
        },
        "44": {
            "condition": "When the question asks to rank heroes by height in descending order",
            "operation": " use RANK() OVER (ORDER BY height_cm DESC) AS HeightRank to assign ranks based on height_cm in descending order."
        },
        "45": {
            "condition": "When the question mentions \"heroes published by Marvel Comics\"",
            "operation": " this means filtering with publisher.publisher_name = 'Marvel Comics' exactly."
        },
        "46": {
            "condition": "When combining superhero and publisher tables",
            "operation": " link rows where superhero.publisher_id = publisher.id and keep only matching pairs (inner match)."
        },
        "47": {
            "condition": "When selecting output columns",
            "operation": " include superhero_name, height_cm, and the computed HeightRank."
        },
        "48": {
            "condition": "When the question asks to rank heroes by height in descending order, When the question mentions \"heroes published by Marvel Comics\", When combining superhero and publisher tables, When selecting output columns, When handling the publisher name literal",
            "operation": " preserve the exact case and spacing as 'Marvel Comics'."
        },
        "49": {
            "condition": "When answering about \"Who is the publisher of Sauron?\"",
            "operation": " make sure the output order: T2.publisher_name."
        },
        "50": {
            "condition": "When the question mentions \"Sauron\"",
            "operation": " \"Sauron\" actually means \"T1.superhero_name = 'Sauron'\" in schema."
        },
        "51": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.publisher_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "52": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "53": {
            "condition": "When answering about \"Who is the publisher of Sauron?\", When the question mentions \"Sauron\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Sauron'."
        },
        "54": {
            "condition": "When answering about superhero eye color popularity from Marvel Comics",
            "operation": " join the colour table on superhero.eye_colour_id = colour.id to get the correct eye color values."
        },
        "55": {
            "condition": "When filtering for Marvel Comics superheroes",
            "operation": " join the publisher table on superhero.publisher_id = publisher.id and filter where publisher.publisher_name = 'Marvel Comics'."
        },
        "56": {
            "condition": "When counting superheroes",
            "operation": " count superhero.id instead of using COUNT(*) to get the accurate count of superhero entities."
        },
        "57": {
            "condition": "When grouping by eye color",
            "operation": " group by colour.colour instead of the raw eye_color field."
        },
        "58": {
            "condition": "When ranking by popularity",
            "operation": " use RANK() OVER (ORDER BY COUNT(superhero.id) DESC) to rank from most common to least common eye color."
        },
        "59": {
            "condition": "When answering about superhero eye color popularity from Marvel Comics, When filtering for Marvel Comics superheroes, When counting superheroes, When grouping by eye color, When ranking by popularity, When selecting eye color information",
            "operation": " select colour.colour AS EyeColor to get the proper formatted eye color values."
        },
        "60": {
            "condition": "When answering about \"average height of superheroes from Marvel Comics\"",
            "operation": " make sure the output order: AVG(T1.height_cm)."
        },
        "61": {
            "condition": "When the question mentions \"superheroes\"",
            "operation": " \"superheroes\" actually means \"T1\" in schema."
        },
        "62": {
            "condition": "When the question mentions \"Marvel Comics\"",
            "operation": " \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema."
        },
        "63": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match)."
        },
        "64": {
            "condition": "When answering about \"average height of superheroes from Marvel Comics\", When the question mentions \"superheroes\", When the question mentions \"Marvel Comics\", When combining T1 and T2 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "65": {
            "condition": "When the question asks for superhero names",
            "operation": " use \"superhero_name\" from table \"superhero\" as T1 instead of \"name\" from \"superheroes\"."
        },
        "66": {
            "condition": "When checking for 'Super Strength' super power",
            "operation": " use an EXISTS subquery that joins \"hero_power\" as T2 with \"superpower\" as T3 on T2.power_id = T3.id where T3.super_power = 'Super Strength' and T1.id = T2.hero_id."
        },
        "67": {
            "condition": "When checking for 'Marvel Comics' publisher",
            "operation": " use an EXISTS subquery that joins \"publisher\" as T4 where T4.publisher_name = 'Marvel Comics' and T1.publisher_id = T4.id."
        },
        "68": {
            "condition": "When the question asks for superhero names, When checking for 'Super Strength' super power, When checking for 'Marvel Comics' publisher, When combining tables for filtering",
            "operation": " use inner matches through foreign key relationships T1.id = T2.hero_id and T1.publisher_id = T4.id instead of direct column value comparisons."
        },
        "69": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "70": {
            "condition": "When answering about superheroes from a specific publisher",
            "operation": " join publisher AS T2 to superheroes AS T1 using INNER JOIN on T1.publisher_id = T2.id instead of filtering directly on the superheroes table."
        },
        "71": {
            "condition": "When counting superheroes, When answering about superheroes from a specific publisher, When filtering for DC Comics",
            "operation": " use T2.publisher_name = 'DC Comics' instead of publisher = 'Marvel Comics' to correctly reference the publisher table and query for the exact publisher name."
        },
        "72": {
            "condition": "When answering about \"slowest superhero\"",
            "operation": " make sure the output order: T3.attribute_value ASC (lowest value first) instead of DESC."
        },
        "73": {
            "condition": "When the question mentions \"publisher\"",
            "operation": " \"publisher\" actually means \"T2.publisher_name\" in schema."
        },
        "74": {
            "condition": "When combining T1 (superheroes) and T2 (publisher)",
            "operation": " link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match)."
        },
        "75": {
            "condition": "When combining T1 (superheroes) and T3 (hero_attribute)",
            "operation": " link rows where T1.id = T3.hero_id and keep only matching pairs (inner match)."
        },
        "76": {
            "condition": "When combining T3 (hero_attribute) and T4 (attribute)",
            "operation": " link rows where T3.attribute_id = T4.id and keep only matching pairs (inner match)."
        },
        "77": {
            "condition": "When filtering for speed attribute",
            "operation": " use WHERE T4.attribute_name = 'Speed' to select only speed-related attributes."
        },
        "78": {
            "condition": "When answering about \"slowest superhero\", When the question mentions \"publisher\", When combining T1 (superheroes) and T2 (publisher), When combining T1 (superheroes) and T3 (hero_attribute), When combining T3 (hero_attribute) and T4 (attribute), When filtering for speed attribute, When ordering by speed values",
            "operation": " use T3.attribute_value instead of a non-existent speed column."
        },
        "79": {
            "condition": "When the question mentions \"gold-eyed superheroes\"",
            "operation": " \"gold-eyed\" actually means \"T3.colour = 'Gold'\" in schema with exact capitalization."
        },
        "80": {
            "condition": "When the question mentions \"Marvel Comics\"",
            "operation": " \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema."
        },
        "81": {
            "condition": "When combining tables for superhero information",
            "operation": " link rows where T1.publisher_id = T2.id and T1.eye_colour_id = T3.id; keep only matching pairs (inner match)."
        },
        "82": {
            "condition": "When counting superheroes",
            "operation": " compute the number of rows using the canonical key token T1.id instead of counting all columns."
        },
        "83": {
            "condition": "When the question mentions \"gold-eyed superheroes\", When the question mentions \"Marvel Comics\", When combining tables for superhero information, When counting superheroes, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Marvel Comics' and 'Gold'."
        },
        "84": {
            "condition": "When the question asks for publisher information about a superhero",
            "operation": " join superhero table as T1 with publisher table as T2 using T1.publisher_id = T2.id to connect the related entities."
        },
        "85": {
            "condition": "When filtering for a specific superhero name",
            "operation": " use T1.superhero_name = 'Blue Beetle II' with exact case and spacing as specified."
        },
        "86": {
            "condition": "When selecting publisher information",
            "operation": " use T2.publisher_name from the publisher table rather than any publisher_name column from other tables."
        },
        "87": {
            "condition": "When the question asks for publisher information about a superhero, When filtering for a specific superhero name, When selecting publisher information, When combining tables for superhero-publisher relationships",
            "operation": " perform an inner match where T1.publisher_id equals T2.id to ensure only valid publisher associations are returned."
        },
        "88": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) instead of COUNT(*) for precise counting."
        },
        "89": {
            "condition": "When the question mentions \"blonde hair\"",
            "operation": " this corresponds to T2.colour = 'Blond' in the schema (note exact capitalization)."
        },
        "90": {
            "condition": "When combining superhero and colour tables",
            "operation": " link rows where T1.hair_colour_id = T2.id (inner match)."
        },
        "91": {
            "condition": "When answering about superhero counts",
            "operation": " reference the \"superhero\" table (not \"superheroes\")."
        },
        "92": {
            "condition": "When counting superheroes, When the question mentions \"blonde hair\", When combining superhero and colour tables, When answering about superhero counts, When filtering by hair color",
            "operation": " use the normalized color reference table through T2.colour instead of direct filtering on hair_color."
        },
        "93": {
            "condition": "When answering about \"the dumbest superhero\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "94": {
            "condition": "When the question mentions \"dumbest\"",
            "operation": " this means the minimum value of intelligence attribute, which requires joining hero_attribute AS T2 and attribute AS T3 tables."
        },
        "95": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T2.hero_id = T1.hero_id and T2.attribute_id = T3.attribute_id; keep only matching pairs (inner match)."
        },
        "96": {
            "condition": "When filtering for intelligence attribute",
            "operation": " use exact literal filter T3.attribute_name = 'Intelligence'."
        },
        "97": {
            "condition": "When finding the minimum intelligence value",
            "operation": " order rows by T2.attribute_value in ascending direction and keep the first 1 row."
        },
        "98": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "99": {
            "condition": "When answering about \"the dumbest superhero\", When the question mentions \"dumbest\", When combining T1, T2, and T3 for shared entities, When filtering for intelligence attribute, When finding the minimum intelligence value, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Intelligence'."
        },
        "100": {
            "condition": "When the question asks about a character's race",
            "operation": " use the race table (T2) to get race information instead of the characters table."
        },
        "101": {
            "condition": "When joining superhero table (T1) with race table (T2)",
            "operation": " link rows where T1.race_id equals T2.id."
        },
        "102": {
            "condition": "When filtering for a specific superhero name like 'Copycat'",
            "operation": " use T1.superhero_name = 'Copycat' instead of name = 'Copycat'."
        },
        "103": {
            "condition": "When the question asks about a character's race, When joining superhero table (T1) with race table (T2), When filtering for a specific superhero name like 'Copycat', When selecting race information",
            "operation": " output T2.race from the race table."
        },
        "104": {
            "condition": "When the question asks about superheroes",
            "operation": " use the exact column \"superhero_name\" from table \"superhero\" instead of \"name\" from \"superheroes\"."
        },
        "105": {
            "condition": "When checking for durability attribute values",
            "operation": " use an EXISTS subquery with joined tables \"hero_attribute\" and \"attribute\" instead of a simple WHERE filter."
        },
        "106": {
            "condition": "When filtering for durability",
            "operation": " check for \"attribute_name = 'Durability'\" and \"attribute_value < 50\" instead of directly comparing \"durability > 50\"."
        },
        "107": {
            "condition": "When the question asks about superheroes, When checking for durability attribute values, When filtering for durability, When linking the subquery to the main table",
            "operation": " add the correlation condition \"T1.id = T2.hero_id\" to properly connect the tables."
        },
        "108": {
            "condition": "When answering about \"names of superheroes with the power of death touch\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "109": {
            "condition": "When the question mentions \"superheroes\"",
            "operation": " use table \"superheroes\" as T1 with column \"superhero_name\" for names."
        },
        "110": {
            "condition": "When the question mentions \"power of death touch\"",
            "operation": " this actually means \"T3.power_name = 'Death Touch'\" in the schema with exact case sensitivity."
        },
        "111": {
            "condition": "When answering about \"names of superheroes with the power of death touch\", When the question mentions \"superheroes\", When the question mentions \"power of death touch\", When combining superheroes and power information",
            "operation": " link rows using T1.id = T2.hero_id and T2.power_id = T3.id through hero_power as T2 and superpower as T3 tables, keeping only matching pairs (inner match)."
        },
        "112": {
            "condition": "When answering about female superheroes with strength value of 100",
            "operation": " make sure the output order: count of superheroes."
        },
        "113": {
            "condition": "When the question mentions \"female superheroes\"",
            "operation": " \"female\" actually means \"T4.gender = 'Female'\" in schema."
        },
        "114": {
            "condition": "When the question mentions \"strength value of 100\"",
            "operation": " \"strength\" actually means \"T3.attribute_name = 'Strength'\" and \"value of 100\" means \"T2.attribute_value = 100\" in schema."
        },
        "115": {
            "condition": "When combining T1, T2, T3, and T4 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id, T2.attribute_id = T3.id, and T1.gender_id = T4.id; keep only matching pairs (inner match)."
        },
        "116": {
            "condition": "When the question asks for \"count of superheroes\"",
            "operation": " compute the number of rows using the canonical key token T1.id."
        },
        "117": {
            "condition": "When answering about female superheroes with strength value of 100, When the question mentions \"female superheroes\", When the question mentions \"strength value of 100\", When combining T1, T2, T3, and T4 for shared entities, When the question asks for \"count of superheroes\", When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exact values 'Female' and 'Strength'."
        },
        "118": {
            "condition": "When answering about \"the superhero that has the most powers\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "119": {
            "condition": "When the question mentions \"name\"",
            "operation": " \"name\" actually means \"T1.superhero_name\" in schema."
        },
        "120": {
            "condition": "When the question asks for \"most powers\"",
            "operation": " count the number of power relationships using COUNT(T2.hero_id) rather than using a raw powers column."
        },
        "121": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id exactly as shown; keep only matching pairs (inner match)."
        },
        "122": {
            "condition": "When the question asks for \"count of powers\"",
            "operation": " compute the number of rows using the canonical key token T2.hero_id for counting power relationships."
        },
        "123": {
            "condition": "When answering about \"the superhero that has the most powers\", When the question mentions \"name\", When the question asks for \"most powers\", When combining T1 and T2 for shared entities, When the question asks for \"count of powers\", When the question mentions \"most\" or \"highest\"",
            "operation": " rank rows by COUNT(T2.hero_id) in descending order and keep the first 1 row."
        },
        "124": {
            "condition": "When answering about \"vampire superheroes\"",
            "operation": " join table \"superhero\" (as T1) with table \"race\" (as T2) using the condition T1.race_id = T2.id to combine superhero and race information."
        },
        "125": {
            "condition": "When the question mentions \"vampire\"",
            "operation": " filter rows where T2.race equals exactly 'Vampire' (case-sensitive) to identify vampire superheroes by their race."
        },
        "126": {
            "condition": "When answering about \"vampire superheroes\", When the question mentions \"vampire\", When counting superhero entities",
            "operation": " count the number of distinct T1.superhero_name values to get the count of vampire superheroes."
        },
        "127": {
            "condition": "When the question asks about superheroes with specific alignment",
            "operation": " filter rows where \"alignment\".\"alignment\" = 'Bad' (exact case and spelling)."
        },
        "128": {
            "condition": "When calculating percentages",
            "operation": " use explicit CAST to REAL for division to avoid integer division."
        },
        "129": {
            "condition": "When joining tables for publisher information",
            "operation": " join \"publisher\" table on \"p1\".\"publisher_id\" = \"p2\".\"id\" to access publisher data correctly."
        },
        "130": {
            "condition": "When joining tables for alignment information",
            "operation": " join \"alignment\" table on \"a\".\"id\" = \"p1\".\"alignment_id\" to access alignment data correctly."
        },
        "131": {
            "condition": "When counting Marvel Comics superheroes",
            "operation": " use SUM(CASE WHEN \"T2\".\"publisher_name\" = 'Marvel Comics' THEN 1 ELSE 0 END) to count occurrences."
        },
        "132": {
            "condition": "When the question asks about superheroes with specific alignment, When calculating percentages, When joining tables for publisher information, When joining tables for alignment information, When counting Marvel Comics superheroes, When outputting results",
            "operation": " include both the percentage calculation and Marvel count as separate columns in the result."
        },
        "133": {
            "condition": "When combining superhero and publisher tables",
            "operation": " link rows where T1.publisher_id equals T2.id exactly as shown in the amends and keep only matching pairs (inner match)."
        },
        "134": {
            "condition": "When counting superheroes per publisher",
            "operation": " compute the number of rows using the canonical key for superheroes (T1.id) with SUM(CASE) expressions instead of separate COUNT(*) subqueries."
        },
        "135": {
            "condition": "When filtering for DC Comics",
            "operation": " use the exact literal 'DC Comics' from the publisher_name column of the joined publisher table (T2.publisher_name)."
        },
        "136": {
            "condition": "When filtering for Marvel Comics",
            "operation": " use the exact literal 'Marvel Comics' from the publisher_name column of the joined publisher table (T2.publisher_name)."
        },
        "137": {
            "condition": "When combining superhero and publisher tables, When counting superheroes per publisher, When filtering for DC Comics, When filtering for Marvel Comics, When calculating the difference in superhero counts",
            "operation": " compute Marvel count minus DC count instead of DC count minus Marvel count."
        },
        "138": {
            "condition": "When answering about the difference in superhero counts between publishers",
            "operation": " calculate only the difference value without including individual counts for each publisher."
        },
        "139": {
            "condition": "When the question mentions \"DC Comics\" and \"Marvel Comics\"",
            "operation": " use the exact literals 'DC Comics' and 'Marvel Comics' with the exact case and spacing."
        },
        "140": {
            "condition": "When counting superheroes per publisher",
            "operation": " use conditional counting with CASE statements that check T2.publisher_name against the exact publisher literals."
        },
        "141": {
            "condition": "When combining superhero and publisher tables",
            "operation": " link rows where T1.publisher_id = T2.id to associate superheroes with their publishers."
        },
        "142": {
            "condition": "When answering about the difference in superhero counts between publishers, When the question mentions \"DC Comics\" and \"Marvel Comics\", When counting superheroes per publisher, When combining superhero and publisher tables, When filtering for specific publishers",
            "operation": " do not use a WHERE clause filter since the CASE statements already handle the conditional counting internally."
        },
        "143": {
            "condition": "When the question asks for publisher ID of a publisher by name",
            "operation": " select \"id\" from the \"publisher\" table instead of \"publisher_id\" from other tables."
        },
        "144": {
            "condition": "When filtering for a specific publisher name",
            "operation": " use \"publisher_name = 'Star Trek'\" exactly as specified, not title or other attributes."
        },
        "145": {
            "condition": "When the question asks for publisher ID of a publisher by name, When filtering for a specific publisher name, When retrieving publisher information",
            "operation": " query the publisher table directly rather than searching through related tables like books."
        },
        "146": {
            "condition": "When answering about \"average attribute value of all superheroes\"",
            "operation": " use the column \"attribute_value\" from table \"hero_attribute\" instead of \"attribute\" from table \"superheroes\"."
        },
        "147": {
            "condition": "When calculating averages",
            "operation": " do not add explicit NULL filters since the AVG function inherently ignores NULL values."
        },
        "148": {
            "condition": "When answering about \"average attribute value of all superheroes\", When calculating averages, When the question mentions \"superheroes\" but the data is stored in \"hero_attribute\" table",
            "operation": " query from the \"hero_attribute\" table to access the correct attribute values."
        },
        "149": {
            "condition": "When counting superheroes",
            "operation": " use the \"id\" column from table \"superhero\" instead of counting all columns."
        },
        "150": {
            "condition": "When identifying superheroes without full name",
            "operation": " only count records where \"full_name\" is explicitly NULL, do not include empty strings."
        },
        "151": {
            "condition": "When counting superheroes, When identifying superheroes without full name, When referencing the superhero table",
            "operation": " use the exact table name \"superhero\" instead of \"superheroes\"."
        },
        "152": {
            "condition": "When answering about \"eye colour of superhero with superhero ID 75\"",
            "operation": " make sure the output order: T2.colour."
        },
        "153": {
            "condition": "When the question mentions \"superhero ID 75\"",
            "operation": " \"superhero ID 75\" actually means \"T1.id = 75\" in schema."
        },
        "154": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.eye_colour_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "155": {
            "condition": "When answering about \"eye colour of superhero with superhero ID 75\", When the question mentions \"superhero ID 75\", When combining T1 and T2 for shared entities, When the question mentions \"eye colour\"",
            "operation": " \"eye colour\" actually means \"T2.colour\" from the colour table, not \"eye_color\" from the superheroes table."
        },
        "156": {
            "condition": "When answering about \"superpowers of the superhero called Deathlok\"",
            "operation": " make sure the output order: T3.power_name"
        },
        "157": {
            "condition": "When the question mentions \"superhero called Deathlok\"",
            "operation": " \"Deathlok\" actually means \"T1.superhero_name = 'Deathlok'\" in schema"
        },
        "158": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and keep only matching pairs (inner match)"
        },
        "159": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.power_id = T3.id and keep only matching pairs (inner match)"
        },
        "160": {
            "condition": "When answering about \"superpowers of the superhero called Deathlok\", When the question mentions \"superhero called Deathlok\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When selecting superpowers",
            "operation": " use T3.power_name instead of superpower from the original table"
        },
        "161": {
            "condition": "When answering about \"average weight of all female superheroes\"",
            "operation": " make sure the output order: AVG(T1.weight_kg)."
        },
        "162": {
            "condition": "When the question mentions \"female superheroes\"",
            "operation": " \"female\" actually means \"T2.gender = 'Female'\" in schema."
        },
        "163": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.gender_id = T2.id; keep only matching pairs (inner match)."
        },
        "164": {
            "condition": "When answering about \"average weight of all female superheroes\", When the question mentions \"female superheroes\", When combining T1 and T2 for shared entities, When calculating average weight",
            "operation": " use AVG(T1.weight_kg) instead of height-related columns."
        },
        "165": {
            "condition": "When answering about \"superpowers of male superheroes\"",
            "operation": " make sure the output order: T3.power_name."
        },
        "166": {
            "condition": "When the question mentions \"male superheroes\"",
            "operation": " \"male\" actually means \"T4.gender = 'Male'\" in schema."
        },
        "167": {
            "condition": "When combining T1 (superheroes), T2 (hero_power), T3 (superpower), and T4 (gender) for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and T3.id = T2.power_id and T4.id = T1.gender_id; keep only matching pairs (inner match)."
        },
        "168": {
            "condition": "When filtering by gender",
            "operation": " use the exact literal 'Male' with exact case and spacing as shown in the schema."
        },
        "169": {
            "condition": "When answering about \"superpowers of male superheroes\", When the question mentions \"male superheroes\", When combining T1 (superheroes), T2 (hero_power), T3 (superpower), and T4 (gender) for shared entities, When filtering by gender, When selecting superpowers",
            "operation": " use T3.power_name from the superpower table instead of any superpower column from the superheroes table."
        },
        "170": {
            "condition": "When answering about \"alien superheroes\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "171": {
            "condition": "When the question mentions \"alien superheroes\"",
            "operation": " \"alien\" actually means \"T2.race = 'Alien'\" in schema."
        },
        "172": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.race_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "173": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "174": {
            "condition": "When answering about \"alien superheroes\", When the question mentions \"alien superheroes\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Alien'."
        },
        "175": {
            "condition": "When the question asks for superhero names",
            "operation": " use \"T1.superhero_name\" with DISTINCT to ensure unique results."
        },
        "176": {
            "condition": "When filtering by height range 170 to 190",
            "operation": " use \"T1.height_cm\" BETWEEN 170 AND 190 (inclusive) instead of \"height\"."
        },
        "177": {
            "condition": "When identifying superheroes with no eye color",
            "operation": " join \"superhero AS T1\" with \"colour AS T2\" using \"T1.eye_colour_id = T2.id\" and filter for \"T2.colour = 'No Colour'\" instead of checking for NULL values."
        },
        "178": {
            "condition": "When the question asks for superhero names, When filtering by height range 170 to 190, When identifying superheroes with no eye color, When combining tables for eye color resolution",
            "operation": " perform an INNER JOIN to keep only superheroes that have matching color records."
        },
        "179": {
            "condition": "When answering about \"superpower of hero ID 56\"",
            "operation": " make sure the output order: T2.power_name."
        },
        "180": {
            "condition": "When the question mentions \"superpower\"",
            "operation": " \"superpower\" actually means \"T2.power_name in schema\"."
        },
        "181": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.power_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "182": {
            "condition": "When answering about \"superpower of hero ID 56\", When the question mentions \"superpower\", When combining T1 and T2 for shared entities, When filtering for hero ID 56",
            "operation": " use T1.hero_id = 56 instead of hero_id from the wrong table."
        },
        "183": {
            "condition": "When answering about \"Demi-God superheroes\"",
            "operation": " make sure the output order: T1.full_name"
        },
        "184": {
            "condition": "When the question mentions \"Demi-God superheroes\"",
            "operation": " \"Demi-God\" actually means \"T2.race = 'Demi-God'\" in schema"
        },
        "185": {
            "condition": "When combining T1 (superhero) and T2 (race) for shared entities",
            "operation": " link rows where T1.race_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "186": {
            "condition": "When the question asks for \"full name\"",
            "operation": " use the exact token T1.full_name from the schema"
        },
        "187": {
            "condition": "When answering about \"Demi-God superheroes\", When the question mentions \"Demi-God superheroes\", When combining T1 (superhero) and T2 (race) for shared entities, When the question asks for \"full name\", When the question says \"at least five\"",
            "operation": " return all matching records instead of limiting to exactly 5 rows"
        },
        "188": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null values."
        },
        "189": {
            "condition": "When answering about superhero alignment",
            "operation": " join superhero AS T1 with alignment AS T2 using the condition T1.alignment_id = T2.id instead of querying a single table."
        },
        "190": {
            "condition": "When filtering for bad superheroes",
            "operation": " filter on T2.alignment = 'Bad' instead of alignment = 'good' to target the correct alignment category."
        },
        "191": {
            "condition": "When counting superheroes, When answering about superhero alignment, When filtering for bad superheroes, When combining superhero and alignment tables",
            "operation": " link rows where T1.alignment_id = T2.id and keep only matching pairs (inner match)."
        },
        "192": {
            "condition": "When answering about superhero race information",
            "operation": " access race data through the race table (T2) rather than directly from the superheroes table."
        },
        "193": {
            "condition": "When combining superhero and race tables",
            "operation": " link rows where T1.race_id equals T2.id and keep only matching pairs (inner match)."
        },
        "194": {
            "condition": "When filtering by weight",
            "operation": " use the exact column T1.weight_kg with the value 169 to match the kilogram unit specification."
        },
        "195": {
            "condition": "When answering about superhero race information, When combining superhero and race tables, When filtering by weight, When selecting output",
            "operation": " return T2.race as the final result."
        },
        "196": {
            "condition": "When answering about hair colour of human superheroes",
            "operation": " use DISTINCT T3.colour instead of hair_color without distinct."
        },
        "197": {
            "condition": "When querying superhero data",
            "operation": " join superhero AS T1 instead of querying superheroes directly."
        },
        "198": {
            "condition": "When filtering by race",
            "operation": " add INNER JOIN race AS T2 ON T1.race_id = T2.id to access race information."
        },
        "199": {
            "condition": "When accessing hair colour information",
            "operation": " use INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id instead of directly selecting hair_color."
        },
        "200": {
            "condition": "When filtering by height",
            "operation": " use T1.height_cm = 185 instead of height = 185."
        },
        "201": {
            "condition": "When answering about hair colour of human superheroes, When querying superhero data, When filtering by race, When accessing hair colour information, When filtering by height, When filtering for human species",
            "operation": " use T2.race = 'Human' instead of species = 'human'."
        },
        "202": {
            "condition": "When the question asks about eye color",
            "operation": " join the superhero table (T1) with the colour table (T2) using T1.eye_colour_id = T2.id to get the actual color value from T2.colour instead of using T1.eye_color directly."
        },
        "203": {
            "condition": "When determining the heaviest superhero",
            "operation": " use T1.weight_kg for ordering by weight in descending order instead of weight."
        },
        "204": {
            "condition": "When the question asks about eye color, When determining the heaviest superhero, When selecting the eye color of the heaviest superhero",
            "operation": " after joining tables and ordering by T1.weight_kg DESC, take only the first row to get the single heaviest superhero's eye color from T2.colour."
        },
        "205": {
            "condition": "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)",
            "operation": "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)"
        },
        "206": {
            "condition": "When answering about superhero names",
            "operation": " use the exact column token \"T1.superhero_name\" for output."
        },
        "207": {
            "condition": "When the question mentions \"male superheroes\"",
            "operation": " join table \"superhero AS T1\" with table \"gender AS T2\" on \"T1.gender_id = T2.id\" and filter using \"T2.gender = 'Male'\"."
        },
        "208": {
            "condition": "When the question mentions \"weight\"",
            "operation": " use the column \"T1.weight_kg\" and multiply it by 100 for comparison."
        },
        "209": {
            "condition": "When calculating the 79% average weight",
            "operation": " compute the average of \"weight_kg\" from all superheroes and multiply the result by 79 instead of 0.79."
        },
        "210": {
            "condition": "When answering about superhero names, When the question mentions \"male superheroes\", When the question mentions \"weight\", When calculating the 79% average weight, When comparing weight",
            "operation": " ensure the main query compares \"T1.weight_kg * 100\" against the calculated 79% average weight from the subquery."
        },
        "211": {
            "condition": "When the question asks about \"power\" that superheroes have",
            "operation": " \"power\" actually means \"T2.power_name\" from the superpower table."
        },
        "212": {
            "condition": "When combining hero_power (T1) and superpower (T2) tables",
            "operation": " link rows where T1.power_id equals T2.id exactly and keep only matching pairs (inner match)."
        },
        "213": {
            "condition": "When counting superhero associations with powers",
            "operation": " count the number of unique T1.hero_id values instead of counting all rows."
        },
        "214": {
            "condition": "When grouping by power",
            "operation": " organize results by T2.power_name and compute the count per power group."
        },
        "215": {
            "condition": "When the question asks about \"power\" that superheroes have, When combining hero_power (T1) and superpower (T2) tables, When counting superhero associations with powers, When grouping by power, When the question asks for \"the most\"",
            "operation": " rank power groups by the count of T1.hero_id in descending order and keep only the top 1 result."
        },
        "216": {
            "condition": "When answering about \"which power do superheroes have the most of\"",
            "operation": " make sure the output order includes only \"T2.power_name\" without any count columns."
        },
        "217": {
            "condition": "When counting superheroes per power",
            "operation": " compute the number of rows using the canonical key \"T1.hero_id\" for counting."
        },
        "218": {
            "condition": "When combining tables \"hero_power\" as T1 and \"superpower\" as T2",
            "operation": " link rows where \"T1.power_id = T2.id\" and keep only matching pairs (inner match)."
        },
        "219": {
            "condition": "When answering about \"which power do superheroes have the most of\", When counting superheroes per power, When combining tables \"hero_power\" as T1 and \"superpower\" as T2, When the question asks for \"the most\"",
            "operation": " rank rows by the count of \"T1.hero_id\" in descending order and keep the first 1 row."
        },
        "220": {
            "condition": "When the question asks for \"attribute value of superhero Abomination\"",
            "operation": " select T2.attribute_value as the output column instead of name."
        },
        "221": {
            "condition": "When querying about superhero attributes",
            "operation": " use \"superhero\" as T1 and \"hero_attribute\" as T2 tables instead of a single \"superheroes\" table."
        },
        "222": {
            "condition": "When combining superhero and hero_attribute tables",
            "operation": " link rows where T1.id = T2.hero_id using an inner match."
        },
        "223": {
            "condition": "When the question asks for \"attribute value of superhero Abomination\", When querying about superhero attributes, When combining superhero and hero_attribute tables, When filtering for a specific superhero",
            "operation": " use T1.superhero_name = 'Abomination' to reference the superhero name column exactly."
        },
        "224": {
            "condition": "When the question asks for \"superpowers\"",
            "operation": " use the exact column token \"T2.power_name\" instead of \"superpower\"."
        },
        "225": {
            "condition": "When retrieving multiple values that may have duplicates",
            "operation": " apply DISTINCT to eliminate duplicate results."
        },
        "226": {
            "condition": "When combining hero and power information",
            "operation": " use \"hero_power AS T1 INNER JOIN superpower AS T2\" with join condition \"T1.power_id = T2.id\" to link related records."
        },
        "227": {
            "condition": "When filtering for a specific hero",
            "operation": " use the exact condition \"T1.hero_id = 1\" with the literal value 1 as specified in the question."
        },
        "228": {
            "condition": "When the question asks for \"superpowers\", When retrieving multiple values that may have duplicates, When combining hero and power information, When filtering for a specific hero, When the question mentions \"heroes with ID 1\"",
            "operation": " ensure the filter uses the exact literal value 1, not 2 or any other value."
        },
        "229": {
            "condition": "When counting heroes",
            "operation": " use COUNT(T1.hero_id) to count specific hero records instead of COUNT(*)."
        },
        "230": {
            "condition": "When the question mentions \"stealth power\"",
            "operation": " \"stealth power\" actually means T2.power_name = 'Stealth' with exact case sensitivity."
        },
        "231": {
            "condition": "When combining hero_power and superpower tables",
            "operation": " link rows where T1.power_id = T2.id and keep only matching pairs (inner match)."
        },
        "232": {
            "condition": "When counting heroes, When the question mentions \"stealth power\", When combining hero_power and superpower tables, When answering about \"how many heroes have stealth power\"",
            "operation": " make sure to join hero_power AS T1 INNER JOIN superpower AS T2 instead of querying a single heroes table."
        },
        "233": {
            "condition": "When the question asks for \"hero's full name\"",
            "operation": " select \"full_name\" from the \"superhero\" table instead of \"hero_name\" from any other table."
        },
        "234": {
            "condition": "When the question mentions \"highest attribute in strength\"",
            "operation": " join \"superhero\" with \"hero_attribute\" on \"id\" = \"hero_id\" and then with \"attribute\" on \"attribute_id\" = \"id\" to access attribute values."
        },
        "235": {
            "condition": "When filtering for strength attribute",
            "operation": " add a condition where \"attribute_name\" equals 'Strength' exactly."
        },
        "236": {
            "condition": "When ordering by attribute value",
            "operation": " sort by \"attribute_value DESC\" to find the highest value."
        },
        "237": {
            "condition": "When the question asks for \"hero's full name\", When the question mentions \"highest attribute in strength\", When filtering for strength attribute, When ordering by attribute value, When retrieving the top result",
            "operation": " limit to the first row after ordering to get the single highest value."
        },
        "238": {
            "condition": "When calculating the proportion of superheroes with a specific skin color",
            "operation": " use the formula CAST(COUNT(*) AS REAL) / SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) instead of AVG(*) for ratio calculation."
        },
        "239": {
            "condition": "When joining superheroes table to color table",
            "operation": " use INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id to establish the relationship between tables."
        },
        "240": {
            "condition": "When checking for skin color condition",
            "operation": " reference T1.skin_colour_id in the join condition instead of checking skin_color IS NULL directly."
        },
        "241": {
            "condition": "When calculating the proportion of superheroes with a specific skin color, When joining superheroes table to color table, When checking for skin color condition, When handling the condition for no skin color",
            "operation": " remove the WHERE clause filter entirely as the condition is handled through the join and case expression."
        },
        "242": {
            "condition": "When counting superheroes",
            "operation": " count using T1.id instead of all columns to avoid counting nulls."
        },
        "243": {
            "condition": "When the question mentions \"published by Dark Horse Comics\"",
            "operation": " this means filtering on T2.publisher_name = 'Dark Horse Comics' exactly as written."
        },
        "244": {
            "condition": "When combining superheroes and publisher tables",
            "operation": " link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match)."
        },
        "245": {
            "condition": "When counting superheroes, When the question mentions \"published by Dark Horse Comics\", When combining superheroes and publisher tables, When answering about \"how many superheroes were published by Dark Horse Comics\"",
            "operation": " make sure to count T1.id after filtering for T2.publisher_name = 'Dark Horse Comics'."
        },
        "246": {
            "condition": "When answering about superhero durability published by Dark Horse Comics",
            "operation": " make sure the output order: superhero_name."
        },
        "247": {
            "condition": "When the question mentions \"durability\"",
            "operation": " \"durability\" actually means \"T3.attribute_name = 'Durability'\" in schema."
        },
        "248": {
            "condition": "When the question mentions \"Dark Horse Comics\"",
            "operation": " \"Dark Horse Comics\" actually means \"T4.publisher_name = 'Dark Horse Comics'\" in schema."
        },
        "249": {
            "condition": "When combining T1 (superhero) and T2 (hero_attribute) for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and keep only matching pairs (inner match)."
        },
        "250": {
            "condition": "When combining T2 (hero_attribute) and T3 (attribute) for shared entities",
            "operation": " link rows where T3.id = T2.attribute_id and keep only matching pairs (inner match)."
        },
        "251": {
            "condition": "When combining T1 (superhero) and T4 (publisher) for shared entities",
            "operation": " link rows where T4.id = T1.publisher_id and keep only matching pairs (inner match)."
        },
        "252": {
            "condition": "When the question asks for \"most durability\"",
            "operation": " rank rows by T2.attribute_value in descending direction and keep the first 1 row."
        },
        "253": {
            "condition": "When filtering for durability attribute",
            "operation": " use exact literal 'Durability' for T3.attribute_name."
        },
        "254": {
            "condition": "When answering about superhero durability published by Dark Horse Comics, When the question mentions \"durability\", When the question mentions \"Dark Horse Comics\", When combining T1 (superhero) and T2 (hero_attribute) for shared entities, When combining T2 (hero_attribute) and T3 (attribute) for shared entities, When combining T1 (superhero) and T4 (publisher) for shared entities, When the question asks for \"most durability\", When filtering for durability attribute, When filtering for publisher",
            "operation": " use exact literal 'Dark Horse Comics' for T4.publisher_name."
        },
        "255": {
            "condition": "When answering about \"superhero with the most durability published by Dark Horse Comics\"",
            "operation": " make sure the output order: T1.superhero_name only"
        },
        "256": {
            "condition": "When the question mentions \"Dark Horse Comics\"",
            "operation": " \"Dark Horse Comics\" actually means T4.publisher_name = 'Dark Horse Comics' in schema"
        },
        "257": {
            "condition": "When the question mentions \"durability\"",
            "operation": " \"durability\" actually means T3.attribute_name = 'Durability' in schema"
        },
        "258": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id; keep only matching pairs (inner match)"
        },
        "259": {
            "condition": "When combining T2 and T3 for shared attributes",
            "operation": " link rows where T3.id = T2.attribute_id; keep only matching pairs (inner match)"
        },
        "260": {
            "condition": "When combining T1 and T4 for shared publishers",
            "operation": " link rows where T4.id = T1.publisher_id; keep only matching pairs (inner match)"
        },
        "261": {
            "condition": "When the question asks for \"most durability\"",
            "operation": " rank rows by T2.attribute_value in descending order and keep the first 1 row"
        },
        "262": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "263": {
            "condition": "When answering about \"superhero with the most durability published by Dark Horse Comics\", When the question mentions \"Dark Horse Comics\", When the question mentions \"durability\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared attributes, When combining T1 and T4 for shared publishers, When the question asks for \"most durability\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Dark Horse Comics' or 'Durability'"
        },
        "264": {
            "condition": "When the question asks about eye color",
            "operation": " retrieve the \"colour\" column from table \"colour\" (aliased as T2) instead of \"eye_color\" from the \"characters\" table."
        },
        "265": {
            "condition": "When combining superhero and colour tables",
            "operation": " link rows where T1.eye_colour_id equals T2.id and keep only matching pairs (inner join)."
        },
        "266": {
            "condition": "When the question asks about eye color, When combining superhero and colour tables, When filtering for a specific character",
            "operation": " use T1.full_name = 'Abraham Sapien' instead of name = 'Abraham Lincoln' to reference the correct character identifier."
        },
        "267": {
            "condition": "When answering about \"superheroes with flight power\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "268": {
            "condition": "When the question mentions \"name\"",
            "operation": " \"name\" actually means \"T1.superhero_name\" in schema."
        },
        "269": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match)."
        },
        "270": {
            "condition": "When answering about \"superheroes with flight power\", When the question mentions \"name\", When combining T1, T2, and T3 for shared entities, When the question mentions \"flight power\"",
            "operation": " \"flight power\" actually means \"T3.power_name = 'Flight'\" with exact case sensitivity."
        },
        "271": {
            "condition": "When the question asks about superhero attributes",
            "operation": " use table \"superhero\" (not \"superheroes\") with alias T1."
        },
        "272": {
            "condition": "When referencing eye, hair, and skin colors",
            "operation": " use columns T1.eye_colour_id, T1.hair_colour_id, and T1.skin_colour_id instead of eyes, hair, and skin."
        },
        "273": {
            "condition": "When filtering by publisher",
            "operation": " join table \"publisher\" as T2 using T2.id = T1.publisher_id and filter with T2.publisher_name = 'Dark Horse Comics'."
        },
        "274": {
            "condition": "When filtering by gender",
            "operation": " join table \"gender\" as T3 using T3.id = T1.gender_id and filter with T3.gender = 'Female' (not 'male')."
        },
        "275": {
            "condition": "When the question asks about superhero attributes, When referencing eye, hair, and skin colors, When filtering by publisher, When filtering by gender, When combining tables",
            "operation": " perform inner joins on the exact key relationships T2.id = T1.publisher_id and T3.id = T1.gender_id to ensure only matching pairs are kept."
        },
        "276": {
            "condition": "When the question asks for eye, hair, and skin colour",
            "operation": " select the raw ID columns \"T1.eye_colour_id\", \"T1.hair_colour_id\", and \"T1.skin_colour_id\" directly from the superhero table instead of joining to resolve colour names."
        },
        "277": {
            "condition": "When joining tables for publisher filtering",
            "operation": " link \"T1.publisher_id\" with \"T2.id\" where \"T2.publisher_name\" equals 'Dark Horse Comics' exactly."
        },
        "278": {
            "condition": "When filtering for female superheroes",
            "operation": " link \"T1.gender_id\" with \"T3.id\" where \"T3.gender\" equals 'Female' exactly."
        },
        "279": {
            "condition": "When the question asks for eye, hair, and skin colour, When joining tables for publisher filtering, When filtering for female superheroes, When selecting output columns",
            "operation": " maintain the order eye_colour, hair_colour, skin_colour as specified in the question."
        },
        "280": {
            "condition": "When answering about superhero attributes and publisher",
            "operation": " make sure the output order: T1.superhero_name, T2.publisher_name"
        },
        "281": {
            "condition": "When the question mentions \"name\"",
            "operation": " \"name\" actually means \"T1.superhero_name\" in schema"
        },
        "282": {
            "condition": "When the question mentions \"publisher\"",
            "operation": " \"publisher\" actually means \"T2.publisher_name\" in schema"
        },
        "283": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match)"
        },
        "284": {
            "condition": "When answering about superhero attributes and publisher, When the question mentions \"name\", When the question mentions \"publisher\", When combining T1 and T2 for shared entities, When filtering for same eye, hair and skin color",
            "operation": " filter with T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id instead of direct color name comparisons"
        },
        "285": {
            "condition": "When the question asks about a superhero's group",
            "operation": " use \"T2.race\" instead of \"group_name\" as the output column."
        },
        "286": {
            "condition": "When querying for superhero information",
            "operation": " use table \"superhero AS T1\" instead of \"superheroes\"."
        },
        "287": {
            "condition": "When retrieving group/race information for a superhero",
            "operation": " perform an inner join between \"superhero AS T1\" and \"race AS T2\" where \"T1.race_id = T2.id\"."
        },
        "288": {
            "condition": "When the question asks about a superhero's group, When querying for superhero information, When retrieving group/race information for a superhero, When filtering by superhero name",
            "operation": " use the exact column \"T1.superhero_name\" and literal value \"'A-Bomb'\" with exact case and punctuation."
        },
        "289": {
            "condition": "When answering about percentage of blue female superheroes among all female superheroes",
            "operation": " join table superhero (T1) with gender (T2) on T1.gender_id = T2.id and with colour (T3) on T1.skin_colour_id = T3.id."
        },
        "290": {
            "condition": "When filtering for female superheroes",
            "operation": " use condition T2.gender = 'Female' in the WHERE clause."
        },
        "291": {
            "condition": "When counting female superheroes with blue eyes",
            "operation": " use condition T3.colour = 'Blue' for the numerator."
        },
        "292": {
            "condition": "When counting all female superheroes",
            "operation": " count T1.id for the denominator instead of using CASE expressions."
        },
        "293": {
            "condition": "When calculating the percentage",
            "operation": " cast the count to REAL before multiplication with 100.0."
        },
        "294": {
            "condition": "When answering about percentage of blue female superheroes among all female superheroes, When filtering for female superheroes, When counting female superheroes with blue eyes, When counting all female superheroes, When calculating the percentage, When combining tables",
            "operation": " use proper table aliases T1 for superhero, T2 for gender, and T3 for colour."
        },
        "295": {
            "condition": "When answering about \"hero name and race of Charles Chandler\"",
            "operation": " make sure the output order: T1.superhero_name, T2.race"
        },
        "296": {
            "condition": "When the question mentions \"hero name\"",
            "operation": " \"hero name\" actually means \"T1.superhero_name\" in schema"
        },
        "297": {
            "condition": "When the question mentions \"race\"",
            "operation": " \"race\" actually means \"T2.race\" in schema"
        },
        "298": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.race_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "299": {
            "condition": "When answering about \"hero name and race of Charles Chandler\", When the question mentions \"hero name\", When the question mentions \"race\", When combining T1 and T2 for shared entities, When filtering for Charles Chandler",
            "operation": " use T1.full_name = 'Charles Chandler' exactly as specified in the amends, not separate first and last name conditions"
        },
        "300": {
            "condition": "When answering about \"gender of Agent 13 hero\"",
            "operation": " make sure the output order: T2.gender"
        },
        "301": {
            "condition": "When the question mentions \"Agent 13 hero\"",
            "operation": " \"Agent 13\" actually means \"T1.superhero_name = 'Agent 13'\" in schema"
        },
        "302": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.gender_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "303": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "304": {
            "condition": "When answering about \"gender of Agent 13 hero\", When the question mentions \"Agent 13 hero\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Agent 13'"
        },
        "305": {
            "condition": "When selecting superhero names",
            "operation": " use \"T1.superhero_name\" instead of \"name\" for the output column."
        },
        "306": {
            "condition": "When answering about superheroes with specific powers",
            "operation": " join \"superheroes AS T1\" to \"hero_power AS T2\" on \"T1.id = T2.hero_id\" and join to \"superpower AS T3\" on \"T2.power_id = T3.id\" using inner matches."
        },
        "307": {
            "condition": "When selecting superhero names, When answering about superheroes with specific powers, When filtering for adaptation power",
            "operation": " use the exact literal \"Adaptation\" with \"T3.power_name = 'Adaptation'\" as the condition."
        },
        "308": {
            "condition": "When counting powers for a specific superhero",
            "operation": " use COUNT(T1.power_id) from the hero_power table instead of COUNT(*) from the powers table."
        },
        "309": {
            "condition": "When joining hero_power and superhero tables",
            "operation": " link rows where T1.hero_id = T2.id to properly associate powers with superheroes."
        },
        "310": {
            "condition": "When filtering by superhero name",
            "operation": " use T2.superhero_name = 'Amazo' instead of hero_name = 'Amazo' to reference the correct column in the superhero table."
        },
        "311": {
            "condition": "When counting powers for a specific superhero, When joining hero_power and superhero tables, When filtering by superhero name, When answering about \"how many powers does Amazo hero have\"",
            "operation": " make sure to join hero_power AS T1 with superhero AS T2 on T1.hero_id = T2.id and filter for T2.superhero_name = 'Amazo' before counting T1.power_id."
        },
        "312": {
            "condition": "When answering about \"powers of Hunter Zolomon\"",
            "operation": " make sure the output order: T3.power_name."
        },
        "313": {
            "condition": "When the question mentions \"Hunter Zolomon\"",
            "operation": " \"Hunter Zolomon\" actually means \"T1.full_name = 'Hunter Zolomon'\" in schema."
        },
        "314": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "315": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.power_id = T3.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "316": {
            "condition": "When answering about \"powers of Hunter Zolomon\", When the question mentions \"Hunter Zolomon\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "317": {
            "condition": "When answering about \"heights of heroes whose eye colours are amber\"",
            "operation": " make sure the output order: T1.height_cm"
        },
        "318": {
            "condition": "When the question mentions \"eye colours are amber\"",
            "operation": " \"amber\" actually means \"T2.colour = 'Amber'\" in schema with exact case sensitivity"
        },
        "319": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.eye_colour_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "320": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "321": {
            "condition": "When answering about \"heights of heroes whose eye colours are amber\", When the question mentions \"eye colours are amber\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exactly 'Amber' not 'amber'"
        },
        "322": {
            "condition": "When answering about \"heroes' names whose eyes and hair colours are both black\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "323": {
            "condition": "When the question mentions \"heroes' names\"",
            "operation": " \"name\" actually means \"T1.superhero_name\" in schema."
        },
        "324": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id; keep only matching pairs (inner match)."
        },
        "325": {
            "condition": "When filtering for black colour",
            "operation": " use T2.colour = 'Black' with exact case sensitivity."
        },
        "326": {
            "condition": "When answering about \"heroes' names whose eyes and hair colours are both black\", When the question mentions \"heroes' names\", When combining T1 and T2 for shared entities, When filtering for black colour, When the question requires both eyes and hair to be black",
            "operation": " ensure both join conditions are satisfied simultaneously rather than using OR logic."
        },
        "327": {
            "condition": "When answering about \"eye colours of heroes\"",
            "operation": " select T2.colour from the colour table instead of eye_color from the heroes table."
        },
        "328": {
            "condition": "When combining superhero table T1 with colour table T2",
            "operation": " link rows where T1.eye_colour_id = T2.id and keep only matching pairs."
        },
        "329": {
            "condition": "When combining superhero table T1 with colour table T3",
            "operation": " link rows where T1.skin_colour_id = T3.id and keep only matching pairs."
        },
        "330": {
            "condition": "When answering about \"eye colours of heroes\", When combining superhero table T1 with colour table T2, When combining superhero table T1 with colour table T3, When filtering for heroes with skin colour gold",
            "operation": " filter on T3.colour = 'Gold' with exact case sensitivity instead of 'gold' with lowercase."
        },
        "331": {
            "condition": "When answering about \"full names of vampire heroes\"",
            "operation": " make sure the output order: T1.full_name."
        },
        "332": {
            "condition": "When the question mentions \"vampire heroes\"",
            "operation": " \"vampire\" actually means \"T2.race = 'Vampire'\" in schema."
        },
        "333": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.race_id = T2.id; keep only matching pairs (inner match)."
        },
        "334": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "335": {
            "condition": "When answering about \"full names of vampire heroes\", When the question mentions \"vampire heroes\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exact literal 'Vampire'."
        },
        "336": {
            "condition": "When answering about superhero names",
            "operation": " use the exact column token \"T1.superhero_name\" instead of \"name\"."
        },
        "337": {
            "condition": "When the question mentions \"neutral alignment\"",
            "operation": " join the alignment table as T2 using \"T1.alignment_id = T2.id\" to establish the relationship."
        },
        "338": {
            "condition": "When filtering for neutral alignment",
            "operation": " use the exact literal value 'Neutral' with \"T2.alignment = 'Neutral'\" instead of 'good'."
        },
        "339": {
            "condition": "When answering about superhero names, When the question mentions \"neutral alignment\", When filtering for neutral alignment, When combining superheroes and alignment tables",
            "operation": " perform an inner join to keep only matching pairs where alignment relationships exist."
        },
        "340": {
            "condition": "When answering about heroes with highest attribute values",
            "operation": " query both hero_attribute (T1) and attribute (T2) tables instead of just heroes table."
        },
        "341": {
            "condition": "When combining hero_attribute and attribute tables",
            "operation": " link rows where T1.attribute_id equals T2.id using inner join."
        },
        "342": {
            "condition": "When filtering for strength attribute",
            "operation": " use T2.attribute_name = 'Strength' exactly as specified."
        },
        "343": {
            "condition": "When counting heroes",
            "operation": " count T1.hero_id instead of using COUNT(*)."
        },
        "344": {
            "condition": "When finding the highest attribute value",
            "operation": " use MAX(attribute_value) instead of MIN."
        },
        "345": {
            "condition": "When answering about heroes with highest attribute values, When combining hero_attribute and attribute tables, When filtering for strength attribute, When counting heroes, When finding the highest attribute value, When comparing attribute values",
            "operation": " reference attribute_value column instead of strength column in the main condition."
        },
        "346": {
            "condition": "When answering about a character's race and alignment",
            "operation": " join table \"superhero\" as T1 with table \"race\" as T2 on T1.race_id = T2.id and with table \"alignment\" as T3 on T1.alignment_id = T3.id."
        },
        "347": {
            "condition": "When the question mentions \"race\"",
            "operation": " select T2.race instead of a direct column from the main table."
        },
        "348": {
            "condition": "When the question mentions \"alignment\"",
            "operation": " select T3.alignment instead of a direct column from the main table."
        },
        "349": {
            "condition": "When answering about a character's race and alignment, When the question mentions \"race\", When the question mentions \"alignment\", When filtering for a specific character name",
            "operation": " use T1.superhero_name = 'Cameron Hicks' instead of name = 'Cameron Hicks' to match the correct column name."
        },
        "350": {
            "condition": "When answering about percentage of female heroes published by Marvel Comics",
            "operation": " make sure the output order: percentage"
        },
        "351": {
            "condition": "When the question mentions \"female heroes\"",
            "operation": " \"female\" actually means \"T3.gender = 'Female'\" in schema"
        },
        "352": {
            "condition": "When the question mentions \"Marvel Comics\"",
            "operation": " \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema"
        },
        "353": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.publisher_id = T2.id and T1.gender_id = T3.id; keep only matching pairs (inner match)"
        },
        "354": {
            "condition": "When calculating percentage of female Marvel Comics heroes",
            "operation": " compute (COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END)) divided by (COUNT(T1.id)), guarding division by zero; cast the result to REAL instead of using integer division"
        },
        "355": {
            "condition": "When answering about percentage of female heroes published by Marvel Comics, When the question mentions \"female heroes\", When the question mentions \"Marvel Comics\", When combining T1, T2, and T3 for shared entities, When calculating percentage of female Marvel Comics heroes, When counting heroes",
            "operation": " use T1.id as the canonical counting key for heroes"
        },
        "356": {
            "condition": "When calculating average weight",
            "operation": " use CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) instead of AVG(height) to properly handle casting and use the correct metric."
        },
        "357": {
            "condition": "When relating superhero and race data",
            "operation": " join superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id instead of querying a single heroes table."
        },
        "358": {
            "condition": "When filtering for alien species",
            "operation": " use T2.race = 'Alien' instead of species = 'alien' to reference the correct column name and table."
        },
        "359": {
            "condition": "When calculating average weight, When relating superhero and race data, When filtering for alien species, When referencing columns for calculation",
            "operation": " use weight_kg and id columns instead of height to calculate the intended weight metric."
        },
        "360": {
            "condition": "When the question asks about character weights",
            "operation": " retrieve data from the \"superhero\" table instead of a \"characters\" table."
        },
        "361": {
            "condition": "When filtering for specific characters",
            "operation": " use \"full_name LIKE 'Emil Blonsky'\" and \"full_name LIKE 'Charles Chandler'\" instead of exact matches on a \"name\" column."
        },
        "362": {
            "condition": "When calculating weight differences",
            "operation": " use direct subtraction \"(SELECT...) - (SELECT...)\" instead of ABS function."
        },
        "363": {
            "condition": "When naming the result column",
            "operation": " alias it as \"CALCULATE\" instead of \"weight_difference\"."
        },
        "364": {
            "condition": "When the question asks about character weights, When filtering for specific characters, When calculating weight differences, When naming the result column, When selecting weight values",
            "operation": " use the exact column name \"weight_kg\" from the \"superhero\" table."
        },
        "365": {
            "condition": "When calculating average height for superheroes",
            "operation": " use SUM(\"height_cm\") divided by COUNT(\"id\") instead of AVG(\"weight\")."
        },
        "366": {
            "condition": "When casting the result",
            "operation": " cast the average as REAL data type."
        },
        "367": {
            "condition": "When referencing the superhero table",
            "operation": " use the exact table name \"superhero\" instead of \"superheroes\"."
        },
        "368": {
            "condition": "When calculating an overall average across all superheroes",
            "operation": " remove GROUP BY \"name\" clause and do not include \"name\" column in the output."
        },
        "369": {
            "condition": "When calculating average height for superheroes, When casting the result, When referencing the superhero table, When calculating an overall average across all superheroes, When naming the result column",
            "operation": " remove the alias \"average_height\" instead of keeping it."
        },
        "370": {
            "condition": "When the question asks about a character's superpower",
            "operation": " use the \"superpower\" table (T3) to get power_name instead of the characters table."
        },
        "371": {
            "condition": "When joining tables for superhero information",
            "operation": " link superhero table (T1) with hero_power table (T2) using T1.id = T2.hero_id."
        },
        "372": {
            "condition": "When accessing superpower details",
            "operation": " join hero_power table (T2) with superpower table (T3) using T2.power_id = T3.id."
        },
        "373": {
            "condition": "When filtering by character name",
            "operation": " use T1.superhero_name = 'Abomination' with exact case and spelling."
        },
        "374": {
            "condition": "When the question asks about a character's superpower, When joining tables for superhero information, When accessing superpower details, When filtering by character name, When selecting the final result",
            "operation": " output T3.power_name as the superpower information."
        },
        "375": {
            "condition": "When answering about superheroes with race of 'god/eternal'",
            "operation": " use integer ID 21 for race filtering instead of the string literal 'god/eternal'."
        },
        "376": {
            "condition": "When answering about male superheroes",
            "operation": " use integer ID 1 for gender filtering instead of the string literal 'male'."
        },
        "377": {
            "condition": "When combining superhero data with race information",
            "operation": " join table superhero AS T1 with race AS T2 on T1.race_id = T2.id."
        },
        "378": {
            "condition": "When combining superhero data with gender information",
            "operation": " join table superhero AS T1 with gender AS T3 on T3.id = T1.gender_id."
        },
        "379": {
            "condition": "When answering about superheroes with race of 'god/eternal', When answering about male superheroes, When combining superhero data with race information, When combining superhero data with gender information, When counting superheroes",
            "operation": " use the canonical key from the superhero table to count entities."
        },
        "380": {
            "condition": "When answering about \"which hero was the fastest\"",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "381": {
            "condition": "When the question mentions \"hero\"",
            "operation": " \"hero\" actually means \"superhero_name in schema\"."
        },
        "382": {
            "condition": "When combining T1 (superhero) and T2 (hero_attribute) for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and keep only matching pairs (inner match)."
        },
        "383": {
            "condition": "When combining T2 (hero_attribute) and T3 (attribute) for shared entities",
            "operation": " link rows where T2.attribute_id = T3.id and keep only matching pairs (inner match)."
        },
        "384": {
            "condition": "When the question asks for \"fastest\" or \"highest speed\"",
            "operation": " add a WHERE filter T3.attribute_name = 'Speed' to specifically target speed attributes."
        },
        "385": {
            "condition": "When answering about \"which hero was the fastest\", When the question mentions \"hero\", When combining T1 (superhero) and T2 (hero_attribute) for shared entities, When combining T2 (hero_attribute) and T3 (attribute) for shared entities, When the question asks for \"fastest\" or \"highest speed\", When the question asks for \"fastest\" or \"highest speed\"",
            "operation": " rank rows by T2.attribute_value in descending direction and keep the first 1 row."
        },
        "386": {
            "condition": "When answering about \"how many superheroes have a neutral alignment\"",
            "operation": " make sure the output order: count of superheroes with neutral alignment."
        },
        "387": {
            "condition": "When the question mentions \"superheroes\"",
            "operation": " \"superheroes\" actually means \"superhero\" table in schema."
        },
        "388": {
            "condition": "When combining superhero and alignment tables",
            "operation": " link rows where superhero.alignment_id = alignment.id; keep only matching pairs (inner match)."
        },
        "389": {
            "condition": "When filtering for neutral alignment",
            "operation": " use alignment.alignment = 'Neutral' exactly as specified."
        },
        "390": {
            "condition": "When answering about \"how many superheroes have a neutral alignment\", When the question mentions \"superheroes\", When combining superhero and alignment tables, When filtering for neutral alignment, When counting superheroes",
            "operation": " compute the number of rows using the canonical key token T1.id."
        },
        "391": {
            "condition": "When answering about a superhero's attributes",
            "operation": " make sure the output order includes T3.attribute_name and T2.attribute_value."
        },
        "392": {
            "condition": "When the question mentions \"3-D Man\"",
            "operation": " \"3-D Man\" actually means T1.superhero_name = '3-D Man' in schema."
        },
        "393": {
            "condition": "When combining T1, T2, and T3 for superhero attributes",
            "operation": " link rows where T1.id = T2.hero_id and T2.attribute_id = T3.id; keep only matching pairs (inner match)."
        },
        "394": {
            "condition": "When answering about a superhero's attributes, When the question mentions \"3-D Man\", When combining T1, T2, and T3 for superhero attributes, When selecting specific attribute information",
            "operation": " do not use SELECT * but instead select specific columns T3.attribute_name and T2.attribute_value."
        },
        "395": {
            "condition": "When answering about superheroes with specific eye and hair colors",
            "operation": " use T1.\"superhero_name\" as the output column instead of \"name\"."
        },
        "396": {
            "condition": "When filtering by eye color",
            "operation": " join \"colour AS T2\" on T1.\"eye_colour_id\" = T2.\"id\" and filter where T2.\"colour\" = 'Blue' instead of directly filtering eye_color."
        },
        "397": {
            "condition": "When filtering by hair color",
            "operation": " join \"colour AS T3\" on T1.\"hair_colour_id\" = T3.\"id\" and filter where T3.\"colour\" = 'Brown' instead of directly filtering hair_color."
        },
        "398": {
            "condition": "When answering about superheroes with specific eye and hair colors, When filtering by eye color, When filtering by hair color, When combining tables for color matching",
            "operation": " perform inner joins using the exact key relationships T1.\"eye_colour_id\" = T2.\"id\" and T1.\"hair_colour_id\" = T3.\"id\" to ensure only matching pairs are kept."
        },
        "399": {
            "condition": "When answering about publisher names for specific superheroes",
            "operation": " select T2.publisher_name instead of publisher from the SELECT list."
        },
        "400": {
            "condition": "When combining superhero and publisher tables",
            "operation": " use superhero AS T1 INNER JOIN publisher AS T2 with join condition T1.publisher_id = T2.id."
        },
        "401": {
            "condition": "When answering about publisher names for specific superheroes, When combining superhero and publisher tables, When filtering by superhero names",
            "operation": " use T1.superhero_name instead of character_name in the WHERE clause with exact literals 'Hawkman', 'Karate Kid', and 'Speedy'."
        },
        "402": {
            "condition": "When counting superheroes",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific non-null identifiers."
        },
        "403": {
            "condition": "When relating superheroes to publishers",
            "operation": " join superhero AS T1 INNER JOIN publisher AS T2 using the condition T1.publisher_id = T2.id instead of querying only the superheroes table."
        },
        "404": {
            "condition": "When filtering for a specific publisher",
            "operation": " use T2.id = 1 instead of checking for null values to target the specific publisher."
        },
        "405": {
            "condition": "When counting superheroes, When relating superheroes to publishers, When filtering for a specific publisher, When answering about superheroes without a publisher",
            "operation": " the question actually means superheroes that do not have a publisher relationship established through the join condition."
        },
        "406": {
            "condition": "When calculating percentages of superheroes with specific eye colors",
            "operation": " join the color reference table using T1.eye_colour_id = T2.id to access color information instead of querying superheroes directly."
        },
        "407": {
            "condition": "When counting superheroes with blue eyes",
            "operation": " use COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) instead of COUNT(*) with a simple WHERE filter to handle conditional counting within the join context."
        },
        "408": {
            "condition": "When accessing eye color data",
            "operation": " reference T2.colour instead of non-existent columns like eye_color to correctly access color data from the joined table."
        },
        "409": {
            "condition": "When calculating percentage denominators",
            "operation": " use COUNT(T1.id) as the denominator instead of subqueries to ensure proper counting within the joined dataset."
        },
        "410": {
            "condition": "When calculating percentages of superheroes with specific eye colors, When counting superheroes with blue eyes, When accessing eye color data, When calculating percentage denominators, When computing percentage values",
            "operation": " cast the result to REAL instead of relying on integer division to get accurate percentage values with decimal precision."
        },
        "411": {
            "condition": "When the question asks for a ratio between male superheroes and female superheroes",
            "operation": " use a single query with an inner join between \"superhero\" table as T1 and \"gender\" table as T2 instead of separate subqueries."
        },
        "412": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.gender_id = T2.id exactly as shown in the amends and keep only matching pairs (inner match)."
        },
        "413": {
            "condition": "When counting male superheroes",
            "operation": " compute COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) using the exact tokens and literals."
        },
        "414": {
            "condition": "When counting female superheroes",
            "operation": " compute COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) using the exact tokens and literals."
        },
        "415": {
            "condition": "When calculating the ratio",
            "operation": " cast the male count to REAL before division to prevent integer division."
        },
        "416": {
            "condition": "When the question asks for a ratio between male superheroes and female superheroes, When combining T1 and T2 for shared entities, When counting male superheroes, When counting female superheroes, When calculating the ratio, When handling division",
            "operation": " guard against division by zero by ensuring the denominator (female count) is not zero."
        },
        "417": {
            "condition": "When the question asks about superheroes",
            "operation": " use table \"superhero\" instead of \"superheroes\"."
        },
        "418": {
            "condition": "When the question asks for a superhero's name",
            "operation": " use column \"superhero_name\" instead of \"name\"."
        },
        "419": {
            "condition": "When the question asks about height",
            "operation": " use column \"height_cm\" instead of \"height\"."
        },
        "420": {
            "condition": "When the question asks about superheroes, When the question asks for a superhero's name, When the question asks about height, When the question asks for the tallest superhero",
            "operation": " order by \"height_cm\" in descending direction and keep the first row."
        },
        "421": {
            "condition": "When the question asks for \"power ID\" of a specific power",
            "operation": " select the \"id\" column from the \"superpower\" table instead of \"power_name\"."
        },
        "422": {
            "condition": "When the question asks for \"power ID\" of a specific power, When filtering by power name in the \"superpower\" table",
            "operation": " use the exact literal 'Cryokinesis' (case-sensitive) with the \"power_name\" column instead of using 'cryokinesis' or filtering on \"power_id\"."
        },
        "423": {
            "condition": "When the question asks for superhero information",
            "operation": " use table \"superhero\" instead of \"superheroes\"."
        },
        "424": {
            "condition": "When selecting the superhero name",
            "operation": " use column \"superhero_name\" instead of \"name\"."
        },
        "425": {
            "condition": "When filtering by superhero ID",
            "operation": " use column \"id\" instead of \"superhero_id\"."
        },
        "426": {
            "condition": "When the question asks for superhero information, When selecting the superhero name, When filtering by superhero ID, When comparing numeric ID values",
            "operation": " use integer literal 294 without quotes instead of string literal '294'."
        },
        "427": {
            "condition": "When selecting superhero names",
            "operation": " use \"full_name\" instead of \"name\" and ensure the result contains only distinct values."
        },
        "428": {
            "condition": "When referring to the superhero table",
            "operation": " use \"superhero\" instead of \"superheroes\"."
        },
        "429": {
            "condition": "When filtering for missing weight",
            "operation": " check for both null values and zero values using \"weight_kg IS NULL OR weight_kg = 0\" instead of just \"weight IS NULL\"."
        },
        "430": {
            "condition": "When selecting superhero names, When referring to the superhero table, When filtering for missing weight, When outputting superhero names",
            "operation": " exclude null names by adding \"full_name IS NOT NULL\" as a filter condition."
        },
        "431": {
            "condition": "When the question asks for eye colour of a superhero",
            "operation": " select the colour value from the colour table (T2.colour) instead of from the superheroes table."
        },
        "432": {
            "condition": "When joining superhero and colour tables",
            "operation": " use an inner join where T1.eye_colour_id equals T2.id to link the tables correctly."
        },
        "433": {
            "condition": "When filtering by a specific superhero name",
            "operation": " use T1.full_name = 'Karen Beecher-Duncan' exactly as specified to identify the correct superhero."
        },
        "434": {
            "condition": "When the question asks for eye colour of a superhero, When joining superhero and colour tables, When filtering by a specific superhero name, When the schema uses normalized colour data",
            "operation": " always join to the colour table to retrieve colour information rather than using denormalized columns in the superhero table."
        },
        "435": {
            "condition": "When answering about \"superpowers of a superhero with a specific full name\"",
            "operation": " make sure the output order: T3.power_name."
        },
        "436": {
            "condition": "When the question mentions \"superpowers\"",
            "operation": " \"superpowers\" actually means \"power_name in superpower table\"."
        },
        "437": {
            "condition": "When combining T1 (superhero) and T2 (hero_power) for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and keep only matching pairs (inner match)."
        },
        "438": {
            "condition": "When combining T2 (hero_power) and T3 (superpower) for shared entities",
            "operation": " link rows where T2.power_id = T3.id and keep only matching pairs (inner match)."
        },
        "439": {
            "condition": "When answering about \"superpowers of a superhero with a specific full name\", When the question mentions \"superpowers\", When combining T1 (superhero) and T2 (hero_power) for shared entities, When combining T2 (hero_power) and T3 (superpower) for shared entities, When filtering for a specific superhero by full name",
            "operation": " use T1.full_name = 'Helen Parr' with exact case and spacing."
        },
        "440": {
            "condition": "When the question asks about superhero attributes",
            "operation": " use table \"superhero\" as T1 and table \"race\" as T2 with the join condition T1.race_id = T2.id to properly resolve race names."
        },
        "441": {
            "condition": "When the question mentions \"weighs 108kg\"",
            "operation": " use column T1.weight_kg = 108 to match the exact weight value with proper units."
        },
        "442": {
            "condition": "When the question mentions \"188cm tall\"",
            "operation": " use column T1.height_cm = 188 to match the exact height value with proper units."
        },
        "443": {
            "condition": "When the question asks about superhero attributes, When the question mentions \"weighs 108kg\", When the question mentions \"188cm tall\", When the question asks for \"race of the superhero\"",
            "operation": " use DISTINCT T2.race to eliminate duplicate race values while retrieving the race information."
        },
        "444": {
            "condition": "When the question asks for \"publisher name\" of a superhero",
            "operation": " use \"T2.publisher_name\" in the output instead of \"name\" to retrieve the publisher name rather than the superhero name."
        },
        "445": {
            "condition": "When combining superhero and publisher information",
            "operation": " add \"publisher AS T2\" as a join source and use INNER JOIN on \"T1.publisher_id = T2.id\" to link the tables correctly."
        },
        "446": {
            "condition": "When referring to the superhero table",
            "operation": " use \"superhero AS T1\" instead of \"superheroes\" for proper table naming."
        },
        "447": {
            "condition": "When the question asks for \"publisher name\" of a superhero, When combining superhero and publisher information, When referring to the superhero table, When filtering by superhero ID",
            "operation": " keep the condition \"WHERE T1.id = 38\" but apply it to the joined table structure instead of a single table."
        },
        "448": {
            "condition": "When answering about superhero race with maximum attribute value",
            "operation": " join table \"superhero\" as T1 with table \"hero_attribute\" as T2 where T1.id equals T2.hero_id to establish the relationship between superheroes and their attributes."
        },
        "449": {
            "condition": "When selecting race information",
            "operation": " join table \"race\" as T3 where T1.race_id equals T3.id to properly access race data through the relationship."
        },
        "450": {
            "condition": "When outputting the race",
            "operation": " select T3.race instead of just race to specify the correct source table."
        },
        "451": {
            "condition": "When ordering by attribute value",
            "operation": " use T2.attribute_value instead of attribute_value to reference the correct table column."
        },
        "452": {
            "condition": "When answering about superhero race with maximum attribute value, When selecting race information, When outputting the race, When ordering by attribute value, When finding the maximum attribute value",
            "operation": " order by T2.attribute_value in descending direction and keep only the first row."
        },
        "453": {
            "condition": "When the question asks about a superhero's alignment and superpowers",
            "operation": " use table aliases T4.alignment and T3.power_name instead of direct column references alignment and superpowers."
        },
        "454": {
            "condition": "When joining tables to get superhero information",
            "operation": " add INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id to connect superheroes to their powers."
        },
        "455": {
            "condition": "When retrieving power information",
            "operation": " add INNER JOIN superpower AS T3 ON T3.id = T2.power_id to get the actual power names."
        },
        "456": {
            "condition": "When retrieving alignment information",
            "operation": " add INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id instead of directly referencing the alignment column."
        },
        "457": {
            "condition": "When the question asks about a superhero's alignment and superpowers, When joining tables to get superhero information, When retrieving power information, When retrieving alignment information, When filtering by superhero name",
            "operation": " use T1.superhero_name in the WHERE clause instead of name to match the exact column name."
        },
        "458": {
            "condition": "When the question asks for \"full names of superheroes\"",
            "operation": " use the exact column token \"T1.superhero_name\" from the \"superhero\" table."
        },
        "459": {
            "condition": "When the question mentions \"blue eyes\"",
            "operation": " join \"superhero AS T1\" with \"colour AS T2\" using an inner match where \"T1.eye_colour_id = T2.id\" and filter for \"T2.colour = 'Blue'\" exactly."
        },
        "460": {
            "condition": "When the question asks for \"at least five\"",
            "operation": " return the first 5 rows that match the criteria."
        },
        "461": {
            "condition": "When the question asks for \"full names of superheroes\", When the question mentions \"blue eyes\", When the question asks for \"at least five\", When handling text literals",
            "operation": " use exact case sensitivity with 'Blue' instead of 'blue'."
        },
        "462": {
            "condition": "When the question asks for \"full names of superheroes\"",
            "operation": " use the exact column token \"T1.superhero_name\" instead of \"T1.full_name\" as it contains the correct superhero names."
        },
        "463": {
            "condition": "When filtering for superheroes with blue eyes",
            "operation": " use the exact literal value 'Blue' for the colour comparison."
        },
        "464": {
            "condition": "When the question asks for \"full names of superheroes\", When filtering for superheroes with blue eyes, When limiting results to \"at least five\"",
            "operation": " use a limit of 5 rows to return exactly five superhero names."
        },
        "465": {
            "condition": "When answering about \"average attribute value of all neutral superheroes\"",
            "operation": " make sure the output order: average of T1.attribute_value."
        },
        "466": {
            "condition": "When the question mentions \"neutral superheroes\"",
            "operation": " \"neutral\" actually means \"T3.alignment = 'Neutral'\" in schema."
        },
        "467": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.hero_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "468": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.alignment_id = T3.id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "469": {
            "condition": "When answering about \"average attribute value of all neutral superheroes\", When the question mentions \"neutral superheroes\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When referring to attribute values",
            "operation": " use T1.attribute_value instead of just attribute_value for explicit table qualification."
        },
        "470": {
            "condition": "When the question asks for \"skin colour of the superheroes\"",
            "operation": " use \"T2.colour\" from the colour table instead of direct column references."
        },
        "471": {
            "condition": "When filtering for superheroes with 100 attribute value",
            "operation": " use \"T3.attribute_value = 100\" from the hero_attribute table."
        },
        "472": {
            "condition": "When combining tables for superhero information",
            "operation": " link rows where \"T1.skin_colour_id = T2.id\" and \"T1.id = T3.hero_id\" using inner matches."
        },
        "473": {
            "condition": "When selecting color values",
            "operation": " use \"DISTINCT T2.colour\" to get unique color values."
        },
        "474": {
            "condition": "When the question asks for \"skin colour of the superheroes\", When filtering for superheroes with 100 attribute value, When combining tables for superhero information, When selecting color values, When answering about superhero attributes",
            "operation": " make sure to join through proper relational tables (superheroes as T1, colour as T2, hero_attribute as T3) instead of querying a single table."
        },
        "475": {
            "condition": "When counting superheroes",
            "operation": " use the canonical key T1.id instead of counting all columns."
        },
        "476": {
            "condition": "When filtering by alignment",
            "operation": " join table \"alignment\" as T2 using T1.alignment_id = T2.id and filter where T2.alignment = 'Good' (case-sensitive)."
        },
        "477": {
            "condition": "When filtering by gender",
            "operation": " join table \"gender\" as T3 using T1.gender_id = T3.id and filter where T3.gender = 'Female' (case-sensitive)."
        },
        "478": {
            "condition": "When counting superheroes, When filtering by alignment, When filtering by gender, When combining tables for filtering",
            "operation": " perform inner matches only, keeping only superheroes that have both alignment and gender records."
        },
        "479": {
            "condition": "When answering about superhero names with attribute values between 75 and 80",
            "operation": " make sure the output order: T1.superhero_name."
        },
        "480": {
            "condition": "When the question mentions \"superheroes\"",
            "operation": " \"superheroes\" actually means \"superhero\" table as T1 and \"hero_attribute\" table as T2 in schema."
        },
        "481": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "482": {
            "condition": "When answering about superhero names with attribute values between 75 and 80, When the question mentions \"superheroes\", When combining T1 and T2 for shared entities, When filtering attribute values between 75 and 80",
            "operation": " use the exact range condition BETWEEN 75 AND 80 instead of impossible conditions like >= 80 AND <= 75."
        },
        "483": {
            "condition": "When the question asks about race of a superhero",
            "operation": " join the race table (T3) using the superheroes table's race_id column to access the race value."
        },
        "484": {
            "condition": "When filtering by hair color",
            "operation": " join the colour table (T2) using the superheroes table's hair_colour_id column and filter on T2.colour = 'Blue' (exact case)."
        },
        "485": {
            "condition": "When filtering by gender",
            "operation": " join the gender table (T4) using the superheroes table's gender_id column and filter on T4.gender = 'Male' (exact case)."
        },
        "486": {
            "condition": "When the question asks about race of a superhero, When filtering by hair color, When filtering by gender, When selecting race information",
            "operation": " reference T3.race instead of just race to specify the table source."
        },
        "487": {
            "condition": "When answering about \"percentage of female superheroes among bad superheroes\"",
            "operation": " make sure the output order: percentage_female."
        },
        "488": {
            "condition": "When the question mentions \"bad superheroes\"",
            "operation": " \"bad\" actually means \"T2.alignment = 'Bad'\" in schema (note capital B)."
        },
        "489": {
            "condition": "When the question mentions \"female superheroes\"",
            "operation": " \"female\" actually means \"T3.gender = 'Female'\" in schema."
        },
        "490": {
            "condition": "When combining T1 (superhero) and T2 (alignment) for shared entities",
            "operation": " link rows where T1.alignment_id = T2.id and keep only matching pairs (inner match)."
        },
        "491": {
            "condition": "When combining T1 (superhero) and T3 (gender) for shared entities",
            "operation": " link rows where T1.gender_id = T3.id and keep only matching pairs (inner match)."
        },
        "492": {
            "condition": "When counting superheroes",
            "operation": " compute the number of rows using the canonical key token T1.id instead of counting all columns."
        },
        "493": {
            "condition": "When answering about \"percentage of female superheroes among bad superheroes\", When the question mentions \"bad superheroes\", When the question mentions \"female superheroes\", When combining T1 (superhero) and T2 (alignment) for shared entities, When combining T1 (superhero) and T3 (gender) for shared entities, When counting superheroes, When calculating percentage",
            "operation": " compute (count of rows where T3.gender = 'Female') divided by (count of all rows where T2.alignment = 'Bad'), cast to REAL and multiply by 100, guarding division by zero."
        },
        "494": {
            "condition": "When answering about superheroes with missing weight data",
            "operation": " filter rows where T1.weight_kg = 0 OR T1.weight_kg is NULL."
        },
        "495": {
            "condition": "When combining superhero and colour tables",
            "operation": " link rows where T1.eye_colour_id = T2.id using an inner match."
        },
        "496": {
            "condition": "When calculating the difference between blue-eyed and no-eye-color superheroes",
            "operation": " compute SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END)."
        },
        "497": {
            "condition": "When handling eye color identifiers",
            "operation": " use T2.id = 7 for blue eyes and T2.id = 1 for no eye color (null)."
        },
        "498": {
            "condition": "When answering about superheroes with missing weight data, When combining superhero and colour tables, When calculating the difference between blue-eyed and no-eye-color superheroes, When handling eye color identifiers, When referencing columns",
            "operation": " use exact tokens T1.weight_kg and T1.eye_colour_id as shown in the schema."
        },
        "499": {
            "condition": "When answering about \"How strong is the Hulk?\"",
            "operation": " make sure the output order: T2.attribute_value"
        },
        "500": {
            "condition": "When the question mentions \"Hulk\"",
            "operation": " \"Hulk\" actually means \"T1.superhero_name = 'Hulk'\" in schema"
        },
        "501": {
            "condition": "When the question mentions \"strength\"",
            "operation": " \"strength\" actually means \"T3.attribute_name = 'Strength'\" in schema"
        },
        "502": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "503": {
            "condition": "When answering about \"How strong is the Hulk?\", When the question mentions \"Hulk\", When the question mentions \"strength\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.attribute_id = T3.id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "504": {
            "condition": "When answering about \"Ajax's superpowers\"",
            "operation": " make sure the output order: T3.power_name."
        },
        "505": {
            "condition": "When the question mentions \"Ajax\"",
            "operation": " \"Ajax\" actually means \"T1.superhero_name = 'Ajax'\" in schema."
        },
        "506": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match)."
        },
        "507": {
            "condition": "When answering about \"Ajax's superpowers\", When the question mentions \"Ajax\", When combining T1, T2, and T3 for shared entities, When selecting output columns",
            "operation": " use only T3.power_name instead of all columns."
        },
        "508": {
            "condition": "When counting entities in the superhero universe",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count specific entities."
        },
        "509": {
            "condition": "When the question mentions \"villains\"",
            "operation": " \"villains\" actually means superheroes with T2.alignment = 'Bad' in the schema."
        },
        "510": {
            "condition": "When the question mentions \"green-skinned\"",
            "operation": " \"green-skinned\" actually means T3.colour = 'Green' in the schema."
        },
        "511": {
            "condition": "When combining tables for superhero data",
            "operation": " link rows using T1.alignment_id = T2.id to connect to alignment data and T1.skin_colour_id = T3.id to connect to color data, keeping only matching pairs (inner match)."
        },
        "512": {
            "condition": "When counting entities in the superhero universe, When the question mentions \"villains\", When the question mentions \"green-skinned\", When combining tables for superhero data, When answering about \"how many green-skinned villains\"",
            "operation": " make sure to filter for both T2.alignment = 'Bad' and T3.colour = 'Green' conditions."
        },
        "513": {
            "condition": "When answering about \"female superheroes in Marvel Comics\"",
            "operation": " make sure the output order: count of superheroes"
        },
        "514": {
            "condition": "When the question mentions \"female\"",
            "operation": " \"female\" actually means \"T3.gender = 'Female'\" in schema"
        },
        "515": {
            "condition": "When the question mentions \"Marvel Comics\"",
            "operation": " \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema"
        },
        "516": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match)"
        },
        "517": {
            "condition": "When combining T1 and T3 for shared entities",
            "operation": " link rows where T1.gender_id = T3.id; keep only matching pairs (inner match)"
        },
        "518": {
            "condition": "When the question asks for \"count of superheroes\"",
            "operation": " compute the number of rows using the canonical key token T1.id"
        },
        "519": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "520": {
            "condition": "When answering about \"female superheroes in Marvel Comics\", When the question mentions \"female\", When the question mentions \"Marvel Comics\", When combining T1 and T2 for shared entities, When combining T1 and T3 for shared entities, When the question asks for \"count of superheroes\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exactly 'Female' and 'Marvel Comics'"
        },
        "521": {
            "condition": "When answering about superheroes who can control wind",
            "operation": " use T1.superhero_name instead of name in the output."
        },
        "522": {
            "condition": "When the question mentions \"control wind\"",
            "operation": " this actually means T3.power_name = 'Wind Control' in the schema."
        },
        "523": {
            "condition": "When combining tables for superhero powers",
            "operation": " link T1 and T2 where T1.id = T2.hero_id, and link T2 and T3 where T2.power_id = T3.id, keeping only matching pairs (inner match)."
        },
        "524": {
            "condition": "When answering about superheroes who can control wind, When the question mentions \"control wind\", When combining tables for superhero powers, When listing names in alphabetical order",
            "operation": " order the results by T1.superhero_name in ascending order."
        },
        "525": {
            "condition": "When answering about superhero gender with a specific ability",
            "operation": " join superhero as T1, hero_power as T2, superpower as T3, and gender as T4 using the exact relationships shown."
        },
        "526": {
            "condition": "When the question mentions \"ability of Phoenix Force\"",
            "operation": " filter on T3.power_name = 'Phoenix Force' exactly as written."
        },
        "527": {
            "condition": "When selecting gender information",
            "operation": " use T4.gender from the joined gender table instead of directly from superhero."
        },
        "528": {
            "condition": "When combining tables",
            "operation": " use inner joins with T1.id = T2.hero_id and T2.power_id = T3.id and T1.gender_id = T4.id to ensure proper relationship matching."
        },
        "529": {
            "condition": "When answering about superhero gender with a specific ability, When the question mentions \"ability of Phoenix Force\", When selecting gender information, When combining tables, When the schema shows gender values as 'Male', 'Female', 'N/A'",
            "operation": " preserve these exact literal values in output."
        },
        "530": {
            "condition": "When the question asks about superhero weight",
            "operation": " use \"T1.weight_kg\" instead of \"weight\" to represent weight in kilograms."
        },
        "531": {
            "condition": "When the question asks for superhero name",
            "operation": " use \"T1.superhero_name\" instead of \"name\" as the identifier."
        },
        "532": {
            "condition": "When combining superhero and publisher information",
            "operation": " join \"superhero\" as T1 with \"publisher\" as T2 where \"T1.publisher_id = T2.id\" to link superheroes to their publishers."
        },
        "533": {
            "condition": "When filtering for DC Comics superheroes",
            "operation": " use the exact literal \"DC Comics\" with \"T2.publisher_name = 'DC Comics'\" instead of \"Marvel\"."
        },
        "534": {
            "condition": "When the question asks about superhero weight, When the question asks for superhero name, When combining superhero and publisher information, When filtering for DC Comics superheroes, When finding the heaviest superhero",
            "operation": " order results by \"T1.weight_kg\" in descending order and take the first row."
        },
        "535": {
            "condition": "When answering about \"the heaviest superhero in DC Comics\"",
            "operation": " make sure the output order: only include superhero_name, not weight_kg."
        },
        "536": {
            "condition": "When combining superhero (T1) and publisher (T2) tables",
            "operation": " link rows where T1.publisher_id = T2.id exactly as shown and keep only matching pairs (inner match)."
        },
        "537": {
            "condition": "When filtering for DC Comics",
            "operation": " use the exact literal 'DC Comics' for T2.publisher_name with the exact case and spacing."
        },
        "538": {
            "condition": "When ordering by weight",
            "operation": " sort by T1.weight_kg in descending order to find the heaviest."
        },
        "539": {
            "condition": "When answering about \"the heaviest superhero in DC Comics\", When combining superhero (T1) and publisher (T2) tables, When filtering for DC Comics, When ordering by weight, When selecting the top result",
            "operation": " keep only the first row after ordering to get the single heaviest superhero."
        },
        "540": {
            "condition": "When answering about \"average height of a non-human superhero in Dark Horse Comics\"",
            "operation": " make sure the output order: AVG(T1.height_cm)."
        },
        "541": {
            "condition": "When the question mentions \"Dark Horse Comics\"",
            "operation": " \"Dark Horse Comics\" actually means \"T2.publisher_name = 'Dark Horse Comics'\" in schema."
        },
        "542": {
            "condition": "When the question mentions \"non-human\"",
            "operation": " \"non-human\" actually means \"T3.race != 'Human'\" in schema."
        },
        "543": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match)."
        },
        "544": {
            "condition": "When combining T1 and T3 for shared entities",
            "operation": " link rows where T1.race_id = T3.id; keep only matching pairs (inner match)."
        },
        "545": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "546": {
            "condition": "When answering about \"average height of a non-human superhero in Dark Horse Comics\", When the question mentions \"Dark Horse Comics\", When the question mentions \"non-human\", When combining T1 and T2 for shared entities, When combining T1 and T3 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Dark Horse Comics' or 'Human'."
        },
        "547": {
            "condition": "When answering about \"fastest superheroes\"",
            "operation": " make sure the output order: COUNT(T3.superhero_name)."
        },
        "548": {
            "condition": "When the question mentions \"fastest superheroes\"",
            "operation": " use the exact literal 'Speed' for T2.attribute_name and the exact value 100 for T1.attribute_value."
        },
        "549": {
            "condition": "When combining tables for superhero attributes",
            "operation": " link rows using T1.attribute_id = T2.id and T1.hero_id = T3.id with inner matches only."
        },
        "550": {
            "condition": "When counting superheroes",
            "operation": " count using the canonical key T3.superhero_name instead of counting all rows."
        },
        "551": {
            "condition": "When answering about \"fastest superheroes\", When the question mentions \"fastest superheroes\", When combining tables for superhero attributes, When counting superheroes, When filtering by speed attribute",
            "operation": " use exact equality T2.attribute_name = 'Speed' and T1.attribute_value = 100 instead of finding maximum values through subqueries."
        },
        "552": {
            "condition": "When the question asks for the difference in superhero counts between DC and Marvel Comics",
            "operation": " use SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) as the single output expression."
        },
        "553": {
            "condition": "When combining superheroes and publisher tables",
            "operation": " link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match)."
        },
        "554": {
            "condition": "When handling publisher names",
            "operation": " use exact literals 'DC Comics' and 'Marvel Comics' with correct case and spacing."
        },
        "555": {
            "condition": "When calculating counts",
            "operation": " do not use GROUP BY or WHERE filtering since conditional aggregation handles the calculation in a single row."
        },
        "556": {
            "condition": "When the question asks for the difference in superhero counts between DC and Marvel Comics, When combining superheroes and publisher tables, When handling publisher names, When calculating counts, When producing output",
            "operation": " return only the scalar difference value without publisher names, counts, or ordering clauses."
        },
        "557": {
            "condition": "When answering about \"the weakest attribute of the Black Panther\"",
            "operation": " make sure the output order: T3.attribute_name."
        },
        "558": {
            "condition": "When the question mentions \"Black Panther\"",
            "operation": " \"Black Panther\" actually means \"T1.superhero_name = 'Black Panther'\" in schema."
        },
        "559": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id and T2.attribute_id = T3.id; keep only matching pairs (inner match)."
        },
        "560": {
            "condition": "When answering about \"the weakest attribute of the Black Panther\", When the question mentions \"Black Panther\", When combining T1, T2, and T3 for shared entities, When the question asks for \"weakest\" (lowest value attribute)",
            "operation": " rank rows by T2.attribute_value in ascending order and keep the first 1 row."
        },
        "561": {
            "condition": "When the question asks about eye colour for a specific character",
            "operation": " use the exact literal 'Abomination' to filter by superhero_name in the superhero table (T1)."
        },
        "562": {
            "condition": "When retrieving eye colour information",
            "operation": " select the colour column from the colour table (T2) instead of directly from the characters table."
        },
        "563": {
            "condition": "When combining superhero and colour tables",
            "operation": " link rows where T1.eye_colour_id equals T2.id using an inner join to ensure proper table relationships."
        },
        "564": {
            "condition": "When the question asks about eye colour for a specific character, When retrieving eye colour information, When combining superhero and colour tables, When filtering by character name",
            "operation": " use T1.superhero_name = 'Abomination' instead of name = 'Abomination' to match the correct column name from the proper table."
        },
        "565": {
            "condition": "When the question asks for \"name\" of a superhero",
            "operation": " use the exact column token \"superhero_name\" from table \"superhero\" instead of \"name\"."
        },
        "566": {
            "condition": "When the question asks about \"tallest\" superhero",
            "operation": " order by \"height_cm\" in descending order to get the maximum height value."
        },
        "567": {
            "condition": "When the question asks for \"name\" of a superhero, When the question asks about \"tallest\" superhero, When retrieving a single result for \"the tallest\"",
            "operation": " take only the first row after ordering by height in descending order."
        },
        "568": {
            "condition": "When the question asks about a superhero's name given their real name",
            "operation": " use the exact table name \"superhero\" (not \"superheroes\") and select the column \"superhero_name\"."
        },
        "569": {
            "condition": "When the question asks about a superhero's name given their real name, When filtering by the real name \"Charles Chandler\"",
            "operation": " use the column \"full_name\" (not \"real_name\") with the exact literal value 'Charles Chandler' (preserving case and spacing)."
        },
        "570": {
            "condition": "When answering about superheroes created by George Lucas",
            "operation": " use table aliases T1 for superheroes, T2 for publisher, and T3 for gender."
        },
        "571": {
            "condition": "When combining superheroes with publisher information",
            "operation": " link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match)."
        },
        "572": {
            "condition": "When combining superheroes with gender information",
            "operation": " link rows where T1.gender_id = T3.id and keep only matching pairs (inner match)."
        },
        "573": {
            "condition": "When filtering for George Lucas as creator",
            "operation": " use T2.publisher_name = 'George Lucas' instead of creator column."
        },
        "574": {
            "condition": "When counting female superheroes",
            "operation": " use COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) with explicit ELSE NULL clause."
        },
        "575": {
            "condition": "When calculating the denominator for percentage",
            "operation": " use COUNT(T1.id) instead of COUNT(*) to count superhero entities."
        },
        "576": {
            "condition": "When computing percentage",
            "operation": " multiply by 100.0 and cast to REAL data type."
        },
        "577": {
            "condition": "When answering about superheroes created by George Lucas, When combining superheroes with publisher information, When combining superheroes with gender information, When filtering for George Lucas as creator, When counting female superheroes, When calculating the denominator for percentage, When computing percentage, When producing output",
            "operation": " do not include column aliases in the final result."
        },
        "578": {
            "condition": "When the question mentions \"Marvel Comics\"",
            "operation": " use \"T2.publisher_name = 'Marvel Comics'\" instead of direct publisher column references."
        },
        "579": {
            "condition": "When the question mentions \"good\" alignment",
            "operation": " use \"T3.alignment = 'Good'\" with exact case sensitivity."
        },
        "580": {
            "condition": "When combining superheroes with publisher and alignment tables",
            "operation": " link rows where T1.publisher_id = T2.id and T1.alignment_id = T3.id, keeping only matching pairs (inner match)."
        },
        "581": {
            "condition": "When calculating percentage of good superheroes",
            "operation": " compute (COUNT(CASE WHEN T3.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(T1.id)) to ensure real number division."
        },
        "582": {
            "condition": "When the question mentions \"Marvel Comics\", When the question mentions \"good\" alignment, When combining superheroes with publisher and alignment tables, When calculating percentage of good superheroes, When counting superheroes",
            "operation": " use T1.id as the canonical counting key instead of counting all columns."
        },
        "583": {
            "condition": "When counting superhero entries",
            "operation": " use the \"id\" column from the \"superhero\" table instead of counting all columns with *."
        },
        "584": {
            "condition": "When filtering for superheroes with John as their first name",
            "operation": " use the \"full_name\" column from the \"superhero\" table with a LIKE condition matching 'John%' instead of using a \"name\" column."
        },
        "585": {
            "condition": "When counting superhero entries, When filtering for superheroes with John as their first name, When referencing the superhero table",
            "operation": " use the exact table name \"superhero\" instead of \"superheroes\"."
        },
        "586": {
            "condition": "When answering about \"the hero ID of superhero with the lowest attribute value\"",
            "operation": " make sure to query from the \"hero_attribute\" table instead of the \"superheroes\" table."
        },
        "587": {
            "condition": "When finding the minimum attribute value",
            "operation": " use a subquery with MIN(attribute_value) instead of ORDER BY attribute_value DESC LIMIT 1."
        },
        "588": {
            "condition": "When filtering for the hero with the minimum attribute value",
            "operation": " use attribute_value = (subquery) instead of selecting the maximum value."
        },
        "589": {
            "condition": "When answering about \"the hero ID of superhero with the lowest attribute value\", When finding the minimum attribute value, When filtering for the hero with the minimum attribute value, When constructing the final query",
            "operation": " remove the ORDER BY and LIMIT clauses instead of keeping them."
        },
        "590": {
            "condition": "When the question asks for \"full name\" of a superhero",
            "operation": " use the exact column token \"full_name\" from table \"superhero\"."
        },
        "591": {
            "condition": "When the question specifies a superhero named \"Alien\"",
            "operation": " use the exact literal value 'Alien' for matching."
        },
        "592": {
            "condition": "When the question asks for \"full name\" of a superhero, When the question specifies a superhero named \"Alien\", When referencing the superhero table",
            "operation": " use the exact table name \"superhero\" (not \"superheroes\")."
        },
        "593": {
            "condition": "When answering about superheroes with weight less than 100 and brown eyes",
            "operation": " use table alias T1 for superhero table and T2 for colour table."
        },
        "594": {
            "condition": "When joining superhero and colour tables",
            "operation": " link rows where T1.eye_colour_id = T2.id and keep only matching pairs (inner match)."
        },
        "595": {
            "condition": "When filtering by weight",
            "operation": " use T1.weight_kg < 100 instead of weight < 100."
        },
        "596": {
            "condition": "When filtering by eye color",
            "operation": " use T2.colour = 'Brown' instead of eye_color = 'brown'."
        },
        "597": {
            "condition": "When answering about superheroes with weight less than 100 and brown eyes, When joining superhero and colour tables, When filtering by weight, When filtering by eye color, When selecting output",
            "operation": " use T1.full_name as the output column with proper table qualification."
        },
        "598": {
            "condition": "When answering about \"attribute value of the superhero named Aquababy\"",
            "operation": " make sure the output order: T2.attribute_value."
        },
        "599": {
            "condition": "When the question mentions \"superhero named Aquababy\"",
            "operation": " \"Aquababy\" actually means T1.superhero_name = 'Aquababy' in schema."
        },
        "600": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "601": {
            "condition": "When answering about \"attribute value of the superhero named Aquababy\", When the question mentions \"superhero named Aquababy\", When combining T1 and T2 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "602": {
            "condition": "When the question asks about superhero information",
            "operation": " use table \"superhero\" as T1 instead of \"superheroes\"."
        },
        "603": {
            "condition": "When the question mentions \"superhero ID\"",
            "operation": " use column T1.id instead of superhero_id."
        },
        "604": {
            "condition": "When the question asks for weight",
            "operation": " select T1.weight_kg as the exact column."
        },
        "605": {
            "condition": "When the question asks for race",
            "operation": " select T2.race from table \"race\" as T2."
        },
        "606": {
            "condition": "When combining superhero and race information",
            "operation": " link rows where T1.race_id = T2.id using an inner match."
        },
        "607": {
            "condition": "When the question asks about superhero information, When the question mentions \"superhero ID\", When the question asks for weight, When the question asks for race, When combining superhero and race information, When filtering by superhero ID 40",
            "operation": " use condition T1.id = 40 with the exact literal value."
        },
        "608": {
            "condition": "When answering about \"average height of all neutral superheroes\"",
            "operation": " make sure the output order: average height."
        },
        "609": {
            "condition": "When the question mentions \"neutral superheroes\"",
            "operation": " \"neutral\" actually means \"T2.alignment = 'Neutral'\" in schema."
        },
        "610": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.alignment_id = T2.id; keep only matching pairs (inner match)."
        },
        "611": {
            "condition": "When calculating average height",
            "operation": " aggregate T1.height_cm instead of height."
        },
        "612": {
            "condition": "When answering about \"average height of all neutral superheroes\", When the question mentions \"neutral superheroes\", When combining T1 and T2 for shared entities, When calculating average height, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "613": {
            "condition": "When answering about superheroes with intelligence as their power",
            "operation": " use table \"hero_power\" as T1 and table \"superpower\" as T2 instead of just \"superheroes\"."
        },
        "614": {
            "condition": "When combining hero_power and superpower tables",
            "operation": " link rows where T1.power_id = T2.id and keep only matching pairs (inner match)."
        },
        "615": {
            "condition": "When filtering for intelligence power",
            "operation": " use T2.power_name = 'Intelligence' instead of filtering directly on a power column in the hero_power table."
        },
        "616": {
            "condition": "When selecting hero IDs",
            "operation": " use T1.hero_id to explicitly specify the table alias."
        },
        "617": {
            "condition": "When answering about superheroes with intelligence as their power, When combining hero_power and superpower tables, When filtering for intelligence power, When selecting hero IDs, When the question mentions \"intelligence\" as a power",
            "operation": " \"intelligence\" actually means \"Intelligence\" in the superpower table's power_name column (note the capital 'I')."
        },
        "618": {
            "condition": "When the question asks for eye colour of a character",
            "operation": " use the colour table (T2) instead of the superhero table (T1) for the eye colour value."
        },
        "619": {
            "condition": "When joining superhero table (T1) with colour table (T2)",
            "operation": " link rows where T1.eye_colour_id equals T2.id using an inner match."
        },
        "620": {
            "condition": "When filtering for a specific character name",
            "operation": " use T1.superhero_name = 'Blackwulf' with exact case and spelling."
        },
        "621": {
            "condition": "When the question asks for eye colour of a character, When joining superhero table (T1) with colour table (T2), When filtering for a specific character name, When selecting the eye colour output",
            "operation": " return T2.colour as the result."
        },
        "622": {
            "condition": "When answering about \"power of superheroes\"",
            "operation": " make sure the output order: T3.power_name"
        },
        "623": {
            "condition": "When the question mentions \"power\"",
            "operation": " \"power\" actually means \"T3.power_name\" in schema"
        },
        "624": {
            "condition": "When combining tables for superhero powers",
            "operation": " link rows where T1.id = T2.hero_id and T2.power_id = T3.id; keep only matching pairs (inner match)"
        },
        "625": {
            "condition": "When filtering by height greater than 80% of average",
            "operation": " use T1.height_cm * 100 > (SELECT AVG(height_cm) FROM superhero) * 80"
        },
        "626": {
            "condition": "When computing average height",
            "operation": " use AVG(height_cm) from the superhero table"
        },
        "627": {
            "condition": "When answering about \"power of superheroes\", When the question mentions \"power\", When combining tables for superhero powers, When filtering by height greater than 80% of average, When computing average height, When handling height comparison",
            "operation": " multiply T1.height_cm by 100 and compare to average multiplied by 80 to achieve the 80% threshold"
        }
    },
    "formula_1": {
        "0": {
            "condition": "When answering about \"drivers eliminated in the first period\"",
            "operation": " use \"T2.driverRef\" instead of \"driver_name\" for the reference names."
        },
        "1": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows where \"T2.driverId = T1.driverId\" and keep only matching pairs (inner match)."
        },
        "2": {
            "condition": "When filtering for race number 20",
            "operation": " use \"T1.raceId = 20\" instead of \"race_id = 20\"."
        },
        "3": {
            "condition": "When the question mentions \"first period\" and the amends show ordering by qualifying time",
            "operation": " rank drivers by \"T1.q1 DESC\" and keep the top 5 rows."
        },
        "4": {
            "condition": "When answering about \"drivers eliminated in the first period\", When combining qualifying and drivers tables, When filtering for race number 20, When the question mentions \"first period\" and the amends show ordering by qualifying time, When the amends specify output ordering",
            "operation": " order results by \"T1.q1 DESC\" and limit to 5 rows."
        },
        "5": {
            "condition": "When answering about driver surnames from qualifying data",
            "operation": " combine qualifying table as T1 and drivers table as T2 using inner match where T2.driverId = T1.driverId."
        },
        "6": {
            "condition": "When the question mentions \"race number 19\"",
            "operation": " filter on T1.raceId = 19 instead of race_number."
        },
        "7": {
            "condition": "When the question asks for the best lap time in the second qualifying period",
            "operation": " order by T1.q2 ASC to find the fastest time."
        },
        "8": {
            "condition": "When selecting the driver surname",
            "operation": " use T2.surname with table qualification."
        },
        "9": {
            "condition": "When answering about driver surnames from qualifying data, When the question mentions \"race number 19\", When the question asks for the best lap time in the second qualifying period, When selecting the driver surname, When the question specifies the second qualifying period",
            "operation": " do not filter on qualifying_period = 2 as the timing data is already in T1.q2."
        },
        "10": {
            "condition": "When answering about races held on circuits in Shanghai",
            "operation": " join tables circuits AS T1 and races AS T2 using T2.circuitID = T1.circuitId to link race information with circuit details."
        },
        "11": {
            "condition": "When filtering for Shanghai circuits",
            "operation": " use T1.location = 'Shanghai' instead of circuit_name since the location attribute is in the circuits table."
        },
        "12": {
            "condition": "When selecting the year information",
            "operation": " use T2.year with table alias qualification instead of unqualified year to specify the source table."
        },
        "13": {
            "condition": "When answering about races held on circuits in Shanghai, When filtering for Shanghai circuits, When selecting the year information, When combining circuits and races tables",
            "operation": " perform an inner join to keep only matching pairs where circuit IDs are equal between both tables."
        },
        "14": {
            "condition": "When answering about \"where to find introduction of races\"",
            "operation": " make sure the output column is T1.url instead of introduction."
        },
        "15": {
            "condition": "When the question mentions \"races held on Circuit de Barcelona-Catalunya\"",
            "operation": " this requires joining circuits AS T1 with races AS T2 using the condition T2.circuitID = T1.circuitId."
        },
        "16": {
            "condition": "When filtering for a specific circuit",
            "operation": " use T1.name = 'Circuit de Barcelona-Catalunya' exactly as specified."
        },
        "17": {
            "condition": "When retrieving URLs from the circuits table",
            "operation": " ensure DISTINCT is applied to avoid duplicate results."
        },
        "18": {
            "condition": "When answering about \"where to find introduction of races\", When the question mentions \"races held on Circuit de Barcelona-Catalunya\", When filtering for a specific circuit, When retrieving URLs from the circuits table, When combining tables for shared entities",
            "operation": " perform an inner join where T2.circuitID equals T1.circuitId to keep only matching pairs."
        },
        "19": {
            "condition": "When the question asks for race names held on circuits in Germany",
            "operation": " use DISTINCT T2.name to eliminate duplicate circuit names."
        },
        "20": {
            "condition": "When combining circuits and races tables",
            "operation": " join circuits AS T1 with races AS T2 using the condition T2.circuitID = T1.circuitId to establish the correct table relationship."
        },
        "21": {
            "condition": "When filtering for circuits in Germany",
            "operation": " use T1.country = 'Germany' to reference the correct table's country column."
        },
        "22": {
            "condition": "When the question asks for race names held on circuits in Germany, When combining circuits and races tables, When filtering for circuits in Germany, When answering about race names on circuits in Germany",
            "operation": " make sure the output order is T2.name."
        },
        "23": {
            "condition": "When answering about \"positions of circuits built by constructor Renault\"",
            "operation": " make sure the output order: T1.position."
        },
        "24": {
            "condition": "When the question mentions \"circuits built by constructor Renault\"",
            "operation": " this actually means \"positions from constructorStandings table (T1) joined with constructors table (T2) where T2.name = 'Renault'\"."
        },
        "25": {
            "condition": "When combining T1 (constructorStandings) and T2 (constructors) for shared entities",
            "operation": " link rows where T2.constructorId = T1.constructorId and keep only matching pairs (inner match)."
        },
        "26": {
            "condition": "When filtering for constructor Renault",
            "operation": " use exact literal value 'Renault' for T2.name."
        },
        "27": {
            "condition": "When answering about \"positions of circuits built by constructor Renault\", When the question mentions \"circuits built by constructor Renault\", When combining T1 (constructorStandings) and T2 (constructors) for shared entities, When filtering for constructor Renault, When retrieving positions",
            "operation": " use DISTINCT T1.position to eliminate duplicate results."
        },
        "28": {
            "condition": "When answering about races in a specific year",
            "operation": " filter races using T3.year = 2010."
        },
        "29": {
            "condition": "When combining circuits and races tables",
            "operation": " link rows where T3.circuitID = T1.circuitId using an inner match."
        },
        "30": {
            "condition": "When counting races",
            "operation": " count using T3.raceId as the canonical key instead of counting all rows."
        },
        "31": {
            "condition": "When the question mentions \"outside Asia and Europe\"",
            "operation": " filter circuits using T1.country NOT IN a specific country list representing Asian and European countries."
        },
        "32": {
            "condition": "When answering about races in a specific year, When combining circuits and races tables, When counting races, When the question mentions \"outside Asia and Europe\", When choosing the primary table",
            "operation": " use circuits AS T1 as the base table instead of races."
        },
        "33": {
            "condition": "When joining tables circuits and races",
            "operation": " use T1.circuitID = T3.circuitID for the join condition instead of circuitId to match the exact column name."
        },
        "34": {
            "condition": "When filtering for races outside Asia and Europe in 2010",
            "operation": " use the exact country values 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' in the NOT IN clause."
        },
        "35": {
            "condition": "When ordering WHERE clause conditions",
            "operation": " place the country filter before the year filter instead of the original order."
        },
        "36": {
            "condition": "When joining tables circuits and races, When filtering for races outside Asia and Europe in 2010, When ordering WHERE clause conditions, When counting races",
            "operation": " use T3.raceId as the counting key for the number of races."
        },
        "37": {
            "condition": "When answering about \"races held on circuits in Spain\"",
            "operation": " make sure the output order: T2.name."
        },
        "38": {
            "condition": "When the question mentions \"circuits in Spain\"",
            "operation": " \"Spain\" actually means T1.country = 'Spain' in schema."
        },
        "39": {
            "condition": "When combining T1 (circuits) and T2 (races) for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "40": {
            "condition": "When the question asks for \"names of the races\"",
            "operation": " return distinct values of T2.name to avoid duplicates."
        },
        "41": {
            "condition": "When answering about \"races held on circuits in Spain\", When the question mentions \"circuits in Spain\", When combining T1 (circuits) and T2 (races) for shared entities, When the question asks for \"names of the races\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T2.circuitID and T1.circuitId."
        },
        "42": {
            "condition": "When answering about coordinates location of circuits for Australian grand prix",
            "operation": " make sure the output order: T1.lat, T1.lng"
        },
        "43": {
            "condition": "When the question mentions \"Australian grand prix\"",
            "operation": " \"Australian grand prix\" actually means T2.name = 'Australian Grand Prix' in schema"
        },
        "44": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "45": {
            "condition": "When selecting coordinate columns",
            "operation": " use T1.lat and T1.lng with table aliases instead of latitude and longitude without aliases"
        },
        "46": {
            "condition": "When answering about coordinates location of circuits for Australian grand prix, When the question mentions \"Australian grand prix\", When combining T1 and T2 for shared entities, When selecting coordinate columns, When eliminating duplicate rows",
            "operation": " use DISTINCT to ensure each circuit appears only once in results"
        },
        "47": {
            "condition": "When answering about races held on a specific circuit",
            "operation": " make sure the output order: T1.url"
        },
        "48": {
            "condition": "When the question mentions \"races held on Sepang International Circuit\"",
            "operation": " \"Sepang International Circuit\" actually means T1.name = 'Sepang International Circuit' in schema"
        },
        "49": {
            "condition": "When combining circuits AS T1 and races AS T2 for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "50": {
            "condition": "When retrieving information about races",
            "operation": " use DISTINCT T1.url instead of selecting all columns to avoid duplicate URLs"
        },
        "51": {
            "condition": "When filtering by circuit name",
            "operation": " use exact literal 'Sepang International Circuit' with correct case and spacing, not 'Monza Circuit'"
        },
        "52": {
            "condition": "When answering about races held on a specific circuit, When the question mentions \"races held on Sepang International Circuit\", When combining circuits AS T1 and races AS T2 for shared entities, When retrieving information about races, When filtering by circuit name, When the question asks about races on a specific circuit",
            "operation": " do not include date filters like '%-09-%' unless explicitly requested"
        },
        "53": {
            "condition": "When answering about race times at Sepang International Circuit",
            "operation": " make sure the output order: T2.time"
        },
        "54": {
            "condition": "When the question mentions \"time of the races\"",
            "operation": " \"time\" actually means \"T2.time in schema\""
        },
        "55": {
            "condition": "When the question mentions \"Sepang International Circuit\"",
            "operation": " \"Sepang International Circuit\" actually means \"T1.name = 'Sepang International Circuit' in schema\""
        },
        "56": {
            "condition": "When combining circuits table T1 and races table T2",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "57": {
            "condition": "When listing race times",
            "operation": " return distinct values of T2.time to avoid duplicate times"
        },
        "58": {
            "condition": "When answering about race times at Sepang International Circuit, When the question mentions \"time of the races\", When the question mentions \"Sepang International Circuit\", When combining circuits table T1 and races table T2, When listing race times, When filtering by circuit name",
            "operation": " do not include month filters as they are unnecessary for this question"
        },
        "59": {
            "condition": "When answering about coordinate position for a Grand Prix",
            "operation": " make sure the output order: T1.lat, T1.lng."
        },
        "60": {
            "condition": "When the question mentions \"Abu Dhabi Grand Prix\"",
            "operation": " \"Abu Dhabi Grand Prix\" actually means T2.name = 'Abu Dhabi Grand Prix' in schema."
        },
        "61": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "62": {
            "condition": "When answering about coordinate position for a Grand Prix, When the question mentions \"Abu Dhabi Grand Prix\", When combining T1 and T2 for shared entities, When selecting coordinate columns",
            "operation": " use DISTINCT T1.lat, T1.lng instead of latitude, longitude to select specific columns with deduplication."
        },
        "63": {
            "condition": "When the question asks about a constructor's country in a specific race",
            "operation": " use the \"nationality\" column from the \"constructors\" table (T2) instead of \"country\"."
        },
        "64": {
            "condition": "When combining race results and constructor information",
            "operation": " join \"constructorResults\" as T1 with \"constructors\" as T2 using T2.constructorId = T1.constructorId with an inner match."
        },
        "65": {
            "condition": "When filtering for race number 24",
            "operation": " use T1.raceId = 24 instead of race_id."
        },
        "66": {
            "condition": "When filtering for 1 point",
            "operation": " use T1.points = 1 instead of filtering on the constructors table's points column."
        },
        "67": {
            "condition": "When the question asks about a constructor's country in a specific race, When combining race results and constructor information, When filtering for race number 24, When filtering for 1 point, When selecting output",
            "operation": " return T2.nationality as the country information."
        },
        "68": {
            "condition": "When answering about qualifying results",
            "operation": " select the exact column \"q1\" from table \"qualifying\" (aliased as T1) instead of \"q1_result\"."
        },
        "69": {
            "condition": "When the question mentions a driver by name \"Bruno Senna\"",
            "operation": " use separate conditions \"T2.forename = 'Bruno'\" and \"T2.surname = 'Senna'\" instead of a single driver_name filter."
        },
        "70": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows where \"T2.driverId = T1.driverId\" using an inner join to ensure accurate driver matching."
        },
        "71": {
            "condition": "When filtering by race number",
            "operation": " use \"T1.raceId = 354\" instead of \"race_id = 354\" to match the exact column name."
        },
        "72": {
            "condition": "When answering about qualifying results, When the question mentions a driver by name \"Bruno Senna\", When combining qualifying and drivers tables, When filtering by race number, When referring to table roles",
            "operation": " use T1 for the qualifying table and T2 for the drivers table as established in the join pattern."
        },
        "73": {
            "condition": "When answering about a driver's nationality",
            "operation": " make sure the output order: T2.nationality with DISTINCT to avoid duplicates."
        },
        "74": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match)."
        },
        "75": {
            "condition": "When filtering by race number",
            "operation": " use T1.raceId = 355 instead of race_number."
        },
        "76": {
            "condition": "When matching qualifying time pattern for Q2",
            "operation": " use T1.q2 LIKE '1:40%' instead of exact equality with '0:01:40'."
        },
        "77": {
            "condition": "When answering about a driver's nationality, When combining qualifying and drivers tables, When filtering by race number, When matching qualifying time pattern for Q2, When the question specifies Q2 time",
            "operation": " do not add an explicit quarter = 'Q2' filter since the quarter is already implied by querying the q2 column."
        },
        "78": {
            "condition": "When answering about driver numbers",
            "operation": " make sure the output order: T2.number"
        },
        "79": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match)"
        },
        "80": {
            "condition": "When filtering by race ID",
            "operation": " use T1.raceId = 903 instead of race_id = 903"
        },
        "81": {
            "condition": "When answering about driver numbers, When combining qualifying and drivers tables, When filtering by race ID, When filtering by Q3 time value '0",
            "operation": "01:54': use pattern matching T1.q3 LIKE '1:54%' instead of exact time comparison to handle time formatting variations"
        },
        "82": {
            "condition": "When answering about drivers not finishing a specific Grand Prix",
            "operation": " combine races table as T1, results table as T2, and drivers table as T3 using the exact join conditions T2.raceId = T1.raceId and T3.driverId = T2.driverId."
        },
        "83": {
            "condition": "When filtering for the Bahrain Grand Prix in 2007",
            "operation": " use T1.year = 2007 and T1.name = 'Bahrain Grand Prix' exactly as specified."
        },
        "84": {
            "condition": "When identifying drivers who did not finish",
            "operation": " check T2.time IS NULL instead of using a 'No' value."
        },
        "85": {
            "condition": "When answering about drivers not finishing a specific Grand Prix, When filtering for the Bahrain Grand Prix in 2007, When identifying drivers who did not finish, When counting drivers",
            "operation": " count T3.driverId to ensure accurate driver counting rather than counting all rows."
        },
        "86": {
            "condition": "When answering about \"the season page of year when the race No. 901 took place\"",
            "operation": " make sure the output order: T2.url"
        },
        "87": {
            "condition": "When the question mentions \"season page\"",
            "operation": " \"season page\" actually means \"T2.url in schema\""
        },
        "88": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.year = T1.year; keep only matching pairs (inner match)"
        },
        "89": {
            "condition": "When filtering for race No. 901",
            "operation": " use WHERE T1.raceId = 901 with exact literal value 901"
        },
        "90": {
            "condition": "When answering about \"the season page of year when the race No. 901 took place\", When the question mentions \"season page\", When combining T1 and T2 for shared entities, When filtering for race No. 901, When referring to table roles",
            "operation": " use races AS T1 and seasons AS T2 as specified in the amends"
        },
        "91": {
            "condition": "When answering about \"how many drivers finished the game\"",
            "operation": " make sure the output order: COUNT(T2.driverId)."
        },
        "92": {
            "condition": "When the question mentions \"race happened on 2015/11/29\"",
            "operation": " use T1.date = '2015-11-29' with the exact date format '2015-11-29'."
        },
        "93": {
            "condition": "When the question asks for \"finished the game\"",
            "operation": " use T2.time IS NOT NULL to identify completed races."
        },
        "94": {
            "condition": "When combining races AS T1 and results AS T2",
            "operation": " link rows where T2.raceId = T1.raceId and keep only matching pairs (inner match)."
        },
        "95": {
            "condition": "When answering about \"how many drivers finished the game\", When the question mentions \"race happened on 2015/11/29\", When the question asks for \"finished the game\", When combining races AS T1 and results AS T2, When counting drivers",
            "operation": " use COUNT(T2.driverId) to count specific drivers rather than all rows."
        },
        "96": {
            "condition": "When answering about drivers who finished a race",
            "operation": " combine the \"drivers\" table (T1) and \"results\" table (T2) by matching rows where T1.\"driverId\" equals T2.\"driverId\" and keep only matching pairs."
        },
        "97": {
            "condition": "When filtering for race No. 592",
            "operation": " use the exact literal value 592 for T2.\"raceId\" column."
        },
        "98": {
            "condition": "When identifying finished drivers",
            "operation": " ensure T2.\"time\" is not null to confirm completion."
        },
        "99": {
            "condition": "When checking for known birth dates",
            "operation": " ensure T1.\"dob\" is not null."
        },
        "100": {
            "condition": "When determining the oldest driver",
            "operation": " order by T1.\"dob\" in ascending order (earliest birth date first) and take the first result."
        },
        "101": {
            "condition": "When answering about drivers who finished a race, When filtering for race No. 592, When identifying finished drivers, When checking for known birth dates, When determining the oldest driver, When outputting driver names",
            "operation": " return both T1.\"forename\" and T1.\"surname\" columns instead of a single driver_name field."
        },
        "102": {
            "condition": "When answering about drivers who finished a specific race",
            "operation": " use table aliases T1 for drivers and T2 for results."
        },
        "103": {
            "condition": "When combining driver and race result information",
            "operation": " link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match)."
        },
        "104": {
            "condition": "When filtering for race No. 592",
            "operation": " include only rows where T2.raceId = 592."
        },
        "105": {
            "condition": "When identifying drivers who finished the game",
            "operation": " include only rows where T2.time IS NOT NULL."
        },
        "106": {
            "condition": "When ensuring valid driver age information",
            "operation": " include only rows where T1.dob IS NOT NULL."
        },
        "107": {
            "condition": "When finding the oldest driver",
            "operation": " order rows by T1.dob in ascending order and keep the first 1 row."
        },
        "108": {
            "condition": "When answering about drivers who finished a specific race, When combining driver and race result information, When filtering for race No. 592, When identifying drivers who finished the game, When ensuring valid driver age information, When finding the oldest driver, When outputting driver information",
            "operation": " include only T1.forename and T1.surname in the results, not T1.dob."
        },
        "109": {
            "condition": "When answering about lap times and driver information",
            "operation": " join lapTimes table as T1 with drivers table as T2 using T2.driverId = T1.driverId to link driver details with lap time records."
        },
        "110": {
            "condition": "When filtering by race number 161",
            "operation": " use T1.raceId = 161 to match the exact race identifier."
        },
        "111": {
            "condition": "When searching for lap time 0",
            "operation": "01:27: use T1.time LIKE '1:27%' for pattern matching instead of exact string comparison."
        },
        "112": {
            "condition": "When selecting driver information",
            "operation": " output T2.forename, T2.surname, and T2.url instead of introduction_website."
        },
        "113": {
            "condition": "When answering about lap times and driver information, When filtering by race number 161, When searching for lap time 0, When selecting driver information, When retrieving results",
            "operation": " use DISTINCT to ensure unique driver records are returned."
        },
        "114": {
            "condition": "When answering about the fastest lap speed driver's nationality",
            "operation": " use table alias T1 for \"drivers\" and T2 for \"results\""
        },
        "115": {
            "condition": "When combining drivers and results tables",
            "operation": " link rows where T2.driverId = T1.driverId using inner join"
        },
        "116": {
            "condition": "When filtering for race No.933",
            "operation": " use T2.race_id = 933"
        },
        "117": {
            "condition": "When handling fastest lap data",
            "operation": " add filter T2.fastestLapTime IS NOT NULL to exclude null lap times"
        },
        "118": {
            "condition": "When ordering by fastest lap speed",
            "operation": " reference T2.fastestLapSpeed in descending order"
        },
        "119": {
            "condition": "When limiting to the fastest driver",
            "operation": " take only the first row after ordering"
        },
        "120": {
            "condition": "When answering about the fastest lap speed driver's nationality, When combining drivers and results tables, When filtering for race No.933, When handling fastest lap data, When ordering by fastest lap speed, When limiting to the fastest driver, When selecting the driver's origin",
            "operation": " output T1.nationality"
        },
        "121": {
            "condition": "When the question asks for location coordinates of a specific Grand Prix",
            "operation": " select T1.lat and T1.lng as the coordinate columns instead of latitude and longitude."
        },
        "122": {
            "condition": "When joining circuits and races tables",
            "operation": " use INNER JOIN on T2.circuitID = T1.circuitId to properly relate the tables."
        },
        "123": {
            "condition": "When filtering for a specific Grand Prix event",
            "operation": " use T2.name = 'Malaysian Grand Prix' instead of country filtering to target the specific race."
        },
        "124": {
            "condition": "When the question asks for location coordinates of a specific Grand Prix, When joining circuits and races tables, When filtering for a specific Grand Prix event, When retrieving data that might have duplicates",
            "operation": " use DISTINCT to eliminate duplicate rows."
        },
        "125": {
            "condition": "When answering about the constructor with highest points in race No. 9",
            "operation": " make sure the output order: T2.url"
        },
        "126": {
            "condition": "When combining constructorResults (T1) and constructors (T2)",
            "operation": " link rows where T2.constructorId = T1.constructorId and keep only matching pairs (inner match)."
        },
        "127": {
            "condition": "When filtering for race No. 9",
            "operation": " use T1.raceId = 9 exactly."
        },
        "128": {
            "condition": "When the question mentions \"highest point\"",
            "operation": " rank rows by T1.points in descending order and keep the first 1 row."
        },
        "129": {
            "condition": "When answering about the constructor with highest points in race No. 9, When combining constructorResults (T1) and constructors (T2), When filtering for race No. 9, When the question mentions \"highest point\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "130": {
            "condition": "When answering about a driver's qualifying result",
            "operation": " select the exact column \"q1\" from table \"qualifying\" (aliased as T1) instead of \"q1_result\" from \"race_results\"."
        },
        "131": {
            "condition": "When combining driver and qualifying information",
            "operation": " join table \"drivers\" (aliased as T2) with \"qualifying\" (T1) using the exact key equality T2.driverId = T1.driverId and keep only matching pairs (inner match)."
        },
        "132": {
            "condition": "When filtering by race identifier",
            "operation": " use the exact column \"raceId\" from table \"qualifying\" (T1) with value 345 instead of \"race_id\"."
        },
        "133": {
            "condition": "When answering about a driver's qualifying result, When combining driver and qualifying information, When filtering by race identifier, When identifying driver \"Lucas di Grassi\"",
            "operation": " use the exact columns \"forename\" with value 'Lucas' and \"surname\" with value 'di Grassi' from table \"drivers\" (T2) instead of a single \"driver_name\" column."
        },
        "134": {
            "condition": "When the question asks about a driver's nationality",
            "operation": " use \"T2.nationality\" from the drivers table with DISTINCT to remove duplicates."
        },
        "135": {
            "condition": "When filtering by race number",
            "operation": " use \"T1.raceId = 347\" instead of race_no."
        },
        "136": {
            "condition": "When matching Q2 time pattern '0",
            "operation": "01:15': use pattern matching \"T1.q2 LIKE '1:15%'\" instead of exact equality."
        },
        "137": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows using \"T2.driverId = T1.driverId\" for inner join."
        },
        "138": {
            "condition": "When the question asks about a driver's nationality, When filtering by race number, When matching Q2 time pattern '0, When combining qualifying and drivers tables, When selecting from multiple tables",
            "operation": " use qualifying as T1 and drivers as T2 as specified in the schema mapping."
        },
        "139": {
            "condition": "When answering about driver codes for qualifying times",
            "operation": " make sure the output order: T2.code"
        },
        "140": {
            "condition": "When the question mentions \"race No. 45\"",
            "operation": " \"race No. 45\" actually means \"T1.raceId = 45\" in schema"
        },
        "141": {
            "condition": "When the question mentions \"Q3 time as 0",
            "operation": "01:33\": \"Q3 time as 0:01:33\" actually means \"T1.q3 LIKE '1:33%'\" for pattern matching"
        },
        "142": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows where T2.driverId = T1.driverId exactly as shown; keep only matching pairs (inner match)"
        },
        "143": {
            "condition": "When answering about driver codes for qualifying times, When the question mentions \"race No. 45\", When the question mentions \"Q3 time as 0, When combining qualifying and drivers tables, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "144": {
            "condition": "When answering about actual finish time for a driver in a specific race",
            "operation": " select T2.time from the results table instead of finish_time from races table."
        },
        "145": {
            "condition": "When combining driver and result information",
            "operation": " join drivers AS T1 with results AS T2 using inner join where T2.driverId = T1.driverId."
        },
        "146": {
            "condition": "When filtering by race number 743",
            "operation": " use T2.raceId = 743 instead of race_id = 743."
        },
        "147": {
            "condition": "When answering about actual finish time for a driver in a specific race, When combining driver and result information, When filtering by race number 743, When filtering for driver Bruce McLaren",
            "operation": " use separate conditions T1.forename = 'Bruce' AND T1.surname = 'McLaren' instead of a single driver_name filter."
        },
        "148": {
            "condition": "When the question asks about race results",
            "operation": " join races table as T1, results table as T2 on T2.raceId = T1.raceId, and drivers table as T3 on T3.driverId = T2.driverId using inner matches only."
        },
        "149": {
            "condition": "When the question mentions \"San Marino Grand Prix\"",
            "operation": " use T1.name = 'San Marino Grand Prix' exactly as written."
        },
        "150": {
            "condition": "When the question mentions year 2006",
            "operation": " use T1.year = 2006."
        },
        "151": {
            "condition": "When the question asks about \"second place\" finisher",
            "operation": " use T2.position = 2."
        },
        "152": {
            "condition": "When the question asks about race results, When the question mentions \"San Marino Grand Prix\", When the question mentions year 2006, When the question asks about \"second place\" finisher, When the question asks \"who finished\"",
            "operation": " output both T3.forename and T3.surname instead of just driver_name."
        },
        "153": {
            "condition": "When the question asks for \"season page of year\"",
            "operation": " select \"T2.url\" instead of \"season\" from the seasons table."
        },
        "154": {
            "condition": "When combining races and seasons tables",
            "operation": " link rows where \"T2.year = T1.year\" using an inner match."
        },
        "155": {
            "condition": "When filtering for race No. 901",
            "operation": " use \"T1.raceId = 901\" as the exact filter condition."
        },
        "156": {
            "condition": "When the question asks for \"season page of year\", When combining races and seasons tables, When filtering for race No. 901, When answering about the season page",
            "operation": " make sure the output order contains only \"T2.url\" as the result."
        },
        "157": {
            "condition": "When answering about drivers who did not finish a race",
            "operation": " use tables \"races AS T1\" and \"results AS T2\" instead of only the \"drivers\" table."
        },
        "158": {
            "condition": "When combining races and results tables",
            "operation": " link rows where T2.raceId = T1.raceId using inner match."
        },
        "159": {
            "condition": "When filtering for race date '2015/11/29'",
            "operation": " use T1.date = '2015-11-29' with exact date format instead of '2015/11/29'."
        },
        "160": {
            "condition": "When checking for drivers who did not finish",
            "operation": " use T2.time IS NULL instead of finish_position IS NULL."
        },
        "161": {
            "condition": "When answering about drivers who did not finish a race, When combining races and results tables, When filtering for race date '2015/11/29', When checking for drivers who did not finish, When counting drivers",
            "operation": " count T2.driverId specifically instead of using COUNT(*)."
        },
        "162": {
            "condition": "When answering about drivers who finished a specific race",
            "operation": " combine drivers table (as T1) with results table (as T2) using inner match where T2.driverId equals T1.driverId."
        },
        "163": {
            "condition": "When filtering for race No. 872",
            "operation": " use T2.raceId = 872 and ensure T2.time IS NOT NULL to identify finishers."
        },
        "164": {
            "condition": "When determining the youngest driver",
            "operation": " order by T1.dob in descending order (most recent birth date first) and take the first result."
        },
        "165": {
            "condition": "When answering about drivers who finished a specific race, When filtering for race No. 872, When determining the youngest driver, When selecting driver names",
            "operation": " output both T1.forename and T1.surname instead of a single driver_name field."
        },
        "166": {
            "condition": "When answering about \"the driver that got the best lap time\"",
            "operation": " make sure the output order includes both T2.forename and T2.surname for the full name."
        },
        "167": {
            "condition": "When the question mentions \"race No. 348\"",
            "operation": " filter using T1.raceId = 348 exactly."
        },
        "168": {
            "condition": "When combining lapTimes (T1) and drivers (T2)",
            "operation": " link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match)."
        },
        "169": {
            "condition": "When finding the best lap time",
            "operation": " order by T1.time ASC and take the first row."
        },
        "170": {
            "condition": "When answering about \"the driver that got the best lap time\", When the question mentions \"race No. 348\", When combining lapTimes (T1) and drivers (T2), When finding the best lap time, When the question asks for \"best lap time\"",
            "operation": " this means the minimum time value, so order in ascending order."
        },
        "171": {
            "condition": "When answering about \"the driver who set the fastest lap speed\"",
            "operation": " make sure to combine drivers table (as T1) with results table (as T2) using the exact join condition T2.driverId = T1.driverId."
        },
        "172": {
            "condition": "When the question mentions \"fastest lap speed\"",
            "operation": " \"fastest lap speed\" actually means T2.fastestLapSpeed in schema."
        },
        "173": {
            "condition": "When the question asks for \"nationality\"",
            "operation": " select T1.nationality from the joined result."
        },
        "174": {
            "condition": "When answering about \"the driver who set the fastest lap speed\", When the question mentions \"fastest lap speed\", When the question asks for \"nationality\", When the question asks for \"the driver who set the fastest lap speed\"",
            "operation": " order rows by T2.fastestLapSpeed in descending direction and keep the first 1 row."
        },
        "175": {
            "condition": "When answering about percentage difference in fastest lap speeds between two specific races for a driver",
            "operation": " use conditional aggregation with SUM(IIF()) instead of direct column subtraction."
        },
        "176": {
            "condition": "When combining driver and race information",
            "operation": " join \"drivers\" and \"results\" tables instead of self-joining a single table."
        },
        "177": {
            "condition": "When filtering for driver 'Paul di Resta'",
            "operation": " use exact conditions forename = 'Paul' AND surname = 'di Resta' instead of a combined driver_name field."
        },
        "178": {
            "condition": "When calculating percentage difference",
            "operation": " use formula (sum_853 - sum_854) * 100 / sum_853 instead of (r1.speed - r2.speed) / r2.speed * 100."
        },
        "179": {
            "condition": "When answering about percentage difference in fastest lap speeds between two specific races for a driver, When combining driver and race information, When filtering for driver 'Paul di Resta', When calculating percentage difference, When referencing specific races",
            "operation": " use exact column \"raceId\" with values 853 and 854 instead of race_number."
        },
        "180": {
            "condition": "When calculating race completion rate",
            "operation": " use CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) to compute the percentage of drivers who completed the race."
        },
        "181": {
            "condition": "When joining tables for race results",
            "operation": " use races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId to link race information with driver results."
        },
        "182": {
            "condition": "When filtering for a specific race date",
            "operation": " use WHERE T1.date = '1983-07-16' with the exact date format '1983-07-16'."
        },
        "183": {
            "condition": "When calculating race completion rate, When joining tables for race results, When filtering for a specific race date, When the question asks for overall completion rate",
            "operation": " do not group by individual drivers but return a single aggregate value for all drivers in the specified race."
        },
        "184": {
            "condition": "When answering about \"first Singapore Grand Prix\"",
            "operation": " query the \"races\" table instead of the \"grand_prix\" table."
        },
        "185": {
            "condition": "When filtering for Singapore Grand Prix",
            "operation": " use \"name = 'Singapore Grand Prix'\" instead of filtering by country."
        },
        "186": {
            "condition": "When finding the first occurrence by year",
            "operation": " use \"ORDER BY year ASC\" instead of descending order to get the earliest year."
        },
        "187": {
            "condition": "When answering about \"first Singapore Grand Prix\", When filtering for Singapore Grand Prix, When finding the first occurrence by year, When retrieving the year of the first occurrence",
            "operation": " use \"LIMIT 1\" to get only the earliest result."
        },
        "188": {
            "condition": "When the question asks for \"how many races\" but also requires naming all races",
            "operation": " do not perform aggregation and counting, instead return individual race names."
        },
        "189": {
            "condition": "When the question asks to \"name all the races\"",
            "operation": " use the exact column \"name\" from table \"races\" instead of any other column name."
        },
        "190": {
            "condition": "When the question specifies \"in 2005\"",
            "operation": " filter rows where the year equals 2005."
        },
        "191": {
            "condition": "When the question requires \"descending order\"",
            "operation": " sort the results by the \"name\" column in descending alphabetical order instead of ascending order."
        },
        "192": {
            "condition": "When the question asks for \"how many races\" but also requires naming all races, When the question asks to \"name all the races\", When the question specifies \"in 2005\", When the question requires \"descending order\", When the question asks for both count and names but the schema only has name information",
            "operation": " return only the individual race names without attempting to count them."
        },
        "193": {
            "condition": "When the question asks for race names",
            "operation": " use the exact column \"name\" from table \"races\" instead of \"race_name\"."
        },
        "194": {
            "condition": "When extracting year and month information from dates",
            "operation": " use STRFTIME('%Y', date) for year and STRFTIME('%m', date) for month instead of separate year and month columns."
        },
        "195": {
            "condition": "When finding the earliest recorded year and month",
            "operation": " identify the single earliest date record using ORDER BY date ASC LIMIT 1 instead of separate MIN() aggregates on year and month to ensure consistency."
        },
        "196": {
            "condition": "When the question asks for race names, When extracting year and month information from dates, When finding the earliest recorded year and month, When comparing races to the earliest date",
            "operation": " ensure both year and month comparisons come from the same earliest race record rather than potentially different minimum values from separate aggregates."
        },
        "197": {
            "condition": "When answering about \"the last round of race in year 1999\"",
            "operation": " make sure the output order: round DESC."
        },
        "198": {
            "condition": "When the question mentions \"last round\"",
            "operation": " this means the highest round number in the year."
        },
        "199": {
            "condition": "When the question asks for \"name and date\" of the last round",
            "operation": " select the name and date columns from the races table."
        },
        "200": {
            "condition": "When filtering for year 1999",
            "operation": " include only rows where year = 1999."
        },
        "201": {
            "condition": "When answering about \"the last round of race in year 1999\", When the question mentions \"last round\", When the question asks for \"name and date\" of the last round, When filtering for year 1999, When selecting the last round",
            "operation": " use LIMIT 1 after ordering by round DESC to get the single row with the highest round number."
        },
        "202": {
            "condition": "When counting races",
            "operation": " count the \"round\" column instead of counting all records."
        },
        "203": {
            "condition": "When ordering by count to find the most",
            "operation": " order by the count in descending order instead of ascending order."
        },
        "204": {
            "condition": "When selecting output columns",
            "operation": " only include \"year\" in the final output, not the count value."
        },
        "205": {
            "condition": "When counting races, When ordering by count to find the most, When selecting output columns, When the question asks for the year with the most races",
            "operation": " rank years by the count of rounds in descending order and take the top result."
        },
        "206": {
            "condition": "When answering about races in a specific year",
            "operation": " filter the races table using the exact year value mentioned (e.g., year = 2017)."
        },
        "207": {
            "condition": "When excluding entities that exist in another condition",
            "operation": " use a subquery condition with NOT IN to exclude names that appear in the other condition (e.g., name NOT IN (SELECT name FROM races WHERE year = 2000))."
        },
        "208": {
            "condition": "When answering about races in a specific year, When excluding entities that exist in another condition, When filtering the same table for different conditions",
            "operation": " avoid using contradictory filters on the same column in the same WHERE clause, instead use subqueries to handle different conditions separately."
        },
        "209": {
            "condition": "When answering about the first European Grand Prix",
            "operation": " make sure the output order: T1.country, T1.location."
        },
        "210": {
            "condition": "When the question mentions \"circuit and location\"",
            "operation": " \"circuit\" actually means \"T1.name in schema\" but should not be selected, and \"location\" actually means \"T1.location in schema\"."
        },
        "211": {
            "condition": "When combining circuits AS T1 and races AS T2",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown; keep only matching pairs (inner match)."
        },
        "212": {
            "condition": "When filtering for European Grand Prix",
            "operation": " use T2.name = 'European Grand Prix' exactly as specified."
        },
        "213": {
            "condition": "When finding the first occurrence",
            "operation": " order by T2.year in ascending direction and keep only the first 1 row."
        },
        "214": {
            "condition": "When answering about the first European Grand Prix, When the question mentions \"circuit and location\", When combining circuits AS T1 and races AS T2, When filtering for European Grand Prix, When finding the first occurrence, When handling text literals",
            "operation": " do not change 'European Grand Prix' case, spacing, or punctuation."
        },
        "215": {
            "condition": "When answering about the first European Grand Prix",
            "operation": " make sure the output order: country, location."
        },
        "216": {
            "condition": "When the question asks for circuit name",
            "operation": " do not include circuit name in the output columns."
        },
        "217": {
            "condition": "When combining circuits table (T1) and races table (T2)",
            "operation": " link rows where T2.circuitId = T1.circuitId and keep only matching pairs (inner match)."
        },
        "218": {
            "condition": "When filtering for European Grand Prix",
            "operation": " use exact literal 'European Grand Prix' for T2.name comparison."
        },
        "219": {
            "condition": "When answering about the first European Grand Prix, When the question asks for circuit name, When combining circuits table (T1) and races table (T2), When filtering for European Grand Prix, When finding the first occurrence",
            "operation": " order results by T2.year in ascending order and keep only the first row."
        },
        "220": {
            "condition": "When answering about \"last f1 season with British Grand Prix at Brands Hatch\"",
            "operation": " make sure the output order: T2.date"
        },
        "221": {
            "condition": "When combining circuits and races tables",
            "operation": " link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match)."
        },
        "222": {
            "condition": "When the question mentions \"Brands Hatch\"",
            "operation": " \"Brands Hatch\" actually means T1.name = 'Brands Hatch' in schema."
        },
        "223": {
            "condition": "When the question mentions \"British Grand Prix\"",
            "operation": " \"British Grand Prix\" actually means T2.name = 'British Grand Prix' in schema."
        },
        "224": {
            "condition": "When answering about \"last f1 season with British Grand Prix at Brands Hatch\", When combining circuits and races tables, When the question mentions \"Brands Hatch\", When the question mentions \"British Grand Prix\", When the question asks for \"last\" or \"most recent\"",
            "operation": " rank rows by T2.year in descending order and keep the first 1 row."
        },
        "225": {
            "condition": "When answering about \"how many seasons Silverstone Circuit hosted the United Kingdom grand prix\"",
            "operation": " make sure the output order: count of seasons"
        },
        "226": {
            "condition": "When the question mentions \"Silverstone Circuit\"",
            "operation": " \"Silverstone Circuit\" actually means \"T1.name = 'Silverstone Circuit'\" in schema"
        },
        "227": {
            "condition": "When the question mentions \"United Kingdom grand prix\"",
            "operation": " \"United Kingdom grand prix\" actually means \"T2.name = 'British Grand Prix'\" in schema"
        },
        "228": {
            "condition": "When combining T1 (circuits) and T2 (races) for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "229": {
            "condition": "When answering about \"how many seasons Silverstone Circuit hosted the United Kingdom grand prix\", When the question mentions \"Silverstone Circuit\", When the question mentions \"United Kingdom grand prix\", When combining T1 (circuits) and T2 (races) for shared entities, When the question asks for \"count of seasons\"",
            "operation": " compute the number of rows using the canonical key token T2.circuitid as shown in the amends"
        },
        "230": {
            "condition": "When answering about driver names in a specific race",
            "operation": " select both T3.forename and T3.surname instead of just driver_name."
        },
        "231": {
            "condition": "When the question mentions \"2010 Singapore Grand Prix\"",
            "operation": " filter using T1.name = 'Singapore Grand Prix' AND T1.year = 2010 to properly separate year and race name."
        },
        "232": {
            "condition": "When combining tables for race and driver standings",
            "operation": " link rows where T2.raceId = T1.raceId using an inner match."
        },
        "233": {
            "condition": "When combining tables for driver information",
            "operation": " link rows where T3.driverId = T2.driverId using an inner match."
        },
        "234": {
            "condition": "When ordering by position",
            "operation": " order by T2.position ASC with explicit table qualification."
        },
        "235": {
            "condition": "When answering about driver names in a specific race, When the question mentions \"2010 Singapore Grand Prix\", When combining tables for race and driver standings, When combining tables for driver information, When ordering by position, When the question asks for drivers in a specific race order by position",
            "operation": " use the canonical position column T2.position from the driverStandings table."
        },
        "236": {
            "condition": "When answering about \"driver with the most points scored\"",
            "operation": " make sure the output order: T3.forename, T3.surname, T2.points"
        },
        "237": {
            "condition": "When the question mentions \"points\"",
            "operation": " \"points\" actually means \"T2.points in driverStandings table\" not points from drivers table"
        },
        "238": {
            "condition": "When the question mentions \"full name\"",
            "operation": " \"full name\" actually means \"T3.forename and T3.surname from drivers table\""
        },
        "239": {
            "condition": "When combining tables races, driverStandings, and drivers",
            "operation": " link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match)"
        },
        "240": {
            "condition": "When the question asks for \"driver with the most points\"",
            "operation": " rank rows by T2.points in descending order and keep the first 1 row"
        },
        "241": {
            "condition": "When answering about \"driver with the most points scored\", When the question mentions \"points\", When the question mentions \"full name\", When combining tables races, driverStandings, and drivers, When the question asks for \"driver with the most points\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for any table or column names"
        },
        "242": {
            "condition": "When answering about \"top 3 drivers and points in the 2017 Chinese Grand Prix\"",
            "operation": " make sure the output order: T3.forename, T3.surname, T2.points."
        },
        "243": {
            "condition": "When the question mentions \"Chinese Grand Prix\"",
            "operation": " \"Chinese Grand Prix\" actually means \"T1.name = 'Chinese Grand Prix'\" in schema."
        },
        "244": {
            "condition": "When the question mentions \"top 3\" by points",
            "operation": " rank rows by T2.points in descending order and keep the first 3 rows."
        },
        "245": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match)."
        },
        "246": {
            "condition": "When answering about \"top 3 drivers and points in the 2017 Chinese Grand Prix\", When the question mentions \"Chinese Grand Prix\", When the question mentions \"top 3\" by points, When combining T1, T2, and T3 for shared entities, When filtering by year",
            "operation": " use T1.year = 2017 exactly as specified in the question."
        },
        "247": {
            "condition": "When answering about \"best lap time recorded\"",
            "operation": " make sure the output order: T2.milliseconds, T1.forename, T1.surname, T3.name"
        },
        "248": {
            "condition": "When the question mentions \"driver\"",
            "operation": " \"driver\" actually means \"T1.forename and T1.surname in schema\""
        },
        "249": {
            "condition": "When the question mentions \"race\"",
            "operation": " \"race\" actually means \"T3.name in schema\""
        },
        "250": {
            "condition": "When the question mentions \"lap time\"",
            "operation": " \"lap time\" actually means \"T2.milliseconds in schema\""
        },
        "251": {
            "condition": "When combining T1 (drivers) and T2 (lapTimes) for shared entities",
            "operation": " link rows where T1.driverId = T2.driverId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "252": {
            "condition": "When combining T2 (lapTimes) and T3 (races) for shared entities",
            "operation": " link rows where T2.raceId = T3.raceId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "253": {
            "condition": "When the question asks for \"best lap time\" (minimum time)",
            "operation": " order rows by T2.milliseconds ASC and keep the first 1 row"
        },
        "254": {
            "condition": "When answering about \"best lap time recorded\", When the question mentions \"driver\", When the question mentions \"race\", When the question mentions \"lap time\", When combining T1 (drivers) and T2 (lapTimes) for shared entities, When combining T2 (lapTimes) and T3 (races) for shared entities, When the question asks for \"best lap time\" (minimum time), When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for identifiers like T2.milliseconds, T1.forename, T1.surname, T3.name, T1.driverId, T2.driverId, T2.raceId, T3.raceId"
        },
        "255": {
            "condition": "When answering about average lap time",
            "operation": " use T2.milliseconds for the average calculation instead of lap_time."
        },
        "256": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " filter by T3.forename = 'Lewis' AND T3.surname = 'Hamilton' instead of driver_name = 'Lewis Hamilton'."
        },
        "257": {
            "condition": "When the question mentions \"2009 Malaysian Grand Prix\"",
            "operation": " filter by T1.year = 2009 AND T1.name = 'Malaysian Grand Prix' instead of race_year = 2009 AND race_name = 'Malaysian Grand Prix'."
        },
        "258": {
            "condition": "When combining races and lapTimes tables",
            "operation": " link rows where T2.raceId = T1.raceId and keep only matching pairs (inner match)."
        },
        "259": {
            "condition": "When answering about average lap time, When the question mentions \"Lewis Hamilton\", When the question mentions \"2009 Malaysian Grand Prix\", When combining races and lapTimes tables, When combining drivers and lapTimes tables",
            "operation": " link rows where T3.driverId = T2.driverId and keep only matching pairs (inner match)."
        },
        "260": {
            "condition": "When calculating percentages with division",
            "operation": " use CAST(COUNT(CASE WHEN T2.position <> 1 THEN T2.position END) AS REAL) * 100 / COUNT(T2.driverStandingsId) for proper type casting and accurate column references instead of generic COUNT(*)."
        },
        "261": {
            "condition": "When querying about F1 race results",
            "operation": " join races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId to properly relate race and driver data through the correct join structure."
        },
        "262": {
            "condition": "When filtering for driver 'Hamilton'",
            "operation": " use T3.surname = 'Hamilton' instead of driver = 'Hamilton' to use the correct driver identification column."
        },
        "263": {
            "condition": "When calculating percentages with division, When querying about F1 race results, When filtering for driver 'Hamilton', When calculating percentage of races where Hamilton was not first",
            "operation": " remove any track_position = 1 filter as this condition improperly limits the result set."
        },
        "264": {
            "condition": "When answering about \"driver with the most winning\"",
            "operation": " use T1.forename, T1.surname, T1.nationality instead of driver_name, nationality for the output columns."
        },
        "265": {
            "condition": "When combining drivers and driverStandings tables",
            "operation": " link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match)."
        },
        "266": {
            "condition": "When filtering for drivers with wins",
            "operation": " include only rows where T2.wins >= 1."
        },
        "267": {
            "condition": "When computing maximum points",
            "operation": " use MAX(T2.points) instead of MAX(points) to reference the correct table."
        },
        "268": {
            "condition": "When grouping results",
            "operation": " organize by T1.forename, T1.surname, T1.nationality to match the SELECT list."
        },
        "269": {
            "condition": "When ordering by number of wins",
            "operation": " use COUNT(T2.wins) instead of COUNT(wins) to reference the correct table."
        },
        "270": {
            "condition": "When answering about \"driver with the most winning\", When combining drivers and driverStandings tables, When filtering for drivers with wins, When computing maximum points, When grouping results, When ordering by number of wins, When finding the driver with most wins",
            "operation": " rank rows by COUNT(T2.wins) in descending order and keep the first 1 row."
        },
        "271": {
            "condition": "When the question asks for a driver's name",
            "operation": " include both \"forename\" and \"surname\" columns instead of a single \"name\" column."
        },
        "272": {
            "condition": "When calculating age from date of birth",
            "operation": " compute dynamically using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) instead of selecting a static age value."
        },
        "273": {
            "condition": "When identifying the youngest driver",
            "operation": " order by \"dob\" in descending order instead of \"age\" in ascending order to correctly find the most recent birth date."
        },
        "274": {
            "condition": "When the question asks for a driver's name, When calculating age from date of birth, When identifying the youngest driver, When filtering by nationality",
            "operation": " use the exact literal 'Japanese' with the correct case and spelling."
        },
        "275": {
            "condition": "When calculating age from date of birth",
            "operation": " use the expression STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob) without any alias."
        },
        "276": {
            "condition": "When ordering output columns",
            "operation": " place the calculated expression before the name columns forename and surname."
        },
        "277": {
            "condition": "When calculating age from date of birth, When ordering output columns, When filtering for Japanese drivers",
            "operation": " use the exact literal 'Japanese' for the nationality condition."
        },
        "278": {
            "condition": "When answering about circuits hosting races",
            "operation": " join table \"circuits\" as T1 with table \"races\" as T2 using the exact key equality T2.circuitID = T1.circuitId and keep only matching pairs (inner match)."
        },
        "279": {
            "condition": "When filtering by year range 1990 to 2000",
            "operation": " use STRFTIME('%Y', T2.date) BETWEEN '1990' AND '2000' on race dates instead of a non-existent year column."
        },
        "280": {
            "condition": "When counting races hosted per circuit",
            "operation": " group by T1.name and count using T2.raceId as the counting key."
        },
        "281": {
            "condition": "When the question asks for circuits hosting exactly 4 races",
            "operation": " use HAVING COUNT(T2.raceId) = 4 to filter groups."
        },
        "282": {
            "condition": "When answering about circuits hosting races, When filtering by year range 1990 to 2000, When counting races hosted per circuit, When the question asks for circuits hosting exactly 4 races, When selecting circuit names",
            "operation": " use DISTINCT T1.name with the table alias instead of circuit_name without aliasing."
        },
        "283": {
            "condition": "When eliminating duplicate rows",
            "operation": " use DISTINCT to ensure each result row is unique."
        },
        "284": {
            "condition": "When assigning table aliases",
            "operation": " use T1 for circuits table and T2 for races table."
        },
        "285": {
            "condition": "When selecting race names",
            "operation": " use T2.name to get the race name from the races table."
        },
        "286": {
            "condition": "When selecting circuit names",
            "operation": " use T1.name to get the circuit name from the circuits table."
        },
        "287": {
            "condition": "When selecting circuit locations",
            "operation": " use T1.location to get the location from the circuits table."
        },
        "288": {
            "condition": "When joining races and circuits tables",
            "operation": " use INNER JOIN to combine only matching rows."
        },
        "289": {
            "condition": "When specifying join condition",
            "operation": " use T2.circuitID = T1.circuitId to match the exact column names."
        },
        "290": {
            "condition": "When filtering for year 2005",
            "operation": " use T2.year = 2005 to ensure races are from the correct year."
        },
        "291": {
            "condition": "When filtering for September races",
            "operation": " use STRFTIME('%m', T2.date) = '09' to extract the month from date values."
        },
        "292": {
            "condition": "When eliminating duplicate rows, When assigning table aliases, When selecting race names, When selecting circuit names, When selecting circuit locations, When joining races and circuits tables, When specifying join condition, When filtering for year 2005, When filtering for September races, When answering about races hosted in September 2005",
            "operation": " make sure the output order includes race name, circuit name, and location."
        },
        "293": {
            "condition": "When answering about \"which race Alex Yoong was in with track number less than 20\"",
            "operation": " make sure the output order: T1.name"
        },
        "294": {
            "condition": "When the question mentions \"race\"",
            "operation": " \"race\" actually means \"T1.name in schema\""
        },
        "295": {
            "condition": "When combining tables for driver information",
            "operation": " link rows using T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match)"
        },
        "296": {
            "condition": "When filtering for driver \"Alex Yoong\"",
            "operation": " use T3.forename = 'Alex' AND T3.surname = 'Yoong'"
        },
        "297": {
            "condition": "When answering about \"which race Alex Yoong was in with track number less than 20\", When the question mentions \"race\", When combining tables for driver information, When filtering for driver \"Alex Yoong\", When the question mentions \"track number less than 20\"",
            "operation": " \"track number\" actually means \"T2.position\" and use T2.position < 20"
        },
        "298": {
            "condition": "When answering about \"How many times did Michael Schumacher won from races hosted in Sepang International Circuit\"",
            "operation": " make sure the output order: SUM(T2.wins) as the count of wins."
        },
        "299": {
            "condition": "When the question mentions \"Michael Schumacher\"",
            "operation": " \"Michael Schumacher\" actually means \"T1.forename = 'Michael' AND T1.surname = 'Schumacher'\" in schema."
        },
        "300": {
            "condition": "When the question mentions \"Sepang International Circuit\"",
            "operation": " \"Sepang International Circuit\" actually means \"T4.name = 'Sepang International Circuit'\" in schema."
        },
        "301": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.driverId = T1.driverId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "302": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T3.raceId = T2.raceId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "303": {
            "condition": "When combining T3 and T4 for shared entities",
            "operation": " link rows where T4.circuitId = T3.circuitId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "304": {
            "condition": "When answering about \"How many times did Michael Schumacher won from races hosted in Sepang International Circuit\", When the question mentions \"Michael Schumacher\", When the question mentions \"Sepang International Circuit\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When combining T3 and T4 for shared entities, When calculating total wins",
            "operation": " use SUM(T2.wins) instead of COUNT(*) to calculate total wins from driver standings rather than counting rows."
        },
        "305": {
            "condition": "When answering about Michael Schumacher's fastest lap race",
            "operation": " join races AS T1 with lapTimes AS T2 on T2.raceId = T1.raceId and join drivers AS T3 on T3.driverId = T2.driverId to properly link race information with lap times and driver details."
        },
        "306": {
            "condition": "When filtering for Michael Schumacher",
            "operation": " use T3.forename = 'Michael' AND T3.surname = 'Schumacher' instead of a single driver column to match the driver's full name across separate columns."
        },
        "307": {
            "condition": "When identifying the fastest lap",
            "operation": " order by T2.milliseconds ASC instead of fastest_lap DESC to correctly identify the fastest lap based on time measurement."
        },
        "308": {
            "condition": "When answering about Michael Schumacher's fastest lap race, When filtering for Michael Schumacher, When identifying the fastest lap, When selecting output columns",
            "operation": " use T1.name and T1.year instead of race and year to get the correct race name and year information."
        },
        "309": {
            "condition": "When the question asks about a driver's performance",
            "operation": " join drivers table as T1 with driverStandings table as T2 using T2.driverId = T1.driverId to get driver results."
        },
        "310": {
            "condition": "When the question involves race year information",
            "operation": " join races table as T3 with T3.raceId = T2.raceId to access year data."
        },
        "311": {
            "condition": "When filtering for driver name \"Eddie Irvine\"",
            "operation": " use T1.forename = 'Eddie' and T1.surname = 'Irvine' instead of a single driver_name column."
        },
        "312": {
            "condition": "When filtering for year 2000",
            "operation": " use T3.year = 2000 instead of a simple year column."
        },
        "313": {
            "condition": "When the question asks about a driver's performance, When the question involves race year information, When filtering for driver name \"Eddie Irvine\", When filtering for year 2000, When calculating average points scored",
            "operation": " compute AVG(T2.points) from the joined tables instead of directly from a results table."
        },
        "314": {
            "condition": "When answering about \"Lewis Hamilton's first race\"",
            "operation": " make sure the output order: T1.name, T2.points."
        },
        "315": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema."
        },
        "316": {
            "condition": "When combining T1 (races) and T2 (driverStandings) for shared entities",
            "operation": " link rows where T2.raceId = T1.raceId and keep only matching pairs (inner match)."
        },
        "317": {
            "condition": "When combining T2 (driverStandings) and T3 (drivers) for shared entities",
            "operation": " link rows where T3.driverId = T2.driverId and keep only matching pairs (inner match)."
        },
        "318": {
            "condition": "When answering about \"Lewis Hamilton's first race\", When the question mentions \"Lewis Hamilton\", When combining T1 (races) and T2 (driverStandings) for shared entities, When combining T2 (driverStandings) and T3 (drivers) for shared entities, When determining the first race",
            "operation": " order by T1.year ASC and keep the first 1 row."
        },
        "319": {
            "condition": "When answering about \"races in 2017 and hosting country\"",
            "operation": " make sure the output order: T2.name, T1.country"
        },
        "320": {
            "condition": "When the question mentions \"races\"",
            "operation": " \"races\" actually means \"T2.name in schema\""
        },
        "321": {
            "condition": "When the question mentions \"hosting country\"",
            "operation": " \"hosting country\" actually means \"T1.country in schema\""
        },
        "322": {
            "condition": "When combining circuits as T1 and races as T2",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown; keep only matching pairs (inner match)"
        },
        "323": {
            "condition": "When filtering for year 2017",
            "operation": " use T2.year = 2017 instead of year = 2017"
        },
        "324": {
            "condition": "When ordering by date of the event",
            "operation": " use T2.date ASC instead of event_date DESC"
        },
        "325": {
            "condition": "When answering about \"races in 2017 and hosting country\", When the question mentions \"races\", When the question mentions \"hosting country\", When combining circuits as T1 and races as T2, When filtering for year 2017, When ordering by date of the event, When retrieving distinct values",
            "operation": " use DISTINCT to get unique circuit names with their countries"
        },
        "326": {
            "condition": "When answering about \"most laps f1 races had\"",
            "operation": " make sure the output order: T3.lap, T2.name, T2.year, T1.location"
        },
        "327": {
            "condition": "When the question mentions \"race\"",
            "operation": " \"race\" actually means \"T2.name in schema\""
        },
        "328": {
            "condition": "When the question mentions \"year\"",
            "operation": " \"year\" actually means \"T2.year in schema\""
        },
        "329": {
            "condition": "When the question mentions \"circuit location\"",
            "operation": " \"circuit location\" actually means \"T1.location in schema\""
        },
        "330": {
            "condition": "When combining circuits AS T1 and races AS T2",
            "operation": " link rows where T1.circuitId = T2.circuitId and keep only matching pairs (inner match)"
        },
        "331": {
            "condition": "When combining races AS T2 and lapTimes AS T3",
            "operation": " link rows where T3.raceId = T2.raceId and keep only matching pairs (inner match)"
        },
        "332": {
            "condition": "When the question asks for \"most laps\"",
            "operation": " rank rows by T3.lap in descending order and keep the first 1 row"
        },
        "333": {
            "condition": "When answering about \"most laps f1 races had\", When the question mentions \"race\", When the question mentions \"year\", When the question mentions \"circuit location\", When combining circuits AS T1 and races AS T2, When combining races AS T2 and lapTimes AS T3, When the question asks for \"most laps\", When handling the maximum lap value",
            "operation": " do not use GROUP BY or aggregation functions, instead retrieve the actual T3.lap value directly from the detailed data"
        },
        "334": {
            "condition": "When answering about European Grand Prix races",
            "operation": " use exact match T2.name = 'European Grand Prix' instead of pattern matching."
        },
        "335": {
            "condition": "When combining races and circuits tables",
            "operation": " link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match)."
        },
        "336": {
            "condition": "When accessing country information",
            "operation": " reference T1.country instead of country alone."
        },
        "337": {
            "condition": "When counting races hosted in Germany",
            "operation": " use T2.circuitID in the numerator's CASE condition instead of 1."
        },
        "338": {
            "condition": "When computing the total count",
            "operation": " reference T2.circuitId in the denominator instead of *."
        },
        "339": {
            "condition": "When answering about European Grand Prix races, When combining races and circuits tables, When accessing country information, When counting races hosted in Germany, When computing the total count, When calculating percentage",
            "operation": " cast the count as REAL instead of using implicit conversion."
        },
        "340": {
            "condition": "When the question asks for location coordinates",
            "operation": " use the exact column names \"lat\" and \"lng\" from the circuits table instead of \"latitude\" and \"longitude\"."
        },
        "341": {
            "condition": "When the question asks for location coordinates, When filtering for a specific circuit name",
            "operation": " use the exact literal value 'Silverstone Circuit' with proper case and spacing as shown in the question."
        },
        "342": {
            "condition": "When the question asks about latitude comparison between specific circuits",
            "operation": " use the exact circuit names 'Silverstone Circuit', 'Hockenheimring', and 'Hungaroring' as specified in the question."
        },
        "343": {
            "condition": "When selecting data about circuit locations",
            "operation": " include only the circuit name in the output, not the latitude coordinate."
        },
        "344": {
            "condition": "When ordering circuits by latitude",
            "operation": " use the column \"lat\" from the circuits table instead of \"latitude\" for sorting."
        },
        "345": {
            "condition": "When the question asks about latitude comparison between specific circuits, When selecting data about circuit locations, When ordering circuits by latitude, When finding the circuit at the highest latitude",
            "operation": " sort by \"lat\" in descending order and return only the top result."
        },
        "346": {
            "condition": "When the question asks for the reference name of a circuit",
            "operation": " select the exact column \"circuitRef\" from the circuits table."
        },
        "347": {
            "condition": "When filtering by circuit name to find its reference",
            "operation": " use the exact literal 'Marina Bay Street Circuit' to match against the name column, not the circuitRef column."
        },
        "348": {
            "condition": "When the question asks for the reference name of a circuit, When filtering by circuit name to find its reference, When the question mentions \"Marina Bay Street Circuit\"",
            "operation": " this refers to the name value, not the circuitRef value, so filter using name = 'Marina Bay Street Circuit'."
        },
        "349": {
            "condition": "When the question asks about \"highest altitude\"",
            "operation": " use the exact column token \"alt\" from the circuits table for ordering instead of \"altitude\"."
        },
        "350": {
            "condition": "When ordering by altitude to find the highest value",
            "operation": " sort in descending order (DESC) and take the first row only (LIMIT 1)."
        },
        "351": {
            "condition": "When the question asks about \"highest altitude\", When ordering by altitude to find the highest value, When answering about circuits and their countries",
            "operation": " return the \"country\" column from the circuits table as the output."
        },
        "352": {
            "condition": "When counting drivers that don't have a code",
            "operation": " calculate the total count of drivers using the canonical key \"driverId\" minus the count of drivers where \"code\" is not null."
        },
        "353": {
            "condition": "When handling null values for \"code\"",
            "operation": " use the exact condition \"code IS NOT NULL\" to identify drivers with non-null codes."
        },
        "354": {
            "condition": "When counting drivers that don't have a code, When handling null values for \"code\", When computing the difference between counts",
            "operation": " perform arithmetic subtraction between the total driver count and the count of drivers with non-null codes to get the count of drivers with null codes."
        },
        "355": {
            "condition": "When the question asks about \"country\" for drivers",
            "operation": " use the exact column token \"nationality\" from the drivers table instead of \"country\"."
        },
        "356": {
            "condition": "When filtering drivers by birth date",
            "operation": " include only rows where \"dob\" is not null using the exact condition \"dob IS NOT NULL\"."
        },
        "357": {
            "condition": "When the question asks about \"country\" for drivers, When filtering drivers by birth date, When finding the oldest driver",
            "operation": " order by the exact column \"dob\" in ascending order (oldest first) and keep only the first result using LIMIT 1."
        },
        "358": {
            "condition": "When the question asks for \"surnames\" of drivers",
            "operation": " use the exact column token \"surname\" from the drivers table."
        },
        "359": {
            "condition": "When filtering for Italian drivers",
            "operation": " use the exact literal value 'Italian' for the nationality column comparison."
        },
        "360": {
            "condition": "When the question asks for \"surnames\" of drivers, When filtering for Italian drivers, When selecting output columns",
            "operation": " ensure the output contains only the surname column as requested."
        },
        "361": {
            "condition": "When the question asks about a website for a person",
            "operation": " use the \"url\" column from the \"drivers\" table instead of \"website_url\" from \"websites\"."
        },
        "362": {
            "condition": "When filtering for a person's name",
            "operation": " split the full name into separate \"forename\" and \"surname\" columns and filter using both conditions \"forename = 'Anthony'\" and \"surname = 'Davidson'\" instead of a single \"name\" column."
        },
        "363": {
            "condition": "When the question asks about a website for a person, When filtering for a person's name, When retrieving driver information",
            "operation": " use the \"drivers\" table as the correct source instead of the \"websites\" table."
        },
        "364": {
            "condition": "When the question asks for \"reference name\"",
            "operation": " select the exact column \"driverRef\" from the drivers table."
        },
        "365": {
            "condition": "When filtering for Lewis Hamilton",
            "operation": " use both conditions \"forename = 'Lewis'\" and \"surname = 'Hamilton'\" in the WHERE clause."
        },
        "366": {
            "condition": "When the question asks for \"reference name\", When filtering for Lewis Hamilton, When the question mentions \"Lewis Hamilton's reference name\"",
            "operation": " ensure the output contains only the \"driverRef\" column with the exact literal values as stored in the database."
        },
        "367": {
            "condition": "When answering about which circuit hosted a specific Grand Prix in a specific year",
            "operation": " join the circuits table (as T1) with the races table (as T2) using an inner match where T2.circuitID equals T1.circuitId."
        },
        "368": {
            "condition": "When the question mentions a specific year like \"2009\"",
            "operation": " filter races where T2.year equals 2009."
        },
        "369": {
            "condition": "When the question mentions a specific Grand Prix name like \"Spanish Grand Prix\"",
            "operation": " filter races where T2.name equals 'Spanish Grand Prix' exactly."
        },
        "370": {
            "condition": "When answering about which circuit hosted a specific Grand Prix in a specific year, When the question mentions a specific year like \"2009\", When the question mentions a specific Grand Prix name like \"Spanish Grand Prix\", When the final output asks for the circuit name",
            "operation": " return the name column from the circuits table (T1.name)."
        },
        "371": {
            "condition": "When answering about years for a specific circuit",
            "operation": " join tables circuits AS T1 and races AS T2 using INNER JOIN with T2.circuitID = T1.circuitId."
        },
        "372": {
            "condition": "When the question mentions \"Silverstone Circuit\"",
            "operation": " filter on T1.name = 'Silverstone Circuit' exactly as written."
        },
        "373": {
            "condition": "When listing distinct years",
            "operation": " select DISTINCT T2.year from the races table."
        },
        "374": {
            "condition": "When answering about years for a specific circuit, When the question mentions \"Silverstone Circuit\", When listing distinct years, When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match)."
        },
        "375": {
            "condition": "When answering about Formula_1 races that used the Silverstone Circuit",
            "operation": " make sure the output order: T1.url"
        },
        "376": {
            "condition": "When the question mentions \"Silverstone Circuit\"",
            "operation": " \"Silverstone Circuit\" actually means \"T1.name = 'Silverstone Circuit'\" in schema"
        },
        "377": {
            "condition": "When combining circuits as T1 and races as T2",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "378": {
            "condition": "When selecting circuit URLs",
            "operation": " compute distinct values of T1.url instead of all columns"
        },
        "379": {
            "condition": "When answering about Formula_1 races that used the Silverstone Circuit, When the question mentions \"Silverstone Circuit\", When combining circuits as T1 and races as T2, When selecting circuit URLs, When filtering conditions",
            "operation": " do not include year < 2000 condition as it was removed in the amends"
        },
        "380": {
            "condition": "When answering about Formula 1 race time on Abu Dhabi Circuit",
            "operation": " make sure the output order includes both date and time columns from the races table."
        },
        "381": {
            "condition": "When the question mentions \"Abu Dhabi Circuit\"",
            "operation": " \"Abu Dhabi Circuit\" actually means \"name = 'Abu Dhabi Grand Prix'\" in the races table."
        },
        "382": {
            "condition": "When combining circuits table (T1) and races table (T2)",
            "operation": " link rows where T2.circuitID = T1.circuitId and keep only matching pairs (inner match)."
        },
        "383": {
            "condition": "When filtering for year 2010",
            "operation": " use T2.year = 2010 exactly as specified."
        },
        "384": {
            "condition": "When answering about Formula 1 race time on Abu Dhabi Circuit, When the question mentions \"Abu Dhabi Circuit\", When combining circuits table (T1) and races table (T2), When filtering for year 2010, When selecting time information",
            "operation": " retrieve both T2.date and T2.time columns from the races table."
        },
        "385": {
            "condition": "When answering about \"Formula_1 races on circuits in Italy\"",
            "operation": " make sure the output order: count of races"
        },
        "386": {
            "condition": "When combining circuits and races tables",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown; keep only matching pairs (inner match)"
        },
        "387": {
            "condition": "When filtering for circuits in Italy",
            "operation": " use T1.country = 'Italy' with exact literal 'Italy'"
        },
        "388": {
            "condition": "When answering about \"Formula_1 races on circuits in Italy\", When combining circuits and races tables, When filtering for circuits in Italy, When counting races",
            "operation": " compute the number of rows using the canonical key T2.circuitId instead of counting all rows"
        },
        "389": {
            "condition": "When answering about Formula 1 race dates on Barcelona-Catalunya circuit",
            "operation": " make sure the output order: T2.date"
        },
        "390": {
            "condition": "When the question mentions \"Barcelona-Catalunya circuit\"",
            "operation": " \"Barcelona-Catalunya\" actually means \"T1.name = 'Circuit de Barcelona-Catalunya'\" in schema"
        },
        "391": {
            "condition": "When combining T1 (circuits) and T2 (races) for shared entities",
            "operation": " link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "392": {
            "condition": "When answering about Formula 1 race dates on Barcelona-Catalunya circuit, When the question mentions \"Barcelona-Catalunya circuit\", When combining T1 (circuits) and T2 (races) for shared entities, When the question asks for Formula 1 race dates",
            "operation": " do not filter on race_type = 'Formula_1' as this filter should be removed according to the amends"
        },
        "393": {
            "condition": "When answering about website links for circuits",
            "operation": " use the exact column token \"T1.url\" instead of \"website\" for the output."
        },
        "394": {
            "condition": "When the question mentions \"Spanish Grand Prix\"",
            "operation": " use the exact literal 'Spanish Grand Prix' for filtering in \"T2.name\"."
        },
        "395": {
            "condition": "When the question specifies year 2009",
            "operation": " filter using \"T2.year = 2009\" instead of a direct year column in circuits."
        },
        "396": {
            "condition": "When combining circuit and race information",
            "operation": " perform an inner join between \"circuits AS T1\" and \"races AS T2\" using the exact key equality \"T2.circuitID = T1.circuitId\"."
        },
        "397": {
            "condition": "When answering about website links for circuits, When the question mentions \"Spanish Grand Prix\", When the question specifies year 2009, When combining circuit and race information, When the question asks about a specific Grand Prix event",
            "operation": " filter by both the race name ('Spanish Grand Prix') and year (2009) in the races table rather than using country filtering in the circuits table."
        },
        "398": {
            "condition": "When answering about \"fastest lap time ever in a race for Lewis Hamilton\"",
            "operation": " make sure the output order: T2.fastestLapTime."
        },
        "399": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " \"Lewis Hamilton\" actually means \"T1.forename = 'Lewis' AND T1.surname = 'Hamilton' in schema\"."
        },
        "400": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T2.driverId = T1.driverId; keep only matching pairs (inner match)."
        },
        "401": {
            "condition": "When handling fastest lap time values",
            "operation": " exclude rows where T2.fastestLapTime IS NOT NULL."
        },
        "402": {
            "condition": "When answering about \"fastest lap time ever in a race for Lewis Hamilton\", When the question mentions \"Lewis Hamilton\", When combining T1 and T2 for shared entities, When handling fastest lap time values, When the question asks for \"fastest\" lap time",
            "operation": " rank rows by T2.fastestLapTime in ascending order and keep the first 1 row."
        },
        "403": {
            "condition": "When answering about \"fastest lap speed in a Formula_1 race\"",
            "operation": " make sure the output order: forename, surname."
        },
        "404": {
            "condition": "When the question asks for the fastest lap speed",
            "operation": " use the \"results\" table instead of \"laptimes\" table as the data source."
        },
        "405": {
            "condition": "When combining drivers and results tables",
            "operation": " link rows where T1.driverId = T2.driverId using inner join."
        },
        "406": {
            "condition": "When filtering for valid lap speed records",
            "operation": " include only rows where T2.fastestLapTime IS NOT NULL."
        },
        "407": {
            "condition": "When ordering by fastest lap speed",
            "operation": " sort by T2.fastestLapSpeed DESC to find the maximum value."
        },
        "408": {
            "condition": "When answering about \"fastest lap speed in a Formula_1 race\", When the question asks for the fastest lap speed, When combining drivers and results tables, When filtering for valid lap speed records, When ordering by fastest lap speed, When selecting the top result",
            "operation": " take only the first row after ordering by fastest lap speed descending."
        },
        "409": {
            "condition": "When the question asks about a driver's reference name in a specific Grand Prix",
            "operation": " select T3.forename, T3.surname, and T3.driverRef as output columns."
        },
        "410": {
            "condition": "When combining race information with results",
            "operation": " join races AS T1 with results AS T2 on T2.raceId = T1.raceId using an inner match."
        },
        "411": {
            "condition": "When adding driver details to results",
            "operation": " join drivers AS T3 on T3.driverId = T2.driverId using an inner match."
        },
        "412": {
            "condition": "When filtering for a specific Grand Prix",
            "operation": " use T1.name = 'Canadian Grand Prix' exactly as written."
        },
        "413": {
            "condition": "When filtering for a specific year",
            "operation": " use T1.year = 2007."
        },
        "414": {
            "condition": "When the question asks about a driver's reference name in a specific Grand Prix, When combining race information with results, When adding driver details to results, When filtering for a specific Grand Prix, When filtering for a specific year, When identifying the first-ranked driver",
            "operation": " use T2.rank = 1 instead of ordering by position with LIMIT 1."
        },
        "415": {
            "condition": "When answering about \"Formula_1 races that Lewis Hamilton participated\"",
            "operation": " make sure the output order: T1.name."
        },
        "416": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' and T3.surname = 'Hamilton'\" in schema."
        },
        "417": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match)."
        },
        "418": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "419": {
            "condition": "When answering about \"Formula_1 races that Lewis Hamilton participated\", When the question mentions \"Lewis Hamilton\", When combining T1, T2, and T3 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Lewis' and 'Hamilton'."
        },
        "420": {
            "condition": "When the question asks about Formula_1 races",
            "operation": " use the \"name\" column from the \"races\" table to identify race names."
        },
        "421": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " this corresponds to filtering drivers where forename = 'Lewis' AND surname = 'Hamilton' in the \"drivers\" table."
        },
        "422": {
            "condition": "When finding races where a driver ranked highest",
            "operation": " use the \"rank\" column from the \"results\" table with value 1 to identify winning positions."
        },
        "423": {
            "condition": "When combining driver and race information",
            "operation": " link tables through driverId and raceId keys, matching rows where results.driverId = drivers.driverId and results.raceId = races.raceId, keeping only matching pairs (inner match)."
        },
        "424": {
            "condition": "When the question asks about Formula_1 races, When the question mentions \"Lewis Hamilton\", When finding races where a driver ranked highest, When combining driver and race information, When selecting race names for specific driver achievements",
            "operation": " use a subquery approach with raceId IN to find races where the driver achieved the specified rank condition."
        },
        "425": {
            "condition": "When answering about fastest lap speed",
            "operation": " use column \"fastestLapSpeed\" from table \"results\" instead of \"lap_time\" from \"lap_times\"."
        },
        "426": {
            "condition": "When combining races and results tables",
            "operation": " link rows where \"T2.raceId = T1.raceId\" using inner join."
        },
        "427": {
            "condition": "When filtering for the 2009 Spanish Grand Prix",
            "operation": " apply conditions \"T1.name = 'Spanish Grand Prix'\" and \"T1.year = 2009\"."
        },
        "428": {
            "condition": "When handling null values",
            "operation": " exclude rows where \"T2.fastestLapSpeed IS NOT NULL\"."
        },
        "429": {
            "condition": "When answering about fastest lap speed, When combining races and results tables, When filtering for the 2009 Spanish Grand Prix, When handling null values, When finding the maximum fastest lap speed",
            "operation": " order by \"T2.fastestLapSpeed DESC\" and take the first row instead of using MAX aggregate function."
        },
        "430": {
            "condition": "When answering about \"years Lewis Hamilton participated in Formula 1 races\"",
            "operation": " make sure the output order: T1.year."
        },
        "431": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " \"Lewis Hamilton\" actually means \"T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\" in schema."
        },
        "432": {
            "condition": "When combining T1 (races), T2 (results), and T3 (drivers) for shared entities",
            "operation": " link rows where T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match)."
        },
        "433": {
            "condition": "When answering about \"years Lewis Hamilton participated in Formula 1 races\", When the question mentions \"Lewis Hamilton\", When combining T1 (races), T2 (results), and T3 (drivers) for shared entities, When selecting the year column",
            "operation": " use T1.year instead of unqualified year to specify the table source."
        },
        "434": {
            "condition": "When answering about a driver's final rank in a specific race",
            "operation": " join races AS T1, results AS T2, and drivers AS T3 using T2.raceId = T1.raceId and T3.driverId = T2.driverId."
        },
        "435": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " use T3.forename = 'Lewis' AND T3.surname = 'Hamilton' for filtering."
        },
        "436": {
            "condition": "When the question mentions \"2008 Chinese Grand Prix\"",
            "operation": " use T1.name = 'Chinese Grand Prix' AND T1.year = 2008 for filtering."
        },
        "437": {
            "condition": "When answering about a driver's final rank in a specific race, When the question mentions \"Lewis Hamilton\", When the question mentions \"2008 Chinese Grand Prix\", When the question asks for final rank",
            "operation": " use T2.positionOrder instead of position for the result column."
        },
        "438": {
            "condition": "When answering about drivers in specific grid positions",
            "operation": " combine tables races AS T1, results AS T2, and drivers AS T3 using inner matches where T2.raceId = T1.raceId and T3.driverId = T2.driverId."
        },
        "439": {
            "condition": "When the question mentions \"grid formation\"",
            "operation": " use T2.grid = 4 to filter for the exact grid position."
        },
        "440": {
            "condition": "When the question mentions \"1989's Australian Grand Prix\"",
            "operation": " use T1.year = 1989 and T1.name = 'Australian Grand Prix' to filter for the specific race."
        },
        "441": {
            "condition": "When answering about drivers in specific grid positions, When the question mentions \"grid formation\", When the question mentions \"1989's Australian Grand Prix\", When the question asks for driver's forename and surname",
            "operation": " output T3.forename and T3.surname in that order."
        },
        "442": {
            "condition": "When counting drivers who finished a race",
            "operation": " use COUNT(T2.driverId) to count specific drivers rather than all rows."
        },
        "443": {
            "condition": "When answering about race results",
            "operation": " join races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId to properly combine race and result data."
        },
        "444": {
            "condition": "When filtering for a specific race",
            "operation": " use T1.name = 'Australian Grand Prix' and T1.year = 2008 to match the exact race name and year."
        },
        "445": {
            "condition": "When counting drivers who finished a race, When answering about race results, When filtering for a specific race, When identifying finished drivers",
            "operation": " use T2.time IS NOT NULL instead of position checks to properly identify drivers who completed the race."
        },
        "446": {
            "condition": "When answering about the fastest lap for a driver in a specific race",
            "operation": " use T1.fastestLapTime instead of MIN(lap_time) for the fastest lap value."
        },
        "447": {
            "condition": "When querying lap time data",
            "operation": " join results AS T1 instead of querying lap_times directly."
        },
        "448": {
            "condition": "When filtering by race",
            "operation": " join races AS T2 with condition T1.raceId = T2.raceId and filter with T2.name = 'Australian Grand Prix' AND T2.year = 2008 instead of race = '2008 Australian Grand Prix'."
        },
        "449": {
            "condition": "When answering about the fastest lap for a driver in a specific race, When querying lap time data, When filtering by race, When filtering by driver",
            "operation": " join drivers AS T3 with condition T1.driverId = T3.driverId and filter with T3.forename = 'Lewis' AND T3.surname = 'Hamilton' instead of driver = 'Lewis Hamilton'."
        },
        "450": {
            "condition": "When the question asks for \"fastest lap\" data",
            "operation": " use the exact column token \"fastestLap\" from table results (T1) instead of \"fastestLapTime\"."
        },
        "451": {
            "condition": "When joining tables results, races, and drivers",
            "operation": " use explicit INNER JOIN syntax to link T1.raceId = T2.raceId and T1.driverId = T3.driverId."
        },
        "452": {
            "condition": "When the question asks for \"fastest lap\" data, When joining tables results, races, and drivers, When filtering for Lewis Hamilton in the 2008 Australian Grand Prix",
            "operation": " match T2.name exactly to 'Australian Grand Prix', T2.year exactly to 2008, T3.forename exactly to 'Lewis', and T3.surname exactly to 'Hamilton'."
        },
        "453": {
            "condition": "When answering about finish time for a driver",
            "operation": " use T1.time from the results table instead of finish_time from races table."
        },
        "454": {
            "condition": "When combining results and races tables",
            "operation": " join T1 (results) with T2 (races) on T1.raceId = T2.raceId using inner match."
        },
        "455": {
            "condition": "When filtering for a specific rank position",
            "operation": " use T1.rank = 2 instead of ordering and offsetting."
        },
        "456": {
            "condition": "When filtering for a specific race name",
            "operation": " use T2.name = 'Chinese Grand Prix' instead of 'Australian Grand Prix'."
        },
        "457": {
            "condition": "When filtering for a specific year",
            "operation": " use T2.year = 2008."
        },
        "458": {
            "condition": "When answering about finish time for a driver, When combining results and races tables, When filtering for a specific rank position, When filtering for a specific race name, When filtering for a specific year, When the question asks for second ranked driver",
            "operation": " do not use ORDER BY and LIMIT/OFFSET clauses, filter directly by rank value instead."
        },
        "459": {
            "condition": "When answering about the champion of a specific Grand Prix",
            "operation": " select forename, surname, and url instead of driver_name and biography_url."
        },
        "460": {
            "condition": "When combining driver and race information",
            "operation": " join drivers AS T1 with results AS T2 on T1.driverId = T2.driverId, then join races AS T3 on T3.raceId = T2.raceId."
        },
        "461": {
            "condition": "When filtering for a specific Grand Prix and year",
            "operation": " use T3.name = 'Australian Grand Prix' and T3.year = 2008 instead of direct column filters."
        },
        "462": {
            "condition": "When answering about the champion of a specific Grand Prix, When combining driver and race information, When filtering for a specific Grand Prix and year, When identifying race winners",
            "operation": " filter using T2.time LIKE '_:%:__.___' instead of position = 1 to correctly identify winners by time rather than position."
        },
        "463": {
            "condition": "When answering about drivers participating in a specific race",
            "operation": " join \"drivers AS T1\" with \"results AS T2\" on T1.driverId = T2.driverId to connect drivers to their race participations."
        },
        "464": {
            "condition": "When connecting race participations to specific race events",
            "operation": " join \"results AS T2\" with \"races AS T3\" on T3.raceId = T2.raceId to access race details."
        },
        "465": {
            "condition": "When filtering for a specific race name",
            "operation": " use T3.name = 'Australian Grand Prix' instead of non-existent race_name column."
        },
        "466": {
            "condition": "When filtering for driver nationality",
            "operation": " use T1.nationality = 'British' instead of 'UN' as specified in the question correction."
        },
        "467": {
            "condition": "When filtering for race year",
            "operation": " use T3.year = 2008 instead of non-existent race_year column."
        },
        "468": {
            "condition": "When answering about drivers participating in a specific race, When connecting race participations to specific race events, When filtering for a specific race name, When filtering for driver nationality, When filtering for race year, When counting drivers from a specific nationality in a specific race",
            "operation": " count the number of matching rows using the driver-race connection established through the joins."
        },
        "469": {
            "condition": "When answering about drivers who finished a specific race",
            "operation": " combine results table (T1) with races table (T2) by matching T1.raceId = T2.raceId to get race details."
        },
        "470": {
            "condition": "When the question mentions \"2008 Chinese Grand Prix\"",
            "operation": " filter for T2.year = 2008 and T2.name = 'Chinese Grand Prix' exactly."
        },
        "471": {
            "condition": "When identifying drivers who finished the race",
            "operation": " check T1.time IS NOT NULL to confirm completion."
        },
        "472": {
            "condition": "When counting drivers who participated in Formula 1 races",
            "operation": " group by T1.driverId and verify participation with HAVING COUNT(T2.raceId) > 0."
        },
        "473": {
            "condition": "When answering about drivers who finished a specific race, When the question mentions \"2008 Chinese Grand Prix\", When identifying drivers who finished the race, When counting drivers who participated in Formula 1 races, When producing the final count",
            "operation": " use COUNT(*) on the grouped results rather than COUNT(DISTINCT driver_id) since grouping ensures uniqueness."
        },
        "474": {
            "condition": "When answering about \"points Lewis Hamilton got in Formula 1 races\"",
            "operation": " join tables \"drivers AS T1\" and \"results AS T2\" where T1.driverId equals T2.driverId to link driver information with race results."
        },
        "475": {
            "condition": "When filtering for Lewis Hamilton",
            "operation": " use T1.forename = 'Lewis' and T1.surname = 'Hamilton' instead of a single driver field."
        },
        "476": {
            "condition": "When answering about \"points Lewis Hamilton got in Formula 1 races\", When filtering for Lewis Hamilton, When calculating total points",
            "operation": " sum T2.points from the results table after joining with the filtered driver information."
        },
        "477": {
            "condition": "When answering about Formula 1 races and drivers",
            "operation": " combine tables \"drivers\" as T1 and \"results\" as T2 using inner match where T1.driverId equals T2.driverId."
        },
        "478": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " filter using both T1.forename = 'Lewis' and T1.surname = 'Hamilton' to match the driver's full name."
        },
        "479": {
            "condition": "When handling fastest lap time in seconds",
            "operation": " convert the colon-separated time format using CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') -"
        },
        "480": {
            "condition": "AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, '",
            "operation": "') +"
        },
        "481": {
            "condition": "AS REAL) to properly calculate seconds instead of using the raw string value.",
            "operation": "AS REAL) to properly calculate seconds instead of using the raw string value."
        },
        "482": {
            "condition": "When answering about Formula 1 races and drivers, When the question mentions \"Lewis Hamilton\", When handling fastest lap time in seconds, AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ', AS REAL) to properly calculate seconds instead of using the raw string value., When computing average fastest lap time",
            "operation": " calculate the average of the converted time values in seconds."
        },
        "483": {
            "condition": "When answering about driver completion rate in a specific race",
            "operation": " use SUM(IIF(T1.time IS NOT NULL, 1, 0)) to count drivers who completed all laps based on time presence instead of counting distinct driver IDs."
        },
        "484": {
            "condition": "When filtering for a specific race year and name",
            "operation": " join races AS T2 with INNER JOIN on T1.raceId = T2.raceId and apply conditions T2.year = 2008 and T2.name = 'Australian Grand Prix' in the WHERE clause instead of using a subquery."
        },
        "485": {
            "condition": "When calculating the denominator for completion rate",
            "operation": " use COUNT(T1.resultId) instead of COUNT(*) to count all race entries."
        },
        "486": {
            "condition": "When calculating percentage rates",
            "operation": " explicitly cast to REAL instead of relying on implicit conversion."
        },
        "487": {
            "condition": "When answering about driver completion rate in a specific race, When filtering for a specific race year and name, When calculating the denominator for completion rate, When calculating percentage rates, When determining race completion",
            "operation": " do not use position IS NOT NULL filter as completion is correctly determined by time presence."
        },
        "488": {
            "condition": "When joining race data",
            "operation": " combine \"results\" table (T1) with \"races\" table (T2) using the exact key equality T1.\"raceId\" = T2.\"raceId\" and keep only matching pairs (inner match)."
        },
        "489": {
            "condition": "When filtering for the 2008 Australian Grand Prix",
            "operation": " apply both conditions T2.\"year\" = 2008 AND T2.\"name\" = 'Australian Grand Prix' exactly as specified."
        },
        "490": {
            "condition": "When converting time strings to seconds",
            "operation": " use SUBSTR and CAST operations to handle different time formats instead of assuming numeric values."
        },
        "491": {
            "condition": "When handling different time formats",
            "operation": " use a CASE statement based on T1.\"positionOrder\" to process time values appropriately."
        },
        "492": {
            "condition": "When checking for valid time data",
            "operation": " ensure T1.\"time\" IS NOT NULL to handle missing values properly."
        },
        "493": {
            "condition": "When calculating percentage difference between champion and last driver",
            "operation": " compute (champion_time - last_driver_time) / last_driver_time * 100 using the exact time values in seconds."
        },
        "494": {
            "condition": "When identifying the champion",
            "operation": " use the driver with T1.\"positionOrder\" = 1 (lowest position order value)."
        },
        "495": {
            "condition": "When joining race data, When filtering for the 2008 Australian Grand Prix, When converting time strings to seconds, When handling different time formats, When checking for valid time data, When calculating percentage difference between champion and last driver, When identifying the champion, When identifying the last driver",
            "operation": " use the driver with the highest T1.\"positionOrder\" value that completed the race."
        },
        "496": {
            "condition": "When handling time format conversions",
            "operation": " use a simplified CASE expression that handles only two specific time formats instead of complex nested string parsing with multiple INSTR functions."
        },
        "497": {
            "condition": "When referencing time column values",
            "operation": " reference the time column directly with specific substring positions instead of using dynamic position calculations."
        },
        "498": {
            "condition": "When selecting columns for intermediate results",
            "operation": " remove unused columns like driverId from the SELECT list since they're not used in subsequent calculations."
        },
        "499": {
            "condition": "When combining tables",
            "operation": " use explicit INNER JOIN syntax instead of comma-separated FROM clauses."
        },
        "500": {
            "condition": "When calculating percentage differences between times",
            "operation": " use proper division and addition operations instead of incorrect subtraction-based formulas for percentage calculations."
        },
        "501": {
            "condition": "When handling time format conversions, When referencing time column values, When selecting columns for intermediate results, When combining tables, When calculating percentage differences between times, When handling numeric results",
            "operation": " cast the final result explicitly to ensure proper numeric handling instead of relying on implicit casting."
        },
        "502": {
            "condition": "When parsing time values from T1.time",
            "operation": " for champion positions (positionOrder = 1), extract hours using SUBSTR(T1.time, 1, 1), minutes using SUBSTR(T1.time, 3, 2), and seconds using SUBSTR(T1.time, 6); for other positions, extract seconds using CAST(SUBSTR(T1.time,"
        },
        "503": {
            "condition": "AS REAL).",
            "operation": "AS REAL)."
        },
        "504": {
            "condition": "When combining T1 and T2 for race information",
            "operation": " link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match)."
        },
        "505": {
            "condition": "When filtering for the 2008 Australian Grand Prix",
            "operation": " use T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL."
        },
        "506": {
            "condition": "When calculating percentage difference between champion and last driver",
            "operation": " use the formula (last_driver_time *"
        },
        "507": {
            "condition": "When parsing time values from T1.time, AS REAL)., When combining T1 and T2 for race information, When filtering for the 2008 Australian Grand Prix, When calculating percentage difference between champion and last driver, / (champion_time + last_driver_time) instead of the standard percentage difference formula.",
            "operation": "When parsing time values from T1.time, AS REAL)., When combining T1 and T2 for race information, When filtering for the 2008 Australian Grand Prix, When calculating percentage difference between champion and last driver, / (champion_time + last_driver_time) instead of the standard percentage difference formula."
        },
        "508": {
            "condition": "When counting circuits",
            "operation": " count non-null values of \"circuitId\" instead of counting all rows to exclude null values from the count."
        },
        "509": {
            "condition": "When filtering for circuits in Adelaide, Australia",
            "operation": " use the \"location\" column instead of \"city\" to match the correct column name that contains Adelaide location data."
        },
        "510": {
            "condition": "When counting circuits, When filtering for circuits in Adelaide, Australia, When the question asks about circuits in a specific location",
            "operation": " filter using exact string literals 'Adelaide' and 'Australia' with the correct case and spacing."
        },
        "511": {
            "condition": "When the question asks for location coordinates",
            "operation": " use the exact column names \"lat\" and \"lng\" instead of \"latitude\" and \"longitude\" from the circuits table"
        },
        "512": {
            "condition": "When the question asks for circuits in the US",
            "operation": " use the country code 'USA' instead of 'US' to match the ISO country code format in the WHERE filter"
        },
        "513": {
            "condition": "When counting drivers",
            "operation": " use COUNT(driverId) to count specific driver identifiers rather than all rows."
        },
        "514": {
            "condition": "When filtering by date of birth",
            "operation": " reference the column dob instead of date_of_birth."
        },
        "515": {
            "condition": "When counting drivers, When filtering by date of birth, When filtering for drivers born after 1980",
            "operation": " apply STRFTIME('%Y', dob) > '1980' to extract the year component and correctly identify drivers born in years greater than 1980 rather than using date comparison."
        },
        "516": {
            "condition": "When answering about maximum points of British constructors",
            "operation": " make sure to join constructorStandings as T1 and constructors as T2 on T1.constructorId = T2.constructorId to link constructor standings with their constructor details."
        },
        "517": {
            "condition": "When filtering for British constructors",
            "operation": " use T2.nationality = 'British' exactly as specified, with the literal 'British' matching case and spelling."
        },
        "518": {
            "condition": "When calculating maximum points",
            "operation": " select MAX(T1.points) from the constructorStandings table (T1) rather than from the constructors table, as points data resides in constructorStandings."
        },
        "519": {
            "condition": "When answering about maximum points of British constructors, When filtering for British constructors, When calculating maximum points, When combining tables for this query",
            "operation": " perform an inner match where T1.constructorId = T2.constructorId to keep only matching pairs of constructor standings and constructor details."
        },
        "520": {
            "condition": "When answering about \"which constructor has the highest point\"",
            "operation": " make sure the output order: T2.name."
        },
        "521": {
            "condition": "When the question mentions \"constructor\"",
            "operation": " \"constructor\" actually means \"T2.name in schema\"."
        },
        "522": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.constructorId = T2.constructorId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "523": {
            "condition": "When the question mentions \"highest\" point",
            "operation": " rank rows by T1.points in descending order and keep the first 1 row."
        },
        "524": {
            "condition": "When answering about \"which constructor has the highest point\", When the question mentions \"constructor\", When combining T1 and T2 for shared entities, When the question mentions \"highest\" point, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "525": {
            "condition": "When answering about constructor names with 0 points at a specific race",
            "operation": " make sure the output order: T2.name."
        },
        "526": {
            "condition": "When the question mentions \"constructor names\"",
            "operation": " \"constructor names\" actually means \"T2.name in schema\"."
        },
        "527": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.constructorId = T2.constructorId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "528": {
            "condition": "When answering about constructor names with 0 points at a specific race, When the question mentions \"constructor names\", When combining T1 and T2 for shared entities, When filtering for 0 points at race 291",
            "operation": " filter on T1.points = 0 and T1.raceId = 291 from the constructorStandings table instead of filtering directly on the constructors table."
        },
        "529": {
            "condition": "When answering about Japanese constructors with 0 points in 2 races",
            "operation": " join \"constructorStandings\" as T1 and \"constructors\" as T2 where T1.\"constructorId\" = T2.\"constructorId\" and keep only matching pairs (inner match)."
        },
        "530": {
            "condition": "When filtering by nationality",
            "operation": " use T2.\"nationality\" = 'Japanese' exactly as specified."
        },
        "531": {
            "condition": "When filtering by points",
            "operation": " use T1.\"points\" = 0 exactly as specified."
        },
        "532": {
            "condition": "When counting races",
            "operation": " count unique T1.\"raceId\" values per constructor."
        },
        "533": {
            "condition": "When requiring exactly 2 races",
            "operation": " ensure the count of T1.\"raceId\" equals 2."
        },
        "534": {
            "condition": "When answering about Japanese constructors with 0 points in 2 races, When filtering by nationality, When filtering by points, When counting races, When requiring exactly 2 races, When producing the final count",
            "operation": " count the number of distinct T1.\"constructorId\" values that satisfy all conditions."
        },
        "535": {
            "condition": "When answering about \"Japanese constructors with 0 points in 2 races\"",
            "operation": " make sure the output order: count of constructors meeting the criteria."
        },
        "536": {
            "condition": "When the question mentions \"Japanese\"",
            "operation": " \"Japanese\" actually means \"T2.nationality = 'Japanese'\" in schema."
        },
        "537": {
            "condition": "When the question mentions \"0 points\"",
            "operation": " \"0 points\" actually means \"T1.points = 0\" in schema."
        },
        "538": {
            "condition": "When the question asks for \"count of constructors\"",
            "operation": " compute the number of rows using the canonical key token T1.constructorId."
        },
        "539": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.constructorId = T2.constructorId; keep only matching pairs (inner match)."
        },
        "540": {
            "condition": "When the question asks for \"in 2 races\"",
            "operation": " ensure the count of T1.raceId equals 2 for each constructor group."
        },
        "541": {
            "condition": "When answering about \"Japanese constructors with 0 points in 2 races\", When the question mentions \"Japanese\", When the question mentions \"0 points\", When the question asks for \"count of constructors\", When combining T1 and T2 for shared entities, When the question asks for \"in 2 races\", When grouping by constructor",
            "operation": " organize results by T1.constructorId and compute COUNT(T1.raceId) per group, then filter to groups where this count equals exactly 2."
        },
        "542": {
            "condition": "When answering about \"constructors ranked 1\"",
            "operation": " make sure the output order: T2.name."
        },
        "543": {
            "condition": "When the question mentions \"constructors\"",
            "operation": " \"constructors\" actually means \"T2.name in schema\"."
        },
        "544": {
            "condition": "When combining T1 (results) and T2 (constructors) for shared entities",
            "operation": " link rows where T1.constructorId = T2.constructorId exactly as shown; keep only matching pairs (inner match)."
        },
        "545": {
            "condition": "When filtering for rank 1",
            "operation": " use T1.rank = 1 with integer comparison instead of string comparison."
        },
        "546": {
            "condition": "When answering about \"constructors ranked 1\", When the question mentions \"constructors\", When combining T1 (results) and T2 (constructors) for shared entities, When filtering for rank 1, When selecting constructor names",
            "operation": " use DISTINCT T2.name instead of selecting all columns without distinct."
        },
        "547": {
            "condition": "When counting constructors",
            "operation": " use COUNT(DISTINCT T2.constructorId) instead of COUNT(*) to count unique constructors rather than all rows."
        },
        "548": {
            "condition": "When accessing both constructor and race results data",
            "operation": " join results AS T1 INNER JOIN constructors AS T2 using the condition T1.constructorId = T2.constructorId instead of querying only the constructors table."
        },
        "549": {
            "condition": "When filtering by lap count",
            "operation": " apply the laps > 50 filter to the results table (T1.laps >"
        },
        "550": {
            "condition": "instead of the constructors table since laps data belongs to race results.",
            "operation": "instead of the constructors table since laps data belongs to race results."
        },
        "551": {
            "condition": "When counting constructors, When accessing both constructor and race results data, When filtering by lap count, instead of the constructors table since laps data belongs to race results., When filtering by nationality",
            "operation": " apply the nationality = 'French' filter to the constructors table (T2.nationality = 'French') using the exact literal 'French'."
        },
        "552": {
            "condition": "When calculating race completion percentage for Japanese drivers",
            "operation": " use SUM(IIF(T1.time IS NOT NULL, 1, 0)) to count completed races based on time presence rather than position."
        },
        "553": {
            "condition": "When computing completion percentage",
            "operation": " multiply the completed race count by 100 and divide by COUNT(T1.raceId) instead of using a subquery for total races."
        },
        "554": {
            "condition": "When determining race completion",
            "operation": " check T1.time IS NOT NULL instead of position being not null."
        },
        "555": {
            "condition": "When combining tables for this analysis",
            "operation": " use consistent table aliases T1, T2, and T3 as established in the schema relationships."
        },
        "556": {
            "condition": "When filtering for Japanese drivers",
            "operation": " use the exact literal 'Japanese' for nationality comparison."
        },
        "557": {
            "condition": "When calculating race completion percentage for Japanese drivers, When computing completion percentage, When determining race completion, When combining tables for this analysis, When filtering for Japanese drivers, When filtering for years 2007 to 2009",
            "operation": " use inclusive range BETWEEN 2007 AND 2009."
        },
        "558": {
            "condition": "When calculating a single aggregate value across multiple years instead of per-year breakdowns",
            "operation": " remove the year column from both the SELECT list and GROUP BY clause."
        },
        "559": {
            "condition": "When computing percentage calculations that require decimal precision",
            "operation": " cast the numerator to REAL type before division to ensure proper decimal results."
        },
        "560": {
            "condition": "When the result is a single scalar value without grouping",
            "operation": " remove the ORDER BY clause as no ordering is needed."
        },
        "561": {
            "condition": "When calculating a single aggregate value across multiple years instead of per-year breakdowns, When computing percentage calculations that require decimal precision, When the result is a single scalar value without grouping, When joining tables for clarity",
            "operation": " use explicit INNER JOIN syntax instead of just JOIN."
        },
        "562": {
            "condition": "When answering about \"average time in seconds of champion for each year\"",
            "operation": " make sure the output order: year, average time in seconds."
        },
        "563": {
            "condition": "When the question mentions \"champion\"",
            "operation": " \"champion\" actually means \"positionOrder = 1\" in the schema."
        },
        "564": {
            "condition": "When the question mentions \"time in seconds\"",
            "operation": " calculate time conversion using CASE WHEN T1.positionOrder = 1 THEN with substring parsing instead of assuming pre-calculated time_seconds."
        },
        "565": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.raceId = T2.raceId exactly as shown; keep only matching pairs (inner match)."
        },
        "566": {
            "condition": "When the question asks for \"before year 1975\"",
            "operation": " filter for year < 1975."
        },
        "567": {
            "condition": "When the question says \"for each year\"",
            "operation": " organize results by year and compute average time per year."
        },
        "568": {
            "condition": "When computing averages",
            "operation": " exclude null averages by adding HAVING AVG(time_seconds) IS NOT NULL."
        },
        "569": {
            "condition": "When answering about \"average time in seconds of champion for each year\", When the question mentions \"champion\", When the question mentions \"time in seconds\", When combining T1 and T2 for shared entities, When the question asks for \"before year 1975\", When the question says \"for each year\", When computing averages, When producing output",
            "operation": " do not use aliases like \"as avg_time\" in the final SELECT."
        },
        "570": {
            "condition": "When parsing time values from \"T1.time\"",
            "operation": " use fixed position SUBSTR operations with specific offsets instead of dynamic instr-based parsing."
        },
        "571": {
            "condition": "When filtering for champion results",
            "operation": " filter by \"T1.positionOrder = 1\" in the aggregation phase instead of the initial data extraction phase."
        },
        "572": {
            "condition": "When handling time data",
            "operation": " include \"T1.time IS NOT NULL\" filter to exclude null time values."
        },
        "573": {
            "condition": "When filtering by year",
            "operation": " apply \"T2.year < 1975\" filter in the final query instead of in intermediate CTEs."
        },
        "574": {
            "condition": "When calculating average champion time",
            "operation": " compute AVG(time_seconds) directly in the main SELECT instead of pre-aggregating in a CTE."
        },
        "575": {
            "condition": "When parsing time values from \"T1.time\", When filtering for champion results, When handling time data, When filtering by year, When calculating average champion time, When selecting columns",
            "operation": " include both \"T2.raceId\" and \"T1.positionOrder\" in the SELECT list instead of omitting them."
        },
        "576": {
            "condition": "When parsing time values in format 'H",
            "operation": "MM:SS.mmm': extract hours using SUBSTR(T1.time, 1,"
        },
        "577": {
            "condition": "for single-digit hours, minutes using SUBSTR(T1.time, 3, 2), seconds using SUBSTR(T1.time, 6, 2), and milliseconds using SUBSTR(T1.time,",
            "operation": "for single-digit hours, minutes using SUBSTR(T1.time, 3, 2), seconds using SUBSTR(T1.time, 6, 2), and milliseconds using SUBSTR(T1.time,"
        },
        "578": {
            "condition": "divided by 1000.",
            "operation": "divided by 1000."
        },
        "579": {
            "condition": "When calculating time in seconds for champion positions",
            "operation": " use CASE WHEN T1.positionOrder = 1 THEN to convert time format to seconds, not including redundant time IS NOT NULL checks."
        },
        "580": {
            "condition": "When handling non-winning positions",
            "operation": " provide a default value of 0 instead of NULL for time_seconds calculation."
        },
        "581": {
            "condition": "When selecting columns for time calculation",
            "operation": " do not include the raw T1.time column in the output, only include the calculated time_seconds."
        },
        "582": {
            "condition": "When parsing time values in format 'H, for single-digit hours, minutes using SUBSTR(T1.time, 3, 2), seconds using SUBSTR(T1.time, 6, 2), and milliseconds using SUBSTR(T1.time,, divided by 1000., When calculating time in seconds for champion positions, When handling non-winning positions, When selecting columns for time calculation, When the question asks for average time of champions per year before 1975",
            "operation": " group results by year and compute average of time_seconds where year < 1975, filtering out NULL averages."
        },
        "583": {
            "condition": "When answering about drivers ranked 2",
            "operation": " join table \"results\" as T1 with table \"drivers\" as T2 on T1.driverId = T2.driverId to combine race results with driver information."
        },
        "584": {
            "condition": "When the question mentions \"born after 1975\"",
            "operation": " use STRFTIME('%Y', T2.dob) to extract the year from the date of birth and compare it to be greater than 1975."
        },
        "585": {
            "condition": "When the question mentions \"ranked 2\"",
            "operation": " filter on T1.rank = 2 instead of position = 2."
        },
        "586": {
            "condition": "When selecting driver names",
            "operation": " reference columns as T2.forename and T2.surname to specify the correct table source."
        },
        "587": {
            "condition": "When answering about drivers ranked 2, When the question mentions \"born after 1975\", When the question mentions \"ranked 2\", When selecting driver names, When combining results and drivers tables",
            "operation": " perform an inner join where T1.driverId = T2.driverId to keep only matching driver-result pairs."
        },
        "588": {
            "condition": "When answering about \"Italian drivers who haven't finished the race\"",
            "operation": " make sure the output order: COUNT(T1.driverId)."
        },
        "589": {
            "condition": "When the question mentions \"Italian drivers\"",
            "operation": " \"Italian\" actually means \"T2.nationality = 'Italian'\" in schema."
        },
        "590": {
            "condition": "When the question mentions \"haven't finished the race\"",
            "operation": " this actually means \"T1.time IS NULL\" in schema."
        },
        "591": {
            "condition": "When combining T1 (results) and T2 (drivers) for shared entities",
            "operation": " link rows where T1.driverId = T2.driverId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "592": {
            "condition": "When answering about \"Italian drivers who haven't finished the race\", When the question mentions \"Italian drivers\", When the question mentions \"haven't finished the race\", When combining T1 (results) and T2 (drivers) for shared entities, When counting drivers",
            "operation": " compute the number of rows using the canonical key token T1.driverId rather than counting all rows."
        },
        "593": {
            "condition": "When answering about \"fastest lap time\"",
            "operation": " make sure the output order includes T1.fastestLapTime as the first column."
        },
        "594": {
            "condition": "When the question mentions \"driver\"",
            "operation": " use results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId to combine driver information with lap time results."
        },
        "595": {
            "condition": "When filtering for valid lap times",
            "operation": " include WHERE T1.fastestLapTime IS NOT NULL to exclude null values."
        },
        "596": {
            "condition": "When ordering by fastest lap time",
            "operation": " use T1.fastestLapTime ASC to find the smallest (fastest) time."
        },
        "597": {
            "condition": "When answering about \"fastest lap time\", When the question mentions \"driver\", When filtering for valid lap times, When ordering by fastest lap time, When selecting driver names",
            "operation": " include both T2.forename and T2.surname from the joined drivers table."
        },
        "598": {
            "condition": "When answering about \"fastest lap number of the champion in 2009\"",
            "operation": " make sure the output order: T1.fastestLap"
        },
        "599": {
            "condition": "When the question mentions \"champion\"",
            "operation": " \"champion\" actually means \"race winners identified by time format '_:%:__.___' in schema\""
        },
        "600": {
            "condition": "When combining T1 (results) and T2 (races) for shared entities",
            "operation": " link rows where T1.raceId = T2.raceId; keep only matching pairs (inner match)"
        },
        "601": {
            "condition": "When filtering for year 2009",
            "operation": " use T2.year = 2009 with proper table qualification"
        },
        "602": {
            "condition": "When answering about \"fastest lap number of the champion in 2009\", When the question mentions \"champion\", When combining T1 (results) and T2 (races) for shared entities, When filtering for year 2009, When identifying race winners",
            "operation": " use T1.time LIKE '_:%:__.___' instead of position-based filtering to correctly identify champions"
        },
        "603": {
            "condition": "When the question asks for the fastest lap number of the champion in 2009",
            "operation": " use the exact column token \"fastestLap\" from table \"results\" with alias T1."
        },
        "604": {
            "condition": "When combining tables \"results\" and \"races\"",
            "operation": " link rows where T1.raceId = T2.raceId using inner join and keep only matching pairs."
        },
        "605": {
            "condition": "When filtering for the year 2009",
            "operation": " use the exact literal value 2009 with column T2.year."
        },
        "606": {
            "condition": "When identifying champion results",
            "operation": " filter using T1.time LIKE '_:%:__.___' to match time patterns indicating winning positions."
        },
        "607": {
            "condition": "When the question asks for the fastest lap number of the champion in 2009, When combining tables \"results\" and \"races\", When filtering for the year 2009, When identifying champion results, When the question asks for a single fastest lap number",
            "operation": " do not apply ordering or limiting clauses as the champion's result should naturally be the fastest lap among winning entries."
        },
        "608": {
            "condition": "When answering about average fastest lap speed for a specific race",
            "operation": " join results AS T1 with races AS T2 on T1.raceId = T2.raceId to combine race information with lap speed data."
        },
        "609": {
            "condition": "When the question mentions \"fastest lap speed\"",
            "operation": " \"fastest lap speed\" actually means T1.fastestLapSpeed in the results table."
        },
        "610": {
            "condition": "When filtering for the 2009 Spanish Grand Prix race",
            "operation": " apply year filter to T2.year = 2009 and name filter to T2.name = 'Spanish Grand Prix' exactly as specified."
        },
        "611": {
            "condition": "When answering about average fastest lap speed for a specific race, When the question mentions \"fastest lap speed\", When filtering for the 2009 Spanish Grand Prix race, When computing the average",
            "operation": " calculate AVG(T1.fastestLapSpeed) from the joined results to get the correct average fastest lap speed."
        },
        "612": {
            "condition": "When answering about \"race with shortest actual finishing time\"",
            "operation": " make sure the output order: T1.name, T1.year."
        },
        "613": {
            "condition": "When combining races and results tables",
            "operation": " link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match)."
        },
        "614": {
            "condition": "When filtering for valid timing information",
            "operation": " include only rows where T2.milliseconds IS NOT NULL."
        },
        "615": {
            "condition": "When ordering by finishing time",
            "operation": " sort by T2.milliseconds in ascending order to find the shortest time."
        },
        "616": {
            "condition": "When answering about \"race with shortest actual finishing time\", When combining races and results tables, When filtering for valid timing information, When ordering by finishing time, When selecting the fastest race",
            "operation": " take only the first row after ordering by T2.milliseconds ascending."
        },
        "617": {
            "condition": "When answering about percentage of drivers born before 1985 with laps over 50 from 2000 to 2005",
            "operation": " use SUM(IIF(condition, 1, 0)) instead of COUNT(DISTINCT CASE WHEN condition THEN id END) for conditional counting."
        },
        "618": {
            "condition": "When combining tables for races between 2000 and 2005",
            "operation": " join with races table on raceId and use the year column from races instead of results in the WHERE filter."
        },
        "619": {
            "condition": "When checking lap numbers",
            "operation": " reference laps column from results table instead of lap from laptimes table, and remove unnecessary join to laptimes table."
        },
        "620": {
            "condition": "When calculating denominator for percentage",
            "operation": " use COUNT(*) instead of COUNT(DISTINCT driverId)."
        },
        "621": {
            "condition": "When calculating percentage",
            "operation": " add explicit CAST to REAL instead of using decimal notation."
        },
        "622": {
            "condition": "When answering about percentage of drivers born before 1985 with laps over 50 from 2000 to 2005, When combining tables for races between 2000 and 2005, When checking lap numbers, When calculating denominator for percentage, When calculating percentage, When checking driver birth year",
            "operation": " use STRFTIME('%Y', dob) for year extraction instead of direct date comparison with dob < '1985-01-01'."
        },
        "623": {
            "condition": "When answering about French drivers with laptime less than 02",
            "operation": "00.00: make sure to join the lapTimes table as T2 with drivers table as T1 using T1.driverId = T2.driverId to access laptime data."
        },
        "624": {
            "condition": "When counting French drivers",
            "operation": " use COUNT(T1.driverId) to count distinct drivers instead of COUNT(*)."
        },
        "625": {
            "condition": "When filtering laptime less than 02",
            "operation": "00.00: convert the time string format using (CAST(SUBSTR(T2.time, 1,"
        },
        "626": {
            "condition": "AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4,",
            "operation": "AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4,"
        },
        "627": {
            "condition": "AS INTEGER) + CAST(SUBSTR(T2.time, 7,",
            "operation": "AS INTEGER) + CAST(SUBSTR(T2.time, 7,"
        },
        "628": {
            "condition": "AS REAL) /",
            "operation": "AS REAL) /"
        },
        "629": {
            "condition": "< 120 to properly parse and compare time values numerically.",
            "operation": "< 120 to properly parse and compare time values numerically."
        },
        "630": {
            "condition": "When answering about French drivers with laptime less than 02, When counting French drivers, When filtering laptime less than 02, AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4,, AS INTEGER) + CAST(SUBSTR(T2.time, 7,, AS REAL) /, < 120 to properly parse and compare time values numerically., When filtering by nationality",
            "operation": " use nationality = 'French' with exact case and quotes as shown."
        },
        "631": {
            "condition": "When counting French drivers with qualifying lap times",
            "operation": " use COUNT(T1.driverId) without DISTINCT since the join condition ensures unique driver IDs are counted correctly."
        },
        "632": {
            "condition": "When filtering for French nationality",
            "operation": " use T1.nationality = 'French' with exact case and quotes."
        },
        "633": {
            "condition": "When counting French drivers with qualifying lap times, When filtering for French nationality, When filtering for lap times less than 02",
            "operation": "00.00: convert the time format to total seconds and compare against 120 seconds using the exact conversion logic shown in the query."
        },
        "634": {
            "condition": "When the question asks for \"Id number of races\"",
            "operation": " use the exact column token \"raceId\" from the results table instead of \"Id\"."
        },
        "635": {
            "condition": "When the question asks for \"Id number of races\", When filtering races by year",
            "operation": " use the exact literal value \"2009\" as specified in the question, not \"2008\"."
        },
        "636": {
            "condition": "When answering about \"how many drivers participated in race ID number 18\"",
            "operation": " make sure the output order: COUNT(driverId) from driverStandings table."
        },
        "637": {
            "condition": "When the question mentions \"race ID number 18\"",
            "operation": " \"race ID number 18\" actually means \"raceId = 18\" in schema."
        },
        "638": {
            "condition": "When counting drivers",
            "operation": " use driverId as the counting key from driverStandings table, not COUNT(*) from drivers table."
        },
        "639": {
            "condition": "When answering about \"how many drivers participated in race ID number 18\", When the question mentions \"race ID number 18\", When counting drivers, When filtering by race",
            "operation": " use the exact column name raceId with value 18, not race_id."
        },
        "640": {
            "condition": "When the question asks for \"top 3 youngest drivers\"",
            "operation": " rank drivers by JULIANDAY(dob) in descending order (most recent birth dates first) and keep the first 3 rows."
        },
        "641": {
            "condition": "When the question mentions \"Netherlandic drivers\"",
            "operation": " \"Netherlandic\" actually means \"Dutch\" in the schema, so use nationality = 'Dutch' exactly."
        },
        "642": {
            "condition": "When counting how many drivers among the top 3 youngest have Dutch nationality",
            "operation": " count the number of rows where nationality = 'Dutch' within the selected top 3 drivers."
        },
        "643": {
            "condition": "When the question asks for \"top 3 youngest drivers\", When the question mentions \"Netherlandic drivers\", When counting how many drivers among the top 3 youngest have Dutch nationality, When ordering by date of birth",
            "operation": " use JULIANDAY(dob) function instead of age column for proper date-based ordering."
        },
        "644": {
            "condition": "When the question asks for \"reference name\"",
            "operation": " select the exact column \"driverRef\" from the drivers table."
        },
        "645": {
            "condition": "When the question asks for \"reference name\", When filtering for driver \"Robert Kubica\"",
            "operation": " use both conditions \"forename = 'Robert'\" and \"surname = 'Kubica'\" with exact string literals 'Robert' and 'Kubica'."
        },
        "646": {
            "condition": "When counting drivers",
            "operation": " use \"driverId\" as the counting key instead of \"*\" to exclude null values."
        },
        "647": {
            "condition": "When extracting year from date of birth",
            "operation": " use STRFTIME('%Y', dob) instead of year(birth_date) for proper SQLite date extraction."
        },
        "648": {
            "condition": "When counting drivers, When extracting year from date of birth, When referencing date of birth column",
            "operation": " use \"dob\" instead of \"birth_date\" to match the actual schema."
        },
        "649": {
            "condition": "When answering about \"top 3 German drivers\"",
            "operation": " make sure the output order: T2.driverId."
        },
        "650": {
            "condition": "When the question mentions \"German drivers\"",
            "operation": " \"German\" actually means \"T2.nationality = 'German'\" in schema."
        },
        "651": {
            "condition": "When the question mentions \"born from 1980-1990\"",
            "operation": " use STRFTIME('%Y', T2.dob) to extract birth year and filter for values between 1980 and 1990 inclusive."
        },
        "652": {
            "condition": "When the question mentions \"earliest lap time\"",
            "operation": " order by T1.time in ascending order."
        },
        "653": {
            "condition": "When combining T1 (pitStops) and T2 (drivers) for shared entities",
            "operation": " link rows where T1.driverId = T2.driverId; keep only matching pairs (inner match)."
        },
        "654": {
            "condition": "When answering about \"top 3 German drivers\", When the question mentions \"German drivers\", When the question mentions \"born from 1980-1990\", When the question mentions \"earliest lap time\", When combining T1 (pitStops) and T2 (drivers) for shared entities, When the question asks for \"top 3\"",
            "operation": " rank rows by T1.time in ascending order and keep the first 3 rows."
        },
        "655": {
            "condition": "When the question asks for \"reference name\" of a driver",
            "operation": " use the exact column token \"driverRef\" from the drivers table instead of \"name\"."
        },
        "656": {
            "condition": "When ordering by date of birth to find the oldest driver",
            "operation": " use JULIANDAY(dob) function for accurate date ordering instead of the date_of_birth column."
        },
        "657": {
            "condition": "When the question asks for \"reference name\" of a driver, When ordering by date of birth to find the oldest driver, When filtering for German drivers",
            "operation": " use the exact literal value 'German' for the nationality condition."
        },
        "658": {
            "condition": "When extracting year from date of birth",
            "operation": " use STRFTIME('%Y', T2.dob) = '1971' for precise year matching instead of pattern matching."
        },
        "659": {
            "condition": "When filtering for valid fastest lap times",
            "operation": " add condition T1.fastestLapTime IS NOT NULL to exclude null values."
        },
        "660": {
            "condition": "When the question asks for all qualifying drivers",
            "operation": " do not use ORDER BY and LIMIT 1, return all matching rows instead of just the single fastest."
        },
        "661": {
            "condition": "When joining tables",
            "operation": " use explicit INNER JOIN syntax for clarity."
        },
        "662": {
            "condition": "When extracting year from date of birth, When filtering for valid fastest lap times, When the question asks for all qualifying drivers, When joining tables, When assigning table aliases",
            "operation": " use T1 for the results table and T2 for the drivers table consistently."
        },
        "663": {
            "condition": "When answering about \"top 10 Spanish drivers who were born before 1982 and have the latest lap time\"",
            "operation": " make sure the output order: T2.driverId."
        },
        "664": {
            "condition": "When combining pitStops and drivers tables",
            "operation": " link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match)."
        },
        "665": {
            "condition": "When the question mentions \"Spanish\"",
            "operation": " \"Spanish\" actually means T2.nationality = 'Spanish' in schema."
        },
        "666": {
            "condition": "When the question mentions \"born before 1982\"",
            "operation": " use STRFTIME('%Y', T2.dob) < '1982' for year comparison."
        },
        "667": {
            "condition": "When the question mentions \"latest lap time\"",
            "operation": " \"latest lap time\" actually means T1.time in descending order."
        },
        "668": {
            "condition": "When answering about \"top 10 Spanish drivers who were born before 1982 and have the latest lap time\", When combining pitStops and drivers tables, When the question mentions \"Spanish\", When the question mentions \"born before 1982\", When the question mentions \"latest lap time\", When the question mentions \"top 10\"",
            "operation": " rank rows by T1.time in descending direction and keep the first 10 rows."
        },
        "669": {
            "condition": "When answering about racing years with fastest lap times",
            "operation": " use T2.year from the races table instead of unqualified year."
        },
        "670": {
            "condition": "When combining results and races tables",
            "operation": " link rows where T1.raceId = T2.raceId using an inner match."
        },
        "671": {
            "condition": "When filtering for races with recorded fastest lap times",
            "operation": " include only rows where T1.fastestLapTime IS NOT NULL."
        },
        "672": {
            "condition": "When answering about racing years with fastest lap times, When combining results and races tables, When filtering for races with recorded fastest lap times, When the question asks for years with fastest lap times",
            "operation": " retrieve all qualifying years rather than finding the maximum value through ordering and limiting."
        },
        "673": {
            "condition": "When answering about \"year with lowest speed of lap time\"",
            "operation": " make sure the output order contains only T2.year."
        },
        "674": {
            "condition": "When combining lapTimes and races tables",
            "operation": " link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match)."
        },
        "675": {
            "condition": "When the question mentions \"lowest speed\" which implies slowest lap time",
            "operation": " order rows by T1.time in descending direction to find the maximum lap time."
        },
        "676": {
            "condition": "When the question asks for a single result",
            "operation": " keep only the first row after ordering."
        },
        "677": {
            "condition": "When answering about \"year with lowest speed of lap time\", When combining lapTimes and races tables, When the question mentions \"lowest speed\" which implies slowest lap time, When the question asks for a single result, When handling the query",
            "operation": " do not use GROUP BY or aggregation functions since we're working with individual lap times."
        },
        "678": {
            "condition": "When the question mentions \"driver's ID\"",
            "operation": " use the exact column token \"driverId\" from the schema."
        },
        "679": {
            "condition": "When the question mentions \"first lap\"",
            "operation": " filter rows where the exact column \"lap\" equals the literal value 1."
        },
        "680": {
            "condition": "When the question asks for \"top five driver by fastest time\"",
            "operation": " rank rows by the \"time\" column in ascending order (fastest to slowest) and keep the first 5 rows."
        },
        "681": {
            "condition": "When the question mentions \"driver's ID\", When the question mentions \"first lap\", When the question asks for \"top five driver by fastest time\", When choosing table and column identifiers",
            "operation": " use \"lapTimes\" for the table name and \"driverId\" for the column name exactly as specified in the schema, without changing case or adding underscores."
        },
        "682": {
            "condition": "When counting finishers",
            "operation": " use SUM(IIF(time IS NOT NULL, 1, 0)) to count only non-null time values instead of COUNT(*)."
        },
        "683": {
            "condition": "When querying about finishers",
            "operation": " use the \"results\" table instead of the \"finishers\" table."
        },
        "684": {
            "condition": "When identifying disqualified finishers",
            "operation": " use statusId = 2 instead of disqualified = 'yes'."
        },
        "685": {
            "condition": "When counting finishers, When querying about finishers, When identifying disqualified finishers, When filtering by race range from 50 to 100",
            "operation": " use raceID < 100 AND raceId > 50 instead of race_no BETWEEN 50 AND 100."
        },
        "686": {
            "condition": "When the question asks for \"how many times the circuits were held in Austria\" but also requests \"their location and coordinates\"",
            "operation": " return the distinct location coordinates instead of counting occurrences."
        },
        "687": {
            "condition": "When selecting location coordinates from circuits",
            "operation": " use DISTINCT to eliminate duplicate location entries with the same coordinates."
        },
        "688": {
            "condition": "When filtering circuits by country",
            "operation": " use the exact literal 'Austria' with the correct case and spelling."
        },
        "689": {
            "condition": "When the question asks for \"how many times the circuits were held in Austria\" but also requests \"their location and coordinates\", When selecting location coordinates from circuits, When filtering circuits by country, When outputting results",
            "operation": " include the exact columns location, lat, and lng in the output."
        },
        "690": {
            "condition": "When answering about \"race number with the most finishers\"",
            "operation": " use the \"raceId\" column instead of \"race_number\" from the results table."
        },
        "691": {
            "condition": "When counting finishers",
            "operation": " count only rows where the \"time\" column is not null using COUNT(time IS NOT NULL) instead of counting all rows."
        },
        "692": {
            "condition": "When ordering by finisher count to find the most finishers",
            "operation": " sort in descending order (DESC) instead of ascending order (ASC)."
        },
        "693": {
            "condition": "When answering about \"race number with the most finishers\", When counting finishers, When ordering by finisher count to find the most finishers, When selecting output columns",
            "operation": " include only \"raceId\" and omit any aliases like \"finisher_count\" from the final output."
        },
        "694": {
            "condition": "When counting finishers for races",
            "operation": " count only non-null time values using COUNT(time IS NOT NULL) to identify finishers."
        },
        "695": {
            "condition": "When finding the race with the most finishers",
            "operation": " group by raceId and order by the count of non-null time values in descending order."
        },
        "696": {
            "condition": "When counting finishers for races, When finding the race with the most finishers, When selecting the top result",
            "operation": " limit to 1 row to get the race with the highest count."
        },
        "697": {
            "condition": "When answering about drivers who passed the second qualifying lap",
            "operation": " use the presence of q2 time (T1.q2 IS NOT NULL) instead of filtering by lap number and position."
        },
        "698": {
            "condition": "When the question mentions \"reference name\"",
            "operation": " \"reference name\" actually means \"driverRef in schema\" and should be selected as T2.driverRef."
        },
        "699": {
            "condition": "When the question mentions \"birthday\"",
            "operation": " \"birthday\" actually means \"dob in schema\" and should be selected as T2.dob."
        },
        "700": {
            "condition": "When combining qualifying and drivers tables",
            "operation": " link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match)."
        },
        "701": {
            "condition": "When filtering for race no. 23",
            "operation": " use T1.raceId = 23 exactly as specified."
        },
        "702": {
            "condition": "When answering about drivers who passed the second qualifying lap, When the question mentions \"reference name\", When the question mentions \"birthday\", When combining qualifying and drivers tables, When filtering for race no. 23, When selecting output columns",
            "operation": " make sure the output order is T2.driverRef, T2.nationality, T2.dob."
        },
        "703": {
            "condition": "When answering about the youngest driver's first qualifying race",
            "operation": " join qualifying as T1 and drivers as T2 on T1.driverId = T2.driverId, then join races as T3 on T1.raceId = T3.raceId."
        },
        "704": {
            "condition": "When identifying the youngest driver",
            "operation": " use T1.driverId = (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT"
        },
        "705": {
            "condition": "to find the driver with the most recent date of birth.",
            "operation": "to find the driver with the most recent date of birth."
        },
        "706": {
            "condition": "When selecting output columns",
            "operation": " choose T3.year, T3.name, T3.date, and T3.time from the races table."
        },
        "707": {
            "condition": "When answering about the youngest driver's first qualifying race, When identifying the youngest driver, to find the driver with the most recent date of birth., When selecting output columns, When handling the qualifying race relationship",
            "operation": " ensure the connection is made through the qualifying table (T1) rather than directly between drivers and races."
        },
        "708": {
            "condition": "When answering about \"How many American drivers have puncture status\"",
            "operation": " make sure the output order: COUNT(T1.driverId)."
        },
        "709": {
            "condition": "When the question mentions \"American\"",
            "operation": " \"American\" actually means \"nationality = 'American' in schema\"."
        },
        "710": {
            "condition": "When the question mentions \"puncture status\"",
            "operation": " \"puncture status\" actually means \"T3.status = 'Puncture' in schema\"."
        },
        "711": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.driverId = T2.driverId and T2.statusId = T3.statusId; keep only matching pairs (inner match)."
        },
        "712": {
            "condition": "When the question asks for \"count of drivers\"",
            "operation": " compute the number of rows using the canonical key token T1.driverId."
        },
        "713": {
            "condition": "When answering about \"How many American drivers have puncture status\", When the question mentions \"American\", When the question mentions \"puncture status\", When combining T1, T2, and T3 for shared entities, When the question asks for \"count of drivers\", When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use 'Puncture' exactly as shown in the schema."
        },
        "714": {
            "condition": "When answering about \"Italian constructor with highest points\"",
            "operation": " make sure the output order: constructor's website (T1.url)."
        },
        "715": {
            "condition": "When combining constructors and constructorStandings tables",
            "operation": " link rows where T1.constructorId = T2.constructorId and keep only matching pairs (inner match)."
        },
        "716": {
            "condition": "When filtering by nationality",
            "operation": " use T1.nationality = 'Italian' exactly as specified."
        },
        "717": {
            "condition": "When finding the highest points",
            "operation": " order by T2.points DESC and take only the top result."
        },
        "718": {
            "condition": "When answering about \"Italian constructor with highest points\", When combining constructors and constructorStandings tables, When filtering by nationality, When finding the highest points, When the question asks for the constructor's website",
            "operation": " select T1.url as the website field."
        },
        "719": {
            "condition": "When the question asks for \"website\"",
            "operation": " use the exact column token \"T1.url\" instead of \"website\"."
        },
        "720": {
            "condition": "When combining constructors and constructorStandings tables",
            "operation": " link rows where \"T1.constructorId = T2.constructorId\" and keep only matching pairs (inner match)."
        },
        "721": {
            "condition": "When the question asks for \"most total wins\"",
            "operation": " rank rows by \"T2.wins\" in descending order and keep the first 1 row."
        },
        "722": {
            "condition": "When the question asks for \"website\", When combining constructors and constructorStandings tables, When the question asks for \"most total wins\", When answering about constructor website with most wins",
            "operation": " make sure the output order: \"T1.url\"."
        },
        "723": {
            "condition": "When answering about drivers who participated in the French Grand Prix",
            "operation": " join lapTimes AS T1 with races AS T2 using inner match where T1.raceId = T2.raceId."
        },
        "724": {
            "condition": "When filtering for the French Grand Prix",
            "operation": " use T2.name = 'French Grand Prix' exactly as specified."
        },
        "725": {
            "condition": "When filtering for the 3rd lap",
            "operation": " use T1.lap = 3 exactly as specified."
        },
        "726": {
            "condition": "When finding the slowest time",
            "operation": " order by T1.time DESC (maximum time) instead of ascending order."
        },
        "727": {
            "condition": "When selecting the driver",
            "operation": " use T1.driverId instead of driver_name from the result set."
        },
        "728": {
            "condition": "When answering about drivers who participated in the French Grand Prix, When filtering for the French Grand Prix, When filtering for the 3rd lap, When finding the slowest time, When selecting the driver, When limiting to the slowest driver",
            "operation": " keep only the first row after ordering by time DESC."
        },
        "729": {
            "condition": "When answering about fastest 1st lap time",
            "operation": " use milliseconds column instead of race_name and MIN(lap_time) for output."
        },
        "730": {
            "condition": "When combining lapTimes and races tables",
            "operation": " link rows where T1.raceId = T2.raceId using inner join and keep only matching pairs."
        },
        "731": {
            "condition": "When filtering for first lap",
            "operation": " add condition WHERE T1.lap = 1 to select only lap 1 data."
        },
        "732": {
            "condition": "When ordering by lap time",
            "operation": " order by T1.time column in ascending direction to find fastest time."
        },
        "733": {
            "condition": "When answering about fastest 1st lap time, When combining lapTimes and races tables, When filtering for first lap, When ordering by lap time, When retrieving the fastest time",
            "operation": " take only the first row after ordering to get the single fastest result."
        },
        "734": {
            "condition": "When answering about \"fastest 1st lap time\"",
            "operation": " make sure the output order includes only the milliseconds column."
        },
        "735": {
            "condition": "When the question asks for the fastest time",
            "operation": " order by the time column in ascending order (lowest value first) without specifying direction explicitly."
        },
        "736": {
            "condition": "When answering about \"fastest 1st lap time\", When the question asks for the fastest time, When filtering for first lap records",
            "operation": " include only rows where lap equals 1 using the exact literal value."
        },
        "737": {
            "condition": "When answering about \"average fastest lap time of the top 10 drivers\"",
            "operation": " make sure the output order: AVG(T1.fastest_lap_time)."
        },
        "738": {
            "condition": "When the question mentions \"top 10 drivers\"",
            "operation": " use T1.rank < 11 instead of LIMIT with ORDER BY."
        },
        "739": {
            "condition": "When combining results (T1) and races (T2) tables",
            "operation": " link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match)."
        },
        "740": {
            "condition": "When filtering for the 2006 United States Grand Prix",
            "operation": " use T2.year = 2006 and T2.name = 'United States Grand Prix' exactly as specified."
        },
        "741": {
            "condition": "When answering about \"average fastest lap time of the top 10 drivers\", When the question mentions \"top 10 drivers\", When combining results (T1) and races (T2) tables, When filtering for the 2006 United States Grand Prix, When performing aggregation",
            "operation": " remove ORDER BY and LIMIT clauses since they are unnecessary for aggregate calculations."
        },
        "742": {
            "condition": "When the question mentions \"German drivers\"",
            "operation": " use \"T2.nationality = 'German'\" with exact literal 'German'."
        },
        "743": {
            "condition": "When filtering by birth years 1980-1985",
            "operation": " extract year from T2.dob using STRFTIME('%Y', T2.dob) and check BETWEEN '1980' AND '1985'."
        },
        "744": {
            "condition": "When combining pit stops and drivers tables",
            "operation": " use INNER JOIN where T1.driverId = T2.driverId."
        },
        "745": {
            "condition": "When computing average pit stop duration",
            "operation": " calculate AVG(T1.duration)."
        },
        "746": {
            "condition": "When grouping results",
            "operation": " group by T2.forename, T2.surname to match output columns."
        },
        "747": {
            "condition": "When ordering by shortest average pit stop duration",
            "operation": " order by AVG(T1.duration) in ASCending order."
        },
        "748": {
            "condition": "When selecting top 3",
            "operation": " limit to 3 rows after ordering."
        },
        "749": {
            "condition": "When the question mentions \"German drivers\", When filtering by birth years 1980-1985, When combining pit stops and drivers tables, When computing average pit stop duration, When grouping results, When ordering by shortest average pit stop duration, When selecting top 3, When outputting driver names",
            "operation": " use T2.forename and T2.surname as the exact column references."
        },
        "750": {
            "condition": "When answering about \"top 3 German drivers with shortest average pit stop duration born between 1980-1985\"",
            "operation": " make sure the output order includes only T2.forename and T2.surname without displaying the average calculation."
        },
        "751": {
            "condition": "When the question mentions \"German drivers\"",
            "operation": " filter using T2.nationality = 'German' exactly as specified."
        },
        "752": {
            "condition": "When the question mentions \"born between 1980-1985\"",
            "operation": " filter using STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' with exact year literals."
        },
        "753": {
            "condition": "When the question asks for \"shortest average pit stop duration\"",
            "operation": " compute AVG(T1.duration) for ordering but do not include it in the final output."
        },
        "754": {
            "condition": "When the question asks for \"top 3\"",
            "operation": " rank rows by AVG(T1.duration) in ascending order and keep the first 3 rows."
        },
        "755": {
            "condition": "When combining T1 (pitStops) and T2 (drivers)",
            "operation": " link rows where T1.driverId = T2.driverId exactly as shown; keep only matching pairs (inner match)."
        },
        "756": {
            "condition": "When answering about \"top 3 German drivers with shortest average pit stop duration born between 1980-1985\", When the question mentions \"German drivers\", When the question mentions \"born between 1980-1985\", When the question asks for \"shortest average pit stop duration\", When the question asks for \"top 3\", When combining T1 (pitStops) and T2 (drivers), When grouping by driver",
            "operation": " organize results by T2.forename and T2.surname to compute the average per driver."
        },
        "757": {
            "condition": "When answering about the champion of a Grand Prix",
            "operation": " use the exact time format pattern '_:%:__.___' to identify finishing times instead of position = 1."
        },
        "758": {
            "condition": "When the question mentions \"Canadian Grand Prix\"",
            "operation": " use the exact literal 'Canadian Grand Prix' with column T2.name."
        },
        "759": {
            "condition": "When the question mentions year 2008",
            "operation": " use T2.year = 2008."
        },
        "760": {
            "condition": "When combining results and races tables",
            "operation": " link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match)."
        },
        "761": {
            "condition": "When answering about the champion of a Grand Prix, When the question mentions \"Canadian Grand Prix\", When the question mentions year 2008, When combining results and races tables, When selecting output columns",
            "operation": " use T1.time instead of driver_name and finish_time."
        },
        "762": {
            "condition": "When answering about constructor reference name and website of a champion",
            "operation": " select T3.constructorRef and T3.url as output columns."
        },
        "763": {
            "condition": "When combining race results and race information",
            "operation": " link T1 (results) and T2 (races) where T1.raceId = T2.raceId and keep only matching pairs."
        },
        "764": {
            "condition": "When combining results with constructor information",
            "operation": " link T1 (results) and T3 (constructors) where T1.constructorId = T3.constructorId and keep only matching pairs."
        },
        "765": {
            "condition": "When filtering for the 2009 Singapore Grand Prix",
            "operation": " apply both T2.name = 'Singapore Grand Prix' and T2.year = 2009 conditions."
        },
        "766": {
            "condition": "When answering about constructor reference name and website of a champion, When combining race results and race information, When combining results with constructor information, When filtering for the 2009 Singapore Grand Prix, When identifying the champion in a race",
            "operation": " filter for results where T1.time LIKE '_:%:__.___' to find the winning entry."
        },
        "767": {
            "condition": "When the question asks for \"full name\"",
            "operation": " use columns \"forename\" and \"surname\" from table drivers."
        },
        "768": {
            "condition": "When the question asks for \"date of birth\"",
            "operation": " use column \"dob\" from table drivers."
        },
        "769": {
            "condition": "When filtering by nationality \"Austrian\"",
            "operation": " use condition nationality = 'Austrian' with exact literal 'Austrian'."
        },
        "770": {
            "condition": "When the question asks for \"full name\", When the question asks for \"date of birth\", When filtering by nationality \"Austrian\", When filtering for birth years between 1981 and 1991",
            "operation": " extract the year from \"dob\" using STRFTIME('%Y', dob) and compare between string literals '1981' and '1991' inclusive."
        },
        "771": {
            "condition": "When the question asks for \"full name\"",
            "operation": " use both \"forename\" and \"surname\" columns from table \"drivers\" to construct the full name."
        },
        "772": {
            "condition": "When the question asks for \"Wiki Pedia page link\"",
            "operation": " use the \"url\" column from table \"races\" instead of a \"wikipedia_link\" column."
        },
        "773": {
            "condition": "When the question asks for \"date of birth\"",
            "operation": " use the \"dob\" column from table \"drivers\" instead of \"date_of_birth\"."
        },
        "774": {
            "condition": "When filtering for drivers born between 1971 and 1985",
            "operation": " extract the year from \"dob\" using STRFTIME('%Y', dob) and check if it falls between 1971 and 1985 inclusive, rather than using date range comparison with BETWEEN."
        },
        "775": {
            "condition": "When the question asks for \"full name\", When the question asks for \"Wiki Pedia page link\", When the question asks for \"date of birth\", When filtering for drivers born between 1971 and 1985, When ordering results by date of birth",
            "operation": " use \"dob DESC\" for descending order instead of ascending order."
        },
        "776": {
            "condition": "When the question asks about a specific circuit by name \"Hungaroring\"",
            "operation": " filter the circuits table where name equals 'Hungaroring' exactly."
        },
        "777": {
            "condition": "When the question asks for location, country, and coordinates",
            "operation": " select the location, country, lat, and lng columns from the circuits table."
        },
        "778": {
            "condition": "When the question asks about a specific circuit by name \"Hungaroring\", When the question asks for location, country, and coordinates, When the WHERE clause already filters by a specific value",
            "operation": " do not include the filtering column (name) in the output columns to avoid redundancy."
        },
        "779": {
            "condition": "When the question asks about a circuit's location but the schema shows 'location' refers to a city/place name while the question seeks geographical coordinates",
            "operation": " exclude the 'location' column from output and include only 'country', 'lat', and 'lng' columns instead."
        },
        "780": {
            "condition": "When filtering for a specific circuit by name",
            "operation": " use exact literal matching with 'Hungaroring' (case-sensitive) in the WHERE condition."
        },
        "781": {
            "condition": "When the question asks about a circuit's location but the schema shows 'location' refers to a city/place name while the question seeks geographical coordinates, When filtering for a specific circuit by name, When selecting from the circuits table",
            "operation": " maintain the table reference without aliases since only one table is involved."
        },
        "782": {
            "condition": "When answering about constructor points from Monaco Grand Prix",
            "operation": " use the \"constructorResults\" table instead of the \"results\" table for points data."
        },
        "783": {
            "condition": "When joining constructor data",
            "operation": " link \"constructorResults\" to \"constructors\" using \"constructorId\" as the join key."
        },
        "784": {
            "condition": "When aggregating points",
            "operation": " compute the sum of \"T1.points\" without using an alias in the aggregation."
        },
        "785": {
            "condition": "When grouping results",
            "operation": " group by \"T2.name\" to match the non-aggregated columns in the output."
        },
        "786": {
            "condition": "When ordering results",
            "operation": " sort by the sum of points directly rather than using an alias."
        },
        "787": {
            "condition": "When filtering for Monaco Grand Prix",
            "operation": " use the exact literal 'Monaco Grand Prix' for race name comparison."
        },
        "788": {
            "condition": "When answering about constructor points from Monaco Grand Prix, When joining constructor data, When aggregating points, When grouping results, When ordering results, When filtering for Monaco Grand Prix, When filtering for years between 1980 and 2010",
            "operation": " use inclusive range comparison with years 1980 and 2010."
        },
        "789": {
            "condition": "When answering about average score of a specific driver",
            "operation": " calculate the average of T2.points from the driverStandings table instead of using a score column from races."
        },
        "790": {
            "condition": "When identifying Lewis Hamilton",
            "operation": " use T1.forename = 'Lewis' and T1.surname = 'Hamilton' from the drivers table instead of a single driver_name column."
        },
        "791": {
            "condition": "When filtering for Turkish Grand Prix",
            "operation": " use T3.name = 'Turkish Grand Prix' from the races table instead of a race_name LIKE pattern match."
        },
        "792": {
            "condition": "When combining driver and race information",
            "operation": " join drivers (T1) and driverStandings (T2) tables on driverId, then join races (T3) on raceId using exact key equality."
        },
        "793": {
            "condition": "When answering about average score of a specific driver, When identifying Lewis Hamilton, When filtering for Turkish Grand Prix, When combining driver and race information, When computing aggregates across multiple tables",
            "operation": " ensure all joins are inner matches to only include rows present in all three tables (drivers, driverStandings, and races)."
        },
        "794": {
            "condition": "When calculating the annual average number of races over a decade",
            "operation": " use CAST(SUM(CASE WHEN year BETWEEN 2000 AND 2010 THEN 1 ELSE 0 END) AS REAL) / 10 instead of AVG(COUNT(raceId)) for proper decade averaging."
        },
        "795": {
            "condition": "When filtering for the first 10 years of the 21st century",
            "operation": " use date BETWEEN '2000-01-01' AND '2010-12-31' instead of year BETWEEN 2000 AND 2009 to include the complete decade range."
        },
        "796": {
            "condition": "When calculating the annual average number of races over a decade, When filtering for the first 10 years of the 21st century, When computing a single average value across multiple years",
            "operation": " remove GROUP BY year clause since the aggregation handles the calculation without per-year grouping."
        },
        "797": {
            "condition": "When the question mentions \"citizenship\"",
            "operation": " use the exact column token \"nationality\" instead."
        },
        "798": {
            "condition": "When counting drivers",
            "operation": " count using the canonical key \"driverId\" rather than all rows."
        },
        "799": {
            "condition": "When ordering by count",
            "operation": " order by the count of driverId in descending direction."
        },
        "800": {
            "condition": "When answering about the majority citizenship",
            "operation": " take only the top 1 result after ordering by count."
        },
        "801": {
            "condition": "When grouping by nationality",
            "operation": " organize results by the \"nationality\" column and compute counts per group."
        },
        "802": {
            "condition": "When the question mentions \"citizenship\", When counting drivers, When ordering by count, When answering about the majority citizenship, When grouping by nationality, When producing output",
            "operation": " include \"nationality\" and the count without any alias in the SELECT list."
        },
        "803": {
            "condition": "When answering about \"which citizenship do the vast majority of the drivers hold\"",
            "operation": " make sure the output order: only return the nationality value without the count."
        },
        "804": {
            "condition": "When the question asks for the majority nationality",
            "operation": " group by the exact token \"nationality\" and count using the canonical key \"driverId\"."
        },
        "805": {
            "condition": "When determining the most common nationality",
            "operation": " order by the count of driverId in descending order and keep only the first result (limit 1)."
        },
        "806": {
            "condition": "When answering about \"which citizenship do the vast majority of the drivers hold\", When the question asks for the majority nationality, When determining the most common nationality, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of the nationality values."
        },
        "807": {
            "condition": "When the question asks about \"number of points acquired\" and \"victories\" for a specific rank",
            "operation": " use the exact column \"points\" to identify drivers and \"wins\" to count victories."
        },
        "808": {
            "condition": "When the question mentions \"ranked 91st\"",
            "operation": " this refers to drivers with exactly 91 points in the \"points\" column, not the \"rank\" column."
        },
        "809": {
            "condition": "When calculating victories for drivers with specific points",
            "operation": " sum the \"wins\" values using SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) instead of counting race results."
        },
        "810": {
            "condition": "When accessing driver statistics",
            "operation": " query from the \"driverStandings\" table to get driver-level statistics rather than individual race results."
        },
        "811": {
            "condition": "When the question asks about \"number of points acquired\" and \"victories\" for a specific rank, When the question mentions \"ranked 91st\", When calculating victories for drivers with specific points, When accessing driver statistics, When filtering for specific points values",
            "operation": " use the exact literal value 91 without quotes for numeric comparison in the points column."
        },
        "812": {
            "condition": "When answering about \"fastest lap time\"",
            "operation": " make sure the output order: T1.name"
        },
        "813": {
            "condition": "When the question mentions \"race name\"",
            "operation": " \"race name\" actually means \"T1.name in schema\""
        },
        "814": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.raceId = T2.raceId exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "815": {
            "condition": "When handling fastest lap time data",
            "operation": " filter for T2.fastestLapTime IS NOT NULL instead of omitting null value handling."
        },
        "816": {
            "condition": "When answering about \"fastest lap time\", When the question mentions \"race name\", When combining T1 and T2 for shared entities, When handling fastest lap time data, When the question asks for \"fastest\" lap time",
            "operation": " order by T2.fastestLapTime ASC for ascending order instead of descending order to find the minimum time."
        },
        "817": {
            "condition": "When answering about \"most recent race\"",
            "operation": " order results by T2.date in descending order and keep only the first row."
        },
        "818": {
            "condition": "When the question mentions \"racetrack\" and \"location\"",
            "operation": " use T1.location from the circuits table (aliased as T1) to represent the full location."
        },
        "819": {
            "condition": "When combining circuits and races tables",
            "operation": " link rows where T1.circuitId = T2.circuitId and keep only matching pairs (inner match)."
        },
        "820": {
            "condition": "When answering about \"most recent race\", When the question mentions \"racetrack\" and \"location\", When combining circuits and races tables, When selecting output columns",
            "operation": " include only T1.location to show the full location of the racetrack."
        },
        "821": {
            "condition": "When answering about racer names",
            "operation": " select both T2.forename and T2.surname instead of a single racer_name field."
        },
        "822": {
            "condition": "When the question involves qualifying races",
            "operation": " join qualifying AS T1 and drivers AS T2 on T1.driverId = T2.driverId instead of querying only races."
        },
        "823": {
            "condition": "When combining qualifying and race information",
            "operation": " add an INNER JOIN with races AS T3 on T1.raceid = T3.raceid to access race details."
        },
        "824": {
            "condition": "When filtering for valid qualifying results",
            "operation": " include q3 IS NOT NULL to ensure the racer completed the third qualifying session."
        },
        "825": {
            "condition": "When filtering by year",
            "operation": " use T3.year = 2008 instead of a generic year filter."
        },
        "826": {
            "condition": "When filtering by circuit name 'Marina Bay Street Circuit'",
            "operation": " use T3.circuitId IN (SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit') instead of direct circuit name matching."
        },
        "827": {
            "condition": "When ranking qualifiers by position",
            "operation": " use complex time conversion logic with CAST, SUBSTR, and INSTR functions to sort by qualifying time instead of position number."
        },
        "828": {
            "condition": "When answering about racer names, When the question involves qualifying races, When combining qualifying and race information, When filtering for valid qualifying results, When filtering by year, When filtering by circuit name 'Marina Bay Street Circuit', When ranking qualifiers by position, When selecting the top-ranked qualifier",
            "operation": " add LIMIT 1 to return only the fastest racer."
        },
        "829": {
            "condition": "When answering about the youngest racer",
            "operation": " use T1.forename and T1.surname instead of racer_name to get the full name."
        },
        "830": {
            "condition": "When the question mentions \"youngest\"",
            "operation": " order by JULIANDAY(T1.dob) DESC to find the person with the most recent date of birth."
        },
        "831": {
            "condition": "When combining driver information with standings and races",
            "operation": " link T1 and T2 using T1.driverId = T2.driverId and link T2 and T3 using T2.raceId = T3.raceId, keeping only matching pairs (inner match)."
        },
        "832": {
            "condition": "When retrieving the race information",
            "operation": " use T3.name instead of race_name for the race name."
        },
        "833": {
            "condition": "When limiting to the youngest racer",
            "operation": " keep only the first result after ordering by date of birth descending."
        },
        "834": {
            "condition": "When answering about the youngest racer, When the question mentions \"youngest\", When combining driver information with standings and races, When retrieving the race information, When limiting to the youngest racer, When handling nationality",
            "operation": " use T1.nationality exactly as specified in the schema."
        },
        "835": {
            "condition": "When answering about accidents in the Canadian Grand Prix",
            "operation": " use tables \"results\" as T1, \"races\" as T2, and \"status\" as T3 with proper joins instead of querying only one table."
        },
        "836": {
            "condition": "When combining T1 and T2 for shared race information",
            "operation": " link rows where T1.\"raceId\" = T2.\"raceId\" exactly and keep only matching pairs (inner match)."
        },
        "837": {
            "condition": "When combining T1 and T3 for status information",
            "operation": " link rows where T1.\"statusId\" = T3.\"statusId\" exactly and keep only matching pairs (inner match)."
        },
        "838": {
            "condition": "When filtering for accident status",
            "operation": " use T1.\"statusId\" = 3 instead of missing this condition."
        },
        "839": {
            "condition": "When filtering for Canadian Grand Prix",
            "operation": " use T2.\"name\" = 'Canadian Grand Prix' instead of incorrect column references."
        },
        "840": {
            "condition": "When counting accidents by driver",
            "operation": " compute COUNT(T1.\"driverId\") with GROUP BY T1.\"driverId\" instead of incorrect subquery approaches."
        },
        "841": {
            "condition": "When finding the driver with highest number of accidents",
            "operation": " order by COUNT(T1.\"driverId\") DESC and take the first row."
        },
        "842": {
            "condition": "When answering about accidents in the Canadian Grand Prix, When combining T1 and T2 for shared race information, When combining T1 and T3 for status information, When filtering for accident status, When filtering for Canadian Grand Prix, When counting accidents by driver, When finding the driver with highest number of accidents, When the question asks for count of accidents for the top driver",
            "operation": " return the maximum COUNT(T1.\"driverId\") value from the ordered results."
        },
        "843": {
            "condition": "When answering about \"how many wins was achieved by the oldest racer\"",
            "operation": " make sure to sum actual win counts using SUM(T1.wins) instead of counting rows."
        },
        "844": {
            "condition": "When combining driver standings and drivers tables",
            "operation": " link rows where T1.driverId = T2.driverId using an inner match and keep only matching pairs."
        },
        "845": {
            "condition": "When the question asks for the oldest racer",
            "operation": " order by T2.dob in ascending order and take only the first row."
        },
        "846": {
            "condition": "When answering about \"how many wins was achieved by the oldest racer\", When combining driver standings and drivers tables, When the question asks for the oldest racer, When the question asks for the racer's full name",
            "operation": " select both T2.forename and T2.surname to get complete name components."
        },
        "847": {
            "condition": "When answering about \"How many wins was achieved by the oldest racer\"",
            "operation": " make sure the output order: SUM(T1.wins) first, then T2.forename, then T2.surname."
        },
        "848": {
            "condition": "When the question asks for the oldest racer",
            "operation": " use the earliest date of birth (T2.dob) in ascending order and take only the first result."
        },
        "849": {
            "condition": "When combining driverStandings as T1 and drivers as T2",
            "operation": " link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match)."
        },
        "850": {
            "condition": "When computing total wins",
            "operation": " use SUM(T1.wins) without grouping by driverId since we only need one result."
        },
        "851": {
            "condition": "When answering about \"How many wins was achieved by the oldest racer\", When the question asks for the oldest racer, When combining driverStandings as T1 and drivers as T2, When computing total wins, When returning a single result",
            "operation": " do not use column aliases for aggregates as only one row is returned."
        },
        "852": {
            "condition": "When answering about \"the longest time a driver had ever spent at a pit stop\"",
            "operation": " make sure the output order: duration."
        },
        "853": {
            "condition": "When the question mentions \"longest time\"",
            "operation": " \"longest time\" actually means \"duration in schema\"."
        },
        "854": {
            "condition": "When the question asks for the maximum duration value",
            "operation": " use ORDER BY duration DESC LIMIT 1 to find the single highest duration value."
        },
        "855": {
            "condition": "When querying from the pit stops table",
            "operation": " use table name \"pitStops\" exactly as shown in the schema, not \"pit_stops\"."
        },
        "856": {
            "condition": "When selecting the duration value",
            "operation": " use column name \"duration\" without aggregate functions like MAX()."
        },
        "857": {
            "condition": "When answering about \"the longest time a driver had ever spent at a pit stop\", When the question mentions \"longest time\", When the question asks for the maximum duration value, When querying from the pit stops table, When selecting the duration value, When finding the maximum duration",
            "operation": " do not filter by driver_id or use subqueries that reference driver tables."
        },
        "858": {
            "condition": "When answering about \"longest time spent at a pit stop\"",
            "operation": " make sure the output order: duration DESC LIMIT 1."
        },
        "859": {
            "condition": "When combining T1 (pitStops) and T2 (drivers) for shared entities",
            "operation": " link rows where T1.driverId = T2.driverId; keep only matching pairs (inner match)."
        },
        "860": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton' in schema\"."
        },
        "861": {
            "condition": "When answering about \"longest time spent at a pit stop\", When combining T1 (pitStops) and T2 (drivers) for shared entities, When the question mentions \"Lewis Hamilton\", When selecting the duration value",
            "operation": " use T1.duration instead of MAX(pit_stop_duration) since we need the actual duration value, not an aggregate function."
        },
        "862": {
            "condition": "When the question asks for the longest time spent at a pit stop for Lewis Hamilton",
            "operation": " return only the duration value instead of including driver name columns in the output."
        },
        "863": {
            "condition": "When filtering for Lewis Hamilton",
            "operation": " use exact literal values 'Lewis' for forename and 'Hamilton' for surname."
        },
        "864": {
            "condition": "When finding the longest duration",
            "operation": " sort by duration in descending order and take only the top result."
        },
        "865": {
            "condition": "When the question asks for the longest time spent at a pit stop for Lewis Hamilton, When filtering for Lewis Hamilton, When finding the longest duration, When joining pitStops and drivers tables",
            "operation": " link rows where T1.driverId equals T2.driverId using an inner match."
        },
        "866": {
            "condition": "When joining pit stops with driver information",
            "operation": " combine \"pitStops AS T1\" with \"drivers AS T2\" where \"T1.driverId\" equals \"T2.driverId\" to link through proper foreign key relationships."
        },
        "867": {
            "condition": "When joining pit stops with race information",
            "operation": " combine \"pitStops AS T1\" with \"races AS T3\" where \"T1.raceId\" equals \"T3.raceId\" to link through proper foreign key relationships."
        },
        "868": {
            "condition": "When filtering for Lewis Hamilton",
            "operation": " check both \"T2.forename = 'Lewis'\" and \"T2.surname = 'Hamilton'\" instead of using a combined driver name string."
        },
        "869": {
            "condition": "When filtering for the 2011 Australian Grand Prix",
            "operation": " check both \"T3.year = 2011\" and \"T3.name = 'Australian Grand Prix'\" instead of using a year-included race name string."
        },
        "870": {
            "condition": "When joining pit stops with driver information, When joining pit stops with race information, When filtering for Lewis Hamilton, When filtering for the 2011 Australian Grand Prix, When answering about specific lap information",
            "operation": " return the lap value directly without ordering or limiting since the query logic correctly identifies the specific lap."
        },
        "871": {
            "condition": "When answering about \"time each driver spent at the pit stop\"",
            "operation": " make sure the output order: T1.duration."
        },
        "872": {
            "condition": "When the question mentions \"2011 Australian Grand Prix\"",
            "operation": " use T2.year = 2011 and T2.name = 'Australian Grand Prix' for filtering."
        },
        "873": {
            "condition": "When combining pit stops and races tables",
            "operation": " link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match)."
        },
        "874": {
            "condition": "When answering about \"time each driver spent at the pit stop\", When the question mentions \"2011 Australian Grand Prix\", When combining pit stops and races tables, When producing output",
            "operation": " do not include ORDER BY driver_name clause."
        },
        "875": {
            "condition": "When answering about lap records",
            "operation": " use table aliases T1 for lapTimes and T2 for drivers instead of direct table names."
        },
        "876": {
            "condition": "When selecting lap time information",
            "operation": " select T1.time instead of lap_time."
        },
        "877": {
            "condition": "When combining driver and lap time information",
            "operation": " join lapTimes AS T1 with drivers AS T2 on T1.driverId = T2.driverId using an inner match."
        },
        "878": {
            "condition": "When filtering for Lewis Hamilton",
            "operation": " use T2.forename = 'Lewis' AND T2.surname = 'Hamilton' instead of a single driver_name field."
        },
        "879": {
            "condition": "When answering about lap records, When selecting lap time information, When combining driver and lap time information, When filtering for Lewis Hamilton, When the question asks for a lap record",
            "operation": " do not use ORDER BY and LIMIT as the query logic should correctly identify the minimum time through proper table relationships."
        },
        "880": {
            "condition": "When the question asks for \"top 20\" drivers by lap time performance",
            "operation": " rank drivers by their minimum lap time in ascending order and keep the first 20 rows."
        },
        "881": {
            "condition": "When the question mentions \"shortest lap time ever\"",
            "operation": " for each driver, find their absolute minimum lap time across all races instead of individual lap times."
        },
        "882": {
            "condition": "When converting lap time format",
            "operation": " convert the time format to seconds before performing comparisons and ranking."
        },
        "883": {
            "condition": "When joining driver information",
            "operation": " use an inner match between the aggregated lap times and drivers table where driverId values are equal."
        },
        "884": {
            "condition": "When selecting driver names",
            "operation": " include both forename and surname columns to get full names instead of a single driver_name column."
        },
        "885": {
            "condition": "When the question asks for \"top 20\" drivers by lap time performance, When the question mentions \"shortest lap time ever\", When converting lap time format, When joining driver information, When selecting driver names, When ordering results",
            "operation": " sort by the calculated minimum time in seconds (min_time_in_seconds) in ascending order to find the fastest times."
        },
        "886": {
            "condition": "When extracting lap time information",
            "operation": " parse the \"time\" column using string manipulation to extract minutes, seconds, and milliseconds components instead of using the \"milliseconds\" column."
        },
        "887": {
            "condition": "When calculating time in seconds",
            "operation": " convert minutes to seconds, add seconds, and add milliseconds converted to seconds instead of simply dividing milliseconds by 1000."
        },
        "888": {
            "condition": "When finding minimum lap times",
            "operation": " first convert all lap times to seconds before finding the minimum, instead of finding the minimum milliseconds and then converting."
        },
        "889": {
            "condition": "When producing final output",
            "operation": " remove the time column from the final SELECT list as it's not needed in the output."
        },
        "890": {
            "condition": "When using table aliases",
            "operation": " use \"T1\" for the lap times table and \"T2\" for the drivers table for consistency."
        },
        "891": {
            "condition": "When answering about top 20 drivers with shortest lap times",
            "operation": " rank rows by lap time in ascending order and keep the first 20 rows."
        },
        "892": {
            "condition": "When combining lap times and drivers tables",
            "operation": " link rows where T1.driverId = T2.driverId and keep only matching pairs (inner match)."
        },
        "893": {
            "condition": "When extracting lap time information, When calculating time in seconds, When finding minimum lap times, When producing final output, When using table aliases, When answering about top 20 drivers with shortest lap times, When combining lap times and drivers tables, When the question asks for full names",
            "operation": " output both forename and surname columns from the drivers table."
        },
        "894": {
            "condition": "When parsing time values that may contain empty strings",
            "operation": " use CASE statements to validate each time component before casting instead of direct casting without validation."
        },
        "895": {
            "condition": "When selecting driver information",
            "operation": " include driverId in the final output columns instead of omitting it."
        },
        "896": {
            "condition": "When referencing tables in joins",
            "operation": " use table aliases T1 and T2 instead of unaliased table names."
        },
        "897": {
            "condition": "When parsing time values that may contain empty strings, When selecting driver information, When referencing tables in joins, When handling potentially null time values",
            "operation": " remove explicit NULL filters as CASE statements handle null values appropriately."
        },
        "898": {
            "condition": "When the question asks about Lewis Hamilton's fastest lap",
            "operation": " join table \"lapTimes\" as T1 with table \"drivers\" as T2 on T1.driverId = T2.driverId using an inner match."
        },
        "899": {
            "condition": "When filtering for Lewis Hamilton",
            "operation": " use T2.forename = 'Lewis' and T2.surname = 'Hamilton' as exact literal conditions."
        },
        "900": {
            "condition": "When finding the fastest lap",
            "operation": " order rows by T1.time in ascending order and keep only the first row."
        },
        "901": {
            "condition": "When the question asks about Lewis Hamilton's fastest lap, When filtering for Lewis Hamilton, When finding the fastest lap, When selecting the position",
            "operation": " output T1.position as the result column."
        },
        "902": {
            "condition": "When answering about lap records",
            "operation": " use a CTE named fastest_lap_times instead of querying lap_records directly."
        },
        "903": {
            "condition": "When selecting lap time data",
            "operation": " select from results table with alias T1 instead of lap_records, filtering for FastestLapTime IS NOT NULL."
        },
        "904": {
            "condition": "When combining race information",
            "operation": " add INNER JOIN on races AS T2 with predicate fastest_lap_times.raceId = T2.raceId."
        },
        "905": {
            "condition": "When combining circuit information",
            "operation": " add INNER JOIN on circuits AS T3 with predicate T2.circuitId = T3.circuitId."
        },
        "906": {
            "condition": "When filtering for Austrian Grand Prix",
            "operation": " use T2.name = 'Austrian Grand Prix' instead of circuit_name = 'Austrian Grand Prix Circuit' to match the correct race naming convention."
        },
        "907": {
            "condition": "When answering about lap records, When selecting lap time data, When combining race information, When combining circuit information, When filtering for Austrian Grand Prix, When computing the lap record",
            "operation": " aggregate MIN(fastest_lap_times.fastestLapTime) with alias lap_record instead of MIN(lap_time) from the wrong table."
        },
        "908": {
            "condition": "When answering about lap records for circuits in Italy",
            "operation": " restructure the query to use multiple INNER JOIN operations between results, races, and circuits tables instead of querying only circuits."
        },
        "909": {
            "condition": "When the question mentions \"lap records\"",
            "operation": " calculate the minimum lap time using time conversion logic with CAST, SUBSTR, and INSTR functions to convert FastestLapTime to seconds."
        },
        "910": {
            "condition": "When filtering for Italian circuits",
            "operation": " apply the country filter 'Italy' in a subquery that calculates the minimum lap time rather than directly in the main WHERE clause."
        },
        "911": {
            "condition": "When combining results, races, and circuits tables",
            "operation": " use join conditions matching the converted lap time to the minimum time found in Italian circuits."
        },
        "912": {
            "condition": "When answering about lap records for circuits in Italy, When the question mentions \"lap records\", When filtering for Italian circuits, When combining results, races, and circuits tables, When the question asks for lap records",
            "operation": " return only the fastest lap record using LIMIT 1 instead of all Italian circuits."
        },
        "913": {
            "condition": "When answering about lap records for circuits in Italy",
            "operation": " make sure the output order contains only the lap_record column instead of multiple columns like circuit_name, race_name, and driver_name."
        },
        "914": {
            "condition": "When converting fastest lap times that include milliseconds",
            "operation": " properly handle the millisecond component by adding (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') +"
        },
        "915": {
            "condition": "AS REAL) /",
            "operation": "AS REAL) /"
        },
        "916": {
            "condition": "to the time conversion calculation.",
            "operation": "to the time conversion calculation."
        },
        "917": {
            "condition": "When filtering for circuits in Italy",
            "operation": " apply the country = 'Italy' condition only to the subquery that calculates the minimum time instead of applying it globally."
        },
        "918": {
            "condition": "When finding the minimum lap time",
            "operation": " use a subquery with proper joins to races and circuits tables instead of filtering a CTE directly."
        },
        "919": {
            "condition": "When answering about lap records for circuits in Italy, When converting fastest lap times that include milliseconds, AS REAL) /, to the time conversion calculation., When filtering for circuits in Italy, When finding the minimum lap time, When comparing lap times",
            "operation": " change the final join condition to compare the calculated time with the minimum time from the subquery instead of using a WHERE clause with a subquery."
        },
        "920": {
            "condition": "When answering about lap records for circuits in Italy",
            "operation": " make sure the output order includes T1.FastestLapTime as lap_record."
        },
        "921": {
            "condition": "When combining tables for lap records",
            "operation": " link rows where T1.raceId = T2.raceId and T2.circuitId = T3.circuitId using inner joins."
        },
        "922": {
            "condition": "When filtering for Italian circuits",
            "operation": " ensure T3.country = 'Italy' exactly."
        },
        "923": {
            "condition": "When finding the fastest lap time",
            "operation": " compute the minimum converted time using (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') -"
        },
        "924": {
            "condition": "AS REAL) *",
            "operation": "AS REAL) *"
        },
        "925": {
            "condition": "+ CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '",
            "operation": "') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') -"
        },
        "926": {
            "condition": "AS REAL) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') +",
            "operation": "AS REAL) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') +"
        },
        "927": {
            "condition": "AS REAL) /",
            "operation": "AS REAL) /"
        },
        "928": {
            "condition": "for Italian circuits.",
            "operation": "for Italian circuits."
        },
        "929": {
            "condition": "When answering about lap records for circuits in Italy, When combining tables for lap records, When filtering for Italian circuits, When finding the fastest lap time, AS REAL) *, + CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ', AS REAL) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') +, AS REAL) /, for Italian circuits., When comparing lap times",
            "operation": " match the converted time from T1 against the minimum converted time subquery result using equality comparison."
        },
        "930": {
            "condition": "When the question asks about the Formula 1 race with the lap record for a specific circuit",
            "operation": " use the exact circuit name literal 'Austrian Grand Prix' from the amends instead of 'Austrian Grand Prix Circuit'."
        },
        "931": {
            "condition": "When converting lap times for comparison",
            "operation": " convert the FastestLapTime to seconds using CAST, SUBSTR, and INSTR functions as shown in the amends instead of using a simple lap_time column."
        },
        "932": {
            "condition": "When combining data from multiple tables",
            "operation": " perform INNER JOINs connecting races (T1), circuits (T2), and results tables using the exact join conditions specified in the amends."
        },
        "933": {
            "condition": "When finding the minimum lap time",
            "operation": " use a subquery to calculate the minimum lap time in seconds instead of simple ordering with LIMIT."
        },
        "934": {
            "condition": "When identifying the race with the fastest lap",
            "operation": " match the calculated lap time in seconds to the minimum time using an equality join condition instead of ORDER BY and LIMIT."
        },
        "935": {
            "condition": "When the question asks about the Formula 1 race with the lap record for a specific circuit, When converting lap times for comparison, When combining data from multiple tables, When finding the minimum lap time, When identifying the race with the fastest lap, When selecting the output",
            "operation": " use T2.name for the race name instead of race_name."
        },
        "936": {
            "condition": "When the question asks about Formula 1 races at a specific circuit",
            "operation": " filter the circuits table using T2.name = 'Austrian Grand Prix' exactly as specified."
        },
        "937": {
            "condition": "When calculating lap times with millisecond precision",
            "operation": " convert the FastestLapTime by extracting minutes, seconds, and milliseconds using SUBSTR and INSTR functions, then combine them as (minutes *"
        },
        "938": {
            "condition": "+ seconds + (milliseconds / 1000).",
            "operation": "+ seconds + (milliseconds / 1000)."
        },
        "939": {
            "condition": "When finding the minimum lap time",
            "operation": " compute the minimum converted lap time value across all relevant records."
        },
        "940": {
            "condition": "When joining tables for race and circuit information",
            "operation": " use T1 for results, T2 for circuits, and T3 for races with proper join conditions as shown in the schema relationships."
        },
        "941": {
            "condition": "When the question asks about Formula 1 races at a specific circuit, When calculating lap times with millisecond precision, + seconds + (milliseconds / 1000)., When finding the minimum lap time, When joining tables for race and circuit information, When outputting results",
            "operation": " only include the race name in the final output, excluding year, circuit_name, and other intermediate columns."
        },
        "942": {
            "condition": "When answering about lap records and pit stops",
            "operation": " use a CTE structure with fastest_lap_times and lap_record_race instead of simple subqueries."
        },
        "943": {
            "condition": "When calculating lap times",
            "operation": " convert to seconds using CAST and string manipulation functions instead of assuming a simple time column."
        },
        "944": {
            "condition": "When combining data from multiple tables",
            "operation": " join results, races, and circuits tables instead of querying only races."
        },
        "945": {
            "condition": "When filtering for the Austrian Grand Prix",
            "operation": " use T2.name = 'Austrian Grand Prix' instead of 'Austrian Grand Prix Circuit'."
        },
        "946": {
            "condition": "When finding the fastest lap record",
            "operation": " use MIN(fastest_lap_times.time_in_seconds) to identify the minimum lap time."
        },
        "947": {
            "condition": "When joining tables",
            "operation": " use proper join conditions with raceId and driverId columns instead of driver name matching."
        },
        "948": {
            "condition": "When answering about lap records and pit stops, When calculating lap times, When combining data from multiple tables, When filtering for the Austrian Grand Prix, When finding the fastest lap record, When joining tables, When retrieving pit stop duration",
            "operation": " get duration from pitStops table instead of pit_stop_time from races."
        },
        "949": {
            "condition": "When answering about the fastest lap time",
            "operation": " use the \"results\" table with \"FastestLapTime\" column instead of \"lapTimes\" table with \"time\" column."
        },
        "950": {
            "condition": "When converting time format",
            "operation": " handle only the MM:SS.fff format and calculate as (minutes*60) + seconds + (milliseconds/1000) instead of complex string parsing."
        },
        "951": {
            "condition": "When filtering for valid fastest lap times",
            "operation": " ensure FastestLapTime IS NOT NULL."
        },
        "952": {
            "condition": "When finding the minimum time",
            "operation": " use a subquery to find the minimum time instead of GROUP BY with MIN aggregation."
        },
        "953": {
            "condition": "When joining on the calculated time",
            "operation": " match the minimum time instead of grouping by race and driver."
        },
        "954": {
            "condition": "When filtering races by circuit name",
            "operation": " use T2.name = 'Austrian Grand Prix' instead of c.name = 'Austrian Grand Prix'."
        },
        "955": {
            "condition": "When selecting from CTE",
            "operation": " only select raceId and driverId instead of including the time value."
        },
        "956": {
            "condition": "When answering about the fastest lap time, When converting time format, When filtering for valid fastest lap times, When finding the minimum time, When joining on the calculated time, When filtering races by circuit name, When selecting from CTE, When joining with pitStops",
            "operation": " join directly with pitStops table instead of using additional CTE layers."
        },
        "957": {
            "condition": "When the question asks for location coordinates of circuits",
            "operation": " select \"T3.lat\" and \"T3.lng\" instead of latitude and longitude."
        },
        "958": {
            "condition": "When finding circuits by lap record time",
            "operation": " join \"lapTimes AS T1\" and \"races AS T2\" using inner match where \"T1.raceId = T2.raceId\"."
        },
        "959": {
            "condition": "When connecting to circuit coordinates",
            "operation": " join \"circuits AS T3\" using inner match where \"T2.circuitId = T3.circuitId\"."
        },
        "960": {
            "condition": "When the question asks for location coordinates of circuits, When finding circuits by lap record time, When connecting to circuit coordinates, When filtering for lap record time '1",
            "operation": "29.488': use the exact condition \"T1.time = '1:29.488'\" instead of lap_record."
        },
        "961": {
            "condition": "When answering about \"average time in milliseconds Lewis Hamilton spent at a pit stop\"",
            "operation": " make sure the output order: AVG(milliseconds)."
        },
        "962": {
            "condition": "When the question mentions \"Lewis Hamilton\"",
            "operation": " \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\" in schema."
        },
        "963": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.driverId = T2.driverId; keep only matching pairs (inner match)."
        },
        "964": {
            "condition": "When answering about \"average time in milliseconds Lewis Hamilton spent at a pit stop\", When the question mentions \"Lewis Hamilton\", When combining T1 and T2 for shared entities, When the question asks for \"average time in milliseconds\"",
            "operation": " compute AVG(milliseconds) from T1 instead of pit_stop_time."
        },
        "965": {
            "condition": "When calculating average lap time in milliseconds",
            "operation": " use CAST(SUM(T1.milliseconds) AS REAL) / COUNT(T1.lap) instead of AVG(lap_time) to ensure proper type casting and explicit aggregation."
        },
        "966": {
            "condition": "When accessing circuit information for filtering by country",
            "operation": " join lapTimes AS T1 with races AS T2 on T1.raceId = T2.raceId, then join circuits AS T3 on T2.circuitId = T3.circuitId."
        },
        "967": {
            "condition": "When calculating average lap time in milliseconds, When accessing circuit information for filtering by country, When filtering for circuits in Italy",
            "operation": " use T3.country = 'Italy' to reference the circuit's country field rather than an unspecified table's country field."
        }
    },
    "european_football_2": {
        "0": {
            "condition": "When answering about \"highest overall rating\"",
            "operation": " use the table \"Player_Attributes\" as the source table instead of \"players\"."
        },
        "1": {
            "condition": "When selecting the player's api id",
            "operation": " use the exact column name \"player_api_id\" instead of \"api_id\"."
        },
        "2": {
            "condition": "When answering about \"highest overall rating\", When selecting the player's api id, When finding the highest overall rating",
            "operation": " order by \"overall_rating\" in descending direction and keep only the top 1 row."
        },
        "3": {
            "condition": "When the question asks for \"height of the tallest player\"",
            "operation": " sort rows from table \"Player\" by column \"height\" in descending order and keep only the first row."
        },
        "4": {
            "condition": "When the question asks to indicate the player's name",
            "operation": " include column \"player_name\" in the output."
        },
        "5": {
            "condition": "When referencing the table containing player information",
            "operation": " use the exact table name \"Player\" (case-sensitive) instead of \"players\"."
        },
        "6": {
            "condition": "When ordering by height to find the tallest",
            "operation": " use the exact column name \"height\" for sorting in descending direction."
        },
        "7": {
            "condition": "When the question asks for \"height of the tallest player\", When the question asks to indicate the player's name, When referencing the table containing player information, When ordering by height to find the tallest, When limiting results to only the tallest player",
            "operation": " return exactly one row using limit 1."
        },
        "8": {
            "condition": "When the question asks for the tallest player's name but not the height value",
            "operation": " exclude the height column from the output and return only the player_name column."
        },
        "9": {
            "condition": "When identifying the tallest player",
            "operation": " order all players by height in descending order and take the first row."
        },
        "10": {
            "condition": "When the question asks for the tallest player's name but not the height value, When identifying the tallest player, When the question asks for \"the tallest player\"",
            "operation": " use the exact column name \"height\" from the Player table for comparison and ordering."
        },
        "11": {
            "condition": "When answering about \"preferred foot when attacking\"",
            "operation": " query the \"Player_Attributes\" table instead of the \"players\" table."
        },
        "12": {
            "condition": "When filtering for \"potential\" values",
            "operation": " add \"IS NOT NULL\" filter to exclude null values."
        },
        "13": {
            "condition": "When finding the player with the \"lowest potential\"",
            "operation": " use \"ORDER BY potential ASC LIMIT 1\" instead of a subquery with MAX(potential)."
        },
        "14": {
            "condition": "When answering about \"preferred foot when attacking\", When filtering for \"potential\" values, When finding the player with the \"lowest potential\", When handling ordering and limiting",
            "operation": " add explicit \"ORDER BY\" and \"LIMIT\" clauses instead of relying on implicit behavior."
        },
        "15": {
            "condition": "When counting players",
            "operation": " count \"id\" instead of \"*\" to avoid counting null values."
        },
        "16": {
            "condition": "When querying player attributes",
            "operation": " use table \"Player_Attributes\" instead of \"players\" to access the correct table."
        },
        "17": {
            "condition": "When filtering for players who focus on attack moves instead of defense",
            "operation": " use condition \"defensive_work_rate = 'low'\" instead of non-existent attack_moves conditions."
        },
        "18": {
            "condition": "When counting players, When querying player attributes, When filtering for players who focus on attack moves instead of defense, When filtering for overall rating between 60 to 65",
            "operation": " use \"overall_rating BETWEEN 60 AND 65\" to include the specified range."
        },
        "19": {
            "condition": "When the question asks for \"top 5 players who perform better in crossing actions\"",
            "operation": " rank players by their crossing attribute in descending order and keep the first 5 rows."
        },
        "20": {
            "condition": "When the question asks for player id",
            "operation": " use the exact column \"id\" from the Player_Attributes table instead of \"player_id\"."
        },
        "21": {
            "condition": "When ordering by crossing performance",
            "operation": " use the exact column \"crossing\" from the Player_Attributes table instead of counting crossing actions."
        },
        "22": {
            "condition": "When retrieving data about player attributes",
            "operation": " use the Player_Attributes table instead of player_actions table."
        },
        "23": {
            "condition": "When the question asks for \"top 5 players who perform better in crossing actions\", When the question asks for player id, When ordering by crossing performance, When retrieving data about player attributes, When selecting output columns",
            "operation": " include only the \"id\" column to indicate player id."
        },
        "24": {
            "condition": "When the question asks for \"top 5 players who perform better in crossing actions\"",
            "operation": " rank players by their crossing attribute in descending order and keep the first 5 rows."
        },
        "25": {
            "condition": "When the question asks for \"player id\" from Player_Attributes table",
            "operation": " select the \"id\" column instead of \"player_api_id\" column."
        },
        "26": {
            "condition": "When the question asks for \"top 5 players who perform better in crossing actions\", When the question asks for \"player id\" from Player_Attributes table, When ordering by crossing performance",
            "operation": " use the \"crossing\" column from Player_Attributes table with DESC direction to get highest values first."
        },
        "27": {
            "condition": "When answering about \"most goals in the 2016 season\"",
            "operation": " use the exact season format '2015/2016' instead of '2016' to match the correct season format."
        },
        "28": {
            "condition": "When calculating total goals",
            "operation": " compute SUM(t1.home_team_goal + t1.away_team_goal) instead of using a simple goals column."
        },
        "29": {
            "condition": "When joining Match and League tables",
            "operation": " use INNER JOIN with the condition t1.league_id = t2.id to properly link the tables."
        },
        "30": {
            "condition": "When selecting league names",
            "operation": " use t2.name instead of league_name to reference the correct column from the joined table."
        },
        "31": {
            "condition": "When grouping results",
            "operation": " group by t2.name instead of league_name to ensure proper aggregation by league."
        },
        "32": {
            "condition": "When answering about \"most goals in the 2016 season\", When calculating total goals, When joining Match and League tables, When selecting league names, When grouping results, When ordering by total goals",
            "operation": " order by SUM(t1.home_team_goal + t1.away_team_goal) DESC instead of total_goals DESC to reference the actual calculated sum."
        },
        "33": {
            "condition": "When the question asks about home teams",
            "operation": " use \"teamDetails.team_long_name\" to display the team name instead of \"home_team\"."
        },
        "34": {
            "condition": "When combining match data with team details",
            "operation": " link rows where \"matchData.home_team_api_id = teamDetails.team_api_id\" and keep only matching pairs (inner match)."
        },
        "35": {
            "condition": "When filtering for the 2016 season",
            "operation": " use exact literal \"2015/2016\" for \"matchData.season\" instead of numeric 2016."
        },
        "36": {
            "condition": "When determining if a home team lost",
            "operation": " calculate \"matchData.home_team_goal - matchData.away_team_goal < 0\" instead of comparing home_score and away_score."
        },
        "37": {
            "condition": "When grouping by home team",
            "operation": " use \"matchData.home_team_api_id\" as the grouping key instead of the team name."
        },
        "38": {
            "condition": "When ordering by number of losses",
            "operation": " order by \"COUNT(*)\" in ascending order to find the team with fewest losses."
        },
        "39": {
            "condition": "When the question asks about home teams, When combining match data with team details, When filtering for the 2016 season, When determining if a home team lost, When grouping by home team, When ordering by number of losses, When finding the team with fewest losses",
            "operation": " take only the first row after ordering by loss count ascending."
        },
        "40": {
            "condition": "When answering about \"top 10 players with highest number of penalties\"",
            "operation": " make sure the output order: t2.player_name."
        },
        "41": {
            "condition": "When combining Player_Attributes (as T1) and Player (as T2) tables",
            "operation": " link rows where T1.id = T2.id and keep only matching pairs (inner match)."
        },
        "42": {
            "condition": "When ordering by penalties",
            "operation": " use T1.penalties DESC to rank players from highest to lowest."
        },
        "43": {
            "condition": "When answering about \"top 10 players with highest number of penalties\", When combining Player_Attributes (as T1) and Player (as T2) tables, When ordering by penalties, When the question mentions \"top 10\"",
            "operation": " rank rows by T1.penalties in descending order and keep the first 10 rows."
        },
        "44": {
            "condition": "When joining Player_Attributes and Player tables",
            "operation": " link rows where t1.id = t2.id exactly as shown in the amends, keeping only matching pairs (inner match)."
        },
        "45": {
            "condition": "When answering about \"top 10 players with highest number of penalties\"",
            "operation": " rank rows by t1.penalties in descending order and keep the first 10 rows."
        },
        "46": {
            "condition": "When joining Player_Attributes and Player tables, When answering about \"top 10 players with highest number of penalties\", When producing output",
            "operation": " make sure the output order includes only t2.player_name as the full names of players."
        },
        "47": {
            "condition": "When answering about away team wins in Scotland Premier League",
            "operation": " make sure the output order: teamInfo.team_long_name first, then the count of wins."
        },
        "48": {
            "condition": "When the question mentions \"Scotland Premier League\"",
            "operation": " \"Scotland Premier League\" actually means \"leagueData.name = 'Scotland Premier League'\" in schema."
        },
        "49": {
            "condition": "When the question mentions \"2010 season\"",
            "operation": " \"2010 season\" actually means \"matchData.season = '2009/2010'\" in schema."
        },
        "50": {
            "condition": "When the question asks for \"away team won\"",
            "operation": " use condition \"matchData.away_team_goal - matchData.home_team_goal > 0\" instead of home_score > away_score."
        },
        "51": {
            "condition": "When combining leagueData and matchData",
            "operation": " link rows where leagueData.id = matchData.league_id and keep only matching pairs (inner match)."
        },
        "52": {
            "condition": "When combining matchData and teamInfo",
            "operation": " link rows where matchData.away_team_api_id = teamInfo.team_api_id and keep only matching pairs (inner match)."
        },
        "53": {
            "condition": "When grouping by away team",
            "operation": " group by matchData.away_team_api_id instead of home_team."
        },
        "54": {
            "condition": "When counting wins",
            "operation": " count the number of rows using the matchData table's records that satisfy the win condition."
        },
        "55": {
            "condition": "When answering about away team wins in Scotland Premier League, When the question mentions \"Scotland Premier League\", When the question mentions \"2010 season\", When the question asks for \"away team won\", When combining leagueData and matchData, When combining matchData and teamInfo, When grouping by away team, When counting wins, When the question asks for \"the most\" wins",
            "operation": " rank rows by the count of wins in descending order and keep the first 1 row."
        },
        "56": {
            "condition": "When the question asks for \"which away team won the most\"",
            "operation": " count the number of wins using the canonical counting method of goal difference comparison (away_team_goal - home_team_goal >"
        },
        "57": {
            "condition": "instead of direct goal comparison.",
            "operation": "instead of direct goal comparison."
        },
        "58": {
            "condition": "When computing aggregate counts for ordering",
            "operation": " use COUNT(*) directly in the ORDER BY clause instead of referencing an alias when the aggregate is not selected in the output."
        },
        "59": {
            "condition": "When filtering for Scottish Premier League matches",
            "operation": " use the exact literal 'Scotland Premier League' for league name comparison."
        },
        "60": {
            "condition": "When filtering for the 2010 season",
            "operation": " use the exact literal '2009/2010' for season comparison."
        },
        "61": {
            "condition": "When the question asks for \"which away team won the most\", instead of direct goal comparison., When computing aggregate counts for ordering, When filtering for Scottish Premier League matches, When filtering for the 2010 season, When identifying away team wins",
            "operation": " ensure the output includes only the team_long_name from the Team table without any aggregate columns."
        },
        "62": {
            "condition": "When answering about \"speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed\"",
            "operation": " make sure the output order: t1.buildUpPlaySpeed"
        },
        "63": {
            "condition": "When the question mentions \"top 4 teams with the highest build Up Play Speed\"",
            "operation": " actually means \"the four lowest values of buildUpPlaySpeed in ascending order\" in schema"
        },
        "64": {
            "condition": "When combining Team_Attributes as t1 and Team as t2",
            "operation": " link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)"
        },
        "65": {
            "condition": "When producing output",
            "operation": " include only t1.buildUpPlaySpeed column, not team_name"
        },
        "66": {
            "condition": "When answering about \"speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed\", When the question mentions \"top 4 teams with the highest build Up Play Speed\", When combining Team_Attributes as t1 and Team as t2, When producing output, When ordering results",
            "operation": " sort by t1.buildUpPlaySpeed in ascending order instead of descending order"
        },
        "67": {
            "condition": "When the question asks about league names",
            "operation": " use \"t2.name\" from the \"League\" table instead of \"league_name\" from \"leagues\"."
        },
        "68": {
            "condition": "When combining match and league data",
            "operation": " perform an inner join between \"Match AS t1\" and \"League AS t2\" where \"t1.league_id = t2.id\"."
        },
        "69": {
            "condition": "When filtering for the 2016 season",
            "operation": " use \"t1.season = '2015/2016'\" instead of \"season = '2016'\"."
        },
        "70": {
            "condition": "When identifying draw matches",
            "operation": " use the condition \"t1.home_team_goal = t1.away_team_goal\" instead of checking for \"result = 'draw'\"."
        },
        "71": {
            "condition": "When counting matches per league",
            "operation": " use \"GROUP BY t2.name\" with \"COUNT(t1.id)\" aggregation."
        },
        "72": {
            "condition": "When the question asks about league names, When combining match and league data, When filtering for the 2016 season, When identifying draw matches, When counting matches per league, When finding the league with most draws",
            "operation": " order by \"COUNT(t1.id) DESC\" and take the top result."
        },
        "73": {
            "condition": "When the question asks for player ages with sprint speed conditions",
            "operation": " use DISTINCT to eliminate duplicate rows."
        },
        "74": {
            "condition": "When calculating player age",
            "operation": " compute age using DATETIME() - T2.birthday instead of simple year subtraction for proper date arithmetic."
        },
        "75": {
            "condition": "When accessing player data",
            "operation": " reference tables Player_Attributes AS T1 and Player AS T2 with proper table aliases."
        },
        "76": {
            "condition": "When combining player attributes and player information",
            "operation": " use INNER JOIN on T1.player_api_id = T2.player_api_id to properly link the two related tables."
        },
        "77": {
            "condition": "When filtering by year range 2013 to 2015",
            "operation": " use STRFTIME('%Y',T1.date) >= '2013' AND STRFTIME('%Y',T1.date) <= '2015' to properly extract and compare year components from date strings."
        },
        "78": {
            "condition": "When the question asks for player ages with sprint speed conditions, When calculating player age, When accessing player data, When combining player attributes and player information, When filtering by year range 2013 to 2015, When referencing sprint speed",
            "operation": " use T1.sprint_speed with proper table qualification instead of unqualified sprint_speed."
        },
        "79": {
            "condition": "When the question asks to calculate player ages",
            "operation": " only include the age calculation in the output, not player names or sprint speed values."
        },
        "80": {
            "condition": "When calculating age from birthday",
            "operation": " use DATETIME('now') - t2.birthday without parentheses around the datetime function."
        },
        "81": {
            "condition": "When filtering by sprint speed",
            "operation": " place the t1.sprint_speed >= 97 condition at the end of the WHERE clause."
        },
        "82": {
            "condition": "When the question asks to calculate player ages, When calculating age from birthday, When filtering by sprint speed, When the question specifies a date range between 2013 to 2015",
            "operation": " filter using STRFTIME('%Y', t1.date) >= '2013' AND STRFTIME('%Y', t1.date) <= '2015' to include both years inclusively."
        },
        "83": {
            "condition": "When calculating age from a birthday field",
            "operation": " use DATETIME() - T2.birthday instead of complex strftime arithmetic with year subtraction and date comparison."
        },
        "84": {
            "condition": "When the question asks for distinct values",
            "operation": " maintain SELECT DISTINCT clause to return unique results."
        },
        "85": {
            "condition": "When combining Player_Attributes and Player tables",
            "operation": " use INNER JOIN with T1.player_api_id = T2.player_api_id as the join condition."
        },
        "86": {
            "condition": "When filtering by year range 2013 to 2015",
            "operation": " use STRFTIME('%Y',t1.date) >= '2013' AND STRFTIME('%Y',t1.date) <= '2015' with exact literals '2013' and '2015'."
        },
        "87": {
            "condition": "When calculating age from a birthday field, When the question asks for distinct values, When combining Player_Attributes and Player tables, When filtering by year range 2013 to 2015, When filtering by sprint speed",
            "operation": " use t1.sprint_speed >= 97 with the exact numeric value 97."
        },
        "88": {
            "condition": "league with highest matches of all time refers to MAX(COUNT(league_id));",
            "operation": "league with highest matches of all time refers to MAX(COUNT(league_id));"
        },
        "89": {
            "condition": "When calculating average height",
            "operation": " compute SUM(height) / COUNT(id) instead of using AVG(weight)"
        },
        "90": {
            "condition": "When referencing the players table",
            "operation": " use exact table name \"Player\" instead of \"players\""
        },
        "91": {
            "condition": "When filtering by birth years between 1990 and 1995",
            "operation": " extract year using SUBSTR(birthday, 1,"
        },
        "92": {
            "condition": "When calculating average height, When referencing the players table, When filtering by birth years between 1990 and 1995, and compare with string literals '1990' and '1995' instead of using numeric birth_year column",
            "operation": "When calculating average height, When referencing the players table, When filtering by birth years between 1990 and 1995, and compare with string literals '1990' and '1995' instead of using numeric birth_year column"
        },
        "93": {
            "condition": "When answering about players' api id",
            "operation": " select \"player_api_id\" instead of \"api_id\"."
        },
        "94": {
            "condition": "When the question mentions \"highest above average overall ratings in 2010\"",
            "operation": " use the \"Player_Attributes\" table instead of the \"players\" table."
        },
        "95": {
            "condition": "When filtering for the year 2010",
            "operation": " use SUBSTR(date, 1,"
        },
        "96": {
            "condition": "= '2010' instead of year = 2010.",
            "operation": "= '2010' instead of year = 2010."
        },
        "97": {
            "condition": "When answering about players' api id, When the question mentions \"highest above average overall ratings in 2010\", When filtering for the year 2010, = '2010' instead of year = 2010., When finding the highest rating",
            "operation": " order by overall_rating in descending direction and keep the first row."
        },
        "98": {
            "condition": "When the question asks for \"highest above average overall ratings\"",
            "operation": " use ORDER BY overall_rating DESC LIMIT 1 instead of a subquery with MAX(overall_rating) to find the single highest rated player."
        },
        "99": {
            "condition": "When handling the date column",
            "operation": " use explicit backticks around `date` column for better SQL compatibility."
        },
        "100": {
            "condition": "When filtering for year 2010",
            "operation": " use SUBSTR(date, 1,"
        },
        "101": {
            "condition": "When the question asks for \"highest above average overall ratings\", When handling the date column, When filtering for year 2010, = '2010' to extract the year portion from the date string.",
            "operation": "When the question asks for \"highest above average overall ratings\", When handling the date column, When filtering for year 2010, = '2010' to extract the year portion from the date string."
        },
        "102": {
            "condition": "When the question asks for team long names",
            "operation": " use \"t4.team_long_name\" with DISTINCT instead of \"long_name\" without distinct."
        },
        "103": {
            "condition": "When combining team attributes and team information",
            "operation": " join \"Team_Attributes AS t3\" with \"Team AS t4\" on \"t3.team_api_id = t4.team_api_id\" using inner match."
        },
        "104": {
            "condition": "When filtering for year 2012 in team attributes",
            "operation": " use \"SUBSTR(t3.date, 1,"
        },
        "105": {
            "condition": "= '2012'\" instead of a year column.",
            "operation": "= '2012'\" instead of a year column."
        },
        "106": {
            "condition": "When calculating the average build-up play passing",
            "operation": " use \"CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id)\" with proper casting and aggregation."
        },
        "107": {
            "condition": "When the question asks for team long names, When combining team attributes and team information, When filtering for year 2012 in team attributes, = '2012'\" instead of a year column., When calculating the average build-up play passing, When correlating the subquery for average calculation",
            "operation": " join \"Team AS t1\" with \"Team_Attributes AS t2\" on \"team_api_id\" and filter with \"STRFTIME('%Y',t2.date) = '2012'\" to ensure year-specific correlation."
        },
        "108": {
            "condition": "When answering about percentage of players who prefer left foot",
            "operation": " join Player as T1 with Player_Attributes as T2 using T1.player_api_id = T2.player_api_id to access preferred_foot information."
        },
        "109": {
            "condition": "When filtering players born between 1987 and 1992",
            "operation": " extract year from T1.birthday using SUBSTR(T1.birthday, 1,"
        },
        "110": {
            "condition": "and check if it's between '1987' AND '1992'.",
            "operation": "and check if it's between '1987' AND '1992'."
        },
        "111": {
            "condition": "When counting players who prefer left foot",
            "operation": " use COUNT(CASE WHEN T2.preferred_foot = 'left' THEN T1.id ELSE NULL END) to count only left-footed players."
        },
        "112": {
            "condition": "When calculating the percentage",
            "operation": " compute (left-footed count * 100.0 / total count) with CAST(... AS REAL) for floating-point division."
        },
        "113": {
            "condition": "When naming the result column",
            "operation": " use percent as the output column name instead of percentage_left_foot."
        },
        "114": {
            "condition": "When answering about percentage of players who prefer left foot, When filtering players born between 1987 and 1992, and check if it's between '1987' AND '1992'., When counting players who prefer left foot, When calculating the percentage, When naming the result column, When counting total players",
            "operation": " use T1.id as the counting key instead of counting all rows with *."
        },
        "115": {
            "condition": "When answering about \"top 5 leagues in ascending order of the number of goals\"",
            "operation": " make sure the output order: t1.name, then the calculated total goals sum."
        },
        "116": {
            "condition": "When the question mentions \"number of goals made\"",
            "operation": " goals actually means the sum of t2.home_team_goal and t2.away_team_goal from the Match table."
        },
        "117": {
            "condition": "When combining League AS t1 and Match AS t2",
            "operation": " link rows where t1.id = t2.league_id exactly and keep only matching pairs (inner match)."
        },
        "118": {
            "condition": "When the question asks for \"top 5\" in ascending order",
            "operation": " rank rows by the calculated total goals sum in ascending order and keep the first 5 rows."
        },
        "119": {
            "condition": "When answering about \"top 5 leagues in ascending order of the number of goals\", When the question mentions \"number of goals made\", When combining League AS t1 and Match AS t2, When the question asks for \"top 5\" in ascending order, When grouping by league",
            "operation": " organize results by t1.name and compute the sum of goals per league group."
        },
        "120": {
            "condition": "When answering about \"average number of long-shot done by Ahmed Samir Farag\"",
            "operation": " make sure the output order: calculate average manually using SUM(t2.long_shots) divided by COUNT(t2.date) with CAST to REAL instead of using AVG function."
        },
        "121": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id exactly and keep only matching pairs (inner match)."
        },
        "122": {
            "condition": "When the question mentions \"long-shot\"",
            "operation": " \"long-shot\" actually means \"t2.long_shots\" in schema from the Player_Attributes table."
        },
        "123": {
            "condition": "When the question mentions \"Ahmed Samir Farag\"",
            "operation": " \"Ahmed Samir Farag\" actually means filtering by t1.player_name = 'Ahmed Samir Farag' exactly as written."
        },
        "124": {
            "condition": "When answering about \"average number of long-shot done by Ahmed Samir Farag\", When combining Player and Player_Attributes tables, When the question mentions \"long-shot\", When the question mentions \"Ahmed Samir Farag\", When handling division operations",
            "operation": " always use CAST to REAL for the division to ensure proper numeric casting instead of relying on implicit casting."
        },
        "125": {
            "condition": "When the question asks for \"players' names\"",
            "operation": " use \"t1.player_name\" instead of \"name\" as the output column."
        },
        "126": {
            "condition": "When combining player data with player attributes",
            "operation": " perform an inner join between \"players\" table (as T1) and \"Player_Attributes\" table (as T2) using the exact key equality \"t1.player_api_id = t2.player_api_id\"."
        },
        "127": {
            "condition": "When filtering by height above 180",
            "operation": " apply the condition \"t1.height > 180\" to the players table."
        },
        "128": {
            "condition": "When calculating average heading accuracy per player",
            "operation": " compute \"CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id)\" for each player group."
        },
        "129": {
            "condition": "When grouping player data",
            "operation": " use \"t1.id\" as the grouping key to aggregate attributes per player."
        },
        "130": {
            "condition": "When ordering by average heading accuracy",
            "operation": " sort results in descending order of the calculated average heading accuracy value."
        },
        "131": {
            "condition": "When the question asks for \"players' names\", When combining player data with player attributes, When filtering by height above 180, When calculating average heading accuracy per player, When grouping player data, When ordering by average heading accuracy, When the question asks for \"top 10 players\"",
            "operation": " limit the results to the first 10 rows after ordering."
        },
        "132": {
            "condition": "When answering about team names",
            "operation": " use \"t3.team_long_name\" instead of \"team_name\" for the output column."
        },
        "133": {
            "condition": "When ordering by chance creation passing",
            "operation": " sort in descending order (DESC) instead of ascending order (ASC)."
        },
        "134": {
            "condition": "When combining team and team attributes data",
            "operation": " join \"Team AS t3\" with \"Team_Attributes AS t4\" using \"t3.team_api_id = t4.team_api_id\" instead of querying a single table."
        },
        "135": {
            "condition": "When filtering for normal build-up play dribbling class",
            "operation": " use \"t4.buildUpPlayDribblingClass = 'Normal'\" instead of \"build_up_play_dribbling_class = 'Normal'\"."
        },
        "136": {
            "condition": "When filtering for year 2014",
            "operation": " remove the direct \"year = 2014\" filter and instead use \"SUBSTR(t2.date, 1,"
        },
        "137": {
            "condition": "= '2014'\" for date-based filtering.",
            "operation": "= '2014'\" for date-based filtering."
        },
        "138": {
            "condition": "When answering about team names, When ordering by chance creation passing, When combining team and team attributes data, When filtering for normal build-up play dribbling class, When filtering for year 2014, = '2014'\" for date-based filtering., When calculating average chance creation passing",
            "operation": " use \"CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\" instead of \"AVG(chance_creation_passing)\" and maintain the \"buildUpPlayDribblingClass = 'Normal'\" condition within the subquery."
        },
        "139": {
            "condition": "When joining Team_Attributes with Team tables",
            "operation": " use the exact join condition t1.team_api_id = t2.team_api_id where t1 is Team and t2 is Team_Attributes."
        },
        "140": {
            "condition": "When filtering for buildUpPlayDribblingClass = 'Normal' in Team_Attributes",
            "operation": " apply the filter directly on the Team_Attributes table (t2.buildUpPlayDribblingClass = 'Normal')."
        },
        "141": {
            "condition": "When calculating average chanceCreationPassing for teams with Normal build-up play dribbling class in 2014",
            "operation": " filter by year using SUBSTR(t2.date, 1,"
        },
        "142": {
            "condition": "= '2014' in the subquery only, not in the main query.",
            "operation": "= '2014' in the subquery only, not in the main query."
        },
        "143": {
            "condition": "When the question asks for teams with less than average chance creation passing",
            "operation": " compare t4.chanceCreationPassing against the calculated average from the subquery."
        },
        "144": {
            "condition": "When joining Team_Attributes with Team tables, When filtering for buildUpPlayDribblingClass = 'Normal' in Team_Attributes, When calculating average chanceCreationPassing for teams with Normal build-up play dribbling class in 2014, = '2014' in the subquery only, not in the main query., When the question asks for teams with less than average chance creation passing, When ordering results in descending order of chance creation passing",
            "operation": " sort by t4.chanceCreationPassing DESC."
        },
        "145": {
            "condition": "When answering about \"leagues where average home goals exceed average away goals\"",
            "operation": " make sure the output order: t1.name"
        },
        "146": {
            "condition": "When the question mentions \"leagues\"",
            "operation": " \"leagues\" actually means \"League table as t1\" in schema"
        },
        "147": {
            "condition": "When the question mentions \"2009/2010 season\"",
            "operation": " filter rows where t2.season = '2009/2010' exactly"
        },
        "148": {
            "condition": "When combining League (t1) and Match (t2) tables",
            "operation": " link rows where t1.id = t2.league_id and keep only matching pairs (inner match)"
        },
        "149": {
            "condition": "When the question asks for \"average goals by home team vs away team per league\"",
            "operation": " group results by t1.name and compute (average home goals) minus (average away goals) using (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) minus (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id))"
        },
        "150": {
            "condition": "When filtering for leagues where home average exceeds away average",
            "operation": " apply the condition (average home goals minus average away goals) > 0 in the HAVING clause"
        },
        "151": {
            "condition": "When answering about \"leagues where average home goals exceed average away goals\", When the question mentions \"leagues\", When the question mentions \"2009/2010 season\", When combining League (t1) and Match (t2) tables, When the question asks for \"average goals by home team vs away team per league\", When filtering for leagues where home average exceeds away average, When counting matches for average calculations",
            "operation": " use COUNT(DISTINCT t2.id) as the canonical key for match counting"
        },
        "152": {
            "condition": "When the question asks for the short name of a football team",
            "operation": " select the \"team_short_name\" column from the \"Team\" table."
        },
        "153": {
            "condition": "When the question mentions \"Queens Park Rangers\"",
            "operation": " this refers to filtering where \"team_long_name\" equals 'Queens Park Rangers' exactly."
        },
        "154": {
            "condition": "When the question asks for the short name of a football team, When the question mentions \"Queens Park Rangers\", When querying from the Team table",
            "operation": " use the exact table name \"Team\" and do not use alternative table names like \"football_teams\"."
        },
        "155": {
            "condition": "When the question asks for football players with specific birth details",
            "operation": " select \"player_name\" from table \"Player\" instead of using *"
        },
        "156": {
            "condition": "When handling birthdate filtering",
            "operation": " use SUBSTR(birthday, 1,"
        },
        "157": {
            "condition": "= '1970-10' to extract both year and month from a single birthday field instead of separate year and month conditions",
            "operation": "= '1970-10' to extract both year and month from a single birthday field instead of separate year and month conditions"
        },
        "158": {
            "condition": "When the question asks for football players with specific birth details, When handling birthdate filtering, = '1970-10' to extract both year and month from a single birthday field instead of separate year and month conditions, When the question mentions \"birthyear of 1970 and birthmonth of October\"",
            "operation": " this translates to checking for the date pattern '1970-10' in the birthday field"
        },
        "159": {
            "condition": "When answering about \"attacking work rate of Franco Zennaro\"",
            "operation": " make sure the output order: t2.attacking_work_rate"
        },
        "160": {
            "condition": "When the question mentions \"Franco Zennaro\"",
            "operation": " \"Franco Zennaro\" actually means \"t1.player_name = 'Franco Zennaro'\" in schema"
        },
        "161": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (t1.player_api_id = t2.player_api_id); keep only matching pairs (inner match)"
        },
        "162": {
            "condition": "When the question asks for distinct values",
            "operation": " compute the number of unique values of the exact token for t2.attacking_work_rate"
        },
        "163": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "164": {
            "condition": "When answering about \"attacking work rate of Franco Zennaro\", When the question mentions \"Franco Zennaro\", When combining T1 and T2 for shared entities, When the question asks for distinct values, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Franco Zennaro'"
        },
        "165": {
            "condition": "When answering about ADO Den Haag team freedom of movement",
            "operation": " select \"t2\".\"buildUpPlayPositioningClass\" instead of \"freedom_of_movement\"."
        },
        "166": {
            "condition": "When retrieving data about team attributes",
            "operation": " use DISTINCT to ensure unique values."
        },
        "167": {
            "condition": "When combining team information with team attributes",
            "operation": " join \"Team\" AS \"t1\" INNER JOIN \"Team_attributes\" AS \"t2\" on \"t1\".\"team_fifa_api_id\" = \"t2\".\"team_fifa_api_id\" instead of querying only \"team_stats\"."
        },
        "168": {
            "condition": "When answering about ADO Den Haag team freedom of movement, When retrieving data about team attributes, When combining team information with team attributes, When filtering for ADO Den Haag team",
            "operation": " use \"t1\".\"team_long_name\" = 'ADO Den Haag' instead of filtering on \"team_name\" and \"pitch_zone\" conditions."
        },
        "169": {
            "condition": "When answering about football player finishing rate",
            "operation": " use \"t2.heading_accuracy\" as the finishing rate instead of calculating (goals_scored / headers_attempted) * 100."
        },
        "170": {
            "condition": "When combining player and player attributes data",
            "operation": " link rows where \"t1.player_api_id = t2.player_api_id\" and keep only matching pairs (inner match)."
        },
        "171": {
            "condition": "When filtering by date '2014-09-18'",
            "operation": " use \"SUBSTR(t2.date, 1,"
        },
        "172": {
            "condition": "= '2014-09-18'\" to handle date string extraction instead of direct date comparison.",
            "operation": "= '2014-09-18'\" to handle date string extraction instead of direct date comparison."
        },
        "173": {
            "condition": "When answering about football player finishing rate, When combining player and player attributes data, When filtering by date '2014-09-18', = '2014-09-18'\" to handle date string extraction instead of direct date comparison., When the question mentions \"Francois Affolter\"",
            "operation": " use \"player_name = 'Francois Affolter'\" as the filter condition."
        },
        "174": {
            "condition": "When answering about \"overall rating of football player Gabriel Tamas in year 2011\"",
            "operation": " make sure the output order: t2.overall_rating."
        },
        "175": {
            "condition": "When the question mentions \"Gabriel Tamas\"",
            "operation": " \"Gabriel Tamas\" actually means \"t1.player_name = 'Gabriel Tamas'\" in schema."
        },
        "176": {
            "condition": "When the question mentions \"year 2011\"",
            "operation": " \"year 2011\" actually means \"strftime('%Y', t2.date) = '2011'\" in schema."
        },
        "177": {
            "condition": "When answering about \"overall rating of football player Gabriel Tamas in year 2011\", When the question mentions \"Gabriel Tamas\", When the question mentions \"year 2011\", When combining Player as T1 and Player_Attributes as T2 for shared entities",
            "operation": " link rows where t1.player_api_id = t2.player_api_id; keep only matching pairs (inner match)."
        },
        "178": {
            "condition": "When answering about matches in a specific league",
            "operation": " use tables League as T1 and Match as T2 with an inner join on T1.id = T2.league_id."
        },
        "179": {
            "condition": "When the question mentions \"Scotland Premier League\"",
            "operation": " use exact literal 'Scotland Premier League' for T1.name filter."
        },
        "180": {
            "condition": "When the question mentions \"2015/2016 season\"",
            "operation": " use exact literal '2015/2016' for T2.season filter."
        },
        "181": {
            "condition": "When answering about matches in a specific league, When the question mentions \"Scotland Premier League\", When the question mentions \"2015/2016 season\", When counting matches",
            "operation": " count T2.id values instead of all rows to count specific non-null values."
        },
        "182": {
            "condition": "When answering about \"the youngest football player\"",
            "operation": " sort players by birthday in descending order (most recent first) and keep only the top 1 result."
        },
        "183": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match)."
        },
        "184": {
            "condition": "When the question asks for \"preferred foot when attacking\"",
            "operation": " select t2.preferred_foot from the joined Player_Attributes table instead of from the base Player table."
        },
        "185": {
            "condition": "When answering about \"the youngest football player\", When combining Player and Player_Attributes tables, When the question asks for \"preferred foot when attacking\", When determining the youngest player",
            "operation": " use t1.birthday for age calculation instead of an age column or MAX subquery."
        },
        "186": {
            "condition": "When answering about \"football player with the highest potential score\"",
            "operation": " make sure the output order: t1.player_name"
        },
        "187": {
            "condition": "When the question mentions \"football player\"",
            "operation": " \"football player\" actually means \"t1.player_name in schema\""
        },
        "188": {
            "condition": "When the question mentions \"highest potential score\"",
            "operation": " \"highest potential score\" actually means \"t2.potential in schema\""
        },
        "189": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where t1.player_api_id = t2.player_api_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "190": {
            "condition": "When the question asks for \"highest potential\"",
            "operation": " filter rows where t2.potential equals the maximum value from Player_Attributes table"
        },
        "191": {
            "condition": "When answering about \"football player with the highest potential score\", When the question mentions \"football player\", When the question mentions \"highest potential score\", When combining T1 and T2 for shared entities, When the question asks for \"highest potential\", When selecting output",
            "operation": " return only distinct t1.player_name values instead of all columns to avoid duplicate player names"
        },
        "192": {
            "condition": "When counting players",
            "operation": " use COUNT(DISTINCT t1.id) instead of COUNT(*) to count unique players."
        },
        "193": {
            "condition": "When the question involves both player attributes and player information",
            "operation": " join Player table as T1 with Player_Attributes table as T2 using INNER JOIN ON t1.player_api_id = t2.player_api_id."
        },
        "194": {
            "condition": "When filtering by preferred foot",
            "operation": " apply the condition t2.preferred_foot = 'left' to the Player_Attributes table (T2)."
        },
        "195": {
            "condition": "When filtering by weight",
            "operation": " apply the condition t1.weight < 130 to the Player table (T1)."
        },
        "196": {
            "condition": "When counting players, When the question involves both player attributes and player information, When filtering by preferred foot, When filtering by weight, When combining player data with attributes",
            "operation": " keep only matching pairs where t1.player_api_id = t2.player_api_id (inner match)."
        },
        "197": {
            "condition": "When answering about football teams with chance creation passing class",
            "operation": " join Team as T1 and Team_attributes as T2 where T1.team_api_id = T2.team_api_id to properly relate team attributes."
        },
        "198": {
            "condition": "When filtering for chance creation passing class of Risky",
            "operation": " use T2.chanceCreationPassingClass = 'Risky' with exact case and spacing."
        },
        "199": {
            "condition": "When selecting team short names",
            "operation": " use DISTINCT T1.team_short_name instead of team_name to get unique short names only."
        },
        "200": {
            "condition": "When answering about football teams with chance creation passing class, When filtering for chance creation passing class of Risky, When selecting team short names, When the question asks for \"short name only\"",
            "operation": " output only the team_short_name column without other columns."
        },
        "201": {
            "condition": "When joining Player and Player_Attributes tables",
            "operation": " use INNER JOIN on t1.player_api_id = t2.player_api_id to link matching rows between the tables."
        },
        "202": {
            "condition": "When filtering for a specific player by name",
            "operation": " use t1.player_name = 'David Wilson' instead of separate first_name and last_name conditions."
        },
        "203": {
            "condition": "When selecting defensive_work_rate",
            "operation": " retrieve it from table t2 (Player_Attributes) instead of directly from the players table."
        },
        "204": {
            "condition": "When joining Player and Player_Attributes tables, When filtering for a specific player by name, When selecting defensive_work_rate, When returning results",
            "operation": " use DISTINCT on the result set to eliminate duplicate defensive_work_rate values."
        },
        "205": {
            "condition": "When answering about football players with highest overall rating",
            "operation": " join Player table (T1) with Player_Attributes table (T2) using T1.player_api_id = T2.player_api_id to access the overall_rating attribute."
        },
        "206": {
            "condition": "When the question asks for the highest overall rating",
            "operation": " use T2.overall_rating from the joined Player_Attributes table instead of any column from the Player table."
        },
        "207": {
            "condition": "When retrieving birthday information",
            "operation": " use T1.birthday from the Player table as the source for birthday data."
        },
        "208": {
            "condition": "When answering about football players with highest overall rating, When the question asks for the highest overall rating, When retrieving birthday information, When finding the player with the highest overall rating",
            "operation": " order results by T2.overall_rating in descending direction and keep only the first row."
        },
        "209": {
            "condition": "When answering about football leagues in a specific country",
            "operation": " join Country table as T1 with League table as T2 using inner join on T1.id = T2.country_id."
        },
        "210": {
            "condition": "When the question mentions \"Netherlands\"",
            "operation": " use T1.name = 'Netherlands' as the filter condition."
        },
        "211": {
            "condition": "When selecting the league name",
            "operation": " output T2.name from the League table."
        },
        "212": {
            "condition": "When answering about football leagues in a specific country, When the question mentions \"Netherlands\", When selecting the league name, When combining Country and League tables",
            "operation": " keep only matching pairs where T1.id equals T2.country_id (inner match)."
        },
        "213": {
            "condition": "When calculating averages to avoid integer division",
            "operation": " use CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(t2.id) instead of AVG(home_team_goal)."
        },
        "214": {
            "condition": "When the question mentions a country name like 'Poland'",
            "operation": " join Country table as t1 with Match table as t2 using t1.id = t2.country_id and filter on t1.name = 'Poland'."
        },
        "215": {
            "condition": "When filtering by season '2010/2011'",
            "operation": " apply t2.season = '2010/2011' through the joined table alias."
        },
        "216": {
            "condition": "When calculating averages to avoid integer division, When the question mentions a country name like 'Poland', When filtering by season '2010/2011', When combining Country and Match tables",
            "operation": " perform an inner join where t1.id = t2.country_id to ensure proper country data linkage."
        },
        "217": {
            "condition": "When the question asks for average finishing rate",
            "operation": " use AVG(finishing) instead of AVG(finishing_rate)"
        },
        "218": {
            "condition": "When comparing highest and shortest football players",
            "operation": " calculate separate averages for maximum height players and minimum height players instead of grouping by player names"
        },
        "219": {
            "condition": "When structuring the query for two height groups",
            "operation": " use a UNION subquery that returns two rows labeled 'Max' and 'Min' instead of a single JOIN with OR conditions"
        },
        "220": {
            "condition": "When joining Player and Player_Attributes tables",
            "operation": " use player_api_id as the join key instead of player_id"
        },
        "221": {
            "condition": "When selecting output",
            "operation": " only select the label column A in the outer query instead of player names"
        },
        "222": {
            "condition": "When the question asks for average finishing rate, When comparing highest and shortest football players, When structuring the query for two height groups, When joining Player and Player_Attributes tables, When selecting output, When ordering results",
            "operation": " order by the calculated result column instead of the alias avg_finishing_rate"
        },
        "223": {
            "condition": "When the question asks for player names",
            "operation": " use the exact column token \"player_name\" from table \"Player\" instead of \"name\"."
        },
        "224": {
            "condition": "When filtering by height greater than 180",
            "operation": " apply the condition \"height > 180\" to the \"Player\" table."
        },
        "225": {
            "condition": "When the question asks for player names, When filtering by height greater than 180, When selecting from the player table",
            "operation": " use the exact table name \"Player\" instead of \"players\"."
        },
        "226": {
            "condition": "When counting players",
            "operation": " use the \"Player\" table and count the \"id\" column to get specific non-null identifiers."
        },
        "227": {
            "condition": "When extracting birth year from a date field",
            "operation": " use STRFTIME('%Y', birthday) to get the year component."
        },
        "228": {
            "condition": "When counting players, When extracting birth year from a date field, When filtering for players born after 1990",
            "operation": " compare the extracted birth year using > '1990' to capture years greater than 1990."
        },
        "229": {
            "condition": "When counting players",
            "operation": " use \"Player\" as the exact table name instead of \"players\" with proper case."
        },
        "230": {
            "condition": "When filtering by name starting with Adam",
            "operation": " use \"player_name LIKE 'Adam%'\" instead of \"first_name = 'Adam'\" to match names starting with Adam."
        },
        "231": {
            "condition": "When filtering by weight greater than 170",
            "operation": " use \"weight > 170\" instead of \"weight < 170\" to capture heavier players."
        },
        "232": {
            "condition": "When counting players, When filtering by name starting with Adam, When filtering by weight greater than 170, When counting players",
            "operation": " count \"id\" instead of \"*\" to exclude null values."
        },
        "233": {
            "condition": "When answering about players with overall rating over 80 from 2008 to 2010",
            "operation": " make sure the output order: DISTINCT t1.player_name."
        },
        "234": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match)."
        },
        "235": {
            "condition": "When filtering for overall rating over 80",
            "operation": " use t2.overall_rating > 80."
        },
        "236": {
            "condition": "When filtering for years 2008 to 2010",
            "operation": " extract year from t2.\"date\" using SUBSTR(t2.\"date\", 1,"
        },
        "237": {
            "condition": "When answering about players with overall rating over 80 from 2008 to 2010, When combining Player and Player_Attributes tables, When filtering for overall rating over 80, When filtering for years 2008 to 2010, BETWEEN '2008' AND '2010'.",
            "operation": "When answering about players with overall rating over 80 from 2008 to 2010, When combining Player and Player_Attributes tables, When filtering for overall rating over 80, When filtering for years 2008 to 2010, BETWEEN '2008' AND '2010'."
        },
        "238": {
            "condition": "When answering about a player's potential score",
            "operation": " select the \"potential\" column from the Player_Attributes table (aliased as t2)."
        },
        "239": {
            "condition": "When joining player information with player attributes",
            "operation": " use an inner join between the players table (t1) and Player_Attributes table (t2) where t1.player_api_id = t2.player_api_id."
        },
        "240": {
            "condition": "When filtering for a specific player by name",
            "operation": " use the combined player_name field with exact literal 'Aaron Doran' instead of separate first and last name fields."
        },
        "241": {
            "condition": "When answering about a player's potential score, When joining player information with player attributes, When filtering for a specific player by name, When the question asks for Aaron Doran's potential score",
            "operation": " ensure the output column is t2.potential from the joined Player_Attributes table."
        },
        "242": {
            "condition": "When answering about \"players whose preferred foot is left\"",
            "operation": " select specific columns \"t1.id\" and \"t1.player_name\" with distinct values instead of all columns."
        },
        "243": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where \"t1.player_api_id = t2.player_api_id\" using inner join instead of querying only the players table."
        },
        "244": {
            "condition": "When answering about \"players whose preferred foot is left\", When combining Player and Player_Attributes tables, When filtering on preferred foot",
            "operation": " use condition \"t2.preferred_foot = 'left'\" instead of 'right' to match the question requirement."
        },
        "245": {
            "condition": "When answering about team names with fast speed class",
            "operation": " make sure the output order: t1.team_long_name."
        },
        "246": {
            "condition": "When the question mentions \"team names\"",
            "operation": " \"team names\" actually means \"t1.team_long_name in schema\"."
        },
        "247": {
            "condition": "When the question mentions \"speed class is fast\"",
            "operation": " \"speed class\" actually means \"t2.buildUpPlaySpeedClass in schema\" and \"fast\" means the literal value 'Fast'."
        },
        "248": {
            "condition": "When combining teams table (T1) and Team_Attributes table (T2)",
            "operation": " link rows where t1.team_api_id = t2.team_api_id exactly as shown; keep only matching pairs (inner match)."
        },
        "249": {
            "condition": "When answering about team names with fast speed class, When the question mentions \"team names\", When the question mentions \"speed class is fast\", When combining teams table (T1) and Team_Attributes table (T2), When selecting team names",
            "operation": " use DISTINCT t1.team_long_name to ensure unique team names are returned."
        },
        "250": {
            "condition": "When the question asks about \"passing class of CLB team\"",
            "operation": " select DISTINCT t2.buildUpPlayPassingClass instead of passing_class to retrieve the specific attribute from the joined table."
        },
        "251": {
            "condition": "When combining Team and Team_Attributes tables",
            "operation": " use Team AS t1 INNER JOIN Team_Attributes AS t2 instead of querying only the teams table to properly join the attributes data."
        },
        "252": {
            "condition": "When joining Team and Team_Attributes tables",
            "operation": " link rows where t1.team_api_id = t2.team_api_id instead of missing the join condition entirely."
        },
        "253": {
            "condition": "When the question asks about \"passing class of CLB team\", When combining Team and Team_Attributes tables, When joining Team and Team_Attributes tables, When filtering for team identification",
            "operation": " use t1.team_short_name = 'CLB' instead of team_name = 'CLB' to use the correct column name for team identification."
        },
        "254": {
            "condition": "When answering about \"teams with build up play passing more than 70\"",
            "operation": " make sure the output order: t1.team_short_name."
        },
        "255": {
            "condition": "When the question mentions \"short names\"",
            "operation": " \"short names\" actually means \"t1.team_short_name in schema\"."
        },
        "256": {
            "condition": "When the question mentions \"build up play passing more than 70\"",
            "operation": " \"build up play passing\" actually means \"t2.buildUpPlayPassing > 70 in schema\"."
        },
        "257": {
            "condition": "When combining teams and Team_Attributes for shared entities",
            "operation": " link rows where t1.team_api_id = t2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "258": {
            "condition": "When answering about \"teams with build up play passing more than 70\", When the question mentions \"short names\", When the question mentions \"build up play passing more than 70\", When combining teams and Team_Attributes for shared entities, When eliminating duplicates",
            "operation": " use DISTINCT t1.team_short_name to ensure each team short name appears only once in results."
        },
        "259": {
            "condition": "When calculating averages of numeric columns",
            "operation": " use CAST(SUM(column) AS REAL) / COUNT(key_column) instead of AVG() to ensure proper numeric casting."
        },
        "260": {
            "condition": "When joining Player and Player_Attributes tables",
            "operation": " perform an INNER JOIN where Player AS t1.player_api_id equals Player_Attributes AS t2.player_api_id exactly."
        },
        "261": {
            "condition": "When filtering by height",
            "operation": " specify the table source as t1.height instead of just height to avoid ambiguity."
        },
        "262": {
            "condition": "When filtering by year ranges from date strings",
            "operation": " use STRFTIME('%Y', date_column) >= 'start_year' AND STRFTIME('%Y', date_column) <= 'end_year' instead of year BETWEEN for proper date extraction."
        },
        "263": {
            "condition": "When the question asks for average overall rating of players",
            "operation": " calculate the average using t2.overall_rating from Player_Attributes table."
        },
        "264": {
            "condition": "When filtering players by height",
            "operation": " use the condition t1.height > 170 with the exact numeric value."
        },
        "265": {
            "condition": "When calculating averages of numeric columns, When joining Player and Player_Attributes tables, When filtering by height, When filtering by year ranges from date strings, When the question asks for average overall rating of players, When filtering players by height, When filtering by years 2010 to 2015",
            "operation": " use the exact string literals '2010' and '2015' with STRFTIME year extraction from t2.date."
        },
        "266": {
            "condition": "When the question asks about football players",
            "operation": " use the \"player\" table instead of \"players\" as the data source."
        },
        "267": {
            "condition": "When selecting the player's name",
            "operation": " use the exact column token \"player_name\" instead of \"name\"."
        },
        "268": {
            "condition": "When finding the shortest height",
            "operation": " order by the height column in ascending (ASC) direction instead of descending (DESC)."
        },
        "269": {
            "condition": "When the question asks about football players, When selecting the player's name, When finding the shortest height, When the question asks for \"which football player\"",
            "operation": " return only the top 1 result after ordering by height in ascending order."
        },
        "270": {
            "condition": "When answering about \"which country is the league Italy Serie A from\"",
            "operation": " make sure the output order: t1.name"
        },
        "271": {
            "condition": "When the question mentions \"country\"",
            "operation": " \"country\" actually means \"t1.name in schema\" from the Country table"
        },
        "272": {
            "condition": "When the question mentions \"league Italy Serie A\"",
            "operation": " filter using t2.name = 'Italy Serie A' exactly as specified"
        },
        "273": {
            "condition": "When answering about \"which country is the league Italy Serie A from\", When the question mentions \"country\", When the question mentions \"league Italy Serie A\", When combining Country table as T1 and League table as T2",
            "operation": " link rows where t1.id = t2.country_id and keep only matching pairs (inner match)"
        },
        "274": {
            "condition": "When answering about football teams with specific build-up play attributes",
            "operation": " use Team table as T1 and Team_Attributes table as T2 with an inner join on T1.team_api_id = T2.team_api_id."
        },
        "275": {
            "condition": "When the question asks for \"short name of the team\"",
            "operation": " select T1.team_short_name with DISTINCT instead of team_name."
        },
        "276": {
            "condition": "When filtering for build up play speed of 31",
            "operation": " use T2.buildUpPlaySpeed = 31 with exact case and no underscores."
        },
        "277": {
            "condition": "When filtering for build up play dribbling of 53",
            "operation": " use T2.buildUpPlayDribbling = 53 with exact case and no underscores."
        },
        "278": {
            "condition": "When filtering for build up play passing of 32",
            "operation": " use T2.buildUpPlayPassing = 32 with exact case and no underscores."
        },
        "279": {
            "condition": "When answering about football teams with specific build-up play attributes, When the question asks for \"short name of the team\", When filtering for build up play speed of 31, When filtering for build up play dribbling of 53, When filtering for build up play passing of 32, When combining Team and Team_Attributes tables",
            "operation": " perform an inner match where T1.team_api_id equals T2.team_api_id and keep only matching pairs."
        },
        "280": {
            "condition": "When answering about average overall rating of a football player",
            "operation": " use SUM(t2.overall_rating) divided by COUNT(t2.id) with explicit casting to REAL instead of AVG() function."
        },
        "281": {
            "condition": "When the question mentions a player name like \"Aaron Doran\"",
            "operation": " use t1.player_name column with exact literal 'Aaron Doran' for filtering."
        },
        "282": {
            "condition": "When combining player data with attributes",
            "operation": " link Player AS t1 and Player_Attributes AS t2 using t1.player_api_id = t2.player_api_id with inner match."
        },
        "283": {
            "condition": "When answering about average overall rating of a football player, When the question mentions a player name like \"Aaron Doran\", When combining player data with attributes, When handling numeric calculations",
            "operation": " use CAST(... AS REAL) to ensure proper floating-point division accuracy."
        },
        "284": {
            "condition": "When answering about matches in a specific league",
            "operation": " join League AS t1 with Match AS t2 on t1.id = t2.league_id to properly relate league information to matches."
        },
        "285": {
            "condition": "When the question mentions \"Germany 1. Bundesliga\"",
            "operation": " filter on t1.name = 'Germany 1. Bundesliga' instead of directly filtering on a league column in the matches table."
        },
        "286": {
            "condition": "When filtering for dates from August to October 2008",
            "operation": " use SUBSTR(t2.date, 1,"
        },
        "287": {
            "condition": "to extract year-month for date range comparison instead of full date BETWEEN conditions.",
            "operation": "to extract year-month for date range comparison instead of full date BETWEEN conditions."
        },
        "288": {
            "condition": "When answering about matches in a specific league, When the question mentions \"Germany 1. Bundesliga\", When filtering for dates from August to October 2008, to extract year-month for date range comparison instead of full date BETWEEN conditions., When counting matches",
            "operation": " count t2.id specifically instead of using COUNT(*) for more precise counting of match entities."
        },
        "289": {
            "condition": "When the question asks for \"short name of the football team\"",
            "operation": " use \"t1.team_short_name\" from the Team table instead of \"short_name\" from football_teams."
        },
        "290": {
            "condition": "When combining Team and Match tables",
            "operation": " link rows where \"t1.team_api_id = t2.home_team_api_id\" and keep only matching pairs (inner match)."
        },
        "291": {
            "condition": "When the question asks for \"short name of the football team\", When combining Team and Match tables, When filtering for home team goal of 10",
            "operation": " use \"t2.home_team_goal = 10\" from the Match table instead of filtering on a non-existent column in the original table."
        },
        "292": {
            "condition": "When answering about \"football player with the highest balance score and potential score of 61\"",
            "operation": " make sure the output order: t1.player_name."
        },
        "293": {
            "condition": "When the question mentions \"football player\"",
            "operation": " use \"Player AS t1\" table and join with \"Player_Attributes AS t2\" on t1.player_api_id = t2.player_api_id using inner match."
        },
        "294": {
            "condition": "When the question mentions \"potential score of 61\"",
            "operation": " filter with t2.potential = '61' exactly (with string quotes)."
        },
        "295": {
            "condition": "When the question mentions \"highest balance score\"",
            "operation": " order rows by t2.balance in descending direction and keep only the first 1 row."
        },
        "296": {
            "condition": "When answering about \"football player with the highest balance score and potential score of 61\", When the question mentions \"football player\", When the question mentions \"potential score of 61\", When the question mentions \"highest balance score\", When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id exactly and keep only matching pairs (inner match)."
        },
        "297": {
            "condition": "When answering about the difference of average ball control scores between two specific players",
            "operation": " join the Player table (T1) and Player_Attributes table (T2) where T1.player_api_id equals T2.player_api_id to combine player names with their attributes."
        },
        "298": {
            "condition": "When calculating averages for specific players",
            "operation": " use conditional aggregation with SUM(CASE WHEN T1.player_name = 'Abdou Diallo' THEN CAST(T2.ball_control AS REAL) ELSE NULL END) / COUNT(CASE WHEN T1.player_name = 'Abdou Diallo' THEN 1 ELSE NULL END) for the first player and similarly for 'Aaron Appindangoye' for the second player."
        },
        "299": {
            "condition": "When handling division operations",
            "operation": " cast sums to REAL type to ensure proper decimal division instead of integer division."
        },
        "300": {
            "condition": "When counting records for averages",
            "operation": " use COUNT(CASE... ELSE NULL END) to only count relevant records and exclude null values from the denominator."
        },
        "301": {
            "condition": "When referencing player names",
            "operation": " use T1.player_name from the Player table with exact literals 'Abdou Diallo' and 'Aaron Appindangoye' including proper capitalization and spacing."
        },
        "302": {
            "condition": "When referencing ball control scores",
            "operation": " use T2.ball_control from the Player_Attributes table."
        },
        "303": {
            "condition": "When answering about the difference of average ball control scores between two specific players, When calculating averages for specific players, When handling division operations, When counting records for averages, When referencing player names, When referencing ball control scores, When combining tables for this question",
            "operation": " perform an inner join between Player and Player_Attributes using the exact equality condition T1.player_api_id = T2.player_api_id."
        },
        "304": {
            "condition": "When the question asks for \"long name\" of a team",
            "operation": " select \"team_long_name\" from table \"Team\"."
        },
        "305": {
            "condition": "When filtering by team abbreviation mentioned in the question",
            "operation": " use column \"team_short_name\" with exact literal value 'GEN' (case-sensitive)."
        },
        "306": {
            "condition": "When the question asks for \"long name\" of a team, When filtering by team abbreviation mentioned in the question, When referring to the teams table",
            "operation": " use exact table name \"Team\" (case-sensitive) instead of any other table name."
        },
        "307": {
            "condition": "When the question asks about player ages",
            "operation": " use the \"Player\" table instead of \"players\" table."
        },
        "308": {
            "condition": "When comparing specific players by age",
            "operation": " use \"WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada')\" with exact name literals instead of separate subqueries."
        },
        "309": {
            "condition": "When determining the older player",
            "operation": " sort by \"birthday ASC\" to get players in ascending order of birth date."
        },
        "310": {
            "condition": "When only the oldest player is needed",
            "operation": " use \"LIMIT 1\" to return only the first result after sorting."
        },
        "311": {
            "condition": "When the question asks about player ages, When comparing specific players by age, When determining the older player, When only the oldest player is needed, When outputting results",
            "operation": " return the actual \"player_name\" value instead of a descriptive CASE statement."
        },
        "312": {
            "condition": "When the question asks for a player's name",
            "operation": " use the exact column \"player_name\" from table \"Player\" instead of \"name\"."
        },
        "313": {
            "condition": "When the question asks for the tallest player",
            "operation": " order by \"height\" in descending direction (DESC) instead of ascending (ASC)."
        },
        "314": {
            "condition": "When the question asks for a player's name, When the question asks for the tallest player, When selecting from the player table",
            "operation": " use the exact table name \"Player\" instead of \"players\"."
        },
        "315": {
            "condition": "When counting players",
            "operation": " use \"player_api_id\" as the counting key instead of counting all columns."
        },
        "316": {
            "condition": "When accessing player attributes data",
            "operation": " query from the \"Player_Attributes\" table instead of the \"players\" table."
        },
        "317": {
            "condition": "When filtering for players who remain in position when attacking",
            "operation": " use \"attacking_work_rate = 'low'\" instead of position-based filters."
        },
        "318": {
            "condition": "When counting players, When accessing player attributes data, When filtering for players who remain in position when attacking, When filtering for left-footed players",
            "operation": " use \"preferred_foot = 'left'\" as specified in the question."
        },
        "319": {
            "condition": "When counting players",
            "operation": " count all rows matching the criteria instead of counting distinct player IDs."
        },
        "320": {
            "condition": "When filtering for players with left preferred foot",
            "operation": " use the exact literal 'left' for the preferred_foot column."
        },
        "321": {
            "condition": "When counting players, When filtering for players with left preferred foot, When filtering for players with low attacking work rate",
            "operation": " use the exact literal 'low' for the attacking_work_rate column."
        },
        "322": {
            "condition": "When answering about \"which country a league is from\"",
            "operation": " make sure the output order: t1.name"
        },
        "323": {
            "condition": "When the question mentions \"Belgium Jupiler League\"",
            "operation": " \"Belgium Jupiler League\" actually means t2.name = 'Belgium Jupiler League' in schema"
        },
        "324": {
            "condition": "When combining Country table as T1 and League table as T2 for shared entities",
            "operation": " link rows where t1.id = t2.country_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "325": {
            "condition": "When answering about \"which country a league is from\", When the question mentions \"Belgium Jupiler League\", When combining Country table as T1 and League table as T2 for shared entities, When selecting the country name",
            "operation": " use t1.name from the Country table instead of country from the leagues table"
        },
        "326": {
            "condition": "When answering about \"leagues from Germany\"",
            "operation": " make sure the output order: t2.name."
        },
        "327": {
            "condition": "When the question mentions \"Germany\"",
            "operation": " \"Germany\" actually means \"t1.name = 'Germany'\" in schema."
        },
        "328": {
            "condition": "When combining Country as T1 and League as T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (t1.id = t2.country_id); keep only matching pairs (inner match)."
        },
        "329": {
            "condition": "When answering about \"leagues from Germany\", When the question mentions \"Germany\", When combining Country as T1 and League as T2 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "330": {
            "condition": "When the question asks about \"player\"",
            "operation": " use \"t1.player_name\" from the \"Player\" table instead of \"name\" from \"players\"."
        },
        "331": {
            "condition": "When combining player information with attributes",
            "operation": " perform an inner join between \"Player\" as t1 and \"Player_Attributes\" as t2 using \"t1.player_api_id = t2.player_api_id\"."
        },
        "332": {
            "condition": "When determining \"strongest overall strength\"",
            "operation": " order by \"t2.overall_rating DESC\" instead of \"strength DESC\"."
        },
        "333": {
            "condition": "When the question asks about \"player\", When combining player information with attributes, When determining \"strongest overall strength\", When selecting the top result",
            "operation": " keep only the first row after ordering by the rating."
        },
        "334": {
            "condition": "When answering about players born before 1986",
            "operation": " extract year from t1.birthday using STRFTIME('%Y',t1.birthday) and compare to '1986' as string."
        },
        "335": {
            "condition": "When determining defensive players during attack",
            "operation": " use t2.defensive_work_rate = 'high' instead of position and team_status filters."
        },
        "336": {
            "condition": "When counting players",
            "operation": " count distinct t1.player_name values rather than all rows."
        },
        "337": {
            "condition": "When combining player information",
            "operation": " join Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id to link player attributes with player data."
        },
        "338": {
            "condition": "When answering about players born before 1986, When determining defensive players during attack, When counting players, When combining player information, When handling player identification",
            "operation": " use t1.player_api_id as the join key between Player and Player_Attributes tables."
        },
        "339": {
            "condition": "When the question asks about player performance in crossing actions",
            "operation": " join table Player as T1 with table Player_Attributes as T2 using the condition T1.player_api_id = T2.player_api_id to get complete player data."
        },
        "340": {
            "condition": "When filtering for specific players like 'Alexis', 'Ariel Borysiuk', or 'Arouna Kone'",
            "operation": " use T1.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') with exact name literals."
        },
        "341": {
            "condition": "When determining the best performer",
            "operation": " order results by T2.crossing in descending order and take only the top result (LIMIT 1)."
        },
        "342": {
            "condition": "When the question asks about player performance in crossing actions, When filtering for specific players like 'Alexis', 'Ariel Borysiuk', or 'Arouna Kone', When determining the best performer, When selecting output columns",
            "operation": " return T1.player_name and T2.crossing to show both the player name and their crossing performance metric."
        },
        "343": {
            "condition": "When answering about \"heading accuracy of Ariel Borysiuk\"",
            "operation": " make sure the output order: t2.heading_accuracy."
        },
        "344": {
            "condition": "When the question mentions \"Ariel Borysiuk\"",
            "operation": " \"Ariel Borysiuk\" actually means t1.player_name in schema."
        },
        "345": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (t1.player_api_id = t2.player_api_id); keep only matching pairs (inner match)."
        },
        "346": {
            "condition": "When answering about \"heading accuracy of Ariel Borysiuk\", When the question mentions \"Ariel Borysiuk\", When combining T1 and T2 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "347": {
            "condition": "When counting players",
            "operation": " count distinct player IDs using \"t1.id\" rather than counting all rows."
        },
        "348": {
            "condition": "When the question mentions \"players\"",
            "operation": " use table \"Player\" with alias \"t1\" as the base table."
        },
        "349": {
            "condition": "When the question mentions \"volley score\"",
            "operation": " this actually means column \"volleys\" from table \"Player_Attributes\" with alias \"t2\"."
        },
        "350": {
            "condition": "When combining player and attribute information",
            "operation": " link rows where \"t1.player_api_id = t2.player_api_id\" using an inner match to keep only players with attribute records."
        },
        "351": {
            "condition": "When filtering for height over 180",
            "operation": " use condition \"t1.height > 180\"."
        },
        "352": {
            "condition": "When counting players, When the question mentions \"players\", When the question mentions \"volley score\", When combining player and attribute information, When filtering for height over 180, When filtering for volley score over 70",
            "operation": " use condition \"t2.volleys > 70\"."
        },
        "353": {
            "condition": "When the question asks for player names",
            "operation": " use \"t1.player_name\" with DISTINCT instead of just \"name\" without distinct."
        },
        "354": {
            "condition": "When combining player information with attributes",
            "operation": " perform an INNER JOIN between \"players\" as T1 and \"Player_Attributes\" as T2 where \"t1.player_api_id = t2.player_api_id\"."
        },
        "355": {
            "condition": "When the question asks for player names, When combining player information with attributes, When filtering for players with volley and dribbling scores over 70",
            "operation": " use the condition \"t2.volleys > 70 AND t2.dribbling > 70\" instead of \"volley_score > 70 OR dribbling_score > 70\", ensuring both conditions must be met simultaneously."
        },
        "356": {
            "condition": "When counting matches",
            "operation": " use COUNT(t2.id) instead of COUNT(*) to count specific match records."
        },
        "357": {
            "condition": "When combining Country and Match tables",
            "operation": " link rows where t1.id = t2.country_id using an inner join to maintain relational integrity."
        },
        "358": {
            "condition": "When filtering by country name",
            "operation": " use t1.name = 'Belgium' instead of country = 'Belgium' to reference the proper country name column."
        },
        "359": {
            "condition": "When counting matches, When combining Country and Match tables, When filtering by country name, When filtering by season",
            "operation": " use t2.season = '2008/2009' instead of season = '2008/2009' to specify the table alias for clarity."
        },
        "360": {
            "condition": "When the question asks for \"long passing score\"",
            "operation": " select \"t2.long_passing\" from the Player_Attributes table instead of a direct column reference."
        },
        "361": {
            "condition": "When combining player information with player attributes",
            "operation": " join \"Player AS t1\" with \"Player_Attributes AS t2\" using the condition \"t1.player_api_id = t2.player_api_id\" to properly relate the tables."
        },
        "362": {
            "condition": "When the question asks for the \"oldest player\"",
            "operation": " order by \"t1.birthday ASC\" to sort by actual birth date instead of an ambiguous age column."
        },
        "363": {
            "condition": "When the question asks for \"long passing score\", When combining player information with player attributes, When the question asks for the \"oldest player\", When retrieving the oldest player's attribute",
            "operation": " take only the first row after ordering by birth date to get the oldest player."
        },
        "364": {
            "condition": "When answering about matches in a specific league",
            "operation": " join League AS t1 and Match AS t2 where t1.id = t2.league_id to link league information with match data."
        },
        "365": {
            "condition": "When filtering for 'Belgium Jupiler League'",
            "operation": " use t1.name = 'Belgium Jupiler League' to identify the correct league."
        },
        "366": {
            "condition": "When filtering for April 2009",
            "operation": " use SUBSTR(t2.date, 1,"
        },
        "367": {
            "condition": "= '2009-04' to extract year-month from the date column.",
            "operation": "= '2009-04' to extract year-month from the date column."
        },
        "368": {
            "condition": "When answering about matches in a specific league, When filtering for 'Belgium Jupiler League', When filtering for April 2009, = '2009-04' to extract year-month from the date column., When counting matches",
            "operation": " count t2.id as the canonical identifier for matches instead of counting all rows."
        },
        "369": {
            "condition": "When answering about \"league had the most matches\"",
            "operation": " make sure the output order: t1.name"
        },
        "370": {
            "condition": "When the question mentions \"league name\"",
            "operation": " \"league name\" actually means \"t1.name in schema\""
        },
        "371": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where t1.id = t2.league_id; keep only matching pairs (inner match)"
        },
        "372": {
            "condition": "When the question mentions \"2008/2009 season\"",
            "operation": " apply the filter t2.season = '2008/2009' exactly as written"
        },
        "373": {
            "condition": "When the question asks for \"most matches\" by count",
            "operation": " group results by t1.name and compute COUNT(t2.id) per group"
        },
        "374": {
            "condition": "When finding the maximum count",
            "operation": " use a subquery to calculate MAX(match_count) from the grouped results and compare COUNT(t2.id) to this maximum value"
        },
        "375": {
            "condition": "When answering about \"league had the most matches\", When the question mentions \"league name\", When combining T1 and T2 for shared entities, When the question mentions \"2008/2009 season\", When the question asks for \"most matches\" by count, When finding the maximum count, When counting matches",
            "operation": " use t2.id as the canonical counting key for matches"
        },
        "376": {
            "condition": "When answering about average overall rating of players born before 1986",
            "operation": " join Player as t1 with Player_Attributes as t2 where t1.player_api_id equals t2.player_api_id to combine player and rating data."
        },
        "377": {
            "condition": "When calculating average rating",
            "operation": " compute SUM(t2.overall_rating) divided by COUNT(t1.id) instead of using a single AVG function."
        },
        "378": {
            "condition": "When filtering players born before 1986",
            "operation": " extract the year from t1.birthday using SUBSTR(t1.birthday, 1,"
        },
        "379": {
            "condition": "and compare with '1986' using less than operator.",
            "operation": "and compare with '1986' using less than operator."
        },
        "380": {
            "condition": "When answering about average overall rating of players born before 1986, When calculating average rating, When filtering players born before 1986, and compare with '1986' using less than operator., When referencing columns",
            "operation": " use exact table aliases t2.overall_rating for ratings and t1.id for counting players."
        },
        "381": {
            "condition": "When answering about percentage difference between two specific players",
            "operation": " use SUM aggregates with CASE expressions to calculate ratings for each player instead of directly subtracting individual player ratings."
        },
        "382": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows using INNER JOIN where Player.player_api_id equals Player_Attributes.player_api_id and keep only matching pairs."
        },
        "383": {
            "condition": "When referencing player names",
            "operation": " use the exact column token \"player_name\" from the appropriate table instead of assuming both exist in a single table."
        },
        "384": {
            "condition": "When calculating percentage differences",
            "operation": " handle division by zero and data type conversion by multiplying by 1.0 instead of using direct integer division."
        },
        "385": {
            "condition": "When answering about percentage difference between two specific players, When combining Player and Player_Attributes tables, When referencing player names, When calculating percentage differences, When filtering for specific players Ariel Borysiuk and Paulin Puel",
            "operation": " use exact string literals 'Ariel Borysiuk' and 'Paulin Puel' with correct case and spacing."
        },
        "386": {
            "condition": "When answering about percentage difference between two players' ratings",
            "operation": " use a single Player table (alias t1) and a single Player_Attributes table (alias t2) joined together."
        },
        "387": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id using an INNER JOIN."
        },
        "388": {
            "condition": "When calculating percentage difference",
            "operation": " compute (Ariel Borysiuk's overall_rating - Paulin Puel's overall_rating) * 100.0 / Paulin Puel's overall_rating."
        },
        "389": {
            "condition": "When handling player-specific values",
            "operation": " use conditional expressions with t1.player_name = 'Ariel Borysiuk' and t1.player_name = 'Paulin Puel' to extract the respective overall_rating values from t2.overall_rating."
        },
        "390": {
            "condition": "When answering about percentage difference between two players' ratings, When combining Player and Player_Attributes tables, When calculating percentage difference, When handling player-specific values, When performing floating-point arithmetic",
            "operation": " use * 1.0 for explicit conversion to ensure proper division results."
        },
        "391": {
            "condition": "When calculating average build up play speed",
            "operation": " use CAST(SUM(t2.buildUpPlaySpeed) AS REAL) / COUNT(t2.id) instead of AVG(build_up_play_speed) to properly handle data type casting."
        },
        "392": {
            "condition": "When accessing team attributes data",
            "operation": " join Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id to combine team information with attributes."
        },
        "393": {
            "condition": "When calculating average build up play speed, When accessing team attributes data, When filtering for Heart of Midlothian team",
            "operation": " use t1.team_long_name = 'Heart of Midlothian' instead of team_name = 'Heart of Midlothian' to match the correct column name for team identification."
        },
        "394": {
            "condition": "When calculating an average rating",
            "operation": " use CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) instead of AVG(overall_rating) to handle proper data type conversion."
        },
        "395": {
            "condition": "When accessing player rating data",
            "operation": " join Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id to combine player information with ratings."
        },
        "396": {
            "condition": "When filtering for a player by name",
            "operation": " use t1.player_name = 'Pietro Marino' to match the combined name field exactly."
        },
        "397": {
            "condition": "When calculating an average rating, When accessing player rating data, When filtering for a player by name, When counting entities for average calculation",
            "operation": " use COUNT(t2.id) as the counting key for Player_Attributes table."
        },
        "398": {
            "condition": "When the question asks for a player's crossing score",
            "operation": " use the \"crossing\" column from the \"Player_Attributes\" table instead of any \"crossing_score\" column."
        },
        "399": {
            "condition": "When combining player information with player attributes",
            "operation": " link rows where \"Player\".\"player_api_id\" = \"Player_Attributes\".\"player_api_id\" using an inner match."
        },
        "400": {
            "condition": "When filtering for a specific player by name",
            "operation": " use the \"player_name\" column from the \"Player\" table with the exact literal value 'Aaron Lennox' instead of separate first and last name filters."
        },
        "401": {
            "condition": "When the question asks for a player's crossing score, When combining player information with player attributes, When filtering for a specific player by name, When aggregating crossing scores",
            "operation": " sum the \"crossing\" values from the \"Player_Attributes\" table for the matching player."
        },
        "402": {
            "condition": "When the question asks about a team's highest chance creation passing score",
            "operation": " select t2.chanceCreationPassing and t2.chanceCreationPassingClass instead of using MAX aggregation on a different column."
        },
        "403": {
            "condition": "When the question mentions a team name like 'Ajax'",
            "operation": " filter on t1.team_long_name = 'Ajax' exactly as written, not on player_name."
        },
        "404": {
            "condition": "When combining Team and Team_Attributes tables",
            "operation": " link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)."
        },
        "405": {
            "condition": "When the question asks about a team's highest chance creation passing score, When the question mentions a team name like 'Ajax', When combining Team and Team_Attributes tables, When finding the highest value",
            "operation": " order by t2.chanceCreationPassing in descending order and take only the first row (limit 1)."
        },
        "406": {
            "condition": "When answering about a player's preferred foot",
            "operation": " make sure the output order: preferred_foot."
        },
        "407": {
            "condition": "When the question mentions \"Abdou Diallo\"",
            "operation": " \"Abdou Diallo\" actually means \"t1.player_name = 'Abdou Diallo'\" in schema."
        },
        "408": {
            "condition": "When combining Player table (t1) and Player_Attributes table (t2)",
            "operation": " link rows where t1.player_api_id = t2.player_api_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "409": {
            "condition": "When retrieving preferred_foot information",
            "operation": " use t2.preferred_foot instead of t1.preferred_foot to specify the correct table source."
        },
        "410": {
            "condition": "When answering about a player's preferred foot, When the question mentions \"Abdou Diallo\", When combining Player table (t1) and Player_Attributes table (t2), When retrieving preferred_foot information, When eliminating duplicate results",
            "operation": " add DISTINCT modifier to ensure unique values are returned."
        },
        "411": {
            "condition": "When answering about \"highest overall rating received by Dorlan Pabon\"",
            "operation": " use MAX(t2.overall_rating) instead of MIN(rating) for the aggregate function and column reference."
        },
        "412": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id using an inner join instead of querying only one table."
        },
        "413": {
            "condition": "When answering about \"highest overall rating received by Dorlan Pabon\", When combining Player and Player_Attributes tables, When filtering for player name \"Dorlan Pabon\"",
            "operation": " reference t1.player_name in the WHERE clause instead of player_name alone."
        },
        "414": {
            "condition": "When answering about average goals made by Parma as away team in Italy",
            "operation": " use explicit table aliases T1 for Match, T2 for Team, and T3 for Country."
        },
        "415": {
            "condition": "When combining Match (T1) and Team (T2)",
            "operation": " link rows where T1.away_team_api_id = T2.team_api_id and keep only matching pairs (inner match)."
        },
        "416": {
            "condition": "When combining Match (T1) and Country (T3)",
            "operation": " link rows where T1.country_id = T3.id and keep only matching pairs (inner match)."
        },
        "417": {
            "condition": "When filtering for Parma team",
            "operation": " use T2.team_long_name = 'Parma' instead of direct team name filtering."
        },
        "418": {
            "condition": "When filtering for Italy country",
            "operation": " use T3.name = 'Italy' instead of direct country name filtering."
        },
        "419": {
            "condition": "When calculating average away team goals",
            "operation": " compute CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) instead of using AVG function."
        },
        "420": {
            "condition": "When answering about average goals made by Parma as away team in Italy, When combining Match (T1) and Team (T2), When combining Match (T1) and Country (T3), When filtering for Parma team, When filtering for Italy country, When calculating average away team goals, When referencing goals metric",
            "operation": " use T1.away_team_goal for away team goals instead of home_goals."
        },
        "421": {
            "condition": "When the question asks about players with a specific overall rating on a specific date",
            "operation": " use an inner join between Player AS t1 and Player_Attributes AS t2 where t1.player_api_id = t2.player_api_id."
        },
        "422": {
            "condition": "When filtering by date '2016/6/23'",
            "operation": " use SUBSTR(t2.date, 1,"
        },
        "423": {
            "condition": "= '2016-06-23' to match the exact date format.",
            "operation": "= '2016-06-23' to match the exact date format."
        },
        "424": {
            "condition": "When filtering by overall rating 77",
            "operation": " use t2.overall_rating = 77."
        },
        "425": {
            "condition": "When finding the oldest player",
            "operation": " order by t1.birthday ASC and take the first result."
        },
        "426": {
            "condition": "When the question asks about players with a specific overall rating on a specific date, When filtering by date '2016/6/23', = '2016-06-23' to match the exact date format., When filtering by overall rating 77, When finding the oldest player, When selecting the player name",
            "operation": " output t1.player_name instead of name."
        },
        "427": {
            "condition": "When answering about player ratings",
            "operation": " use table aliases T1 for Player table and T2 for Player_Attributes table instead of single table references."
        },
        "428": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where T1.player_api_id = T2.player_api_id and keep only matching pairs (inner match)."
        },
        "429": {
            "condition": "When filtering by player name \"Aaron Mooy\"",
            "operation": " use T1.player_name = 'Aaron Mooy' with exact case and spacing."
        },
        "430": {
            "condition": "When filtering by date \"2016/2/4\"",
            "operation": " convert to format '2016-02-04' and use SUBSTR(T2.date, 1,"
        },
        "431": {
            "condition": "= '2016-02-04' for date comparison.",
            "operation": "= '2016-02-04' for date comparison."
        },
        "432": {
            "condition": "When answering about player ratings, When combining Player and Player_Attributes tables, When filtering by player name \"Aaron Mooy\", When filtering by date \"2016/2/4\", = '2016-02-04' for date comparison., When selecting the overall rating",
            "operation": " output T2.overall_rating instead of just rating."
        },
        "433": {
            "condition": "When answering about player potential",
            "operation": " select \"t2.potential\" instead of unqualified \"potential\" to specify the correct table source."
        },
        "434": {
            "condition": "When the question mentions a player name",
            "operation": " \"Francesco Parravicini\" maps to \"t1.player_name\" in the schema, not \"name\"."
        },
        "435": {
            "condition": "When combining player data with attributes",
            "operation": " link rows where \"t1.player_api_id = t2.player_api_id\" using an inner match between Player AS t1 and Player_Attributes AS t2."
        },
        "436": {
            "condition": "When filtering by date \"2010/8/30\"",
            "operation": " convert to format \"2010-08-30\" and use SUBSTR(t2.date, 1,"
        },
        "437": {
            "condition": "When answering about player potential, When the question mentions a player name, When combining player data with attributes, When filtering by date \"2010/8/30\", = '2010-08-30' to handle date format differences and extract only the date portion.",
            "operation": "When answering about player potential, When the question mentions a player name, When combining player data with attributes, When filtering by date \"2010/8/30\", = '2010-08-30' to handle date format differences and extract only the date portion."
        },
        "438": {
            "condition": "When answering about a player's attacking work rate",
            "operation": " make sure the output order: t2.attacking_work_rate"
        },
        "439": {
            "condition": "When the question mentions \"Francesco Migliore\"",
            "operation": " \"Francesco Migliore\" actually means \"t1.player_name = 'Francesco Migliore'\" in schema"
        },
        "440": {
            "condition": "When the question mentions date \"2015/5/1\"",
            "operation": " \"2015/5/1\" actually means \"t2.date LIKE '2015-05-01%'\" to match date format patterns"
        },
        "441": {
            "condition": "When combining Player as t1 and Player_Attributes as t2 for shared entities",
            "operation": " link rows where t1.player_api_id = t2.player_api_id exactly as shown; keep only matching pairs (inner match)"
        },
        "442": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "443": {
            "condition": "When answering about a player's attacking work rate, When the question mentions \"Francesco Migliore\", When the question mentions date \"2015/5/1\", When combining Player as t1 and Player_Attributes as t2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'Francesco Migliore' or '2015-05-01%'"
        },
        "444": {
            "condition": "When answering about defensive work rate for a specific player on a specific date",
            "operation": " join Player table as T1 with Player_Attributes table as T2 using T1.player_fifa_api_id = T2.player_fifa_api_id to get the correct data."
        },
        "445": {
            "condition": "When the question mentions \"Kevin Berigaud\"",
            "operation": " use T1.player_name = 'Kevin Berigaud' to filter for the exact player name."
        },
        "446": {
            "condition": "When the question mentions date \"2013/2/22\"",
            "operation": " use SUBSTR(T2.date, 1,"
        },
        "447": {
            "condition": "= '2013-02-22' to handle the date format conversion and comparison.",
            "operation": "= '2013-02-22' to handle the date format conversion and comparison."
        },
        "448": {
            "condition": "When answering about defensive work rate for a specific player on a specific date, When the question mentions \"Kevin Berigaud\", When the question mentions date \"2013/2/22\", = '2013-02-22' to handle the date format conversion and comparison., When selecting defensive work rate",
            "operation": " reference T2.defensive_work_rate as the correct source column from the Player_Attributes table."
        },
        "449": {
            "condition": "When answering about \"Kevin Constant's highest crossing score date\"",
            "operation": " make sure the output order: date"
        },
        "450": {
            "condition": "When the question mentions \"Kevin Constant\"",
            "operation": " \"Kevin Constant\" actually means \"player_name = 'Kevin Constant' in Player table\""
        },
        "451": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where Player.player_fifa_api_id = Player_Attributes.player_fifa_api_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "452": {
            "condition": "When finding the highest crossing score",
            "operation": " rank rows by crossing in descending order and keep the first row"
        },
        "453": {
            "condition": "When ordering results by date",
            "operation": " use date DESC to get the most recent date instead of the earliest date"
        },
        "454": {
            "condition": "When selecting columns",
            "operation": " include both crossing and date in the inner query instead of only date"
        },
        "455": {
            "condition": "When answering about \"Kevin Constant's highest crossing score date\", When the question mentions \"Kevin Constant\", When combining Player and Player_Attributes tables, When finding the highest crossing score, When ordering results by date, When selecting columns, When counting or identifying players",
            "operation": " use player_fifa_api_id as the canonical key for joining tables instead of player_name"
        },
        "456": {
            "condition": "When answering about \"Kevin Constant's highest crossing score date\"",
            "operation": " make sure the output order: date"
        },
        "457": {
            "condition": "When the question mentions \"Kevin Constant\"",
            "operation": " \"Kevin Constant\" actually means \"player_name = 'Kevin Constant' in Player table\""
        },
        "458": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where Player.player_fifa_api_id = Player_Attributes.player_fifa_api_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "459": {
            "condition": "When finding the highest crossing score",
            "operation": " rank rows by crossing in descending order and keep the first row"
        },
        "460": {
            "condition": "When the question asks for the date of the highest crossing score",
            "operation": " select both crossing and date values to properly identify the maximum crossing occurrence"
        },
        "461": {
            "condition": "When answering about \"Kevin Constant's highest crossing score date\", When the question mentions \"Kevin Constant\", When combining Player and Player_Attributes tables, When finding the highest crossing score, When the question asks for the date of the highest crossing score, When ordering the final result",
            "operation": " sort by date in descending order to get the most recent occurrence of the maximum crossing value"
        },
        "462": {
            "condition": "When answering about \"first time Kevin Constant had his highest crossing score\"",
            "operation": " make sure the output order: date"
        },
        "463": {
            "condition": "When the question mentions \"Kevin Constant\"",
            "operation": " \"Kevin Constant\" actually means \"t2.player_name = 'Kevin Constant'\" in schema"
        },
        "464": {
            "condition": "When combining t1 and t2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (t1.player_fifa_api_id = t2.player_fifa_api_id); keep only matching pairs (inner match)"
        },
        "465": {
            "condition": "When finding the highest crossing score",
            "operation": " first select all records with maximum crossing value for Kevin Constant by ordering by t1.crossing DESC"
        },
        "466": {
            "condition": "When determining the first time",
            "operation": " among records with the highest crossing score, order by t1.date DESC and take the most recent record"
        },
        "467": {
            "condition": "When answering about \"first time Kevin Constant had his highest crossing score\", When the question mentions \"Kevin Constant\", When combining t1 and t2 for shared entities, When finding the highest crossing score, When determining the first time, When producing the final result",
            "operation": " return only the date column with LIMIT 1 to get the single most recent occurrence"
        },
        "468": {
            "condition": "When answering about \"build up play speed class\" for a team",
            "operation": " use the column \"buildUpPlaySpeedClass\" from table \"Team_Attributes\" (aliased as t2) instead of directly from \"team_attributes\"."
        },
        "469": {
            "condition": "When joining \"Team\" and \"Team_Attributes\" tables",
            "operation": " link rows where \"t1.team_api_id = t2.team_api_id\" and keep only matching pairs (inner match)."
        },
        "470": {
            "condition": "When filtering by team name",
            "operation": " use \"t1.team_long_name = 'Willem II'\" instead of \"team_name = 'Willem II'\"."
        },
        "471": {
            "condition": "When filtering by date",
            "operation": " use \"SUBSTR(t2.date, 1,"
        },
        "472": {
            "condition": "When answering about \"build up play speed class\" for a team, When joining \"Team\" and \"Team_Attributes\" tables, When filtering by team name, When filtering by date, = '2011-02-22'\" for date comparison instead of \"date = '2011/2/22'\" to properly handle date formatting.",
            "operation": "When answering about \"build up play speed class\" for a team, When joining \"Team\" and \"Team_Attributes\" tables, When filtering by team name, When filtering by date, = '2011-02-22'\" for date comparison instead of \"date = '2011/2/22'\" to properly handle date formatting."
        },
        "473": {
            "condition": "When answering about build up play dribbling class",
            "operation": " select only t2.buildUpPlayDribblingClass instead of all columns."
        },
        "474": {
            "condition": "When combining Team and Team_Attributes tables",
            "operation": " link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)."
        },
        "475": {
            "condition": "When filtering for team \"LEI\"",
            "operation": " use t1.team_short_name = 'LEI' as the filter condition."
        },
        "476": {
            "condition": "When filtering for date \"2015/9/10\"",
            "operation": " convert to proper date format using SUBSTR(t2.date, 1,"
        },
        "477": {
            "condition": "When answering about build up play dribbling class, When combining Team and Team_Attributes tables, When filtering for team \"LEI\", When filtering for date \"2015/9/10\", = '2015-09-10' with exact literal '2015-09-10'.",
            "operation": "When answering about build up play dribbling class, When combining Team and Team_Attributes tables, When filtering for team \"LEI\", When filtering for date \"2015/9/10\", = '2015-09-10' with exact literal '2015-09-10'."
        },
        "478": {
            "condition": "When answering about \"build Up play passing class for FC Lorient on 2010/2/22\"",
            "operation": " make sure the output order: t2.buildUpPlayPassingClass."
        },
        "479": {
            "condition": "When the question mentions \"FC Lorient\"",
            "operation": " \"FC Lorient\" actually means \"t1.team_long_name = 'FC Lorient'\" in schema."
        },
        "480": {
            "condition": "When the question mentions date \"2010/2/22\"",
            "operation": " use \"t2.date LIKE '2010-02-22%'\" to match the date format with wildcard pattern."
        },
        "481": {
            "condition": "When answering about \"build Up play passing class for FC Lorient on 2010/2/22\", When the question mentions \"FC Lorient\", When the question mentions date \"2010/2/22\", When combining Team as t1 and Team_Attributes as t2",
            "operation": " link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)."
        },
        "482": {
            "condition": "When answering about chance creation passing class for a specific team and date",
            "operation": " make sure the output order: t2.chanceCreationPassingClass"
        },
        "483": {
            "condition": "When the question mentions \"PEC Zwolle\"",
            "operation": " \"PEC Zwolle\" actually means t1.team_long_name = 'PEC Zwolle' in schema"
        },
        "484": {
            "condition": "When the question mentions date \"2013/9/20\"",
            "operation": " use SUBSTR(t2.date, 1,"
        },
        "485": {
            "condition": "= '2013-09-20' to properly handle date formatting",
            "operation": "= '2013-09-20' to properly handle date formatting"
        },
        "486": {
            "condition": "When answering about chance creation passing class for a specific team and date, When the question mentions \"PEC Zwolle\", When the question mentions date \"2013/9/20\", = '2013-09-20' to properly handle date formatting, When combining Team as T1 and Team_Attributes as T2",
            "operation": " link rows where t1.team_api_id = t2.team_api_id and keep only matching pairs (inner match)"
        },
        "487": {
            "condition": "When answering about chance creation crossing class for a team",
            "operation": " use the exact column token \"t2.chanceCreationCrossingClass\" from the Team_Attributes table."
        },
        "488": {
            "condition": "When the question mentions a team name like \"Hull City\"",
            "operation": " use the exact filter condition \"t1.team_long_name = 'Hull City'\" with the exact literal value 'Hull City'."
        },
        "489": {
            "condition": "When the question mentions a specific date like \"2010/2/22\"",
            "operation": " convert it to the format '2010-02-22' and use the exact filter condition \"SUBSTR(t2.date, 1,"
        },
        "490": {
            "condition": "= '2010-02-22'\".",
            "operation": "= '2010-02-22'\"."
        },
        "491": {
            "condition": "When combining Team and Team_Attributes tables",
            "operation": " link rows where \"t1.team_api_id = t2.team_api_id\" and keep only matching pairs (inner match)."
        },
        "492": {
            "condition": "When answering about chance creation crossing class for a team, When the question mentions a team name like \"Hull City\", When the question mentions a specific date like \"2010/2/22\", = '2010-02-22'\"., When combining Team and Team_Attributes tables, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for column names like \"chanceCreationCrossingClass\"."
        },
        "493": {
            "condition": "When the question asks about \"defence aggression class\"",
            "operation": " use the exact column token \"defenceAggressionClass\" from the Team_Attributes table instead of \"defence_aggression_class\"."
        },
        "494": {
            "condition": "When querying for team \"Hannover 96\"",
            "operation": " use the exact column token \"team_long_name\" from the Team table with literal value 'Hannover 96' instead of \"team_name\"."
        },
        "495": {
            "condition": "When filtering by date '2015/9/10'",
            "operation": " use pattern matching \"LIKE '2015-09-10%'\" on the Team_Attributes date column to handle timestamp formats instead of exact equality."
        },
        "496": {
            "condition": "When combining Team and Team_Attributes tables",
            "operation": " perform an inner join where \"t1.team_api_id = t2.team_api_id\" to link team information with their attributes."
        },
        "497": {
            "condition": "When the question asks about \"defence aggression class\", When querying for team \"Hannover 96\", When filtering by date '2015/9/10', When combining Team and Team_Attributes tables, When selecting the output column",
            "operation": " use \"t2.defenceAggressionClass\" as the result column from the joined Team_Attributes table."
        },
        "498": {
            "condition": "When the question asks about \"defence aggression class\" for a team on a specific date",
            "operation": " the correct attribute to select is \"chanceCreationShootingClass\" from the Team_Attributes table."
        },
        "499": {
            "condition": "When filtering for team name \"Hannover 96\"",
            "operation": " use exact literal 'Hannover 96' with table alias t1 and column team_long_name."
        },
        "500": {
            "condition": "When filtering for date \"2015/9/10\"",
            "operation": " use pattern matching with '2015-09-10%' on the date column of Team_Attributes table (alias t2)."
        },
        "501": {
            "condition": "When the question asks about \"defence aggression class\" for a team on a specific date, When filtering for team name \"Hannover 96\", When filtering for date \"2015/9/10\", When joining Team and Team_Attributes tables",
            "operation": " use inner join on the exact key equality t1.team_api_id = t2.team_api_id."
        },
        "502": {
            "condition": "When answering about average overall rating for a specific player",
            "operation": " join Player table as T1 with Player_Attributes table as T2 on T1.player_fifa_api_id = T2.player_fifa_api_id to combine player information with attributes."
        },
        "503": {
            "condition": "When calculating average overall rating",
            "operation": " use CAST(SUM(T2.overall_rating) AS REAL) / COUNT(T2.id) instead of AVG(overall_rating) to ensure proper division handling."
        },
        "504": {
            "condition": "When filtering by player name",
            "operation": " use T1.player_name = 'Marko Arnautovic' to reference the correct table."
        },
        "505": {
            "condition": "When filtering by date range",
            "operation": " use SUBSTR(T2.date, 1,"
        },
        "506": {
            "condition": "When answering about average overall rating for a specific player, When calculating average overall rating, When filtering by player name, When filtering by date range, for date extraction with ISO format dates '2007-02-22' and '2016-04-21' instead of direct date field comparison with slash-separated dates.",
            "operation": "When answering about average overall rating for a specific player, When calculating average overall rating, When filtering by player name, When filtering by date range, for date extraction with ISO format dates '2007-02-22' and '2016-04-21' instead of direct date field comparison with slash-separated dates."
        },
        "507": {
            "condition": "When answering about percentage difference between two players' ratings",
            "operation": " use conditional aggregation with SUM(CASE WHEN) instead of direct column subtraction to handle multiple records."
        },
        "508": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where T1.player_fifa_api_id = T2.player_fifa_api_id and keep only matching pairs (inner match)."
        },
        "509": {
            "condition": "When filtering by date '2013-07-12'",
            "operation": " use SUBSTR(T2.date, 1,"
        },
        "510": {
            "condition": "= '2013-07-12' for date matching instead of direct date comparison.",
            "operation": "= '2013-07-12' for date matching instead of direct date comparison."
        },
        "511": {
            "condition": "When calculating percentage difference",
            "operation": " use formula (sum1 - sum2) * 100 / sum1 where sum1 is Landon Donovan's rating and sum2 is Jordan Bowery's rating."
        },
        "512": {
            "condition": "When referencing player names",
            "operation": " use exact column name \"player_name\" with literals 'Landon Donovan' and 'Jordan Bowery' exactly as specified."
        },
        "513": {
            "condition": "When answering about percentage difference between two players' ratings, When combining Player and Player_Attributes tables, When filtering by date '2013-07-12', = '2013-07-12' for date matching instead of direct date comparison., When calculating percentage difference, When referencing player names, When referencing ratings",
            "operation": " use exact column name \"overall_rating\" from the Player_Attributes table."
        },
        "514": {
            "condition": "When the question asks for \"most tallest players' name\"",
            "operation": " use \"player_name\" from table \"Player\" instead of \"name\" from table \"Country\"."
        },
        "515": {
            "condition": "When ranking players by height to find tallest",
            "operation": " use \"height\" column from table \"Player\" and order in descending direction."
        },
        "516": {
            "condition": "When handling ties for tallest players",
            "operation": " use dense ranking to assign the same rank to players with equal height values."
        },
        "517": {
            "condition": "When the question asks for \"most tallest players' name\", When ranking players by height to find tallest, When handling ties for tallest players, When selecting the tallest players",
            "operation": " filter to include all players with rank = 1 to handle multiple players with maximum height."
        },
        "518": {
            "condition": "When the question asks for player names",
            "operation": " use the exact column token \"player_name\" from table \"Player\" instead of \"name\"."
        },
        "519": {
            "condition": "When calculating age from birthday",
            "operation": " compute age dynamically using (current date minus birthday date) divided by 365 days, not using a static age column."
        },
        "520": {
            "condition": "When filtering for players 35 years old and above",
            "operation": " use >= 35 condition, not < 35 condition."
        },
        "521": {
            "condition": "When the question asks for player names, When calculating age from birthday, When filtering for players 35 years old and above, When the question mentions \"35 years old and above\"",
            "operation": " this means age must be greater than or equal to 35, inclusive of 35-year-olds."
        },
        "522": {
            "condition": "When answering about \"home team goals scored by Aaron Lennon\"",
            "operation": " use SUM(t2.home_team_goal) instead of COUNT(*) to sum actual goal values."
        },
        "523": {
            "condition": "When combining Player and match tables",
            "operation": " link rows where t1.player_api_id = t2.away_player_9 using INNER JOIN and keep only matching pairs."
        },
        "524": {
            "condition": "When filtering for a specific player",
            "operation": " use t1.player_name = 'Aaron Lennon' exactly as specified."
        },
        "525": {
            "condition": "When answering about \"home team goals scored by Aaron Lennon\", When combining Player and match tables, When filtering for a specific player, When the question asks about home team goals",
            "operation": " do not include team_type = 'away' condition as the join logic handles the player-team relationship."
        },
        "526": {
            "condition": "When answering about \"sum up the away team goal scored by both Daan Smith and Filipe Ferreira\"",
            "operation": " make sure the output order: SUM(t2.away_team_goal)."
        },
        "527": {
            "condition": "When the question mentions \"Daan Smith\" and \"Filipe Ferreira\"",
            "operation": " these names actually mean \"t1.player_name IN ('Daan Smith', 'Filipe Ferreira')\" in schema."
        },
        "528": {
            "condition": "When combining Player as T1 and match as T2 for shared entities",
            "operation": " link rows where t1.player_api_id = t2.away_player_5 exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "529": {
            "condition": "When the question asks for \"away team goal\"",
            "operation": " this actually means \"t2.away_team_goal\" in the schema, not \"goals\" from an unspecified source."
        },
        "530": {
            "condition": "When answering about \"sum up the away team goal scored by both Daan Smith and Filipe Ferreira\", When the question mentions \"Daan Smith\" and \"Filipe Ferreira\", When combining Player as T1 and match as T2 for shared entities, When the question asks for \"away team goal\", When the question mentions \"team_type = 'away'\"",
            "operation": " do not include this condition as it doesn't exist in the schema."
        },
        "531": {
            "condition": "When calculating total home team goals",
            "operation": " use SUM(t2.home_team_goal) instead of SUM(goals) and source data from Player AS t1 INNER JOIN match AS t2 instead of a single players table."
        },
        "532": {
            "condition": "When joining Player and match tables",
            "operation": " link rows where t1.player_api_id = t2.away_player_1 exactly as shown and keep only matching pairs (inner match)."
        },
        "533": {
            "condition": "When filtering by age 30 years old and below",
            "operation": " calculate age dynamically using datetime(CURRENT_TIMESTAMP, 'localtime') - datetime(T1.birthday) < 31 instead of using a static age column."
        },
        "534": {
            "condition": "When calculating total home team goals, When joining Player and match tables, When filtering by age 30 years old and below, When the question mentions \"home team goal\"",
            "operation": " remove any filter for team_type = 'home' as this is not needed for the aggregation."
        },
        "535": {
            "condition": "When the question asks for \"most strongest player\"",
            "operation": " use the exact column token \"t2.overall_rating\" to determine player strength instead of \"strength\"."
        },
        "536": {
            "condition": "When combining player data with attributes",
            "operation": " link rows where \"t1.player_api_id = t2.player_api_id\" exactly as shown and keep only matching pairs (inner match)."
        },
        "537": {
            "condition": "When finding the maximum rating",
            "operation": " use the exact condition \"t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\" instead of ordering and limiting."
        },
        "538": {
            "condition": "When selecting player names",
            "operation": " use the exact column token \"t1.player_name\" with DISTINCT instead of \"name\" without distinct."
        },
        "539": {
            "condition": "When the question asks for \"most strongest player\", When combining player data with attributes, When finding the maximum rating, When selecting player names, When answering about \"most strongest player\"",
            "operation": " make sure the output order includes only \"t1.player_name\"."
        },
        "540": {
            "condition": "When selecting player names",
            "operation": " use \"t1.player_name\" with DISTINCT instead of just \"name\" without distinct."
        },
        "541": {
            "condition": "When accessing player potential data",
            "operation": " join \"Player AS t1\" with \"Player_Attributes AS t2\" using \"t1.player_api_id = t2.player_api_id\" instead of using a single table."
        },
        "542": {
            "condition": "When ordering by potential",
            "operation": " use \"t2.potential DESC\" instead of just \"potential DESC\" since potential is in the Player_Attributes table."
        },
        "543": {
            "condition": "When selecting player names, When accessing player potential data, When ordering by potential, When finding players with highest potential",
            "operation": " order by potential in descending order and take the top result."
        },
        "544": {
            "condition": "When the question asks for the highest potential",
            "operation": " rank players by potential in descending order and keep only the top 1 row."
        },
        "545": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where Player.player_api_id equals Player_Attributes.player_api_id and keep only matching pairs (inner match)."
        },
        "546": {
            "condition": "When the question asks for the highest potential, When combining Player and Player_Attributes tables, When answering about players with highest potential",
            "operation": " make sure the output order includes only player_name."
        },
        "547": {
            "condition": "When answering about players who tend to be attacking",
            "operation": " use DISTINCT t1.player_name to eliminate duplicate player names."
        },
        "548": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match)."
        },
        "549": {
            "condition": "When the question mentions \"attacking when their mates were doing attack moves\"",
            "operation": " this actually means filtering for t2.attacking_work_rate = 'high' in the Player_Attributes table."
        },
        "550": {
            "condition": "When answering about players who tend to be attacking, When combining Player and Player_Attributes tables, When the question mentions \"attacking when their mates were doing attack moves\", When the question asks for a list of player names",
            "operation": " do not include any ORDER BY clause in the final output."
        },
        "551": {
            "condition": "When the question asks for \"player's name\"",
            "operation": " use the exact column token \"t1.player_name\" instead of \"name\"."
        },
        "552": {
            "condition": "When selecting player names",
            "operation": " ensure distinct values are returned to avoid duplicates."
        },
        "553": {
            "condition": "When filtering for players with finishing rate of 1",
            "operation": " use the exact condition \"t2.finishing = 1\" with the literal value 1."
        },
        "554": {
            "condition": "When determining the eldest player",
            "operation": " order by \"t1.birthday ASC\" (ascending order of birth dates) instead of age."
        },
        "555": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " perform an inner join using the exact condition \"t1.player_api_id = t2.player_api_id\" to link related records."
        },
        "556": {
            "condition": "When the question asks for \"player's name\", When selecting player names, When filtering for players with finishing rate of 1, When determining the eldest player, When combining Player and Player_Attributes tables, When answering about the eldest player among those with finishing rate of 1",
            "operation": " return only the first result after ordering by birthday in ascending order."
        },
        "557": {
            "condition": "When answering about \"players who came from Belgium\"",
            "operation": " make sure the output order: t3.player_name."
        },
        "558": {
            "condition": "When the question mentions \"Belgium\"",
            "operation": " \"Belgium\" actually means \"t1.name = 'Belgium'\" in schema."
        },
        "559": {
            "condition": "When combining Country as t1 and Match as t2",
            "operation": " link rows where t1.id = t2.country_id and keep only matching pairs (inner match)."
        },
        "560": {
            "condition": "When combining Match as t2 and Player as t3",
            "operation": " link rows where t2.home_player_1 = t3.player_api_id and keep only matching pairs (inner match)."
        },
        "561": {
            "condition": "When answering about \"players who came from Belgium\", When the question mentions \"Belgium\", When combining Country as t1 and Match as t2, When combining Match as t2 and Player as t3, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "562": {
            "condition": "When answering about \"players who came from Belgium\"",
            "operation": " make sure the output order: t3.player_name"
        },
        "563": {
            "condition": "When the question mentions \"Belgium\"",
            "operation": " \"Belgium\" actually means t1.name = 'Belgium' in schema"
        },
        "564": {
            "condition": "When combining Country as T1 and Match as T2",
            "operation": " link rows where T1.id = T2.country_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "565": {
            "condition": "When combining Match as T2 and Player as T3",
            "operation": " link rows where T2.home_player_1 = T3.player_api_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "566": {
            "condition": "When answering about \"players who came from Belgium\", When the question mentions \"Belgium\", When combining Country as T1 and Match as T2, When combining Match as T2 and Player as T3, When selecting players from Belgium matches",
            "operation": " only include home players (T2.home_player_1) instead of both home and away players through union duplication"
        },
        "567": {
            "condition": "When the question asks for \"country of these players\"",
            "operation": " use \"DISTINCT t4.name\" instead of \"country\" in the output."
        },
        "568": {
            "condition": "When combining player data with country information",
            "operation": " link tables using INNER JOIN relationships with \"t1.player_api_id = t2.player_api_id\", \"t2.player_api_id = t3.home_player_8\", and \"t3.country_id = t4.id\"."
        },
        "569": {
            "condition": "When filtering for players with vision scores of 90 and above",
            "operation": " use \"t1.vision > 89\" instead of \"vision_score > 90\" in the filter condition."
        },
        "570": {
            "condition": "When the question asks for \"country of these players\", When combining player data with country information, When filtering for players with vision scores of 90 and above, When answering about players with high vision scores",
            "operation": " make sure to join Player_Attributes as t1, Player as t2, Match as t3, and Country as t4 instead of querying only a single players table."
        },
        "571": {
            "condition": "When answering about \"country's players have the heaviest average weights\"",
            "operation": " make sure the output order: t1.name, AVG(t3.weight)"
        },
        "572": {
            "condition": "When the question mentions \"country\"",
            "operation": " \"country\" actually means \"t1.name in schema\""
        },
        "573": {
            "condition": "When the question mentions \"heaviest average weights\"",
            "operation": " rank rows by AVG(t3.weight) in descending direction and keep the first 1 row"
        },
        "574": {
            "condition": "When combining Country as t1 and Match as t2 for shared entities",
            "operation": " link rows where t1.id = t2.country_id exactly as shown; keep only matching pairs (inner match)"
        },
        "575": {
            "condition": "When combining Match as t2 and Player as t3 for shared entities",
            "operation": " link rows where t2.home_player_1 = t3.player_api_id exactly as shown; keep only matching pairs (inner match)"
        },
        "576": {
            "condition": "When the question asks for \"average weights per country\"",
            "operation": " organize results by t1.name and compute AVG(t3.weight) per group"
        },
        "577": {
            "condition": "When answering about \"country's players have the heaviest average weights\", When the question mentions \"country\", When the question mentions \"heaviest average weights\", When combining Country as t1 and Match as t2 for shared entities, When combining Match as t2 and Player as t3 for shared entities, When the question asks for \"average weights per country\", When producing output",
            "operation": " do not include explicit aliases like avg_weight in the final result columns"
        },
        "578": {
            "condition": "When answering about \"long name for slow speed class team\"",
            "operation": " make sure the output order: t1.team_long_name"
        },
        "579": {
            "condition": "When the question mentions \"slow speed class\"",
            "operation": " \"slow speed class\" actually means \"t2.buildUpPlaySpeedClass = 'Slow'\" in schema"
        },
        "580": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (t1.team_api_id = t2.team_api_id); keep only matching pairs (inner match)"
        },
        "581": {
            "condition": "When the question asks for \"long name\"",
            "operation": " use t1.team_long_name instead of team_name"
        },
        "582": {
            "condition": "When answering about \"long name for slow speed class team\", When the question mentions \"slow speed class\", When combining T1 and T2 for shared entities, When the question asks for \"long name\", When the question asks for distinct values",
            "operation": " use DISTINCT t1.team_long_name to avoid duplicate entries"
        },
        "583": {
            "condition": "When answering about \"short name of team who played safe while creating chance of passing\"",
            "operation": " make sure the output order: t1.team_short_name"
        },
        "584": {
            "condition": "When the question mentions \"short name\"",
            "operation": " \"short name\" actually means \"t1.team_short_name\" in schema"
        },
        "585": {
            "condition": "When the question mentions \"safe while creating chance of passing\"",
            "operation": " \"safe while creating chance of passing\" actually means \"t2.chanceCreationPassingClass = 'Safe'\" in schema"
        },
        "586": {
            "condition": "When combining teams and Team_Attributes for shared entities",
            "operation": " link rows where t1.team_api_id = t2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "587": {
            "condition": "When answering about \"short name of team who played safe while creating chance of passing\", When the question mentions \"short name\", When the question mentions \"safe while creating chance of passing\", When combining teams and Team_Attributes for shared entities, When selecting team short names",
            "operation": " use DISTINCT to return only unique values of t1.team_short_name"
        },
        "588": {
            "condition": "When calculating average height of players",
            "operation": " use CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) instead of AVG(height) for proper floating-point division."
        },
        "589": {
            "condition": "When filtering for Italy players",
            "operation": " join Match table as T2 using T1.id = T2.id and join Country table as T3 using T2.country_id = T3.ID, then filter with T3.NAME = 'Italy' instead of country = 'Italy'."
        },
        "590": {
            "condition": "When calculating average height of players, When filtering for Italy players, When counting players",
            "operation": " use COUNT(T1.id) instead of implicit averaging to handle potential NULL values correctly."
        },
        "591": {
            "condition": "When joining Player and Match tables",
            "operation": " use T1.id = T2.id for the join condition instead of checking T1.player_api_id against multiple player columns."
        },
        "592": {
            "condition": "When computing average height",
            "operation": " do not include an alias for the result column."
        },
        "593": {
            "condition": "When joining Player and Match tables, When computing average height, When filtering for Italy players",
            "operation": " use T3.name = 'Italy' with exact case and spelling."
        },
        "594": {
            "condition": "When the question asks for \"football players\"",
            "operation": " use the table \"Player\" instead of \"football_players\"."
        },
        "595": {
            "condition": "When the question asks for \"names\"",
            "operation": " use the column \"player_name\" instead of \"name\"."
        },
        "596": {
            "condition": "When ordering alphabetically",
            "operation": " use ascending order without specifying direction explicitly as it is the default."
        },
        "597": {
            "condition": "When filtering for players over 180 cm tall",
            "operation": " use the condition height > 180."
        },
        "598": {
            "condition": "When the question asks for \"football players\", When the question asks for \"names\", When ordering alphabetically, When filtering for players over 180 cm tall, When asking for top three results",
            "operation": " limit the output to 3 rows."
        },
        "599": {
            "condition": "When counting entities from the Player table",
            "operation": " count the \"id\" column instead of using * to avoid counting null values."
        },
        "600": {
            "condition": "When referring to the players table",
            "operation": " use the exact table alias \"Player\" as shown in the schema."
        },
        "601": {
            "condition": "When filtering by birth date",
            "operation": " use \"birthday > '1990'\" for date comparison instead of numeric year comparison."
        },
        "602": {
            "condition": "When counting entities from the Player table, When referring to the players table, When filtering by birth date, When matching names starting with \"Aaron\"",
            "operation": " use \"player_name LIKE 'Aaron%'\" to find names beginning with Aaron rather than exact first name matches."
        },
        "603": {
            "condition": "When calculating the difference between two specific players' scores",
            "operation": " use SUM(CASE WHEN t1.id=6 THEN t1.jumping ELSE 0 END) - SUM(CASE WHEN t1.id=23 THEN t1.jumping ELSE 0 END) instead of ABS(p1.jumping_score - p2.jumping_score)."
        },
        "604": {
            "condition": "When referencing the player attributes table",
            "operation": " use Player_Attributes AS t1 instead of players p1, players p2 with a cross join."
        },
        "605": {
            "condition": "When filtering for specific player IDs",
            "operation": " handle the logic within CASE expressions instead of using explicit WHERE filter conditions."
        },
        "606": {
            "condition": "When working with player jumping scores",
            "operation": " use t1.jumping as the column name for jumping scores."
        },
        "607": {
            "condition": "When calculating the difference between two specific players' scores, When referencing the player attributes table, When filtering for specific player IDs, When working with player jumping scores, When identifying players",
            "operation": " use t1.id as the player identifier column."
        },
        "608": {
            "condition": "When answering about \"top five football players' IDs who are among the lowest potential players and prefer to use the right foot\"",
            "operation": " make sure the output order: id from Player_Attributes table."
        },
        "609": {
            "condition": "When the question mentions \"player's IDs\"",
            "operation": " \"player's IDs\" actually means \"id in Player_Attributes table\"."
        },
        "610": {
            "condition": "When the question mentions \"top five\" by potential",
            "operation": " rank rows by potential in descending order and keep the first 5 rows."
        },
        "611": {
            "condition": "When the question mentions \"prefer to use the right foot\"",
            "operation": " \"right foot\" actually means \"preferred_foot = 'right'\" in Player_Attributes table."
        },
        "612": {
            "condition": "When answering about \"top five football players' IDs who are among the lowest potential players and prefer to use the right foot\", When the question mentions \"player's IDs\", When the question mentions \"top five\" by potential, When the question mentions \"prefer to use the right foot\", When selecting from Player_Attributes table",
            "operation": " use double quotes around \"Player_Attributes\" as shown in the schema."
        },
        "613": {
            "condition": "When the question asks for \"top five football players' IDs who are among the lowest potential players\"",
            "operation": " order by \"potential\" in ascending order to get the lowest potential values first, then take the first 5 rows."
        },
        "614": {
            "condition": "When the question mentions players who \"prefer to use the right foot when attacking\"",
            "operation": " filter rows where \"preferred_foot\" equals exactly 'right' (case-sensitive)."
        },
        "615": {
            "condition": "When the question asks for \"top five football players' IDs who are among the lowest potential players\", When the question mentions players who \"prefer to use the right foot when attacking\", When answering about football players' IDs",
            "operation": " select the \"id\" column from the Player_Attributes table."
        },
        "616": {
            "condition": "When answering about \"players with highest potential score for crossing\"",
            "operation": " use the \"Player_Attributes\" table instead of \"players\" table."
        },
        "617": {
            "condition": "When counting players",
            "operation": " use COUNT(t1.id) instead of COUNT(*) to count using the canonical key."
        },
        "618": {
            "condition": "When checking preferred foot",
            "operation": " use lowercase 'left' instead of 'Left' for the preferred_foot condition."
        },
        "619": {
            "condition": "When filtering for maximum crossing ability",
            "operation": " remove the unnecessary condition checking for maximum potential and only check for maximum crossing from the Player_Attributes table."
        },
        "620": {
            "condition": "When the question mentions \"preferred to use their left foots\"",
            "operation": " this means preferred_foot = 'left' exactly."
        },
        "621": {
            "condition": "When the question asks about \"highest potential score for crossing\"",
            "operation": " this means crossing = (SELECT MAX(crossing) FROM Player_Attributes)."
        },
        "622": {
            "condition": "When answering about \"players with highest potential score for crossing\", When counting players, When checking preferred foot, When filtering for maximum crossing ability, When the question mentions \"preferred to use their left foots\", When the question asks about \"highest potential score for crossing\", When the question does not mention attacking work rate",
            "operation": " remove the attacking_work_rate filter entirely."
        },
        "623": {
            "condition": "When counting players with both strength and stamina above 80",
            "operation": " use COUNT(CASE WHEN strength > 80 AND stamina > 80 THEN id ELSE NULL END) instead of COUNT(*) to count only players meeting both conditions."
        },
        "624": {
            "condition": "When requiring both high strength and stamina",
            "operation": " use the logical operator AND instead of OR to ensure both conditions are satisfied."
        },
        "625": {
            "condition": "When performing floating-point division",
            "operation": " use explicit CAST to REAL instead of decimal literal 100.0 for proper division."
        },
        "626": {
            "condition": "When referencing the player attributes table",
            "operation": " use the correct table name Player_Attributes instead of players."
        },
        "627": {
            "condition": "When calculating the total count of players",
            "operation": " use COUNT(id) in the denominator instead of a subquery for the total count."
        },
        "628": {
            "condition": "When counting players with both strength and stamina above 80, When requiring both high strength and stamina, When performing floating-point division, When referencing the player attributes table, When calculating the total count of players, When computing percentages",
            "operation": " calculate the percentage directly in the main query instead of using unnecessary subqueries."
        },
        "629": {
            "condition": "When calculating percentages",
            "operation": " perform division before multiplication by 100 to ensure correct percentage calculation order."
        },
        "630": {
            "condition": "When the question asks for percentage of players with specific attribute scores",
            "operation": " count players where both \"strength\" > 80 and \"stamina\" > 80, then divide by total players count."
        },
        "631": {
            "condition": "When using table aliases",
            "operation": " use consistent table alias \"t\" for the Player_Attributes table."
        },
        "632": {
            "condition": "When calculating percentages, When the question asks for percentage of players with specific attribute scores, When using table aliases, When output formatting",
            "operation": " do not include column aliases for cleaner output when not required by the question."
        },
        "633": {
            "condition": "When the question asks about the country where a league takes place",
            "operation": " use the \"name\" column from the \"Country\" table to get the country name."
        },
        "634": {
            "condition": "When the question mentions a specific league name like \"Poland Ekstraklasa\"",
            "operation": " first find the country_id from the \"League\" table where name = 'Poland Ekstraklasa'."
        },
        "635": {
            "condition": "When the question asks about the country where a league takes place, When the question mentions a specific league name like \"Poland Ekstraklasa\", When combining information from \"League\" and \"Country\" tables",
            "operation": " use the country_id from \"League\" to match with the corresponding record in \"Country\" table to get the country name."
        },
        "636": {
            "condition": "When answering about match scores",
            "operation": " use columns \"t2\".\"home_team_goal\" and \"t2\".\"away_team_goal\" for the final score instead of home_team_score and away_team_score."
        },
        "637": {
            "condition": "When combining league and match information",
            "operation": " join \"League\" as \"t1\" with \"Match\" as \"t2\" where \"t1\".\"id\" equals \"t2\".\"league_id\" and keep only matching pairs."
        },
        "638": {
            "condition": "When filtering for Belgian Jupiler League",
            "operation": " use condition \"t1\".\"name\" = 'Belgium Jupiler League' instead of league = 'Belgian Jupiler League'."
        },
        "639": {
            "condition": "When answering about match scores, When combining league and match information, When filtering for Belgian Jupiler League, When filtering for September 24, 2008",
            "operation": " use \"t2\".\"date\" LIKE '2008-09-24%' to handle potential timestamp values instead of exact date equality."
        },
        "640": {
            "condition": "When the question asks for player attributes like sprint speed, agility, and acceleration",
            "operation": " query the \"Player_Attributes\" table instead of the \"players\" table."
        },
        "641": {
            "condition": "When filtering by a player's name like \"Alexis Blin\"",
            "operation": " use a subquery to filter by \"player_api_id\" instead of directly filtering by name columns."
        },
        "642": {
            "condition": "When referencing a player's name",
            "operation": " use the \"player_name\" column from the \"Player\" table instead of separate \"first_name\" and \"last_name\" columns."
        },
        "643": {
            "condition": "When the question asks for player attributes like sprint speed, agility, and acceleration, When filtering by a player's name like \"Alexis Blin\", When referencing a player's name, When matching a specific player name like \"Alexis Blin\"",
            "operation": " use the IN operator with a subquery instead of direct WHERE conditions on name fields."
        },
        "644": {
            "condition": "When the question asks about a team's speed class",
            "operation": " use \"t1.buildUpPlaySpeedClass\" instead of \"speed_class\" as the output column."
        },
        "645": {
            "condition": "When retrieving values that may have duplicates",
            "operation": " use DISTINCT to return only unique values."
        },
        "646": {
            "condition": "When combining team attributes and team information",
            "operation": " use Team_Attributes AS t1 and Team AS t2 as sources with an INNER JOIN on t1.team_api_id = t2.team_api_id."
        },
        "647": {
            "condition": "When the question asks about a team's speed class, When retrieving values that may have duplicates, When combining team attributes and team information, When filtering for a specific team by name",
            "operation": " use t2.team_long_name = 'KSV Cercle Brugge' instead of team_name = 'KSV Cercle Brugge'."
        },
        "648": {
            "condition": "When answering about games played in a specific league and season",
            "operation": " join League table as T1 with Match table as T2 on T1.id = T2.league_id to combine league and match information."
        },
        "649": {
            "condition": "When the question mentions \"Italian Serie A league\"",
            "operation": " use T1.name = 'Italy Serie A' as the exact league name filter."
        },
        "650": {
            "condition": "When the question mentions \"2015\u20132016 season\"",
            "operation": " use T2.season = '2015/2016' as the exact season format."
        },
        "651": {
            "condition": "When counting games",
            "operation": " count T2.id as the canonical key for matches instead of counting all rows."
        },
        "652": {
            "condition": "When answering about games played in a specific league and season, When the question mentions \"Italian Serie A league\", When the question mentions \"2015\u20132016 season\", When counting games, When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.id = T2.league_id and keep only matching pairs (inner match)."
        },
        "653": {
            "condition": "When answering about \"highest score of the home team\"",
            "operation": " make sure the output order: MAX(t2.home_team_goal)."
        },
        "654": {
            "condition": "When the question mentions \"Netherlands Eredivisie league\"",
            "operation": " \"Netherlands Eredivisie\" actually means \"t1.name = 'Netherlands Eredivisie'\" in schema."
        },
        "655": {
            "condition": "When combining League AS t1 and Match AS t2 for shared entities",
            "operation": " link rows where the canonical keys are equal exactly as shown in the amends (t1.id = t2.league_id); keep only matching pairs (inner match)."
        },
        "656": {
            "condition": "When answering about \"highest score of the home team\", When the question mentions \"Netherlands Eredivisie league\", When combining League AS t1 and Match AS t2 for shared entities, When the question asks for \"highest score\"",
            "operation": " rank rows by t2.home_team_goal in descending direction and keep the first 1 row."
        },
        "657": {
            "condition": "When the question asks for \"finishing rate\" and \"curve score\"",
            "operation": " these actually mean columns \"finishing\" and \"curve\" from table \"Player_Attributes\"."
        },
        "658": {
            "condition": "When identifying the heaviest player",
            "operation": " first find the \"player_api_id\" from table \"Player\" ordered by \"weight DESC\" with \"LIMIT 1\"."
        },
        "659": {
            "condition": "When retrieving attributes for a specific player",
            "operation": " use a WHERE clause to match \"player_api_id\" in \"Player_Attributes\" with the player ID found from the \"Player\" table."
        },
        "660": {
            "condition": "When the question asks for \"finishing rate\" and \"curve score\", When identifying the heaviest player, When retrieving attributes for a specific player, When the question asks for a single result",
            "operation": " maintain \"LIMIT 1\" on the final query."
        },
        "661": {
            "condition": "When answering about \"top 4 leagues had the most games\"",
            "operation": " rank leagues by match count in descending order and keep the first 4 rows."
        },
        "662": {
            "condition": "When the question mentions \"leagues\"",
            "operation": " use \"t1.name\" from the League table to represent league names."
        },
        "663": {
            "condition": "When the question mentions \"games\"",
            "operation": " this actually means \"matches\" in the schema, so count using \"t2.id\" from the Match table."
        },
        "664": {
            "condition": "When combining League and Match tables",
            "operation": " link rows where \"t1.id = t2.league_id\" and keep only matching pairs (inner match)."
        },
        "665": {
            "condition": "When filtering for the 2015-2016 season",
            "operation": " use the exact literal value '2015/2016' for the Match.season column."
        },
        "666": {
            "condition": "When counting matches per league",
            "operation": " compute the number of rows using the canonical key \"t2.id\" from the Match table."
        },
        "667": {
            "condition": "When answering about \"top 4 leagues had the most games\", When the question mentions \"leagues\", When the question mentions \"games\", When combining League and Match tables, When filtering for the 2015-2016 season, When counting matches per league, When producing output",
            "operation": " make sure the output order is \"t1.name\" followed by the match count."
        },
        "668": {
            "condition": "When answering about \"top 4 leagues had the most games\"",
            "operation": " rank leagues by game count in descending order and keep the first 4 rows."
        },
        "669": {
            "condition": "When the question asks for \"most games\"",
            "operation": " count the number of matches using the canonical key t2.id."
        },
        "670": {
            "condition": "When the question mentions \"2015-2016 season\"",
            "operation": " filter matches where t2.season equals exactly '2015/2016'."
        },
        "671": {
            "condition": "When combining League and Match tables",
            "operation": " link rows where t1.id equals t2.league_id and keep only matching pairs (inner match)."
        },
        "672": {
            "condition": "When grouping by league",
            "operation": " organize results by t1.name and compute aggregates per league."
        },
        "673": {
            "condition": "When answering about \"top 4 leagues had the most games\", When the question asks for \"most games\", When the question mentions \"2015-2016 season\", When combining League and Match tables, When grouping by league, When producing output",
            "operation": " only include t1.name in the final results, not the count aggregation."
        },
        "674": {
            "condition": "When answering about \"the away team that scored the most goals\"",
            "operation": " make sure the output order: t2.team_long_name."
        },
        "675": {
            "condition": "When the question mentions \"away team\"",
            "operation": " \"away team\" actually means \"t2.team_long_name in schema\"."
        },
        "676": {
            "condition": "When the question mentions \"most goals\" or \"highest goals\"",
            "operation": " rank rows by t1.away_team_goal in descending direction and keep the first 1 row."
        },
        "677": {
            "condition": "When combining T1 (Match) and T2 (Team) for shared entities",
            "operation": " link rows where t1.away_team_api_id = t2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "678": {
            "condition": "When answering about \"the away team that scored the most goals\", When the question mentions \"away team\", When the question mentions \"most goals\" or \"highest goals\", When combining T1 (Match) and T2 (Team) for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "679": {
            "condition": "When answering about \"player whose overall strength is the greatest\"",
            "operation": " make sure the output order: t1.player_name."
        },
        "680": {
            "condition": "When the question mentions \"name\"",
            "operation": " \"name\" actually means \"t1.player_name\" in schema."
        },
        "681": {
            "condition": "When combining T1 (Player) and T2 (Player_Attributes) for shared entities",
            "operation": " link rows where t1.player_api_id = t2.player_api_id; keep only matching pairs (inner match)."
        },
        "682": {
            "condition": "When the question asks for \"greatest overall strength\"",
            "operation": " find players where t2.overall_rating equals the maximum overall_rating value from Player_Attributes."
        },
        "683": {
            "condition": "When answering about \"player whose overall strength is the greatest\", When the question mentions \"name\", When combining T1 (Player) and T2 (Player_Attributes) for shared entities, When the question asks for \"greatest overall strength\", When selecting player names",
            "operation": " use DISTINCT to ensure each player appears only once in results."
        },
        "684": {
            "condition": "When answering about percentage of players under 180 cm with overall strength over 70",
            "operation": " combine data from both Player table (as t1) and Player_Attributes table (as t2) using an inner match where t1.player_api_id = t2.player_api_id."
        },
        "685": {
            "condition": "When filtering for height under 180 cm",
            "operation": " apply the condition t1.height < 180 to the Player table."
        },
        "686": {
            "condition": "When filtering for overall rating over 70",
            "operation": " apply the condition t2.overall_rating > 70 to the Player_Attributes table."
        },
        "687": {
            "condition": "When counting players",
            "operation": " use t1.id as the counting key for both numerator and denominator counts."
        },
        "688": {
            "condition": "When answering about percentage of players under 180 cm with overall strength over 70, When filtering for height under 180 cm, When filtering for overall rating over 70, When counting players, When calculating percentage",
            "operation": " compute (count of players meeting both conditions) divided by (total count of players meeting height condition) multiplied by 100, using CAST for proper division handling."
        },
        "689": {
            "condition": "When calculating the percentage of players under 180 cm with overall strength above 70",
            "operation": " use COUNT(CASE WHEN t2.overall_rating > 70 THEN t1.id ELSE NULL END) for the numerator instead of COUNT(DISTINCT t1.id) with separate filtering."
        },
        "690": {
            "condition": "When computing the denominator for percentage calculation",
            "operation": " use COUNT(t1.id) for all players under 180 cm instead of a subquery with COUNT(DISTINCT t1.id)."
        },
        "691": {
            "condition": "When combining Player and Player_Attributes tables",
            "operation": " link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match)."
        },
        "692": {
            "condition": "When filtering players by height",
            "operation": " use t1.height < 180 to identify players under 180 cm."
        },
        "693": {
            "condition": "When calculating the percentage of players under 180 cm with overall strength above 70, When computing the denominator for percentage calculation, When combining Player and Player_Attributes tables, When filtering players by height, When calculating the final percentage",
            "operation": " use * 100 / COUNT(t1.id) instead of complex division and multiplication operations."
        }
    },
    "thrombosis_prediction": {
        "0": {
            "condition": "When the question asks about in-patient vs outpatient counts",
            "operation": " use the \"Admission\" column with values '+' for in-patient and '-' for outpatient instead of a \"visit_type\" column."
        },
        "1": {
            "condition": "When counting patients by admission type",
            "operation": " use SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) for in-patient count and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) for outpatient count instead of separate COUNT functions."
        },
        "2": {
            "condition": "When calculating percentage deviation",
            "operation": " compute (in-patient count * 100 / outpatient count) instead of absolute deviation between counts."
        },
        "3": {
            "condition": "When filtering for male patients",
            "operation": " use SEX = 'M' instead of gender = 'Male'."
        },
        "4": {
            "condition": "When working with patient data",
            "operation": " use the \"Patient\" table instead of \"patients\" table and do not join with any other tables."
        },
        "5": {
            "condition": "When the question asks about in-patient vs outpatient counts, When counting patients by admission type, When calculating percentage deviation, When filtering for male patients, When working with patient data, When the question asks about deviation in percentage",
            "operation": " output the simple percentage calculation directly without complex CASE comparison logic or ABS function."
        },
        "6": {
            "condition": "When the question asks for percentage of female patients born after 1930",
            "operation": " use the exact table name \"Patient\" and column name \"SEX\" instead of 'patients' and 'gender'."
        },
        "7": {
            "condition": "When calculating year of birth",
            "operation": " extract the year from the \"Birthday\" column using STRFTIME instead of using a direct year_of_birth column."
        },
        "8": {
            "condition": "When counting female patients born after 1930",
            "operation": " use SUM with a CASE expression instead of COUNT(*) with a WHERE filter."
        },
        "9": {
            "condition": "When calculating the percentage",
            "operation": " compute as (SUM(CASE...END) * 100 / COUNT(*)) with proper type casting instead of using a subquery for total count."
        },
        "10": {
            "condition": "When the question asks for percentage of female patients born after 1930, When calculating year of birth, When counting female patients born after 1930, When calculating the percentage, When filtering for female patients",
            "operation": " use the exact literal value 'F' for the \"SEX\" column."
        },
        "11": {
            "condition": "When the question asks for percentage of female patients",
            "operation": " filter rows where \"SEX\" equals 'F' in the WHERE clause instead of using conditional logic in the CASE expression."
        },
        "12": {
            "condition": "When calculating percentage",
            "operation": " use integer division instead of floating-point division with 100.0."
        },
        "13": {
            "condition": "When performing calculations",
            "operation": " explicitly cast the SUM result to REAL instead of relying on implicit casting."
        },
        "14": {
            "condition": "When the question asks for percentage",
            "operation": " remove column aliases like \"percentage\" from the output."
        },
        "15": {
            "condition": "When the question asks for percentage of female patients, When calculating percentage, When performing calculations, When the question asks for percentage, When filtering by birth year after 1930",
            "operation": " use the exact literal '1930' and compare using greater than operator for year extraction from \"Birthday\" column."
        },
        "16": {
            "condition": "When the question asks about patients born between specific years",
            "operation": " extract the year from the \"Birthday\" column using STRFTIME('%Y', Birthday) instead of using a numeric birth_year field."
        },
        "17": {
            "condition": "When filtering by birth year range",
            "operation": " use BETWEEN '1930' AND '1940' with string literals instead of numeric values."
        },
        "18": {
            "condition": "When counting patients with positive admissions",
            "operation": " use SUM(CASE WHEN Admission = '+' THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN patient_type = 'inpatient' THEN 1 END)."
        },
        "19": {
            "condition": "When calculating percentages",
            "operation": " cast the result as REAL instead of using implicit conversion with 100.0."
        },
        "20": {
            "condition": "When the question asks about patients born between specific years, When filtering by birth year range, When counting patients with positive admissions, When calculating percentages, When the output is a single percentage value",
            "operation": " do not include a column alias like percentage_inpatient."
        },
        "21": {
            "condition": "When the question asks for a ratio of outpatient to inpatient treatment",
            "operation": " use SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) for outpatient count and SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) for inpatient count, with proper decimal handling for the ratio calculation."
        },
        "22": {
            "condition": "When filtering for 'SLE' diagnosed patients",
            "operation": " use WHERE Diagnosis = 'SLE' with exact case sensitivity."
        },
        "23": {
            "condition": "When referencing the patient table",
            "operation": " use table name Patient (not patients) and column names Diagnosis and Admission with proper case sensitivity as shown in the schema."
        },
        "24": {
            "condition": "When the question asks for a ratio of outpatient to inpatient treatment, When filtering for 'SLE' diagnosed patients, When referencing the patient table, When counting admission status",
            "operation": " use Admission column values '+' for outpatient and '-' for inpatient instead of treatment_type column with values 'outpatient' and 'inpatient'."
        },
        "25": {
            "condition": "When the question asks for disease diagnosis and laboratory test dates for a specific patient",
            "operation": " select \"Diagnosis\" from table \"Patient\" and \"Date\" from table \"Laboratory\" as output columns."
        },
        "26": {
            "condition": "When joining tables \"Patient\" and \"Laboratory\"",
            "operation": " perform an inner match where \"T1.ID\" equals \"T2.ID\" exactly."
        },
        "27": {
            "condition": "When filtering for patient '30609'",
            "operation": " use numeric value 30609 without quotes for the patient ID filter."
        },
        "28": {
            "condition": "When the question asks for disease diagnosis and laboratory test dates for a specific patient, When joining tables \"Patient\" and \"Laboratory\", When filtering for patient '30609', When organizing output",
            "operation": " maintain the column order as \"Diagnosis\" followed by \"Date\"."
        },
        "29": {
            "condition": "When answering about patient information",
            "operation": " make sure the output order: T1.SEX, T1.Birthday, T2.\"Examination Date\", T2.Symptoms"
        },
        "30": {
            "condition": "When the question mentions \"patient ID '163109'\"",
            "operation": " use numeric comparison T1.ID = 163109 instead of string comparison"
        },
        "31": {
            "condition": "When combining patient and examination data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "32": {
            "condition": "When selecting columns from multiple tables",
            "operation": " qualify all columns with their table aliases (T1.SEX, T1.Birthday, T2.\"Examination Date\", T2.Symptoms)"
        },
        "33": {
            "condition": "When referring to the examination date column",
            "operation": " use the exact identifier T2.\"Examination Date\" with double quotes and proper case"
        },
        "34": {
            "condition": "When answering about patient information, When the question mentions \"patient ID '163109'\", When combining patient and examination data, When selecting columns from multiple tables, When referring to the examination date column, When referring to the symptoms column",
            "operation": " use the exact identifier T2.Symptoms with proper case"
        },
        "35": {
            "condition": "When answering about \"patient ID, sex and birthday of patient with LDH beyond normal range\"",
            "operation": " make sure the output order: T1.ID, T1.SEX, T1.Birthday"
        },
        "36": {
            "condition": "When the question mentions \"patient with LDH beyond normal range\"",
            "operation": " use the condition T2.LDH > 500 instead of LDH > 100 OR LDH < 50"
        },
        "37": {
            "condition": "When combining patients and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "38": {
            "condition": "When selecting patient information",
            "operation": " use table aliases T1.ID, T1.SEX, and T1.Birthday instead of unqualified column names"
        },
        "39": {
            "condition": "When answering about \"patient ID, sex and birthday of patient with LDH beyond normal range\", When the question mentions \"patient with LDH beyond normal range\", When combining patients and Laboratory tables, When selecting patient information, When retrieving patient records",
            "operation": " use DISTINCT to eliminate duplicate rows"
        },
        "40": {
            "condition": "When answering about patient ID and age",
            "operation": " make sure the output order: T1.ID first, then calculated age expression using STRFTIME."
        },
        "41": {
            "condition": "When the question mentions \"positive degree of coagulation\"",
            "operation": " \"positive\" actually means \"RVVT = '+'\" in the Examination table."
        },
        "42": {
            "condition": "When combining Patient (T1) and Examination (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "43": {
            "condition": "When calculating patient age",
            "operation": " compute age from birthday using STRFTIME function instead of using a direct age column."
        },
        "44": {
            "condition": "When answering about patient ID and age, When the question mentions \"positive degree of coagulation\", When combining Patient (T1) and Examination (T2) tables, When calculating patient age, When filtering for coagulation results",
            "operation": " use T2.RVVT = '+' instead of coagulation_degree = 'positive'."
        },
        "45": {
            "condition": "When calculating age from a birthday field",
            "operation": " use CURRENT_TIMESTAMP instead of 'now' for the current timestamp function."
        },
        "46": {
            "condition": "When computing age from year differences",
            "operation": " calculate only the year difference without month-day adjustments, using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)."
        },
        "47": {
            "condition": "When the question asks for \"positive degree of coagulation\"",
            "operation": " this corresponds to T2.RVVT = '+' condition."
        },
        "48": {
            "condition": "When combining Patient and Examination tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "49": {
            "condition": "When calculating age from a birthday field, When computing age from year differences, When the question asks for \"positive degree of coagulation\", When combining Patient and Examination tables, When answering about patient ID and age",
            "operation": " make sure the output order is T1.ID followed by the calculated age."
        },
        "50": {
            "condition": "When answering about patients with severe thrombosis",
            "operation": " use DISTINCT to eliminate duplicate rows in the results."
        },
        "51": {
            "condition": "When selecting patient identification",
            "operation": " use \"ID\" instead of patient_id as the exact column name."
        },
        "52": {
            "condition": "When selecting patient gender",
            "operation": " use \"SEX\" instead of sex as the exact column name."
        },
        "53": {
            "condition": "When selecting disease information",
            "operation": " use \"Diagnosis\" instead of disease_name as the exact column name."
        },
        "54": {
            "condition": "When combining patient and examination data",
            "operation": " perform an INNER JOIN between patients table (T1) and Examination table (T2) using the condition T1.ID = T2.ID."
        },
        "55": {
            "condition": "When answering about patients with severe thrombosis, When selecting patient identification, When selecting patient gender, When selecting disease information, When combining patient and examination data, When filtering for severe thrombosis",
            "operation": " use T2.Thrombosis = 2 instead of string matching, where 2 represents the severe degree numeric value."
        },
        "56": {
            "condition": "When answering about \"patients with severe degree of thrombosis\"",
            "operation": " filter rows where T2.Thrombosis = 2."
        },
        "57": {
            "condition": "When combining Patient table (T1) and Examination table (T2)",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "58": {
            "condition": "When the question asks for \"disease the patient is diagnosed with\"",
            "operation": " use T1.Diagnosis from the Patient table rather than T2.Diagnosis from the Examination table."
        },
        "59": {
            "condition": "When selecting output columns",
            "operation": " return T1.ID, T1.SEX, and T1.Diagnosis in that order."
        },
        "60": {
            "condition": "When answering about \"patients with severe degree of thrombosis\", When combining Patient table (T1) and Examination table (T2), When the question asks for \"disease the patient is diagnosed with\", When selecting output columns, When retrieving patient information",
            "operation": " ensure DISTINCT is applied to eliminate duplicate rows."
        },
        "61": {
            "condition": "When answering about patients born in a specific year",
            "operation": " use STRFTIME('%Y', T1.Birthday) = '1937' to filter by birth year with exact date formatting."
        },
        "62": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an inner join where T1.ID = T2.ID to link records using patient identifiers."
        },
        "63": {
            "condition": "When checking for abnormal total cholesterol levels",
            "operation": " use T2.\"T-CHO\" >= 250 as the threshold comparison with the correct column name and value."
        },
        "64": {
            "condition": "When selecting patient identifiers",
            "operation": " return DISTINCT T1.ID instead of all columns to ensure unique patient records."
        },
        "65": {
            "condition": "When answering about patients born in a specific year, When combining patient and laboratory data, When checking for abnormal total cholesterol levels, When selecting patient identifiers, When referring to tables",
            "operation": " use Patient AS T1 and Laboratory AS T2 as the canonical table aliases."
        },
        "66": {
            "condition": "When answering about patients with albumin level lower than 3.5",
            "operation": " use DISTINCT to ensure unique patient records."
        },
        "67": {
            "condition": "When selecting patient information",
            "operation": " output columns must be \"ID\", \"SEX\", and \"Diagnosis\" exactly as specified in the schema."
        },
        "68": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an inner join between \"Patient AS T1\" and \"Laboratory AS T2\" where \"T1.ID = T2.ID\" to match patients with their lab results."
        },
        "69": {
            "condition": "When filtering for low albumin levels",
            "operation": " use condition \"T2.ALB < 3.5\" to identify patients with albumin values below 3.5."
        },
        "70": {
            "condition": "When answering about patients with albumin level lower than 3.5, When selecting patient information, When combining patient and laboratory data, When filtering for low albumin levels, When referencing albumin values",
            "operation": " use the \"ALB\" column from the \"Laboratory\" table (T2) rather than any presumed column in the patient table."
        },
        "71": {
            "condition": "When calculating percentages with conditional counting",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN END)."
        },
        "72": {
            "condition": "When referencing total protein values",
            "operation": " use column T2.TP instead of tp.value."
        },
        "73": {
            "condition": "When defining the normal range for total protein",
            "operation": " use upper threshold 8.5 instead of 8.3."
        },
        "74": {
            "condition": "When joining patients and lab_tests tables",
            "operation": " use INNER JOIN on T1.ID = T2.ID instead of p.patient_id = tp.patient_id."
        },
        "75": {
            "condition": "When filtering for female patients",
            "operation": " use T1.SEX = 'F' in the WHERE clause instead of filtering within conditional expressions."
        },
        "76": {
            "condition": "When casting numeric results",
            "operation": " use REAL type instead of decimal notation."
        },
        "77": {
            "condition": "When calculating denominator for percentages",
            "operation": " divide by COUNT(*) instead of counting only specific cases."
        },
        "78": {
            "condition": "When using table aliases",
            "operation": " use T1 for patients table and T2 for lab_tests table."
        },
        "79": {
            "condition": "When referencing gender information",
            "operation": " use column T1.SEX instead of gender."
        },
        "80": {
            "condition": "When calculating percentages with conditional counting, When referencing total protein values, When defining the normal range for total protein, When joining patients and lab_tests tables, When filtering for female patients, When casting numeric results, When calculating denominator for percentages, When using table aliases, When referencing gender information, When referencing test values",
            "operation": " use column T2.TP instead of test_name."
        },
        "81": {
            "condition": "When the question asks about female patients",
            "operation": " filter for patients where T1.SEX equals exactly 'F' (case-sensitive)."
        },
        "82": {
            "condition": "When calculating percentage of patients with total protein outside normal range",
            "operation": " use the exact threshold values of 6.0 for lower bound and 8.5 for upper bound (TP < 6.0 OR TP > 8.5)."
        },
        "83": {
            "condition": "When computing percentage",
            "operation": " use integer division by multiplying the count of matching cases by 100 and then dividing by the total count of female patients."
        },
        "84": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID equals T2.ID exactly and keep only matching pairs (inner join)."
        },
        "85": {
            "condition": "When the question asks about female patients, When calculating percentage of patients with total protein outside normal range, When computing percentage, When combining Patient and Laboratory tables, When the query does not require column aliases",
            "operation": " omit any output column naming."
        },
        "86": {
            "condition": "When calculating percentages that involve division",
            "operation": " use explicit casting to REAL type around the numerator to ensure decimal division instead of integer division."
        },
        "87": {
            "condition": "When filtering conditions need to be combined with aggregate calculations",
            "operation": " include the filter condition (T1.SEX = 'F') directly within the CASE statement condition rather than applying it separately in a WHERE clause."
        },
        "88": {
            "condition": "When checking for values outside a normal range (6.0 to 8.5)",
            "operation": " use the condition (T2.TP < 6.0 OR T2.TP > 8.5) to identify abnormal values."
        },
        "89": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " use the exact key equality T1.ID = T2.ID to link patient records with their laboratory results."
        },
        "90": {
            "condition": "When calculating percentages that involve division, When filtering conditions need to be combined with aggregate calculations, When checking for values outside a normal range (6.0 to 8.5), When joining Patient and Laboratory tables, When computing percentage of female patients with abnormal total protein",
            "operation": " calculate as (count of female patients with TP outside 6.0-8.5 range) divided by (total count of female patients) multiplied by 100."
        },
        "91": {
            "condition": "When answering about \"percentage of female patient had total protein not within the normal range\"",
            "operation": " make sure the output order: percentage calculation"
        },
        "92": {
            "condition": "When the question mentions \"female patient\"",
            "operation": " \"female\" actually means \"SEX = 'F'\" in schema"
        },
        "93": {
            "condition": "When the question asks for \"percentage of female patients with abnormal TP values\"",
            "operation": " compute (number of female patients with T2.TP < 6.0 OR T2.TP > 8.5) divided by (total number of female patients), guarding division by zero"
        },
        "94": {
            "condition": "When combining Patient as T1 and Laboratory as T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "95": {
            "condition": "When filtering for female patients",
            "operation": " apply T1.SEX = 'F' condition to both numerator and denominator counts"
        },
        "96": {
            "condition": "When handling text literals",
            "operation": " use exact value 'F' for female patients without changing case or punctuation"
        },
        "97": {
            "condition": "When answering about \"percentage of female patient had total protein not within the normal range\", When the question mentions \"female patient\", When the question asks for \"percentage of female patients with abnormal TP values\", When combining Patient as T1 and Laboratory as T2, When filtering for female patients, When handling text literals, When calculating percentage",
            "operation": " multiply the ratio by 100 to convert to percentage format"
        },
        "98": {
            "condition": "When answering about average anti-cardiolipin antibody (IgG) concentration",
            "operation": " use T2.\"aCL IgG\" as the exact column name for the measurement."
        },
        "99": {
            "condition": "When calculating age for patients",
            "operation": " compute age using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 instead of a simple age column."
        },
        "100": {
            "condition": "When filtering for in-patient status",
            "operation": " use T1.Admission = '+' instead of patient_type = 'outpatient'."
        },
        "101": {
            "condition": "When answering about average anti-cardiolipin antibody (IgG) concentration, When calculating age for patients, When filtering for in-patient status, When combining patient and examination data",
            "operation": " join Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID to link patient records with their examination results."
        },
        "102": {
            "condition": "When answering about female patients",
            "operation": " use \"SEX = 'F'\" instead of \"gender = 'Female'\""
        },
        "103": {
            "condition": "When filtering by year 1997",
            "operation": " use \"STRFTIME('%Y', Description) = '1997'\" to extract year from the Description column"
        },
        "104": {
            "condition": "When checking admission status",
            "operation": " include filter \"Admission = '-'\" for unspecified admission status"
        },
        "105": {
            "condition": "When counting patients from 1997",
            "operation": " do not include any follow-up type conditions like \"follow_up_type = 'Outpatient'\""
        },
        "106": {
            "condition": "When answering about female patients, When filtering by year 1997, When checking admission status, When counting patients from 1997, When working with this schema",
            "operation": " use the \"Patient\" table directly instead of joining separate patients and visits tables"
        },
        "107": {
            "condition": "When calculating age from date columns",
            "operation": " compute age using STRFTIME('%Y', First Date) - STRFTIME('%Y', Birthday) instead of using a simple age column."
        },
        "108": {
            "condition": "When finding the youngest patient",
            "operation": " use MIN instead of MAX for the age calculation."
        },
        "109": {
            "condition": "When referencing the patient table",
            "operation": " use table name Patient instead of patients."
        },
        "110": {
            "condition": "When calculating age at initial arrival",
            "operation": " reference First Date and Birthday columns instead of arrival_date."
        },
        "111": {
            "condition": "When determining the youngest patient's age",
            "operation": " eliminate any subquery that finds minimum arrival date instead of keeping it."
        },
        "112": {
            "condition": "When calculating age from date columns, When finding the youngest patient, When referencing the patient table, When calculating age at initial arrival, When determining the youngest patient's age, When computing the minimum age",
            "operation": " remove any WHERE clause filter instead of including it."
        },
        "113": {
            "condition": "When combining patients (T1) and examinations (T2) tables",
            "operation": " link rows where T1.ID = T2.ID using inner join and keep only matching pairs."
        },
        "114": {
            "condition": "When filtering by year 1997",
            "operation": " extract year from T2.\"Examination Date\" using STRFTIME('%Y', T2.\"Examination Date\") = '1997'."
        },
        "115": {
            "condition": "When identifying female patients",
            "operation": " use T1.SEX = 'F' instead of 'Female'."
        },
        "116": {
            "condition": "When identifying most serious thrombosis cases",
            "operation": " use T2.Thrombosis = 1 instead of text values."
        },
        "117": {
            "condition": "When counting patients",
            "operation": " count all rows without grouping by gender."
        },
        "118": {
            "condition": "When combining patients (T1) and examinations (T2) tables, When filtering by year 1997, When identifying female patients, When identifying most serious thrombosis cases, When counting patients, When the question asks for count of patients with specific conditions",
            "operation": " compute the total number of rows satisfying all specified filters without grouping."
        },
        "119": {
            "condition": "When calculating age from birth dates",
            "operation": " use STRFTIME('%Y', MAX(Birthday)) - STRFTIME('%Y', MIN(Birthday)) instead of MAX(age) - MIN(age) to properly compute age from birth dates."
        },
        "120": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using an inner join instead of querying only one table."
        },
        "121": {
            "condition": "When filtering for patients with normal triglyceride",
            "operation": " use T2.TG >= 200 instead of triglyceride = 'normal' to use numeric comparison rather than string matching."
        },
        "122": {
            "condition": "When calculating age from birth dates, When combining Patient and Laboratory tables, When filtering for patients with normal triglyceride, When producing output",
            "operation": " do not include the AS age_gap alias in the final result."
        },
        "123": {
            "condition": "When selecting output columns",
            "operation": " use T2.Symptoms and T1.Diagnosis instead of symptom_name and diagnosis_name."
        },
        "124": {
            "condition": "When combining Patient and Examination tables",
            "operation": " use Patient as T1 and Examination as T2 with INNER JOIN on T1.ID = T2.ID."
        },
        "125": {
            "condition": "When filtering for valid symptoms",
            "operation": " add WHERE T2.Symptoms IS NOT NULL to exclude null symptom values."
        },
        "126": {
            "condition": "When finding the youngest patient",
            "operation": " order by T1.Birthday DESC instead of examination date to identify the patient with the most recent birthday (youngest)."
        },
        "127": {
            "condition": "When selecting output columns, When combining Patient and Examination tables, When filtering for valid symptoms, When finding the youngest patient, When limiting results",
            "operation": " take only the first row after ordering by birthday to get the youngest patient's record."
        },
        "128": {
            "condition": "When answering about average monthly count of male patients tested in 1998",
            "operation": " use COUNT(T1.ID) to count patients rather than averaging counts."
        },
        "129": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to properly relate patient and lab data."
        },
        "130": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male' using the correct column name and value format."
        },
        "131": {
            "condition": "When filtering for the year 1998",
            "operation": " use STRFTIME('%Y', T2.Date) = '1998' for year-based filtering instead of date range."
        },
        "132": {
            "condition": "When answering about average monthly count of male patients tested in 1998, When combining patient and laboratory data, When filtering for male patients, When filtering for the year 1998, When calculating monthly average",
            "operation": " use CAST(COUNT(T1.ID) AS REAL) / 12 to properly compute the monthly average count and remove grouping by month since it calculates an annual average."
        },
        "133": {
            "condition": "When counting patients in a laboratory context",
            "operation": " use COUNT(T1.ID) without DISTINCT since the join condition T1.ID = T2.ID already ensures unique patient IDs."
        },
        "134": {
            "condition": "When the question asks about male patients",
            "operation": " filter using T1.SEX = 'M' exactly as specified."
        },
        "135": {
            "condition": "When the question specifies the year 1998",
            "operation": " filter using STRFTIME('%Y', T2.Date) = '1998' to match the exact year."
        },
        "136": {
            "condition": "When calculating monthly averages from annual data",
            "operation": " divide the annual count by 12 to get the average per month."
        },
        "137": {
            "condition": "When counting patients in a laboratory context, When the question asks about male patients, When the question specifies the year 1998, When calculating monthly averages from annual data, When outputting results",
            "operation": " omit column aliases as the question does not require them."
        },
        "138": {
            "condition": "When answering about the oldest SJS patient's medical laboratory work",
            "operation": " make sure the output order: T1.Date, calculated age from date differences, and T2.Birthday."
        },
        "139": {
            "condition": "When the question mentions \"oldest\"",
            "operation": " rank patients by T2.Birthday in ascending order and keep the first 1 row."
        },
        "140": {
            "condition": "When combining Laboratory and Patient tables",
            "operation": " link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match)."
        },
        "141": {
            "condition": "When filtering for SJS patients",
            "operation": " use T2.Diagnosis = 'SJS' exactly as specified."
        },
        "142": {
            "condition": "When calculating patient age",
            "operation": " compute STRFTIME('%Y', T2.\"First Date\") - STRFTIME('%Y', T2.Birthday) to get age at initial arrival."
        },
        "143": {
            "condition": "When answering about the oldest SJS patient's medical laboratory work, When the question mentions \"oldest\", When combining Laboratory and Patient tables, When filtering for SJS patients, When calculating patient age, When handling date values",
            "operation": " ensure T2.Birthday IS NOT NULL to avoid invalid age calculations."
        },
        "144": {
            "condition": "When answering about \"ratio of male to female patients among those with abnormal uric acid counts\"",
            "operation": " use tables \"Patient AS T1\" and \"Laboratory AS T2\" with an inner join on T1.ID = T2.ID."
        },
        "145": {
            "condition": "When calculating counts for male and female patients",
            "operation": " use SUM with conditional expressions instead of COUNT with CASE."
        },
        "146": {
            "condition": "When determining abnormal uric acid levels",
            "operation": " apply gender-specific thresholds where males have UA <= 8.0 and females have UA <= 6.5 instead of a single threshold for all patients."
        },
        "147": {
            "condition": "When calculating the male-to-female ratio",
            "operation": " compute it directly using CAST to REAL division of male count divided by female count."
        },
        "148": {
            "condition": "When answering about \"ratio of male to female patients among those with abnormal uric acid counts\", When calculating counts for male and female patients, When determining abnormal uric acid levels, When calculating the male-to-female ratio, When filtering for abnormal uric acid",
            "operation": " do not use a WHERE clause before aggregation, instead apply the gender-specific thresholds within the conditional expressions for counting."
        },
        "149": {
            "condition": "When the question asks for ratio of male to female patients with abnormal uric acid counts",
            "operation": " compute (count of male patients with UA \u2264 8.0) divided by (count of female patients with UA \u2264 6.5), guarding against division by zero."
        },
        "150": {
            "condition": "When counting male patients with abnormal uric acid",
            "operation": " count rows where T1.SEX = 'M' AND T2.UA \u2264 8.0."
        },
        "151": {
            "condition": "When counting female patients with abnormal uric acid",
            "operation": " count rows where T1.SEX = 'F' AND T2.UA \u2264 6.5."
        },
        "152": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "153": {
            "condition": "When handling text literals",
            "operation": " preserve exact case and quotes for 'M' and 'F' values."
        },
        "154": {
            "condition": "When the question asks for ratio of male to female patients with abnormal uric acid counts, When counting male patients with abnormal uric acid, When counting female patients with abnormal uric acid, When combining Patient (T1) and Laboratory (T2) tables, When handling text literals, When computing ratios",
            "operation": " avoid unnecessary casting operations as division between numeric values doesn't require explicit casting."
        },
        "155": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count distinct patients rather than all examination records."
        },
        "156": {
            "condition": "When referencing tables",
            "operation": " use Patient AS T1 and Examination AS T2 as the canonical aliases."
        },
        "157": {
            "condition": "When combining Patient and Examination tables",
            "operation": " use INNER JOIN on T1.ID = T2.ID to only include patients with examinations."
        },
        "158": {
            "condition": "When filtering patients",
            "operation": " include only those with T1.Admission = '+' status."
        },
        "159": {
            "condition": "When counting patients, When referencing tables, When combining Patient and Examination tables, When filtering patients, When calculating time between initial visit and examination",
            "operation": " use STRFTIME('%Y', T2.Examination Date) - STRFTIME('%Y', T1.First Date) >= 1 to calculate year difference rather than date range comparison."
        },
        "160": {
            "condition": "When answering about underage patients examined during 1990-1993",
            "operation": " join Patient as T1 with Examination as T2 using T1.ID = T2.ID to link patient records with their examinations."
        },
        "161": {
            "condition": "When calculating patient age at examination time",
            "operation": " compute age using STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.Birthday) < 18 instead of using a static age column."
        },
        "162": {
            "condition": "When filtering by the three-year period from 1990 to 1993",
            "operation": " use STRFTIME('%Y', T2.\"Examination Date\") between '1990' and '1993' instead of full date range comparisons."
        },
        "163": {
            "condition": "When answering about underage patients examined during 1990-1993, When calculating patient age at examination time, When filtering by the three-year period from 1990 to 1993, When counting underage patients",
            "operation": " count T1.ID instead of using COUNT(*) to ensure each patient is counted only once regardless of multiple examinations."
        },
        "164": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows."
        },
        "165": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID to incorporate lab data."
        },
        "166": {
            "condition": "When filtering for elevated bilirubin",
            "operation": " use T2.\"T-BIL\" >= 2.0 instead of total_bilirubin > 1.2 to use the correct lab value column with the proper threshold."
        },
        "167": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for elevated bilirubin, When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male' to use the correct column name and value format."
        },
        "168": {
            "condition": "When the question asks about \"illness\" among patients",
            "operation": " \"illness\" actually means \"T2.Diagnosis\" in the schema."
        },
        "169": {
            "condition": "When the question mentions \"lab work was done between 1/1/1985, and 12/31/1995\"",
            "operation": " filter on \"T1.Examination Date\" between '1985-01-01' AND '1995-12-31' instead of lab_date."
        },
        "170": {
            "condition": "When combining examination and patient data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "171": {
            "condition": "When counting the most common illness",
            "operation": " count using T2.Diagnosis instead of counting all rows."
        },
        "172": {
            "condition": "When the question asks about \"illness\" among patients, When the question mentions \"lab work was done between 1/1/1985, and 12/31/1995\", When combining examination and patient data, When counting the most common illness, When the question asks for \"most common illness\"",
            "operation": " rank rows by count of T2.Diagnosis in descending order and keep only the first 1 row."
        },
        "173": {
            "condition": "When the question asks for the most common illness",
            "operation": " rank diagnoses by count in descending order and keep only the top 1 result."
        },
        "174": {
            "condition": "When counting occurrences of diagnoses",
            "operation": " count using the exact token T2.Diagnosis as the counting key."
        },
        "175": {
            "condition": "When filtering by date range for lab work",
            "operation": " use T1.\"Examination Date\" between '1985-01-01' and '1995-12-31' inclusive."
        },
        "176": {
            "condition": "When combining Examination (T1) and Patient (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "177": {
            "condition": "When the question asks for the most common illness, When counting occurrences of diagnoses, When filtering by date range for lab work, When combining Examination (T1) and Patient (T2) tables, When the output should show only the diagnosis value",
            "operation": " return only T2.Diagnosis column without the count aggregation in the results."
        },
        "178": {
            "condition": "When calculating patient age as of year 1999",
            "operation": " compute age using '1999' - STRFTIME('%Y', T2.Birthday) instead of using a simple age column."
        },
        "179": {
            "condition": "When combining laboratory and patient data",
            "operation": " join Laboratory AS T1 with Patient AS T2 on T1.ID = T2.ID using inner match."
        },
        "180": {
            "condition": "When filtering for laboratory examinations in October 1991",
            "operation": " use T1.Date BETWEEN '1991-10-01' AND '1991-10-30' instead of examination_date LIKE '1991-10%' AND examination_year = 1999."
        },
        "181": {
            "condition": "When calculating patient age as of year 1999, When combining laboratory and patient data, When filtering for laboratory examinations in October 1991, When answering about average age of patients",
            "operation": " make sure the output order: average age calculated from the age computation rule."
        },
        "182": {
            "condition": "When answering about patient age",
            "operation": " calculate age using STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) instead of selecting raw age."
        },
        "183": {
            "condition": "When selecting diagnosis information",
            "operation": " select T1.Diagnosis with table alias instead of just diagnosis."
        },
        "184": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "185": {
            "condition": "When ordering by hemoglobin count",
            "operation": " order by T2.HGB DESC with table alias instead of hemoglobin DESC."
        },
        "186": {
            "condition": "When answering about patient age, When selecting diagnosis information, When combining patient and laboratory data, When ordering by hemoglobin count, When finding the highest hemoglobin count",
            "operation": " take the first row after ordering by T2.HGB DESC."
        },
        "187": {
            "condition": "When answering about anti-nucleus antibody concentration level",
            "operation": " select the exact column \"ANA\" from table \"Examination\" instead of \"antibody_level\" from \"lab_tests\"."
        },
        "188": {
            "condition": "When filtering by patient identifier",
            "operation": " use the exact column \"ID\" with value 3605340 instead of \"patient_id\"."
        },
        "189": {
            "condition": "When filtering by date",
            "operation": " use the exact date format '1996-12-02' instead of '1996/12/2'."
        },
        "190": {
            "condition": "When answering about anti-nucleus antibody concentration level, When filtering by patient identifier, When filtering by date, When querying for anti-nucleus antibody test results",
            "operation": " do not include a separate test_type filter since the \"ANA\" column specifically represents this test type."
        },
        "191": {
            "condition": "When answering about cholesterol status for a specific patient and date",
            "operation": " calculate status conditionally using CASE WHEN T-CHO < 250 THEN 'Normal' ELSE 'Abnormal' END instead of selecting all columns."
        },
        "192": {
            "condition": "When querying laboratory data",
            "operation": " use the Laboratory table instead of cholesterol table to access the correct data source."
        },
        "193": {
            "condition": "When filtering by patient identifier",
            "operation": " use ID = 2927464 instead of patient_id = 2927464 with the exact column name."
        },
        "194": {
            "condition": "When filtering by date",
            "operation": " use Date = '1995-09-04' instead of date = '1995-9-4' with proper date formatting and exact column name."
        },
        "195": {
            "condition": "When answering about cholesterol status for a specific patient and date, When querying laboratory data, When filtering by patient identifier, When filtering by date, When deriving cholesterol status from T-CHO values",
            "operation": " remove any static status filter since status is now calculated based on the T-CHO < 250 threshold."
        },
        "196": {
            "condition": "When the question mentions \"gender\"",
            "operation": " \"gender\" actually means \"SEX in schema\"."
        },
        "197": {
            "condition": "When the question mentions \"patients\"",
            "operation": " \"patients\" actually means \"Patient in schema\"."
        },
        "198": {
            "condition": "When filtering for AORTITIS diagnosis",
            "operation": " include only rows where diagnosis equals 'AORTITIS' exactly."
        },
        "199": {
            "condition": "When ordering by diagnosis date",
            "operation": " order rows by First Date ASC instead of patient_id."
        },
        "200": {
            "condition": "When filtering for valid diagnosis dates",
            "operation": " include only rows where First Date IS NOT NULL."
        },
        "201": {
            "condition": "When the question mentions \"gender\", When the question mentions \"patients\", When filtering for AORTITIS diagnosis, When ordering by diagnosis date, When filtering for valid diagnosis dates, When selecting the first diagnosed patient",
            "operation": " keep only the first row after ordering by First Date ASC."
        },
        "202": {
            "condition": "When the question asks about the gender of a patient diagnosed with 'AORTITIS'",
            "operation": " use the exact literal 'AORTITIS' for the Diagnosis column filter."
        },
        "203": {
            "condition": "When handling column names with spaces like 'First Date'",
            "operation": " always use backticks around the identifier as `First Date` in both WHERE conditions and ORDER BY clauses."
        },
        "204": {
            "condition": "When the question asks about the gender of a patient diagnosed with 'AORTITIS', When handling column names with spaces like 'First Date', When finding the first diagnosed patient",
            "operation": " order by `First Date` in ascending order and take only the first result."
        },
        "205": {
            "condition": "When the question asks about anti-Cardiolipin antibody concentration status",
            "operation": " select the specific antibody columns \"aCL IgA\", \"aCL IgG\", and \"aCL IgM\" instead of a generalized column."
        },
        "206": {
            "condition": "When querying for patient examination data",
            "operation": " use the \"Examination\" table instead of patient_diagnoses tables."
        },
        "207": {
            "condition": "When filtering for patients diagnosed with SLE on a specific date",
            "operation": " use a subquery to filter patients where \"Diagnosis\" = 'SLE' and \"Description\" = '1994-02-19' instead of applying these filters directly in the main WHERE clause."
        },
        "208": {
            "condition": "When filtering by examination date",
            "operation": " reference \"Examination Date\" instead of test_date and use the proper date format '1993-11-12' instead of '1993/11/12'."
        },
        "209": {
            "condition": "When the question asks about anti-Cardiolipin antibody concentration status, When querying for patient examination data, When filtering for patients diagnosed with SLE on a specific date, When filtering by examination date, When specifying date values",
            "operation": " always use the format 'YYYY-MM-DD' with hyphens instead of slashes (e.g., '1994-02-19' instead of '1994/2/19')."
        },
        "210": {
            "condition": "When answering about patient gender and laboratory results",
            "operation": " make sure the output order: T1.SEX"
        },
        "211": {
            "condition": "When the question mentions \"ALT glutamic pylvic transaminase status\"",
            "operation": " \"ALT glutamic pylvic transaminase status\" actually means \"T2.GPT in schema\""
        },
        "212": {
            "condition": "When the question mentions a specific date \"1992-6-12\"",
            "operation": " use exact date format '1992-06-12' for T2.Date"
        },
        "213": {
            "condition": "When the question asks for gender information",
            "operation": " use T1.SEX from the Patient table instead of gender from patients table"
        },
        "214": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "215": {
            "condition": "When answering about patient gender and laboratory results, When the question mentions \"ALT glutamic pylvic transaminase status\", When the question mentions a specific date \"1992-6-12\", When the question asks for gender information, When combining Patient (T1) and Laboratory (T2) tables, When filtering for laboratory values",
            "operation": " use T2.GPT = 9.0 instead of alt_glutamic_pylvic_transaminase = 9"
        },
        "216": {
            "condition": "When calculating age from birth date and test date",
            "operation": " use STRFTIME('%Y', Date) - STRFTIME('%Y', Birthday) instead of simple year subtraction to properly handle year differences."
        },
        "217": {
            "condition": "When joining patients and laboratory_tests tables",
            "operation": " use T1.ID = T2.ID as the join condition instead of patient_id columns."
        },
        "218": {
            "condition": "When filtering for uric acid test with value 8.4",
            "operation": " use T2.UA = 8.4 instead of filtering by test_name and test_value separately."
        },
        "219": {
            "condition": "When filtering for test date 1991-10-21",
            "operation": " use T2.Date = '1991-10-21' with exact date format."
        },
        "220": {
            "condition": "When calculating age from birth date and test date, When joining patients and laboratory_tests tables, When filtering for uric acid test with value 8.4, When filtering for test date 1991-10-21, When using table aliases",
            "operation": " use T1 for patients table and T2 for laboratory_tests table consistently."
        },
        "221": {
            "condition": "When the question asks about a patient who first came on a specific date",
            "operation": " use the exact date format '1991-06-13' instead of '1991/6/13' for date comparisons."
        },
        "222": {
            "condition": "When filtering for patients with a specific diagnosis",
            "operation": " use the exact literal 'SJS' for the Diagnosis condition."
        },
        "223": {
            "condition": "When counting laboratory tests for a specific year",
            "operation": " use STRFTIME('%Y', Date) = '1995' to filter tests from 1995."
        },
        "224": {
            "condition": "When referencing the laboratory tests table",
            "operation": " use the table name \"Laboratory\" instead of \"LaboratoryTests\"."
        },
        "225": {
            "condition": "When joining or filtering by patient identifier",
            "operation": " use the column \"ID\" instead of \"PatientID\" for patient identification."
        },
        "226": {
            "condition": "When the question asks about a patient who first came on a specific date, When filtering for patients with a specific diagnosis, When counting laboratory tests for a specific year, When referencing the laboratory tests table, When joining or filtering by patient identifier, When answering about laboratory test counts for specific patients",
            "operation": " use a subquery approach to first identify patients meeting the criteria (First Date = '1991-06-13' and Diagnosis = 'SJS') before counting their laboratory tests."
        },
        "227": {
            "condition": "When answering about a patient diagnosed with SLE on a specific date",
            "operation": " use standardized date format '1997-01-27' instead of '1997/1/27' for exact matching."
        },
        "228": {
            "condition": "When the question mentions \"diagnosed SLE on 1997/1/27\"",
            "operation": " this actually means finding records where T2.Diagnosis = 'SLE' AND T2.Examination Date = '1997-01-27' in the Examination table."
        },
        "229": {
            "condition": "When combining Patient (T1) and Examination (T2) tables",
            "operation": " link rows where T1.ID = T2.ID using exact key equality and keep only matching pairs (inner match)."
        },
        "230": {
            "condition": "When finding the original diagnosis from first hospital visit",
            "operation": " use T1.Diagnosis from the Patient table where T2.Examination Date = T1.First Date."
        },
        "231": {
            "condition": "When identifying the specific patient",
            "operation": " use a subquery to find T2.ID from Examination where T2.Examination Date = '1997-01-27' AND T2.Diagnosis = 'SLE' instead of direct filtering in the main query."
        },
        "232": {
            "condition": "When answering about a patient diagnosed with SLE on a specific date, When the question mentions \"diagnosed SLE on 1997/1/27\", When combining Patient (T1) and Examination (T2) tables, When finding the original diagnosis from first hospital visit, When identifying the specific patient, When selecting output",
            "operation": " use T1.Diagnosis with explicit table alias instead of diagnosis without source specification."
        },
        "233": {
            "condition": "When answering about symptoms for a patient with specific birthday and examination date",
            "operation": " make sure the output order: T2.Symptoms"
        },
        "234": {
            "condition": "When the question mentions \"symptoms\"",
            "operation": " \"symptoms\" actually means \"T2.Symptoms\" in schema"
        },
        "235": {
            "condition": "When combining Patient as T1 and Examination as T2 for shared entities",
            "operation": " link rows where T1.ID = T2.ID; keep only matching pairs (inner match)"
        },
        "236": {
            "condition": "When filtering by patient birthday",
            "operation": " use exact date format '1959-03-01' for T1.Birthday"
        },
        "237": {
            "condition": "When answering about symptoms for a patient with specific birthday and examination date, When the question mentions \"symptoms\", When combining Patient as T1 and Examination as T2 for shared entities, When filtering by patient birthday, When filtering by examination date",
            "operation": " use exact date format '1993-09-27' for T2.\"Examination Date\""
        },
        "238": {
            "condition": "When answering about a patient born on a specific date",
            "operation": " filter patients using T1.Birthday = '1959-02-18' with exact date format."
        },
        "239": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows using T1.ID = T2.ID with inner join to keep only matching pairs."
        },
        "240": {
            "condition": "When calculating cholesterol decrease rate from November to December 1981",
            "operation": " compute (SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.\"T-CHO\" ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END)) / SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.\"T-CHO\" ELSE 0 END) to measure percentage decrease from December baseline."
        },
        "241": {
            "condition": "When handling multiple laboratory records",
            "operation": " use SUM aggregates with conditional logic instead of subquery joins."
        },
        "242": {
            "condition": "When referencing cholesterol values",
            "operation": " use the exact column name T2.\"T-CHO\" instead of total_cholesterol."
        },
        "243": {
            "condition": "When referencing date values",
            "operation": " use the exact column name T2.Date instead of test_date."
        },
        "244": {
            "condition": "When answering about a patient born on a specific date, When combining Patient and Laboratory tables, When calculating cholesterol decrease rate from November to December 1981, When handling multiple laboratory records, When referencing cholesterol values, When referencing date values, When outputting the result",
            "operation": " cast the decrease rate to REAL data type."
        },
        "245": {
            "condition": "When filtering for dates in November 1981",
            "operation": " use T2.Date LIKE '1981-11-%' instead of strftime functions."
        },
        "246": {
            "condition": "When filtering for dates in December 1981",
            "operation": " use T2.Date LIKE '1981-12-%' instead of strftime functions."
        },
        "247": {
            "condition": "When calculating decrease rate between November and December 1981",
            "operation": " maintain the formula (November_total - December_total) / December_total using T2.\"T-CHO\" values."
        },
        "248": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " use T1.ID = T2.ID as the join condition."
        },
        "249": {
            "condition": "When filtering for dates in November 1981, When filtering for dates in December 1981, When calculating decrease rate between November and December 1981, When joining Patient and Laboratory tables, When filtering for a specific patient",
            "operation": " use T1.Birthday = '1959-02-18' to find the patient born on 1959/2/18."
        },
        "250": {
            "condition": "When calculating a decrease rate between two time periods",
            "operation": " compute the difference between the earlier period value and later period value, then divide by the later period value to get the rate of decrease."
        },
        "251": {
            "condition": "When handling date filtering for specific months",
            "operation": " use exact date patterns like '1981-11-%' for November 1981 and '1981-12-%' for December 1981 to isolate measurements from those specific months."
        },
        "252": {
            "condition": "When performing division operations that should yield real numbers",
            "operation": " ensure the entire division operation is treated as real number division rather than casting only parts of the calculation."
        },
        "253": {
            "condition": "When calculating a decrease rate between two time periods, When handling date filtering for specific months, When performing division operations that should yield real numbers, When filtering data by date ranges",
            "operation": " avoid redundant WHERE clause filters when CASE statements already handle the specific date filtering needed for aggregation, to prevent including unwanted rows in calculations."
        },
        "254": {
            "condition": "When answering about patients diagnosed with Behcet's",
            "operation": " use the exact literal 'Behcet' for the Diagnosis filter."
        },
        "255": {
            "condition": "When filtering by examination date range",
            "operation": " use '1997-01-01' as the start date and '1997-12-31' as the end date for the Examination Date column."
        },
        "256": {
            "condition": "When selecting patient identifiers",
            "operation": " use the ID column from the Examination table instead of patient_id from patients."
        },
        "257": {
            "condition": "When referencing column names",
            "operation": " use backtick-quoted `Examination Date` and `Diagnosis` exactly as specified in the schema."
        },
        "258": {
            "condition": "When answering about patients diagnosed with Behcet's, When filtering by examination date range, When selecting patient identifiers, When referencing column names, When the question asks for patients with exams between specific dates",
            "operation": " filter on the Examination Date column with the inclusive range from '1997-01-01' to '1997-12-31'."
        },
        "259": {
            "condition": "When the question asks for patient IDs",
            "operation": " use the exact column token \"ID\" from the Laboratory table instead of \"patient_id\"."
        },
        "260": {
            "condition": "When counting distinct patients",
            "operation": " use DISTINCT with the \"ID\" column to get unique patient identifiers."
        },
        "261": {
            "condition": "When filtering by examination dates",
            "operation": " use the \"Date\" column with proper date format '1987-07-06' to '1996-01-31' instead of '1987/7/6' to '1996/1/31'."
        },
        "262": {
            "condition": "When the question mentions GPT level greater than 30",
            "operation": " use the condition \"GPT > 30\" with the exact column name."
        },
        "263": {
            "condition": "When the question mentions ALB level less than 4",
            "operation": " use the condition \"ALB < 4\" with the exact column name."
        },
        "264": {
            "condition": "When the question asks for patient IDs, When counting distinct patients, When filtering by examination dates, When the question mentions GPT level greater than 30, When the question mentions ALB level less than 4, When retrieving results",
            "operation": " do not include any ORDER BY clause as the question only asks to list them by ID without specifying ordering."
        },
        "265": {
            "condition": "When selecting patient identifiers",
            "operation": " use \"ID\" from table \"Patient\" instead of \"patient_id\" from \"patients\"."
        },
        "266": {
            "condition": "When filtering for female patients",
            "operation": " use \"SEX = 'F'\" instead of \"gender = 'male'\"."
        },
        "267": {
            "condition": "When filtering for birth year 1964",
            "operation": " use \"STRFTIME('%Y', Birthday) = '1964'\" instead of \"year(birth_date) = 1964\"."
        },
        "268": {
            "condition": "When checking admission status",
            "operation": " use \"Admission = '+'\" instead of \"admission_status = 'admitted'\"."
        },
        "269": {
            "condition": "When selecting patient identifiers, When filtering for female patients, When filtering for birth year 1964, When checking admission status, When combining multiple conditions",
            "operation": " ensure proper logical connection without incorrect AND operators."
        },
        "270": {
            "condition": "When answering about patients with thrombosis level 2 and ANA pattern S",
            "operation": " use table \"Examination\" instead of \"patients\" for both main query and subquery."
        },
        "271": {
            "condition": "When the question mentions \"degree of thrombosis level 2\"",
            "operation": " use column \"Thrombosis\" with value 2 instead of thrombosis_level."
        },
        "272": {
            "condition": "When the question mentions \"ANA pattern of only S\"",
            "operation": " use column \"ANA Pattern\" with exact value 'S' instead of ana_pattern."
        },
        "273": {
            "condition": "When the question mentions \"level of anti-Cardiolip in antibody (IgM)\"",
            "operation": " use column \"aCL IgM\" instead of anti_cardiolipin_igm for both outer condition and subquery calculation."
        },
        "274": {
            "condition": "When answering about patients with thrombosis level 2 and ANA pattern S, When the question mentions \"degree of thrombosis level 2\", When the question mentions \"ANA pattern of only S\", When the question mentions \"level of anti-Cardiolip in antibody (IgM)\", When computing average anti-Cardiolipin IgM level for comparison",
            "operation": " apply the same filter conditions \"Thrombosis = 2 AND ANA Pattern = 'S'\" to the subquery's WHERE clause to scope the average calculation to the relevant population matching the outer query's criteria."
        },
        "275": {
            "condition": "When answering about percentage of patients with specific laboratory values",
            "operation": " use table \"Laboratory\" as the data source instead of \"patients\"."
        },
        "276": {
            "condition": "When counting patients with uric acid level below normal range",
            "operation": " use SUM(CASE WHEN UA <= 6.5 THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN uric_acid < normal_range_min THEN 1 END)."
        },
        "277": {
            "condition": "When filtering for proteinuria within normal range",
            "operation": " use condition U-PRO > 0 AND U-PRO < 30 instead of proteinuria BETWEEN normal_range_min AND normal_range_max."
        },
        "278": {
            "condition": "When calculating percentage",
            "operation": " use CAST(... AS REAL) * 100 / COUNT(ID) with explicit casting to real numbers instead of * 100.0 / COUNT(*)."
        },
        "279": {
            "condition": "When answering about percentage of patients with specific laboratory values, When counting patients with uric acid level below normal range, When filtering for proteinuria within normal range, When calculating percentage, When producing final output",
            "operation": " remove the column alias \"percentage\" instead of keeping it."
        },
        "280": {
            "condition": "When the question mentions \"proteinuria level within the normal range\"",
            "operation": " \"U-PRO > 0 AND U-PRO < 30\" represents the condition for proteinuria being within normal range."
        },
        "281": {
            "condition": "When the question mentions \"uric acid level below the normal range\"",
            "operation": " \"UA <= 6.5\" represents the condition for uric acid being below normal range."
        },
        "282": {
            "condition": "When the question asks for a percentage of patients",
            "operation": " compute (number of patients with UA <= 6.5) divided by (total number of patients with U-PRO > 0 AND U-PRO <"
        },
        "283": {
            "condition": "multiplied by 100.",
            "operation": "multiplied by 100."
        },
        "284": {
            "condition": "When handling column names with special characters like hyphens",
            "operation": " enclose the column name `U-PRO` in backticks to avoid syntax errors."
        },
        "285": {
            "condition": "When the question mentions \"proteinuria level within the normal range\", When the question mentions \"uric acid level below the normal range\", When the question asks for a percentage of patients, multiplied by 100., When handling column names with special characters like hyphens, When counting patients",
            "operation": " use the canonical key \"ID\" to count individual patients rather than counting all rows."
        },
        "286": {
            "condition": "When the question asks for percentage of patients diagnosed with 'BEHCET'",
            "operation": " use SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100 / COUNT(ID) instead of complex COUNT expressions with multiple conditions."
        },
        "287": {
            "condition": "When filtering for male patients",
            "operation": " use SEX = 'M' instead of gender = 'M' as the exact column token."
        },
        "288": {
            "condition": "When filtering for patients who first presented in 1981",
            "operation": " use STRFTIME('%Y', \"First Date\") = '1981' with the exact column name \"First Date\" in double quotes."
        },
        "289": {
            "condition": "When calculating percentages",
            "operation": " apply explicit CAST to REAL instead of implicit conversion with * 100.0."
        },
        "290": {
            "condition": "When the question asks for percentage of patients diagnosed with 'BEHCET', When filtering for male patients, When filtering for patients who first presented in 1981, When calculating percentages, When the schema shows that diagnosis information is available in the Patient table",
            "operation": " do not perform LEFT JOIN to a separate diagnoses table, query only from the Patient table."
        },
        "291": {
            "condition": "When answering about patients who were followed up at the outpatient clinic",
            "operation": " filter for patients where T1.Admission equals exactly '-' instead of using 'outpatient' as the literal value."
        },
        "292": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an inner join between Patient AS T1 and Laboratory AS T2 where T1.ID equals T2.ID exactly."
        },
        "293": {
            "condition": "When filtering for laboratory tests in October 1991",
            "operation": " use the date pattern '1991-10-%' with exact spacing and punctuation."
        },
        "294": {
            "condition": "When checking for normal bilirubin levels",
            "operation": " filter where T2.\"T-BIL\" is less than 2.0 instead of checking for values greater than 0."
        },
        "295": {
            "condition": "When answering about patients who were followed up at the outpatient clinic, When combining patient and laboratory data, When filtering for laboratory tests in October 1991, When checking for normal bilirubin levels, When listing distinct patients",
            "operation": " select only T1.ID with DISTINCT instead of all columns with *."
        },
        "296": {
            "condition": "When counting patients",
            "operation": " count distinct T1.ID values instead of all rows to count unique patients."
        },
        "297": {
            "condition": "When combining patient and examination data",
            "operation": " link rows where T1.ID = T2.ID using an inner match to keep only patients with examination records."
        },
        "298": {
            "condition": "When excluding P only ANA Pattern patients",
            "operation": " filter on T2.\"ANA Pattern\" != 'P' instead of pattern != 'P only ANA' to use the correct exclusion criteria."
        },
        "299": {
            "condition": "When filtering by birth year range",
            "operation": " extract year from T1.Birthday using STRFTIME('%Y', T1.Birthday) BETWEEN '1980' AND '1989' instead of using a birth_year column."
        },
        "300": {
            "condition": "When counting patients, When combining patient and examination data, When excluding P only ANA Pattern patients, When filtering by birth year range, When filtering for female patients",
            "operation": " use T1.SEX = 'F' instead of gender = 'F' to use the correct column name."
        },
        "301": {
            "condition": "When answering about patient sex with specific medical conditions",
            "operation": " make sure the output order: T1.SEX"
        },
        "302": {
            "condition": "When the question mentions \"diagnosed with PSS\"",
            "operation": " \"PSS\" actually means T2.Diagnosis = 'PSS' in schema"
        },
        "303": {
            "condition": "When the question mentions \"blood level of C-reactive protein de 2+\"",
            "operation": " \"C-reactive protein 2+\" actually means T3.CRP = '2+' in schema"
        },
        "304": {
            "condition": "When the question mentions \"createnine 1\"",
            "operation": " \"createnine 1\" actually means T3.CRE = 1.0 with decimal precision in schema"
        },
        "305": {
            "condition": "When the question mentions \"LDH 123\"",
            "operation": " \"LDH 123\" actually means T3.LDH = 123 in schema"
        },
        "306": {
            "condition": "When combining T1 (patients), T2 (Examination), and T3 (Laboratory) for shared entities",
            "operation": " link rows where T1.ID = T2.ID and T3.ID = T2.ID; keep only matching pairs (inner match)"
        },
        "307": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for table and column names"
        },
        "308": {
            "condition": "When handling text literals",
            "operation": " do not change case, spacing, or punctuation for values like 'PSS' and '2+'"
        },
        "309": {
            "condition": "When answering about patient sex with specific medical conditions, When the question mentions \"diagnosed with PSS\", When the question mentions \"blood level of C-reactive protein de 2+\", When the question mentions \"createnine 1\", When the question mentions \"LDH 123\", When combining T1 (patients), T2 (Examination), and T3 (Laboratory) for shared entities, When choosing identifier delimiters, When handling text literals, When referring to table roles",
            "operation": " do not rename or swap the aliases T1 for patients, T2 for Examination, T3 for Laboratory once set for this schema"
        },
        "310": {
            "condition": "When answering about average blood albumin level",
            "operation": " use T2.ALB for the average calculation instead of blood_albumin."
        },
        "311": {
            "condition": "When the question mentions \"female patients\"",
            "operation": " use T1.SEX = 'F' instead of gender = 'male' with the exact literal 'F'."
        },
        "312": {
            "condition": "When the question mentions \"PLT greater than 400\"",
            "operation": " use T2.PLT > 400 instead of plt > 400 with proper table qualification."
        },
        "313": {
            "condition": "When the question mentions \"diagnosed with SLE\"",
            "operation": " use T1.Diagnosis = 'SLE' instead of diagnosis = 'SLE' with proper table qualification and exact literal 'SLE'."
        },
        "314": {
            "condition": "When answering about average blood albumin level, When the question mentions \"female patients\", When the question mentions \"PLT greater than 400\", When the question mentions \"diagnosed with SLE\", When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using an inner match instead of querying a single table."
        },
        "315": {
            "condition": "When answering about \"most common sign of patients with SLE disease\"",
            "operation": " use table \"Examination\" instead of \"patients\" and column \"Symptoms\" instead of \"sign\"."
        },
        "316": {
            "condition": "When filtering for SLE disease",
            "operation": " use column \"Diagnosis\" with literal value 'SLE' in the WHERE condition."
        },
        "317": {
            "condition": "When counting occurrences",
            "operation": " use COUNT(\"Symptoms\") instead of COUNT(*) for aggregation."
        },
        "318": {
            "condition": "When grouping results",
            "operation": " group by \"Symptoms\" column."
        },
        "319": {
            "condition": "When ordering by frequency",
            "operation": " sort by the count in descending order."
        },
        "320": {
            "condition": "When answering about \"most common sign of patients with SLE disease\", When filtering for SLE disease, When counting occurrences, When grouping results, When ordering by frequency, When retrieving the most common",
            "operation": " limit to 1 row to get the single most frequent result."
        },
        "321": {
            "condition": "When answering about \"most common sign of patients with SLE disease\"",
            "operation": " make sure the output order: Symptoms."
        },
        "322": {
            "condition": "When the question mentions \"SLE disease\"",
            "operation": " \"SLE\" actually means \"Diagnosis = 'SLE'\" in schema."
        },
        "323": {
            "condition": "When the question asks for \"most common sign\"",
            "operation": " rank rows by count of Symptoms in descending order and keep the first 1 row."
        },
        "324": {
            "condition": "When the question asks for \"count of symptoms\"",
            "operation": " compute the number of rows using the Symptoms column."
        },
        "325": {
            "condition": "When answering about \"most common sign of patients with SLE disease\", When the question mentions \"SLE disease\", When the question asks for \"most common sign\", When the question asks for \"count of symptoms\", When the question says \"per symptom\"/\"by symptom\"",
            "operation": " organize results by Symptoms and compute requested aggregates per group."
        },
        "326": {
            "condition": "When answering about \"medical information on patient number 48473\"",
            "operation": " make sure the output order: \"First Date\", \"Diagnosis\""
        },
        "327": {
            "condition": "When the question mentions \"patient number 48473\"",
            "operation": " use exact literal value 48473 for filtering on column \"ID\""
        },
        "328": {
            "condition": "When selecting from the patient table",
            "operation": " reference table \"Patient\" instead of \"patients\""
        },
        "329": {
            "condition": "When outputting column names",
            "operation": " use aliases \"First Date\" and \"Diagnosis\" instead of \"admission_date\" and \"disease\""
        },
        "330": {
            "condition": "When answering about \"medical information on patient number 48473\", When the question mentions \"patient number 48473\", When selecting from the patient table, When outputting column names, When filtering for a specific patient",
            "operation": " do not use ORDER BY or LIMIT clauses since we want the actual first documentation date and diagnosis"
        },
        "331": {
            "condition": "When the question mentions \"patients\"",
            "operation": " use table \"Patient\" instead of \"patients\"."
        },
        "332": {
            "condition": "When the question mentions \"female\"",
            "operation": " use column \"SEX\" with value 'F' instead of \"gender\" with value 'male'."
        },
        "333": {
            "condition": "When counting patients",
            "operation": " use column \"ID\" as the counting key instead of counting all columns."
        },
        "334": {
            "condition": "When the question mentions \"patients\", When the question mentions \"female\", When counting patients, When filtering for APS diagnosis",
            "operation": " use column \"Diagnosis\" with value 'APS' instead of \"diagnosis\" with value 'APS'."
        },
        "335": {
            "condition": "When answering about \"patients who underwent testing in 1997 had protein levels outside the normal range\"",
            "operation": " use table \"Laboratory\" instead of joining \"patients\" and \"tests\" tables."
        },
        "336": {
            "condition": "When counting patients",
            "operation": " count using \"ID\" column instead of counting all rows with COUNT(*)."
        },
        "337": {
            "condition": "When filtering for year 1997",
            "operation": " use STRFTIME('%Y', Date) = '1997' to extract year from \"Date\" column."
        },
        "338": {
            "condition": "When checking for protein levels outside normal range",
            "operation": " use condition (ALB <= 6.0 OR ALB >= 8.5) instead of protein_level < 60 OR protein_level > 80."
        },
        "339": {
            "condition": "When answering about \"patients who underwent testing in 1997 had protein levels outside the normal range\", When counting patients, When filtering for year 1997, When checking for protein levels outside normal range, When combining conditions",
            "operation": " ensure proper parentheses are used to combine the year filter and protein level condition with correct operator precedence."
        },
        "340": {
            "condition": "When answering about proportion of patients with thrombocytopenia who had SLE diagnosed",
            "operation": " calculate the percentage using (number of SLE patients) divided by (total patients with thrombocytopenia) multiplied by 100."
        },
        "341": {
            "condition": "When the question mentions \"patients who had signs of thrombocytopenia\"",
            "operation": " filter rows where \"Symptoms\" equals 'thrombocytopenia' exactly."
        },
        "342": {
            "condition": "When counting SLE patients",
            "operation": " use SUM(CASE WHEN \"Diagnosis\" = 'SLE' THEN 1 ELSE 0 END) to count patients with SLE diagnosis."
        },
        "343": {
            "condition": "When calculating total patients with thrombocytopenia",
            "operation": " use COUNT(\"ID\") to count all patients with thrombocytopenia symptoms."
        },
        "344": {
            "condition": "When computing the proportion",
            "operation": " cast the SLE count to REAL before multiplying by 100 and dividing by total count to get percentage."
        },
        "345": {
            "condition": "When answering about proportion of patients with thrombocytopenia who had SLE diagnosed, When the question mentions \"patients who had signs of thrombocytopenia\", When counting SLE patients, When calculating total patients with thrombocytopenia, When computing the proportion, When handling diagnosis values",
            "operation": " use exact literal 'SLE' for SLE diagnosis comparison."
        },
        "346": {
            "condition": "When the question asks for percentage of patients who are women",
            "operation": " use SUM(CASE WHEN SEX = 'F' THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN p.gender = 'F' THEN 1 END) for accurate female counting."
        },
        "347": {
            "condition": "When referring to gender in the schema",
            "operation": " use the exact column token SEX instead of gender."
        },
        "348": {
            "condition": "When referring to patient identifier in the schema",
            "operation": " use the exact column token ID instead of patient_id."
        },
        "349": {
            "condition": "When filtering for patients diagnosed with RA",
            "operation": " use Diagnosis = 'RA' directly in the WHERE clause instead of joining a separate diagnoses table."
        },
        "350": {
            "condition": "When extracting birth year from date",
            "operation": " use STRFTIME('%Y', Birthday) = '1980' instead of birth_year = 1980."
        },
        "351": {
            "condition": "When the question asks for percentage of patients who are women, When referring to gender in the schema, When referring to patient identifier in the schema, When filtering for patients diagnosed with RA, When extracting birth year from date, When performing division for percentage calculation",
            "operation": " cast the sum to REAL instead of using 100.0 for proper floating-point division."
        },
        "352": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific non-null values."
        },
        "353": {
            "condition": "When referring to tables",
            "operation": " use Patient AS T1 and Examination AS T2 instead of patients, tests, and diagnoses tables."
        },
        "354": {
            "condition": "When combining Patient and Examination tables",
            "operation": " use INNER JOIN on T1.ID = T2.ID instead of separate joins on patient_id."
        },
        "355": {
            "condition": "When filtering for Behcet disease",
            "operation": " use T2.Diagnosis = 'Behcet' instead of 'Behcet disease'."
        },
        "356": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'Male'."
        },
        "357": {
            "condition": "When filtering for examination years 1995-1997",
            "operation": " use STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1995' AND '1997' instead of date range filtering on test_date."
        },
        "358": {
            "condition": "When counting patients, When referring to tables, When combining Patient and Examination tables, When filtering for Behcet disease, When filtering for male patients, When filtering for examination years 1995-1997, When filtering for patients who did not stay in hospital",
            "operation": " use T1.Admission = '-' instead of hospital_stay_duration > 0."
        },
        "359": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs."
        },
        "360": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows using T1.ID = T2.ID with an inner join between Patient AS T1 and Laboratory AS T2 tables."
        },
        "361": {
            "condition": "When filtering for white blood cell values below 3.5",
            "operation": " use T2.WBC < 3.5 instead of white_blood_cells < 3.5 to reference the correct laboratory table column."
        },
        "362": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for white blood cell values below 3.5, When selecting female patients",
            "operation": " use T1.SEX = 'F' instead of gender = 'male' to filter for female patients rather than male patients."
        },
        "363": {
            "condition": "When calculating time differences between dates",
            "operation": " use STRFTIME('%d', T3.\"Examination Date\") - STRFTIME('%d', T1.\"First Date\") to compute day differences between specific date columns."
        },
        "364": {
            "condition": "When combining Patient and Examination tables",
            "operation": " link rows where T1.ID = T3.ID using an inner join to match patient records."
        },
        "365": {
            "condition": "When filtering for a specific patient",
            "operation": " use T1.ID = 821298 to target the correct patient identifier."
        },
        "366": {
            "condition": "When calculating time differences between dates, When combining Patient and Examination tables, When filtering for a specific patient, When calculating individual date differences",
            "operation": " do not use aggregation functions since the calculation operates on individual date values rather than aggregated minimums."
        },
        "367": {
            "condition": "When answering about whether a patient's uric acid is within normal range",
            "operation": " use a CASE expression with conditional logic based on gender-specific thresholds instead of selecting raw uric acid values."
        },
        "368": {
            "condition": "When combining Patient table as T1 with Laboratory table as T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "369": {
            "condition": "When filtering for a specific patient with ID 57266",
            "operation": " use WHERE T1.ID = 57266 instead of filtering directly on patient_id."
        },
        "370": {
            "condition": "When evaluating uric acid levels",
            "operation": " implement gender-specific evaluation with (T1.SEX = 'F' AND T2.UA > 6.5) OR (T1.SEX = 'M' AND T2.UA > 8.0) instead of a simple range check."
        },
        "371": {
            "condition": "When answering about whether a patient's uric acid is within normal range, When combining Patient table as T1 with Laboratory table as T2, When filtering for a specific patient with ID 57266, When evaluating uric acid levels, When returning results",
            "operation": " return boolean true/false results from the CASE expression instead of numeric uric acid values."
        },
        "372": {
            "condition": "When the question asks about a patient with ID 57266",
            "operation": " filter rows where T1.ID equals 57266 exactly."
        },
        "373": {
            "condition": "When combining Patient table (T1) and Laboratory table (T2)",
            "operation": " link rows where T1.ID equals T2.ID using INNER JOIN."
        },
        "374": {
            "condition": "When checking uric acid (UA) levels against normal ranges",
            "operation": " use exact numeric thresholds of 6.5 for female patients (T1.SEX = 'F') and 8.0 for male patients (T1.SEX = 'M')."
        },
        "375": {
            "condition": "When returning boolean results",
            "operation": " use boolean literals true and false instead of string literals 'true' and 'false'."
        },
        "376": {
            "condition": "When the question asks about a patient with ID 57266, When combining Patient table (T1) and Laboratory table (T2), When checking uric acid (UA) levels against normal ranges, When returning boolean results, When the CASE expression produces a result",
            "operation": " do not assign an alias to the output column."
        },
        "377": {
            "condition": "When the question asks about laboratory examination dates",
            "operation": " use the column name \"Date\" from the \"Laboratory\" table."
        },
        "378": {
            "condition": "When filtering for patient '48473'",
            "operation": " use the condition ID = 48473 (numeric format, not string)."
        },
        "379": {
            "condition": "When checking for AST glutamic oxaloacetic transaminase (GOT) index above normal range",
            "operation": " use the condition GOT >= 60 to find values 60 or higher."
        },
        "380": {
            "condition": "When the question asks about laboratory examination dates, When filtering for patient '48473', When checking for AST glutamic oxaloacetic transaminase (GOT) index above normal range, When the question mentions \"laboratory examination\"",
            "operation": " this refers to the \"Laboratory\" table in the schema."
        },
        "381": {
            "condition": "When selecting patient demographic information",
            "operation": " output columns must be exactly \"SEX\" and \"Birthday\" in that order, not \"name\", \"sex\", and \"date_of_birth\"."
        },
        "382": {
            "condition": "When retrieving patient records",
            "operation": " ensure distinct results by removing duplicate patient entries."
        },
        "383": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " use INNER JOIN on exact key equality \"T1.ID = T2.ID\" to match rows between tables."
        },
        "384": {
            "condition": "When filtering for AST GOT laboratory results",
            "operation": " use the condition \"T2.GOT < 60\" to identify values within normal range."
        },
        "385": {
            "condition": "When filtering for examinations in 1994",
            "operation": " extract year using \"STRFTIME('%Y', T2.Date) = '1994'\" with exact literal '1994'."
        },
        "386": {
            "condition": "When selecting patient demographic information, When retrieving patient records, When joining Patient and Laboratory tables, When filtering for AST GOT laboratory results, When filtering for examinations in 1994, When the question does not specify ordering",
            "operation": " do not include any ORDER BY clause in the final output."
        },
        "387": {
            "condition": "When selecting patient identifiers",
            "operation": " use DISTINCT T1.ID to return unique patient IDs."
        },
        "388": {
            "condition": "When combining Patient and Laboratory data",
            "operation": " join T1 (Patient) and T2 (Laboratory) using T1.ID = T2.ID with an inner match."
        },
        "389": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' with exact case and quotes."
        },
        "390": {
            "condition": "When checking for elevated GPT levels",
            "operation": " use T2.GPT >= 60 with the exact column name and inclusive threshold."
        },
        "391": {
            "condition": "When selecting patient identifiers, When combining Patient and Laboratory data, When filtering for male patients, When checking for elevated GPT levels, When the question asks about ALT glutamic pylvic transaminase (GPT)",
            "operation": " this corresponds to the GPT column in the Laboratory table (T2.GPT)."
        },
        "392": {
            "condition": "When answering about patient diagnoses with abnormal GPT levels",
            "operation": " make sure the output order includes only distinct T1.Diagnosis values."
        },
        "393": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "394": {
            "condition": "When filtering for abnormal GPT levels",
            "operation": " use the condition T2.GPT > 60 instead of ALT > 100."
        },
        "395": {
            "condition": "When ordering results by date of birth",
            "operation": " use T1.Birthday ASC instead of date_of_birth ASC."
        },
        "396": {
            "condition": "When answering about patient diagnoses with abnormal GPT levels, When combining patient and laboratory data, When filtering for abnormal GPT levels, When ordering results by date of birth, When the question asks for diagnosis of patients",
            "operation": " return only distinct T1.Diagnosis values, not date_of_birth columns."
        },
        "397": {
            "condition": "When answering about \"average index of lactate dehydrogenase (LDH) for patients with LDH within normal range\"",
            "operation": " use the \"Laboratory\" table as the data source instead of the \"patients\" table."
        },
        "398": {
            "condition": "When filtering for lactate dehydrogenase (LDH) within normal range",
            "operation": " use the condition LDH < 500 instead of LDH > 200 to select lower LDH values."
        },
        "399": {
            "condition": "When answering about \"average index of lactate dehydrogenase (LDH) for patients with LDH within normal range\", When filtering for lactate dehydrogenase (LDH) within normal range, When calculating the average LDH",
            "operation": " compute the average of the LDH column from the Laboratory table for values below 500."
        },
        "400": {
            "condition": "When answering about patient ID and age",
            "operation": " select T1.ID and calculate age using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) instead of selecting age directly."
        },
        "401": {
            "condition": "When the question mentions lactate dehydrogenase (LDH)",
            "operation": " access LDH values from the Laboratory table (T2.LDH) instead of assuming they exist in the Patient table."
        },
        "402": {
            "condition": "When filtering for LDH between 100-300 index above normal range",
            "operation": " use the exact filter T2.LDH > 600 AND T2.LDH < 800 as specified in the amends."
        },
        "403": {
            "condition": "When combining Patient and Laboratory data",
            "operation": " perform an inner join where T1.ID = T2.ID to link patient records with their laboratory results."
        },
        "404": {
            "condition": "When answering about patient ID and age, When the question mentions lactate dehydrogenase (LDH), When filtering for LDH between 100-300 index above normal range, When combining Patient and Laboratory data, When selecting patient identifiers",
            "operation": " use T1.ID instead of patient_id as the exact identifier token."
        },
        "405": {
            "condition": "When answering about treatment type for patients with ALP within normal range",
            "operation": " use column \"Admission\" from table \"Patient\" instead of \"treatment_type\" from table \"patients\"."
        },
        "406": {
            "condition": "When combining patient and laboratory data",
            "operation": " join tables using INNER JOIN on T1.ID = T2.ID to link matching patient and laboratory records."
        },
        "407": {
            "condition": "When filtering for ALP within normal range",
            "operation": " use condition ALP < 300 instead of alp BETWEEN 44 AND 147."
        },
        "408": {
            "condition": "When answering about treatment type for patients with ALP within normal range, When combining patient and laboratory data, When filtering for ALP within normal range, When the question asks about treatment type without specifying inpatient or outpatient",
            "operation": " do not filter by specific admission types like 'inpatient'."
        },
        "409": {
            "condition": "When answering about patient ID and ALP status",
            "operation": " select T1.ID and a CASE expression evaluating T2.ALP instead of patient_id and alp directly."
        },
        "410": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 using inner join on T1.ID = T2.ID instead of querying only the patients table."
        },
        "411": {
            "condition": "When filtering by birth date",
            "operation": " use T1.Birthday = '1982-04-01' instead of birth_date = '1982-04-01'."
        },
        "412": {
            "condition": "When answering about patient ID and ALP status, When combining patient and laboratory data, When filtering by birth date, When evaluating ALP values",
            "operation": " remove the BETWEEN 40 AND 130 filter on alp and instead use a CASE expression to categorize ALP values."
        },
        "413": {
            "condition": "When the question asks about a patient born on April 1st, 1982",
            "operation": " filter rows where T1.Birthday equals exactly '1982-04-01'."
        },
        "414": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID equals T2.ID and keep only matching pairs (inner match)."
        },
        "415": {
            "condition": "When checking if ALP is within normal range",
            "operation": " use the condition T2.ALP < 300 to determine 'normal' status, otherwise 'abNormal'."
        },
        "416": {
            "condition": "When the question asks about a patient born on April 1st, 1982, When combining Patient (T1) and Laboratory (T2) tables, When checking if ALP is within normal range, When answering about patient ID and ALP status",
            "operation": " output T1.ID first, followed by the ALP status evaluation without a column alias."
        },
        "417": {
            "condition": "When answering about patients with total protein (TP) below normal range",
            "operation": " use a direct threshold comparison of T2.TP < 6.0 instead of referencing a normal_ranges table."
        },
        "418": {
            "condition": "When selecting patient information",
            "operation": " use DISTINCT to eliminate duplicate patient records."
        },
        "419": {
            "condition": "When selecting gender and birth date",
            "operation": " use exact column names \"SEX\" and \"Birthday\" instead of \"sex\" and \"date_of_birth\"."
        },
        "420": {
            "condition": "When joining laboratory data",
            "operation": " use table \"Laboratory\" with alias T2 instead of \"lab_results\"."
        },
        "421": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows using T1.ID = T2.ID instead of p.ID = lr.patient_id."
        },
        "422": {
            "condition": "When answering about patients with total protein (TP) below normal range, When selecting patient information, When selecting gender and birth date, When joining laboratory data, When combining Patient and Laboratory tables, When filtering laboratory results",
            "operation": " use T2.TP column directly instead of checking test_name = 'TP' and result_value."
        },
        "423": {
            "condition": "When answering about female patients with TP beyond normal",
            "operation": " use table \"Patient\" as T1 and \"Laboratory\" as T2."
        },
        "424": {
            "condition": "When combining T1 and T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "425": {
            "condition": "When filtering for female patients",
            "operation": " use T1.SEX = 'F' exactly."
        },
        "426": {
            "condition": "When filtering for TP beyond normal",
            "operation": " use T2.TP > 8.5 exactly."
        },
        "427": {
            "condition": "When calculating deviation from normal TP",
            "operation": " compute T2.TP - 8.5 as the deviation."
        },
        "428": {
            "condition": "When answering about female patients with TP beyond normal, When combining T1 and T2, When filtering for female patients, When filtering for TP beyond normal, When calculating deviation from normal TP, When producing output",
            "operation": " return only the deviation calculation (T2.TP - 8.5) as the result."
        },
        "429": {
            "condition": "When answering about patients with abnormal albumin levels",
            "operation": " join Patient table as T1 with Laboratory table as T2 using inner join on T1.ID = T2.ID instead of querying only one table."
        },
        "430": {
            "condition": "When the question mentions \"male patient\"",
            "operation": " use T1.SEX = 'M' instead of gender = 'male' for filtering."
        },
        "431": {
            "condition": "When the question mentions \"albumin not within range\"",
            "operation": " use T2.ALB <= 3.5 OR T2.ALB >= 5.5 instead of BETWEEN to find values outside the normal range."
        },
        "432": {
            "condition": "When sorting patients by birthday in descending order",
            "operation": " use T1.Birthday DESC instead of ascending order."
        },
        "433": {
            "condition": "When answering about patients with abnormal albumin levels, When the question mentions \"male patient\", When the question mentions \"albumin not within range\", When sorting patients by birthday in descending order, When selecting output columns",
            "operation": " use DISTINCT T1.ID instead of all columns with * to avoid duplicate patient records."
        },
        "434": {
            "condition": "When the question asks about albumin status for patients born in 1982",
            "operation": " use CASE WHEN T2.ALB >= 3.5 AND T2.ALB <= 5.5 THEN 'normal' ELSE 'abnormal' END to determine albumin status with the correct range and lowercase output values."
        },
        "435": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " use INNER JOIN with the condition T1.ID = T2.ID to link patient records with their lab results."
        },
        "436": {
            "condition": "When filtering for patients born in 1982",
            "operation": " use STRFTIME('%Y', T1.Birthday) = '1982' to extract the year from the Birthday date field."
        },
        "437": {
            "condition": "When selecting output columns",
            "operation": " return only the albumin status column, not patient_id or name."
        },
        "438": {
            "condition": "When the question asks about albumin status for patients born in 1982, When joining Patient and Laboratory tables, When filtering for patients born in 1982, When selecting output columns, When ordering results",
            "operation": " do not apply any ordering as the question doesn't require sorted output."
        },
        "439": {
            "condition": "When answering about percentage of female patients with UA beyond normal range",
            "operation": " join Patient table as T1 and Laboratory table as T2 using T1.ID = T2.ID to combine patient and lab data."
        },
        "440": {
            "condition": "When filtering for female patients",
            "operation": " use T1.SEX = 'F' exactly as specified."
        },
        "441": {
            "condition": "When calculating UA values beyond normal range",
            "operation": " use T2.UA > 6.5 as the threshold condition."
        },
        "442": {
            "condition": "When counting patients with abnormal UA",
            "operation": " use SUM(CASE WHEN T2.UA > 6.5 THEN 1 ELSE 0 END) for the numerator."
        },
        "443": {
            "condition": "When calculating the total female patient count",
            "operation": " use COUNT(T1.ID) as the denominator."
        },
        "444": {
            "condition": "When answering about percentage of female patients with UA beyond normal range, When filtering for female patients, When calculating UA values beyond normal range, When counting patients with abnormal UA, When calculating the total female patient count, When computing the percentage",
            "operation": " use CAST(numerator AS REAL) * 100 / denominator to ensure proper decimal calculation."
        },
        "445": {
            "condition": "When answering about \"patients with normal uric acid (UA)\"",
            "operation": " filter laboratory_examinations where UA meets gender-specific thresholds without parentheses grouping."
        },
        "446": {
            "condition": "When calculating average UA index based on latest examination result",
            "operation": " use AVG(UA) and ensure the most recent result is selected by ordering by examination_date DESC and taking the first result."
        },
        "447": {
            "condition": "When answering about \"patients with normal uric acid (UA)\", When calculating average UA index based on latest examination result, When combining filter conditions",
            "operation": " move all conditions including T2.Date filter to the main WHERE clause conjunction without separate conditions."
        },
        "448": {
            "condition": "When answering about patients with normal uric acid",
            "operation": " filter laboratory results where T2.UA < 6.5 for female patients (T1.SEX = 'F') or T2.UA < 8.0 for male patients (T1.SEX = 'M')."
        },
        "449": {
            "condition": "When finding the latest laboratory examination result",
            "operation": " compare T2.Date to the maximum date in the Laboratory table to ensure only the most recent results are considered."
        },
        "450": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using an inner join to match patients with their laboratory records."
        },
        "451": {
            "condition": "When calculating average UA index",
            "operation": " compute AVG(T2.UA) across all matching records without grouping by individual patients."
        },
        "452": {
            "condition": "When answering about patients with normal uric acid, When finding the latest laboratory examination result, When combining Patient and Laboratory tables, When calculating average UA index, When handling table aliases",
            "operation": " use T1 for Patient table and T2 for Laboratory table as specified in the amends."
        },
        "453": {
            "condition": "When answering about patients with normal uric acid (UA)",
            "operation": " use gender-specific UA thresholds where female patients (T1.SEX = 'F') must have UA < 6.5 and male patients (T1.SEX = 'M') must have UA < 8.0."
        },
        "454": {
            "condition": "When finding the latest laboratory examination result",
            "operation": " for each patient, use the maximum Date from the Laboratory table without correlating the subquery to filter by patient ID."
        },
        "455": {
            "condition": "When answering about patients with normal uric acid (UA), When finding the latest laboratory examination result, When calculating average UA index",
            "operation": " compute AVG(T2.UA) from the Laboratory table using the most recent results that meet the normal UA criteria."
        },
        "456": {
            "condition": "When answering about \"average UA index for patients with normal uric acid\"",
            "operation": " make sure the output order: AVG(T2.UA)."
        },
        "457": {
            "condition": "When the question mentions \"latest laboratory examination result\"",
            "operation": " use the global maximum date across all Laboratory records instead of per-patient maximum."
        },
        "458": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "459": {
            "condition": "When filtering for normal uric acid levels",
            "operation": " apply sex-specific thresholds where (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M')."
        },
        "460": {
            "condition": "When answering about \"average UA index for patients with normal uric acid\", When the question mentions \"latest laboratory examination result\", When combining Patient (T1) and Laboratory (T2) tables, When filtering for normal uric acid levels, When selecting laboratory records",
            "operation": " include only those with T2.Date equal to the maximum date across all Laboratory records."
        },
        "461": {
            "condition": "When answering about patients with normal uric acid (UA)",
            "operation": " use sex-specific thresholds where female patients (T1.SEX = 'F') must have UA < 6.5 and male patients (T1.SEX = 'M') must have UA < 8.0."
        },
        "462": {
            "condition": "When calculating average UA based on latest laboratory examination",
            "operation": " ensure T2.Date equals the maximum date from the Laboratory table to get the most recent results."
        },
        "463": {
            "condition": "When combining filter conditions",
            "operation": " apply all conditions including date filter and sex-specific UA thresholds together in the WHERE clause without additional parentheses around the combined conditions."
        },
        "464": {
            "condition": "When answering about patients with normal uric acid (UA), When calculating average UA based on latest laboratory examination, When combining filter conditions, When joining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID to match patient records with their laboratory results."
        },
        "465": {
            "condition": "When answering about \"average UA index for patients with normal uric acid\"",
            "operation": " make sure the output order: AVG(T2.UA)"
        },
        "466": {
            "condition": "When combining Patient table as T1 and Laboratory table as T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "467": {
            "condition": "When filtering for the latest laboratory examination result",
            "operation": " include only rows where T2.Date equals the maximum Date from the Laboratory table"
        },
        "468": {
            "condition": "When defining normal uric acid levels",
            "operation": " apply gender-specific conditions where for female patients (T1.SEX = 'F'), UA must be less than 6.5, and for male patients (T1.SEX = 'M'), UA must be less than 8.0"
        },
        "469": {
            "condition": "When answering about \"average UA index for patients with normal uric acid\", When combining Patient table as T1 and Laboratory table as T2, When filtering for the latest laboratory examination result, When defining normal uric acid levels, When structuring filter conditions",
            "operation": " combine the date filter and gender-specific UA conditions in the main WHERE clause without unnecessary grouping parentheses around the OR condition"
        },
        "470": {
            "condition": "When answering about average UA index for patients with normal uric acid",
            "operation": " make sure the output order: average_ua"
        },
        "471": {
            "condition": "When combining Patient T1 and Laboratory T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "472": {
            "condition": "When filtering for latest laboratory examination result",
            "operation": " include only rows where T2.Date equals the maximum Date from Laboratory."
        },
        "473": {
            "condition": "When determining normal uric acid levels",
            "operation": " use the exact conditional logic (T2.UA < 6.5 AND T1.SEX = 'F') OR (T2.UA < 8.0 AND T1.SEX = 'M') with exact literals 'F' and 'M'."
        },
        "474": {
            "condition": "When answering about average UA index for patients with normal uric acid, When combining Patient T1 and Laboratory T2, When filtering for latest laboratory examination result, When determining normal uric acid levels, When computing the average UA",
            "operation": " calculate AVG(T2.UA) for the filtered results."
        },
        "475": {
            "condition": "When answering about \"patients whose urea nitrogen (UN) just within the borderline of passing\"",
            "operation": " make sure the output order: T1.ID, T1.SEX, T1.Birthday."
        },
        "476": {
            "condition": "When the question mentions \"urea nitrogen (UN)\"",
            "operation": " \"urea nitrogen (UN)\" actually means \"T2.UN in schema\" and requires a numeric value of 29."
        },
        "477": {
            "condition": "When combining Patient table as T1 and Laboratory table as T2",
            "operation": " link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match)."
        },
        "478": {
            "condition": "When selecting patient information",
            "operation": " use DISTINCT to eliminate duplicate rows."
        },
        "479": {
            "condition": "When answering about \"patients whose urea nitrogen (UN) just within the borderline of passing\", When the question mentions \"urea nitrogen (UN)\", When combining Patient table as T1 and Laboratory table as T2, When selecting patient information, When referring to patient identifiers",
            "operation": " use exact column names T1.ID, T1.SEX, and T1.Birthday with the specified casing."
        },
        "480": {
            "condition": "When answering about patient information",
            "operation": " make sure the output order: ID, sex, birthday."
        },
        "481": {
            "condition": "When the question mentions \"ID\"",
            "operation": " \"ID\" actually means \"T1.ID\" in schema."
        },
        "482": {
            "condition": "When the question mentions \"sex\"",
            "operation": " \"sex\" actually means \"T1.SEX\" in schema."
        },
        "483": {
            "condition": "When the question mentions \"birthday\"",
            "operation": " \"birthday\" actually means \"T1.Birthday\" in schema."
        },
        "484": {
            "condition": "When combining T1 (patients) and T2 (Laboratory) for shared entities",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "485": {
            "condition": "When filtering for patients diagnosed with 'RA'",
            "operation": " use T1.Diagnosis = 'RA' exactly as specified."
        },
        "486": {
            "condition": "When filtering for patients within UN normal index",
            "operation": " use T2.UN < 30 to identify patients with UN values below 30."
        },
        "487": {
            "condition": "When answering about patient information, When the question mentions \"ID\", When the question mentions \"sex\", When the question mentions \"birthday\", When combining T1 (patients) and T2 (Laboratory) for shared entities, When filtering for patients diagnosed with 'RA', When filtering for patients within UN normal index, When selecting patient records",
            "operation": " use DISTINCT to ensure each patient appears only once in results."
        },
        "488": {
            "condition": "When answering about \"male patients with creatinine index out of normal range\"",
            "operation": " make sure the output order: COUNT(T1.ID)."
        },
        "489": {
            "condition": "When the question mentions \"male patients\"",
            "operation": " \"male\" actually means \"T1.SEX = 'M'\" in schema."
        },
        "490": {
            "condition": "When the question mentions \"creatinine index out of normal range\"",
            "operation": " \"out of normal range\" actually means \"T2.CRE >= 1.5\" in schema."
        },
        "491": {
            "condition": "When combining patients table T1 and laboratory table T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "492": {
            "condition": "When answering about \"male patients with creatinine index out of normal range\", When the question mentions \"male patients\", When the question mentions \"creatinine index out of normal range\", When combining patients table T1 and laboratory table T2, When counting patients",
            "operation": " compute the number of rows using the canonical key token T1.ID."
        },
        "493": {
            "condition": "When answering about comparing male and female patients with elevated creatinine",
            "operation": " use Patient table as T1 and Laboratory table as T2 with an inner join on T1.ID = T2.ID."
        },
        "494": {
            "condition": "When filtering for elevated creatinine levels",
            "operation": " use WHERE T2.CRE >= 1.5 as the single threshold condition."
        },
        "495": {
            "condition": "When counting patients by gender",
            "operation": " use SUM(CASE WHEN T1.SEX = 'M' THEN 1 ELSE 0 END) for male count and SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) for female count."
        },
        "496": {
            "condition": "When comparing counts",
            "operation": " use CASE WHEN male_count > female_count THEN 'True' ELSE 'False' END to determine if there are more male patients."
        },
        "497": {
            "condition": "When answering about comparing male and female patients with elevated creatinine, When filtering for elevated creatinine levels, When counting patients by gender, When comparing counts, When handling gender values",
            "operation": " use exact literals 'M' for male and 'F' for female as shown in T1.SEX column."
        },
        "498": {
            "condition": "When the question asks for the highest total bilirubin level",
            "operation": " rank rows by T2.\"T-BIL\" in descending order and keep only the first 1 row."
        },
        "499": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match)."
        },
        "500": {
            "condition": "When answering about patient details with ID, sex and birthday",
            "operation": " make sure the output order includes T2.\"T-BIL\", T1.ID, T1.SEX, T1.Birthday."
        },
        "501": {
            "condition": "When the question asks for the highest total bilirubin level, When combining Patient and Laboratory tables, When answering about patient details with ID, sex and birthday, When handling identifier delimiters",
            "operation": " do not replace double quotes around \"T-BIL\" with backticks or unquoted forms."
        },
        "502": {
            "condition": "When selecting patient information",
            "operation": " use T1.ID and T1.SEX instead of just sex and COUNT(*)"
        },
        "503": {
            "condition": "When joining with laboratory data",
            "operation": " use Laboratory AS T2 with INNER JOIN on T1.ID = T2.ID"
        },
        "504": {
            "condition": "When filtering for abnormal T-BIL levels",
            "operation": " use T2.\"T-BIL\" >= 2.0 instead of checking normal range"
        },
        "505": {
            "condition": "When grouping results",
            "operation": " group by both T1.SEX and T1.ID to show individual patient records"
        },
        "506": {
            "condition": "When selecting patient information, When joining with laboratory data, When filtering for abnormal T-BIL levels, When grouping results, When the question asks for patients with abnormal T-BIL levels",
            "operation": " filter for values >= 2.0 rather than within normal range"
        },
        "507": {
            "condition": "When answering about \"oldest patient with highest total cholesterol\"",
            "operation": " make sure the output order: T2.\"T-CHO\" DESC, T1.Birthday ASC"
        },
        "508": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "509": {
            "condition": "When selecting patient identification",
            "operation": " use T1.ID instead of patient_id"
        },
        "510": {
            "condition": "When selecting cholesterol values",
            "operation": " use T2.\"T-CHO\" instead of MAX(t_cho)"
        },
        "511": {
            "condition": "When ordering by age",
            "operation": " use T1.Birthday ASC instead of age DESC"
        },
        "512": {
            "condition": "When answering about \"oldest patient with highest total cholesterol\", When combining Patient and Laboratory tables, When selecting patient identification, When selecting cholesterol values, When ordering by age, When the question asks for \"highest total cholesterol\"",
            "operation": " rank rows by T2.\"T-CHO\" in descending order and keep the first row"
        },
        "513": {
            "condition": "When calculating patient age",
            "operation": " compute age using STRFTIME('%Y', date('NOW')) - STRFTIME('%Y', T1.Birthday) instead of using a simple age column."
        },
        "514": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using inner match."
        },
        "515": {
            "condition": "When identifying high cholesterol",
            "operation": " filter for T2.\"T-CHO\" >= 250 instead of cholesterol = 'high' to use the numeric threshold."
        },
        "516": {
            "condition": "When calculating patient age, When combining patient and laboratory data, When identifying high cholesterol, When targeting male patients",
            "operation": " filter for T1.SEX = 'M' instead of gender = 'female'."
        },
        "517": {
            "condition": "When answering about \"patients and their diagnosis with triglyceride index greater than 100 of the normal range\"",
            "operation": " make sure the output order: T1.ID, T1.Diagnosis."
        },
        "518": {
            "condition": "When the question mentions \"patients\"",
            "operation": " use Patient AS T1 and Laboratory AS T2 with an INNER JOIN on T1.ID = T2.ID instead of querying only the patients table."
        },
        "519": {
            "condition": "When the question mentions \"triglyceride (TG) index greater than 100 of the normal range\"",
            "operation": " T2.TG > 300 instead of triglyceride > 100."
        },
        "520": {
            "condition": "When answering about \"patients and their diagnosis with triglyceride index greater than 100 of the normal range\", When the question mentions \"patients\", When the question mentions \"triglyceride (TG) index greater than 100 of the normal range\", When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "521": {
            "condition": "When counting patients",
            "operation": " count distinct T1.ID values instead of all rows to get unique patient counts."
        },
        "522": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an inner join between Patient AS T1 and Laboratory AS T2 where T1.ID = T2.ID to link patient records with their lab results."
        },
        "523": {
            "condition": "When filtering for high triglyceride levels",
            "operation": " use T2.TG >= 200 instead of TG > 150 to apply the correct threshold from laboratory data."
        },
        "524": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for high triglyceride levels, When calculating patient age",
            "operation": " compute age as current year minus birth year from T1.Birthday using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50 instead of using a direct age column."
        },
        "525": {
            "condition": "When answering about \"outpatient within normal range of creatinine phosphokinase\"",
            "operation": " make sure to combine data from both patients and laboratory tables using an inner match where T1.ID = T2.ID."
        },
        "526": {
            "condition": "When the question mentions \"outpatient\"",
            "operation": " this actually means T1.Admission = '-' in the schema."
        },
        "527": {
            "condition": "When the question mentions \"normal range of creatinine phosphokinase\"",
            "operation": " this actually means T2.CPK < 250 in the schema."
        },
        "528": {
            "condition": "When the question asks for \"distinct ids\"",
            "operation": " compute the number of unique values of T1.ID."
        },
        "529": {
            "condition": "When answering about \"outpatient within normal range of creatinine phosphokinase\", When the question mentions \"outpatient\", When the question mentions \"normal range of creatinine phosphokinase\", When the question asks for \"distinct ids\", When producing output",
            "operation": " return only T1.ID values in the results."
        },
        "530": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patients."
        },
        "531": {
            "condition": "When the question mentions \"male patients\"",
            "operation": " use T1.SEX = 'M' instead of gender = 'Male'."
        },
        "532": {
            "condition": "When extracting birth year from patient data",
            "operation": " use STRFTIME('%Y', T1.Birthday) for year extraction instead of a direct year_of_birth field."
        },
        "533": {
            "condition": "When filtering for patients born between 1936-1956",
            "operation": " apply the year range filter to the formatted birthday year (STRFTIME('%Y', T1.Birthday) BETWEEN 1936 AND 1956)."
        },
        "534": {
            "condition": "When checking creatinine phosphokinase levels",
            "operation": " use T2.CPK >= 250 instead of creatinine_phosphokinase > 100 to identify values beyond normal range."
        },
        "535": {
            "condition": "When counting patients, When the question mentions \"male patients\", When extracting birth year from patient data, When filtering for patients born between 1936-1956, When checking creatinine phosphokinase levels, When combining patient and laboratory data",
            "operation": " perform an INNER JOIN between Patient AS T1 and Laboratory AS T2 tables using T1.ID = T2.ID to link matching records."
        },
        "536": {
            "condition": "When answering about patient information",
            "operation": " use T1.ID, T1.SEX, and calculate age using STRFTIME instead of patient_id, sex, and age directly."
        },
        "537": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using inner match."
        },
        "538": {
            "condition": "When filtering for abnormal blood glucose",
            "operation": " use T2.GLU >= 180 instead of GLU BETWEEN 70 AND 140."
        },
        "539": {
            "condition": "When filtering for normal total cholesterol",
            "operation": " use T2.T-CHO < 250 instead of T_CHO BETWEEN 120 AND 240."
        },
        "540": {
            "condition": "When answering about patient information, When combining patient and laboratory data, When filtering for abnormal blood glucose, When filtering for normal total cholesterol, When selecting patient records",
            "operation": " use DISTINCT to ensure each patient appears only once in results."
        },
        "541": {
            "condition": "When calculating patient age from birthday",
            "operation": " use CURRENT_TIMESTAMP instead of 'now' for current date reference."
        },
        "542": {
            "condition": "When handling column names with hyphens like \"T-CHO\"",
            "operation": " use backticks for quoting instead of double quotes."
        },
        "543": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " explicitly specify INNER JOIN instead of just JOIN."
        },
        "544": {
            "condition": "When calculating patient age from birthday, When handling column names with hyphens like \"T-CHO\", When joining Patient and Laboratory tables, When calculating age from birthday",
            "operation": " remove the complex birthday comparison logic that checks if current month-day is before birth month-day."
        },
        "545": {
            "condition": "When answering about patient ID and blood glucose",
            "operation": " make sure the output order: T1.ID, T2.GLU"
        },
        "546": {
            "condition": "When the question mentions \"patient's ID\"",
            "operation": " \"patient's ID\" actually means \"T1.ID in schema\""
        },
        "547": {
            "condition": "When the question mentions \"blood glucose (GLU)\"",
            "operation": " \"blood glucose (GLU)\" actually means \"T2.GLU in schema\""
        },
        "548": {
            "condition": "When combining Patient as T1 and Laboratory as T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "549": {
            "condition": "When filtering for patients whose data was first recorded in 1991",
            "operation": " use STRFTIME('%Y', T1.\"First Date\") = '1991' to extract the year from the date field"
        },
        "550": {
            "condition": "When filtering for glucose within normal range",
            "operation": " use T2.GLU < 180 as the threshold condition"
        },
        "551": {
            "condition": "When answering about patient ID and blood glucose, When the question mentions \"patient's ID\", When the question mentions \"blood glucose (GLU)\", When combining Patient as T1 and Laboratory as T2, When filtering for patients whose data was first recorded in 1991, When filtering for glucose within normal range, When selecting patient IDs",
            "operation": " use DISTINCT T1.ID to ensure each patient appears only once in the results"
        },
        "552": {
            "condition": "When answering about patients with abnormal white blood cell count",
            "operation": " use T1.ID instead of patient_id and T1.SEX instead of sex."
        },
        "553": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID using an inner join."
        },
        "554": {
            "condition": "When filtering for abnormal white blood cell count",
            "operation": " use T2.WBC <= 3.5 OR T2.WBC >= 9.0 instead of white_blood_cell_count > 10000."
        },
        "555": {
            "condition": "When grouping results",
            "operation": " include T1.ID in the GROUP BY clause instead of grouping by sex only."
        },
        "556": {
            "condition": "When referring to birthday",
            "operation": " qualify it as T1.Birthday instead of unqualified birthday."
        },
        "557": {
            "condition": "When answering about patients with abnormal white blood cell count, When combining patient and laboratory data, When filtering for abnormal white blood cell count, When grouping results, When referring to birthday, When selecting distinct patient records",
            "operation": " use DISTINCT to avoid duplicate patient entries."
        },
        "558": {
            "condition": "When answering about patients with lower red blood cell counts",
            "operation": " join Patient table as T1 with Laboratory table as T2 using T1.ID = T2.ID to combine patient and lab data."
        },
        "559": {
            "condition": "When filtering for lower red blood cell counts",
            "operation": " use T2.RBC < 3.5 instead of red_blood_cell > 5.0, changing both the column reference and inequality direction."
        },
        "560": {
            "condition": "When selecting patient information",
            "operation": " use DISTINCT to return unique results and select Diagnosis and ID instead of patient_id, age, and diagnosis."
        },
        "561": {
            "condition": "When answering about patients with lower red blood cell counts, When filtering for lower red blood cell counts, When selecting patient information, When calculating patient age",
            "operation": " compute it dynamically using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) instead of selecting a pre-existing age column."
        },
        "562": {
            "condition": "When answering about female patients age 50 and above with abnormal red blood cell count",
            "operation": " select distinct T1.ID and T1.Admission instead of gender, age, red_blood_cell_count, and admission_status."
        },
        "563": {
            "condition": "When joining the Laboratory table",
            "operation": " use T2 as the alias and perform an inner join on T1.ID = T2.ID instead of joining on patient_id."
        },
        "564": {
            "condition": "When filtering for female patients",
            "operation": " use T1.SEX = 'F' instead of filtering for males."
        },
        "565": {
            "condition": "When filtering for abnormal red blood cell count",
            "operation": " use (T2.RBC <= 3.5 OR T2.RBC >= 6.0) instead of checking for 'normal' values."
        },
        "566": {
            "condition": "When calculating age",
            "operation": " use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) >= 50 instead of direct age comparison."
        },
        "567": {
            "condition": "When answering about female patients age 50 and above with abnormal red blood cell count, When joining the Laboratory table, When filtering for female patients, When filtering for abnormal red blood cell count, When calculating age, When the question asks about hospital admission status",
            "operation": " use T1.Admission column directly instead of joining an admissions table."
        },
        "568": {
            "condition": "When answering about \"outpatients\"",
            "operation": " use \"T1.Admission = '-'\" instead of \"patient_type = 'outpatient'\" to identify outpatients."
        },
        "569": {
            "condition": "When the question mentions \"low hemoglobin level\"",
            "operation": " use \"T2.HGB < 10\" instead of \"hemoglobin_level > 12.0\" to identify low hemoglobin levels."
        },
        "570": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where \"T1.ID = T2.ID\" using an inner join to ensure only matching patient records are included."
        },
        "571": {
            "condition": "When selecting patient identifiers",
            "operation": " use \"ID\" instead of \"patient_id\" and \"SEX\" instead of \"sex\" as the exact column names."
        },
        "572": {
            "condition": "When answering about \"outpatients\", When the question mentions \"low hemoglobin level\", When combining Patient and Laboratory tables, When selecting patient identifiers, When listing distinct patients",
            "operation": " use DISTINCT to ensure each patient appears only once in the results."
        },
        "573": {
            "condition": "When answering about patients diagnosed with SLE",
            "operation": " use \"T1.Diagnosis = 'SLE'\" as the filter condition."
        },
        "574": {
            "condition": "When determining normal hemoglobin level",
            "operation": " use numeric range filtering \"T2.HGB > 10 AND T2.HGB < 17\" instead of string comparison."
        },
        "575": {
            "condition": "When combining patient and laboratory data",
            "operation": " join \"Patient AS T1\" with \"Laboratory AS T2\" on \"T1.ID = T2.ID\" using inner match."
        },
        "576": {
            "condition": "When identifying the oldest patient",
            "operation": " order by \"T1.Birthday ASC\" and take the first result."
        },
        "577": {
            "condition": "When answering about patients diagnosed with SLE, When determining normal hemoglobin level, When combining patient and laboratory data, When identifying the oldest patient, When selecting output columns",
            "operation": " use \"T1.ID\" and \"T1.SEX\" exactly as specified."
        },
        "578": {
            "condition": "When answering about patient ID and age",
            "operation": " make sure the output order: T1.ID first, then calculated age using STRFTIME functions."
        },
        "579": {
            "condition": "When the question mentions \"patient with two or more laboratory examinations\"",
            "operation": " use a subquery that selects ID from Laboratory where HCT >= 52 grouped by ID with HAVING COUNT(ID) >= 2."
        },
        "580": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID using an inner join and keep only matching pairs."
        },
        "581": {
            "condition": "When the question mentions \"hematocrit level exceeded the normal range\"",
            "operation": " filter using HCT >= 52 as the threshold for abnormal hematocrit values."
        },
        "582": {
            "condition": "When answering about patient ID and age, When the question mentions \"patient with two or more laboratory examinations\", When combining Patient (T1) and Laboratory (T2) tables, When the question mentions \"hematocrit level exceeded the normal range\", When selecting patient identifiers",
            "operation": " use DISTINCT T1.ID to avoid duplicate patient records."
        },
        "583": {
            "condition": "When calculating patient age from birthday",
            "operation": " compute age as the difference between the current year and the birth year using CURRENT_TIMESTAMP for the current timestamp and extracting the year from T1.Birthday, without complex month-day adjustments."
        },
        "584": {
            "condition": "When identifying patients with two or more laboratory examinations showing hematocrit level exceeding normal range",
            "operation": " use the condition T2.HCT >= 52 to identify hematocrit levels exceeding normal range, and count occurrences per patient ID to find those with at least 2 such examinations."
        },
        "585": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID to associate laboratory results with the correct patients, keeping only matching pairs (inner match)."
        },
        "586": {
            "condition": "When calculating patient age from birthday, When identifying patients with two or more laboratory examinations showing hematocrit level exceeding normal range, When joining Patient and Laboratory tables, When selecting output columns",
            "operation": " include T1.ID and the computed age value in the results, ensuring distinct patient records are returned."
        },
        "587": {
            "condition": "When answering about average hematocrit levels",
            "operation": " use column \"HCT\" from table \"Laboratory\" (aliased as T2) instead of \"hematocrit\"."
        },
        "588": {
            "condition": "When filtering for year 1991",
            "operation": " extract year from \"Date\" column using STRFTIME('%Y', T2.Date) = '1991' instead of direct year comparison."
        },
        "589": {
            "condition": "When filtering for values lower than normal range",
            "operation": " use condition HCT < 29 instead of comparing to a normal_range column."
        },
        "590": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an INNER JOIN between \"Patient\" AS T1 and \"Laboratory\" AS T2 using join condition T1.ID = T2.ID."
        },
        "591": {
            "condition": "When answering about average hematocrit levels, When filtering for year 1991, When filtering for values lower than normal range, When combining patient and laboratory data, When calculating averages",
            "operation": " compute AVG(HCT) for the filtered results."
        },
        "592": {
            "condition": "When answering about platelet level comparisons",
            "operation": " join table \"Patient\" as T1 with \"Laboratory\" as T2 using T1.ID = T2.ID to link patient and laboratory data."
        },
        "593": {
            "condition": "When counting patients with abnormal platelet levels",
            "operation": " use column T2.PLT instead of \"platelet\" from a single table."
        },
        "594": {
            "condition": "When identifying low platelet levels",
            "operation": " consider values <= 100 as lower than normal range."
        },
        "595": {
            "condition": "When identifying high platelet levels",
            "operation": " consider values >= 400 as higher than normal range."
        },
        "596": {
            "condition": "When counting conditional cases",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for proper counting."
        },
        "597": {
            "condition": "When answering about platelet level comparisons, When counting patients with abnormal platelet levels, When identifying low platelet levels, When identifying high platelet levels, When counting conditional cases, When comparing low vs high platelet counts",
            "operation": " subtract the high count from the low count to get the net difference instead of showing separate columns."
        },
        "598": {
            "condition": "When answering about laboratory examinations in 1984",
            "operation": " filter to only include records where STRFTIME('%Y', T2.Date) = '1984' exactly."
        },
        "599": {
            "condition": "When determining patient age",
            "operation": " calculate age dynamically using STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday) < 50 to ensure age is computed relative to the lab date."
        },
        "600": {
            "condition": "When checking for normal platelet levels",
            "operation": " filter on T2.PLT BETWEEN 100 AND 400 for numeric range checking instead of text matching."
        },
        "601": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Laboratory AS T2 with Patients AS T1 using INNER JOIN on T1.ID = T2.ID to link related records."
        },
        "602": {
            "condition": "When answering about laboratory examinations in 1984, When determining patient age, When checking for normal platelet levels, When combining patient and laboratory data, When selecting patient identifiers",
            "operation": " use DISTINCT T1.ID instead of all columns to avoid duplicate patient entries."
        },
        "603": {
            "condition": "When calculating percentages",
            "operation": " use SUM(CASE WHEN condition THEN 1 ELSE 0 END) instead of COUNT(CASE WHEN condition THEN 1 END) for accurate counting."
        },
        "604": {
            "condition": "When checking for abnormal prothrombin time",
            "operation": " use PT >= 14 instead of PT > 14 to include the threshold value of 14."
        },
        "605": {
            "condition": "When filtering by gender",
            "operation": " use SEX = 'F' instead of gender = 'F' for the exact column name."
        },
        "606": {
            "condition": "When calculating age dynamically",
            "operation": " use STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55 instead of a static age column."
        },
        "607": {
            "condition": "When joining tables",
            "operation": " use T1.ID = T2.ID instead of patient_id columns for the exact join condition."
        },
        "608": {
            "condition": "When performing numeric division",
            "operation": " cast the sum to REAL instead of using 100.0 for proper floating-point calculation."
        },
        "609": {
            "condition": "When calculating percentages, When checking for abnormal prothrombin time, When filtering by gender, When calculating age dynamically, When joining tables, When performing numeric division, When using table aliases",
            "operation": " use T1 for the patients table and T2 for the lab_results table consistently."
        },
        "610": {
            "condition": "When calculating percentages",
            "operation": " cast the division result to REAL type explicitly instead of relying on implicit casting."
        },
        "611": {
            "condition": "When filtering for specific gender within a conditional calculation",
            "operation": " place the gender condition T1.SEX = 'F' inside the CASE statement rather than in the global WHERE clause."
        },
        "612": {
            "condition": "When joining tables",
            "operation": " use INNER JOIN explicitly for clarity instead of just JOIN."
        },
        "613": {
            "condition": "When naming calculated columns",
            "operation": " do not add alias names like AS percentage to the output column."
        },
        "614": {
            "condition": "When calculating percentages, When filtering for specific gender within a conditional calculation, When joining tables, When naming calculated columns, When writing age calculation conditions",
            "operation": " do not use unnecessary parentheses around the age comparison expression."
        },
        "615": {
            "condition": "When calculating percentages for conditional subsets",
            "operation": " move gender-specific filters like T1.SEX = 'F' into the CASE expression instead of keeping them as separate WHERE conditions to ensure accurate counting of both qualifying and total cases."
        },
        "616": {
            "condition": "When computing percentage calculations",
            "operation": " use the calculation order * 100 / COUNT(*) instead of / COUNT(*) * 100 to ensure proper percentage calculation."
        },
        "617": {
            "condition": "When calculating percentages for conditional subsets, When computing percentage calculations, When handling table aliases",
            "operation": " do not use explicit AS clauses for table aliases as they are functionally equivalent to simple aliases without AS."
        },
        "618": {
            "condition": "When answering about patients with laboratory results",
            "operation": " join \"Patient\" AS T1 with \"Laboratory\" AS T2 using T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "619": {
            "condition": "When the question asks for patients who first came after year 1992",
            "operation": " filter using STRFTIME('%Y', T1.\"First Date\") > '1992' to extract year from the date field."
        },
        "620": {
            "condition": "When the question mentions \"prothrombin time (PT) level that are normal\"",
            "operation": " use T2.PT < 14 as the numerical threshold for normal values."
        },
        "621": {
            "condition": "When answering about patients with laboratory results, When the question asks for patients who first came after year 1992, When the question mentions \"prothrombin time (PT) level that are normal\", When listing patients",
            "operation": " select only T1.ID instead of all columns."
        },
        "622": {
            "condition": "When counting patients from examinations",
            "operation": " use COUNT(T1.ID) from the Patient table instead of COUNT(*) from the examinations table."
        },
        "623": {
            "condition": "When combining Patient and Laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 using INNER JOIN on T1.ID = T2.ID to link patient records with their laboratory results."
        },
        "624": {
            "condition": "When filtering by date after January 1, 1997",
            "operation": " use T2.Date > '1997-01-01' with the exact date format 'YYYY-MM-DD' instead of '1997/1/1'."
        },
        "625": {
            "condition": "When counting patients from examinations, When combining Patient and Laboratory data, When filtering by date after January 1, 1997, When identifying inactivated partial prothrombin time results",
            "operation": " use the condition T2.APTT >= 45 instead of looking for the literal string 'inactivated partial prothrom bin time'."
        },
        "626": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patient IDs."
        },
        "627": {
            "condition": "When combining patient data with laboratory and examination information",
            "operation": " perform inner joins using Laboratory AS T2 ON T1.ID = T2.ID and Examination AS T3 ON T3.ID = T2.ID."
        },
        "628": {
            "condition": "When identifying abnormal activated partial prothrombin time",
            "operation": " use T2.APTT > 45 instead of checking for 'abnormal' text values."
        },
        "629": {
            "condition": "When counting patients, When combining patient data with laboratory and examination information, When identifying abnormal activated partial prothrombin time, When checking for absence of thrombosis",
            "operation": " use T3.Thrombosis = 0 instead of checking for NULL values."
        },
        "630": {
            "condition": "When the question asks about male patients",
            "operation": " use T1.SEX = 'M' to filter for male patients."
        },
        "631": {
            "condition": "When the question asks about normal white blood cell levels",
            "operation": " use T2.WBC > 3.5 AND T2.WBC < 9.0 to filter for normal white blood cell counts using numeric thresholds."
        },
        "632": {
            "condition": "When the question asks about abnormal fibrinogen levels",
            "operation": " use T2.FG <= 150 OR T2.FG >= 450 to filter for abnormal fibrinogen values using numeric ranges."
        },
        "633": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an INNER JOIN between patients table (T1) and Laboratory table (T2) using T1.ID = T2.ID to link patient records with their laboratory results."
        },
        "634": {
            "condition": "When the question asks about male patients, When the question asks about normal white blood cell levels, When the question asks about abnormal fibrinogen levels, When combining patient and laboratory data, When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows."
        },
        "635": {
            "condition": "When the question asks about male patients",
            "operation": " filter rows where T1.SEX equals exactly 'M'."
        },
        "636": {
            "condition": "When the question asks about normal white blood cell levels",
            "operation": " filter rows where T2.WBC is greater than 3.5 AND less than 9.0."
        },
        "637": {
            "condition": "When the question asks about abnormal fibrinogen levels",
            "operation": " filter rows where T2.FG is less than or equal to 150 OR greater than or equal to 450, and ensure this OR condition is properly grouped with parentheses."
        },
        "638": {
            "condition": "When counting distinct patients",
            "operation": " count the number of unique T1.ID values that satisfy all the specified conditions."
        },
        "639": {
            "condition": "When the question asks about male patients, When the question asks about normal white blood cell levels, When the question asks about abnormal fibrinogen levels, When counting distinct patients, When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID equals T2.ID using an inner join to keep only matching patient records."
        },
        "640": {
            "condition": "When the question asks about male patients",
            "operation": " filter rows where T1.SEX equals exactly 'M'."
        },
        "641": {
            "condition": "When the question asks about patients with normal white blood cells",
            "operation": " filter rows where T2.WBC is greater than 3.5 and less than 9.0."
        },
        "642": {
            "condition": "When the question asks about abnormal fibrinogen level",
            "operation": " filter rows where T2.FG is less than or equal to 150 or greater than or equal to 450, and use parentheses to properly group this OR condition."
        },
        "643": {
            "condition": "When counting distinct male patients",
            "operation": " count the number of unique T1.ID values that satisfy all the specified conditions."
        },
        "644": {
            "condition": "When the question asks about male patients, When the question asks about patients with normal white blood cells, When the question asks about abnormal fibrinogen level, When counting distinct male patients, When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID equals T2.ID and keep only matching pairs (inner join)."
        },
        "645": {
            "condition": "When the question asks about male patients",
            "operation": " filter rows where T1.SEX equals exactly 'M'."
        },
        "646": {
            "condition": "When the question mentions \"normal level of white blood cells\"",
            "operation": " filter rows where T2.WBC is greater than 3.5 and less than 9.0."
        },
        "647": {
            "condition": "When the question asks about \"abnormal fibrinogen level\"",
            "operation": " filter rows where T2.FG is less than or equal to 150 OR T2.FG is greater than or equal to 450, and ensure this condition is properly grouped with parentheses."
        },
        "648": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID equals T2.ID using an inner match."
        },
        "649": {
            "condition": "When the question asks about male patients, When the question mentions \"normal level of white blood cells\", When the question asks about \"abnormal fibrinogen level\", When combining Patient and Laboratory tables, When counting distinct male patients",
            "operation": " count the number of unique T1.ID values that satisfy all the specified conditions."
        },
        "650": {
            "condition": "When answering about male patients with normal white blood cells and abnormal fibrinogen levels",
            "operation": " make sure the output order is COUNT(DISTINCT T1.ID)"
        },
        "651": {
            "condition": "When the question mentions \"male patients\"",
            "operation": " \"male\" actually means T1.SEX = 'M' in schema"
        },
        "652": {
            "condition": "When the question mentions \"normal level of white blood cells\"",
            "operation": " \"normal\" actually means T2.WBC > 3.5 AND T2.WBC < 9.0 in schema"
        },
        "653": {
            "condition": "When the question mentions \"abnormal fibrinogen level\"",
            "operation": " \"abnormal\" actually means T2.FG <= 150 OR T2.FG >= 450 in schema"
        },
        "654": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "655": {
            "condition": "When answering about male patients with normal white blood cells and abnormal fibrinogen levels, When the question mentions \"male patients\", When the question mentions \"normal level of white blood cells\", When the question mentions \"abnormal fibrinogen level\", When combining Patient and Laboratory tables, When counting distinct patients",
            "operation": " compute the number of unique values of T1.ID"
        },
        "656": {
            "condition": "When counting distinct patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count unique patient IDs."
        },
        "657": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using an inner join."
        },
        "658": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' with exact literal 'M'."
        },
        "659": {
            "condition": "When identifying normal white blood cell levels",
            "operation": " use T2.WBC > 3.5 AND T2.WBC < 9.0 with the exact numeric bounds."
        },
        "660": {
            "condition": "When identifying abnormal fibrinogen levels",
            "operation": " use T2.FG <= 150 OR T2.FG >= 450 with the exact numeric bounds and OR operator without parentheses."
        },
        "661": {
            "condition": "When ordering conditions",
            "operation": " place the fibrinogen condition (T2.FG <= 150 OR T2.FG >="
        },
        "662": {
            "condition": "When counting distinct patients, When combining Patient and Laboratory tables, When filtering for male patients, When identifying normal white blood cell levels, When identifying abnormal fibrinogen levels, When ordering conditions, before other filter conditions in the WHERE clause.",
            "operation": "When counting distinct patients, When combining Patient and Laboratory tables, When filtering for male patients, When identifying normal white blood cell levels, When identifying abnormal fibrinogen levels, When ordering conditions, before other filter conditions in the WHERE clause."
        },
        "663": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows."
        },
        "664": {
            "condition": "When incorporating laboratory data",
            "operation": " add an INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to link patient and laboratory information."
        },
        "665": {
            "condition": "When identifying abnormal fibrinogen levels",
            "operation": " use T2.FG <= 150 OR T2.FG >= 450 instead of categorical values to apply numeric thresholds."
        },
        "666": {
            "condition": "When filtering by birth date",
            "operation": " use T1.Birthday > '1980-01-01' with the exact column name from the patients table."
        },
        "667": {
            "condition": "When counting patients, When incorporating laboratory data, When identifying abnormal fibrinogen levels, When filtering by birth date, When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "668": {
            "condition": "When combining Patient table (T1) and Laboratory table (T2)",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "669": {
            "condition": "When counting distinct patients",
            "operation": " compute the number of unique values of T1.ID."
        },
        "670": {
            "condition": "When filtering for patients born after 1980/1/1",
            "operation": " use the condition T1.Birthday > '1980-01-01'."
        },
        "671": {
            "condition": "When filtering for abnormal fibrinogen levels",
            "operation": " use the condition T2.FG <= 150 OR T2.FG >= 450 without parentheses."
        },
        "672": {
            "condition": "When combining Patient table (T1) and Laboratory table (T2), When counting distinct patients, When filtering for patients born after 1980/1/1, When filtering for abnormal fibrinogen levels, When ordering WHERE clause conditions",
            "operation": " place the T1.Birthday > '1980-01-01' filter at the end of the WHERE clause."
        },
        "673": {
            "condition": "When the question asks for patients born after 1980/1/1",
            "operation": " use the condition T1.Birthday > '1980-01-01' exactly as specified."
        },
        "674": {
            "condition": "When the question asks for abnormal fibrinogen level",
            "operation": " use the condition T2.FG <= 150 OR T2.FG >= 450 without parentheses to ensure proper operator precedence with AND conditions."
        },
        "675": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using an inner match."
        },
        "676": {
            "condition": "When the question asks for patients born after 1980/1/1, When the question asks for abnormal fibrinogen level, When combining Patient and Laboratory tables, When counting distinct patients",
            "operation": " count distinct values of T1.ID as the canonical patient identifier."
        },
        "677": {
            "condition": "When the question asks for \"disease names\"",
            "operation": " use the exact column \"Diagnosis\" from table \"Patient\" (aliased as T1) instead of \"disease_name\" from \"patients\"."
        },
        "678": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID using an inner join between tables \"Patient\" (T1) and \"Laboratory\" (T2)."
        },
        "679": {
            "condition": "When filtering for proteinuria level higher than normal",
            "operation": " use the condition T2.\"U-PRO\" >= 30 instead of proteinuria_level > 100."
        },
        "680": {
            "condition": "When the question asks for \"disease names\", When combining patient and laboratory data, When filtering for proteinuria level higher than normal, When answering about disease names of patients with abnormal proteinuria",
            "operation": " make sure the output order: Diagnosis."
        },
        "681": {
            "condition": "When answering about patients with normal proteinuria level and SLE diagnosis",
            "operation": " select DISTINCT T1.ID instead of patient_id without distinct."
        },
        "682": {
            "condition": "When combining patient and laboratory data",
            "operation": " use INNER JOIN on Laboratory AS T2 with T1.ID = T2.ID instead of querying only the patients table."
        },
        "683": {
            "condition": "When filtering for normal proteinuria level",
            "operation": " use T2.U-PRO > 0 AND T2.U-PRO < 30 instead of proteinuria_level = 'normal'."
        },
        "684": {
            "condition": "When answering about patients with normal proteinuria level and SLE diagnosis, When combining patient and laboratory data, When filtering for normal proteinuria level, When filtering for SLE diagnosis",
            "operation": " keep T1.Diagnosis = 'SLE' but reference it through the joined table alias instead of directly from the base table."
        },
        "685": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows."
        },
        "686": {
            "condition": "When answering about patients with IgG levels",
            "operation": " incorporate data from Laboratory table as T2 and Examination table as T3 using INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID and INNER JOIN Examination AS T3 ON T3.ID = T2.ID."
        },
        "687": {
            "condition": "When checking for IgG higher than normal",
            "operation": " use T2.IGG >= 2000 with the specific numeric threshold of 2000 instead of undefined references."
        },
        "688": {
            "condition": "When counting patients, When answering about patients with IgG levels, When checking for IgG higher than normal, When combining patient, laboratory, and examination data",
            "operation": " link rows where T1.ID = T2.ID and T3.ID = T2.ID to keep only matching patient records across all three tables."
        },
        "689": {
            "condition": "When answering about patients with normal Ig G level",
            "operation": " use numeric range checking with T2.IGG BETWEEN 900 AND 2000 instead of string matching."
        },
        "690": {
            "condition": "When counting patients with symptoms",
            "operation": " count using T1.ID as the canonical key instead of COUNT(*)."
        },
        "691": {
            "condition": "When combining patient data",
            "operation": " link Laboratory table as T2 using T1.ID = T2.ID and Examination table as T3 using T3.ID = T2.ID with inner joins."
        },
        "692": {
            "condition": "When answering about patients with normal Ig G level, When counting patients with symptoms, When combining patient data, When checking for symptoms",
            "operation": " reference T3.Symptoms IS NOT NULL from the Examination table instead of a symptoms column in the patients table."
        },
        "693": {
            "condition": "When answering about \"the patient who has the highest Ig A within the normal range\"",
            "operation": " make sure the output order: patientData.Diagnosis."
        },
        "694": {
            "condition": "When the question mentions \"highest Ig A within the normal range\"",
            "operation": " filter rows where labData.IGA is between 80 AND 500 inclusive, then order by labData.IGA in descending direction and keep only the first 1 row."
        },
        "695": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where patientData.ID = labData.ID exactly and keep only matching pairs (inner match)."
        },
        "696": {
            "condition": "When answering about \"the patient who has the highest Ig A within the normal range\", When the question mentions \"highest Ig A within the normal range\", When combining Patient and Laboratory tables, When selecting diagnosis information",
            "operation": " use patientData.Diagnosis from the Patient table instead of diagnosis from patients table."
        },
        "697": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "698": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 and Laboratory AS T2 using INNER JOIN on T1.ID = T2.ID to link patient records with their laboratory results."
        },
        "699": {
            "condition": "When filtering for normal IgA levels",
            "operation": " use T2.IGA BETWEEN 80 AND 500 for numeric range checking instead of string comparison with 'normal'."
        },
        "700": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for normal IgA levels, When filtering for visits after 1990/1/1",
            "operation": " use strftime('%Y', T1.First Date) > '1990' to extract the year from the date field and compare it numerically instead of direct date string comparison."
        },
        "701": {
            "condition": "When answering about \"most common disease for patients with abnormal Ig M level\"",
            "operation": " make sure the output order: T1.Diagnosis first, then count of T1.Diagnosis."
        },
        "702": {
            "condition": "When the question mentions \"patients with an abnormal Ig M level\"",
            "operation": " \"abnormal\" actually means \"T2.IGM NOT BETWEEN 40 AND 400\" in the schema."
        },
        "703": {
            "condition": "When combining Patient AS T1 and Laboratory AS T2 for shared patients",
            "operation": " link rows where T1.ID = T2.ID exactly and keep only matching pairs (inner match)."
        },
        "704": {
            "condition": "When the question asks for \"count of diseases\"",
            "operation": " compute the number of rows using T1.Diagnosis as the counting key."
        },
        "705": {
            "condition": "When answering about \"most common disease for patients with abnormal Ig M level\", When the question mentions \"patients with an abnormal Ig M level\", When combining Patient AS T1 and Laboratory AS T2 for shared patients, When the question asks for \"count of diseases\", When the question asks for \"most common disease\"",
            "operation": " rank rows by count of T1.Diagnosis in descending order and keep the first 1 row."
        },
        "706": {
            "condition": "When answering about \"most common disease for patients with abnormal Ig M level\"",
            "operation": " make sure the output order: only include T1.Diagnosis in the final output without any count columns."
        },
        "707": {
            "condition": "When the question mentions \"abnormal Ig M level\"",
            "operation": " \"abnormal\" actually means \"T2.IGM NOT BETWEEN 40 AND 400\" in the schema."
        },
        "708": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "709": {
            "condition": "When the question asks for \"most common disease\"",
            "operation": " group results by T1.Diagnosis, count the number of patients per diagnosis using the canonical key, rank diagnoses by count in descending order, and keep only the top 1 result."
        },
        "710": {
            "condition": "When answering about \"most common disease for patients with abnormal Ig M level\", When the question mentions \"abnormal Ig M level\", When combining Patient (T1) and Laboratory (T2) tables, When the question asks for \"most common disease\", When counting patients per diagnosis",
            "operation": " use the canonical patient identifier (T1.ID) for counting, not the diagnosis field itself."
        },
        "711": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "712": {
            "condition": "When querying patient and laboratory data",
            "operation": " use table aliases Patient AS T1 and Laboratory AS T2 with explicit sources instead of a single patients table."
        },
        "713": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an inner join where T1.ID = T2.ID to link patient records with their laboratory results."
        },
        "714": {
            "condition": "When filtering for abnormal C-reactive protein values",
            "operation": " check T2.CRP = '+' instead of c_reactive_protein = 'abnormal'."
        },
        "715": {
            "condition": "When counting patients, When querying patient and laboratory data, When combining patient and laboratory data, When filtering for abnormal C-reactive protein values, When checking for missing data recording",
            "operation": " verify T1.Description IS NULL instead of data_recorded IS NULL."
        },
        "716": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patient IDs."
        },
        "717": {
            "condition": "When incorporating laboratory data",
            "operation": " add INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to combine patient and laboratory information."
        },
        "718": {
            "condition": "When filtering for abnormal creatinine levels",
            "operation": " use T2.CRE >= 1.5 instead of text-based comparison to apply the specific numeric threshold."
        },
        "719": {
            "condition": "When counting patients, When incorporating laboratory data, When filtering for abnormal creatinine levels, When calculating age from birthdate",
            "operation": " use STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70 to properly compute current age and filter for patients under 70 years old."
        },
        "720": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count distinct patients rather than all test records."
        },
        "721": {
            "condition": "When referencing tables",
            "operation": " use Patient AS T1, Laboratory AS T2, and Examination AS T3 as the canonical table aliases."
        },
        "722": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " use INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to link rows where the ID values match exactly."
        },
        "723": {
            "condition": "When joining Laboratory and Examination tables",
            "operation": " use INNER JOIN Examination AS T3 ON T3.ID = T2.ID to link rows where the ID values match exactly."
        },
        "724": {
            "condition": "When checking for normal rheumatoid factor",
            "operation": " use (T2.RA = '-' OR T2.RA = '+-') instead of checking for 'normal' value."
        },
        "725": {
            "condition": "When counting patients, When referencing tables, When joining Patient and Laboratory tables, When joining Laboratory and Examination tables, When checking for normal rheumatoid factor, When checking for positive coagulation degree",
            "operation": " use T3.KCT = '+' instead of checking for 'positive' value."
        },
        "726": {
            "condition": "When answering about \"diseases of patients\"",
            "operation": " make sure the output column is T1.Diagnosis instead of disease."
        },
        "727": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "728": {
            "condition": "When filtering for patients born after 1985-1-1",
            "operation": " apply the condition T1.birth_date > '1985-01-01'."
        },
        "729": {
            "condition": "When answering about \"diseases of patients\", When combining patient and laboratory data, When filtering for patients born after 1985-1-1, When filtering for normal Rheumatoid Factor",
            "operation": " use the condition (T2.RA = '-' OR T2.RA = '+-') instead of rheumatoid_factor = 'normal'."
        },
        "730": {
            "condition": "When selecting patient identification",
            "operation": " use \"T1.ID\" instead of \"patient_id\" as the output column."
        },
        "731": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where \"T1.ID = T2.ID\" using an inner match between Patient table (T1) and Laboratory table (T2)."
        },
        "732": {
            "condition": "When filtering for normal RF values",
            "operation": " use numeric comparison \"T2.RF < 20\" instead of string comparison with 'normal'."
        },
        "733": {
            "condition": "When selecting patient identification, When combining patient and laboratory data, When filtering for normal RF values, When calculating age for patients older than 60",
            "operation": " compute age dynamically using \"STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', T1.Birthday) > 60\" instead of relying on a static age column."
        },
        "734": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows."
        },
        "735": {
            "condition": "When combining examination and laboratory data",
            "operation": " link rows where T1.ID = T2.ID using an inner match between Examination AS T1 and Laboratory AS T2."
        },
        "736": {
            "condition": "When identifying patients with normal RF",
            "operation": " filter with T2.RF < 20 to use a numeric threshold comparison rather than string matching."
        },
        "737": {
            "condition": "When counting patients, When combining examination and laboratory data, When identifying patients with normal RF, When identifying patients without thrombosis",
            "operation": " filter with T1.Thrombosis = 0 to use a numeric boolean representation instead of string values."
        },
        "738": {
            "condition": "When counting patients",
            "operation": " count distinct T1.ID values instead of all records to ensure each patient is counted only once."
        },
        "739": {
            "condition": "When joining with laboratory data",
            "operation": " use INNER JOIN with Laboratory table as T2 instead of ana_examination table."
        },
        "740": {
            "condition": "When linking patient records",
            "operation": " match rows where T1.ID = T2.ID to connect Examination and Laboratory tables."
        },
        "741": {
            "condition": "When filtering for normal complement 3 levels",
            "operation": " use T2.C3 > 35 instead of checking for 'normal' text values."
        },
        "742": {
            "condition": "When counting patients, When joining with laboratory data, When linking patient records, When filtering for normal complement 3 levels, When filtering for P pattern in ANA examination",
            "operation": " use T1.\"ANA Pattern\" = 'P' from the Examination table."
        },
        "743": {
            "condition": "When answering about patients with abnormal hematocrit levels",
            "operation": " use numeric range checks (T3.HCT >= 52 OR T3.HCT <="
        },
        "744": {
            "condition": "instead of string comparison with 'normal'.",
            "operation": "instead of string comparison with 'normal'."
        },
        "745": {
            "condition": "When combining patient data with examination and laboratory results",
            "operation": " join Patients as T1 with Examination as T2 on T1.ID = T2.ID and with Laboratory as T3 on T1.ID = T3.ID using inner matches."
        },
        "746": {
            "condition": "When ordering by anti-Cardiolipin antibody concentration",
            "operation": " use T2.\"aCL IgA\" DESC to reference the correct column from the joined Examination table."
        },
        "747": {
            "condition": "When selecting patient identification",
            "operation": " use DISTINCT T1.ID instead of Patient_ID to ensure unique patient identifiers."
        },
        "748": {
            "condition": "When answering about patients with abnormal hematocrit levels, instead of string comparison with 'normal'., When combining patient data with examination and laboratory results, When ordering by anti-Cardiolipin antibody concentration, When selecting patient identification, When the question asks for the highest value",
            "operation": " order by the measurement column in descending direction and take the first result."
        },
        "749": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patients."
        },
        "750": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using inner match."
        },
        "751": {
            "condition": "When filtering for complement 4 level",
            "operation": " use T2.C4 > 10 for numeric comparison instead of text-based 'normal' value."
        },
        "752": {
            "condition": "When identifying APS patients",
            "operation": " include condition T1.Diagnosis = 'APS' to filter for antiphospholipid syndrome patients."
        },
        "753": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for complement 4 level, When identifying APS patients, When the question mentions \"blood clots in veins\"",
            "operation": " this condition is already implied by T1.Diagnosis = 'APS' and should not be added as a separate filter."
        },
        "754": {
            "condition": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;",
            "operation": "normal level of anti-ribonuclear protein refers to RNP = '-', '+-'; And'-' means 'negative'; '+-' refers to '0'; admitted to the hospital refers to Admission = '+'; Should consider DISTINCT in the final result;"
        },
        "755": {
            "condition": "When answering about the youngest patient with an abnormal anti-ribonuclear protein level",
            "operation": " make sure the output order is T1.Birthday."
        },
        "756": {
            "condition": "When the question mentions \"date of birth\"",
            "operation": " \"date of birth\" actually means \"T1.Birthday\" in schema."
        },
        "757": {
            "condition": "When the question mentions \"youngest\"",
            "operation": " rank rows by T1.Birthday in descending order and keep the first 1 row."
        },
        "758": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.ID = T2.ID exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "759": {
            "condition": "When answering about the youngest patient with an abnormal anti-ribonuclear protein level, When the question mentions \"date of birth\", When the question mentions \"youngest\", When combining T1 and T2 for shared entities, When filtering for abnormal anti-ribonuclear protein level",
            "operation": " filter with T2.RNP != '-' OR '+-' to properly handle the laboratory result values."
        },
        "760": {
            "condition": "When answering about patients with normal anti-SM",
            "operation": " use \"T2.SM IN ('negative','0')\" instead of \"anti_sm = 'normal'\" to identify normal anti-SM status."
        },
        "761": {
            "condition": "When counting patients who do not have thrombosis",
            "operation": " use \"T1.Thrombosis = 0\" instead of checking for NULL values."
        },
        "762": {
            "condition": "When combining examination and laboratory data",
            "operation": " perform an inner join between \"Examination AS T1\" and \"Laboratory AS T2\" using \"T1.ID = T2.ID\" to link patient records."
        },
        "763": {
            "condition": "When answering about patients with normal anti-SM, When counting patients who do not have thrombosis, When combining examination and laboratory data, When counting patients",
            "operation": " use \"COUNT(T1.ID)\" instead of \"COUNT(*)\" to count based on the patient identifier key."
        },
        "764": {
            "condition": "When selecting patient IDs",
            "operation": " use \"T1.ID\" instead of \"patient_id\" and include table aliases."
        },
        "765": {
            "condition": "When querying patients with abnormal anti-SM",
            "operation": " join \"Patient AS T1\" with \"Laboratory AS T2\" on \"T1.ID = T2.ID\" instead of querying only the patients table."
        },
        "766": {
            "condition": "When filtering for abnormal SM results",
            "operation": " use \"T2.SM NOT IN ('negative','0')\" instead of checking for 'abnormal' to exclude negative and zero values."
        },
        "767": {
            "condition": "When selecting patient IDs, When querying patients with abnormal anti-SM, When filtering for abnormal SM results, When ordering by age to find youngest patients",
            "operation": " use \"T1.Birthday DESC\" instead of ascending order to get the three youngest patients."
        },
        "768": {
            "condition": "When answering about patients with specific laboratory tests",
            "operation": " select \"T1\".\"ID\" from the \"Patient\" table instead of patient_id from examinations."
        },
        "769": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where \"T1\".\"ID\" = \"T2\".\"ID\" using an inner join between \"Patient\" as T1 and \"Laboratory\" as T2."
        },
        "770": {
            "condition": "When filtering for normal anti-scl70 results",
            "operation": " use \"T2\".\"SC170\" IN ('negative','0') instead of anti_scl70 = 'normal'."
        },
        "771": {
            "condition": "When answering about patients with specific laboratory tests, When combining patient and laboratory data, When filtering for normal anti-scl70 results, When filtering for dates after 1997/1/1",
            "operation": " use \"T2\".\"Date\" > 1997-01-01 (without quotes around the date value) instead of exam_date > '1997-01-01'."
        },
        "772": {
            "condition": "When counting patients",
            "operation": " count distinct T1.ID values instead of all records to get unique patient counts."
        },
        "773": {
            "condition": "When combining Laboratory and Examination tables",
            "operation": " use INNER JOIN on T1.ID = T2.ID and T3.ID = T2.ID to properly link all three tables."
        },
        "774": {
            "condition": "When checking for normal anti-scl70 results",
            "operation": " use (T2.SC170 = 'negative' OR T2.SC170 = '0') instead of test_name and result conditions to match the correct column and values."
        },
        "775": {
            "condition": "When filtering for female patients",
            "operation": " use T1.SEX = 'F' instead of gender = 'female' with the correct column name and value format."
        },
        "776": {
            "condition": "When counting patients, When combining Laboratory and Examination tables, When checking for normal anti-scl70 results, When filtering for female patients, When checking for absence of symptoms",
            "operation": " use T3.Symptoms IS NULL instead of symptom_count = 0 to properly detect missing symptom records."
        },
        "777": {
            "condition": "When counting patients",
            "operation": " count distinct T1.ID values instead of all rows to get unique patient counts."
        },
        "778": {
            "condition": "When the question mentions \"normal anti-SSA\"",
            "operation": " this actually means T2.SSA IN ('negative', '0') in the laboratory test results."
        },
        "779": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "780": {
            "condition": "When counting patients, When the question mentions \"normal anti-SSA\", When combining patient and laboratory data, When filtering by year before 2000",
            "operation": " use STRFTIME('%Y', T2.Date) < '2000' to extract the year component from the date field."
        },
        "781": {
            "condition": "When answering about \"first patient with an abnormal anti-SSA\"",
            "operation": " make sure the output order: T1.ID."
        },
        "782": {
            "condition": "When the question mentions \"patient ID\"",
            "operation": " \"patient_id\" actually means \"T1.ID in schema\"."
        },
        "783": {
            "condition": "When combining Patient as T1 and Laboratory as T2 for shared entities",
            "operation": " link rows where T1.ID = T2.ID exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "784": {
            "condition": "When filtering for patients who came to the hospital",
            "operation": " include only rows where T1.First Date IS NOT NULL."
        },
        "785": {
            "condition": "When filtering for abnormal anti-SSA",
            "operation": " include only rows where T2.SSA NOT IN ('negative', '0') instead of using 'abnormal' literal."
        },
        "786": {
            "condition": "When answering about \"first patient with an abnormal anti-SSA\", When the question mentions \"patient ID\", When combining Patient as T1 and Laboratory as T2 for shared entities, When filtering for patients who came to the hospital, When filtering for abnormal anti-SSA, When the question asks for \"first patient\"",
            "operation": " order rows by T1.First Date ASC and keep the first 1 row."
        },
        "787": {
            "condition": "When the question asks for the first patient by date",
            "operation": " order results by the exact column \"First Date\" in ascending order and take only the first row."
        },
        "788": {
            "condition": "When the question mentions \"abnormal anti-SSA\"",
            "operation": " filter Laboratory results where the exact column \"SSA\" is not in the literal values 'negative' or '0'."
        },
        "789": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where the exact column \"ID\" from both tables are equal using an inner match."
        },
        "790": {
            "condition": "When handling column names with spaces",
            "operation": " use backticks to quote the exact column name `First Date` as shown in the schema."
        },
        "791": {
            "condition": "When the question asks for the first patient by date, When the question mentions \"abnormal anti-SSA\", When combining Patient and Laboratory tables, When handling column names with spaces, When selecting output",
            "operation": " return only the exact column `T1.ID` from the Patient table."
        },
        "792": {
            "condition": "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones",
            "operation": "normal anti-SSB refers to SSB IN('-', '+-'); '-' is expressed as 'negative' and '+-' is expressed as '0' in the database ; diagnosed with SLE refers to Diagnosis = 'SLE'; Should compute the number of distinct ones"
        },
        "793": {
            "condition": "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones",
            "operation": "anti-SSB are normal refers to SSB IN ('negative', '0'); have other symptoms refers to Symptoms IS NOT NULL; Should compute the number of distinct ones"
        },
        "794": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patients."
        },
        "795": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "796": {
            "condition": "When filtering for normal anti-centromere levels",
            "operation": " check T2.CENTROMEA IN ('negative', '0') instead of anti_centromere = 'normal'."
        },
        "797": {
            "condition": "When filtering for normal anti-SSB levels",
            "operation": " check T2.SSB IN ('negative', '0') instead of anti_ssb = 'normal'."
        },
        "798": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for normal anti-centromere levels, When filtering for normal anti-SSB levels, When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male' with the correct column name and value format."
        },
        "799": {
            "condition": "When answering about \"diseases diagnosed with abnormal anti-DNA level\"",
            "operation": " make sure the output order: T1.Diagnosis"
        },
        "800": {
            "condition": "When the question mentions \"diseases they are diagnosed with\"",
            "operation": " \"diseases\" actually means \"T1.Diagnosis in schema\""
        },
        "801": {
            "condition": "When retrieving diagnosis values",
            "operation": " select distinct T1.Diagnosis to get unique values"
        },
        "802": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "803": {
            "condition": "When filtering for abnormal anti-DNA level",
            "operation": " use T2.DNA >= 8 as the threshold condition"
        },
        "804": {
            "condition": "When answering about \"diseases diagnosed with abnormal anti-DNA level\", When the question mentions \"diseases they are diagnosed with\", When retrieving diagnosis values, When combining Patient and Laboratory tables, When filtering for abnormal anti-DNA level, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for numeric threshold values"
        },
        "805": {
            "condition": "When counting patients",
            "operation": " use COUNT(DISTINCT T1.ID) to count distinct patient IDs rather than all rows."
        },
        "806": {
            "condition": "When combining patient and laboratory data",
            "operation": " use INNER JOIN between patients as T1 and Laboratory as T2 where T1.ID = T2.ID to incorporate laboratory data."
        },
        "807": {
            "condition": "When filtering for normal anti-DNA level",
            "operation": " use T2.DNA < 8 instead of string comparison to apply the numeric threshold for normal DNA levels."
        },
        "808": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for normal anti-DNA level, When checking for unrecorded data",
            "operation": " use T1.Description IS NULL to reference the correct column for null description values indicating unrecorded data."
        },
        "809": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "810": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using exact key equality and keep only matching pairs (inner match)."
        },
        "811": {
            "condition": "When filtering for normal IgG levels",
            "operation": " use T2.IGG > 900 AND T2.IGG < 2000 for numeric range instead of string comparison with 'normal'."
        },
        "812": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for normal IgG levels, When filtering for hospital admission status",
            "operation": " use T1.Admission = '+' instead of admitted = 'yes' with the exact column name and value format."
        },
        "813": {
            "condition": "When calculating percentages for patient conditions",
            "operation": " use simple division instead of multiplying by 100.0."
        },
        "814": {
            "condition": "When joining patient and laboratory data",
            "operation": " use INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to combine tables."
        },
        "815": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) as the counting key instead of CASE statements."
        },
        "816": {
            "condition": "When filtering for SLE diagnosis",
            "operation": " use T1.Diagnosis LIKE '%SLE%' instead of exact match 'SLE'."
        },
        "817": {
            "condition": "When identifying abnormal glutamic oxaloacetic transaminase levels",
            "operation": " use T2.\"GOT\" >= 60 instead of checking for 'normal' values."
        },
        "818": {
            "condition": "When calculating percentages for patient conditions, When joining patient and laboratory data, When counting patients, When filtering for SLE diagnosis, When identifying abnormal glutamic oxaloacetic transaminase levels, When referencing columns across joined tables",
            "operation": " use table aliases T1 and T2 instead of direct column references."
        },
        "819": {
            "condition": "When the question asks for percentage of patients with abnormal GOT levels who are diagnosed with SLE",
            "operation": " use conditional counting where T1.Diagnosis contains 'SLE' and T2.\"GOT\" >= 60."
        },
        "820": {
            "condition": "When filtering for abnormal glutamic oxaloacetic transaminase levels",
            "operation": " use T2.\"GOT\" >= 60 as the threshold condition."
        },
        "821": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "822": {
            "condition": "When calculating percentage",
            "operation": " compute (count of patients meeting both conditions) divided by (count of all SLE patients) without explicit type casting."
        },
        "823": {
            "condition": "When the question asks for percentage of patients with abnormal GOT levels who are diagnosed with SLE, When filtering for abnormal glutamic oxaloacetic transaminase levels, When combining Patient (T1) and Laboratory (T2) tables, When calculating percentage, When handling SLE diagnosis",
            "operation": " use T1.Diagnosis LIKE '%SLE%' as the diagnostic condition."
        },
        "824": {
            "condition": "When the question asks for percentage of patients with abnormal GOT levels diagnosed with SLE",
            "operation": " calculate the ratio of patients with SLE diagnosis among those with GOT \u2265 60 using exact column names and literals."
        },
        "825": {
            "condition": "When counting patients with specific conditions",
            "operation": " use CASE expressions with ELSE 0 to ensure proper counting when conditions are not met."
        },
        "826": {
            "condition": "When performing division between counts",
            "operation": " use standard integer division without multiplication by 1.0 to get correct decimal results."
        },
        "827": {
            "condition": "When referencing the GOT column",
            "operation": " use backticks around `GOT` to handle potential reserved keyword conflicts."
        },
        "828": {
            "condition": "When the question asks for percentage of patients with abnormal GOT levels diagnosed with SLE, When counting patients with specific conditions, When performing division between counts, When referencing the GOT column, When determining abnormal glutamic oxaloacetic transaminase levels",
            "operation": " use the threshold value of 60 for the `GOT` column as specified in the condition."
        },
        "829": {
            "condition": "When answering about \"male patients with glutamic oxaloacetic transaminase in normal range\"",
            "operation": " use table \"Patient\" as T1 and join with table \"Laboratory\" as T2 on T1.ID = T2.ID."
        },
        "830": {
            "condition": "When counting patients",
            "operation": " count T1.ID instead of all rows for precise counting."
        },
        "831": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male'."
        },
        "832": {
            "condition": "When answering about \"male patients with glutamic oxaloacetic transaminase in normal range\", When counting patients, When filtering for male patients, When filtering for glutamic oxaloacetic transaminase levels",
            "operation": " use T2.GOT < 60 instead of glutamic_oxaloacetic_transaminase > 50 with the correct column name and inequality direction."
        },
        "833": {
            "condition": "When answering about patients with abnormal glutamic oxaloacetic transaminase levels",
            "operation": " use numeric comparison T2.GOT >= 60 instead of string matching."
        },
        "834": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID using inner join."
        },
        "835": {
            "condition": "When finding the youngest patient",
            "operation": " order by T1.Birthday in descending order and take the first result."
        },
        "836": {
            "condition": "When answering about patients with abnormal glutamic oxaloacetic transaminase levels, When combining patient and laboratory data, When finding the youngest patient, When selecting the birth date",
            "operation": " use T1.Birthday directly without aggregation functions."
        },
        "837": {
            "condition": "When answering about patients' birthdays with highest glutamic pylvic transaminase",
            "operation": " make sure the output order: T1.Birthday"
        },
        "838": {
            "condition": "When the question mentions \"glutamic pylvic transaminase\"",
            "operation": " \"glutamic pylvic transaminase\" actually means \"GPT in schema\" from table T2"
        },
        "839": {
            "condition": "When the question mentions \"top three\" and \"highest\"",
            "operation": " rank rows by T2.GPT in descending direction and keep the first 3 rows"
        },
        "840": {
            "condition": "When the question mentions \"normal range\"",
            "operation": " use the condition T2.GPT < 60 to filter for values in the normal range"
        },
        "841": {
            "condition": "When combining patients table T1 and Laboratory table T2",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "842": {
            "condition": "When answering about patients' birthdays with highest glutamic pylvic transaminase, When the question mentions \"glutamic pylvic transaminase\", When the question mentions \"top three\" and \"highest\", When the question mentions \"normal range\", When combining patients table T1 and Laboratory table T2, When selecting patient birthday",
            "operation": " use T1.Birthday from the base table instead of unqualified birthday"
        },
        "843": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs."
        },
        "844": {
            "condition": "When combining patient and laboratory data",
            "operation": " use tables Patient AS T1 and Laboratory AS T2 with an INNER JOIN on T1.ID = T2.ID to connect patient records with laboratory results."
        },
        "845": {
            "condition": "When filtering for normal glutamic oxaloacetic transaminase levels",
            "operation": " use T2.GOT < 60 instead of text comparison to apply the correct numeric threshold."
        },
        "846": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for normal glutamic oxaloacetic transaminase levels, When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male' to use the proper column name and value format."
        },
        "847": {
            "condition": "When answering about the patient with the highest lactate dehydrogenase in the normal range",
            "operation": " use T1 as alias for Patient table and T2 as alias for Laboratory table."
        },
        "848": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using inner join and keep only matching pairs."
        },
        "849": {
            "condition": "When filtering for lactate dehydrogenase in normal range",
            "operation": " use T2.LDH < 500 instead of lactate_dehydrogenase <= 250."
        },
        "850": {
            "condition": "When finding the highest value within the normal range",
            "operation": " order by T2.LDH ASC and take the first row using LIMIT 1."
        },
        "851": {
            "condition": "When retrieving the first recorded date",
            "operation": " select T1.First Date instead of MIN(record_date)."
        },
        "852": {
            "condition": "When answering about the patient with the highest lactate dehydrogenase in the normal range, When combining Patient and Laboratory tables, When filtering for lactate dehydrogenase in normal range, When finding the highest value within the normal range, When retrieving the first recorded date, When handling identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for any table or column names."
        },
        "853": {
            "condition": "When answering about \"latest patient's medical data recorded\"",
            "operation": " make sure the output order: T1.\"First Date\""
        },
        "854": {
            "condition": "When the question mentions \"patient's medical data\"",
            "operation": " combine Patient as T1 and Laboratory as T2 using inner match where T1.ID = T2.ID"
        },
        "855": {
            "condition": "When the question mentions \"abnormal level of lactate dehydrogenase\"",
            "operation": " filter with T2.LDH >= 500"
        },
        "856": {
            "condition": "When answering about \"latest patient's medical data recorded\", When the question mentions \"patient's medical data\", When the question mentions \"abnormal level of lactate dehydrogenase\", When the question asks for \"latest\"",
            "operation": " order by T1.\"First Date\" DESC and take the first row"
        },
        "857": {
            "condition": "When answering about patients with abnormal alkaline phosphatase levels",
            "operation": " join the Patient table (T1) and Laboratory table (T2) using an inner match where T1.ID equals T2.ID."
        },
        "858": {
            "condition": "When filtering for abnormal alkaline phosphatase levels",
            "operation": " use the condition T2.ALP >= 300 instead of text comparisons."
        },
        "859": {
            "condition": "When filtering for hospital admission status",
            "operation": " use the condition T1.Admission = '+' instead of text values like 'admitted'."
        },
        "860": {
            "condition": "When answering about patients with abnormal alkaline phosphatase levels, When filtering for abnormal alkaline phosphatase levels, When filtering for hospital admission status, When counting patients",
            "operation": " count the specific column T1.ID instead of using a generic count of all rows."
        },
        "861": {
            "condition": "When counting patients with abnormal alkaline phosphatase levels who are admitted",
            "operation": " count all patient IDs from T1 without deduplication since the join condition already ensures uniqueness."
        },
        "862": {
            "condition": "When combining Patient (T1) and Laboratory (T2) tables",
            "operation": " link rows where T1.ID = T2.ID using an inner match to ensure only patients with lab results are included."
        },
        "863": {
            "condition": "When filtering for abnormal alkaline phosphatase levels",
            "operation": " include only rows where T2.ALP >= 300."
        },
        "864": {
            "condition": "When counting patients with abnormal alkaline phosphatase levels who are admitted, When combining Patient (T1) and Laboratory (T2) tables, When filtering for abnormal alkaline phosphatase levels, When filtering for admitted patients",
            "operation": " include only rows where T1.Admission = '+' exactly as specified."
        },
        "865": {
            "condition": "When answering about patients followed at the outpatient clinic",
            "operation": " make sure to filter for patients where T1.Admission = '-' exactly as specified."
        },
        "866": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID exactly as shown and keep only matching pairs (inner match)."
        },
        "867": {
            "condition": "When checking for normal alkaline phosphatase levels",
            "operation": " use the condition T2.ALP < 300 instead of checking for text 'normal'."
        },
        "868": {
            "condition": "When answering about patients followed at the outpatient clinic, When combining Patient and Laboratory tables, When checking for normal alkaline phosphatase levels, When counting patients",
            "operation": " count using the canonical key T1.ID instead of counting all rows."
        },
        "869": {
            "condition": "When counting patients from the outpatient clinic",
            "operation": " use T1.ID as the counting key without DISTINCT since the join ensures uniqueness."
        },
        "870": {
            "condition": "When identifying outpatient clinic patients",
            "operation": " filter for T1.Admission = '-' exactly as specified."
        },
        "871": {
            "condition": "When checking for normal alkaline phosphatase levels",
            "operation": " filter for T2.ALP < 300."
        },
        "872": {
            "condition": "When counting patients from the outpatient clinic, When identifying outpatient clinic patients, When checking for normal alkaline phosphatase levels, When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using an inner match to ensure only patients with lab results are included."
        },
        "873": {
            "condition": "When answering about \"diagnosis of patients whose total protein is lower than normal\"",
            "operation": " make sure the output order: T1.Diagnosis."
        },
        "874": {
            "condition": "When the question mentions \"patients\"",
            "operation": " \"patients\" actually means \"Patient table (T1)\" in schema."
        },
        "875": {
            "condition": "When the question mentions \"total protein\"",
            "operation": " \"total protein\" actually means \"TP column in Laboratory table (T2)\" in schema."
        },
        "876": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.ID = T2.ID; keep only matching pairs (inner match)."
        },
        "877": {
            "condition": "When answering about \"diagnosis of patients whose total protein is lower than normal\", When the question mentions \"patients\", When the question mentions \"total protein\", When combining T1 and T2 for shared entities, When filtering for \"lower than normal\" total protein",
            "operation": " filter on T2.TP < 6.0 using the exact literal value 6.0."
        },
        "878": {
            "condition": "When answering about patients diagnosed with SJS",
            "operation": " join Patient table as T1 with Laboratory table as T2 using inner join where T1.ID = T2.ID."
        },
        "879": {
            "condition": "When filtering for SJS diagnosis",
            "operation": " use exact condition T1.Diagnosis = 'SJS' with exact literal 'SJS'."
        },
        "880": {
            "condition": "When checking for normal total protein levels",
            "operation": " use numeric range checks T2.TP > 6.0 AND T2.TP < 8.5 instead of string comparison."
        },
        "881": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "882": {
            "condition": "When answering about patients diagnosed with SJS, When filtering for SJS diagnosis, When checking for normal total protein levels, When counting patients, When handling identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for any identifiers."
        },
        "883": {
            "condition": "When the question asks for \"examination date\"",
            "operation": " use the exact column name \"Date\" from the Laboratory table."
        },
        "884": {
            "condition": "When the question refers to \"albumin\"",
            "operation": " use the exact column name \"ALB\" from the Laboratory table."
        },
        "885": {
            "condition": "When filtering for \"normal range\" of albumin",
            "operation": " use the condition ALB > 3.5 AND ALB < 5.5 as the proper clinical range boundaries."
        },
        "886": {
            "condition": "When finding the \"highest\" value within a range",
            "operation": " order rows by ALB in descending order and take only the first row."
        },
        "887": {
            "condition": "When the question asks for \"examination date\", When the question refers to \"albumin\", When filtering for \"normal range\" of albumin, When finding the \"highest\" value within a range, When retrieving data about laboratory measurements",
            "operation": " use the Laboratory table as the data source instead of patients."
        },
        "888": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "889": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows using T1.ID = T2.ID with an inner join between Patient AS T1 and Laboratory AS T2."
        },
        "890": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male' with exact literal 'M'."
        },
        "891": {
            "condition": "When checking for normal albumin levels",
            "operation": " use numeric range comparison T2.ALB > 3.5 AND T2.ALB < 5.5 instead of string-based albumin = 'normal'."
        },
        "892": {
            "condition": "When checking for normal total protein levels",
            "operation": " use numeric range comparison T2.TP BETWEEN 6.0 AND 8.5 instead of string-based total_protein = 'normal'."
        },
        "893": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for male patients, When checking for normal albumin levels, When checking for normal total protein levels, When combining multiple conditions",
            "operation": " use AND logic to require all conditions simultaneously instead of OR logic."
        },
        "894": {
            "condition": "When answering about anti Cardiolipin antibody concentration",
            "operation": " make sure the output includes T3.\"aCL IgG\", T3.\"aCL IgM\", and T3.\"aCL IgA\" columns."
        },
        "895": {
            "condition": "When combining patient, laboratory, and examination data",
            "operation": " link rows where T1.ID = T2.ID and T3.ID = T2.ID, keeping only matching pairs (inner match)."
        },
        "896": {
            "condition": "When the question mentions \"female patient\"",
            "operation": " use T1.SEX = 'F' as the exact filter condition."
        },
        "897": {
            "condition": "When the question mentions \"highest uric acid level in the normal range\"",
            "operation": " use T2.UA > 6.5 as the direct threshold filter instead of finding maximum values."
        },
        "898": {
            "condition": "When ordering results by uric acid level",
            "operation": " order by T2.UA DESC to get the highest values first."
        },
        "899": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for columns like T3.\"aCL IgG\"."
        },
        "900": {
            "condition": "When answering about anti Cardiolipin antibody concentration, When combining patient, laboratory, and examination data, When the question mentions \"female patient\", When the question mentions \"highest uric acid level in the normal range\", When ordering results by uric acid level, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for values like 'F'."
        },
        "901": {
            "condition": "When answering about \"highest anti-nucleus antibody concentration level\"",
            "operation": " make sure the output order: T2.ANA DESC and take only the first row."
        },
        "902": {
            "condition": "When the question mentions \"patient with a normal creatinine level\"",
            "operation": " \"normal creatinine level\" actually means T3.CRE < 1.5 in schema."
        },
        "903": {
            "condition": "When combining Patient AS T1, Examination AS T2, and Laboratory AS T3",
            "operation": " link rows where T1.ID = T2.ID and T1.ID = T3.ID; keep only matching pairs (inner match)."
        },
        "904": {
            "condition": "When answering about \"highest anti-nucleus antibody concentration level\", When the question mentions \"patient with a normal creatinine level\", When combining Patient AS T1, Examination AS T2, and Laboratory AS T3, When selecting the antibody concentration level",
            "operation": " use T2.ANA instead of MAX(antibody_concentration) and do not use aggregate functions."
        },
        "905": {
            "condition": "When answering about \"patient's ID\"",
            "operation": " make sure the output order: T2.ID"
        },
        "906": {
            "condition": "When the question mentions \"creatinine level is normal\"",
            "operation": " \"normal\" actually means \"T1.CRE < 1.5\" in schema"
        },
        "907": {
            "condition": "When the question mentions \"highest anti Cardiolipin antibody concentration level\"",
            "operation": " rank rows by T2.aCL IgA in descending direction and keep the first 1 row"
        },
        "908": {
            "condition": "When answering about \"patient's ID\", When the question mentions \"creatinine level is normal\", When the question mentions \"highest anti Cardiolipin antibody concentration level\", When combining Laboratory AS T1 and Examination AS T2 for shared entities",
            "operation": " link rows where T1.ID = T2.ID exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "909": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific non-null patient identifiers."
        },
        "910": {
            "condition": "When referencing tables",
            "operation": " use Patient AS T1, Laboratory AS T2, and Examination AS T3 as the canonical table aliases."
        },
        "911": {
            "condition": "When joining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID using an inner match."
        },
        "912": {
            "condition": "When joining Patient and Examination tables",
            "operation": " link rows where T1.ID = T3.ID using an inner match."
        },
        "913": {
            "condition": "When filtering for elevated total bilirubin",
            "operation": " use T2.\"T-BIL\" >= 2 instead of bilirubin > 1.2 to use the correct column name and inclusive threshold."
        },
        "914": {
            "condition": "When counting patients, When referencing tables, When joining Patient and Laboratory tables, When joining Patient and Examination tables, When filtering for elevated total bilirubin, When filtering for peripheral ANA pattern",
            "operation": " use T3.\"ANA Pattern\" LIKE '%P%' instead of exact string comparison to perform pattern matching for peripheral patterns."
        },
        "915": {
            "condition": "When answering about anti-nucleus antibody concentration",
            "operation": " select T3.ANA instead of anti_nucleus_antibody_concentration."
        },
        "916": {
            "condition": "When combining Patient, Laboratory, and Examination tables",
            "operation": " link rows where T1.ID = T2.ID and T1.ID = T3.ID using inner joins."
        },
        "917": {
            "condition": "When filtering for total bilirubin in normal range",
            "operation": " use T2.\"T-BIL\" < 2.0 instead of total_bilirubin."
        },
        "918": {
            "condition": "When finding the patient with highest total bilirubin",
            "operation": " order by T2.\"T-BIL\" DESC and limit to 1 result."
        },
        "919": {
            "condition": "When answering about anti-nucleus antibody concentration, When combining Patient, Laboratory, and Examination tables, When filtering for total bilirubin in normal range, When finding the patient with highest total bilirubin, When the question mentions \"normal range\" for bilirubin",
            "operation": " use the condition T2.\"T-BIL\" < 2.0 to represent the upper bound of normal range."
        },
        "920": {
            "condition": "When answering about patients with high total cholesterol",
            "operation": " use \"T2.\\\"T-CHO\\\" >= 250\" instead of \"total_cholesterol > 200\" to identify patients with higher than normal cholesterol levels."
        },
        "921": {
            "condition": "When answering about negative coagulation measures",
            "operation": " use \"T3.KCT = '-'\" instead of \"coagulation_degree < 0\" to identify patients with negative coagulation results."
        },
        "922": {
            "condition": "When combining patient data with laboratory and examination information",
            "operation": " perform inner joins where \"T1.ID = T2.ID\" to link patients with laboratory results and \"T1.ID = T3.ID\" to link patients with examination results."
        },
        "923": {
            "condition": "When counting patients",
            "operation": " use \"COUNT(T1.ID)\" instead of \"COUNT(*)\" to count distinct patient IDs."
        },
        "924": {
            "condition": "When answering about patients with high total cholesterol, When answering about negative coagulation measures, When combining patient data with laboratory and examination information, When counting patients, When referencing tables",
            "operation": " use aliases T1 for patients table, T2 for Laboratory table, and T3 for Examination table as specified in the schema relationships."
        },
        "925": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific non-null patient identifiers."
        },
        "926": {
            "condition": "When referencing tables",
            "operation": " use table aliases T1 for Patient, T2 for Laboratory, and T3 for Examination instead of p, lr, ae."
        },
        "927": {
            "condition": "When joining tables",
            "operation": " link rows where T1.ID = T2.ID and T1.ID = T3.ID to properly connect patient records across tables."
        },
        "928": {
            "condition": "When filtering for ANA examination patterns",
            "operation": " use T3.\"ANA Pattern\" = 'P' to reference the correct column name and pattern value."
        },
        "929": {
            "condition": "When counting patients, When referencing tables, When joining tables, When filtering for ANA examination patterns, When filtering for normal cholesterol range",
            "operation": " use T2.\"T-CHO\" < 250 instead of greater than 200 to use the correct column name and threshold value with less than comparison."
        },
        "930": {
            "condition": "When answering about patients with normal triglyceride levels",
            "operation": " use numeric comparison T2.TG < 200 instead of string matching 'normal'."
        },
        "931": {
            "condition": "When combining examination and laboratory data",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "932": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count using the canonical patient identifier."
        },
        "933": {
            "condition": "When filtering for patients with symptoms",
            "operation": " use T1.Symptoms IS NOT NULL with proper table qualification."
        },
        "934": {
            "condition": "When answering about patients with normal triglyceride levels, When combining examination and laboratory data, When counting patients, When filtering for patients with symptoms, When selecting source tables",
            "operation": " use Examination AS T1 and Laboratory AS T2 as specified in the schema relationship."
        },
        "935": {
            "condition": "When answering about \"disease name\"",
            "operation": " use \"Diagnosis\" from table \"Examination\" instead of \"disease_name\" from \"patients\"."
        },
        "936": {
            "condition": "When combining patient examination and laboratory data",
            "operation": " link rows where T1.ID = T2.ID using an inner join between the tables."
        },
        "937": {
            "condition": "When filtering for triglyceride levels within normal range",
            "operation": " use the condition T2.TG < 200 instead of triglyceride <= 150."
        },
        "938": {
            "condition": "When answering about \"disease name\", When combining patient examination and laboratory data, When filtering for triglyceride levels within normal range, When finding the highest triglyceride level",
            "operation": " order results by T2.TG in descending order and take only the top 1 result instead of using a subquery to find the maximum value."
        },
        "939": {
            "condition": "When answering about \"patients with no thrombosis and abnormal creatinine phosphokinase\"",
            "operation": " make sure the output order: T1.ID"
        },
        "940": {
            "condition": "When the question mentions \"patient IDs\"",
            "operation": " use \"T1.ID\" from the Laboratory table as the exact identifier"
        },
        "941": {
            "condition": "When combining Laboratory (T1) and Examination (T2) tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)"
        },
        "942": {
            "condition": "When the question mentions \"no thrombosis\"",
            "operation": " use T2.Thrombosis = 0 with numeric comparison instead of string 'no'"
        },
        "943": {
            "condition": "When the question mentions \"abnormal level of creatinine phosphokinase\"",
            "operation": " use T1.CPK < 250 with numeric threshold instead of string 'normal'"
        },
        "944": {
            "condition": "When answering about \"patients with no thrombosis and abnormal creatinine phosphokinase\", When the question mentions \"patient IDs\", When combining Laboratory (T1) and Examination (T2) tables, When the question mentions \"no thrombosis\", When the question mentions \"abnormal level of creatinine phosphokinase\", When selecting patient IDs",
            "operation": " use DISTINCT T1.ID to avoid duplicate patient records"
        },
        "945": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs."
        },
        "946": {
            "condition": "When answering about patients with laboratory and examination data",
            "operation": " join Patient AS T1 with Laboratory AS T2 using T1.ID = T2.ID and with Examination AS T3 using T1.ID = T3.ID, keeping only matching pairs (inner match)."
        },
        "947": {
            "condition": "When filtering for normal creatinine phosphokinase range",
            "operation": " use T2.CPK < 250 instead of a 0-1000 range."
        },
        "948": {
            "condition": "When counting patients, When answering about patients with laboratory and examination data, When filtering for normal creatinine phosphokinase range, When identifying positive coagulation measures",
            "operation": " use (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+') instead of degree_of_coagulation > 0 to check for positive test indicators."
        },
        "949": {
            "condition": "When answering about patient birthdays",
            "operation": " select T1.Birthday instead of using MAX() aggregation to get the actual birthday value."
        },
        "950": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where T1.ID = T2.ID using an inner match to properly correlate patient and lab information."
        },
        "951": {
            "condition": "When filtering for abnormal blood glucose",
            "operation": " use T2.GLU > 180 as the condition instead of blood_glucose > 120 OR blood_glucose < 70 to match the correct column name and threshold."
        },
        "952": {
            "condition": "When answering about patient birthdays, When combining patient and laboratory data, When filtering for abnormal blood glucose, When finding the oldest patient",
            "operation": " order by T1.Birthday ASC and take only the first row to get the earliest birthday."
        },
        "953": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs."
        },
        "954": {
            "condition": "When combining patient data with laboratory and examination information",
            "operation": " link rows using INNER JOIN on T1.ID = T2.ID and T1.ID = T3.ID to connect patients with their laboratory results and examination findings."
        },
        "955": {
            "condition": "When identifying patients with normal blood glucose",
            "operation": " use T2.GLU < 180 instead of blood_glucose = 'normal' to apply the correct numeric threshold for glucose levels."
        },
        "956": {
            "condition": "When counting patients, When combining patient data with laboratory and examination information, When identifying patients with normal blood glucose, When checking for absence of thrombosis",
            "operation": " use T3.Thrombosis = 0 instead of thrombosis IS NULL to properly identify patients without thrombosis using the zero value indicator."
        },
        "957": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count using the patient's canonical key."
        },
        "958": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID using an inner match."
        },
        "959": {
            "condition": "When filtering for normal white blood cells",
            "operation": " use T2.WBC BETWEEN 3.5 AND 9 instead of checking for 'normal' text values."
        },
        "960": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for normal white blood cells, When identifying admitted patients",
            "operation": " include the condition T1.Admission = '+' to filter for patients who have been accepted to the hospital."
        },
        "961": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "962": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 and Laboratory AS T2 using INNER JOIN where T1.ID = T2.ID to match patient records with their lab results."
        },
        "963": {
            "condition": "When filtering for SLE diagnosis",
            "operation": " use T1.Diagnosis = 'SLE' with exact case and table qualification."
        },
        "964": {
            "condition": "When counting patients, When combining patient and laboratory data, When filtering for SLE diagnosis, When checking for normal white blood cell levels",
            "operation": " use T2.WBC BETWEEN 3.5 AND 9 for numeric range comparison instead of string matching."
        },
        "965": {
            "condition": "When answering about patients with abnormal red blood cell levels",
            "operation": " use numeric range comparison (T2.RBC <= 3.5 OR T2.RBC >="
        },
        "966": {
            "condition": "instead of text equality 'abnormal'.",
            "operation": "instead of text equality 'abnormal'."
        },
        "967": {
            "condition": "When identifying outpatient clinic status",
            "operation": " check for T1.Admission = '-' instead of clinic_type = 'outpatient'."
        },
        "968": {
            "condition": "When combining patient and laboratory data",
            "operation": " perform an inner join between patients as T1 and Laboratory as T2 on T1.ID = T2.ID."
        },
        "969": {
            "condition": "When selecting patient identifiers",
            "operation": " use DISTINCT T1.ID to avoid duplicate patient records."
        },
        "970": {
            "condition": "When answering about patients with abnormal red blood cell levels, instead of text equality 'abnormal'., When identifying outpatient clinic status, When combining patient and laboratory data, When selecting patient identifiers, When referencing columns from joined tables",
            "operation": " always specify the table alias (T2.RBC, T1.Admission) instead of standalone column names."
        },
        "971": {
            "condition": "When counting patients",
            "operation": " use COUNT(T1.ID) instead of COUNT(*) to count specific patient identifiers."
        },
        "972": {
            "condition": "When combining patient and laboratory data",
            "operation": " join Patient AS T1 INNER JOIN Laboratory AS T2 using the condition T1.ID = T2.ID to link matching patient records."
        },
        "973": {
            "condition": "When identifying normal platelet levels",
            "operation": " filter on T2.PLT > 100 AND T2.PLT < 400 instead of using string comparison for platelet_level."
        },
        "974": {
            "condition": "When counting patients, When combining patient and laboratory data, When identifying normal platelet levels, When checking for other symptoms",
            "operation": " use T1.Diagnosis IS NOT NULL instead of symptoms IS NOT NULL to validate diagnosis information."
        },
        "975": {
            "condition": "When answering about platelet levels",
            "operation": " select \"T2\".\"PLT\" from the \"Laboratory\" table instead of platelet_level from the patients table."
        },
        "976": {
            "condition": "When combining patient and laboratory data",
            "operation": " link rows where \"T1\".\"ID\" = \"T2\".\"ID\" using an inner join and keep only matching pairs."
        },
        "977": {
            "condition": "When filtering for MCTD diagnosis",
            "operation": " use \"T1\".\"Diagnosis\" = 'MCTD' exactly as specified."
        },
        "978": {
            "condition": "When answering about platelet levels, When combining patient and laboratory data, When filtering for MCTD diagnosis, When checking for normal platelet range",
            "operation": " use BETWEEN 100 AND 400 for inclusive range filtering instead of > 150 AND < 450."
        },
        "979": {
            "condition": "When answering about male patients with normal prothrombin time",
            "operation": " use table aliases T1 for Patient table and T2 for Laboratory table."
        },
        "980": {
            "condition": "When combining Patient and Laboratory tables",
            "operation": " link rows where T1.ID = T2.ID and keep only matching pairs (inner match)."
        },
        "981": {
            "condition": "When filtering for male patients",
            "operation": " use T1.SEX = 'M' instead of gender = 'male'."
        },
        "982": {
            "condition": "When filtering for normal prothrombin time",
            "operation": " use T2.PT < 14 instead of prothrombin_time > 15."
        },
        "983": {
            "condition": "When answering about male patients with normal prothrombin time, When combining Patient and Laboratory tables, When filtering for male patients, When filtering for normal prothrombin time, When calculating average prothrombin time",
            "operation": " use AVG(T2.PT) instead of AVG(prothrombin_time)."
        },
        "984": {
            "condition": "When answering about \"patients with severe thrombosis and normal prothrombin time\"",
            "operation": " join Patient as T1 with Laboratory as T2 on T1.ID = T2.ID and Examination as T3 on T1.ID = T3.ID to access all required data."
        },
        "985": {
            "condition": "When filtering for severe thrombosis",
            "operation": " use T3.Thrombosis < 3 AND T3.Thrombosis > 0 instead of string-based severity classifications."
        },
        "986": {
            "condition": "When filtering for normal prothrombin time",
            "operation": " use T2.PT < 14 instead of string-based values."
        },
        "987": {
            "condition": "When answering about \"patients with severe thrombosis and normal prothrombin time\", When filtering for severe thrombosis, When filtering for normal prothrombin time, When counting patients across joined tables",
            "operation": " count T1.ID instead of all rows to ensure accurate patient counting."
        }
    },
    "student_club": {
        "0": {
            "condition": "When the question asks about a person's major",
            "operation": " select \"T2.major_name\" from the \"major\" table instead of \"major\" from a single table."
        },
        "1": {
            "condition": "When combining member and major tables",
            "operation": " link rows where \"T1.link_to_major\" equals \"T2.major_id\" using an inner join."
        },
        "2": {
            "condition": "When filtering for a person named Angela Sanders",
            "operation": " use separate conditions \"T1.first_name = 'Angela'\" AND \"T1.last_name = 'Sanders'\" instead of a single name field."
        },
        "3": {
            "condition": "When the question asks about a person's major, When combining member and major tables, When filtering for a person named Angela Sanders, When answering about Angela Sanders's major",
            "operation": " make sure the output order: \"T2.major_name\"."
        },
        "4": {
            "condition": "When counting students in the Student_Club",
            "operation": " use COUNT(T1.member_id) instead of COUNT(*) to count specific member identifiers."
        },
        "5": {
            "condition": "When answering about students from the College of Engineering",
            "operation": " use member AS T1 and major AS T2 as source tables instead of only Student_Club."
        },
        "6": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T1.link_to_major = T2.major_id using an inner join to keep only matching pairs."
        },
        "7": {
            "condition": "When counting students in the Student_Club, When answering about students from the College of Engineering, When combining member and major tables, When filtering for College of Engineering",
            "operation": " apply the filter to T2.college = 'College of Engineering' instead of a non-existent column in the original table."
        },
        "8": {
            "condition": "When answering about students in Student_Club from Art and Design Department",
            "operation": " use the \"member\" table as T1 and \"major\" table as T2 instead of \"Students\" and \"Student_Club\" tables."
        },
        "9": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T1.\"link_to_major\" = T2.\"major_id\" using inner join."
        },
        "10": {
            "condition": "When filtering by department",
            "operation": " use the exact literal 'Art and Design Department' instead of 'Art and Design'."
        },
        "11": {
            "condition": "When answering about students in Student_Club from Art and Design Department, When combining member and major tables, When filtering by department, When selecting student names",
            "operation": " reference columns from the \"member\" table (T1) instead of the \"Students\" table."
        },
        "12": {
            "condition": "When counting students who attended an event",
            "operation": " count using T1.event_id from the event table instead of counting all rows from Student_Club."
        },
        "13": {
            "condition": "When joining attendance records with events",
            "operation": " use INNER JOIN between attendance AS T2 and event tables on T1.event_id = T2.link_to_event."
        },
        "14": {
            "condition": "When filtering for a specific event name",
            "operation": " use T1.event_name = 'Women''s Soccer' with exact punctuation and spacing as specified."
        },
        "15": {
            "condition": "When counting students who attended an event, When joining attendance records with events, When filtering for a specific event name, When the question mentions \"students of the Student_Club have attended\"",
            "operation": " this refers to attendance records linked to events through the attendance table's link_to_event column."
        },
        "16": {
            "condition": "When answering about phone numbers of students from a club that attended an event",
            "operation": " select T3.phone instead of phone_number from the Students table."
        },
        "17": {
            "condition": "When combining event, attendance, and member tables",
            "operation": " use a three-table join structure with event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id."
        },
        "18": {
            "condition": "When answering about phone numbers of students from a club that attended an event, When combining event, attendance, and member tables, When filtering for the \"Women's Soccer\" event",
            "operation": " use T1.event_name = 'Women''s Soccer' instead of club_name to correctly identify the event type."
        },
        "19": {
            "condition": "When joining tables for event attendance analysis",
            "operation": " combine event AS T1, attendance AS T2, and member AS T3 using the exact join conditions T1.event_id = T2.link_to_event and T2.link_to_member = T3.member_id, keeping only matching pairs (inner match)."
        },
        "20": {
            "condition": "When filtering for the \"Women's Soccer\" event",
            "operation": " use T1.event_name = 'Women''s Soccer' exactly as specified."
        },
        "21": {
            "condition": "When filtering for medium T-shirt size",
            "operation": " use T3.t_shirt_size = 'Medium' exactly as specified."
        },
        "22": {
            "condition": "When joining tables for event attendance analysis, When filtering for the \"Women's Soccer\" event, When filtering for medium T-shirt size, When counting students from the Student_Club who attended the event",
            "operation": " count using T1.event_id as the canonical counting key instead of counting all columns."
        },
        "23": {
            "condition": "When answering about \"event with highest attendance\"",
            "operation": " make sure the output order: T1.event_name."
        },
        "24": {
            "condition": "When the question mentions \"attendance\"",
            "operation": " \"attendance\" actually means \"COUNT(T2.link_to_event) in schema\"."
        },
        "25": {
            "condition": "When the question mentions \"highest\"",
            "operation": " rank rows by COUNT(T2.link_to_event) in descending direction and keep the first 1 row."
        },
        "26": {
            "condition": "When combining T1 (event) and T2 (attendance) for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "27": {
            "condition": "When the question asks for \"count of attendance\"",
            "operation": " compute the number of rows using the canonical key token T2.link_to_event."
        },
        "28": {
            "condition": "When answering about \"event with highest attendance\", When the question mentions \"attendance\", When the question mentions \"highest\", When combining T1 (event) and T2 (attendance) for shared entities, When the question asks for \"count of attendance\", When the question says \"per event\"",
            "operation": " organize results by T1.event_name and compute requested aggregates per group."
        },
        "29": {
            "condition": "When the question asks about \"college\" for a Student_Club position",
            "operation": " retrieve the college from the major table (T2.college) instead of from the Student_Club table."
        },
        "30": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T1.link_to_major equals T2.major_id using an inner join to ensure only matching pairs are kept."
        },
        "31": {
            "condition": "When filtering for the vice president position",
            "operation": " use T1.position LIKE 'vice president' to match the exact position criteria with case sensitivity."
        },
        "32": {
            "condition": "When the question asks about \"college\" for a Student_Club position, When combining member and major tables, When filtering for the vice president position, When the question mentions \"vice president\"",
            "operation": " this refers to the exact literal 'vice president' in the position column of the member table."
        },
        "33": {
            "condition": "When answering about events attended by a specific person",
            "operation": " use the event table (T1) to get event names instead of an events table."
        },
        "34": {
            "condition": "When finding events attended by someone",
            "operation": " join the attendance table (T2) where T1.event_id = T2.link_to_event to connect events to attendance records."
        },
        "35": {
            "condition": "When identifying the attendee",
            "operation": " join the member table (T3) where T2.link_to_member = T3.member_id to connect attendance records to members."
        },
        "36": {
            "condition": "When filtering for Maya Mclean",
            "operation": " use T3.first_name = 'Maya' AND T3.last_name = 'Mclean' instead of a single attendee_name column to match first and last names separately."
        },
        "37": {
            "condition": "When answering about events attended by a specific person, When finding events attended by someone, When identifying the attendee, When filtering for Maya Mclean, When selecting output",
            "operation": " return T1.event_name from the event table as the final result."
        },
        "38": {
            "condition": "When answering about \"events of the Student_Club\"",
            "operation": " make sure to filter on T1.club_name = 'Student_Club'."
        },
        "39": {
            "condition": "When the question mentions \"Sacha Harrison\"",
            "operation": " this actually means T3.first_name = 'Sacha' and T3.last_name = 'Harrison' in the member table."
        },
        "40": {
            "condition": "When the question mentions \"in 2019\"",
            "operation": " use SUBSTR(T1.event_date, 1,"
        },
        "41": {
            "condition": "= '2019' for year extraction from the event date.",
            "operation": "= '2019' for year extraction from the event date."
        },
        "42": {
            "condition": "When combining event (T1), attendance (T2), and member (T3) tables",
            "operation": " link rows where T1.event_id = T2.link_to_event and T2.link_to_member = T3.member_id; keep only matching pairs (inner match)."
        },
        "43": {
            "condition": "When answering about \"events of the Student_Club\", When the question mentions \"Sacha Harrison\", When the question mentions \"in 2019\", = '2019' for year extraction from the event date., When combining event (T1), attendance (T2), and member (T3) tables, When counting events",
            "operation": " compute the number of rows using the canonical key T1.event_id instead of counting all columns."
        },
        "44": {
            "condition": "When answering about events attended by more than 10 members",
            "operation": " select event_name instead of counting all rows."
        },
        "45": {
            "condition": "When combining event and attendance tables",
            "operation": " link rows where event.event_id equals attendance.link_to_event using an inner join."
        },
        "46": {
            "condition": "When grouping events",
            "operation": " group by event_id to organize results by individual events."
        },
        "47": {
            "condition": "When filtering for sufficient attendance",
            "operation": " use HAVING COUNT(attendance.link_to_event) > 10 to count attendance records."
        },
        "48": {
            "condition": "When excluding meeting-type events",
            "operation": " filter out events where type equals 'Meeting' (case-sensitive) instead of filtering for event_type = 'meeting'."
        },
        "49": {
            "condition": "When answering about events attended by more than 10 members, When combining event and attendance tables, When grouping events, When filtering for sufficient attendance, When excluding meeting-type events, When the question asks about events attended by more than 10 members",
            "operation": " the output should be event names, not a count."
        },
        "50": {
            "condition": "When answering about \"events with attendance over 20 students but not fundraisers\"",
            "operation": " make sure the output order: T1.event_name."
        },
        "51": {
            "condition": "When the question mentions \"names of events\"",
            "operation": " \"names\" actually means \"T1.event_name in schema\"."
        },
        "52": {
            "condition": "When the question mentions \"attendance of over 20 students\"",
            "operation": " calculate attendance by counting T2.link_to_event per event group and require COUNT(T2.link_to_event) > 20."
        },
        "53": {
            "condition": "When the question mentions \"not fundraisers\"",
            "operation": " exclude events where T1.type = 'Fundraiser' (note exact case and spelling)."
        },
        "54": {
            "condition": "When combining T1 (event) and T2 (attendance) for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event; keep only matching pairs (inner match)."
        },
        "55": {
            "condition": "When answering about \"events with attendance over 20 students but not fundraisers\", When the question mentions \"names of events\", When the question mentions \"attendance of over 20 students\", When the question mentions \"not fundraisers\", When combining T1 (event) and T2 (attendance) for shared entities, When grouping by event",
            "operation": " organize results by T1.event_id and compute requested aggregates per group."
        },
        "56": {
            "condition": "When calculating average attendance for meetings",
            "operation": " compute it as total attendances divided by distinct events using CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) instead of using AVG(attendance)."
        },
        "57": {
            "condition": "When combining event and attendance data",
            "operation": " link tables using INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event to match event records with their attendance records."
        },
        "58": {
            "condition": "When filtering by year 2020",
            "operation": " use SUBSTR(T1.event_date, 1,"
        },
        "59": {
            "condition": "= '2020' to extract the year portion from the event date field.",
            "operation": "= '2020' to extract the year portion from the event date field."
        },
        "60": {
            "condition": "When calculating average attendance for meetings, When combining event and attendance data, When filtering by year 2020, = '2020' to extract the year portion from the event date field., When the question specifies meetings",
            "operation": " add filter T1.type = 'Meeting' to include only meeting type events."
        },
        "61": {
            "condition": "When answering about \"the most expensive item\"",
            "operation": " select \"expense_description\" from table \"expense\" instead of MAX(amount) from \"expenses\"."
        },
        "62": {
            "condition": "When the question mentions \"spent in support of club events\"",
            "operation": " do not apply any category filter as the question does not specify a category constraint."
        },
        "63": {
            "condition": "When answering about \"the most expensive item\", When the question mentions \"spent in support of club events\", When finding the single most expensive item",
            "operation": " order rows by \"cost\" in descending order and keep only the first row (top 1)."
        },
        "64": {
            "condition": "When counting members",
            "operation": " use COUNT(T1.member_id) instead of COUNT(*) to count specific members rather than all rows."
        },
        "65": {
            "condition": "When joining member and major tables",
            "operation": " use FROM member AS T1 INNER JOIN major AS T2 instead of FROM Student_Club to properly access both tables."
        },
        "66": {
            "condition": "When linking member and major tables",
            "operation": " add the join condition ON T1.link_to_major = T2.major_id to establish the proper relationship between tables."
        },
        "67": {
            "condition": "When counting members, When joining member and major tables, When linking member and major tables, When filtering for Environmental Engineering majors",
            "operation": " use WHERE T2.major_name = 'Environmental Engineering' instead of WHERE major = 'Environmental Engineering' to reference the correct table column with exact literal value."
        },
        "68": {
            "condition": "When the question asks for members of Student_Club",
            "operation": " use the \"member\" table as T1 to get first_name and last_name."
        },
        "69": {
            "condition": "When filtering by event name \"Laugh Out Loud\"",
            "operation": " join T1 with \"attendance\" as T2 on T1.member_id = T2.link_to_member, then join T2 with \"event\" as T3 on T2.link_to_event = T3.event_id, and filter where T3.event_name = 'Laugh Out Loud'."
        },
        "70": {
            "condition": "When the question asks for members of Student_Club, When filtering by event name \"Laugh Out Loud\", When combining tables for attendance relationships",
            "operation": " perform inner joins using the exact key equalities T1.member_id = T2.link_to_member and T2.link_to_event = T3.event_id to ensure only matching pairs are kept."
        },
        "71": {
            "condition": "When answering about \"students who majored Law and Constitutional Studies\"",
            "operation": " use the exact literal 'Law and Constitutional Studies' for filtering, not separate values 'Law' and 'Constitutional Studies'."
        },
        "72": {
            "condition": "When the question mentions \"students\"",
            "operation": " the actual table is \"member\" (aliased as T1) and the relevant column is \"last_name\"."
        },
        "73": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T1.link_to_major = T2.major_id using an inner join to keep only matching pairs."
        },
        "74": {
            "condition": "When answering about \"students who majored Law and Constitutional Studies\", When the question mentions \"students\", When combining member and major tables, When filtering by major",
            "operation": " use T2.major_name = 'Law and Constitutional Studies' as the exact condition."
        },
        "75": {
            "condition": "When the question asks about county information for a person",
            "operation": " join the member table (as T1) with the zip_code table (as T2) using the relationship T1.zip = T2.zip_code to connect person records with their geographic data."
        },
        "76": {
            "condition": "When the question mentions a person's name like 'Sherri Ramsey'",
            "operation": " split the name into first_name and last_name components and filter using T1.first_name = 'Sherri' AND T1.last_name = 'Ramsey' to match the member table structure."
        },
        "77": {
            "condition": "When the question asks about county information for a person, When the question mentions a person's name like 'Sherri Ramsey', When retrieving county information",
            "operation": " select T2.county from the zip_code table rather than a generic county column to specify the correct source table."
        },
        "78": {
            "condition": "When the question asks about a college offering a major taken by a specific person",
            "operation": " use \"member\" as T1 and \"major\" as T2 as source tables instead of a single students table."
        },
        "79": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.link_to_major = T2.major_id and keep only matching pairs (inner match)."
        },
        "80": {
            "condition": "When the question mentions a person's full name \"Tyler Hewitt\"",
            "operation": " use separate first and last name fields with T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt' instead of a single student_name field."
        },
        "81": {
            "condition": "When the question asks about a college offering a major taken by a specific person, When combining T1 and T2 for shared entities, When the question mentions a person's full name \"Tyler Hewitt\", When answering about what college offers the major",
            "operation": " make sure the output column is T2.college instead of college_name."
        },
        "82": {
            "condition": "When answering about funds received by the Vice President",
            "operation": " make sure the output order: T2.amount"
        },
        "83": {
            "condition": "When the question mentions \"Vice President\"",
            "operation": " \"Vice President\" actually means \"T1.position = 'Vice President'\" in schema"
        },
        "84": {
            "condition": "When combining member AS T1 and income AS T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "85": {
            "condition": "When answering about funds received by the Vice President, When the question mentions \"Vice President\", When combining member AS T1 and income AS T2 for shared entities, When the question asks for individual amounts",
            "operation": " do not aggregate and return individual T2.amount values instead of using SUM"
        },
        "86": {
            "condition": "When answering about spending on food in September Meeting",
            "operation": " select T2.spent instead of SUM(amount) and use event AS T1 INNER JOIN budget AS T2 as the source."
        },
        "87": {
            "condition": "When combining event and budget tables",
            "operation": " link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match)."
        },
        "88": {
            "condition": "When filtering for September Meeting",
            "operation": " use T1.event_name = 'September Meeting' instead of club = 'Student_Club'."
        },
        "89": {
            "condition": "When filtering for food category",
            "operation": " use T2.category = 'Food' instead of category = 'food' (note exact case and spelling)."
        },
        "90": {
            "condition": "When filtering for September date",
            "operation": " use SUBSTR(T1.event_date, 6,"
        },
        "91": {
            "condition": "When answering about spending on food in September Meeting, When combining event and budget tables, When filtering for September Meeting, When filtering for food category, When filtering for September date, = '09' to extract the month instead of date LIKE '2023-09%'.",
            "operation": "When answering about spending on food in September Meeting, When combining event and budget tables, When filtering for September Meeting, When filtering for food category, When filtering for September date, = '09' to extract the month instead of date LIKE '2023-09%'."
        },
        "92": {
            "condition": "When the question asks for city and state information",
            "operation": " select \"T2\".\"city\" and \"T2\".\"state\" from the \"zip_code\" table instead of directly from the \"Student_Club\" table."
        },
        "93": {
            "condition": "When combining member and zip code data",
            "operation": " join \"member\" table as T1 with \"zip_code\" table as T2 using inner join where \"T1\".\"zip\" equals \"T2\".\"zip_code\"."
        },
        "94": {
            "condition": "When the question asks for city and state information, When combining member and zip code data, When filtering for the President position",
            "operation": " apply the condition \"T1\".\"position\" = 'President' to identify the correct member."
        },
        "95": {
            "condition": "When answering about \"Student_Club members that grew up in Illinois state\"",
            "operation": " make sure the output order: T1.first_name, T1.last_name."
        },
        "96": {
            "condition": "When the question mentions \"Student_Club members\"",
            "operation": " \"Student_Club\" actually means \"member table as T1\" in schema."
        },
        "97": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.zip = T2.zip_code exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "98": {
            "condition": "When answering about \"Student_Club members that grew up in Illinois state\", When the question mentions \"Student_Club members\", When combining T1 and T2 for shared entities, When filtering by state",
            "operation": " use T2.state = 'Illinois' exactly as specified, preserving the exact case and spelling of 'Illinois'."
        },
        "99": {
            "condition": "When answering about \"spend on advertisement\"",
            "operation": " select \"T2\".\"spent\" instead of SUM(amount) to reference the correct column from the budget table."
        },
        "100": {
            "condition": "When combining event and budget tables",
            "operation": " use FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event to properly relate events to their budgets."
        },
        "101": {
            "condition": "When filtering for September Meeting",
            "operation": " use T1.event_name = 'September Meeting' instead of month-based filtering."
        },
        "102": {
            "condition": "When filtering for advertisement category",
            "operation": " use T2.category = 'Advertisement' with exact capitalization."
        },
        "103": {
            "condition": "When checking for September events",
            "operation": " use SUBSTR(T1.event_date, 6,"
        },
        "104": {
            "condition": "= '09' to extract the month from the event date field.",
            "operation": "= '09' to extract the month from the event date field."
        },
        "105": {
            "condition": "When answering about \"spend on advertisement\", When combining event and budget tables, When filtering for September Meeting, When filtering for advertisement category, When checking for September events, = '09' to extract the month from the event date field., When the question mentions Student_Club",
            "operation": " do not include club = 'Student_Club' filter as the query focuses on specific event relationships rather than club membership."
        },
        "106": {
            "condition": "When answering about department for majors taken by specific students",
            "operation": " make sure the output order: T2.department."
        },
        "107": {
            "condition": "When the question mentions \"Pierce\" and \"Guidi\"",
            "operation": " these actually mean T1.last_name = 'Pierce' OR T1.last_name = 'Guidi' in the schema."
        },
        "108": {
            "condition": "When combining member table (T1) and major table (T2) for shared entities",
            "operation": " link rows where T1.link_to_major = T2.major_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "109": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for column names like T2.department."
        },
        "110": {
            "condition": "When answering about department for majors taken by specific students, When the question mentions \"Pierce\" and \"Guidi\", When combining member table (T1) and major table (T2) for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for values like 'Pierce' and 'Guidi'."
        },
        "111": {
            "condition": "When answering about \"total budgeted amount for all category in 'October Speaker' event\"",
            "operation": " make sure the output order: SUM(T2.amount)"
        },
        "112": {
            "condition": "When the question mentions \"October Speaker\" event",
            "operation": " \"October Speaker\" actually means T1.event_name = 'October Speaker' in schema"
        },
        "113": {
            "condition": "When combining T1 (event) and T2 (budget) for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "114": {
            "condition": "When answering about \"total budgeted amount for all category in 'October Speaker' event\", When the question mentions \"October Speaker\" event, When combining T1 (event) and T2 (budget) for shared entities, When computing total budgeted amount",
            "operation": " use SUM(T2.amount) from the budget table instead of SUM(budgeted_amount) from categories table"
        },
        "115": {
            "condition": "When answering about expenses for a specific event",
            "operation": " join event AS T1, budget AS T2, and expense AS T3 using inner joins on T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget instead of querying only expenses table."
        },
        "116": {
            "condition": "When the question mentions \"October Meeting\"",
            "operation": " use exact literal matching with T1.event_name = 'October Meeting' instead of pattern matching on description."
        },
        "117": {
            "condition": "When filtering by date \"October 8, 2019\"",
            "operation": " use T1.event_date LIKE '2019-10-08%' for date matching instead of exact equality."
        },
        "118": {
            "condition": "When checking approval status",
            "operation": " select T3.approved as output instead of filtering by approved = 'yes'."
        },
        "119": {
            "condition": "When answering about expenses for a specific event, When the question mentions \"October Meeting\", When filtering by date \"October 8, 2019\", When checking approval status, When combining tables for shared entities",
            "operation": " perform inner matches using the exact key equalities T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget to maintain relational integrity."
        },
        "120": {
            "condition": "When answering about average cost spent by Elijah Allen",
            "operation": " use AVG(T2.cost) with explicit table alias qualification."
        },
        "121": {
            "condition": "When combining member and expense tables",
            "operation": " link rows where T1.member_id = T2.link_to_member using an inner join to keep only matching pairs."
        },
        "122": {
            "condition": "When filtering for Elijah Allen",
            "operation": " use T1.last_name = 'Allen' and T1.first_name = 'Elijah' instead of a single participant_name field."
        },
        "123": {
            "condition": "When filtering for September and October months",
            "operation": " extract month numbers using SUBSTR(T2.expense_date, 6,"
        },
        "124": {
            "condition": "When answering about average cost spent by Elijah Allen, When combining member and expense tables, When filtering for Elijah Allen, When filtering for September and October months, and compare to '09' and '10' instead of using month names 'September' and 'October'.",
            "operation": "When answering about average cost spent by Elijah Allen, When combining member and expense tables, When filtering for Elijah Allen, When filtering for September and October months, and compare to '09' and '10' instead of using month names 'September' and 'October'."
        },
        "125": {
            "condition": "When calculating total amount spent by Student_Club",
            "operation": " use T2.spent from the budget table instead of amount from events table."
        },
        "126": {
            "condition": "When extracting year from event dates",
            "operation": " use SUBSTR(T1.event_date, 1,"
        },
        "127": {
            "condition": "instead of strftime('%Y', date).",
            "operation": "instead of strftime('%Y', date)."
        },
        "128": {
            "condition": "When combining event and budget tables",
            "operation": " perform an INNER JOIN where T1.event_id = T2.link_to_event to access spent amounts."
        },
        "129": {
            "condition": "When filtering for Student_Club events",
            "operation": " use T1.organizer = 'Student_Club' exactly as specified."
        },
        "130": {
            "condition": "When calculating total amount spent by Student_Club, When extracting year from event dates, instead of strftime('%Y', date)., When combining event and budget tables, When filtering for Student_Club events, When calculating year-over-year difference",
            "operation": " use conditional aggregation with CASE WHEN statements for years 2019 and 2020 in a single query instead of separate subqueries."
        },
        "131": {
            "condition": "When answering about \"location for Spring Budget Review\"",
            "operation": " make sure the output order: location."
        },
        "132": {
            "condition": "When the question mentions \"Spring Budget Review\"",
            "operation": " \"Spring Budget Review\" actually means \"event_name = 'Spring Budget Review' in schema\"."
        },
        "133": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "134": {
            "condition": "When answering about \"location for Spring Budget Review\", When the question mentions \"Spring Budget Review\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use exact literal 'Spring Budget Review'."
        },
        "135": {
            "condition": "When the question asks about \"cost for Posters\"",
            "operation": " use the exact literal value 'Posters' for filtering the \"expense_description\" column."
        },
        "136": {
            "condition": "When the question specifies a date \"2019/9/4\"",
            "operation": " convert it to ISO date format '2019-09-04' for filtering the \"expense_date\" column."
        },
        "137": {
            "condition": "When referencing the expenses table",
            "operation": " use the exact table name \"expense\" (singular) instead of \"expenses\"."
        },
        "138": {
            "condition": "When filtering by item description",
            "operation": " use the column \"expense_description\" instead of \"item\"."
        },
        "139": {
            "condition": "When the question asks about \"cost for Posters\", When the question specifies a date \"2019/9/4\", When referencing the expenses table, When filtering by item description, When filtering by date",
            "operation": " use the column \"expense_date\" instead of \"date\"."
        },
        "140": {
            "condition": "When answering about \"the biggest budget for Food\"",
            "operation": " find the maximum amount value from the budget table where category equals 'Food' exactly."
        },
        "141": {
            "condition": "When the question mentions \"remaining\"",
            "operation": " use the column \"remaining\" directly from the budget table instead of calculating budget - spent."
        },
        "142": {
            "condition": "When filtering for the maximum budget amount",
            "operation": " use a subquery to find MAX(amount) where category = 'Food' and then match that exact amount value in the main query."
        },
        "143": {
            "condition": "When answering about \"the biggest budget for Food\", When the question mentions \"remaining\", When filtering for the maximum budget amount, When the question asks for the remaining budget",
            "operation": " select only the \"remaining\" column from the budget table where amount equals the maximum amount for category 'Food'."
        },
        "144": {
            "condition": "When answering about fundraising notes",
            "operation": " query the \"income\" table instead of the \"fundraisings\" table."
        },
        "145": {
            "condition": "When filtering for fundraising events",
            "operation": " include the condition where \"source\" equals 'Fundraising' exactly."
        },
        "146": {
            "condition": "When filtering by date",
            "operation": " use \"date_received\" = '2019-09-14' with ISO date format instead of non-standard date formats."
        },
        "147": {
            "condition": "When answering about fundraising notes, When filtering for fundraising events, When filtering by date, When retrieving notes from fundraising events",
            "operation": " select the \"notes\" column from the \"income\" table with proper date and source filtering."
        },
        "148": {
            "condition": "When counting majors",
            "operation": " use COUNT(\"major_name\") from the \"major\" table instead of COUNT(*) from the \"colleges\" table."
        },
        "149": {
            "condition": "When counting majors, When filtering for \"College of Humanities and Social Sciences\"",
            "operation": " use the exact literal 'College of Humanities and Social Sciences' with the column \"college\" in the \"major\" table instead of \"college_name\" in the \"colleges\" table."
        },
        "150": {
            "condition": "When the question asks for phone number of a person",
            "operation": " use the \"phone\" column from the \"member\" table."
        },
        "151": {
            "condition": "When filtering for a person named \"Carlo Jacobs\"",
            "operation": " use exact literal values 'Carlo' for \"first_name\" and 'Jacobs' for \"last_name\" with AND conditions."
        },
        "152": {
            "condition": "When the question asks for phone number of a person, When filtering for a person named \"Carlo Jacobs\", When the schema specifies a \"member\" table instead of \"customers\"",
            "operation": " query the \"member\" table to retrieve phone information."
        },
        "153": {
            "condition": "When the question asks for hometown county for a person",
            "operation": " join member table as T1 with zip_code table as T2 using T1.zip = T2.zip_code to get the county information."
        },
        "154": {
            "condition": "When filtering for a person by name",
            "operation": " use separate first_name and last_name columns with exact literals 'Adela' and 'O''Gallagher' instead of a single name column."
        },
        "155": {
            "condition": "When retrieving county information",
            "operation": " select T2.county from the joined zip_code table rather than from the member table directly."
        },
        "156": {
            "condition": "When the question asks for hometown county for a person, When filtering for a person by name, When retrieving county information, When handling apostrophes in string literals",
            "operation": " properly escape them with double quotes as shown in O''Gallagher."
        },
        "157": {
            "condition": "When answering about budgets for \"November Meeting\"",
            "operation": " make sure the output order: count of events with exceeded budget."
        },
        "158": {
            "condition": "When the question mentions \"budgets\"",
            "operation": " use table \"budget AS T1\" and \"event AS T2\" with aliases exactly as specified."
        },
        "159": {
            "condition": "When combining budget and event tables",
            "operation": " link rows where T1.link_to_event = T2.event_id using inner match only."
        },
        "160": {
            "condition": "When filtering for \"November Meeting\"",
            "operation": " use T2.event_name = 'November Meeting' exactly as written with proper case and quotes."
        },
        "161": {
            "condition": "When checking for exceeded budget",
            "operation": " use T1.remaining < 0 to identify budget deficits."
        },
        "162": {
            "condition": "When answering about budgets for \"November Meeting\", When the question mentions \"budgets\", When combining budget and event tables, When filtering for \"November Meeting\", When checking for exceeded budget, When counting events with exceeded budget",
            "operation": " count using T2.event_id as the canonical key rather than all rows."
        },
        "163": {
            "condition": "When answering about \"total number of the budget amount\"",
            "operation": " make sure the output order: SUM(T1.amount)."
        },
        "164": {
            "condition": "When the question mentions \"budget amount\"",
            "operation": " \"budget amount\" actually means \"T1.amount in schema\"."
        },
        "165": {
            "condition": "When the question mentions \"September Speaker\" event",
            "operation": " filter using T2.event_name = 'September Speaker' exactly as written."
        },
        "166": {
            "condition": "When combining T1 (budget) and T2 (event) for shared entities",
            "operation": " link rows where T1.link_to_event = T2.event_id; keep only matching pairs (inner match)."
        },
        "167": {
            "condition": "When answering about \"total number of the budget amount\", When the question mentions \"budget amount\", When the question mentions \"September Speaker\" event, When combining T1 (budget) and T2 (event) for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "168": {
            "condition": "When answering about event status for purchases",
            "operation": " select \"T1\".\"event_status\" from the \"budget\" table as \"T1\" instead of \"status\" from \"events\"."
        },
        "169": {
            "condition": "When the question mentions \"Post Cards, Posters\"",
            "operation": " this refers to \"T2\".\"expense_description\" = 'Post Cards, Posters' exactly as written."
        },
        "170": {
            "condition": "When the question mentions date \"2019/8/20\"",
            "operation": " convert to date format '2019-08-20' with hyphens and use \"T2\".\"expense_date\" instead of \"date\"."
        },
        "171": {
            "condition": "When combining budget and expense information",
            "operation": " use INNER JOIN between \"budget\" as \"T1\" and \"expense\" as \"T2\" on \"T1\".\"budget_id\" = \"T2\".\"link_to_budget\" to link related records."
        },
        "172": {
            "condition": "When answering about event status for purchases, When the question mentions \"Post Cards, Posters\", When the question mentions date \"2019/8/20\", When combining budget and expense information, When filtering by expense criteria",
            "operation": " apply filters on the \"expense\" table (\"T2\") for both description and date conditions."
        },
        "173": {
            "condition": "When the question asks about a person's major",
            "operation": " use the exact column \"T2.major_name\" instead of \"major\" for output."
        },
        "174": {
            "condition": "When combining member and major tables",
            "operation": " link rows where \"T1.link_to_major = T2.major_id\" using an inner match."
        },
        "175": {
            "condition": "When filtering for a person named \"Brent Thomason\"",
            "operation": " use separate conditions \"T1.first_name = 'Brent'\" AND \"T1.last_name = 'Thomason'\" instead of a single name field."
        },
        "176": {
            "condition": "When the question asks about a person's major, When combining member and major tables, When filtering for a person named \"Brent Thomason\", When answering about a person's major",
            "operation": " make sure to join \"member AS T1\" and \"major AS T2\" tables instead of querying only a single students table."
        },
        "177": {
            "condition": "When counting club members",
            "operation": " use COUNT(T1.member_id) instead of COUNT(*) to count specific non-null values."
        },
        "178": {
            "condition": "When the question mentions \"Business\" major",
            "operation": " \"Business\" actually means T2.major_name = 'Business' in the schema."
        },
        "179": {
            "condition": "When the question mentions \"medium size t-shirt\"",
            "operation": " \"medium size t-shirt\" actually means T1.t_shirt_size = 'Medium' in the schema."
        },
        "180": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T1.link_to_major = T2.major_id and keep only matching pairs (inner match)."
        },
        "181": {
            "condition": "When counting club members, When the question mentions \"Business\" major, When the question mentions \"medium size t-shirt\", When combining member and major tables, When answering about club members from \"Business\" major who wear medium size t-shirts",
            "operation": " make sure to join member AS T1 INNER JOIN major AS T2 with the condition T1.link_to_major = T2.major_id."
        },
        "182": {
            "condition": "When the question asks about zip code type for a person",
            "operation": " select \"type\" from the \"zip_code\" table (as T2) instead of \"zip_code_type\" from the \"customers\" table."
        },
        "183": {
            "condition": "When joining member and zip_code tables",
            "operation": " use INNER JOIN between \"member\" AS T1 and \"zip_code\" AS T2 on T1.zip = T2.zip_code."
        },
        "184": {
            "condition": "When filtering by first and last name",
            "operation": " apply the conditions first_name = 'Christof' and last_name = 'Nielson' to the \"member\" table (T1)."
        },
        "185": {
            "condition": "When the question asks about zip code type for a person, When joining member and zip_code tables, When filtering by first and last name, When selecting output columns",
            "operation": " return T2.type as the zip code type information."
        },
        "186": {
            "condition": "When the question asks for \"major name\" for a position",
            "operation": " use the exact column token \"T2.major_name\" from the joined major table instead of \"major\" from the base table."
        },
        "187": {
            "condition": "When combining club_members and major tables",
            "operation": " perform an inner join where \"T1.link_to_major = T2.major_id\" to link the tables correctly."
        },
        "188": {
            "condition": "When filtering for the Vice President position",
            "operation": " use the exact literal value \"Vice President\" for the position column filter instead of \"President\"."
        },
        "189": {
            "condition": "When the question asks for \"major name\" for a position, When combining club_members and major tables, When filtering for the Vice President position, When answering about the Vice President's major name",
            "operation": " make sure the output order includes only \"T2.major_name\" as the result column."
        },
        "190": {
            "condition": "When the question asks for hometown state of a person",
            "operation": " use the zip_code table's state column (T2.state) instead of a hometowns table."
        },
        "191": {
            "condition": "When joining member and zip_code tables",
            "operation": " link rows where T1.zip = T2.zip_code using an inner match."
        },
        "192": {
            "condition": "When filtering for a person named 'Sacha Harrison'",
            "operation": " use separate conditions T1.first_name = 'Sacha' and T1.last_name = 'Harrison' instead of a combined name field."
        },
        "193": {
            "condition": "When the question asks for hometown state of a person, When joining member and zip_code tables, When filtering for a person named 'Sacha Harrison', When selecting output",
            "operation": " return only the state column from the zip_code table (T2.state)."
        },
        "194": {
            "condition": "When answering about \"which department was the President of the club in\"",
            "operation": " make sure the output order: T2.department."
        },
        "195": {
            "condition": "When the question mentions \"department\"",
            "operation": " \"department\" actually means \"T2.department in schema\"."
        },
        "196": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.link_to_major = T2.major_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "197": {
            "condition": "When answering about \"which department was the President of the club in\", When the question mentions \"department\", When combining T1 and T2 for shared entities, When filtering for position",
            "operation": " use T1.position = 'President' with exact case and spacing."
        },
        "198": {
            "condition": "When answering about payment dates for dues",
            "operation": " use T2.date_received instead of payment_date."
        },
        "199": {
            "condition": "When the question mentions a member's name",
            "operation": " split into T1.first_name = 'Connor' and T1.last_name = 'Hilton' instead of using a single name field."
        },
        "200": {
            "condition": "When the question mentions dues payment",
            "operation": " use T2.source = 'Dues' instead of payment_type = 'dues'."
        },
        "201": {
            "condition": "When answering about payment dates for dues, When the question mentions a member's name, When the question mentions dues payment, When combining member and income information",
            "operation": " link tables using T1.member_id = T2.link_to_member with an inner match to keep only records with corresponding entries in both tables."
        },
        "202": {
            "condition": "When answering about \"first one paid his/her dues\"",
            "operation": " make sure the output order: T1.first_name, T1.last_name."
        },
        "203": {
            "condition": "When the question mentions \"paid his/her dues\"",
            "operation": " \"dues\" actually means \"source = 'Dues' in T2 table\"."
        },
        "204": {
            "condition": "When the question asks for \"first one\"",
            "operation": " rank rows by T2.date_received in ascending order and keep the first 1 row."
        },
        "205": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member; keep only matching pairs (inner match)."
        },
        "206": {
            "condition": "When answering about \"first one paid his/her dues\", When the question mentions \"paid his/her dues\", When the question asks for \"first one\", When combining T1 and T2 for shared entities, When producing output",
            "operation": " qualify column references with table aliases T1.first_name and T1.last_name instead of unqualified column names."
        },
        "207": {
            "condition": "When answering about budget ratio between events",
            "operation": " calculate SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) instead of counting rows."
        },
        "208": {
            "condition": "When combining budget and event tables",
            "operation": " link rows where T1.link_to_event = T2.event_id using an inner join."
        },
        "209": {
            "condition": "When filtering for advertisement category",
            "operation": " use T1.category = 'Advertisement' exactly."
        },
        "210": {
            "condition": "When filtering for meeting type",
            "operation": " use T2.type = 'Meeting' exactly."
        },
        "211": {
            "condition": "When answering about budget ratio between events, When combining budget and event tables, When filtering for advertisement category, When filtering for meeting type, When handling the result",
            "operation": " cast the ratio as REAL instead of returning an integer."
        },
        "212": {
            "condition": "When answering about percentage of budget for a specific category to total budget",
            "operation": " calculate the ratio as (sum of amounts for the specific category) * 100 divided by (sum of all amounts)."
        },
        "213": {
            "condition": "When the question mentions \"Parking\"",
            "operation": " use exact literal 'Parking' for the category filter."
        },
        "214": {
            "condition": "When the question mentions \"November Speaker\"",
            "operation": " use exact literal 'November Speaker' for the event_name filter."
        },
        "215": {
            "condition": "When combining budget and event tables",
            "operation": " link rows where T1.link_to_event = T2.event_id and keep only matching pairs (inner join)."
        },
        "216": {
            "condition": "When performing division for percentage calculation",
            "operation": " ensure floating-point arithmetic by casting to REAL to avoid integer division."
        },
        "217": {
            "condition": "When answering about percentage of budget for a specific category to total budget, When the question mentions \"Parking\", When the question mentions \"November Speaker\", When combining budget and event tables, When performing division for percentage calculation, When calculating category-specific amounts",
            "operation": " use SUM(CASE WHEN T1.category = 'Parking' THEN T1.amount ELSE 0 END) to isolate the parking budget."
        },
        "218": {
            "condition": "When calculating total cost of pizzas",
            "operation": " use SUM(\"cost\") from the \"expense\" table instead of SUM(price) from the \"pizzas\" table."
        },
        "219": {
            "condition": "When calculating total cost of pizzas, When filtering for pizza expenses",
            "operation": " add a condition where \"expense_description\" equals exactly 'Pizza' to ensure only pizza-related costs are included."
        },
        "220": {
            "condition": "When the question asks for count of cities",
            "operation": " count the number of non-null values in the \"city\" column instead of counting all rows."
        },
        "221": {
            "condition": "When querying about cities and counties",
            "operation": " use the \"zip_code\" table instead of a \"cities\" table to access the correct data source."
        },
        "222": {
            "condition": "When the question asks for count of cities, When querying about cities and counties, When filtering for Orange County, Virginia",
            "operation": " use the exact literal 'Orange County' for the county filter instead of 'Orange' to match the full county name format."
        },
        "223": {
            "condition": "When answering about \"College of Humanities and Social Sciences' departments\"",
            "operation": " make sure the output order: department"
        },
        "224": {
            "condition": "When the question mentions \"departments\"",
            "operation": " \"departments\" actually means \"department in major table\""
        },
        "225": {
            "condition": "When selecting from the major table",
            "operation": " use the exact literal 'College of Humanities and Social Sciences' for the college filter"
        },
        "226": {
            "condition": "When answering about \"College of Humanities and Social Sciences' departments\", When the question mentions \"departments\", When selecting from the major table, When producing output",
            "operation": " only return the department column, not all columns (*)"
        },
        "227": {
            "condition": "When answering about \"Amy Firth's hometown\"",
            "operation": " make sure the output order: T2.city, T2.county, T2.state"
        },
        "228": {
            "condition": "When the question mentions \"hometown\"",
            "operation": " \"hometown\" actually means \"city, county, and state in schema\""
        },
        "229": {
            "condition": "When combining member table as T1 and zip_code table as T2",
            "operation": " link rows where T1.zip = T2.zip_code and keep only matching pairs (inner match)"
        },
        "230": {
            "condition": "When answering about \"Amy Firth's hometown\", When the question mentions \"hometown\", When combining member table as T1 and zip_code table as T2, When filtering for Amy Firth",
            "operation": " filter on T1.first_name = 'Amy' and T1.last_name = 'Firth' using exact literals 'Amy' and 'Firth'"
        },
        "231": {
            "condition": "When answering about \"expenses of the budget with the lowest remaining\"",
            "operation": " make sure the output order: T2.expense_description"
        },
        "232": {
            "condition": "When the question mentions \"expenses\"",
            "operation": " \"expenses\" actually means \"expense_description in expense table\""
        },
        "233": {
            "condition": "When combining T1 (budget) and T2 (expense) for shared entities",
            "operation": " link rows where T1.budget_id = T2.link_to_budget and keep only matching pairs (inner match)"
        },
        "234": {
            "condition": "When the question asks for \"lowest remaining\"",
            "operation": " order rows by T1.remaining in ascending order and keep the first 1 row"
        },
        "235": {
            "condition": "When answering about \"expenses of the budget with the lowest remaining\", When the question mentions \"expenses\", When combining T1 (budget) and T2 (expense) for shared entities, When the question asks for \"lowest remaining\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "236": {
            "condition": "When answering about members who attended an event",
            "operation": " use the exact table alias plan where T1 = event, T2 = attendance, T3 = member."
        },
        "237": {
            "condition": "When the question mentions \"attended the event\"",
            "operation": " this requires joining through the attendance table (T2) that links events to members."
        },
        "238": {
            "condition": "When combining T1 (event) and T2 (attendance)",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly and keep only matching pairs (inner match)."
        },
        "239": {
            "condition": "When combining T2 (attendance) and T3 (member)",
            "operation": " link rows where T2.link_to_member = T3.member_id exactly and keep only matching pairs (inner match)."
        },
        "240": {
            "condition": "When filtering for event \"October Meeting\"",
            "operation": " use T1.event_name = 'October Meeting' exactly (case-sensitive with single quotes)."
        },
        "241": {
            "condition": "When selecting member identifiers",
            "operation": " use DISTINCT T3.member_id to avoid duplicates."
        },
        "242": {
            "condition": "When answering about members who attended an event, When the question mentions \"attended the event\", When combining T1 (event) and T2 (attendance), When combining T2 (attendance) and T3 (member), When filtering for event \"October Meeting\", When selecting member identifiers, When the question asks to \"list all members\"",
            "operation": " the output should contain only member_id values from T3, not all columns from any table."
        },
        "243": {
            "condition": "When answering about \"which college do most of the members go to\"",
            "operation": " make sure the output order: T2.college."
        },
        "244": {
            "condition": "When combining member table T1 and major table T2",
            "operation": " link rows where T1.link_to_major = T2.major_id and keep only matching pairs (inner match)."
        },
        "245": {
            "condition": "When grouping by major identifier",
            "operation": " organize results by T2.major_id and compute requested aggregates per group."
        },
        "246": {
            "condition": "When counting members per college",
            "operation": " compute the number of rows using the canonical key T2.major_id."
        },
        "247": {
            "condition": "When answering about \"which college do most of the members go to\", When combining member table T1 and major table T2, When grouping by major identifier, When counting members per college, When the question asks for \"most\" members",
            "operation": " rank rows by COUNT(T2.college) in descending direction and keep the first 1 row."
        },
        "248": {
            "condition": "When the question asks about a person's major based on phone number",
            "operation": " use the \"member\" table as T1 and \"major\" table as T2 with T1 as the base table."
        },
        "249": {
            "condition": "When joining T1 and T2",
            "operation": " link rows where T1.link_to_major equals T2.major_id using an inner join to keep only matching pairs."
        },
        "250": {
            "condition": "When filtering by phone number \"809-555-3360\"",
            "operation": " apply the condition T1.phone = '809-555-3360' exactly as specified."
        },
        "251": {
            "condition": "When the question asks about a person's major based on phone number, When joining T1 and T2, When filtering by phone number \"809-555-3360\", When selecting the major information",
            "operation": " output T2.major_name instead of any major column from the persons table."
        },
        "252": {
            "condition": "When answering about \"which event has the highest budget amount\"",
            "operation": " make sure the output order: T2.event_name."
        },
        "253": {
            "condition": "When the question mentions \"event\"",
            "operation": " \"event\" actually means \"event AS T2\" in schema."
        },
        "254": {
            "condition": "When the question mentions \"highest budget amount\"",
            "operation": " \"budget amount\" actually means \"T1.amount\" from budget table."
        },
        "255": {
            "condition": "When combining budget AS T1 and event AS T2 for shared entities",
            "operation": " link rows where T1.link_to_event = T2.event_id exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "256": {
            "condition": "When answering about \"which event has the highest budget amount\", When the question mentions \"event\", When the question mentions \"highest budget amount\", When combining budget AS T1 and event AS T2 for shared entities, When the question asks for \"highest\"",
            "operation": " rank rows by T1.amount in descending direction and keep the first 1 row."
        },
        "257": {
            "condition": "When answering about \"expenses incurred by the vice president\"",
            "operation": " make sure the output order: T2.expense_id, T2.expense_description."
        },
        "258": {
            "condition": "When the question mentions \"vice president\"",
            "operation": " \"vice president\" actually means \"T1.position = 'Vice President'\" in schema."
        },
        "259": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "260": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "261": {
            "condition": "When answering about \"expenses incurred by the vice president\", When the question mentions \"vice president\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation from 'Vice President'."
        },
        "262": {
            "condition": "When counting attendance for an event",
            "operation": " count the specific attendance records using COUNT(T2.link_to_member) instead of counting all rows."
        },
        "263": {
            "condition": "When answering about event attendance",
            "operation": " use both event AS T1 and attendance AS T2 tables with an inner join where T1.event_id = T2.link_to_event to connect events with their attendance records."
        },
        "264": {
            "condition": "When filtering for a specific event name",
            "operation": " use T1.event_name = 'Women''s Soccer' with proper SQL string escaping (double single quotes) and reference the correct table alias."
        },
        "265": {
            "condition": "When counting attendance for an event, When answering about event attendance, When filtering for a specific event name, When the question mentions \"Women's Soccer\"",
            "operation": " this exact literal value must be used with proper escaping as 'Women''s Soccer'."
        },
        "266": {
            "condition": "When answering about \"When did the member, Casey Mason, received the income?\"",
            "operation": " make sure the output order: T2.date_received"
        },
        "267": {
            "condition": "When the question mentions \"Casey Mason\"",
            "operation": " \"Casey\" actually means T1.first_name = 'Casey' and \"Mason\" actually means T1.last_name = 'Mason' in schema"
        },
        "268": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "269": {
            "condition": "When answering about \"When did the member, Casey Mason, received the income?\", When the question mentions \"Casey Mason\", When combining T1 and T2 for shared entities, When selecting from multiple tables",
            "operation": " use T2.date_received from the income table instead of income_date from members table"
        },
        "270": {
            "condition": "When answering about \"members' hometowns from Maryland state\"",
            "operation": " make sure the output order: count of members from Maryland"
        },
        "271": {
            "condition": "When the question mentions \"Maryland state\"",
            "operation": " \"Maryland\" actually means \"T1.state = 'Maryland'\" in schema"
        },
        "272": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.zip_code = T2.zip exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "273": {
            "condition": "When the question asks for \"count of members\"",
            "operation": " compute the number of rows using the canonical key token T2.member_id"
        },
        "274": {
            "condition": "When answering about \"members' hometowns from Maryland state\", When the question mentions \"Maryland state\", When combining T1 and T2 for shared entities, When the question asks for \"count of members\", When filtering for Maryland residents",
            "operation": " use T1.state = 'Maryland' instead of hometown field to correctly identify Maryland residents by state"
        },
        "275": {
            "condition": "When the question asks about events attended by a member with a specific phone number",
            "operation": " use the member table as T1 and the attendance table as T2."
        },
        "276": {
            "condition": "When filtering by phone number \"954-555-6240\"",
            "operation": " use T1.phone = '954-555-6240' as the filter condition."
        },
        "277": {
            "condition": "When combining member and attendance tables",
            "operation": " link rows where T1.member_id = T2.link_to_member using an inner join."
        },
        "278": {
            "condition": "When counting attendance events",
            "operation": " count T2.link_to_event instead of counting all rows."
        },
        "279": {
            "condition": "When the question asks about events attended by a member with a specific phone number, When filtering by phone number \"954-555-6240\", When combining member and attendance tables, When counting attendance events, When answering about event attendance",
            "operation": " make sure the output order is the count of attendance records."
        },
        "280": {
            "condition": "When the question asks for members of a specific department",
            "operation": " join table \"members\" as T1 with table \"major\" as T2 using the exact join condition T1.link_to_major = T2.major_id to connect members to their departments."
        },
        "281": {
            "condition": "When filtering for department \"School of Applied Sciences, Technology and Education\"",
            "operation": " apply the filter condition to T2.department column with the exact literal value 'School of Applied Sciences, Technology and Education'."
        },
        "282": {
            "condition": "When selecting output columns for members",
            "operation": " return T1.first_name and T1.last_name instead of using SELECT * to get only the member names."
        },
        "283": {
            "condition": "When the question asks for members of a specific department, When filtering for department \"School of Applied Sciences, Technology and Education\", When selecting output columns for members, When combining tables for department queries",
            "operation": " perform an inner join to keep only members who have a matching major record with the specified department."
        },
        "284": {
            "condition": "When answering about events with budgets",
            "operation": " combine budget table as T1 and event table as T2 using inner match where T1.link_to_event equals T2.event_id."
        },
        "285": {
            "condition": "When filtering for closed events",
            "operation": " use T2.status = 'Closed' (exact case and quotes)."
        },
        "286": {
            "condition": "When calculating spend-to-budget ratio",
            "operation": " compute T1.spent divided by T1.amount."
        },
        "287": {
            "condition": "When finding the highest ratio",
            "operation": " order results by T1.spent / T1.amount in descending direction and keep only the top result."
        },
        "288": {
            "condition": "When answering about events with budgets, When filtering for closed events, When calculating spend-to-budget ratio, When finding the highest ratio, When selecting output",
            "operation": " include T2.event_name as the event identifier."
        },
        "289": {
            "condition": "When counting students with a specific position",
            "operation": " count non-null values of \"member_id\" instead of all rows to exclude null values."
        },
        "290": {
            "condition": "When the question mentions \"students\"",
            "operation": " this actually means the \"member\" table in the schema."
        },
        "291": {
            "condition": "When filtering for position values",
            "operation": " use exact capitalization 'President' instead of 'president' to match database values exactly."
        },
        "292": {
            "condition": "When counting students with a specific position, When the question mentions \"students\", When filtering for position values, When answering about \"how many students have the position of president\"",
            "operation": " make sure the output order: count of \"member_id\" from \"member\" table where \"position\" equals 'President'."
        },
        "293": {
            "condition": "When the question asks for the \"highest amount of budget spend\"",
            "operation": " use MAX(\"spent\") instead of MIN(\"budget\") to find the maximum expenditure value."
        },
        "294": {
            "condition": "When the question asks for the \"highest amount of budget spend\", When querying for budget spending information",
            "operation": " use the \"budget\" table instead of the \"events\" table to access the correct data source containing spending records."
        },
        "295": {
            "condition": "When counting events",
            "operation": " count non-null values of \"event_id\" instead of all rows to exclude null values."
        },
        "296": {
            "condition": "When referencing the events table",
            "operation": " use table name \"event\" instead of \"events\" to match the correct schema."
        },
        "297": {
            "condition": "When filtering by event type",
            "operation": " use column \"type\" with exact literal value 'Meeting' (case-sensitive) instead of \"event_type\" with 'meeting'."
        },
        "298": {
            "condition": "When filtering by year 2020",
            "operation": " extract year from \"event_date\" column using SUBSTR(\"event_date\", 1,"
        },
        "299": {
            "condition": "When counting events, When referencing the events table, When filtering by event type, When filtering by year 2020, = '2020' instead of using a separate \"year\" column.",
            "operation": "When counting events, When referencing the events table, When filtering by event type, When filtering by year 2020, = '2020' instead of using a separate \"year\" column."
        },
        "300": {
            "condition": "When answering about \"total amount of money spent for food\"",
            "operation": " make sure the output order: SUM(\"spent\")."
        },
        "301": {
            "condition": "When the question mentions \"food\"",
            "operation": " \"food\" actually means \"category = 'Food'\" in schema."
        },
        "302": {
            "condition": "When computing total spending",
            "operation": " use the column \"spent\" from table \"budget\" for aggregation."
        },
        "303": {
            "condition": "When answering about \"total amount of money spent for food\", When the question mentions \"food\", When computing total spending, When filtering for food expenses",
            "operation": " use the exact literal 'Food' (case-sensitive) for the category condition."
        },
        "304": {
            "condition": "When answering about \"students that have attended more than 7 events\"",
            "operation": " make sure the output order: T1.first_name, T1.last_name."
        },
        "305": {
            "condition": "When the question mentions \"students\"",
            "operation": " \"students\" actually means \"member AS T1\" in schema."
        },
        "306": {
            "condition": "When the question mentions \"events attended\"",
            "operation": " \"events attended\" actually means \"COUNT(T2.link_to_event)\" through attendance AS T2."
        },
        "307": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member exactly as shown; keep only matching pairs (inner match)."
        },
        "308": {
            "condition": "When the question asks for \"count of events attended per student\"",
            "operation": " organize results by T2.link_to_member and compute COUNT(T2.link_to_event) per group."
        },
        "309": {
            "condition": "When answering about \"students that have attended more than 7 events\", When the question mentions \"students\", When the question mentions \"events attended\", When combining T1 and T2 for shared entities, When the question asks for \"count of events attended per student\", When filtering for \"more than 7 events\"",
            "operation": " apply the condition COUNT(T2.link_to_event) > 7 after grouping."
        },
        "310": {
            "condition": "When answering about students majored in interior design who attended Community Theater event",
            "operation": " use tables major, member, attendance, and event with aliases T1, T2, T3, T4 respectively."
        },
        "311": {
            "condition": "When combining major and member tables",
            "operation": " link rows where T1.major_id = T2.link_to_major and keep only matching pairs (inner match)."
        },
        "312": {
            "condition": "When combining member and attendance tables",
            "operation": " link rows where T2.member_id = T3.link_to_member and keep only matching pairs (inner match)."
        },
        "313": {
            "condition": "When combining attendance and event tables",
            "operation": " link rows where T3.link_to_event = T4.event_id and keep only matching pairs (inner match)."
        },
        "314": {
            "condition": "When filtering for interior design majors",
            "operation": " use condition T1.major_name = 'Interior Design' in the WHERE clause."
        },
        "315": {
            "condition": "When filtering for Community Theater event",
            "operation": " use condition T4.event_name = 'Community Theater' in the WHERE clause."
        },
        "316": {
            "condition": "When answering about students majored in interior design who attended Community Theater event, When combining major and member tables, When combining member and attendance tables, When combining attendance and event tables, When filtering for interior design majors, When filtering for Community Theater event, When selecting output columns",
            "operation": " include both T2.first_name and T2.last_name instead of just a name field."
        },
        "317": {
            "condition": "When the question asks for student names from Georgetown, South Carolina",
            "operation": " select both \"first_name\" and \"last_name\" from table \"member\" (T1) instead of a single \"name\" column."
        },
        "318": {
            "condition": "When combining geographic data with member information",
            "operation": " join table \"zip_code\" (T2) to \"member\" (T1) where T1.\"zip\" equals T2.\"zip_code\" using an inner match."
        },
        "319": {
            "condition": "When filtering by location",
            "operation": " apply the city filter using T2.\"city\" = 'Georgetown' and state filter using T2.\"state\" = 'South Carolina' instead of filtering on the main table."
        },
        "320": {
            "condition": "When the question asks for student names from Georgetown, South Carolina, When combining geographic data with member information, When filtering by location, When using table aliases",
            "operation": " consistently use T1 for \"member\" table and T2 for \"zip_code\" table as specified in the amends."
        },
        "321": {
            "condition": "When answering about \"income generated by Grant Gilmour\"",
            "operation": " make sure the output order: T2.amount"
        },
        "322": {
            "condition": "When the question mentions \"Grant Gilmour\"",
            "operation": " \"Grant Gilmour\" actually means \"T1.first_name = 'Grant' AND T1.last_name = 'Gilmour'\" in schema"
        },
        "323": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "324": {
            "condition": "When the question asks for income amounts",
            "operation": " do not apply any aggregation function to T2.amount instead of using SUM"
        },
        "325": {
            "condition": "When answering about \"income generated by Grant Gilmour\", When the question mentions \"Grant Gilmour\", When combining T1 and T2 for shared entities, When the question asks for income amounts, When filtering for transaction types",
            "operation": " do not include transaction_type = 'expense' filter instead of removing it entirely"
        },
        "326": {
            "condition": "When the question asks about \"student\"",
            "operation": " use the exact identifier \"member\" as table T1 instead of \"students\"."
        },
        "327": {
            "condition": "When the question asks for student name",
            "operation": " select both \"T1.first_name\" and \"T1.last_name\" instead of \"student_name\"."
        },
        "328": {
            "condition": "When combining member and income data",
            "operation": " use \"income\" as table T2 and link rows where \"T1.member_id = T2.link_to_member\" exactly as shown, keeping only matching pairs (inner match)."
        },
        "329": {
            "condition": "When the question asks about \"student\", When the question asks for student name, When combining member and income data, When filtering for income more than $40",
            "operation": " use the exact condition \"T2.amount > 40\" instead of \"income > 40\"."
        },
        "330": {
            "condition": "When answering about total expense for an event",
            "operation": " join tables event (T1), budget (T2), and expense (T3) using proper relationships instead of querying a single table."
        },
        "331": {
            "condition": "When combining T1 and T2",
            "operation": " link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match)."
        },
        "332": {
            "condition": "When combining T2 and T3",
            "operation": " link rows where T2.budget_id = T3.link_to_budget and keep only matching pairs (inner match)."
        },
        "333": {
            "condition": "When filtering for a specific event name",
            "operation": " use T1.event_name = 'Yearly Kickoff' instead of filtering directly on expense tables."
        },
        "334": {
            "condition": "When answering about total expense for an event, When combining T1 and T2, When combining T2 and T3, When filtering for a specific event name, When aggregating total expense",
            "operation": " use SUM(T3.cost) as the aggregation column instead of amount."
        },
        "335": {
            "condition": "When answering about \"which student has been entrusted to manage the budget for the Yearly Kickoff\"",
            "operation": " make sure the output order: T4.first_name, T4.last_name."
        },
        "336": {
            "condition": "When the question mentions \"student\"",
            "operation": " \"student\" actually means \"member in schema\" and requires joining through event, budget, and expense tables."
        },
        "337": {
            "condition": "When combining T1 (event), T2 (budget), T3 (expense), and T4 (member) tables",
            "operation": " link rows where T1.event_id = T2.link_to_event, T2.budget_id = T3.link_to_budget, and T3.link_to_member = T4.member_id; keep only matching pairs (inner match)."
        },
        "338": {
            "condition": "When answering about \"which student has been entrusted to manage the budget for the Yearly Kickoff\", When the question mentions \"student\", When combining T1 (event), T2 (budget), T3 (expense), and T4 (member) tables, When filtering for the Yearly Kickoff event",
            "operation": " use T1.event_name = 'Yearly Kickoff' exactly as specified."
        },
        "339": {
            "condition": "When the question asks about students",
            "operation": " use the \"member\" table instead of \"students\" table with alias T1."
        },
        "340": {
            "condition": "When joining income information",
            "operation": " use INNER JOIN with the \"income\" table as T2 and link using T1.member_id = T2.link_to_member instead of student_id."
        },
        "341": {
            "condition": "When selecting output columns",
            "operation": " include only T1.first_name, T1.last_name, and T2.source, not the aggregate amount."
        },
        "342": {
            "condition": "When grouping for highest income",
            "operation": " group by T1.first_name, T1.last_name, and T2.source combination instead of by member_id."
        },
        "343": {
            "condition": "When ordering for highest income",
            "operation": " order by SUM(T2.amount) DESC instead of MAX(amount) to find total income per source."
        },
        "344": {
            "condition": "When the question asks about students, When joining income information, When selecting output columns, When grouping for highest income, When ordering for highest income, When the question asks for \"highest income\"",
            "operation": " compute the sum of T2.amount per member and source combination rather than the maximum single amount."
        },
        "345": {
            "condition": "When answering about \"which event has the lowest cost\"",
            "operation": " make sure the output order: T1.event_name."
        },
        "346": {
            "condition": "When the question mentions \"event\"",
            "operation": " use table \"event AS T1\" with column \"T1.event_name\"."
        },
        "347": {
            "condition": "When the question mentions \"cost\"",
            "operation": " use table \"expense AS T3\" with column \"T3.cost\"."
        },
        "348": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match)."
        },
        "349": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.budget_id = T3.link_to_budget and keep only matching pairs (inner match)."
        },
        "350": {
            "condition": "When the question asks for \"lowest cost\"",
            "operation": " order by T3.cost in ascending order and keep the first row."
        },
        "351": {
            "condition": "When answering about \"which event has the lowest cost\", When the question mentions \"event\", When the question mentions \"cost\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When the question asks for \"lowest cost\", When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "352": {
            "condition": "When calculating percentage of cost for a specific event",
            "operation": " use conditional aggregation with SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T3.cost ELSE 0 END) instead of simple column references."
        },
        "353": {
            "condition": "When accessing cost data for events",
            "operation": " join tables using INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event and INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget to properly relate events to their expenses."
        },
        "354": {
            "condition": "When computing percentage calculations",
            "operation": " use the formula * 100 / SUM(T3.cost) instead of subquery division to calculate against total expenses."
        },
        "355": {
            "condition": "When ensuring numeric precision in division",
            "operation": " use CAST(... AS REAL) to maintain proper numeric precision."
        },
        "356": {
            "condition": "When calculating percentage of cost for a specific event, When accessing cost data for events, When computing percentage calculations, When ensuring numeric precision in division, When filtering for specific events in aggregation",
            "operation": " incorporate the filter condition T1.event_name = 'Yearly Kickoff' into a CASE expression instead of using a WHERE clause before aggregation."
        },
        "357": {
            "condition": "When the question asks for a ratio between students majored in finance and physics",
            "operation": " calculate (number of Finance majors) divided by (number of Physics majors) from the major table."
        },
        "358": {
            "condition": "When counting Finance majors",
            "operation": " use SUM(CASE WHEN \"major_name\" = 'Finance' THEN 1 ELSE 0 END) to properly count Finance majors."
        },
        "359": {
            "condition": "When counting Physics majors",
            "operation": " use SUM(CASE WHEN \"major_name\" = 'Physics' THEN 1 ELSE 0 END) to properly count Physics majors."
        },
        "360": {
            "condition": "When accessing major data",
            "operation": " query from the \"major\" table instead of the \"students\" table to use the correct data source."
        },
        "361": {
            "condition": "When referring to major names",
            "operation": " use the column \"major_name\" instead of \"major\" to access the proper column name."
        },
        "362": {
            "condition": "When matching literal values",
            "operation": " use exact case 'Finance' and 'Physics' instead of lowercase 'finance' and 'physics' to match the actual data values."
        },
        "363": {
            "condition": "When the question asks for a ratio between students majored in finance and physics, When counting Finance majors, When counting Physics majors, When accessing major data, When referring to major names, When matching literal values, When calculating ratios",
            "operation": " perform the calculation in a single query instead of using separate subqueries for better performance and accuracy."
        },
        "364": {
            "condition": "When answering about \"top source of funds received in September 2019\"",
            "operation": " make sure the output order: source."
        },
        "365": {
            "condition": "When the question mentions \"September 2019\"",
            "operation": " use date_received BETWEEN '2019-09-01' and '2019-09-30' filter."
        },
        "366": {
            "condition": "When the question asks for \"top source based on their amount\"",
            "operation": " order by source DESC and keep the first 1 row."
        },
        "367": {
            "condition": "When querying from the database",
            "operation": " use the income table instead of funds table."
        },
        "368": {
            "condition": "When selecting columns",
            "operation": " select only source instead of source, SUM(amount) as total_amount."
        },
        "369": {
            "condition": "When filtering by date",
            "operation": " do not use strftime('%Y-%m', date) = '2019-09' function."
        },
        "370": {
            "condition": "When answering about \"top source of funds received in September 2019\", When the question mentions \"September 2019\", When the question asks for \"top source based on their amount\", When querying from the database, When selecting columns, When filtering by date, When processing the query",
            "operation": " remove GROUP BY source and aggregation instead of keeping them."
        },
        "371": {
            "condition": "When answering about Student_Club's Secretary",
            "operation": " query the \"member\" table instead of the \"Students\" table."
        },
        "372": {
            "condition": "When filtering for the Secretary position",
            "operation": " use \"position = 'Secretary'\" instead of \"role = 'President'\"."
        },
        "373": {
            "condition": "When answering about Student_Club's Secretary, When filtering for the Secretary position, When selecting output columns",
            "operation": " include \"first_name\", \"last_name\", and \"email\" in that order."
        },
        "374": {
            "condition": "When the question asks about \"members of the Student_Club\"",
            "operation": " the correct table to query is \"member\" (aliased as T2) instead of a non-existent \"Student_Club\" table."
        },
        "375": {
            "condition": "When counting members",
            "operation": " use COUNT(T2.member_id) as the counting key instead of COUNT(*)."
        },
        "376": {
            "condition": "When the question mentions \"major in 'Physics Teaching'\"",
            "operation": " this refers to T1.major_name = 'Physics Teaching' where T1 represents the \"major\" table."
        },
        "377": {
            "condition": "When combining major and member tables",
            "operation": " link rows where T1.major_id = T2.link_to_major using an inner join to keep only matching pairs."
        },
        "378": {
            "condition": "When the question asks about \"members of the Student_Club\", When counting members, When the question mentions \"major in 'Physics Teaching'\", When combining major and member tables, When filtering for specific majors",
            "operation": " apply the exact literal filter T1.major_name = 'Physics Teaching' with the exact case and spacing."
        },
        "379": {
            "condition": "When answering about member attendance for a specific event",
            "operation": " make sure the output order: COUNT(T2.link_to_member)."
        },
        "380": {
            "condition": "When the question mentions \"attend the event\"",
            "operation": " use tables \"event AS T1\" and \"attendance AS T2\" with an INNER JOIN on T1.event_id = T2.link_to_event."
        },
        "381": {
            "condition": "When the question asks for \"count of members\"",
            "operation": " compute the number of rows using the canonical key token T2.link_to_member."
        },
        "382": {
            "condition": "When the question specifies event name \"Community Theater\"",
            "operation": " filter using T1.event_name = 'Community Theater' exactly."
        },
        "383": {
            "condition": "When the question specifies year 2019",
            "operation": " extract year from T1.event_date using SUBSTR(T1.event_date, 1,"
        },
        "384": {
            "condition": "When answering about member attendance for a specific event, When the question mentions \"attend the event\", When the question asks for \"count of members\", When the question specifies event name \"Community Theater\", When the question specifies year 2019, = '2019' instead of a separate year column.",
            "operation": "When answering about member attendance for a specific event, When the question mentions \"attend the event\", When the question asks for \"count of members\", When the question specifies event name \"Community Theater\", When the question specifies year 2019, = '2019' instead of a separate year column."
        },
        "385": {
            "condition": "When counting events attended by a person",
            "operation": " count using T3.link_to_event instead of counting all rows to get specific event links."
        },
        "386": {
            "condition": "When the question asks for a person's major",
            "operation": " select T1.major_name instead of major to reference the proper column from the major table."
        },
        "387": {
            "condition": "When combining major information with member data",
            "operation": " join major AS T1 with member AS T2 using T1.major_id = T2.link_to_major to establish the proper relationship."
        },
        "388": {
            "condition": "When combining member data with attendance information",
            "operation": " join member AS T2 with attendance AS T3 using T2.member_id = T3.link_to_member to use the correct attendance table with proper foreign key relationships."
        },
        "389": {
            "condition": "When counting events attended by a person, When the question asks for a person's major, When combining major information with member data, When combining member data with attendance information, When filtering for a person by name",
            "operation": " use T2.first_name = 'Luisa' AND T2.last_name = 'Guidi' instead of a single name field to properly handle separate first and last name fields."
        },
        "390": {
            "condition": "When calculating average spending",
            "operation": " use SUM(spent) divided by COUNT(spent) instead of AVG(food_cost) for the aggregate calculation."
        },
        "391": {
            "condition": "When referencing data source",
            "operation": " use the \"budget\" table instead of the \"events\" table."
        },
        "392": {
            "condition": "When filtering for category",
            "operation": " use category = 'Food' instead of event_type = 'Student_Club'."
        },
        "393": {
            "condition": "When filtering for event status",
            "operation": " include event_status = 'Closed' condition."
        },
        "394": {
            "condition": "When calculating average spending, When referencing data source, When filtering for category, When filtering for event status, When handling date conditions",
            "operation": " remove the date < date('now') condition instead of keeping it."
        },
        "395": {
            "condition": "When answering about \"highest amount spent on advertisement\"",
            "operation": " make sure the output order: T1.spent DESC."
        },
        "396": {
            "condition": "When the question mentions \"event\"",
            "operation": " \"event\" actually means \"T2.event_name\" in schema."
        },
        "397": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.link_to_event = T2.event_id; keep only matching pairs (inner match)."
        },
        "398": {
            "condition": "When filtering for advertisement spending",
            "operation": " include only rows where T1.category = 'Advertisement' exactly as specified."
        },
        "399": {
            "condition": "When answering about \"highest amount spent on advertisement\", When the question mentions \"event\", When combining T1 and T2 for shared entities, When filtering for advertisement spending, When the question asks for \"highest amount spent\"",
            "operation": " rank rows by T1.spent in descending direction and keep the first 1 row."
        },
        "400": {
            "condition": "When answering about whether someone attended an event",
            "operation": " use a CASE expression returning 'YES' instead of selecting all columns."
        },
        "401": {
            "condition": "When checking attendance records",
            "operation": " join three tables (member, attendance, and event) with INNER JOIN instead of using a single table."
        },
        "402": {
            "condition": "When linking member to attendance",
            "operation": " join on member_id = link_to_member."
        },
        "403": {
            "condition": "When linking attendance to event",
            "operation": " join on link_to_event = event_id."
        },
        "404": {
            "condition": "When filtering for a person's name",
            "operation": " use separate conditions first_name = 'Maya' and last_name = 'Mclean' instead of a single name filter."
        },
        "405": {
            "condition": "When answering about whether someone attended an event, When checking attendance records, When linking member to attendance, When linking attendance to event, When filtering for a person's name, When filtering for an event",
            "operation": " use event_name = 'Women's Soccer' instead of event = 'Women's Soccer'."
        },
        "406": {
            "condition": "When answering about attendance at a specific event",
            "operation": " use CASE WHEN T3.event_name = 'Women''s Soccer' THEN 'YES' END to directly check the event condition rather than counting rows."
        },
        "407": {
            "condition": "When handling conditional results",
            "operation": " do not include an ELSE 'NO' clause when the query should only return 'YES' when the specific event is found."
        },
        "408": {
            "condition": "When filtering for specific events",
            "operation": " place the event_name condition in the SELECT clause instead of the WHERE clause to preserve all matching records while only marking the specific event."
        },
        "409": {
            "condition": "When using table aliases",
            "operation": " use T1 for member table, T2 for attendance table, and T3 for event table for consistency."
        },
        "410": {
            "condition": "When naming result columns",
            "operation": " rename the output column to result instead of attended for clarity."
        },
        "411": {
            "condition": "When answering about attendance at a specific event, When handling conditional results, When filtering for specific events, When using table aliases, When naming result columns, When combining tables for attendance records",
            "operation": " link rows where T1.member_id = T2.link_to_member and T2.link_to_event = T3.event_id to find member attendance at events."
        },
        "412": {
            "condition": "When answering about percentage share of events related to 'Community Service'",
            "operation": " use SUM(CASE WHEN type = 'Community Service' THEN 1 ELSE 0 END) for accurate counting instead of COUNT with CASE."
        },
        "413": {
            "condition": "When referencing event type information",
            "operation": " use column \"type\" instead of event_type."
        },
        "414": {
            "condition": "When filtering for year 2019",
            "operation": " use SUBSTR(event_date, 1,"
        },
        "415": {
            "condition": "= '2019' for year extraction instead of strftime function.",
            "operation": "= '2019' for year extraction instead of strftime function."
        },
        "416": {
            "condition": "When calculating percentage",
            "operation": " use explicit CAST(... AS REAL) instead of implicit decimal conversion with 100.0."
        },
        "417": {
            "condition": "When counting total events for denominator",
            "operation": " use COUNT(type) instead of COUNT(*) for consistency."
        },
        "418": {
            "condition": "When answering about percentage share of events related to 'Community Service', When referencing event type information, When filtering for year 2019, = '2019' for year extraction instead of strftime function., When calculating percentage, When counting total events for denominator, When the question mentions events held by Student_Club",
            "operation": " do not apply organizer = 'Student_Club' filter as it should be removed."
        },
        "419": {
            "condition": "When answering about \"cost of posters for 'September Speaker' event\"",
            "operation": " make sure the output order: T3.cost"
        },
        "420": {
            "condition": "When the question mentions \"posters\"",
            "operation": " \"posters\" actually means \"T3.expense_description = 'Posters'\" in schema"
        },
        "421": {
            "condition": "When the question mentions \"'September Speaker' event\"",
            "operation": " \"'September Speaker'\" actually means \"T1.event_name = 'September Speaker'\" in schema"
        },
        "422": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "423": {
            "condition": "When combining T2 and T3 for shared entities",
            "operation": " link rows where T2.budget_id = T3.link_to_budget exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "424": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "425": {
            "condition": "When answering about \"cost of posters for 'September Speaker' event\", When the question mentions \"posters\", When the question mentions \"'September Speaker' event\", When combining T1 and T2 for shared entities, When combining T2 and T3 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'September Speaker' or 'Posters'"
        },
        "426": {
            "condition": "When answering about \"most popular size of t-shirt ordered by club members\"",
            "operation": " make sure the output order: t_shirt_size."
        },
        "427": {
            "condition": "When the question mentions \"size\"",
            "operation": " \"size\" actually means \"t_shirt_size\" in the member table."
        },
        "428": {
            "condition": "When counting t-shirt sizes",
            "operation": " compute the number of occurrences using t_shirt_size directly."
        },
        "429": {
            "condition": "When the question asks for \"most popular\"",
            "operation": " rank rows by count of t_shirt_size in descending order and keep the first 1 row."
        },
        "430": {
            "condition": "When grouping by t-shirt size",
            "operation": " organize results by t_shirt_size and compute counts per group."
        },
        "431": {
            "condition": "When answering about \"most popular size of t-shirt ordered by club members\", When the question mentions \"size\", When counting t-shirt sizes, When the question asks for \"most popular\", When grouping by t-shirt size, When choosing the data source",
            "operation": " use the member table as the primary data source instead of any orders table."
        },
        "432": {
            "condition": "When answering about \"closed event whose cost has exceeded the budget the most\"",
            "operation": " make sure the output order: T2.event_name."
        },
        "433": {
            "condition": "When combining budget AS T1 and event AS T2",
            "operation": " link rows where T2.event_id = T1.link_to_event exactly as shown and keep only matching pairs (inner match)."
        },
        "434": {
            "condition": "When filtering for closed events",
            "operation": " use T1.event_status = 'Closed' (exact case and spacing) instead of 'closed'."
        },
        "435": {
            "condition": "When identifying events that exceeded budget",
            "operation": " filter on T1.remaining < 0 to find events with negative remaining budget."
        },
        "436": {
            "condition": "When answering about \"closed event whose cost has exceeded the budget the most\", When combining budget AS T1 and event AS T2, When filtering for closed events, When identifying events that exceeded budget, When determining which event exceeded budget the most",
            "operation": " order by T1.remaining (lower values indicate greater budget overruns) instead of calculating cost-budget difference."
        },
        "437": {
            "condition": "When answering about expenses for 'October Meeting' event",
            "operation": " start from event table as T1 and filter where T1.event_name = 'October Meeting' exactly."
        },
        "438": {
            "condition": "When combining events with budgets",
            "operation": " link T1 to budget table as T2 using T1.event_id = T2.link_to_event with inner matching."
        },
        "439": {
            "condition": "When combining budgets with expenses",
            "operation": " link T2 to expense table as T3 using T2.budget_id = T3.link_to_budget with inner matching."
        },
        "440": {
            "condition": "When extracting expense type",
            "operation": " use T1.type instead of expense_type column."
        },
        "441": {
            "condition": "When calculating total value",
            "operation": " use SUM(T3.cost) instead of SUM(amount) for aggregation."
        },
        "442": {
            "condition": "When producing output",
            "operation": " do not include explicit aliases like total_value."
        },
        "443": {
            "condition": "When answering about expenses for 'October Meeting' event, When combining events with budgets, When combining budgets with expenses, When extracting expense type, When calculating total value, When producing output, When organizing results",
            "operation": " do not use GROUP BY clause as aggregation is handled through proper table relationships."
        },
        "444": {
            "condition": "When answering about budgeted categories for 'April Speaker' event",
            "operation": " join table \"event\" as T1 with table \"budget\" as T2 on T1.event_id = T2.link_to_event using inner match."
        },
        "445": {
            "condition": "When filtering for specific event",
            "operation": " use condition T1.event_name = 'April Speaker' exactly as written."
        },
        "446": {
            "condition": "When calculating budget amounts per category",
            "operation": " use SUM(T2.amount) aggregate function instead of raw amount values."
        },
        "447": {
            "condition": "When grouping results by category",
            "operation": " use GROUP BY T2.category to organize results by budget category."
        },
        "448": {
            "condition": "When answering about budgeted categories for 'April Speaker' event, When filtering for specific event, When calculating budget amounts per category, When grouping results by category, When ordering results by amount budgeted",
            "operation": " sort in ascending order (ASC) on the aggregated SUM(T2.amount) values."
        },
        "449": {
            "condition": "When answering about \"highest budgeted amount\"",
            "operation": " find the maximum value of the \"amount\" column instead of ordering and limiting."
        },
        "450": {
            "condition": "When the question mentions \"Food\"",
            "operation": " \"Food\" actually means category = 'Food' in the budget table."
        },
        "451": {
            "condition": "When selecting columns",
            "operation": " select only \"budget_id\" instead of all columns with *."
        },
        "452": {
            "condition": "When referring to the table",
            "operation": " use table name \"budget\" instead of \"budgets\"."
        },
        "453": {
            "condition": "When finding the maximum amount",
            "operation": " use a subquery with SELECT MAX(amount) FROM budget to get the maximum value."
        },
        "454": {
            "condition": "When answering about \"highest budgeted amount\", When the question mentions \"Food\", When selecting columns, When referring to the table, When finding the maximum amount, When filtering for the maximum amount",
            "operation": " use amount = (subquery) instead of ordering by budgeted_amount ASC with LIMIT 1."
        },
        "455": {
            "condition": "When answering about \"top three which have the most budgeted amount\"",
            "operation": " rank rows by amount in descending order and keep the first 3 rows."
        },
        "456": {
            "condition": "When the question mentions \"Advertising\"",
            "operation": " \"Advertising\" actually means \"Advertisement\" in the schema."
        },
        "457": {
            "condition": "When selecting columns",
            "operation": " include budget_id instead of all columns."
        },
        "458": {
            "condition": "When referencing the table",
            "operation": " use budget instead of budgets."
        },
        "459": {
            "condition": "When answering about \"top three which have the most budgeted amount\", When the question mentions \"Advertising\", When selecting columns, When referencing the table, When filtering for category",
            "operation": " use category = 'Advertisement' exactly as specified."
        },
        "460": {
            "condition": "When the question asks about \"total cost spent for Parking\"",
            "operation": " use the exact column \"cost\" from table \"expense\" to calculate the sum."
        },
        "461": {
            "condition": "When filtering for \"Parking\" expenses",
            "operation": " use the exact literal 'Parking' with column \"expense_description\" in the WHERE condition."
        },
        "462": {
            "condition": "When the question asks about \"total cost spent for Parking\", When filtering for \"Parking\" expenses, When referencing the expense table",
            "operation": " use the exact table name \"expense\" (not \"expenses\") in the FROM clause."
        },
        "463": {
            "condition": "When the question asks for \"total expense\"",
            "operation": " use the \"cost\" column from the \"expense\" table to calculate the sum."
        },
        "464": {
            "condition": "When the question mentions a specific date \"8/20/2019\"",
            "operation": " filter using the \"expense_date\" column with the exact date value '2019-08-20'."
        },
        "465": {
            "condition": "When the question asks for \"total expense\", When the question mentions a specific date \"8/20/2019\", When referencing table names",
            "operation": " use the exact table name \"expense\" (not \"expenses\") as shown in the schema."
        },
        "466": {
            "condition": "When the question mentions a date like \"8/20/2019\"",
            "operation": " convert it to ISO date format '2019-08-20' to ensure proper date parsing and avoid month/day confusion."
        },
        "467": {
            "condition": "When the question mentions a date like \"8/20/2019\", When calculating aggregate functions like SUM(cost)",
            "operation": " do not add unnecessary aliases like AS total_expense when the result doesn't require naming in the context."
        },
        "468": {
            "condition": "When answering about \"member id 'rec4BLdZHS2Blfp4v'\"",
            "operation": " use T1.member_id = 'rec4BLdZHS2Blfp4v' as the filter condition."
        },
        "469": {
            "condition": "When combining member and expense tables",
            "operation": " link rows where T1.member_id = T2.link_to_member using an inner match."
        },
        "470": {
            "condition": "When calculating total cost",
            "operation": " compute SUM(T2.cost) instead of SUM(amount)."
        },
        "471": {
            "condition": "When selecting output columns",
            "operation": " use T1.first_name and T1.last_name with exact table qualification."
        },
        "472": {
            "condition": "When referring to table aliases",
            "operation": " use member AS T1 and expense AS T2 as specified."
        },
        "473": {
            "condition": "When answering about \"member id 'rec4BLdZHS2Blfp4v'\", When combining member and expense tables, When calculating total cost, When selecting output columns, When referring to table aliases, When producing output",
            "operation": " do not use the alias total_cost for the sum result."
        },
        "474": {
            "condition": "When the question asks about expenses for a person",
            "operation": " use the exact column \"T2.expense_description\" instead of \"expense_type\" to represent expense types."
        },
        "475": {
            "condition": "When retrieving data about members and expenses",
            "operation": " use \"member AS T1\" and \"expense AS T2\" as the source tables instead of a single \"expenses\" table."
        },
        "476": {
            "condition": "When combining member and expense tables",
            "operation": " link rows where \"T1.member_id = T2.link_to_member\" using an inner join to ensure only matching pairs are kept."
        },
        "477": {
            "condition": "When the question asks about expenses for a person, When retrieving data about members and expenses, When combining member and expense tables, When filtering by a person's name",
            "operation": " use separate conditions \"T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'\" instead of a single name field to properly match first and last names individually."
        },
        "478": {
            "condition": "When answering about \"expenses incurred by members\"",
            "operation": " make sure the output order: T2.expense_description"
        },
        "479": {
            "condition": "When the question mentions \"expense_type\"",
            "operation": " \"expense_type\" actually means \"T2.expense_description\" in schema"
        },
        "480": {
            "condition": "When the question mentions \"members who have X-Large in size of tee shirt\"",
            "operation": " use T1.t_shirt_size = 'X-Large' as the filter condition"
        },
        "481": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "482": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "483": {
            "condition": "When answering about \"expenses incurred by members\", When the question mentions \"expense_type\", When the question mentions \"members who have X-Large in size of tee shirt\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation of 'X-Large'"
        },
        "484": {
            "condition": "When the question asks for \"zip code of member\"",
            "operation": " select \"zip\" from table \"member\" instead of \"zip_code\" from table \"members\"."
        },
        "485": {
            "condition": "When combining member and expense data",
            "operation": " use an inner join between \"member\" and \"expense\" tables where \"member_id = link_to_member\" to link related records."
        },
        "486": {
            "condition": "When the question asks for \"zip code of member\", When combining member and expense data, When filtering for members who incurred less than 50USD",
            "operation": " apply the condition \"cost < 50\" from the \"expense\" table instead of filtering on member attributes."
        },
        "487": {
            "condition": "When the question asks about a person's major",
            "operation": " use the \"major\" table as T1 and the \"member\" table as T2 instead of a \"students\" table."
        },
        "488": {
            "condition": "When joining T1 and T2",
            "operation": " link rows where T1.major_id = T2.link_to_major using an inner match."
        },
        "489": {
            "condition": "When filtering for a specific person named \"Phillip Cullen\"",
            "operation": " apply T2.first_name = 'Phillip' and T2.last_name = 'Cullen' exactly as specified."
        },
        "490": {
            "condition": "When the question asks about a person's major, When joining T1 and T2, When filtering for a specific person named \"Phillip Cullen\", When selecting the major name",
            "operation": " output T1.major_name from the major table."
        },
        "491": {
            "condition": "When answering about \"position of members who joined major of Business\"",
            "operation": " make sure the output order: T2.position"
        },
        "492": {
            "condition": "When the question mentions \"major of Business\"",
            "operation": " \"Business\" actually means \"T1.major_name = 'Business'\" in schema"
        },
        "493": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.major_id = T2.link_to_major exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "494": {
            "condition": "When answering about \"position of members who joined major of Business\", When the question mentions \"major of Business\", When combining T1 and T2 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "495": {
            "condition": "When answering about \"members of Business\"",
            "operation": " join table \"major AS T1\" and table \"member AS T2\" where T1.major_id equals T2.link_to_major to connect members to their majors."
        },
        "496": {
            "condition": "When filtering for Business major",
            "operation": " use condition T1.major_name = 'Business' exactly as specified."
        },
        "497": {
            "condition": "When filtering for Medium t-shirt size",
            "operation": " use condition T2.t_shirt_size = 'Medium' exactly as specified."
        },
        "498": {
            "condition": "When answering about \"members of Business\", When filtering for Business major, When filtering for Medium t-shirt size, When counting members",
            "operation": " count using T2.member_id as the canonical key instead of counting all rows."
        },
        "499": {
            "condition": "When the question asks about \"type of events\"",
            "operation": " select \"T1.type\" from the \"event\" table instead of \"event_type\" from \"events\" table."
        },
        "500": {
            "condition": "When combining event and budget information",
            "operation": " perform an inner join between \"event\" table as T1 and \"budget\" table as T2 where \"T1.event_id\" = \"T2.link_to_event\" to match related records."
        },
        "501": {
            "condition": "When the question asks about \"type of events\", When combining event and budget information, When filtering for remaining budget more than 30 USD",
            "operation": " apply the condition \"T2.remaining\" > 30 to reference the correct budget column from the joined table."
        },
        "502": {
            "condition": "When answering about \"category of events\"",
            "operation": " make sure the output order: T2.category"
        },
        "503": {
            "condition": "When the question mentions \"events held at MU 215\"",
            "operation": " \"MU 215\" actually means T1.location = 'MU 215' in schema"
        },
        "504": {
            "condition": "When combining event table (T1) and budget table (T2) for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "505": {
            "condition": "When answering about \"category of events\", When the question mentions \"events held at MU 215\", When combining event table (T1) and budget table (T2) for shared entities, When retrieving category information",
            "operation": " select T2.category from the budget table instead of category from the events table"
        },
        "506": {
            "condition": "When answering about \"category of event\"",
            "operation": " make sure the output order: T2.category"
        },
        "507": {
            "condition": "When the question mentions \"event\"",
            "operation": " use table \"event AS T1\" for event information and \"budget AS T2\" for category information"
        },
        "508": {
            "condition": "When combining event and budget tables",
            "operation": " link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match)"
        },
        "509": {
            "condition": "When answering about \"category of event\", When the question mentions \"event\", When combining event and budget tables, When filtering by date \"2020-03-24T12",
            "operation": "00:00\": use T1.event_date = '2020-03-24T12:00:00' exactly as specified"
        },
        "510": {
            "condition": "When answering about \"major that Vice President has joined\"",
            "operation": " make sure the output order: T1.major_name."
        },
        "511": {
            "condition": "When the question mentions \"Vice President\"",
            "operation": " \"Vice President\" actually means T2.position = 'Vice President' in schema."
        },
        "512": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.major_id = T2.link_to_major exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "513": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "514": {
            "condition": "When answering about \"major that Vice President has joined\", When the question mentions \"Vice President\", When combining T1 and T2 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Vice President'."
        },
        "515": {
            "condition": "When the question asks for percentage of members with a specific major",
            "operation": " join the members table (T1) with the major table (T2) using the exact key equality T2.major_id = T1.link_to_major and keep only matching pairs (inner match)."
        },
        "516": {
            "condition": "When counting business majors",
            "operation": " use SUM(CASE WHEN T2.major_name = 'Business' THEN 1 ELSE 0 END) to count only rows where major_name equals 'Business' exactly."
        },
        "517": {
            "condition": "When filtering for members only",
            "operation": " add condition WHERE T1.position = 'Member' to include only rows where position equals 'Member' exactly."
        },
        "518": {
            "condition": "When calculating percentage",
            "operation": " compute (business major count) divided by COUNT(T1.member_id) and multiply by 100.0, using CAST for proper real number division."
        },
        "519": {
            "condition": "When the question asks for percentage of members with a specific major, When counting business majors, When filtering for members only, When calculating percentage, When referencing identifiers",
            "operation": " use exact tokens T2.major_name, T1.link_to_major, T2.major_id, T1.position, and T1.member_id as shown in the schema."
        },
        "520": {
            "condition": "When answering about \"category of events\"",
            "operation": " make sure the output order: T2.category."
        },
        "521": {
            "condition": "When the question asks for distinct categories",
            "operation": " compute the number of unique values of the exact token T2.category."
        },
        "522": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly as shown; keep only matching pairs (inner match)."
        },
        "523": {
            "condition": "When answering about \"category of events\", When the question asks for distinct categories, When combining T1 and T2 for shared entities, When filtering by location 'MU 215'",
            "operation": " use the exact literal 'MU 215' with the exact token T1.location."
        },
        "524": {
            "condition": "When counting records in the income table",
            "operation": " count using the exact token \"income_id\" instead of counting all columns to exclude null values."
        },
        "525": {
            "condition": "When counting records in the income table, When filtering for records with amount equal to 50",
            "operation": " use the exact condition amount = 50 instead of amount != 50 to count matching records rather than non-matching ones."
        },
        "526": {
            "condition": "When counting members",
            "operation": " use \"member_id\" instead of \"*\" to exclude NULL values."
        },
        "527": {
            "condition": "When referencing the member table",
            "operation": " use table name \"member\" instead of \"members\" to reference the correct table."
        },
        "528": {
            "condition": "When filtering for members",
            "operation": " add condition \"position = 'Member'\" to count only members with that position."
        },
        "529": {
            "condition": "When counting members, When referencing the member table, When filtering for members, When filtering for extra large t-shirt size",
            "operation": " use value \"'X-Large'\" instead of \"'XL'\" to match the correct size designation."
        },
        "530": {
            "condition": "When answering about majors in a specific college and department",
            "operation": " query the \"major\" table instead of the \"departments\" table."
        },
        "531": {
            "condition": "When counting majors",
            "operation": " count \"major_id\" instead of using COUNT(*)."
        },
        "532": {
            "condition": "When filtering by department",
            "operation": " use \"department = 'School of Applied Sciences, Technology and Education'\" instead of \"department_name = 'School of Applied Sciences, Technology and Education'\"."
        },
        "533": {
            "condition": "When answering about majors in a specific college and department, When counting majors, When filtering by department, When filtering by college",
            "operation": " use \"college = 'College of Agriculture and Applied Sciences'\" instead of \"college_name = 'College of Agriculture and Applied Sciences'\"."
        },
        "534": {
            "condition": "When the question asks for last name, department, and college name",
            "operation": " select T2.last_name, T1.department, and T1.college as output columns."
        },
        "535": {
            "condition": "When combining member and major information",
            "operation": " use INNER JOIN between major AS T1 and member AS T2 where T1.major_id = T2.link_to_major."
        },
        "536": {
            "condition": "When filtering for members with a specific major",
            "operation": " apply T2.position = 'Member' and T1.major_name = 'Environmental Engineering' as filter conditions."
        },
        "537": {
            "condition": "When the question asks for last name, department, and college name, When combining member and major information, When filtering for members with a specific major, When the question mentions \"environmental engineering\"",
            "operation": " use the exact literal 'Environmental Engineering' for filtering."
        },
        "538": {
            "condition": "When answering about budget categories and types for events",
            "operation": " make sure the output order includes both T2.category and T1.type."
        },
        "539": {
            "condition": "When the question mentions \"budget category\"",
            "operation": " \"budget category\" actually means \"T2.category in schema\"."
        },
        "540": {
            "condition": "When the question mentions \"guest speaker type\"",
            "operation": " \"guest speaker type\" actually means \"T1.type = 'Guest Speaker' in schema\"."
        },
        "541": {
            "condition": "When combining event AS T1 and budget AS T2",
            "operation": " link rows where T1.event_id = T2.link_to_event exactly as shown; keep only matching pairs (inner match)."
        },
        "542": {
            "condition": "When filtering for location",
            "operation": " use T1.location = 'MU 215' exactly as specified."
        },
        "543": {
            "condition": "When filtering for budget spent",
            "operation": " use T2.spent = 0 exactly as specified."
        },
        "544": {
            "condition": "When filtering for guest speaker type",
            "operation": " use T1.type = 'Guest Speaker' exactly as specified."
        },
        "545": {
            "condition": "When answering about budget categories and types for events, When the question mentions \"budget category\", When the question mentions \"guest speaker type\", When combining event AS T1 and budget AS T2, When filtering for location, When filtering for budget spent, When filtering for guest speaker type, When retrieving results",
            "operation": " use DISTINCT to return unique combinations of T2.category and T1.type."
        },
        "546": {
            "condition": "When querying about members",
            "operation": " use table alias T1 for the member table instead of directly referencing members."
        },
        "547": {
            "condition": "When the question mentions \"electrical and computer engineering department\"",
            "operation": " the exact literal value is 'Electrical and Computer Engineering Department' with proper capitalization and spacing."
        },
        "548": {
            "condition": "When filtering members by department",
            "operation": " add an additional filter for position = 'Member' to only include actual members."
        },
        "549": {
            "condition": "When combining member data with major information",
            "operation": " link rows where T2.major_id = T1.link_to_major using an inner join with major table as T2."
        },
        "550": {
            "condition": "When querying about members, When the question mentions \"electrical and computer engineering department\", When filtering members by department, When combining member data with major information, When combining member data with location information",
            "operation": " link rows where T3.zip_code = T1.zip using an inner join with zip_code table as T3."
        },
        "551": {
            "condition": "When selecting the name of a social event",
            "operation": " use \"T2.event_name\" as the output column instead of \"e.name\"."
        },
        "552": {
            "condition": "When joining attendance records",
            "operation": " use \"attendance AS T1\" as the table alias."
        },
        "553": {
            "condition": "When linking events to attendance",
            "operation": " use \"INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event\" to connect events through the correct relationship."
        },
        "554": {
            "condition": "When joining member information",
            "operation": " use \"INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\" to connect members through the correct relationship."
        },
        "555": {
            "condition": "When filtering for vice presidents",
            "operation": " use \"T3.position = 'Vice President'\" to identify members with the vice president role."
        },
        "556": {
            "condition": "When filtering by location",
            "operation": " use \"T2.location = '900 E. Washington St.'\" to find events at the specified address."
        },
        "557": {
            "condition": "When selecting the name of a social event, When joining attendance records, When linking events to attendance, When joining member information, When filtering for vice presidents, When filtering by location, When ensuring the event is social",
            "operation": " use \"T2.type = 'Social'\" to filter for social events specifically."
        },
        "558": {
            "condition": "When answering about student purchases",
            "operation": " use the member table (T1) for student details like last_name and position instead of a students table."
        },
        "559": {
            "condition": "When the question mentions \"bought pizza\"",
            "operation": " filter on T2.expense_description = 'Pizza' with exact case matching."
        },
        "560": {
            "condition": "When the question mentions \"on 09/10/2019\"",
            "operation": " filter on T2.expense_date = '2019-09-10' with proper date format conversion."
        },
        "561": {
            "condition": "When combining member and expense tables",
            "operation": " link rows where T1.member_id = T2.link_to_member using an inner join to find matching pairs."
        },
        "562": {
            "condition": "When answering about student purchases, When the question mentions \"bought pizza\", When the question mentions \"on 09/10/2019\", When combining member and expense tables, When retrieving results for this specific query",
            "operation": " do not apply ordering or limit clauses as they are unnecessary for finding the exact match."
        },
        "563": {
            "condition": "When answering about \"members of the club that attended the women's soccer event\"",
            "operation": " make sure the output order: T3.last_name."
        },
        "564": {
            "condition": "When the question mentions \"members of the club\"",
            "operation": " this actually means \"T3.position = 'Member'\" in the schema."
        },
        "565": {
            "condition": "When the question mentions \"women's soccer event\"",
            "operation": " this actually means \"T2.event_name = 'Women''s Soccer'\" in the schema."
        },
        "566": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T2.event_id = T1.link_to_event and T1.link_to_member = T3.member_id; keep only matching pairs (inner match)."
        },
        "567": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "568": {
            "condition": "When answering about \"members of the club that attended the women's soccer event\", When the question mentions \"members of the club\", When the question mentions \"women's soccer event\", When combining T1, T2, and T3 for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation for 'Women''s Soccer' or 'Member'."
        },
        "569": {
            "condition": "When the question asks for percentage of amount 50 received by Student_Club among members with medium t-shirt size",
            "operation": " use SUM(CASE WHEN T2.amount = 50 THEN 1.0 ELSE 0 END) divided by COUNT(T2.income_id) to calculate the percentage."
        },
        "570": {
            "condition": "When combining member and income tables",
            "operation": " link rows where T1.member_id = T2.link_to_member using an inner join."
        },
        "571": {
            "condition": "When filtering members",
            "operation": " include only rows where T1.t_shirt_size = 'Medium' (case-sensitive) and T1.position = 'Member'."
        },
        "572": {
            "condition": "When handling the amount condition",
            "operation": " do not filter by amount = 50 in the WHERE clause since amount is in the joined income table."
        },
        "573": {
            "condition": "When the question asks for percentage of amount 50 received by Student_Club among members with medium t-shirt size, When combining member and income tables, When filtering members, When handling the amount condition, When casting the result",
            "operation": " cast the percentage calculation to REAL data type."
        },
        "574": {
            "condition": "When the question asks about \"countries\" with zip codes",
            "operation": " \"countries\" actually means \"county\" in the schema."
        },
        "575": {
            "condition": "When selecting from the zip_code table",
            "operation": " use DISTINCT county to get unique county values."
        },
        "576": {
            "condition": "When filtering for post office boxes",
            "operation": " use type = 'PO Box' instead of pattern matching on zip_code."
        },
        "577": {
            "condition": "When handling null values",
            "operation": " ensure county IS NOT NULL to exclude records with missing county information."
        },
        "578": {
            "condition": "When the question asks about \"countries\" with zip codes, When selecting from the zip_code table, When filtering for post office boxes, When handling null values, When the question mentions \"zip codes with post office boxes\"",
            "operation": " this refers to records where the type column equals 'PO Box' exactly."
        },
        "579": {
            "condition": "When answering about zip codes with post office boxes",
            "operation": " query the \"zip_code\" table instead of the \"post_offices\" table."
        },
        "580": {
            "condition": "When filtering for post office boxes",
            "operation": " use \"type = 'PO Box'\" instead of \"has_po_boxes = 1\"."
        },
        "581": {
            "condition": "When filtering for geographic location",
            "operation": " use \"county = 'San Juan Municipio'\" instead of \"city = 'San Juan'\"."
        },
        "582": {
            "condition": "When the question mentions \"state is Puerto Rico\"",
            "operation": " include \"state = 'Puerto Rico'\" as a filter condition."
        },
        "583": {
            "condition": "When answering about zip codes with post office boxes, When filtering for post office boxes, When filtering for geographic location, When the question mentions \"state is Puerto Rico\", When selecting output columns",
            "operation": " return the \"zip_code\" column from the \"zip_code\" table."
        },
        "584": {
            "condition": "When the question asks for \"names of closed event as 'game'\"",
            "operation": " select \"event_name\" instead of \"name AS game\" and use DISTINCT to avoid duplicates."
        },
        "585": {
            "condition": "When filtering by event type",
            "operation": " add condition \"type = 'Game'\" to only include game events."
        },
        "586": {
            "condition": "When filtering by status",
            "operation": " use \"status = 'Closed'\" (with capital C) instead of lowercase to match actual data values."
        },
        "587": {
            "condition": "When filtering by date range",
            "operation": " use \"date(SUBSTR(event_date, 1, 10))\" for date handling instead of \"closed_date\" and filter between '2019-03-15' AND '2020-03-20'."
        },
        "588": {
            "condition": "When the question asks for \"names of closed event as 'game'\", When filtering by event type, When filtering by status, When filtering by date range, When referencing the table",
            "operation": " use \"event\" instead of \"events\" as the correct table name."
        },
        "589": {
            "condition": "When answering about \"links to events for members who have paid more than 50 dollar\"",
            "operation": " make sure the output order: T3.link_to_event."
        },
        "590": {
            "condition": "When the question mentions \"paid more than 50 dollar\"",
            "operation": " \"paid\" actually means \"cost > 50\" in the expense table (T1.cost > 50)."
        },
        "591": {
            "condition": "When combining tables for this query",
            "operation": " link T1 (expense) and T2 (member) where T1.link_to_member = T2.member_id, then link T2 and T3 (attendance) where T2.member_id = T3.link_to_member, keeping only matching pairs (inner match)."
        },
        "592": {
            "condition": "When retrieving event links",
            "operation": " use DISTINCT T3.link_to_event to get unique values."
        },
        "593": {
            "condition": "When answering about \"links to events for members who have paid more than 50 dollar\", When the question mentions \"paid more than 50 dollar\", When combining tables for this query, When retrieving event links, When filtering payment amounts",
            "operation": " use T1.cost > 50 instead of payment_amount from the members table."
        },
        "594": {
            "condition": "When answering about members approved from 1/10/2019 to 11/19/2019",
            "operation": " use date(SUBSTR(T1.expense_date, 1, 10)) BETWEEN '2019-01-10' AND '2019-11-19' AND T1.approved = 'true' for filtering instead of approval_date and attended conditions."
        },
        "595": {
            "condition": "When combining tables for this question",
            "operation": " use FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member to link expense, member, and attendance tables."
        },
        "596": {
            "condition": "When selecting output columns",
            "operation": " choose DISTINCT T1.link_to_member, T3.link_to_event instead of member_name, event_name, and event_link."
        },
        "597": {
            "condition": "When handling date ranges",
            "operation": " ensure the start date is '2019-01-10' (January 10th) not '2019-10-01' (October 1st)."
        },
        "598": {
            "condition": "When answering about members approved from 1/10/2019 to 11/19/2019, When combining tables for this question, When selecting output columns, When handling date ranges, When checking approval status",
            "operation": " use T1.approved = 'true' literal exactly as specified."
        },
        "599": {
            "condition": "When answering about \"college of the person whose first name is Katy with link to major 'rec1N0upiVLy5esTO'\"",
            "operation": " make sure the output order: T2.college"
        },
        "600": {
            "condition": "When the question mentions \"person\"",
            "operation": " \"person\" actually means \"member table (T1) in schema\""
        },
        "601": {
            "condition": "When the question mentions \"college\"",
            "operation": " \"college\" actually means \"college column in major table (T2) in schema\""
        },
        "602": {
            "condition": "When combining T1 (member) and T2 (major) for shared entities",
            "operation": " link rows where T2.major_id = T1.link_to_major exactly as shown in the amends; keep only matching pairs (inner match)"
        },
        "603": {
            "condition": "When filtering for first name \"Katy\"",
            "operation": " use T1.first_name = 'Katy' with exact case and spacing"
        },
        "604": {
            "condition": "When answering about \"college of the person whose first name is Katy with link to major 'rec1N0upiVLy5esTO'\", When the question mentions \"person\", When the question mentions \"college\", When combining T1 (member) and T2 (major) for shared entities, When filtering for first name \"Katy\", When filtering for major link \"rec1N0upiVLy5esTO\"",
            "operation": " use T1.link_to_major = 'rec1N0upiVLy5esTO' with exact identifier and literal"
        },
        "605": {
            "condition": "When the question asks for phone numbers",
            "operation": " select the exact column \"phone\" from table \"member\" instead of \"phone_number\" from \"members\"."
        },
        "606": {
            "condition": "When the question mentions members who majored in a specific subject",
            "operation": " join the \"major\" table with \"member\" using INNER JOIN where \"major_id = link_to_major\" to establish the proper relationship."
        },
        "607": {
            "condition": "When filtering for business majors",
            "operation": " use the exact condition \"major_name = 'Business'\" with proper capitalization instead of \"major = 'business'\"."
        },
        "608": {
            "condition": "When the question asks for phone numbers, When the question mentions members who majored in a specific subject, When filtering for business majors, When filtering for College of Agriculture and Applied Sciences",
            "operation": " apply the filter \"college = 'College of Agriculture and Applied Sciences'\" to the joined major table rather than the member table."
        },
        "609": {
            "condition": "When the question asks for emails of people",
            "operation": " select distinct \"email\" from the \"member\" table (as T1) instead of from \"payments\"."
        },
        "610": {
            "condition": "When combining member and expense information",
            "operation": " join \"member\" AS T1 with \"expense\" AS T2 using inner join where T1.\"member_id\" = T2.\"link_to_member\"."
        },
        "611": {
            "condition": "When filtering for payments over 20 dollars",
            "operation": " use T2.\"cost\" > 20 instead of \"amount\" > 20."
        },
        "612": {
            "condition": "When the question asks for emails of people, When combining member and expense information, When filtering for payments over 20 dollars, When filtering for dates from 9/10/2019 to 11/19/2019",
            "operation": " use date(SUBSTR(T2.\"expense_date\", 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19' instead of \"payment_date\" BETWEEN the same range."
        },
        "613": {
            "condition": "When counting members",
            "operation": " count using T1.member_id instead of counting all rows to avoid counting null values."
        },
        "614": {
            "condition": "When combining member and major information",
            "operation": " join member AS T1 with major AS T2 on T2.major_id = T1.link_to_major to connect members with their majors."
        },
        "615": {
            "condition": "When filtering for members only",
            "operation": " add filter T1.position = 'Member' to include only members, not other positions."
        },
        "616": {
            "condition": "When identifying education majors",
            "operation": " use T2.major_name LIKE '%Education%' instead of directly filtering on education_major column."
        },
        "617": {
            "condition": "When counting members, When combining member and major information, When filtering for members only, When identifying education majors, When filtering by college",
            "operation": " use T2.college = 'College of Education & Human Services' with exact case and spacing as specified."
        },
        "618": {
            "condition": "When calculating percentage of events that went over budget",
            "operation": " use the \"budget\" table instead of the \"events\" table."
        },
        "619": {
            "condition": "When counting occurrences where remaining is negative",
            "operation": " use SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) instead of counting when actual_cost exceeds budget."
        },
        "620": {
            "condition": "When counting total budget entries",
            "operation": " use COUNT(budget_id) instead of COUNT(*) to count only non-null budget_id values."
        },
        "621": {
            "condition": "When performing floating-point division",
            "operation": " cast the result to REAL using CAST(... AS REAL) instead of using 100.0."
        },
        "622": {
            "condition": "When calculating percentage of events that went over budget, When counting occurrences where remaining is negative, When counting total budget entries, When performing floating-point division, When calculating percentage",
            "operation": " multiply by 100 after division instead of before division."
        },
        "623": {
            "condition": "When calculating percentages",
            "operation": " perform division first then multiply by 100 to maintain correct mathematical operation precedence."
        },
        "624": {
            "condition": "When the question asks for \"percentage of events that went over budget\"",
            "operation": " count rows where remaining < 0 divided by total count of budget_id, then multiply by 100."
        },
        "625": {
            "condition": "When calculating percentages, When the question asks for \"percentage of events that went over budget\", When producing output columns",
            "operation": " omit explicit column aliases if the amends show they should be removed."
        },
        "626": {
            "condition": "When calculating a percentage",
            "operation": " perform the division first and then multiply by 100 to get the correct percentage value."
        },
        "627": {
            "condition": "When counting events that went over budget",
            "operation": " identify them as events where the remaining value is negative (remaining < 0)."
        },
        "628": {
            "condition": "When computing percentage of events",
            "operation": " use the formula (count of events meeting condition *"
        },
        "629": {
            "condition": "When calculating a percentage, When counting events that went over budget, When computing percentage of events, / total count of events.",
            "operation": "When calculating a percentage, When counting events that went over budget, When computing percentage of events, / total count of events."
        },
        "630": {
            "condition": "When the question asks about events",
            "operation": " use table \"event\" instead of \"events\" as the data source."
        },
        "631": {
            "condition": "When filtering by date range on the \"event_date\" column",
            "operation": " apply date(SUBSTR(event_date, 1, 10)) to extract and convert the date portion from the datetime/timestamp string format before comparison."
        },
        "632": {
            "condition": "When the question asks about events, When filtering by date range on the \"event_date\" column, When selecting output columns",
            "operation": " return event_id, location, and status in that order."
        },
        "633": {
            "condition": "When answering about \"expenses that spend more than fifty dollars on average\"",
            "operation": " make sure the output order: expense_description."
        },
        "634": {
            "condition": "When the question mentions \"expenses\"",
            "operation": " \"expenses\" actually means \"expense\" in schema."
        },
        "635": {
            "condition": "When the question mentions \"spend more than fifty dollars on average\"",
            "operation": " compute the average of \"cost\" column and keep only groups where this average is greater than 50."
        },
        "636": {
            "condition": "When the question asks for \"expenses\" by description",
            "operation": " organize results by expense_description and compute requested aggregates per group."
        },
        "637": {
            "condition": "When answering about \"expenses that spend more than fifty dollars on average\", When the question mentions \"expenses\", When the question mentions \"spend more than fifty dollars on average\", When the question asks for \"expenses\" by description, When producing output",
            "operation": " include only the expense_description column instead of all columns."
        },
        "638": {
            "condition": "When answering about \"expenses that spend more than fifty dollars on average\"",
            "operation": " make sure the output order: expense_description only, without including the average cost calculation in the results."
        },
        "639": {
            "condition": "When filtering groups by average cost exceeding 50",
            "operation": " apply the condition AVG(cost) > 50 to filter groups while keeping the expense_description in the output."
        },
        "640": {
            "condition": "When answering about \"expenses that spend more than fifty dollars on average\", When filtering groups by average cost exceeding 50, When the question asks for expense descriptions with average cost over 50",
            "operation": " return only the expense_description column for groups that meet the average cost threshold, not the calculated average values themselves."
        },
        "641": {
            "condition": "When the question asks for \"full name\" of members",
            "operation": " include both \"first_name\" and \"last_name\" in the output."
        },
        "642": {
            "condition": "When filtering by t-shirt size",
            "operation": " use the exact literal value 'X-Large' instead of 'XL'."
        },
        "643": {
            "condition": "When the question asks for \"full name\" of members, When filtering by t-shirt size, When referencing the member table",
            "operation": " use the exact table name \"member\" instead of \"members\"."
        },
        "644": {
            "condition": "When counting PO Box addresses",
            "operation": " use exact literal comparison \"type = 'PO Box'\" instead of pattern matching on zip_code."
        },
        "645": {
            "condition": "When calculating percentage of PO Box addresses",
            "operation": " count occurrences using SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) instead of COUNT with pattern matching."
        },
        "646": {
            "condition": "When performing division for percentage calculation",
            "operation": " cast the numerator to REAL data type for proper floating-point arithmetic."
        },
        "647": {
            "condition": "When calculating the denominator for percentage",
            "operation": " use COUNT(zip_code) instead of COUNT(*) to exclude null values from the count."
        },
        "648": {
            "condition": "When counting PO Box addresses, When calculating percentage of PO Box addresses, When performing division for percentage calculation, When calculating the denominator for percentage, When formatting the final output",
            "operation": " do not include an alias for the percentage calculation result."
        },
        "649": {
            "condition": "When answering about \"events that underspend its budget\"",
            "operation": " make sure the output order: T1.event_name, T1.location."
        },
        "650": {
            "condition": "When the question mentions \"name\"",
            "operation": " \"name\" actually means \"T1.event_name in schema\"."
        },
        "651": {
            "condition": "When the question mentions \"location\"",
            "operation": " \"location\" actually means \"T1.location in schema\"."
        },
        "652": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event; keep only matching pairs (inner match)."
        },
        "653": {
            "condition": "When answering about \"events that underspend its budget\", When the question mentions \"name\", When the question mentions \"location\", When combining T1 and T2 for shared entities, When filtering for underspending events",
            "operation": " use T2.remaining > 0 to identify events with positive remaining budget."
        },
        "654": {
            "condition": "When the question asks for event name and date",
            "operation": " select T1.event_name and T1.event_date as output columns."
        },
        "655": {
            "condition": "When combining events, budget, and expense tables",
            "operation": " link events (T1) to budget (T2) using T1.event_id = T2.link_to_event, then link budget (T2) to expense (T3) using T2.budget_id = T3.link_to_budget, keeping only matching pairs (inner joins)."
        },
        "656": {
            "condition": "When filtering for pizza expenses",
            "operation": " filter on T3.expense_description = 'Pizza' (exact case and spelling)."
        },
        "657": {
            "condition": "When the question asks for event name and date, When combining events, budget, and expense tables, When filtering for pizza expenses, When filtering for expenses between fifty and one hundred dollars",
            "operation": " filter on T3.cost > 50 AND T3.cost < 100 (exclusive range)."
        },
        "658": {
            "condition": "When answering about members who spent more than a hundred dollars on an expense",
            "operation": " make sure the output order: first_name, last_name, major_name."
        },
        "659": {
            "condition": "When the question mentions \"name\"",
            "operation": " \"name\" actually means \"first_name and last_name in schema\"."
        },
        "660": {
            "condition": "When the question mentions \"major\"",
            "operation": " \"major\" actually means \"major_name in schema\"."
        },
        "661": {
            "condition": "When combining T1 (members) and T2 (major) for shared entities",
            "operation": " link rows where T2.major_id = T1.link_to_major; keep only matching pairs (inner match)."
        },
        "662": {
            "condition": "When combining T1 (members) and T3 (expense) for shared entities",
            "operation": " link rows where T1.member_id = T3.link_to_member; keep only matching pairs (inner match)."
        },
        "663": {
            "condition": "When filtering for expenses over 100 dollars",
            "operation": " use T3.cost > 100 as the exact condition."
        },
        "664": {
            "condition": "When answering about members who spent more than a hundred dollars on an expense, When the question mentions \"name\", When the question mentions \"major\", When combining T1 (members) and T2 (major) for shared entities, When combining T1 (members) and T3 (expense) for shared entities, When filtering for expenses over 100 dollars, When selecting member information",
            "operation": " return distinct combinations of T1.first_name, T1.last_name, T2.major_name to avoid duplicate entries."
        },
        "665": {
            "condition": "When answering about events with more than forty incomes",
            "operation": " use a three-table join structure with INCOME as T1, member as T2, and zip_code as T3."
        },
        "666": {
            "condition": "When combining tables for shared entities",
            "operation": " link T1 to T2 where T1.link_to_member = T2.member_id, and link T2 to T3 where T3.zip_code = T2.zip, keeping only matching pairs (inner match)."
        },
        "667": {
            "condition": "When filtering for incomes greater than forty",
            "operation": " use T1.amount > 40 instead of income > 40."
        },
        "668": {
            "condition": "When selecting location data",
            "operation": " output T3.city and T3.county instead of city and country."
        },
        "669": {
            "condition": "When answering about events with more than forty incomes, When combining tables for shared entities, When filtering for incomes greater than forty, When selecting location data, When retrieving distinct results",
            "operation": " ensure the output includes DISTINCT to avoid duplicate rows."
        },
        "670": {
            "condition": "When answering about members who incurred expenses in more than one event",
            "operation": " use expense as T1, member as T2, budget as T3, and event as T4 with the exact aliases shown in the amends."
        },
        "671": {
            "condition": "When combining tables for shared entities",
            "operation": " link T1 to T2 where T1.link_to_member = T2.member_id, link T1 to T3 where T1.link_to_budget = T3.budget_id, and link T3 to T4 where T3.link_to_event = T4.event_id, keeping only matching pairs (inner match)."
        },
        "672": {
            "condition": "When grouping by member",
            "operation": " group by T2.member_id instead of member_name."
        },
        "673": {
            "condition": "When counting distinct events per member",
            "operation": " use COUNT(DISTINCT T4.event_id) > 1 to identify members with expenses in more than one event."
        },
        "674": {
            "condition": "When summing expenses",
            "operation": " use SUM(T1.cost) instead of SUM(amount) to calculate the total amount paid."
        },
        "675": {
            "condition": "When ordering results to find who paid the most",
            "operation": " order by SUM(T1.cost) descending."
        },
        "676": {
            "condition": "When answering about members who incurred expenses in more than one event, When combining tables for shared entities, When grouping by member, When counting distinct events per member, When summing expenses, When ordering results to find who paid the most, When selecting the top payer",
            "operation": " use LIMIT 1 to return only the member who paid the highest amount."
        },
        "677": {
            "condition": "When answering about members who incurred expenses in more than one event",
            "operation": " only include T2.member_id in the final output columns, not SUM(T1.cost)."
        },
        "678": {
            "condition": "When combining tables for this question",
            "operation": " use explicit INNER JOIN syntax instead of implicit JOIN syntax for clarity."
        },
        "679": {
            "condition": "When answering about members who incurred expenses in more than one event, When combining tables for this question, When filtering for members with expenses in multiple events",
            "operation": " use HAVING COUNT(DISTINCT T4.event_id) > 1 to identify members with expenses in more than one distinct event."
        },
        "680": {
            "condition": "When answering about \"average amount paid by students in a position other than a member\"",
            "operation": " use table \"expense AS T1\" and compute AVG(T1.cost) instead of AVG(amount)."
        },
        "681": {
            "condition": "When combining expense and member tables",
            "operation": " perform an INNER JOIN between T1 and member AS T2 on T1.link_to_member = T2.member_id instead of querying a single table."
        },
        "682": {
            "condition": "When answering about \"average amount paid by students in a position other than a member\", When combining expense and member tables, When filtering for non-member positions",
            "operation": " apply the condition T2.position != 'Member' instead of position != 'member', using exact case-sensitive literal 'Member' and proper table reference."
        },
        "683": {
            "condition": "When answering about \"events with less than average parking cost\"",
            "operation": " make sure the output order: T1.event_name."
        },
        "684": {
            "condition": "When the question mentions \"events\"",
            "operation": " use table \"event AS T1\" instead of \"events\"."
        },
        "685": {
            "condition": "When the question mentions \"parking cost\"",
            "operation": " \"parking cost\" actually means \"T2.category = 'Parking' AND T3.cost\" in schema."
        },
        "686": {
            "condition": "When combining T1, T2, and T3 for shared entities",
            "operation": " link rows where T1.event_id = T2.link_to_event and T2.budget_id = T3.link_to_budget; keep only matching pairs (inner match)."
        },
        "687": {
            "condition": "When computing average parking cost",
            "operation": " calculate the average of T3.cost where T2.category = 'Parking'."
        },
        "688": {
            "condition": "When answering about \"events with less than average parking cost\", When the question mentions \"events\", When the question mentions \"parking cost\", When combining T1, T2, and T3 for shared entities, When computing average parking cost, When filtering for events with less than average parking cost",
            "operation": " include only rows where T2.category = 'Parking' AND T3.cost < (average parking cost)."
        },
        "689": {
            "condition": "When calculating average parking cost",
            "operation": " compute the overall average cost from the expense table using just SELECT AVG(cost) FROM expense instead of joining with budget table and filtering by category."
        },
        "690": {
            "condition": "When filtering for parking expenses",
            "operation": " use the outer query's budget category filter (T2.category = 'Parking') to identify parking-related expenses, not the subquery."
        },
        "691": {
            "condition": "When calculating average parking cost, When filtering for parking expenses, When comparing expense costs against average",
            "operation": " use the simplified subquery result to compare T3.cost < (overall average cost) without redundant joins in the subquery."
        },
        "692": {
            "condition": "When calculating percentage of meeting event costs",
            "operation": " use SUM(CASE WHEN T1.type = 'Meeting' THEN T3.cost ELSE 0 END) * 100 / SUM(T3.cost) instead of simple division"
        },
        "693": {
            "condition": "When combining event and budget tables",
            "operation": " link rows where T1.event_id = T2.link_to_event using inner join"
        },
        "694": {
            "condition": "When combining budget and expense tables",
            "operation": " link rows where T2.budget_id = T3.link_to_budget using inner join"
        },
        "695": {
            "condition": "When calculating percentage of meeting event costs, When combining event and budget tables, When combining budget and expense tables, When the question asks for percentage of meeting events",
            "operation": " do not use an alias for the percentage calculation"
        },
        "696": {
            "condition": "When the question asks about budgets and expenses",
            "operation": " combine tables expense as T1 and budget as T2 using inner match where T1.link_to_budget = T2.budget_id."
        },
        "697": {
            "condition": "When the question mentions \"water, chips, and cookies\"",
            "operation": " filter for T1.expense_description = 'Water, chips, cookies' exactly."
        },
        "698": {
            "condition": "When the question asks for \"which budget allowed the most money\"",
            "operation": " order results by T1.cost in descending order and take the first row."
        },
        "699": {
            "condition": "When the question asks about budgets and expenses, When the question mentions \"water, chips, and cookies\", When the question asks for \"which budget allowed the most money\", When producing output",
            "operation": " return T2.budget_id instead of budget_name."
        },
        "700": {
            "condition": "When the question asks for \"which budget allowed the most money for water, chips, and cookies\"",
            "operation": " select only the budget_id column from the budget table (T2)."
        },
        "701": {
            "condition": "When calculating the total cost for water, chips, and cookies",
            "operation": " sum the individual budget amounts (water_budget + chips_budget + cookies_budget) rather than using MAX aggregate function."
        },
        "702": {
            "condition": "When filtering for expenses related to water, chips, and cookies",
            "operation": " use the exact literal 'Water, chips, cookies' for the expense_description condition."
        },
        "703": {
            "condition": "When joining expense and budget tables",
            "operation": " link rows where T1.link_to_budget equals T2.budget_id using an inner join."
        },
        "704": {
            "condition": "When the question asks for \"which budget allowed the most money for water, chips, and cookies\", When calculating the total cost for water, chips, and cookies, When filtering for expenses related to water, chips, and cookies, When joining expense and budget tables, When determining the highest cost",
            "operation": " order the results by the total calculated sum in descending order and return only the top result."
        },
        "705": {
            "condition": "When answering about \"top five members who spend the most money\"",
            "operation": " make sure the output order: T3.first_name, T3.last_name."
        },
        "706": {
            "condition": "When the question mentions \"members\"",
            "operation": " \"members\" actually means \"member table as T3\" in schema."
        },
        "707": {
            "condition": "When the question mentions \"top\", \"highest\", or \"most money\"",
            "operation": " rank rows by T2.spent in descending order and keep the first 5 rows."
        },
        "708": {
            "condition": "When combining expense, budget, and member tables",
            "operation": " link rows where T1.link_to_budget = T2.budget_id and T1.link_to_member = T3.member_id; keep only matching pairs (inner match)."
        },
        "709": {
            "condition": "When answering about \"top five members who spend the most money\", When the question mentions \"members\", When the question mentions \"top\", \"highest\", or \"most money\", When combining expense, budget, and member tables, When selecting member information",
            "operation": " use T3.first_name and T3.last_name from the member table instead of direct columns from unspecified sources."
        },
        "710": {
            "condition": "When the question asks for \"full name and contact number\"",
            "operation": " select distinct \"T3\".\"first_name\", \"T3\".\"last_name\", \"T3\".\"phone\" instead of m.first_name, m.last_name, m.contact_number."
        },
        "711": {
            "condition": "When combining tables for expense analysis",
            "operation": " use INNER JOIN \"budget\" AS \"T2\" ON \"T1\".\"link_to_budget\" = \"T2\".\"budget_id\" and INNER JOIN \"member\" AS \"T3\" ON \"T3\".\"member_id\" = \"T1\".\"link_to_member\" instead of a single join on expenses."
        },
        "712": {
            "condition": "When filtering for expenses above average",
            "operation": " use \"T1\".\"cost\" > (correlated subquery) instead of e.amount > (simple average)."
        },
        "713": {
            "condition": "When deduplicating results",
            "operation": " use DISTINCT instead of GROUP BY \"T3\".\"member_id\"."
        },
        "714": {
            "condition": "When the question asks for \"full name and contact number\", When combining tables for expense analysis, When filtering for expenses above average, When deduplicating results, When computing average expense cost",
            "operation": " use a correlated subquery that joins the same three tables instead of a simple average from a single table."
        },
        "715": {
            "condition": "When calculating percentages of members by state",
            "operation": " join the member table (T1) with the zip_code table (T2) using the exact key equality T1.zip_code = T2.zip_code instead of querying members directly."
        },
        "716": {
            "condition": "When counting members",
            "operation": " use T1.member_id for counting instead of COUNT(*) from a separate table."
        },
        "717": {
            "condition": "When computing state-specific counts",
            "operation": " use SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) and SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END) expressions instead of multiple subqueries."
        },
        "718": {
            "condition": "When calculating percentage difference",
            "operation": " compute the difference between state counts directly using SUM(CASE) expressions instead of subtracting percentage results."
        },
        "719": {
            "condition": "When handling numeric results",
            "operation": " cast the final result to REAL type instead of using implicit conversion."
        },
        "720": {
            "condition": "When calculating percentages of members by state, When counting members, When computing state-specific counts, When calculating percentage difference, When handling numeric results, When organizing the query",
            "operation": " use proper table aliases T1 for member table and T2 for zip_code table instead of no aliases."
        },
        "721": {
            "condition": "When the question asks about a person's major and department",
            "operation": " select T2.major_name and T2.department as output columns."
        },
        "722": {
            "condition": "When querying for information about a person",
            "operation": " use FROM member AS T1 INNER JOIN major AS T2 instead of a single table."
        },
        "723": {
            "condition": "When joining member and major tables",
            "operation": " link rows where T2.major_id = T1.link_to_major to establish the proper relationship."
        },
        "724": {
            "condition": "When the question asks about a person's major and department, When querying for information about a person, When joining member and major tables, When filtering by a person's name",
            "operation": " use T1.first_name = 'Garrett' AND T1.last_name = 'Gerke' instead of a single name field, matching the exact case and spacing of the literal values."
        },
        "725": {
            "condition": "When the question asks for spending on specific items",
            "operation": " use exact literal 'Water, Veggie tray, supplies' for expense_description filtering instead of separate item names."
        },
        "726": {
            "condition": "When selecting member information and cost",
            "operation": " use T2.first_name, T2.last_name, and T1.cost directly without aggregation."
        },
        "727": {
            "condition": "When joining member and expense tables",
            "operation": " link using T1.link_to_member = T2.member_id for direct member association."
        },
        "728": {
            "condition": "When the source data structure changes",
            "operation": " use FROM expense AS T1 as the primary table instead of members table."
        },
        "729": {
            "condition": "When the question asks for spending on specific items, When selecting member information and cost, When joining member and expense tables, When the source data structure changes, When the question requires individual expense records",
            "operation": " remove GROUP BY, ORDER BY, and LIMIT operations that aggregate and rank results."
        },
        "730": {
            "condition": "When the question asks for \"last names\" and \"phone numbers\" of students",
            "operation": " use columns \"T1.last_name\" and \"T1.phone\" exactly as specified in the schema."
        },
        "731": {
            "condition": "When filtering by \"Elementary Education\" major",
            "operation": " join table \"member AS T1\" with \"major AS T2\" using \"T2.major_id = T1.link_to_major\" and filter with \"T2.major_name = 'Elementary Education'\" exactly."
        },
        "732": {
            "condition": "When the question asks for \"last names\" and \"phone numbers\" of students, When filtering by \"Elementary Education\" major, When combining member and major tables",
            "operation": " perform an inner join to keep only matching pairs where the major ID relationship exists."
        },
        "733": {
            "condition": "When answering about budget information for a specific event",
            "operation": " join table \"event\" as T1 with table \"budget\" as T2 using T1.event_id = T2.link_to_event to establish the proper relationship between events and their budgets."
        },
        "734": {
            "condition": "When the question mentions 'January Speaker' event",
            "operation": " filter using T1.event_name = 'January Speaker' exactly as specified."
        },
        "735": {
            "condition": "When retrieving budget category and amount",
            "operation": " reference the columns as T2.category and T2.amount from the budget table."
        },
        "736": {
            "condition": "When answering about budget information for a specific event, When the question mentions 'January Speaker' event, When retrieving budget category and amount, When only one matching record exists due to the join relationship",
            "operation": " do not apply ordering or limiting operations that would unnecessarily restrict the results."
        },
        "737": {
            "condition": "When answering about \"event names which were budgeted for the food\"",
            "operation": " make sure the output order: T1.event_name."
        },
        "738": {
            "condition": "When combining event and budget tables",
            "operation": " link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match)."
        },
        "739": {
            "condition": "When the question mentions \"budgeted for the food\"",
            "operation": " \"food\" actually means T2.category = 'Food' in schema (with exact case sensitivity)."
        },
        "740": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "741": {
            "condition": "When answering about \"event names which were budgeted for the food\", When combining event and budget tables, When the question mentions \"budgeted for the food\", When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use 'Food' exactly as specified."
        },
        "742": {
            "condition": "When answering about students who received funds",
            "operation": " use the exact identifier \"member\" as table T3 instead of \"students\" and select \"T3.first_name\" and \"T3.last_name\" for student names."
        },
        "743": {
            "condition": "When the question mentions \"received funds on the date of 9/9/2019\"",
            "operation": " filter using \"T4.date_received = '2019-09-09'\" instead of funds.date, and include \"T4.amount\" for the amount received."
        },
        "744": {
            "condition": "When combining tables for this query",
            "operation": " perform inner joins where T1.event_id = T2.link_to_event, T3.member_id = T2.link_to_member, and T4.link_to_member = T3.member_id to establish proper relationships between event, attendance, member, and income tables."
        },
        "745": {
            "condition": "When retrieving distinct student information",
            "operation": " use DISTINCT to ensure each student appears only once in the results."
        },
        "746": {
            "condition": "When answering about students who received funds, When the question mentions \"received funds on the date of 9/9/2019\", When combining tables for this query, When retrieving distinct student information, When handling the date literal",
            "operation": " preserve the exact format '2019-09-09' as shown in the amends."
        },
        "747": {
            "condition": "When the question asks about budget category for an expense",
            "operation": " join table \"expense\" as T1 with table \"budget\" as T2 using inner join where T1.link_to_budget = T2.budget_id."
        },
        "748": {
            "condition": "When filtering for expense 'Posters'",
            "operation": " use T1.expense_description = 'Posters' exactly as written."
        },
        "749": {
            "condition": "When the question asks about budget category for an expense, When filtering for expense 'Posters', When selecting the category",
            "operation": " use DISTINCT T2.category to eliminate duplicate category values."
        },
        "750": {
            "condition": "When answering about club members and their colleges",
            "operation": " use table \"member\" as T1 and table \"major\" as T2 instead of using \"club_members\" directly."
        },
        "751": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T2.major_id = T1.link_to_major and keep only matching pairs (inner match)."
        },
        "752": {
            "condition": "When selecting member information",
            "operation": " qualify columns as T1.first_name and T1.last_name instead of using unqualified column references."
        },
        "753": {
            "condition": "When answering about club members and their colleges, When combining member and major tables, When selecting member information, When filtering for position",
            "operation": " use condition T1.position = 'Secretary' with exact literal 'Secretary'."
        },
        "754": {
            "condition": "When answering about club member names",
            "operation": " output first_name and last_name as separate columns instead of concatenating them into a full_name."
        },
        "755": {
            "condition": "When the question asks for a club member with position 'Secretary'",
            "operation": " filter rows where T1.position equals exactly 'Secretary'."
        },
        "756": {
            "condition": "When combining member and major tables",
            "operation": " link rows where T2.major_id equals T1.link_to_major and keep only matching pairs (inner match)."
        },
        "757": {
            "condition": "When answering about club member names, When the question asks for a club member with position 'Secretary', When combining member and major tables, When the question asks for which college a club member belongs to",
            "operation": " include T2.college in the output columns."
        },
        "758": {
            "condition": "When answering about \"total amount spent on speaker gifts and event names\"",
            "operation": " make sure the output order: T2.event_name, SUM(T1.spent)."
        },
        "759": {
            "condition": "When the question mentions \"speaker gifts\"",
            "operation": " \"speaker gifts\" actually means \"T1.category = 'Speaker Gifts'\" in schema."
        },
        "760": {
            "condition": "When combining budget as T1 and event as T2",
            "operation": " link rows where T1.link_to_event = T2.event_id exactly as shown; keep only matching pairs (inner match)."
        },
        "761": {
            "condition": "When the question asks for \"total amount spent\"",
            "operation": " compute the sum of T1.spent."
        },
        "762": {
            "condition": "When answering about \"total amount spent on speaker gifts and event names\", When the question mentions \"speaker gifts\", When combining budget as T1 and event as T2, When the question asks for \"total amount spent\", When the question says \"per event\"/\"by event\"",
            "operation": " organize results by T2.event_name and compute requested aggregates per group."
        },
        "763": {
            "condition": "When answering about \"total amount spent on speaker gifts and list the name of the event\"",
            "operation": " make sure the output order: SUM(T1.spent) before T2.event_name."
        },
        "764": {
            "condition": "When the question asks for \"total amount spent\"",
            "operation": " compute the sum of T1.spent."
        },
        "765": {
            "condition": "When the question mentions \"speaker gifts\"",
            "operation": " \"speaker gifts\" actually means T1.category = 'Speaker Gifts' in the schema."
        },
        "766": {
            "condition": "When combining budget table (T1) and event table (T2)",
            "operation": " link rows where T1.link_to_event = T2.event_id and keep only matching pairs (inner match)."
        },
        "767": {
            "condition": "When the question asks for results \"by event\"",
            "operation": " organize results by T2.event_name and compute the sum per group."
        },
        "768": {
            "condition": "When answering about \"total amount spent on speaker gifts and list the name of the event\", When the question asks for \"total amount spent\", When the question mentions \"speaker gifts\", When combining budget table (T1) and event table (T2), When the question asks for results \"by event\", When producing output",
            "operation": " do not add aliases like total_spent to aggregated columns."
        },
        "769": {
            "condition": "When answering about \"hometown of Garrett Gerke\"",
            "operation": " make sure the output order: T2.city"
        },
        "770": {
            "condition": "When the question mentions \"hometown\"",
            "operation": " \"hometown\" actually means \"city in schema\" from the zip_code table"
        },
        "771": {
            "condition": "When combining T1 (member) and T2 (zip_code) for shared entities",
            "operation": " link rows where T2.zip_code = T1.zip exactly as shown; keep only matching pairs (inner match)"
        },
        "772": {
            "condition": "When answering about \"hometown of Garrett Gerke\", When the question mentions \"hometown\", When combining T1 (member) and T2 (zip_code) for shared entities, When filtering for a specific person",
            "operation": " use exact literals T1.first_name = 'Garrett' AND T1.last_name = 'Gerke' with the correct case and spacing"
        },
        "773": {
            "condition": "When answering about students with hometown information",
            "operation": " select from \"member\" AS T1 instead of \"students\" table."
        },
        "774": {
            "condition": "When the question mentions \"hometown of Lincolnton, North Carolina\"",
            "operation": " use T2.city = 'Lincolnton' and T2.state = 'North Carolina' instead of hometown filtering."
        },
        "775": {
            "condition": "When the question mentions \"zip code of 28092\"",
            "operation": " use T2.zip_code = 28092 (numeric value) instead of string comparison."
        },
        "776": {
            "condition": "When combining member and zip_code information",
            "operation": " link rows where T2.zip_code = T1.zip using INNER JOIN and keep only matching pairs."
        },
        "777": {
            "condition": "When selecting output columns",
            "operation": " use T1.first_name, T1.last_name, and T1.position with exact table aliases."
        },
        "778": {
            "condition": "When answering about students with hometown information, When the question mentions \"hometown of Lincolnton, North Carolina\", When the question mentions \"zip code of 28092\", When combining member and zip_code information, When selecting output columns, When handling zip code values",
            "operation": " treat zip_code as numeric type, not string type."
        }
    },
    "debit_card_specializing": {
        "0": {
            "condition": "When counting gas stations",
            "operation": " use the exact column name \"GasStationID\" from the gasstations table instead of counting all columns."
        },
        "1": {
            "condition": "When filtering by country 'CZE'",
            "operation": " use the exact column name \"Country\" with exact literal value 'CZE' (case-sensitive)."
        },
        "2": {
            "condition": "When filtering by gas type 'Premium'",
            "operation": " use the exact column name \"Segment\" with exact literal value 'Premium' instead of 'gas_type'."
        },
        "3": {
            "condition": "When counting gas stations, When filtering by country 'CZE', When filtering by gas type 'Premium', When referencing the gas stations table",
            "operation": " use the exact table name \"gasstations\" instead of \"gas_stations\"."
        },
        "4": {
            "condition": "When calculating a ratio of customers by currency",
            "operation": " use conditional aggregation with SUM(IIF(Currency = 'EUR', 1, 0)) for EUR customers and SUM(IIF(Currency = 'CZK', 1, 0)) for CZK customers instead of separate subqueries."
        },
        "5": {
            "condition": "When performing division between aggregated counts",
            "operation": " explicitly CAST the numerator to FLOAT to ensure proper type handling."
        },
        "6": {
            "condition": "When computing ratios",
            "operation": " calculate directly from aggregated counts in the main query rather than using division between separate subquery results."
        },
        "7": {
            "condition": "When calculating a ratio of customers by currency, When performing division between aggregated counts, When computing ratios, When handling currency values",
            "operation": " use exact literals 'EUR' and 'CZK' with the exact case and spelling as specified."
        },
        "8": {
            "condition": "When answering about \"who had the least consumption in LAM in 2012\"",
            "operation": " make sure the output order: T1.CustomerID."
        },
        "9": {
            "condition": "When the question mentions \"consumption\"",
            "operation": " \"consumption\" actually means \"T2.Consumption in schema\"."
        },
        "10": {
            "condition": "When the question mentions \"least\" or \"lowest\"",
            "operation": " rank rows by SUM(T2.Consumption) in ascending order and keep the first 1 row."
        },
        "11": {
            "condition": "When the question asks about \"in LAM\"",
            "operation": " filter rows where T1.Segment = 'LAM'."
        },
        "12": {
            "condition": "When the question asks about \"in 2012\"",
            "operation": " filter rows where SUBSTR(T2.Date, 1,"
        },
        "13": {
            "condition": "= '2012'.",
            "operation": "= '2012'."
        },
        "14": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)."
        },
        "15": {
            "condition": "When answering about \"who had the least consumption in LAM in 2012\", When the question mentions \"consumption\", When the question mentions \"least\" or \"lowest\", When the question asks about \"in LAM\", When the question asks about \"in 2012\", = '2012'., When combining T1 and T2 for shared entities, When computing total consumption per customer",
            "operation": " group results by T1.CustomerID and compute SUM(T2.Consumption) per group."
        },
        "16": {
            "condition": "When the question asks about average monthly consumption",
            "operation": " calculate the average of T2.Consumption divided by 12 to get the annual average directly instead of grouping by month."
        },
        "17": {
            "condition": "When the question mentions customers in SME",
            "operation": " filter using T1.Segment = 'SME' instead of customer_type."
        },
        "18": {
            "condition": "When the question specifies the year 2013",
            "operation": " filter using SUBSTR(T2.Date, 1,"
        },
        "19": {
            "condition": "= '2013' instead of a year column.",
            "operation": "= '2013' instead of a year column."
        },
        "20": {
            "condition": "When combining customer and consumption data",
            "operation": " join tables using T1.CustomerID = T2.CustomerID with an inner match."
        },
        "21": {
            "condition": "When the question asks about average monthly consumption, When the question mentions customers in SME, When the question specifies the year 2013, = '2013' instead of a year column., When combining customer and consumption data, When selecting consumption data",
            "operation": " use T2.Consumption as the source instead of a consumption column from the customers table."
        },
        "22": {
            "condition": "When answering about customers paying in CZK",
            "operation": " filter using T1.Currency = 'CZK' exactly as written."
        },
        "23": {
            "condition": "When answering about gas consumption in 2011",
            "operation": " filter using T2.Date BETWEEN 201101 AND 201112 inclusive range."
        },
        "24": {
            "condition": "When combining customer and consumption data",
            "operation": " perform an inner join where T1.CustomerID = T2.CustomerID and keep only matching pairs."
        },
        "25": {
            "condition": "When grouping results by customer",
            "operation": " group by T1.CustomerID instead of customer_name."
        },
        "26": {
            "condition": "When calculating total gas consumption",
            "operation": " sum T2.Consumption values."
        },
        "27": {
            "condition": "When ordering results to find the highest consumption",
            "operation": " order by SUM(T2.Consumption) in descending direction."
        },
        "28": {
            "condition": "When answering about customers paying in CZK, When answering about gas consumption in 2011, When combining customer and consumption data, When grouping results by customer, When calculating total gas consumption, When ordering results to find the highest consumption, When selecting output columns",
            "operation": " include T1.CustomerID instead of customer_name and the sum of consumption."
        },
        "29": {
            "condition": "When the question asks for customers who consumed the most gas",
            "operation": " rank customers by total gas consumption in descending order and keep only the top 1 result."
        },
        "30": {
            "condition": "When the question specifies paying in CZK",
            "operation": " filter customers where T1.Currency equals exactly 'CZK'."
        },
        "31": {
            "condition": "When the question specifies the year 2011",
            "operation": " filter yearmonth records where T2.Date is between 201101 and 201112 (numeric values without quotes)."
        },
        "32": {
            "condition": "When combining customers and yearmonth tables",
            "operation": " link rows where T1.CustomerID equals T2.CustomerID and keep only matching pairs."
        },
        "33": {
            "condition": "When computing gas consumption",
            "operation": " sum the T2.Consumption values for each customer."
        },
        "34": {
            "condition": "When the question asks for customers who consumed the most gas, When the question specifies paying in CZK, When the question specifies the year 2011, When combining customers and yearmonth tables, When computing gas consumption, When answering about customers with highest consumption",
            "operation": " make sure the output order includes only T1.CustomerID (do not include the sum in the output columns)."
        },
        "35": {
            "condition": "When the question mentions \"customers in KAM\"",
            "operation": " use \"T1.Segment = 'KAM'\" for filtering instead of region-based filtering."
        },
        "36": {
            "condition": "When filtering for year 2012",
            "operation": " extract year from date using \"SUBSTRING(T2.Date, 1,"
        },
        "37": {
            "condition": "= '2012'\" instead of a direct year column.",
            "operation": "= '2012'\" instead of a direct year column."
        },
        "38": {
            "condition": "When combining customer and consumption data",
            "operation": " join \"yearmonth\" table with \"customers\" table using \"T1.CustomerID = T2.CustomerID\" with inner join."
        },
        "39": {
            "condition": "When calculating total consumption per customer",
            "operation": " group by \"T2.CustomerID\" and compute \"SUM(T2.Consumption)\" for each customer."
        },
        "40": {
            "condition": "When filtering for consumption less than 30,000",
            "operation": " apply \"HAVING SUM(T2.Consumption) < 30000\" after grouping instead of filtering individual records."
        },
        "41": {
            "condition": "When the question mentions \"customers in KAM\", When filtering for year 2012, = '2012'\" instead of a direct year column., When combining customer and consumption data, When calculating total consumption per customer, When filtering for consumption less than 30,000, When counting customers",
            "operation": " wrap the grouped query in a subquery and count the distinct customer IDs rather than counting all records directly."
        },
        "42": {
            "condition": "When answering about gas consumption difference between currency types",
            "operation": " use conditional aggregation with IIF functions instead of separate subqueries."
        },
        "43": {
            "condition": "When combining customer and yearmonth data",
            "operation": " perform an inner join between customers table (T1) and yearmonth table (T2) using CustomerID equality (T1.CustomerID = T2.CustomerID)."
        },
        "44": {
            "condition": "When referencing consumption data",
            "operation": " use T2.Consumption instead of gas_consumption column."
        },
        "45": {
            "condition": "When filtering for year 2012",
            "operation": " use SUBSTR(T2.Date, 1,"
        },
        "46": {
            "condition": "= '2012' on the date field instead of a year column filter.",
            "operation": "= '2012' on the date field instead of a year column filter."
        },
        "47": {
            "condition": "When calculating currency-specific sums",
            "operation": " use IIF(T1.currency = 'CZK', T2.Consumption,"
        },
        "48": {
            "condition": "for CZK-paying customers and IIF(T1.currency = 'EUR', T2.Consumption,",
            "operation": "for CZK-paying customers and IIF(T1.currency = 'EUR', T2.Consumption,"
        },
        "49": {
            "condition": "for EUR-paying customers.",
            "operation": "for EUR-paying customers."
        },
        "50": {
            "condition": "When answering about gas consumption difference between currency types, When combining customer and yearmonth data, When referencing consumption data, When filtering for year 2012, = '2012' on the date field instead of a year column filter., When calculating currency-specific sums, for CZK-paying customers and IIF(T1.currency = 'EUR', T2.Consumption,, for EUR-paying customers., When computing the final difference",
            "operation": " calculate SUM(IIF(T1.currency = 'CZK', T2.Consumption, 0)) - SUM(IIF(T1.currency = 'EUR', T2.Consumption, 0)) as consumption_difference."
        },
        "51": {
            "condition": "When answering about \"year with most gas use paid in EUR\"",
            "operation": " make sure the output order: year column first."
        },
        "52": {
            "condition": "When the question mentions \"year\"",
            "operation": " \"year\" actually means \"SUBSTRING(T2.Date, 1, 4)\" in schema."
        },
        "53": {
            "condition": "When the question mentions \"most gas use\"",
            "operation": " \"gas use\" actually means \"SUM(T2.Consumption)\" in schema."
        },
        "54": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)."
        },
        "55": {
            "condition": "When the question mentions \"paid in EUR\"",
            "operation": " add filter WHERE T1.Currency = 'EUR' using exact literal 'EUR'."
        },
        "56": {
            "condition": "When the question asks for \"most\" (highest)",
            "operation": " rank rows by SUM(T2.Consumption) in descending order and keep the first 1 row."
        },
        "57": {
            "condition": "When the question asks for results \"by year\"",
            "operation": " organize results by SUBSTRING(T2.Date, 1,"
        },
        "58": {
            "condition": "When answering about \"year with most gas use paid in EUR\", When the question mentions \"year\", When the question mentions \"most gas use\", When combining T1 and T2 for shared entities, When the question mentions \"paid in EUR\", When the question asks for \"most\" (highest), When the question asks for results \"by year\", and compute SUM(T2.Consumption) per group.",
            "operation": "When answering about \"year with most gas use paid in EUR\", When the question mentions \"year\", When the question mentions \"most gas use\", When combining T1 and T2 for shared entities, When the question mentions \"paid in EUR\", When the question asks for \"most\" (highest), When the question asks for results \"by year\", and compute SUM(T2.Consumption) per group."
        },
        "59": {
            "condition": "When answering about \"which segment had the least consumption\"",
            "operation": " make sure the output order: T1.Segment."
        },
        "60": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)."
        },
        "61": {
            "condition": "When the question asks for \"least consumption\"",
            "operation": " rank rows by SUM(T2.Consumption) in ascending order and keep the first 1 row."
        },
        "62": {
            "condition": "When answering about \"which segment had the least consumption\", When combining T1 and T2 for shared entities, When the question asks for \"least consumption\", When the question says \"by segment\"",
            "operation": " organize results by T1.Segment and compute SUM(T2.Consumption) per group."
        },
        "63": {
            "condition": "When answering about \"year with most consumption of gas paid in CZK\"",
            "operation": " extract year from T2.Date using SUBSTR(T2.Date, 1,"
        },
        "64": {
            "condition": "instead of using a year column directly.",
            "operation": "instead of using a year column directly."
        },
        "65": {
            "condition": "When combining customer and consumption data",
            "operation": " join customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID to link customer currency information with consumption records."
        },
        "66": {
            "condition": "When filtering for CZK currency",
            "operation": " use T1.Currency = 'CZK' exactly as specified."
        },
        "67": {
            "condition": "When grouping by year",
            "operation": " use GROUP BY SUBSTR(T2.Date, 1,"
        },
        "68": {
            "condition": "to aggregate consumption data annually.",
            "operation": "to aggregate consumption data annually."
        },
        "69": {
            "condition": "When ordering by highest consumption",
            "operation": " order by SUM(T2.Consumption) DESC to rank years by total consumption."
        },
        "70": {
            "condition": "When answering about \"year with most consumption of gas paid in CZK\", instead of using a year column directly., When combining customer and consumption data, When filtering for CZK currency, When grouping by year, to aggregate consumption data annually., When ordering by highest consumption, When selecting the top result",
            "operation": " return only the first row after ordering to get the year with maximum consumption."
        },
        "71": {
            "condition": "When answering about \"which year recorded the most consumption of gas paid in CZK\"",
            "operation": " make sure the output order: year only without column aliases."
        },
        "72": {
            "condition": "When the question mentions \"consumption of gas paid in CZK\"",
            "operation": " \"CZK\" actually means \"Currency = 'CZK'\" in the customers table."
        },
        "73": {
            "condition": "When the question asks for \"most consumption\"",
            "operation": " rank rows by total consumption in descending order and keep the first 1 row."
        },
        "74": {
            "condition": "When the question asks for \"year\"",
            "operation": " extract year from the Date column using SUBSTR(T2.Date, 1, 4)."
        },
        "75": {
            "condition": "When combining customers as T1 and yearmonth as T2",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match)."
        },
        "76": {
            "condition": "When answering about \"which year recorded the most consumption of gas paid in CZK\", When the question mentions \"consumption of gas paid in CZK\", When the question asks for \"most consumption\", When the question asks for \"year\", When combining customers as T1 and yearmonth as T2, When grouping by year",
            "operation": " organize results by the extracted year value and compute SUM(T2.Consumption) per group."
        },
        "77": {
            "condition": "When extracting month from date",
            "operation": " use SUBSTR(T2.Date, 5,"
        },
        "78": {
            "condition": "to get the month part from the Date column instead of a direct month column.",
            "operation": "to get the month part from the Date column instead of a direct month column."
        },
        "79": {
            "condition": "When combining customer and consumption data",
            "operation": " join customers AS T1 with yearmonth AS T2 on T1.CustomerID = T2.CustomerID using an inner match."
        },
        "80": {
            "condition": "When filtering for year 2013",
            "operation": " use SUBSTR(T2.Date, 1,"
        },
        "81": {
            "condition": "= '2013' to extract the year from the Date column instead of a direct year column.",
            "operation": "= '2013' to extract the year from the Date column instead of a direct year column."
        },
        "82": {
            "condition": "When filtering for SME customers",
            "operation": " use T1.Segment = 'SME' instead of customer_type = 'SME'."
        },
        "83": {
            "condition": "When calculating gas consumption",
            "operation": " use SUM(T2.Consumption) to aggregate monthly totals instead of MAX(gas_consumption)."
        },
        "84": {
            "condition": "When ordering results",
            "operation": " sort by the sum of consumption in descending order to find the peak month."
        },
        "85": {
            "condition": "When extracting month from date, to get the month part from the Date column instead of a direct month column., When combining customer and consumption data, When filtering for year 2013, = '2013' to extract the year from the Date column instead of a direct year column., When filtering for SME customers, When calculating gas consumption, When ordering results, When answering about the gas consumption peak month",
            "operation": " make sure the output order includes the month and the total consumption value."
        },
        "86": {
            "condition": "When answering about gas consumption peak month",
            "operation": " make sure the output order includes only the month portion without an alias."
        },
        "87": {
            "condition": "When the question asks for peak consumption",
            "operation": " order results by the sum of consumption in descending direction and keep only the first row."
        },
        "88": {
            "condition": "When combining customers and yearmonth tables",
            "operation": " link rows where T1.CustomerID = T2.CustomerID using an inner match."
        },
        "89": {
            "condition": "When filtering for SME customers and year 2013",
            "operation": " apply both conditions with T1.Segment = 'SME' and SUBSTR(T2.Date, 1,"
        },
        "90": {
            "condition": "= '2013' exactly as specified.",
            "operation": "= '2013' exactly as specified."
        },
        "91": {
            "condition": "When answering about gas consumption peak month, When the question asks for peak consumption, When combining customers and yearmonth tables, When filtering for SME customers and year 2013, = '2013' exactly as specified., When grouping by month",
            "operation": " group by the month portion extracted from T2.Date using SUBSTR(T2.Date, 5, 2)."
        },
        "92": {
            "condition": "When answering about annual average consumption differences between customer segments",
            "operation": " make sure the output order includes all three comparisons in a single row with separate columns instead of multiple rows."
        },
        "93": {
            "condition": "When the question mentions \"customers with the least amount of consumption\"",
            "operation": " filter to only include rows where T2.Consumption equals the minimum consumption value from the yearmonth table."
        },
        "94": {
            "condition": "When the question specifies \"paid in CZK\"",
            "operation": " add filter condition T1.Currency = 'CZK' exactly as shown."
        },
        "95": {
            "condition": "When the question specifies \"for 2013\"",
            "operation": " filter T2.Date to be between 201301 and 201312 inclusive."
        },
        "96": {
            "condition": "When combining customers and yearmonth tables",
            "operation": " link rows where T1.CustomerID = T2.CustomerID using an inner join and keep only matching pairs."
        },
        "97": {
            "condition": "When computing averages",
            "operation": " use explicit calculations with SUM(IIF(...)) / COUNT(...) instead of AVG(CASE ... END) for proper average computation."
        },
        "98": {
            "condition": "When handling numeric values",
            "operation": " use CAST(... AS REAL) for explicit type conversion instead of implicit casting."
        },
        "99": {
            "condition": "When answering about annual average consumption differences between customer segments, When the question mentions \"customers with the least amount of consumption\", When the question specifies \"paid in CZK\", When the question specifies \"for 2013\", When combining customers and yearmonth tables, When computing averages, When handling numeric values, When referring to columns",
            "operation": " always use table aliases T1.Segment and T2.Consumption instead of unqualified column names."
        },
        "100": {
            "condition": "When calculating average consumption differences between segments",
            "operation": " use COUNT(T1.CustomerID) as the denominator instead of conditional sums for each segment to properly count all relevant customers."
        },
        "101": {
            "condition": "When specifying date range for year 2013",
            "operation": " use integer literals 201301 and 201312 instead of string literals '201301' and '201312'."
        },
        "102": {
            "condition": "When calculating average consumption differences between segments, When specifying date range for year 2013, When producing output for consumption differences",
            "operation": " do not use explicit column aliases SME_LAM_Diff, LAM_KAM_Diff, and KAM_SME_Diff to match unaliased output format."
        },
        "103": {
            "condition": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for",
            "operation": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for"
        },
        "104": {
            "condition": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for, * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
            "operation": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for, * 100%; The first 4 strings of the Date values in the yearmonth table can represent year"
        },
        "105": {
            "condition": "When answering about customer consumption",
            "operation": " use table \"yearmonth\" instead of \"transactions\""
        },
        "106": {
            "condition": "When aggregating consumption amounts",
            "operation": " use column \"Consumption\" instead of \"amount\""
        },
        "107": {
            "condition": "When filtering by customer",
            "operation": " use column \"CustomerID\" instead of \"customer_id\" with exact value 6"
        },
        "108": {
            "condition": "When filtering by date range",
            "operation": " use column \"Date\" instead of \"date\" with exact format 'YYYYMM'"
        },
        "109": {
            "condition": "When answering about customer consumption, When aggregating consumption amounts, When filtering by customer, When filtering by date range, When specifying date range between August and November 2013",
            "operation": " use exact values '201308' and '201311' instead of '2013-08-01' and '2013-11-30'"
        },
        "110": {
            "condition": "When the question mentions \"Czech Republic\"",
            "operation": " use the exact country code 'CZE' instead of the full name 'Czech Republic' for the Country column."
        },
        "111": {
            "condition": "When the question mentions \"Slovakia\"",
            "operation": " use the exact country code 'SVK' instead of the full name 'Slovakia' for the Country column."
        },
        "112": {
            "condition": "When the question mentions \"discount\" gas stations",
            "operation": " use the exact segment value 'Discount' (with capital D) for the Segment column instead of 'discount'."
        },
        "113": {
            "condition": "When calculating the difference between counts for two countries",
            "operation": " compute SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) in a single table scan rather than using separate subqueries."
        },
        "114": {
            "condition": "When the question mentions \"Czech Republic\", When the question mentions \"Slovakia\", When the question mentions \"discount\" gas stations, When calculating the difference between counts for two countries, When querying gas station data",
            "operation": " use the exact table name \"gasstations\" instead of \"gas_stations\"."
        },
        "115": {
            "condition": "When the question asks about customer consumption differences",
            "operation": " use conditional aggregation with SUM(IIF(CustomerID = <CUSTOMER_ID>, Consumption, 0)) instead of subqueries."
        },
        "116": {
            "condition": "When filtering by year and month",
            "operation": " use the combined Date column with format 'YYYYMM' (e.g., '201304' for April"
        },
        "117": {
            "condition": "instead of separate year and month conditions.",
            "operation": "instead of separate year and month conditions."
        },
        "118": {
            "condition": "When querying customer consumption data",
            "operation": " use the yearmonth table instead of customer_consumption table."
        },
        "119": {
            "condition": "When the question asks about customer consumption differences, When filtering by year and month, instead of separate year and month conditions., When querying customer consumption data, When calculating consumption differences between specific customers",
            "operation": " subtract the conditional sums directly (SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)))."
        },
        "120": {
            "condition": "When the question asks about SMEs",
            "operation": " filter to only include rows where \"Segment\" equals exactly 'SME'."
        },
        "121": {
            "condition": "When counting payments in specific currencies",
            "operation": " use boolean aggregation with SUM() where \"Currency\" equals exactly 'CZK' for Czech koruna and exactly 'EUR' for euros."
        },
        "122": {
            "condition": "When calculating the difference between two counts",
            "operation": " compute SUM(Currency = 'CZK') - SUM(Currency = 'EUR') to get how many more SMEs pay in Czech koruna than in euros."
        },
        "123": {
            "condition": "When the question asks \"how many more\"",
            "operation": " only output the difference value, not the individual currency counts."
        },
        "124": {
            "condition": "When the question asks about SMEs, When counting payments in specific currencies, When calculating the difference between two counts, When the question asks \"how many more\", When querying customer payment data",
            "operation": " use the \"customers\" table instead of any other table source."
        },
        "125": {
            "condition": "When answering about \"LAM customer with highest consumption\"",
            "operation": " make sure the output order: T1.CustomerID, SUM(T2.Consumption)."
        },
        "126": {
            "condition": "When the question mentions \"LAM customer\"",
            "operation": " \"LAM\" actually means \"T1.Segment = 'LAM'\" in schema."
        },
        "127": {
            "condition": "When the question mentions \"Euro as their currency\"",
            "operation": " \"Euro\" actually means \"T1.Currency = 'EUR'\" in schema."
        },
        "128": {
            "condition": "When the question mentions \"October 2013\"",
            "operation": " this actually means \"T2.Date = '201310'\" in schema."
        },
        "129": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match)."
        },
        "130": {
            "condition": "When the question asks for \"highest consumption\"",
            "operation": " rank rows by SUM(T2.Consumption) in descending order and keep the first 1 row."
        },
        "131": {
            "condition": "When answering about \"LAM customer with highest consumption\", When the question mentions \"LAM customer\", When the question mentions \"Euro as their currency\", When the question mentions \"October 2013\", When combining T1 and T2 for shared entities, When the question asks for \"highest consumption\", When the question asks for consumption in a specific period",
            "operation": " compute SUM(T2.Consumption) per customer for the filtered date range."
        },
        "132": {
            "condition": "When answering about \"customers who consumed the most\"",
            "operation": " rank customers by total consumption in descending order and keep only the top 1 row."
        },
        "133": {
            "condition": "When the question mentions \"KAM's customers\"",
            "operation": " \"KAM\" actually means \"T1.Segment = 'KAM'\" in the schema."
        },
        "134": {
            "condition": "When combining T1 (customers) and T2 (yearmonth) for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match)."
        },
        "135": {
            "condition": "When computing consumption per customer",
            "operation": " organize results by T2.CustomerID and compute SUM(T2.Consumption) per group."
        },
        "136": {
            "condition": "When answering about \"customers who consumed the most\", When the question mentions \"KAM's customers\", When combining T1 (customers) and T2 (yearmonth) for shared entities, When computing consumption per customer, When selecting output columns",
            "operation": " return T2.CustomerID and SUM(T2.Consumption) in that order."
        },
        "137": {
            "condition": "When answering about \"total consumption for KAM customers in May 2013\"",
            "operation": " make sure the output order: SUM(T2.Consumption)."
        },
        "138": {
            "condition": "When the question mentions \"KAM customers\"",
            "operation": " \"KAM\" actually means \"T1.Segment = 'KAM'\" in schema."
        },
        "139": {
            "condition": "When the question mentions \"May 2013\"",
            "operation": " this date actually means \"T2.Date = '201305'\" in schema."
        },
        "140": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)."
        },
        "141": {
            "condition": "When answering about \"total consumption for KAM customers in May 2013\", When the question mentions \"KAM customers\", When the question mentions \"May 2013\", When combining T1 and T2 for shared entities, When computing total consumption",
            "operation": " use SUM(T2.Consumption) instead of SUM(amount)."
        },
        "142": {
            "condition": "When answering about \"percent of LAM customer consumed more than 46.73\"",
            "operation": " make sure the output order: percentage."
        },
        "143": {
            "condition": "When the question mentions \"LAM customer\"",
            "operation": " \"LAM\" actually means \"T1.Segment = 'LAM'\" in schema."
        },
        "144": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)."
        },
        "145": {
            "condition": "When counting qualifying records with consumption > 46.73",
            "operation": " use SUM(IIF(T2.Consumption > 46.73, 1, 0)) instead of COUNT(*) with a WHERE filter."
        },
        "146": {
            "condition": "When calculating percentage",
            "operation": " compute (SUM(IIF(T2.Consumption > 46.73, 1, 0)) * 100 / COUNT(T1.CustomerID)) with proper casting to FLOAT."
        },
        "147": {
            "condition": "When answering about \"percent of LAM customer consumed more than 46.73\", When the question mentions \"LAM customer\", When combining T1 and T2 for shared entities, When counting qualifying records with consumption > 46.73, When calculating percentage, When referencing consumption data",
            "operation": " use T2.Consumption from the joined yearmonth table instead of consumption directly from customers table."
        },
        "148": {
            "condition": "When the question mentions \"country\"",
            "operation": " use the exact column name \"Country\" from the gasstations table."
        },
        "149": {
            "condition": "When filtering for \"value for money\" gas stations",
            "operation": " use the condition \"Segment = 'Value for money'\" exactly as specified."
        },
        "150": {
            "condition": "When counting gas stations",
            "operation": " use \"GasStationID\" as the counting key instead of counting all columns."
        },
        "151": {
            "condition": "When the question asks for the country with more value for money stations",
            "operation": " return only the top result using LIMIT 1."
        },
        "152": {
            "condition": "When ordering results by count",
            "operation": " reference COUNT(GasStationID) directly in the ORDER BY clause instead of using an alias."
        },
        "153": {
            "condition": "When the question mentions \"country\", When filtering for \"value for money\" gas stations, When counting gas stations, When the question asks for the country with more value for money stations, When ordering results by count, When referring to the gas stations table",
            "operation": " use the exact table name \"gasstations\" instead of \"gas_stations\"."
        },
        "154": {
            "condition": "When the question asks for \"value for money\" gas stations",
            "operation": " use the exact literal 'Value for money' for the Segment filter."
        },
        "155": {
            "condition": "When counting gas stations",
            "operation": " use GasStationID as the counting key."
        },
        "156": {
            "condition": "When grouping results by country",
            "operation": " organize results by the Country column."
        },
        "157": {
            "condition": "When finding the country with the highest count",
            "operation": " order results by the count of GasStationID in descending order and keep only the top result."
        },
        "158": {
            "condition": "When the question asks for \"value for money\" gas stations, When counting gas stations, When grouping results by country, When finding the country with the highest count, When calculating total counts across all countries",
            "operation": " use a scalar subquery to count all gas stations with Segment = 'Value for money' regardless of country grouping."
        },
        "159": {
            "condition": "When the question asks for percentage of customers paying in euros within KAM segment",
            "operation": " calculate (number of EUR-paying KAM customers) divided by (total KAM customers) multiplied by 100.0."
        },
        "160": {
            "condition": "When counting customers conditionally",
            "operation": " use CAST(SUM(Currency = 'EUR') AS FLOAT) instead of COUNT(*) with subqueries."
        },
        "161": {
            "condition": "When filtering for KAM customers",
            "operation": " use WHERE Segment = 'KAM' to identify the target segment."
        },
        "162": {
            "condition": "When calculating the denominator",
            "operation": " use COUNT(CustomerID) for total KAM customers instead of separate subquery counts."
        },
        "163": {
            "condition": "When the question mentions \"KAM customers\"",
            "operation": " this refers to customers where Segment = 'KAM'."
        },
        "164": {
            "condition": "When the question mentions \"pay in euros\"",
            "operation": " this refers to customers where Currency = 'EUR'."
        },
        "165": {
            "condition": "When the question asks for percentage of customers paying in euros within KAM segment, When counting customers conditionally, When filtering for KAM customers, When calculating the denominator, When the question mentions \"KAM customers\", When the question mentions \"pay in euros\", When producing output",
            "operation": " do not include column aliases like 'percentage'."
        },
        "166": {
            "condition": "When answering about percentage of customers consuming more than a threshold",
            "operation": " use SUM(IIF(Consumption > 528.3, 1, 0)) for conditional counting instead of COUNT(CASE WHEN consumption > 528.3 THEN 1 END)."
        },
        "167": {
            "condition": "When casting numerical results",
            "operation": " use CAST(... AS FLOAT) instead of decimal multiplication for percentage calculation."
        },
        "168": {
            "condition": "When referencing data source",
            "operation": " use table yearmonth instead of customers as the primary data source."
        },
        "169": {
            "condition": "When filtering by date",
            "operation": " use Date = '201202' for direct date comparison instead of strftime('%Y-%m', date) = '2012-02'."
        },
        "170": {
            "condition": "When answering about percentage of customers consuming more than a threshold, When casting numerical results, When referencing data source, When filtering by date, When counting customers",
            "operation": " use COUNT(CustomerID) instead of COUNT(*) to count specific non-null values."
        },
        "171": {
            "condition": "When the question asks for percentage of premium gas stations",
            "operation": " use SUM(IIF(Segment = 'Premium', 1, 0)) to count premium segments instead of COUNT(CASE WHEN type = 'premium' THEN 1 END)."
        },
        "172": {
            "condition": "When calculating percentages",
            "operation": " cast the sum to FLOAT for proper division instead of using 100.0."
        },
        "173": {
            "condition": "When counting total gas stations",
            "operation": " reference GasStationID instead of * for counting."
        },
        "174": {
            "condition": "When referencing the gas stations table",
            "operation": " use table name gasstations instead of gas_stations."
        },
        "175": {
            "condition": "When the question asks for percentage of premium gas stations, When calculating percentages, When counting total gas stations, When referencing the gas stations table, When filtering for Slovakian gas stations",
            "operation": " use Country = 'SVK' instead of country = 'Slovakia' using the country code."
        },
        "176": {
            "condition": "When answering about \"which client ID consumed the most\"",
            "operation": " make sure the output order: T1.CustomerID, SUM(T2.Consumption) as total_consumed"
        },
        "177": {
            "condition": "When the question mentions \"client ID\"",
            "operation": " \"client ID\" actually means \"T1.CustomerID in schema\""
        },
        "178": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)"
        },
        "179": {
            "condition": "When filtering for September 2013",
            "operation": " use T2.Date = '201309' exactly as specified"
        },
        "180": {
            "condition": "When the question asks for \"the most\"",
            "operation": " rank rows by SUM(T2.Consumption) in descending order and keep the first 1 row"
        },
        "181": {
            "condition": "When answering about \"which client ID consumed the most\", When the question mentions \"client ID\", When combining T1 and T2 for shared entities, When filtering for September 2013, When the question asks for \"the most\", When grouping by client",
            "operation": " organize results by T1.CustomerID and compute SUM(T2.Consumption) per group"
        },
        "182": {
            "condition": "When answering about \"which client ID consumed the most\"",
            "operation": " make sure the output order includes only the CustomerID column without consumption data."
        },
        "183": {
            "condition": "When the question mentions \"September 2013\"",
            "operation": " use the exact literal '201309' for the Date filter."
        },
        "184": {
            "condition": "When combining customers table (T1) and yearmonth table (T2)",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match)."
        },
        "185": {
            "condition": "When grouping by CustomerID",
            "operation": " organize results by T1.CustomerID and compute the sum of T2.Consumption per group."
        },
        "186": {
            "condition": "When answering about \"which client ID consumed the most\", When the question mentions \"September 2013\", When combining customers table (T1) and yearmonth table (T2), When grouping by CustomerID, When identifying the top consumer",
            "operation": " rank rows by SUM(T2.Consumption) in descending order and keep only the first row (highest consumer)."
        },
        "187": {
            "condition": "September 2013 refers to yearmonth.date = '201309'",
            "operation": "September 2013 refers to yearmonth.date = '201309'"
        },
        "188": {
            "condition": "When answering about \"which SME customer consumed the least in June 2012\"",
            "operation": " make sure the output order: T1.CustomerID."
        },
        "189": {
            "condition": "When the question mentions \"SME customer\"",
            "operation": " \"SME\" actually means \"T1.Segment = 'SME'\" in schema."
        },
        "190": {
            "condition": "When the question mentions \"June 2012\"",
            "operation": " this actually means \"T2.Date = '201206'\" in schema."
        },
        "191": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match)."
        },
        "192": {
            "condition": "When the question asks for \"least consumption\"",
            "operation": " rank rows by SUM(T2.Consumption) in ascending order and keep the first 1 row."
        },
        "193": {
            "condition": "When answering about \"which SME customer consumed the least in June 2012\", When the question mentions \"SME customer\", When the question mentions \"June 2012\", When combining T1 and T2 for shared entities, When the question asks for \"least consumption\", When computing consumption per customer",
            "operation": " organize results by T1.CustomerID and compute SUM(T2.Consumption) per group."
        },
        "194": {
            "condition": "When answering about \"highest monthly consumption\"",
            "operation": " make sure to sum the \"Consumption\" values instead of taking the maximum single value."
        },
        "195": {
            "condition": "When the question mentions \"monthly consumption\"",
            "operation": " group results by month using SUBSTR(Date, 5,"
        },
        "196": {
            "condition": "to extract the month part.",
            "operation": "to extract the month part."
        },
        "197": {
            "condition": "When filtering for the year 2012",
            "operation": " use SUBSTR(Date, 1,"
        },
        "198": {
            "condition": "= '2012' to extract the year part from the Date field instead of a direct year column.",
            "operation": "= '2012' to extract the year part from the Date field instead of a direct year column."
        },
        "199": {
            "condition": "When the question asks for \"highest\"",
            "operation": " order the results by SUM(Consumption) in descending order and limit to the top 1 result."
        },
        "200": {
            "condition": "When answering about \"highest monthly consumption\", When the question mentions \"monthly consumption\", to extract the month part., When filtering for the year 2012, = '2012' to extract the year part from the Date field instead of a direct year column., When the question asks for \"highest\", When querying consumption data",
            "operation": " use the \"yearmonth\" table instead of \"monthly_data\" table."
        },
        "201": {
            "condition": "When answering about \"highest monthly consumption in the year 2012\"",
            "operation": " make sure the output order: only the maximum total consumption value without the month column."
        },
        "202": {
            "condition": "When the question asks for \"highest monthly consumption\"",
            "operation": " rank rows by SUM(Consumption) in descending order and keep the first 1 row."
        },
        "203": {
            "condition": "When filtering for the year 2012",
            "operation": " use WHERE SUBSTR(Date, 1,"
        },
        "204": {
            "condition": "= '2012' exactly as specified.",
            "operation": "= '2012' exactly as specified."
        },
        "205": {
            "condition": "When grouping by month",
            "operation": " use GROUP BY SUBSTR(Date, 5,"
        },
        "206": {
            "condition": "to organize results by month.",
            "operation": "to organize results by month."
        },
        "207": {
            "condition": "When answering about \"highest monthly consumption in the year 2012\", When the question asks for \"highest monthly consumption\", When filtering for the year 2012, = '2012' exactly as specified., When grouping by month, to organize results by month., When producing output",
            "operation": " do not include the month column or alias the aggregate function."
        },
        "208": {
            "condition": "When calculating monthly consumption for customers",
            "operation": " compute SUM(T2.Consumption) / 12 AS MonthlyConsumption to get average monthly consumption."
        },
        "209": {
            "condition": "When combining customer and yearmonth data",
            "operation": " link rows using T1.CustomerID = T2.CustomerID with an inner match."
        },
        "210": {
            "condition": "When filtering by currency",
            "operation": " use T1.Currency = 'EUR' exactly as specified, not 'euro'."
        },
        "211": {
            "condition": "When analyzing consumption per customer",
            "operation": " group results by T1.CustomerID to get individual customer metrics."
        },
        "212": {
            "condition": "When calculating monthly consumption for customers, When combining customer and yearmonth data, When filtering by currency, When analyzing consumption per customer, When finding the biggest monthly consumption",
            "operation": " order results by MonthlyConsumption DESC and take only the top 1 result."
        },
        "213": {
            "condition": "When answering about \"products consumed in September, 2013\"",
            "operation": " make sure the output order: T3.Description."
        },
        "214": {
            "condition": "When the question mentions \"products consumed\"",
            "operation": " this requires joining transactions_1k AS T1, yearmonth AS T2, and products AS T3 using inner joins."
        },
        "215": {
            "condition": "When combining T1 and T2",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs."
        },
        "216": {
            "condition": "When combining T1 and T3",
            "operation": " link rows where T1.ProductID = T3.ProductID and keep only matching pairs."
        },
        "217": {
            "condition": "When filtering for September 2013",
            "operation": " use T2.Date = '201309' exactly as specified, not '2013-09-01'."
        },
        "218": {
            "condition": "When answering about \"products consumed in September, 2013\", When the question mentions \"products consumed\", When combining T1 and T2, When combining T1 and T3, When filtering for September 2013, When selecting product descriptions",
            "operation": " use T3.Description from the products table, not description from products directly."
        },
        "219": {
            "condition": "When answering about countries of gas stations with transactions in June 2013",
            "operation": " make sure the output order: T2.Country."
        },
        "220": {
            "condition": "When the question mentions \"countries\"",
            "operation": " \"countries\" actually means \"T2.Country\" in schema."
        },
        "221": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.GasStationID = T2.GasStationID exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "222": {
            "condition": "When combining T1 and T3 for shared entities",
            "operation": " link rows where T1.CustomerID = T3.CustomerID exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "223": {
            "condition": "When filtering for transactions in June 2013",
            "operation": " use T3.Date = '201306' with the exact literal '201306' instead of transaction_date = '2013-06-01'."
        },
        "224": {
            "condition": "When answering about countries of gas stations with transactions in June 2013, When the question mentions \"countries\", When combining T1 and T2 for shared entities, When combining T1 and T3 for shared entities, When filtering for transactions in June 2013, When selecting distinct countries",
            "operation": " compute the number of unique values of T2.Country."
        },
        "225": {
            "condition": "When answering about \"chains of gas stations with transactions in euro\"",
            "operation": " make sure the output order: T3.ChainID"
        },
        "226": {
            "condition": "When the question mentions \"transactions in euro\"",
            "operation": " \"euro\" actually means \"T2.Currency = 'EUR'\" in schema"
        },
        "227": {
            "condition": "When combining tables for shared entities",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and T1.GasStationID = T3.GasStationID; keep only matching pairs (inner match)"
        },
        "228": {
            "condition": "When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms"
        },
        "229": {
            "condition": "When answering about \"chains of gas stations with transactions in euro\", When the question mentions \"transactions in euro\", When combining tables for shared entities, When choosing identifier delimiters, When handling text literals",
            "operation": " do not change case, spacing, or punctuation - use 'EUR' exactly as specified"
        },
        "230": {
            "condition": "When answering about \"products bought in transactions in euro\"",
            "operation": " make sure the output order: T1.ProductID, T3.Description."
        },
        "231": {
            "condition": "When the question mentions \"products bought in transactions\"",
            "operation": " join transactions_1k AS T1 with customers AS T2 on T1.CustomerID = T2.CustomerID and with products AS T3 on T1.ProductID = T3.ProductID."
        },
        "232": {
            "condition": "When the question mentions \"in euro\"",
            "operation": " filter on T2.Currency = 'EUR' instead of 'euro' to use the correct currency code format."
        },
        "233": {
            "condition": "When answering about \"products bought in transactions in euro\", When the question mentions \"products bought in transactions\", When the question mentions \"in euro\", When selecting product descriptions",
            "operation": " use DISTINCT T1.ProductID, T3.Description to show unique product information rather than product_description alone."
        },
        "234": {
            "condition": "When the question asks for \"average total price\"",
            "operation": " use the exact column name \"Amount\" from the transactions_1k table instead of \"price\"."
        },
        "235": {
            "condition": "When filtering for transactions in January 2012",
            "operation": " use the pattern '2012-01%' to match dates starting with January 2012 instead of separate YEAR and MONTH functions."
        },
        "236": {
            "condition": "When the question asks for \"average total price\", When filtering for transactions in January 2012, When selecting from the transactions table",
            "operation": " use the exact table name \"transactions_1k\" instead of \"transactions\"."
        },
        "237": {
            "condition": "When answering about customers who paid in euro",
            "operation": " use \"T2.Currency = 'EUR'\" as the filter condition with exact literal 'EUR'."
        },
        "238": {
            "condition": "When answering about monthly consumption over 1000",
            "operation": " use \"T1.Consumption > 1000.00\" as the filter condition with exact numeric value 1000.00."
        },
        "239": {
            "condition": "When combining yearmonth and customers tables",
            "operation": " link rows where \"T1.CustomerID = T2.CustomerID\" using exact identifier tokens."
        },
        "240": {
            "condition": "When counting customers",
            "operation": " count records from the yearmonth table (T1) using the join condition with customers table."
        },
        "241": {
            "condition": "When answering about customers who paid in euro, When answering about monthly consumption over 1000, When combining yearmonth and customers tables, When counting customers, When choosing table aliases",
            "operation": " use T1 for yearmonth table and T2 for customers table as specified in the amends."
        },
        "242": {
            "condition": "When counting records that meet specific criteria",
            "operation": " use COUNT(*) to count all matching rows rather than counting distinct values of a specific column."
        },
        "243": {
            "condition": "When joining tables with a key relationship",
            "operation": " use INNER JOIN explicitly for clarity, though it is functionally equivalent to JOIN."
        },
        "244": {
            "condition": "When counting records that meet specific criteria, When joining tables with a key relationship, When the question asks about customers with specific payment currency and consumption",
            "operation": " ensure the query filters for T2.Currency = 'EUR' and T1.Consumption > 1000.00 exactly as specified."
        },
        "245": {
            "condition": "When answering about product descriptions from transactions at gas stations in Czech Republic",
            "operation": " make sure the output order: T3.Description."
        },
        "246": {
            "condition": "When the question mentions \"Czech Republic\"",
            "operation": " \"Czech Republic\" actually means \"T2.Country = 'CZE'\" in schema."
        },
        "247": {
            "condition": "When combining T1 (transactions_1k) and T2 (gasstations) for shared entities",
            "operation": " link rows where T1.GasStationID = T2.GasStationID; keep only matching pairs (inner match)."
        },
        "248": {
            "condition": "When combining T1 (transactions_1k) and T3 (products) for shared entities",
            "operation": " link rows where T1.ProductID = T3.ProductID; keep only matching pairs (inner match)."
        },
        "249": {
            "condition": "When selecting product descriptions",
            "operation": " use T3.Description instead of product_description directly from transactions."
        },
        "250": {
            "condition": "When listing distinct product descriptions",
            "operation": " use DISTINCT to return only unique values of T3.Description."
        },
        "251": {
            "condition": "When answering about product descriptions from transactions at gas stations in Czech Republic, When the question mentions \"Czech Republic\", When combining T1 (transactions_1k) and T2 (gasstations) for shared entities, When combining T1 (transactions_1k) and T3 (products) for shared entities, When selecting product descriptions, When listing distinct product descriptions, When filtering for gas stations",
            "operation": " do not use location_type filter since the gasstations table inherently provides this context through the join."
        },
        "252": {
            "condition": "When answering about \"disparate time of transactions in gas stations from chain no. 11\"",
            "operation": " make sure the output order: T1.Time"
        },
        "253": {
            "condition": "When the question mentions \"transactions taken place in the gas stations\"",
            "operation": " combine T1 (transactions) and T2 (gasstations) using T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match)"
        },
        "254": {
            "condition": "When the question mentions \"chain no. 11\"",
            "operation": " filter to include only rows where T2.ChainID = 11"
        },
        "255": {
            "condition": "When answering about \"disparate time of transactions in gas stations from chain no. 11\", When the question mentions \"transactions taken place in the gas stations\", When the question mentions \"chain no. 11\", When the question asks for \"disparate time\"",
            "operation": " select distinct values of T1.Time"
        },
        "256": {
            "condition": "When answering about transactions in the Czech Republic",
            "operation": " use country code 'CZE' instead of 'Czech Republic' and reference it through T2.Country."
        },
        "257": {
            "condition": "When combining transaction and gas station data",
            "operation": " link rows where T1.GasStationID = T2.GasStationID using an inner match."
        },
        "258": {
            "condition": "When filtering by price",
            "operation": " use T1.Price > 1000 to find transactions over 1000."
        },
        "259": {
            "condition": "When counting transactions",
            "operation": " count T1.TransactionID instead of all rows."
        },
        "260": {
            "condition": "When answering about transactions in the Czech Republic, When combining transaction and gas station data, When filtering by price, When counting transactions, When the question mentions \"gas station\"",
            "operation": " do not filter by station_type as this information is already handled through the gasstations table join."
        },
        "261": {
            "condition": "When answering about transactions in gas stations",
            "operation": " combine tables \"transactions\" as T1 and \"gasstations\" as T2 using inner match where T1 and T2 are linked by their canonical keys."
        },
        "262": {
            "condition": "When the question mentions \"Czech Republic\"",
            "operation": " use country code 'CZE' instead of full name 'Czech Republic' and reference T2.Country for filtering."
        },
        "263": {
            "condition": "When filtering transactions by date after 2012/1/1",
            "operation": " use STRFTIME('%Y', T1.Date) >= '2012' to capture all transactions from 2012 onward."
        },
        "264": {
            "condition": "When answering about transactions in gas stations, When the question mentions \"Czech Republic\", When filtering transactions by date after 2012/1/1, When counting transactions",
            "operation": " count T1.TransactionID instead of all rows for more precise counting."
        },
        "265": {
            "condition": "When answering about average transaction price in gas stations in the Czech Republic",
            "operation": " make sure the output order: AVG(T1.Price)."
        },
        "266": {
            "condition": "When the question mentions \"gas stations\"",
            "operation": " use table \"gasstations\" as T2 and join with T1 using T1.GasStationID = T2.GasStationID."
        },
        "267": {
            "condition": "When the question mentions \"Czech Republic\"",
            "operation": " use country code 'CZE' instead of the full name, filtering on T2.Country = 'CZE'."
        },
        "268": {
            "condition": "When computing average transaction price",
            "operation": " use T1.Price column instead of total_price."
        },
        "269": {
            "condition": "When answering about average transaction price in gas stations in the Czech Republic, When the question mentions \"gas stations\", When the question mentions \"Czech Republic\", When computing average transaction price, When combining transactions and gas stations",
            "operation": " perform an inner join where T1.GasStationID equals T2.GasStationID to ensure only matching pairs are included."
        },
        "270": {
            "condition": "When answering about average total price for customers who paid in euro",
            "operation": " use AVG(T1.Price) instead of AVG(total_price) for the aggregate calculation."
        },
        "271": {
            "condition": "When combining tables for this question",
            "operation": " link transactions as T1 with gasstations as T2 using T1.GasStationID = T2.GasStationID and with customers as T3 using T1.CustomerID = T3.CustomerID, keeping only matching pairs (inner match)."
        },
        "272": {
            "condition": "When filtering for currency",
            "operation": " use T3.Currency = 'EUR' instead of currency = 'euro' and match the exact currency code format 'EUR'."
        },
        "273": {
            "condition": "When answering about average total price for customers who paid in euro, When combining tables for this question, When filtering for currency, When referencing tables",
            "operation": " use the aliases T1 for transactions, T2 for gasstations, and T3 for customers as established in the joins."
        },
        "274": {
            "condition": "When answering about \"which customer paid the most\"",
            "operation": " make sure the output order: CustomerID, SUM(Price)"
        },
        "275": {
            "condition": "When the question mentions \"customer\"",
            "operation": " \"customer\" actually means \"CustomerID in schema\""
        },
        "276": {
            "condition": "When the question mentions \"paid the most\"",
            "operation": " rank rows by SUM(Price) in descending direction and keep the first 1 row"
        },
        "277": {
            "condition": "When the question asks about date \"2012/8/25\"",
            "operation": " filter rows where Date equals '2012-08-25' exactly"
        },
        "278": {
            "condition": "When grouping by customer",
            "operation": " organize results by CustomerID and compute SUM(Price) per group"
        },
        "279": {
            "condition": "When using table transactions_1k",
            "operation": " do not use payments table"
        },
        "280": {
            "condition": "When selecting columns",
            "operation": " use CustomerID instead of customer_id"
        },
        "281": {
            "condition": "When answering about \"which customer paid the most\", When the question mentions \"customer\", When the question mentions \"paid the most\", When the question asks about date \"2012/8/25\", When grouping by customer, When using table transactions_1k, When selecting columns, When ordering results",
            "operation": " order by SUM(Price) descending instead of any aliased column"
        },
        "282": {
            "condition": "When filtering by date '2012/8/25' from the question",
            "operation": " use the exact date format '2012-08-25' instead of '2012/8/25' to ensure proper date parsing and comparison."
        },
        "283": {
            "condition": "When answering about \"which country's gas station had the first paid customer\"",
            "operation": " make sure the output order: T2.Country."
        },
        "284": {
            "condition": "When combining transactions_1k AS T1 and gasstations AS T2",
            "operation": " link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match)."
        },
        "285": {
            "condition": "When filtering for date '2012/8/25'",
            "operation": " use T1.Date = '2012-08-25' with the exact date format shown in the amends."
        },
        "286": {
            "condition": "When determining the first paid customer",
            "operation": " order by T1.Time DESC to get the earliest time first."
        },
        "287": {
            "condition": "When answering about \"which country's gas station had the first paid customer\", When combining transactions_1k AS T1 and gasstations AS T2, When filtering for date '2012/8/25', When determining the first paid customer, When selecting the top result",
            "operation": " keep only the first row after ordering."
        },
        "288": {
            "condition": "When answering about currency paid by a customer",
            "operation": " select distinct T3.Currency instead of currency from the payments table."
        },
        "289": {
            "condition": "When combining transaction, gas station, and customer data",
            "operation": " use transactions_1k AS T1 as the main table and join gasstations AS T2 on T1.GasStationID = T2.GasStationID and customers AS T3 on T1.CustomerID = T3.CustomerID."
        },
        "290": {
            "condition": "When filtering by date",
            "operation": " use T1.Date = '2012-08-24' with proper date format instead of '2012/8/24'."
        },
        "291": {
            "condition": "When filtering by time",
            "operation": " use T1.Time = '16:25:00' exactly as specified."
        },
        "292": {
            "condition": "When answering about currency paid by a customer, When combining transaction, gas station, and customer data, When filtering by date, When filtering by time, When handling table relationships",
            "operation": " perform inner joins using the exact key equalities T1.GasStationID = T2.GasStationID and T1.CustomerID = T3.CustomerID."
        },
        "293": {
            "condition": "When answering about customer segment at a specific timestamp",
            "operation": " use transactions_1k AS T1 and customers AS T2 tables with an inner join on T1.CustomerID = T2.CustomerID instead of querying only the customers table."
        },
        "294": {
            "condition": "When filtering by date and time",
            "operation": " use separate conditions T1.date = '2012-08-23' and T1.time = '21:20:00' instead of a combined timestamp filter."
        },
        "295": {
            "condition": "When handling date literals",
            "operation": " use the exact format '2012-08-23' (YYYY-MM-DD) instead of '2012/8/23'."
        },
        "296": {
            "condition": "When answering about customer segment at a specific timestamp, When filtering by date and time, When handling date literals, When retrieving customer segment",
            "operation": " select the segment column from the customers table (T2.segment) after joining with transactions data."
        },
        "297": {
            "condition": "When answering about transactions paid in CZK",
            "operation": " join transactions_1k AS T1 with customers AS T2 on T1.CustomerID = T2.CustomerID to access currency information from the customers table."
        },
        "298": {
            "condition": "When filtering for CZK currency",
            "operation": " use T2.Currency = 'CZK' instead of currency = 'CZK' since currency information is sourced from the customers table."
        },
        "299": {
            "condition": "When filtering for morning time",
            "operation": " use T1.Time < '13:00:00' instead of time BETWEEN '00:00:00' AND '11:59:59' to capture the correct morning time range."
        },
        "300": {
            "condition": "When answering about transactions paid in CZK, When filtering for CZK currency, When filtering for morning time, When counting transactions",
            "operation": " count T1.TransactionID instead of using COUNT(*) for more precise counting of transaction records."
        },
        "301": {
            "condition": "When handling date literals in the question",
            "operation": " use the standard date format '2012-08-26' with hyphens and zero-padding instead of '2012/8/26' with slashes."
        },
        "302": {
            "condition": "When joining tables",
            "operation": " explicitly specify INNER JOIN instead of implicit JOIN syntax for clarity."
        },
        "303": {
            "condition": "When filtering transactions by date and time",
            "operation": " use T1.Date = '2012-08-26' AND T1.Time < '13:00:00' to capture morning transactions."
        },
        "304": {
            "condition": "When filtering by currency",
            "operation": " use T2.Currency = 'CZK' to match Czech Koruna transactions."
        },
        "305": {
            "condition": "When handling date literals in the question, When joining tables, When filtering transactions by date and time, When filtering by currency, When counting transactions",
            "operation": " use T1.TransactionID as the counting key for accurate transaction counts."
        },
        "306": {
            "condition": "When answering about \"the earliest customer\"",
            "operation": " make sure the output order: sort by Date ASC to find the earliest transaction."
        },
        "307": {
            "condition": "When combining transaction and customer data",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match)."
        },
        "308": {
            "condition": "When retrieving customer segment information",
            "operation": " use T2.Segment to specify the exact column from the customers table."
        },
        "309": {
            "condition": "When answering about \"the earliest customer\", When combining transaction and customer data, When retrieving customer segment information, When the question asks for segment of the earliest customer",
            "operation": " retrieve only the first result after ordering by transaction date."
        },
        "310": {
            "condition": "When answering about \"which country was it for a deal\"",
            "operation": " make sure the output order: T2.Country."
        },
        "311": {
            "condition": "When the question mentions \"deal happened at 2012/8/24 12",
            "operation": "42:00\": filter using T1.Date = '2012-08-24' and T1.Time = '12:42:00' instead of a combined datetime string."
        },
        "312": {
            "condition": "When combining transactions_1k AS T1 and gasstations AS T2",
            "operation": " link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match)."
        },
        "313": {
            "condition": "When answering about \"which country was it for a deal\", When the question mentions \"deal happened at 2012/8/24 12, When combining transactions_1k AS T1 and gasstations AS T2, When handling date literals",
            "operation": " use exact format '2012-08-24' instead of '2012/8/24' and preserve time format '12:42:00' exactly as specified."
        },
        "314": {
            "condition": "When answering about transaction product ID at a specific datetime",
            "operation": " make sure the output order: T1.ProductID."
        },
        "315": {
            "condition": "When the question mentions \"transactions\"",
            "operation": " use table \"transactions_1k AS T1\" instead of \"transactions\"."
        },
        "316": {
            "condition": "When combining transactions and gasstations tables",
            "operation": " link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match)."
        },
        "317": {
            "condition": "When filtering by datetime \"2012/8/23 21",
            "operation": "20:00\": split into separate date and time components with T1.Date = '2012-08-23' AND T1.Time = '21:20:00' using exact date format '2012-08-23' and time format '21:20:00'."
        },
        "318": {
            "condition": "When answering about transaction product ID at a specific datetime, When the question mentions \"transactions\", When combining transactions and gasstations tables, When filtering by datetime \"2012/8/23 21, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms for T1.ProductID, T1.GasStationID, and T2.GasStationID."
        },
        "319": {
            "condition": "When answering about a customer who paid 124.05 on 2012-08-24",
            "operation": " select T1.CustomerID, T2.Date, and T2.Consumption as output columns."
        },
        "320": {
            "condition": "When joining tables for customer transaction analysis",
            "operation": " use transactions_1k as T1 and INNER JOIN yearmonth as T2 on T1.CustomerID = T2.CustomerID."
        },
        "321": {
            "condition": "When filtering for a specific payment amount",
            "operation": " use T1.Price = 124.05."
        },
        "322": {
            "condition": "When filtering for a specific payment date",
            "operation": " use T1.Date = '2012-08-24'."
        },
        "323": {
            "condition": "When filtering for January 2012 consumption data",
            "operation": " use T2.Date = '201201'."
        },
        "324": {
            "condition": "When answering about a customer who paid 124.05 on 2012-08-24, When joining tables for customer transaction analysis, When filtering for a specific payment amount, When filtering for a specific payment date, When filtering for January 2012 consumption data, When the question asks for spending during January 2012",
            "operation": " return the T2.Consumption value directly without aggregation or grouping."
        },
        "325": {
            "condition": "When answering about transactions during a specific time period",
            "operation": " use table \"transactions_1k AS T1\" instead of just \"transactions\"."
        },
        "326": {
            "condition": "When counting transactions",
            "operation": " count using \"T1.TransactionID\" instead of counting all rows with COUNT(*)."
        },
        "327": {
            "condition": "When filtering by country",
            "operation": " apply the filter \"T2.Country = 'CZE'\" on the gasstations table instead of directly on the transactions table."
        },
        "328": {
            "condition": "When combining transaction and gas station data",
            "operation": " link rows where \"T1.GasStationID = T2.GasStationID\" using an inner join between \"transactions_1k AS T1\" and \"gasstations AS T2\"."
        },
        "329": {
            "condition": "When answering about transactions during a specific time period, When counting transactions, When filtering by country, When combining transaction and gas station data, When handling time and date filters",
            "operation": " keep the exact conditions \"date = '2012-08-26' AND time BETWEEN '08:00:00' AND '09:00:00'\" as specified in the question."
        },
        "330": {
            "condition": "When the question mentions a date in format \"2012/8/26\"",
            "operation": " use the ISO date format \"2012-08-26\" with leading zeros for month and day."
        },
        "331": {
            "condition": "When the question mentions a date in format \"2012/8/26\", When the question mentions a time range \"8",
            "operation": "00-9:00\": use the full time format with seconds as \"08:00:00\" and \"09:00:00\" including leading zeros for hours."
        },
        "332": {
            "condition": "When answering about currency used by a customer with specific spending",
            "operation": " select T2.Currency from the customers table instead of currency from customers alone."
        },
        "333": {
            "condition": "When combining yearmonth and customers tables",
            "operation": " link rows where T1.CustomerID = T2.CustomerID using an inner join to match consumption data with customer currency information."
        },
        "334": {
            "condition": "When filtering for June 2013",
            "operation": " use T1.Date = '201306' instead of separate month and year conditions."
        },
        "335": {
            "condition": "When answering about currency used by a customer with specific spending, When combining yearmonth and customers tables, When filtering for June 2013, When filtering for consumption amount 214582.17",
            "operation": " use T1.Consumption = 214582.17 instead of amount = 214582.17."
        },
        "336": {
            "condition": "When answering about \"which country was the card owner of No.667467 in\"",
            "operation": " make sure the output order: T2.Country."
        },
        "337": {
            "condition": "When the question mentions \"No.667467\"",
            "operation": " \"No.667467\" actually means \"T1.CardID = '667467'\" in schema."
        },
        "338": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.GasStationID = T2.GasStationID exactly as shown in the amends; keep only matching pairs (inner match)."
        },
        "339": {
            "condition": "When answering about \"which country was the card owner of No.667467 in\", When the question mentions \"No.667467\", When combining T1 and T2 for shared entities, When choosing identifier delimiters",
            "operation": " do not replace double quotes with backticks or unquoted forms."
        },
        "340": {
            "condition": "When answering about customer nationality for a specific transaction",
            "operation": " use T2.Country instead of nationality from the result set."
        },
        "341": {
            "condition": "When combining transaction and gas station data",
            "operation": " link rows where T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match)."
        },
        "342": {
            "condition": "When filtering by date",
            "operation": " use T1.Date = '2012-08-24' with the exact date format shown."
        },
        "343": {
            "condition": "When filtering by transaction amount",
            "operation": " use T1.Price = 548.4 instead of amount_spent."
        },
        "344": {
            "condition": "When answering about customer nationality for a specific transaction, When combining transaction and gas station data, When filtering by date, When filtering by transaction amount, When the question mentions \"customer who spent\"",
            "operation": " this actually means transaction data in T1 with Price column and gas station country in T2.Country."
        },
        "345": {
            "condition": "When answering about percentage of customers who used EUR on a specific date",
            "operation": " join transactions_1k as T1 with customers as T2 using T1.CustomerID = T2.CustomerID to link customer transaction data."
        },
        "346": {
            "condition": "When filtering for a specific date '2012-08-25'",
            "operation": " apply the filter T1.Date = '2012-08-25' to select only transactions from that date."
        },
        "347": {
            "condition": "When calculating percentage of EUR users",
            "operation": " use SUM(IIF(T2.Currency = 'EUR', 1, 0)) with explicit casting to FLOAT for the numerator instead of COUNT(*) with currency filtering."
        },
        "348": {
            "condition": "When computing the denominator for percentage",
            "operation": " use COUNT(T1.CustomerID) to count all customers with transactions on the specified date instead of counting all customers from the customers table."
        },
        "349": {
            "condition": "When answering about percentage of customers who used EUR on a specific date, When filtering for a specific date '2012-08-25', When calculating percentage of EUR users, When computing the denominator for percentage, When handling currency filtering",
            "operation": " remove separate currency filter from WHERE clause and instead handle EUR condition within the conditional sum logic using T2.Currency = 'EUR'."
        },
        "350": {
            "condition": "When calculating a ratio involving division",
            "operation": " use CAST(... AS FLOAT) to ensure floating-point division instead of integer division."
        },
        "351": {
            "condition": "When implementing conditional logic",
            "operation": " use IIF() expressions instead of CASE WHEN statements."
        },
        "352": {
            "condition": "When extracting year from a date field",
            "operation": " use SUBSTR(Date, 1,"
        },
        "353": {
            "condition": "to get the first 4 characters instead of strftime functions.",
            "operation": "to get the first 4 characters instead of strftime functions."
        },
        "354": {
            "condition": "When referring to consumption amounts",
            "operation": " use the Consumption column instead of amount."
        },
        "355": {
            "condition": "When querying consumption data",
            "operation": " use the yearmonth table instead of payments."
        },
        "356": {
            "condition": "When filtering by customer",
            "operation": " use CustomerID = (...) with a single-row subquery instead of customerNumber IN (...) with a multi-row subquery."
        },
        "357": {
            "condition": "When referencing date fields",
            "operation": " use the Date column instead of paymentDate."
        },
        "358": {
            "condition": "When identifying a specific customer who made a payment",
            "operation": " join transactions_1k with gasstations on GasStationID to find the correct CustomerID instead of simple filtering."
        },
        "359": {
            "condition": "When calculating a ratio involving division, When implementing conditional logic, When extracting year from a date field, to get the first 4 characters instead of strftime functions., When referring to consumption amounts, When querying consumption data, When filtering by customer, When referencing date fields, When identifying a specific customer who made a payment, When calculating year-over-year changes",
            "operation": " handle the year filtering internally within the calculation logic instead of using an outer WHERE clause for years."
        },
        "360": {
            "condition": "When the question asks about a customer who paid a specific amount on a specific date",
            "operation": " use the exact date format '2012-08-25' instead of '2012/8/25' in filter conditions."
        },
        "361": {
            "condition": "When calculating consumption for different years from the same table",
            "operation": " use conditional aggregation with SUM(IIF(SUBSTR(Date, 1,"
        },
        "362": {
            "condition": "= '2012', Consumption, 0)) instead of separate scalar subqueries.",
            "operation": "= '2012', Consumption, 0)) instead of separate scalar subqueries."
        },
        "363": {
            "condition": "When joining tables for customer identification",
            "operation": " use INNER JOIN with explicit aliases T1 and T2 instead of implicit aliases."
        },
        "364": {
            "condition": "When expecting only one customer ID result",
            "operation": " remove the DISTINCT modifier from the subquery."
        },
        "365": {
            "condition": "When calculating percentage decrease rates",
            "operation": " handle division by zero implicitly through the aggregate structure rather than explicit IIF(cons_2012 > 0, ...) logic."
        },
        "366": {
            "condition": "When the question asks about a customer who paid a specific amount on a specific date, When calculating consumption for different years from the same table, = '2012', Consumption, 0)) instead of separate scalar subqueries., When joining tables for customer identification, When expecting only one customer ID result, When calculating percentage decrease rates, When filtering for a specific customer",
            "operation": " place the subquery directly in the WHERE CustomerID = clause instead of using multiple nested levels."
        },
        "367": {
            "condition": "When calculating a ratio difference between two years",
            "operation": " cast the numerator difference as FLOAT instead of omitting explicit casting to ensure proper division."
        },
        "368": {
            "condition": "When computing a decrease rate",
            "operation": " remove any multiplication factor like * 100.0 instead of keeping percentage scaling."
        },
        "369": {
            "condition": "When retrieving a CustomerID from a subquery",
            "operation": " remove the DISTINCT keyword instead of including it to avoid unnecessary deduplication."
        },
        "370": {
            "condition": "When joining tables in a subquery",
            "operation": " use table aliases T1 and T2 instead of t and g for consistency with the schema convention."
        },
        "371": {
            "condition": "When calculating a ratio difference between two years, When computing a decrease rate, When retrieving a CustomerID from a subquery, When joining tables in a subquery, When presenting the final result",
            "operation": " remove column aliases like DecreaseRate instead of keeping them for the output format."
        },
        "372": {
            "condition": "When answering about \"which gas station has the highest amount of revenue\"",
            "operation": " make sure the output order: GasStationID."
        },
        "373": {
            "condition": "When the question mentions \"revenue\"",
            "operation": " \"revenue\" actually means \"SUM(Price) in schema\"."
        },
        "374": {
            "condition": "When the question mentions \"highest\"",
            "operation": " rank rows by SUM(Price) in descending direction and keep the first 1 row."
        },
        "375": {
            "condition": "When the question asks for \"which gas station\"",
            "operation": " organize results by GasStationID and compute requested aggregates per group."
        },
        "376": {
            "condition": "When answering about \"which gas station has the highest amount of revenue\", When the question mentions \"revenue\", When the question mentions \"highest\", When the question asks for \"which gas station\", When combining data for gas stations",
            "operation": " use the table transactions_1k instead of gas_stations."
        },
        "377": {
            "condition": "When answering about \"which gas station has the highest amount of revenue\"",
            "operation": " make sure the output order: GasStationID only."
        },
        "378": {
            "condition": "When computing the highest revenue",
            "operation": " rank rows by SUM(Price) in descending order and keep the first 1 row."
        },
        "379": {
            "condition": "When grouping by GasStationID",
            "operation": " organize results by GasStationID and compute SUM(Price) per group."
        },
        "380": {
            "condition": "When answering about \"which gas station has the highest amount of revenue\", When computing the highest revenue, When grouping by GasStationID, When producing output",
            "operation": " do not include the SUM(Price) column in the final results, only include GasStationID."
        },
        "381": {
            "condition": "When answering about percentage of \"premium\" segment in Country = \"SVK\"",
            "operation": " use the gasstations table as the data source instead of customers table."
        },
        "382": {
            "condition": "When calculating conditional counts",
            "operation": " use SUM(IIF(condition, 1, 0)) aggregation instead of COUNT(CASE WHEN condition THEN 1 END)."
        },
        "383": {
            "condition": "When filtering for Country = \"SVK\"",
            "operation": " apply the filter within both numerator and denominator conditional expressions instead of using a WHERE clause to ensure proper denominator calculation."
        },
        "384": {
            "condition": "When handling numeric calculations",
            "operation": " cast the numerator to FLOAT instead of using 100.0 for explicit type handling."
        },
        "385": {
            "condition": "When answering about percentage of \"premium\" segment in Country = \"SVK\", When calculating conditional counts, When filtering for Country = \"SVK\", When handling numeric calculations, When calculating percentage",
            "operation": " use the formula numerator * 100 / denominator instead of numerator * 100.0 / COUNT(*) to properly handle the conditional denominator."
        },
        "386": {
            "condition": "When the question asks for percentage of \"premium\" segment in Country = \"SVK\"",
            "operation": " compute (number of rows where \"Segment\" = 'Premium' and \"Country\" = 'SVK') divided by (number of rows where \"Country\" = 'SVK') multiplied by 100.0."
        },
        "387": {
            "condition": "When handling string literals",
            "operation": " use exact case 'Premium' instead of 'premium' for matching the \"Segment\" column."
        },
        "388": {
            "condition": "When performing division",
            "operation": " cast the numerator to FLOAT before division to avoid integer division."
        },
        "389": {
            "condition": "When filtering conditions",
            "operation": " place the \"Country\" = 'SVK' filter before the \"Segment\" = 'Premium' filter in conditional logic."
        },
        "390": {
            "condition": "When the question asks for percentage of \"premium\" segment in Country = \"SVK\", When handling string literals, When performing division, When filtering conditions, When referencing columns",
            "operation": " use unaliased column names \"Country\" and \"Segment\" instead of table-prefixed versions."
        },
        "391": {
            "condition": "When the question asks for amount spent by customer \"38508\"",
            "operation": " filter rows where T1.CustomerID equals '38508' exactly."
        },
        "392": {
            "condition": "When the question asks about spending at gas stations",
            "operation": " join table gasstations as T2 where T1.GasStationID equals T2.GasStationID to properly categorize transactions."
        },
        "393": {
            "condition": "When the question asks for total amount spent",
            "operation": " compute the sum of T1.Price."
        },
        "394": {
            "condition": "When the question asks for spending in January 2012",
            "operation": " join table yearmonth as T3 where T1.CustomerID equals T3.CustomerID and compute the sum of T1.Price only for rows where T3.Date equals '201201' exactly."
        },
        "395": {
            "condition": "When the question asks for amount spent by customer \"38508\", When the question asks about spending at gas stations, When the question asks for total amount spent, When the question asks for spending in January 2012, When combining multiple tables for this analysis",
            "operation": " perform inner joins using the exact key equalities shown in the amends (T1.GasStationID = T2.GasStationID and T1.CustomerID = T3.CustomerID)."
        },
        "396": {
            "condition": "When answering about \"top five best selling products\"",
            "operation": " make sure the output order: T2.Description."
        },
        "397": {
            "condition": "When the question mentions \"best selling products\"",
            "operation": " \"best selling\" actually means \"highest transaction amounts in T1.Amount\"."
        },
        "398": {
            "condition": "When the question mentions \"top five\"",
            "operation": " rank rows by T1.Amount in descending order and keep the first 5 rows."
        },
        "399": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.ProductID = T2.ProductID exactly as shown; keep only matching pairs (inner match)."
        },
        "400": {
            "condition": "When answering about \"top five best selling products\", When the question mentions \"best selling products\", When the question mentions \"top five\", When combining T1 and T2 for shared entities, When the question asks for \"full name of them\"",
            "operation": " use T2.Description from the products table instead of product_name."
        },
        "401": {
            "condition": "When answering about \"top five best selling products\"",
            "operation": " make sure the output order: T2.Description"
        },
        "402": {
            "condition": "When the question mentions \"best selling products\"",
            "operation": " \"best selling\" actually means \"highest individual transaction amounts in T1.Amount\" in schema"
        },
        "403": {
            "condition": "When the question mentions \"top five\"",
            "operation": " rank rows by T1.Amount in descending direction and keep the first 5 rows"
        },
        "404": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.ProductID = T2.ProductID exactly as shown; keep only matching pairs (inner match)"
        },
        "405": {
            "condition": "When answering about \"top five best selling products\", When the question mentions \"best selling products\", When the question mentions \"top five\", When combining T1 and T2 for shared entities, When producing output",
            "operation": " do not group by T2.Description or aggregate T1.Amount with SUM function"
        },
        "406": {
            "condition": "When answering about the top spending customer",
            "operation": " identify the customer with the highest total spending using a subquery that computes SUM(T2.Price / T2.Amount) for each T2.CustomerID and orders by this sum in descending order, keeping only the top result."
        },
        "407": {
            "condition": "When calculating average price per single item",
            "operation": " compute SUM(T2.Price / T2.Amount) as the average price per item rather than using AVG(p.price)."
        },
        "408": {
            "condition": "When combining customer and transaction data",
            "operation": " use INNER JOIN between T1 (customers) and T2 (transactions_1k) where T1.CustomerID = T2.CustomerID to match customer records with their transactions."
        },
        "409": {
            "condition": "When grouping results",
            "operation": " group by both T2.CustomerID and T1.Currency to ensure currency information is properly included in the grouped results."
        },
        "410": {
            "condition": "When filtering for the top customer",
            "operation": " use a WHERE clause with T2.CustomerID = (subquery) to restrict results to only the top spending customer identified in the subquery."
        },
        "411": {
            "condition": "When answering about the top spending customer, When calculating average price per single item, When combining customer and transaction data, When grouping results, When filtering for the top customer, When selecting output columns",
            "operation": " include T2.CustomerID instead of customer_name, SUM(T2.Price / T2.Amount) instead of total spending and average price calculations, and T1.Currency for the currency information."
        },
        "412": {
            "condition": "When identifying the top spending customer",
            "operation": " use the CustomerID from the yearmonth table ordered by Consumption DESC with LIMIT 1 instead of aggregating transaction data."
        },
        "413": {
            "condition": "When calculating average price per item",
            "operation": " compute SUM(T2.Price / T2.Amount) without assigning an alias to the expression."
        },
        "414": {
            "condition": "When combining customer and transaction data",
            "operation": " link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match)."
        },
        "415": {
            "condition": "When identifying the top spending customer, When calculating average price per item, When combining customer and transaction data, When outputting results",
            "operation": " include T2.CustomerID, the computed average price expression, and T1.Currency in that order."
        },
        "416": {
            "condition": "When answering about \"which country had the gas station that sold the most expensive product id No.2\"",
            "operation": " make sure the output order: T2.Country."
        },
        "417": {
            "condition": "When the question mentions \"gas station\"",
            "operation": " \"gas station\" actually means \"T2\" in schema."
        },
        "418": {
            "condition": "When combining T1 and T2 for shared entities",
            "operation": " link rows where T1.GasStationID = T2.GasStationID; keep only matching pairs (inner match)."
        },
        "419": {
            "condition": "When the question mentions \"product id No.2\"",
            "operation": " \"product id No.2\" actually means \"T1.ProductID = 2\" in schema."
        },
        "420": {
            "condition": "When answering about \"which country had the gas station that sold the most expensive product id No.2\", When the question mentions \"gas station\", When combining T1 and T2 for shared entities, When the question mentions \"product id No.2\", When the question mentions \"most expensive\"",
            "operation": " rank rows by T1.Price in descending direction and keep the first 1 row."
        },
        "421": {
            "condition": "When the question asks for \"consumption status\"",
            "operation": " select \"Consumption\" from table \"yearmonth\" instead of \"consumption_status\" from table \"payments\"."
        },
        "422": {
            "condition": "When combining customer transaction and yearmonth data",
            "operation": " join \"transactions_1k\" with \"yearmonth\" on \"CustomerID\" using inner match."
        },
        "423": {
            "condition": "When filtering for price per unit greater than 29.00",
            "operation": " use condition \"Price / Amount > 29.00\" instead of \"unit_price > 29.00\"."
        },
        "424": {
            "condition": "When filtering for product ID No.5",
            "operation": " use exact condition \"ProductID = 5\"."
        },
        "425": {
            "condition": "When the question asks for \"consumption status\", When combining customer transaction and yearmonth data, When filtering for price per unit greater than 29.00, When filtering for product ID No.5, When filtering for August 2012",
            "operation": " use exact date matching \"Date = '201208'\" instead of pattern matching with LIKE."
        }
    }
}