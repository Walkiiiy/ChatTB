{
    "795": {
        "db_id": "superhero",
        "question": "How many superheroes have a neutral alignment?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [
            "Do reference the `superhero` table instead of `superheroes`. Do join with `alignment` table on `superhero.alignment_id = alignment.id` instead of directly filtering on a column that doesn't exist. Do filter on `alignment.alignment = 'Neutral'` instead of `alignment = 'good'`. Do count specific IDs with `COUNT(T1.id)` instead of `COUNT(*)` for more precise results. The amended query now correctly handles the relational structure by joining tables and filtering on the proper alignment value, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"how many superheroes have a neutral alignment\": make sure the output order: count of superheroes with neutral alignment. 2) When the question mentions \"superheroes\": \"superheroes\" actually means \"superhero\" table in schema. 3) When combining superhero and alignment tables: link rows where superhero.alignment_id = alignment.id; keep only matching pairs (inner match). 4) When filtering for neutral alignment: use alignment.alignment = 'Neutral' exactly as specified. 5) When counting superheroes: compute the number of rows using the canonical key token T1.id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE alignment = 'good';",
            "SELECT COUNT(superhero.id) \nFROM superhero \nJOIN alignment ON superhero.alignment_id = alignment.id \nWHERE alignment.alignment = 'Neutral'"
        ],
        "rule_sql": [
            "SELECT COUNT(superhero.id) \nFROM superhero \nINNER JOIN alignment ON superhero.alignment_id = alignment.id \nWHERE alignment.alignment = 'Neutral'"
        ],
        "amend_res": 1
    },
    "380": {
        "db_id": "card_games",
        "question": "List the edhrecRank for cards with frame version 2015.",
        "evidence": "",
        "ground_truth": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
        "amends": [
            "Do use column name `frameVersion` instead of `frame_version` in the WHERE clause filter. Do use integer value `2015` without quotes instead of string '2015' for the numeric comparison. The amended query now correctly filters on the actual column name and uses proper numeric comparison semantics, matching the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"frame version\": use the exact column name \"frameVersion\" from the cards table. 2) When filtering on numeric values like 2015: use the integer value 2015 without quotes for proper numeric comparison. 3) When answering about cards with frame version 2015: make sure the output includes edhrecRank from the cards table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT edhrecRank FROM cards WHERE frame_version = '2015';",
            "SELECT edhrecRank FROM cards WHERE frameVersion = 2015;"
        ],
        "rule_sql": [
            "SELECT edhrecRank FROM cards WHERE frameVersion = 2015;"
        ],
        "amend_res": 1
    },
    "644": {
        "db_id": "codebase_community",
        "question": "Provide the last edit date and last edit user ID for the post \"Detecting a given face in a database of facial images\".",
        "ground_truth": "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images'",
        "amends": [
            "Do use column name `LastEditDate` instead of `last_edit_date` and `LastEditorUserId` instead of `last_edit_user_id` in the SELECT list. Do use table column `Title` instead of `title` in the WHERE filter predicate. The amended query now correctly references the proper column names to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting the last edit date: use column \"LastEditDate\" instead of \"last_edit_date\". 2) When selecting the last edit user ID: use column \"LastEditorUserId\" instead of \"last_edit_user_id\". 3) When filtering by post title: use column \"Title\" instead of \"title\" and match the exact literal value 'Detecting a given face in a database of facial images'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_edit_date, last_edit_user_id FROM posts WHERE title = 'Detecting a given face in a database of facial images';",
            "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';"
        ],
        "rule_sql": [
            "SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';"
        ],
        "amend_res": 1
    },
    "965": {
        "db_id": "formula_1",
        "question": "List out the Id number of races which were hold in 2009.",
        "evidence": "",
        "ground_truth": "SELECT raceId FROM races WHERE year = 2009",
        "amends": [
            "Do reference column `raceId` instead of `Id` in the SELECT list. Do filter on year `2009` instead of `2008` in the WHERE clause. The amended query now correctly retrieves race identifiers for the specified year."
        ],
        "rules": [
            "1) When the question asks for \"Id number of races\": use the exact column token \"raceId\" from the results table instead of \"Id\". 2) When filtering races by year: use the exact literal value \"2009\" as specified in the question, not \"2008\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT Id FROM races WHERE year = 2008;",
            "SELECT raceId FROM races WHERE year = 2009;"
        ],
        "rule_sql": [
            "SELECT raceId FROM races WHERE year = 2009;"
        ],
        "amend_res": 1
    },
    "1052": {
        "db_id": "european_football_2",
        "question": "Among all the players whose weight is under 130, how many of them preferred foot in attacking is left?",
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.weight < 130 AND t2.preferred_foot = 'left'",
        "amends": [
            "Do select `COUNT(DISTINCT t1.id)` instead of `COUNT(*)` to count unique players. Do add `INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the players table. Do move the `preferred_foot` filter to the joined table `t2.preferred_foot = 'left'` instead of applying it to the main table. Do keep the `weight` filter on `t1.weight < 130` but now applied to the correct table context. The amended query now correctly counts distinct players who meet both weight and preferred foot criteria by properly joining the relevant tables."
        ],
        "rules": [
            "1) When counting players: use COUNT(DISTINCT t1.id) instead of COUNT(*) to count unique players. 2) When the question involves both player attributes and player information: join Player table as T1 with Player_Attributes table as T2 using INNER JOIN ON t1.player_api_id = t2.player_api_id. 3) When filtering by preferred foot: apply the condition t2.preferred_foot = 'left' to the Player_Attributes table (T2). 4) When filtering by weight: apply the condition t1.weight < 130 to the Player table (T1). 5) When combining player data with attributes: keep only matching pairs where t1.player_api_id = t2.player_api_id (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE weight < 130 AND preferred_foot = 'left';",
            "SELECT COUNT(DISTINCT t1.id) \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.weight < 130 \nAND t2.preferred_foot = 'left'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t1.id) \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.weight < 130 \nAND t2.preferred_foot = 'left'"
        ],
        "amend_res": 1
    },
    "306": {
        "db_id": "toxicology",
        "question": "Which molecules have triple bonds and list all the elements they contain.",
        "ground_truth": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select `molecule_id` and `element` instead of `name` and concatenated `elements`. Do use `DISTINCT` instead of `GROUP_CONCAT` with grouping. Do join `bond` as `T1` and `atom` as `T2` instead of joining `molecules`, `bonds`, and `elements`. Do use `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of separate joins on molecule IDs. Do filter for `bond_type = '#'` instead of `bond_type = 'triple'`. Do remove the `GROUP BY` clause instead of grouping by molecule name. The amended query now correctly identifies distinct molecule-element pairs for triple bonds using proper table relationships."
        ],
        "rules": [
            "1) When answering about molecules with triple bonds: use table bond as T1 and table atom as T2 with INNER JOIN on T1.molecule_id = T2.molecule_id instead of joining molecules, bonds, and elements separately. 2) When filtering for triple bonds: use bond_type = '#' instead of bond_type = 'triple'. 3) When selecting molecule and element information: select T1.molecule_id and T2.element instead of name and concatenated elements. 4) When listing distinct elements per molecule: use DISTINCT instead of GROUP_CONCAT with grouping. 5) When organizing results: remove the GROUP BY clause instead of grouping by molecule name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT m.name, GROUP_CONCAT(e.symbol) as elements\nFROM molecules m\nJOIN bonds b ON m.id = b.molecule_id\nJOIN elements e ON m.id = e.molecule_id\nWHERE b.bond_type = 'triple'\nGROUP BY m.name;",
            "SELECT DISTINCT T1.molecule_id, T2.element\nFROM bond AS T1\nINNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "1107": {
        "db_id": "european_football_2",
        "question": "When was the first time did Kevin Constant have his highest crossing score? Give the date.",
        "ground_truth": "SELECT `date` FROM ( SELECT t2.crossing, t2.`date` FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Kevin Constant' ORDER BY t2.crossing DESC) ORDER BY date DESC LIMIT 1",
        "amends": [
            "Do use a subquery with `Player` and `Player_Attributes` tables instead of querying only the `matches` table. Do join on `player_fifa_api_id` instead of not having any join condition. Do select `crossing` and `date` in the inner query instead of only `date`. Do order by `crossing DESC` in the inner query instead of using a subquery with `MAX(crossing_score)`. Do remove the `WHERE` filter on `crossing_score` instead of keeping it. Do change the outer `ORDER BY` to `date DESC` instead of `date ASC`. The amended query now correctly retrieves the most recent date with the highest crossing score for the specified player.",
            "Do use a subquery with `INNER JOIN` between `Player` and `Player_Attributes` tables on `player_fifa_api_id` instead of multiple nested subqueries. Do select `crossing` and `date` in the inner query instead of just `date` in the outer query. Do order by `crossing DESC` in the inner query instead of filtering for maximum crossing with a subquery. Do move the player name filter to the `WHERE` clause of the join instead of using subqueries for player lookup. Do change the final sort to `date DESC` instead of `date ASC`. Do remove the redundant player lookup subqueries and instead use a single join-based approach. The amended query now correctly retrieves the most recent date for the maximum crossing value through efficient joining and sorting rather than multiple expensive subqueries.",
            "Do use a subquery to first select `crossing` and `date` with ordering by `crossing DESC` instead of directly selecting from the main query. Do reference columns with table aliases `t1` and `t2` instead of using full table names. Do maintain the same `INNER JOIN` on `player_fifa_api_id` between `Player` and `Player_Attributes` instead of changing the join logic. Do keep the same `WHERE` filter on `player_name = 'Kevin Constant'` instead of modifying the filtering condition. Do add an outer query to order by `date DESC` instead of ordering by both `crossing` and `date` in a single clause. Do preserve the same `LIMIT 1` instead of changing the result set size. The amended query now correctly retrieves the most recent record for Kevin Constant by first finding the record with the highest crossing value and then ensuring the most recent date among those results."
        ],
        "rules": [
            "1) When answering about \"Kevin Constant's highest crossing score date\": make sure the output order: date\n2) When the question mentions \"Kevin Constant\": \"Kevin Constant\" actually means \"player_name = 'Kevin Constant' in Player table\"\n3) When combining Player and Player_Attributes tables: link rows where Player.player_fifa_api_id = Player_Attributes.player_fifa_api_id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When finding the highest crossing score: rank rows by crossing in descending order and keep the first row\n5) When ordering results by date: use date DESC to get the most recent date instead of the earliest date\n6) When selecting columns: include both crossing and date in the inner query instead of only date\n7) When counting or identifying players: use player_fifa_api_id as the canonical key for joining tables instead of player_name",
            "1) When answering about \"Kevin Constant's highest crossing score date\": make sure the output order: date\n2) When the question mentions \"Kevin Constant\": \"Kevin Constant\" actually means \"player_name = 'Kevin Constant' in Player table\"\n3) When combining Player and Player_Attributes tables: link rows where Player.player_fifa_api_id = Player_Attributes.player_fifa_api_id exactly as shown in the amends; keep only matching pairs (inner match)\n4) When finding the highest crossing score: rank rows by crossing in descending order and keep the first row\n5) When the question asks for the date of the highest crossing score: select both crossing and date values to properly identify the maximum crossing occurrence\n6) When ordering the final result: sort by date in descending order to get the most recent occurrence of the maximum crossing value",
            "1) When answering about \"first time Kevin Constant had his highest crossing score\": make sure the output order: date\n2) When the question mentions \"Kevin Constant\": \"Kevin Constant\" actually means \"t2.player_name = 'Kevin Constant'\" in schema\n3) When combining t1 and t2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.player_fifa_api_id = t2.player_fifa_api_id); keep only matching pairs (inner match)\n4) When finding the highest crossing score: first select all records with maximum crossing value for Kevin Constant by ordering by t1.crossing DESC\n5) When determining the first time: among records with the highest crossing score, order by t1.date DESC and take the most recent record\n6) When producing the final result: return only the date column with LIMIT 1 to get the single most recent occurrence"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT date FROM matches WHERE player_name = 'Kevin Constant' AND crossing_score = (SELECT MAX(crossing_score) FROM matches WHERE player_name = 'Kevin Constant') ORDER BY date ASC LIMIT 1;",
            "SELECT date\nFROM Player_Attributes\nWHERE player_fifa_api_id = (\n    SELECT player_fifa_api_id\n    FROM Player\n    WHERE player_name = 'Kevin Constant'\n)\nAND crossing = (\n    SELECT MAX(crossing)\n    FROM Player_Attributes\n    WHERE player_fifa_api_id = (\n        SELECT player_fifa_api_id\n        FROM Player\n        WHERE player_name = 'Kevin Constant'\n    )\n)\nORDER BY date ASC\nLIMIT 1;",
            "SELECT pa.date\nFROM Player_Attributes pa\nINNER JOIN Player p ON pa.player_fifa_api_id = p.player_fifa_api_id\nWHERE p.player_name = 'Kevin Constant'\nORDER BY pa.crossing DESC, pa.date DESC\nLIMIT 1",
            "SELECT date\nFROM (\n    SELECT pa.crossing, pa.date\n    FROM Player p\n    INNER JOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id\n    WHERE p.player_name = 'Kevin Constant'\n    ORDER BY pa.crossing DESC\n) t\nORDER BY date DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT date\nFROM Player_Attributes pa\nINNER JOIN Player p ON pa.player_fifa_api_id = p.player_fifa_api_id\nWHERE p.player_name = 'Kevin Constant'\nAND pa.crossing = (\n    SELECT MAX(crossing)\n    FROM Player_Attributes pa2\n    INNER JOIN Player p2 ON pa2.player_fifa_api_id = p2.player_fifa_api_id\n    WHERE p2.player_name = 'Kevin Constant'\n)\nORDER BY date DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1303": {
        "db_id": "thrombosis_prediction",
        "question": "When is the birthday of the oldest patient whose blood glucose is abnormal?",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU > 180 ORDER BY T1.Birthday ASC LIMIT 1",
        "amends": [
            "Do select `T1.Birthday` instead of `MAX(birthday)` to get the actual birthday value rather than the maximum date. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table to properly correlate patient and lab data. Do filter on `T2.GLU > 180` instead of `blood_glucose > 120 OR blood_glucose < 70` to use the correct column name and threshold value from the joined laboratory table. Do add `ORDER BY T1.Birthday ASC` and `LIMIT 1` instead of using `MAX()` aggregation to get the oldest patient meeting the criteria. The amended query now correctly joins patient and laboratory tables, uses proper column references, and returns the earliest birthday of patients with glucose levels exceeding 180, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patient birthdays: select T1.Birthday instead of using MAX() aggregation to get the actual birthday value. 2) When combining patient and laboratory data: link rows where T1.ID = T2.ID using an inner match to properly correlate patient and lab information. 3) When filtering for abnormal blood glucose: use T2.GLU > 180 as the condition instead of blood_glucose > 120 OR blood_glucose < 70 to match the correct column name and threshold. 4) When finding the oldest patient: order by T1.Birthday ASC and take only the first row to get the earliest birthday."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(birthday) FROM patients WHERE blood_glucose > 120 OR blood_glucose < 70;",
            "SELECT T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.GLU > 180\nORDER BY T1.Birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GLU > 180\nORDER BY T1.Birthday ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "61": {
        "db_id": "california_schools",
        "question": "How many chartered schools located in the city of Hickman are owned by the Elementary School District?",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE DOC = 52 AND Charter = 1 AND City = 'Hickman'",
        "amends": [
            "Do select `COUNT(School)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do filter on `DOC = 52` instead of `city = 'Hickman'` to match by district code rather than city name. Do filter on `Charter = 1` instead of `district = 'Elementary School District'` to identify charter schools through a flag rather than district description. Do filter on `City = 'Hickman'` instead of `type = 'public'` to include the city filter while removing the school type condition. The amended query now correctly counts charter schools in Hickman with district code 52, matching the intended behavior."
        ],
        "rules": [
            "1) When counting schools: count the specific non-null values of \"School\" column instead of counting all rows. 2) When filtering by city Hickman: use exact literal 'Hickman' for the \"City\" column. 3) When identifying charter schools: use the flag condition \"Charter\" = 1 instead of district descriptions. 4) When filtering by district: use district code \"DOC\" = 52 instead of city name or district descriptions. 5) When the question asks about charter schools in a specific city owned by a district: ensure all three conditions are applied - \"City\" = 'Hickman', \"Charter\" = 1, and \"DOC\" = 52."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE city = 'Hickman' AND district = 'Elementary School District' AND type = 'public';",
            "SELECT COUNT(School) FROM schools WHERE DOC = '52' AND Charter = 1 AND City = 'Hickman'"
        ],
        "rule_sql": [
            "SELECT COUNT(School) FROM schools WHERE City = 'Hickman' AND Charter = 1 AND DOC = '52' AND School IS NOT NULL"
        ],
        "amend_res": 1
    },
    "531": {
        "db_id": "codebase_community",
        "question": "Which user has a higher reputation, Harlan or Jarrod Dixon?",
        "ground_truth": "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = ( SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') )",
        "amends": [
            "Do select `DisplayName` instead of `name, reputation` and remove the explicit column from the output. Do use `IN` with a list of values instead of multiple `OR` conditions for the name filter. Do add a subquery to find the maximum reputation with `MAX(Reputation)` instead of ordering and limiting. Do reference `Reputation` instead of `reputation` and use proper case sensitivity. Do filter by matching the maximum reputation value instead of relying on sort order and limit. Do remove `ORDER BY` and `LIMIT` clauses instead of keeping them since the subquery handles the maximum value logic. The amended query now correctly identifies the user with the highest reputation among those specified names."
        ],
        "rules": [
            "1) When the question asks about user names and reputation: use \"DisplayName\" instead of \"name\" and \"Reputation\" instead of \"reputation\" with exact case sensitivity. 2) When filtering for specific user names like 'Harlan' or 'Jarrod Dixon': use IN with a list of exact string literals instead of multiple OR conditions. 3) When finding the user with the highest reputation among specified names: compute the maximum reputation value using MAX(Reputation) and then filter for users matching that maximum value. 4) When outputting results: only show the DisplayName column and remove explicit reputation output since the question only asks which user has higher reputation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, reputation FROM users WHERE name = 'Harlan' OR name = 'Jarrod Dixon' ORDER BY reputation DESC LIMIT 1;",
            "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') AND Reputation = (SELECT MAX(Reputation) FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon'))"
        ],
        "amend_res": 1
    },
    "1177": {
        "db_id": "thrombosis_prediction",
        "question": "Was the total cholesterol status for the patient id 2927464 on 1995-9-4 at the normal level?",
        "ground_truth": "SELECT CASE WHEN `T-CHO` < 250 THEN 'Normal' ELSE 'Abnormal' END FROM Laboratory WHERE ID = 2927464 AND Date = '1995-09-04'",
        "amends": [
            "Do select `CASE WHEN T-CHO < 250 THEN 'Normal' ELSE 'Abnormal' END` instead of `*` to calculate status conditionally rather than filtering by static status. Do query from `Laboratory` table instead of `cholesterol` table to access the correct data source. Do filter by `ID = 2927464` instead of `patient_id = 2927464` using the correct column name. Do filter by `Date = '1995-09-04'` instead of `date = '1995-9-4'` with proper date formatting and column name. Do remove the `status = 'normal'` filter instead of keeping it since status is now derived from the T-CHO value. The amended query now correctly calculates cholesterol status based on T-CHO threshold rather than relying on a potentially incorrect stored status value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cholesterol status for a specific patient and date: calculate status conditionally using CASE WHEN T-CHO < 250 THEN 'Normal' ELSE 'Abnormal' END instead of selecting all columns. 2) When querying laboratory data: use the Laboratory table instead of cholesterol table to access the correct data source. 3) When filtering by patient identifier: use ID = 2927464 instead of patient_id = 2927464 with the exact column name. 4) When filtering by date: use Date = '1995-09-04' instead of date = '1995-9-4' with proper date formatting and exact column name. 5) When deriving cholesterol status from T-CHO values: remove any static status filter since status is now calculated based on the T-CHO < 250 threshold."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cholesterol WHERE patient_id = 2927464 AND date = '1995-9-4' AND status = 'normal';",
            "SELECT CASE WHEN \"T-CHO\" < 250 THEN 'Normal' ELSE 'Abnormal' END as status FROM Laboratory WHERE ID = 2927464 AND Date = '1995-09-04'"
        ],
        "rule_sql": [
            "SELECT \n    CASE \n        WHEN \"T-CHO\" < 250 THEN 'Normal' \n        ELSE 'Abnormal' \n    END AS cholesterol_status\nFROM Laboratory \nWHERE ID = 2927464 \nAND Date = '1995-09-04';"
        ],
        "amend_res": 1
    },
    "31": {
        "db_id": "california_schools",
        "question": "What is the eligible free rate of the 10th and 11th schools with the highest enrolment for students in grades 1 through 12?",
        "ground_truth": "SELECT CAST(`Free Meal Count (K-12)` AS REAL) / `Enrollment (K-12)` FROM frpm ORDER BY `Enrollment (K-12)` DESC LIMIT 9, 2",
        "amends": [
            "Do use explicit column calculation `CAST(Free Meal Count (K-12) AS REAL) / Enrollment (K-12)` instead of the precomputed `eligible_free_rate`. Do reference table `frpm` instead of `schools`. Do order by `Enrollment (K-12)` instead of `enrolment`. Do use `LIMIT 9, 2` syntax instead of `LIMIT 2 OFFSET 9` for the pagination. The amended query now correctly calculates the free meal rate on the fly and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about eligible free rate: calculate it as CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" instead of using a precomputed column. 2) When referencing the schools data: use table \"frpm\" instead of \"schools\". 3) When ordering by enrollment: use column \"Enrollment (K-12)\" in descending order instead of \"enrolment\". 4) When retrieving the 10th and 11th schools with highest enrollment: use LIMIT 9, 2 syntax to get 2 rows starting from position 10 (offset 9)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eligible_free_rate \nFROM schools \nORDER BY enrolment DESC \nLIMIT 2 OFFSET 9;",
            "SELECT \n    CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" AS eligible_free_rate\nFROM \n    frpm\nWHERE \n    \"Enrollment (K-12)\" IS NOT NULL\nORDER BY \n    \"Enrollment (K-12)\" DESC\nLIMIT 9, 2"
        ],
        "rule_sql": [
            "SELECT \n    CAST(\"Free Meal Count (K-12)\" AS REAL) / \"Enrollment (K-12)\" AS eligible_free_rate\nFROM \n    frpm\nWHERE \n    \"Enrollment (K-12)\" IS NOT NULL \n    AND \"Free Meal Count (K-12)\" IS NOT NULL\nORDER BY \n    \"Enrollment (K-12)\" DESC\nLIMIT 9, 2"
        ],
        "amend_res": 1
    },
    "951": {
        "db_id": "formula_1",
        "question": "How many Japanese constructors have 0 points in 2 races?",
        "ground_truth": "SELECT COUNT(T1.raceId) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T2.nationality = 'Japanese' GROUP BY T1.constructorId HAVING COUNT(raceId) = 2",
        "amends": [
            "Do join `constructorStandings` and `constructors` on `constructorId` instead of querying only `constructors`. Do filter on `points = 0` from `constructorStandings` instead of from `constructors`. Do filter on `nationality = 'Japanese'` from `constructors` instead of from the wrong table. Do aggregate by `constructorId` and count `raceId` instead of counting all rows. Do use `HAVING COUNT(raceId) = 2` to find constructors with exactly two races at zero points instead of filtering on a non-existent `races` column. Do select `COUNT(T1.raceId)` instead of `COUNT(*)` to count specific race occurrences. The amended query now correctly counts Japanese constructors with exactly two races where they scored zero points, matching the intended behavior.",
            "Do `COUNT(T1.raceId)` instead of `COUNT(DISTINCT cs.constructorId)` in the SELECT list. Do use table aliases `T1` and `T2` instead of `cs` and `c`. Do place the `T1.points = 0` filter in the `WHERE` clause instead of keeping it there but ensure both conditions are properly combined with `AND`. Do remove the redundant `GROUP BY T1.constructorId` since it's already present but ensure the HAVING clause correctly references `COUNT(raceId)` without table alias ambiguity. The amended query now correctly counts race occurrences for Japanese constructors with zero points that appear exactly twice, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about Japanese constructors with 0 points in 2 races: join \"constructorStandings\" as T1 and \"constructors\" as T2 where T1.\"constructorId\" = T2.\"constructorId\" and keep only matching pairs (inner match). 2) When filtering by nationality: use T2.\"nationality\" = 'Japanese' exactly as specified. 3) When filtering by points: use T1.\"points\" = 0 exactly as specified. 4) When counting races: count unique T1.\"raceId\" values per constructor. 5) When requiring exactly 2 races: ensure the count of T1.\"raceId\" equals 2. 6) When producing the final count: count the number of distinct T1.\"constructorId\" values that satisfy all conditions.",
            "1) When answering about \"Japanese constructors with 0 points in 2 races\": make sure the output order: count of constructors meeting the criteria. 2) When the question mentions \"Japanese\": \"Japanese\" actually means \"T2.nationality = 'Japanese'\" in schema. 3) When the question mentions \"0 points\": \"0 points\" actually means \"T1.points = 0\" in schema. 4) When the question asks for \"count of constructors\": compute the number of rows using the canonical key token T1.constructorId. 5) When combining T1 and T2 for shared entities: link rows where T1.constructorId = T2.constructorId; keep only matching pairs (inner match). 6) When the question asks for \"in 2 races\": ensure the count of T1.raceId equals 2 for each constructor group. 7) When grouping by constructor: organize results by T1.constructorId and compute COUNT(T1.raceId) per group, then filter to groups where this count equals exactly 2."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT COUNT(*) FROM constructors WHERE nationality = 'Japanese' AND points = 0 AND races = 2;",
            "SELECT COUNT(DISTINCT cs.constructorId) \nFROM constructorStandings cs\nJOIN constructors c ON cs.constructorId = c.constructorId\nWHERE c.nationality = 'Japanese' \nAND cs.points = 0\nGROUP BY cs.constructorId\nHAVING COUNT(cs.raceId) = 2",
            "SELECT COUNT(T1.raceId) \nFROM constructorStandings T1\nJOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T1.points = 0 AND T2.nationality = 'Japanese'\nGROUP BY T1.constructorId\nHAVING COUNT(T1.raceId) = 2"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.constructorId) \nFROM constructorStandings T1\nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId\nWHERE T2.nationality = 'Japanese' \n  AND T1.points = 0\nGROUP BY T1.constructorId\nHAVING COUNT(DISTINCT T1.raceId) = 2"
        ],
        "amend_res": 1
    },
    "385": {
        "db_id": "card_games",
        "question": "Write down the ruling of Beacon of Immortality.",
        "ground_truth": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
        "amends": [
            "Do select only `T2.text` instead of all columns with `*`. Do use `cards AS T1` and `rulings AS T2` as source tables instead of `magic_cards`. Do use `INNER JOIN` with `ON T1.uuid = T2.uuid` instead of querying a single table. Do filter on `T1.name = 'Beacon of Immortality'` instead of filtering on both `name` and `type`. Do remove the `type = 'Instant'` filter instead of keeping it. The amended query now correctly joins the cards and rulings tables to retrieve ruling text for the specified card name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the ruling of Beacon of Immortality\": make sure the output order: T2.text\n2) When the question mentions \"Beacon of Immortality\": \"Beacon of Immortality\" actually means T1.name = 'Beacon of Immortality' in schema\n3) When combining T1 (cards) and T2 (rulings) for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (T1.uuid = T2.uuid); keep only matching pairs (inner match)\n4) When selecting columns: do select only T2.text instead of all columns with *\n5) When filtering: do filter on T1.name = 'Beacon of Immortality' instead of filtering on both name and type\n6) When filtering: do remove the type = 'Instant' filter instead of keeping it"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM magic_cards WHERE name = 'Beacon of Immortality' AND type = 'Instant'",
            "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'"
        ],
        "rule_sql": [
            "SELECT T2.text\nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.name = 'Beacon of Immortality'"
        ],
        "amend_res": 1
    },
    "730": {
        "db_id": "superhero",
        "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
        "ground_truth": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
        "amends": [
            "Do use `superhero_name` from table `superhero AS T1` instead of `name` from `superheroes`. Do replace the direct `WHERE` filter approach with `EXISTS` subqueries instead of simple column comparisons. Do add a subquery checking for `Super Strength` through joins between `hero_power AS T2` and `superpower AS T3` on `T2.power_id = T3.id` instead of directly filtering `super_power`. Do add another subquery checking for `Marvel Comics` through table `publisher AS T4` on `T4.publisher_name` and relationship `T1.publisher_id = T4.id` instead of direct `publisher` column filter. Do use proper relationship-based filtering through foreign key connections (`T1.id = T2.hero_id` and `T1.publisher_id = T4.id`) instead of assuming direct column values. The amended query now correctly handles the normalized database structure and matches the intended behavior."
        ],
        "rules": [
            "1) When the question asks for superhero names: use \"superhero_name\" from table \"superhero\" as T1 instead of \"name\" from \"superheroes\". 2) When checking for 'Super Strength' super power: use an EXISTS subquery that joins \"hero_power\" as T2 with \"superpower\" as T3 on T2.power_id = T3.id where T3.super_power = 'Super Strength' and T1.id = T2.hero_id. 3) When checking for 'Marvel Comics' publisher: use an EXISTS subquery that joins \"publisher\" as T4 where T4.publisher_name = 'Marvel Comics' and T1.publisher_id = T4.id. 4) When combining tables for filtering: use inner matches through foreign key relationships T1.id = T2.hero_id and T1.publisher_id = T4.id instead of direct column value comparisons."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE publisher = 'Marvel Comics' AND super_power = 'Super Strength';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nWHERE EXISTS (\n    SELECT 1\n    FROM hero_power AS T2\n    JOIN superpower AS T3 ON T2.power_id = T3.id\n    WHERE T2.hero_id = T1.id\n    AND T3.power_name = 'Super Strength'\n)\nAND EXISTS (\n    SELECT 1\n    FROM publisher AS T4\n    WHERE T1.publisher_id = T4.id\n    AND T4.publisher_name = 'Marvel Comics'\n);"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nWHERE EXISTS (\n    SELECT 1\n    FROM hero_power AS T2\n    JOIN superpower AS T3 ON T2.power_id = T3.id\n    WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id\n)\nAND EXISTS (\n    SELECT 1\n    FROM publisher AS T4\n    WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id\n)"
        ],
        "amend_res": 1
    },
    "1222": {
        "db_id": "thrombosis_prediction",
        "question": "How many male patients are are with creatinine index out of the normal range?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND T1.SEX = 'M'",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific joined tables instead of `COUNT(*)` from a single table. Do use `INNER JOIN` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.CRE >= 1.5` for creatinine values instead of `creatinine > 1.2`. Do filter on `T1.SEX = 'M'` for male patients instead of `gender = 'male'`. The amended query now correctly joins patient and laboratory data with appropriate filtering criteria to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"male patients with creatinine index out of normal range\": make sure the output order: COUNT(T1.ID). 2) When the question mentions \"male patients\": \"male\" actually means \"T1.SEX = 'M'\" in schema. 3) When the question mentions \"creatinine index out of normal range\": \"out of normal range\" actually means \"T2.CRE >= 1.5\" in schema. 4) When combining patients table T1 and laboratory table T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 5) When counting patients: compute the number of rows using the canonical key token T1.ID."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND creatinine > 1.2",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.CRE >= 1.5"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' AND T2.CRE >= 1.5",
            "SELECT COUNT(T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.SEX = 'M' AND T2.CRE >= 1.5"
        ],
        "amend_res": 1
    },
    "278": {
        "db_id": "toxicology",
        "question": "How many of the single bond type molecules are non-carcinogenic?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "amends": [
            "Do select `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all bonds. Do join `bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table to properly relate bonds to their parent molecules. Do filter with `T2.label = '-' AND T1.bond_type = '-'` instead of `bond_type = 'single' AND carcinogenic = 'yes'` to use the correct column names and values for the intended chemical properties. The amended query now correctly counts distinct molecules with specific bond and label characteristics, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(DISTINCT T2.molecule_id) instead of COUNT(*) to count unique molecules rather than all bonds. 2) When combining bond and molecule tables: link rows where T1.molecule_id = T2.molecule_id using an inner join to properly relate bonds to their parent molecules. 3) When filtering for single bond type molecules: use T1.bond_type = '-' instead of bond_type = 'single' to match the exact column name and value format. 4) When filtering for non-carcinogenic molecules: use T2.label = '-' instead of carcinogenic = 'yes' to use the correct column name and value for the intended chemical property."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE bond_type = 'single' AND carcinogenic = 'yes';",
            "SELECT COUNT(DISTINCT T2.molecule_id) \nFROM bond AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.label = '-' AND T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.molecule_id) \nFROM bond T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.bond_type = '-' AND T2.label = '-'"
        ],
        "amend_res": 1
    },
    "1300": {
        "db_id": "thrombosis_prediction",
        "question": "What is the disease name of the patient who has the highest level of triglyceride within the normal range?",
        "ground_truth": "SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG < 200 ORDER BY T2.TG DESC LIMIT 1",
        "amends": [
            "Do select `Diagnosis` from `Examination` instead of `disease_name` from `patients`. Do join `Laboratory` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter with `T2.TG < 200` instead of `triglyceride <= 150`. Do add `ORDER BY T2.TG DESC LIMIT 1` instead of using a subquery to find the maximum value. The amended query now correctly retrieves the diagnosis with the highest triglyceride value below 200 from joined examination and laboratory data, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"disease name\": use \"Diagnosis\" from table \"Examination\" instead of \"disease_name\" from \"patients\". 2) When combining patient examination and laboratory data: link rows where T1.ID = T2.ID using an inner join between the tables. 3) When filtering for triglyceride levels within normal range: use the condition T2.TG < 200 instead of triglyceride <= 150. 4) When finding the highest triglyceride level: order results by T2.TG in descending order and take only the top 1 result instead of using a subquery to find the maximum value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disease_name FROM patients WHERE triglyceride = (SELECT MAX(triglyceride) FROM patients WHERE triglyceride <= 150);",
            "SELECT E.Diagnosis \nFROM Examination E\nINNER JOIN Laboratory L ON E.ID = L.ID\nWHERE L.TG < 200\nORDER BY L.TG DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT e.Diagnosis\nFROM Examination e\nINNER JOIN Laboratory l ON e.ID = l.ID\nWHERE l.TG < 200\nORDER BY l.TG DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "742": {
        "db_id": "superhero",
        "question": "How many vampire superheroes are there?",
        "ground_truth": "SELECT COUNT(T1.superhero_name) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'",
        "amends": [
            "Do join `superhero AS T1` with `race AS T2` on `T1.race_id = T2.id` instead of querying only the `superheroes` table. Do filter on `T2.race = 'Vampire'` instead of `power = 'vampire'` to correctly identify vampires by race rather than power. Do count `T1.superhero_name` instead of `COUNT(*)` to count specific superhero names rather than all rows. The amended query now correctly joins tables and filters by race to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"vampire superheroes\": join table \"superhero\" (as T1) with table \"race\" (as T2) using the condition T1.race_id = T2.id to combine superhero and race information. 2) When the question mentions \"vampire\": filter rows where T2.race equals exactly 'Vampire' (case-sensitive) to identify vampire superheroes by their race. 3) When counting superhero entities: count the number of distinct T1.superhero_name values to get the count of vampire superheroes."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE power = 'vampire';",
            "SELECT COUNT(T1.superhero_name) \nFROM superhero AS T1 \nJOIN race AS T2 ON T1.race_id = T2.id \nWHERE T2.race = 'Vampire'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.superhero_name) \nFROM superhero T1\nJOIN race T2 ON T1.race_id = T2.id\nWHERE T2.race = 'Vampire'"
        ],
        "amend_res": 1
    },
    "1089": {
        "db_id": "european_football_2",
        "question": "How many matches in the 2008/2009 season were held in Belgium?",
        "ground_truth": "SELECT COUNT(t2.id) FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id WHERE t1.name = 'Belgium' AND t2.season = '2008/2009'",
        "amends": [
            "Do select `COUNT(t2.id)` instead of `COUNT(*)` to count specific match records. Do join `Country AS t1` and `Match AS t2` with `INNER JOIN` on `t1.id = t2.country_id` instead of querying a single table. Do filter by `t1.name = 'Belgium'` instead of `country = 'Belgium'` to use the proper country name column from the joined table. Do filter by `t2.season = '2008/2009'` instead of `season = '2008/2009'` to specify the table alias for clarity. The amended query now correctly joins the Country and Match tables to count Belgian matches from the 2008/2009 season using proper relational integrity."
        ],
        "rules": [
            "1) When counting matches: use COUNT(t2.id) instead of COUNT(*) to count specific match records. 2) When combining Country and Match tables: link rows where t1.id = t2.country_id using an inner join to maintain relational integrity. 3) When filtering by country name: use t1.name = 'Belgium' instead of country = 'Belgium' to reference the proper country name column. 4) When filtering by season: use t2.season = '2008/2009' instead of season = '2008/2009' to specify the table alias for clarity."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE season = '2008/2009' AND country = 'Belgium';",
            "SELECT COUNT(t2.id) \nFROM Country AS t1 \nINNER JOIN Match AS t2 ON t1.id = t2.country_id \nWHERE t1.name = 'Belgium' AND t2.season = '2008/2009'"
        ],
        "rule_sql": [
            "SELECT COUNT(t2.id) \nFROM Country t1 \nINNER JOIN Match t2 ON t1.id = t2.country_id \nWHERE t1.name = 'Belgium' AND t2.season = '2008/2009'"
        ],
        "amend_res": 1
    },
    "62": {
        "db_id": "california_schools",
        "question": "What is the total number of non-chartered schools in the county of Los Angeles with a percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%?",
        "ground_truth": "SELECT COUNT(T2.School) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.Charter = 0 AND CAST(T1.`Free Meal Count (K-12)` AS REAL) * 100 / T1.`Enrollment (K-12)` < 0.18",
        "amends": [
            "Do join `frpm AS T1` and `schools AS T2` instead of querying only `schools` table. Do use `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of no join condition. Do reference `T2.County` instead of `county` and `T2.Charter = 0` instead of `charter = 'No'`. Do calculate free meal percentage using `CAST(T1.\"Free Meal Count (K-12)\" AS REAL) * 100 / T1.\"Enrollment (K-12)\" < 0.18` instead of `percent_free_meals < 0.18`. Do remove the `grade_level` filter instead of including it. Do count `T2.School` instead of `COUNT(*)`. The amended query now correctly joins the frpm table to access meal count data and calculates the percentage properly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about non-chartered schools in Los Angeles county: use T2.\"County\" = 'Los Angeles' instead of county = 'Los Angeles'. 2) When identifying non-chartered schools: use T2.Charter = 0 instead of charter = 'No'. 3) When calculating free meal percentage: compute CAST(T1.\"Free Meal Count (K-12)\" AS REAL) * 100 / T1.\"Enrollment (K-12)\" < 0.18 instead of using a pre-calculated percent_free_meals column. 4) When combining frpm and schools tables: perform an INNER JOIN on T1.CDSCode = T2.CDSCode to link related records. 5) When counting schools: count T2.School instead of using COUNT(*). 6) When filtering by grade levels: do not include grade_level filters as the question specifies grades 1 through 12 but the calculation uses K-12 enrollment data."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools \nWHERE county = 'Los Angeles' \nAND charter = 'No' \nAND percent_free_meals < 0.18 \nAND (grade_level = '1-12' OR grade_level LIKE '%1-12%');",
            "SELECT COUNT(T2.School) \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.County = 'Los Angeles' \nAND T2.Charter = 0 \nAND (CAST(T1.\"Free Meal Count (K-12)\" AS REAL) * 100 / T1.\"Enrollment (K-12)\") < 0.18"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.School) \nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.\"County\" = 'Los Angeles' \nAND T2.Charter = 0\nAND (CAST(T1.\"Free Meal Count (K-12)\" AS REAL) * 100 / T1.\"Enrollment (K-12)\") < 0.18"
        ],
        "amend_res": 1
    },
    "1023": {
        "db_id": "european_football_2",
        "question": "Among the players with an overall rating between 60 to 65, how many players whose going to be in all of your attack moves instead of defensing?",
        "ground_truth": "SELECT COUNT(id) FROM Player_Attributes WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do query from `Player_Attributes` instead of `players` to access the correct table. Do filter on `defensive_work_rate = 'low'` instead of `attack_moves = 'all' AND defense = 'no'` to use the appropriate defensive rating column. Do remove the extraneous `attack_moves` condition that doesn't exist in the target schema. The amended query now correctly counts players with overall ratings between 60-65 and low defensive work rate, matching the intended behavior."
        ],
        "rules": [
            "1) When counting players: count \"id\" instead of \"*\" to avoid counting null values. 2) When querying player attributes: use table \"Player_Attributes\" instead of \"players\" to access the correct table. 3) When filtering for players who focus on attack moves instead of defense: use condition \"defensive_work_rate = 'low'\" instead of non-existent attack_moves conditions. 4) When filtering for overall rating between 60 to 65: use \"overall_rating BETWEEN 60 AND 65\" to include the specified range."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM players \nWHERE overall_rating BETWEEN 60 AND 65 \nAND attack_moves = 'all' \nAND defense = 'no'",
            "SELECT COUNT(id) FROM Player_Attributes WHERE overall_rating BETWEEN 60 AND 65 AND defensive_work_rate = 'low'"
        ],
        "rule_sql": [
            "SELECT COUNT(id) \nFROM Player_Attributes \nWHERE overall_rating BETWEEN 60 AND 65 \nAND defensive_work_rate = 'low'"
        ],
        "amend_res": 1
    },
    "825": {
        "db_id": "superhero",
        "question": "Identify the gender of the superhero who has the ability of Phoenix Force.",
        "ground_truth": "SELECT T4.gender FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.power_name = 'Phoenix Force'",
        "amends": [
            "Do join `superhero AS T1` instead of querying `superheroes` directly. Do add `INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id` instead of omitting the hero-power relationship. Do add `INNER JOIN superpower AS T3 ON T2.power_id = T3.id` instead of missing the power table connection. Do add `INNER JOIN gender AS T4 ON T1.gender_id = T4.id` instead of accessing gender directly from superhero. Do filter on `T3.power_name = 'Phoenix Force'` instead of `ability = 'Phoenix Force'` to use the proper column reference. Do select `T4.gender` instead of `gender` to specify the joined table source. The amended query now correctly retrieves gender information through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about superhero gender with a specific ability: join superhero as T1, hero_power as T2, superpower as T3, and gender as T4 using the exact relationships shown. 2) When the question mentions \"ability of Phoenix Force\": filter on T3.power_name = 'Phoenix Force' exactly as written. 3) When selecting gender information: use T4.gender from the joined gender table instead of directly from superhero. 4) When combining tables: use inner joins with T1.id = T2.hero_id and T2.power_id = T3.id and T1.gender_id = T4.id to ensure proper relationship matching. 5) When the schema shows gender values as 'Male', 'Female', 'N/A': preserve these exact literal values in output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender FROM superheroes WHERE ability = 'Phoenix Force';",
            "SELECT T4.gender\nFROM superhero AS T1\nINNER JOIN hero_power AS T2 ON T1.id = T2.hero_id\nINNER JOIN superpower AS T3 ON T2.power_id = T3.id\nINNER JOIN gender AS T4 ON T1.gender_id = T4.id\nWHERE T3.power_name = 'Phoenix Force'"
        ],
        "rule_sql": [
            "SELECT T4.gender\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nINNER JOIN gender T4 ON T1.gender_id = T4.id\nWHERE T3.power_name = 'Phoenix Force'"
        ],
        "amend_res": 1
    },
    "1517": {
        "db_id": "debit_card_specializing",
        "question": "For the earliest customer, what segment did he/she have?",
        "evidence": "",
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY Date ASC LIMIT 1",
        "amends": [
            "Do add `transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID` as the FROM source instead of querying `customers` alone. Do change the SELECT list to `T2.Segment` instead of `segment` to specify the table alias. Do change the ORDER BY clause to `Date ASC` instead of `customer_id ASC` to sort by transaction date rather than customer identifier. Do remove the direct table reference from the SELECT clause and instead join through the transactions table to ensure the segment is retrieved in the context of transaction data. The amended query now correctly retrieves the customer segment associated with the earliest transaction rather than an arbitrary customer segment, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the earliest customer\": make sure the output order: sort by Date ASC to find the earliest transaction. 2) When combining transaction and customer data: link rows where T1.CustomerID = T2.CustomerID and keep only matching pairs (inner match). 3) When retrieving customer segment information: use T2.Segment to specify the exact column from the customers table. 4) When the question asks for segment of the earliest customer: retrieve only the first result after ordering by transaction date."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT segment FROM customers ORDER BY customer_id ASC LIMIT 1;",
            "SELECT T2.Segment \nFROM transactions_1k AS T1 \nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nORDER BY Date ASC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT c.Segment \nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nORDER BY t.Date ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1146": {
        "db_id": "european_football_2",
        "question": "Please provide the full name of the away team that scored the most goals.",
        "ground_truth": "SELECT t2.team_long_name FROM Match AS t1 INNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id ORDER BY t1.away_team_goal DESC LIMIT 1",
        "amends": [
            "Do select `t2.team_long_name` instead of `away_team_name` and remove the `SUM(away_goals)` aggregate instead of keeping it. Do use `FROM Match AS t1 INNER JOIN Team AS t2` instead of just `FROM matches` and change the join condition to `ON t1.away_team_api_id = t2.team_api_id` instead of grouping by team name. Do remove the `GROUP BY` clause instead of grouping by team name and change the ordering to `ORDER BY t1.away_team_goal DESC` instead of ordering by the aggregated total goals. The amended query now correctly retrieves the single team with the highest away goal in a match rather than calculating aggregate totals per team."
        ],
        "rules": [
            "1) When answering about \"the away team that scored the most goals\": make sure the output order: t2.team_long_name. 2) When the question mentions \"away team\": \"away team\" actually means \"t2.team_long_name in schema\". 3) When the question mentions \"most goals\" or \"highest goals\": rank rows by t1.away_team_goal in descending direction and keep the first 1 row. 4) When combining T1 (Match) and T2 (Team) for shared entities: link rows where t1.away_team_api_id = t2.team_api_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT away_team_name, SUM(away_goals) as total_goals \nFROM matches \nGROUP BY away_team_name \nORDER BY total_goals DESC \nLIMIT 1;",
            "SELECT t2.team_long_name \nFROM Match AS t1 \nINNER JOIN Team AS t2 ON t1.away_team_api_id = t2.team_api_id \nORDER BY t1.away_team_goal DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT t2.team_long_name\nFROM \"Match\" t1\nINNER JOIN \"Team\" t2 ON t1.away_team_api_id = t2.team_api_id\nORDER BY t1.away_team_goal DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1391": {
        "db_id": "student_club",
        "question": "What is the ratio between students majored in finance and physics?",
        "ground_truth": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
        "amends": [
            "Do use `SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END)` instead of `COUNT(*)` with `major = 'finance'` to properly count Finance majors. Do use `SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END)` instead of `COUNT(*)` with `major = 'physics'` to properly count Physics majors. Do query from the `major` table instead of the `students` table to access the correct data source. Do reference `major_name` column instead of `major` column to use the proper column name. Do use proper case `'Finance'` and `'Physics'` instead of lowercase `'finance'` and `'physics'` to match the actual data values. Do calculate the ratio directly in a single query instead of using separate subqueries for better performance and accuracy. The amended query now correctly calculates the ratio of Finance to Physics majors from the appropriate table and column."
        ],
        "rules": [
            "1) When the question asks for a ratio between students majored in finance and physics: calculate (number of Finance majors) divided by (number of Physics majors) from the major table. 2) When counting Finance majors: use SUM(CASE WHEN \"major_name\" = 'Finance' THEN 1 ELSE 0 END) to properly count Finance majors. 3) When counting Physics majors: use SUM(CASE WHEN \"major_name\" = 'Physics' THEN 1 ELSE 0 END) to properly count Physics majors. 4) When accessing major data: query from the \"major\" table instead of the \"students\" table to use the correct data source. 5) When referring to major names: use the column \"major_name\" instead of \"major\" to access the proper column name. 6) When matching literal values: use exact case 'Finance' and 'Physics' instead of lowercase 'finance' and 'physics' to match the actual data values. 7) When calculating ratios: perform the calculation in a single query instead of using separate subqueries for better performance and accuracy."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM students WHERE major = 'finance') / \n    (SELECT COUNT(*) FROM students WHERE major = 'physics') AS finance_physics_ratio;",
            "SELECT \n    CAST(SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS finance_to_physics_ratio\nFROM \n    major;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / \n    NULLIF(SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END), 0) AS finance_to_physics_ratio\nFROM \n    major;"
        ],
        "amend_res": 1
    },
    "914": {
        "db_id": "formula_1",
        "question": "How many drivers don't have a code?",
        "ground_truth": "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers",
        "amends": [
            "Do use `COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END)` instead of `COUNT(*)` to calculate the count of drivers where code is null rather than all non-null code entries. Do remove the `WHERE code IS NOT NULL` filter instead of keeping it, as the correct logic requires counting all drivers and subtracting those with non-null codes to find drivers with null codes. The amended query now correctly calculates the count of drivers with null code values by using arithmetic between two aggregate functions instead of a simple count with filtering."
        ],
        "rules": [
            "1) When counting drivers that don't have a code: calculate the total count of drivers using the canonical key \"driverId\" minus the count of drivers where \"code\" is not null. 2) When handling null values for \"code\": use the exact condition \"code IS NOT NULL\" to identify drivers with non-null codes. 3) When computing the difference between counts: perform arithmetic subtraction between the total driver count and the count of drivers with non-null codes to get the count of drivers with null codes."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE code IS NOT NULL;",
            "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN code END) FROM drivers;"
        ],
        "rule_sql": [
            "SELECT COUNT(driverId) - COUNT(CASE WHEN code IS NOT NULL THEN 1 END) AS drivers_without_code FROM drivers;"
        ],
        "amend_res": 1
    },
    "1288": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the diagnosis of the patients whose total protein is lower than normal.",
        "ground_truth": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
        "amends": [
            "Do select `T1.Diagnosis` from the `Patient` table instead of `diagnosis` from the `patients` table. Do add an `INNER JOIN` with the `Laboratory` table on `T1.ID = T2.ID` instead of querying only a single table. Do filter on `T2.TP < 6.0` from the joined Laboratory table instead of `total_protein < 6.0` from the original table. The amended query now correctly joins the Patient and Laboratory tables to filter based on laboratory test results rather than assuming the protein data exists in the patient table directly, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"diagnosis of patients whose total protein is lower than normal\": make sure the output order: T1.Diagnosis. 2) When the question mentions \"patients\": \"patients\" actually means \"Patient table (T1)\" in schema. 3) When the question mentions \"total protein\": \"total protein\" actually means \"TP column in Laboratory table (T2)\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.ID = T2.ID; keep only matching pairs (inner match). 5) When filtering for \"lower than normal\" total protein: filter on T2.TP < 6.0 using the exact literal value 6.0."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT diagnosis FROM patients WHERE total_protein < 6.0",
            "SELECT T1.Diagnosis FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Diagnosis\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.TP < 6.0\nORDER BY T1.Diagnosis;"
        ],
        "amend_res": 1
    },
    "396": {
        "db_id": "card_games",
        "question": "How many cards with a 1993 frame version and available on paper have a sensitive content warning?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1",
        "amends": [
            "Do count `id` instead of `*` to avoid counting null values. Do use column name `frameVersion` with integer value `1993` instead of string `'1993'` for proper data type matching. Do filter on `availability = 'paper'` instead of `paper_available = 1` to use the correct column name and string value. Do filter on `hasContentWarning = 1` instead of `sensitive_content_warning = 0` to properly identify cards with content warnings using the correct column name and boolean logic. The amended query now correctly counts cards with the specified frame version, paper availability, and content warning status."
        ],
        "rules": [
            "1) When counting cards: count using the canonical key \"id\" instead of counting all columns to avoid null values. 2) When filtering by frame version: use column \"frameVersion\" with integer value 1993 instead of string '1993' for proper data type matching. 3) When filtering by availability: use column \"availability\" with string value 'paper' instead of boolean 1 to use the correct column name and value format. 4) When filtering for content warnings: use column \"hasContentWarning\" with value 1 instead of 0 to properly identify cards with content warnings using the correct boolean logic."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE frame_version = '1993' AND paper_available = 1 AND sensitive_content_warning = 0;",
            "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1"
        ],
        "amend_res": 1
    },
    "143": {
        "db_id": "financial",
        "question": "What are the accounts that have gold credit cards?",
        "evidence": "",
        "ground_truth": "SELECT T2.account_id FROM disp AS T2  INNER JOIN card AS T1 ON T1.disp_id = T2.disp_id  WHERE T1.type = 'gold'",
        "amends": [
            "Do select `T2.account_id` instead of `*` to return only the specific required column. Do use `FROM disp AS T2` and `INNER JOIN card AS T1` instead of `FROM accounts` to properly join the disp and card tables. Do use join condition `T1.disp_id = T2.disp_id` instead of no join condition to correctly relate the tables. Do filter on `T1.type = 'gold'` instead of `credit_card_type = 'gold'` to use the correct column name from the joined card table. The amended query now correctly identifies accounts with gold cards by joining through the proper relationship between disp and card tables."
        ],
        "rules": [
            "1) When answering about \"accounts that have gold credit cards\": make sure the output order: T2.account_id. 2) When the question mentions \"accounts\": \"accounts\" actually means \"T2.account_id in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.disp_id = T2.disp_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for gold credit cards: use T1.type = 'gold' with exact literal 'gold' (case-sensitive)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM accounts WHERE credit_card_type = 'gold';",
            "SELECT T2.account_id\nFROM disp AS T2\nINNER JOIN card AS T1 ON T1.disp_id = T2.disp_id\nWHERE T1.type = 'gold'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.account_id\nFROM card T1\nINNER JOIN disp T2 ON T1.disp_id = T2.disp_id\nWHERE T1.type = 'gold'\nORDER BY T2.account_id"
        ],
        "amend_res": 1
    },
    "863": {
        "db_id": "formula_1",
        "question": "Show me the season page of year when the race No. 901 took place.",
        "ground_truth": "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901",
        "amends": [
            "Do add `T2.url` in the SELECT list instead of `season`. Do add `INNER JOIN seasons AS T2 ON T2.year = T1.year` instead of querying only the `races` table. Do change the table reference to `races AS T1` instead of just `races`. Do keep the `WHERE T1.raceId = 901` filter but add the table alias. The amended query now correctly joins seasons data to retrieve the URL instead of just the season value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"the season page of year when the race No. 901 took place\": make sure the output order: T2.url 2) When the question mentions \"season page\": \"season page\" actually means \"T2.url in schema\" 3) When combining T1 and T2 for shared entities: link rows where T2.year = T1.year; keep only matching pairs (inner match) 4) When filtering for race No. 901: use WHERE T1.raceId = 901 with exact literal value 901 5) When referring to table roles: use races AS T1 and seasons AS T2 as specified in the amends"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT season FROM races WHERE raceId = 901;",
            "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901"
        ],
        "rule_sql": [
            "SELECT T2.url FROM races AS T1 INNER JOIN seasons AS T2 ON T2.year = T1.year WHERE T1.raceId = 901"
        ],
        "amend_res": 1
    },
    "1092": {
        "db_id": "european_football_2",
        "question": "Give the name of the league had the most matches in the 2008/2009 season?",
        "ground_truth": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
        "amends": [
            "Do select `t1.name` instead of `league_name` and use explicit table aliases. Do join `League AS t1` with `Match AS t2` on `t1.id = t2.league_id` instead of querying only the `leagues` table. Do move the season filter to the `WHERE` clause on `t2.season` instead of applying it directly to the leagues table. Do add `GROUP BY t1.name` and `HAVING COUNT(t2.id)` with a subquery to find the maximum match count instead of using `ORDER BY COUNT(matches) DESC LIMIT 1`. Do include a correlated subquery that calculates `MAX(match_count)` from a derived table grouping by `t2.league_id` instead of simply ordering and limiting. The amended query now correctly identifies the league with the most matches in the specified season by properly joining tables and using aggregate comparison logic."
        ],
        "rules": [
            "1) When answering about \"league had the most matches\": make sure the output order: t1.name 2) When the question mentions \"league name\": \"league name\" actually means \"t1.name in schema\" 3) When combining T1 and T2 for shared entities: link rows where t1.id = t2.league_id; keep only matching pairs (inner match) 4) When the question mentions \"2008/2009 season\": apply the filter t2.season = '2008/2009' exactly as written 5) When the question asks for \"most matches\" by count: group results by t1.name and compute COUNT(t2.id) per group 6) When finding the maximum count: use a subquery to calculate MAX(match_count) from the grouped results and compare COUNT(t2.id) to this maximum value 7) When counting matches: use t2.id as the canonical counting key for matches"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT league_name \nFROM leagues \nWHERE season = '2008/2009' \nORDER BY COUNT(matches) DESC \nLIMIT 1;",
            "SELECT t1.name \nFROM League AS t1\nJOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2008/2009'\nGROUP BY t1.name\nHAVING COUNT(t2.id) = (\n    SELECT MAX(match_count)\n    FROM (\n        SELECT COUNT(t3.id) AS match_count\n        FROM Match AS t3\n        WHERE t3.season = '2008/2009'\n        GROUP BY t3.league_id\n    )\n)"
        ],
        "rule_sql": [
            "SELECT t1.name \nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2008/2009'\nGROUP BY t1.name\nHAVING COUNT(t2.id) = (\n    SELECT MAX(match_count)\n    FROM (\n        SELECT COUNT(t2_inner.id) AS match_count\n        FROM League AS t1_inner\n        INNER JOIN Match AS t2_inner ON t1_inner.id = t2_inner.league_id\n        WHERE t2_inner.season = '2008/2009'\n        GROUP BY t1_inner.name\n    )\n)"
        ],
        "amend_res": 1
    },
    "1156": {
        "db_id": "thrombosis_prediction",
        "question": "State the ID and age of patient with positive degree of coagulation.",
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.RVVT = '+'",
        "amends": [
            "Do select `DISTINCT T1.ID` and a calculated age expression using `STRFTIME` instead of `patient_id` and `age`. Do join `Patient AS T1` with `Examination AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.RVVT = '+'` instead of `coagulation_degree = 'positive'`. The amended query now correctly matches RIGHT_SQL's behavior by properly calculating age from birthday and filtering based on examination results rather than patient attributes.",
            "Do use `CURRENT_TIMESTAMP` instead of `'now'` for the current timestamp function. Do remove the complex age calculation `- (STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T1.Birthday))` instead of keeping it, simplifying to just the year difference calculation. The amended query now correctly calculates age using only year differences without the month-day adjustment, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patient ID and age: make sure the output order: T1.ID first, then calculated age expression using STRFTIME. 2) When the question mentions \"positive degree of coagulation\": \"positive\" actually means \"RVVT = '+'\" in the Examination table. 3) When combining Patient (T1) and Examination (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 4) When calculating patient age: compute age from birthday using STRFTIME function instead of using a direct age column. 5) When filtering for coagulation results: use T2.RVVT = '+' instead of coagulation_degree = 'positive'.",
            "1) When calculating age from a birthday field: use CURRENT_TIMESTAMP instead of 'now' for the current timestamp function. 2) When computing age from year differences: calculate only the year difference without month-day adjustments, using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday). 3) When the question asks for \"positive degree of coagulation\": this corresponds to T2.RVVT = '+' condition. 4) When combining Patient and Examination tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 5) When answering about patient ID and age: make sure the output order is T1.ID followed by the calculated age."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, age FROM patients WHERE coagulation_degree = 'positive';",
            "SELECT DISTINCT T1.ID, STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T1.Birthday)) AS age FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.RVVT = '+'",
            "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS age\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T2.RVVT = '+'"
        ],
        "rule_sql": [
            "SELECT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS Age\nFROM Patient T1\nINNER JOIN Examination T2 ON T1.ID = T2.ID\nWHERE T2.RVVT = '+'"
        ],
        "amend_res": 1
    },
    "1473": {
        "db_id": "debit_card_specializing",
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "ground_truth": "SELECT AVG(T2.Consumption) / 12 FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME'",
        "amends": [
            "Do add table `yearmonth AS T2` with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do change the consumption source to `T2.Consumption` instead of the original `consumption` column. Do replace the `WHERE` filter with `SUBSTR(T2.Date, 1, 4) = '2013'` instead of `year = 2013`. Do change the customer filter to `T1.Segment = 'SME'` instead of `customer_type = 'SME'`. Do remove the `GROUP BY month` clause and instead calculate `AVG(T2.Consumption) / 12` to get the annual average directly. The amended query now correctly joins the necessary tables and handles the date-based filtering and aggregation to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about average monthly consumption: calculate the average of T2.Consumption divided by 12 to get the annual average directly instead of grouping by month. 2) When the question mentions customers in SME: filter using T1.Segment = 'SME' instead of customer_type. 3) When the question specifies the year 2013: filter using SUBSTR(T2.Date, 1, 4) = '2013' instead of a year column. 4) When combining customer and consumption data: join tables using T1.CustomerID = T2.CustomerID with an inner match. 5) When selecting consumption data: use T2.Consumption as the source instead of a consumption column from the customers table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(consumption) FROM customers WHERE customer_type = 'SME' AND year = 2013 GROUP BY month;",
            "SELECT AVG(T2.Consumption) / 12 AS average_monthly_consumption\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME'\nAND SUBSTR(T2.Date, 1, 4) = '2013'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.Consumption) / 12 AS average_monthly_consumption\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'SME'\nAND SUBSTR(T2.Date, 1, 4) = '2013'"
        ],
        "amend_res": 1
    },
    "891": {
        "db_id": "formula_1",
        "question": "Name all drivers in the 2010 Singapore Grand Prix order by their position stands.",
        "evidence": "",
        "ground_truth": "SELECT T3.forename, T3.surname FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010 ORDER BY T2.position ASC",
        "amends": [
            "Do select `T3.forename` and `T3.surname` instead of just `driver_name`. Do join `races AS T1` and `driverStandings AS T2` with `INNER JOIN` on `T2.raceId = T1.raceId` instead of querying only the `drivers` table. Do add a second `INNER JOIN` to `drivers AS T3` on `T3.driverId = T2.driverId` instead of missing these table relationships. Do filter with `T1.name = 'Singapore Grand Prix' AND T1.year = 2010` instead of just `race = '2010 Singapore Grand Prix'` to properly separate year and race name. Do order by `T2.position ASC` with explicit table qualification instead of just `position`. The amended query now correctly joins multiple tables to retrieve driver names with proper race year filtering and position ordering."
        ],
        "rules": [
            "1) When answering about driver names in a specific race: select both T3.forename and T3.surname instead of just driver_name. 2) When the question mentions \"2010 Singapore Grand Prix\": filter using T1.name = 'Singapore Grand Prix' AND T1.year = 2010 to properly separate year and race name. 3) When combining tables for race and driver standings: link rows where T2.raceId = T1.raceId using an inner match. 4) When combining tables for driver information: link rows where T3.driverId = T2.driverId using an inner match. 5) When ordering by position: order by T2.position ASC with explicit table qualification. 6) When the question asks for drivers in a specific race order by position: use the canonical position column T2.position from the driverStandings table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM drivers WHERE race = '2010 Singapore Grand Prix' ORDER BY position;",
            "SELECT T3.forename, T3.surname\nFROM races AS T1\nINNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010\nORDER BY T2.position ASC"
        ],
        "rule_sql": [
            "SELECT T3.forename, T3.surname \nFROM races T1\nINNER JOIN driverStandings T2 ON T2.raceId = T1.raceId\nINNER JOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T1.name = 'Singapore Grand Prix' AND T1.year = 2010\nORDER BY T2.position ASC"
        ],
        "amend_res": 1
    },
    "1171": {
        "db_id": "thrombosis_prediction",
        "question": "How many underage patients were examined during the course of the three-year period from 1990 to 1993?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1990' AND '1993' AND STRFTIME('%Y', T2.`Examination Date`) - STRFTIME('%Y', T1.Birthday) < 18",
        "amends": [
            "Do join `Patient AS T1` with `Examination AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter by `STRFTIME('%Y', T2.Examination Date)` between '1990' and '1993' instead of using `examination_date BETWEEN` with full date ranges. Do calculate age using `STRFTIME('%Y', T2.Examination Date) - STRFTIME('%Y', T1.Birthday) < 18` instead of filtering by a static `age < 18` column. Do count `T1.ID` instead of using `COUNT(*)`. The amended query now correctly calculates patient age at examination time and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about underage patients examined during 1990-1993: join Patient as T1 with Examination as T2 using T1.ID = T2.ID to link patient records with their examinations. 2) When calculating patient age at examination time: compute age using STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.Birthday) < 18 instead of using a static age column. 3) When filtering by the three-year period from 1990 to 1993: use STRFTIME('%Y', T2.\"Examination Date\") between '1990' and '1993' instead of full date range comparisons. 4) When counting underage patients: count T1.ID instead of using COUNT(*) to ensure each patient is counted only once regardless of multiple examinations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE age < 18 AND examination_date BETWEEN '1990-01-01' AND '1993-12-31';",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1990' AND '1993' \nAND (STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.Birthday)) < 18"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nJOIN Examination T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T2.\"Examination Date\") BETWEEN '1990' AND '1993'\nAND (STRFTIME('%Y', T2.\"Examination Date\") - STRFTIME('%Y', T1.Birthday)) < 18"
        ],
        "amend_res": 1
    },
    "268": {
        "db_id": "toxicology",
        "question": "What are the elements for bond id TR001_10_11?",
        "ground_truth": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select only `T2.element` instead of all columns with `*`. Do join `connected AS T1` and `atom AS T2` with `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of querying only the `bonds` table. Do filter on `T1.bond_id = 'TR001_10_11'` instead of filtering directly on the bonds table. The amended query now correctly retrieves element information from the atom table through the connected relationship using the specified bond_id, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about elements for a specific bond id: make sure the output order: T2.element 2) When the question mentions \"bond id TR001_10_11\": filter rows where T1.bond_id equals exactly 'TR001_10_11' 3) When combining connected as T1 and atom as T2: link rows where T1.atom_id equals T2.atom_id and keep only matching pairs (inner match) 4) When selecting output columns: choose only T2.element instead of all columns"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM bonds WHERE bond_id = 'TR001_10_11';",
            "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'"
        ],
        "rule_sql": [
            "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR001_10_11'"
        ],
        "amend_res": 1
    },
    "1174": {
        "db_id": "thrombosis_prediction",
        "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
        "ground_truth": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
        "amends": [
            "Do calculate age using `'1999' - STRFTIME('%Y', T2.Birthday)` instead of using a simple `age` column. Do join `Laboratory AS T1` with `Patient AS T2` on `T1.ID = T2.ID` instead of querying a single `patients` table. Do filter with `T1.Date BETWEEN '1991-10-01' AND '1991-10-30'` instead of using `examination_date LIKE '1991-10%' AND examination_year = 1999`. The amended query now correctly calculates patient ages from birth year and filters laboratory examinations from October 1991, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating patient age as of year 1999: compute age using '1999' - STRFTIME('%Y', T2.Birthday) instead of using a simple age column. 2) When combining laboratory and patient data: join Laboratory AS T1 with Patient AS T2 on T1.ID = T2.ID using inner match. 3) When filtering for laboratory examinations in October 1991: use T1.Date BETWEEN '1991-10-01' AND '1991-10-30' instead of examination_date LIKE '1991-10%' AND examination_year = 1999. 4) When answering about average age of patients: make sure the output order: average age calculated from the age computation rule."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(age) FROM patients WHERE examination_date LIKE '1991-10%' AND examination_year = 1999;",
            "SELECT AVG(1999 - STRFTIME('%Y', T2.Birthday)) AS average_age\nFROM Laboratory AS T1\nJOIN Patient AS T2 ON T1.ID = T2.ID\nWHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'"
        ],
        "rule_sql": [
            "SELECT AVG(1999 - STRFTIME('%Y', T2.Birthday)) AS average_age\nFROM Laboratory AS T1\nINNER JOIN Patient AS T2 ON T1.ID = T2.ID\nWHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'"
        ],
        "amend_res": 1
    },
    "63": {
        "db_id": "california_schools",
        "question": "In chartered schools with charter number 00D2, what are the names of all the administrators? Include the name of the school and the city to which it belongs",
        "ground_truth": "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'",
        "amends": [
            "Do select columns `AdmFName1`, `AdmLName1`, `School`, and `City` instead of `administrator_name`, `school_name`, and `city`. Do add filter conditions `Charter = 1` and `CharterNum = '00D2'` instead of only `charter_number = '00D2'`. The amended query now correctly filters for charter schools with the specific charter number and returns the appropriate administrator name fields split into first and last name components."
        ],
        "rules": [
            "1) When the question asks for administrator names: use both \"AdmFName1\" and \"AdmLName1\" columns instead of a single administrator_name field. 2) When filtering for chartered schools: apply both conditions \"Charter = 1\" and \"CharterNum = '00D2'\" instead of only checking charter number. 3) When selecting school information: use exact column names \"School\" for school name and \"City\" for city instead of generic names. 4) When answering about chartered schools with specific charter number: ensure the output order includes administrator first name, administrator last name, school name, and city in that sequence."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT administrator_name, school_name, city FROM schools WHERE charter_number = '00D2';",
            "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'"
        ],
        "rule_sql": [
            "SELECT AdmFName1, AdmLName1, School, City FROM schools WHERE Charter = 1 AND CharterNum = '00D2'"
        ],
        "amend_res": 1
    },
    "715": {
        "db_id": "codebase_community",
        "question": "In comments with score between 1 to 5, list down the display names of the users with 0 down votes.",
        "ground_truth": "SELECT T2.DisplayName FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score BETWEEN 1 AND 5 AND T2.DownVotes = 0",
        "amends": [
            "Do join `comments AS T1` and `users AS T2` instead of querying only `users` table. Do use `INNER JOIN` on `T1.UserId = T2.Id` instead of no join condition. Do select `T2.DisplayName` instead of `display_name`. Do filter `T1.Score BETWEEN 1 AND 5` instead of filtering `score` from the wrong table. Do filter `T2.DownVotes = 0` instead of `down_votes = 0` with different casing. The amended query now correctly joins tables and applies filters to the appropriate sources, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"users with comments having score between 1 to 5 and 0 down votes\": make sure to combine comments table as T1 and users table as T2 using an inner match where T1.UserId equals T2.Id. 2) When the question mentions \"display names\": \"display names\" actually means T2.DisplayName in schema. 3) When filtering for comments with score between 1 and 5: apply the condition T1.Score BETWEEN 1 AND 5. 4) When filtering for users with 0 down votes: apply the condition T2.DownVotes = 0. 5) When producing output: return only T2.DisplayName as the result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT display_name FROM users WHERE down_votes = 0 AND score BETWEEN 1 AND 5",
            "SELECT T2.DisplayName\nFROM comments AS T1\nINNER JOIN users AS T2 ON T1.UserId = T2.Id\nWHERE T1.Score BETWEEN 1 AND 5\nAND T2.DownVotes = 0;"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName \nFROM comments AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.Score BETWEEN 1 AND 5 \nAND T2.DownVotes = 0"
        ],
        "amend_res": 1
    },
    "286": {
        "db_id": "toxicology",
        "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) FROM bond AS T",
        "amends": [
            "Do use `COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END)` instead of `COUNT(*)` with `WHERE bond_type = 'triple' OR bond_type LIKE '%triple%'` to properly count specific bond types. Do reference table `bond AS T` instead of `compounds` to use the correct data source. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T.bond_id)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM compounds)` to avoid the subquery and ensure proper division with real numbers. Do remove the incorrect `WHERE` clause filter and instead handle the conditional counting within the `CASE` expression. The amended query now correctly calculates the percentage of specific bond types from the appropriate table."
        ],
        "rules": [
            "1) When answering about percentage of compounds with triple bonds: use table \"bond\" with alias T as the data source instead of \"compounds\". 2) When counting specific bond types: use COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) to properly count triple bonds instead of filtering with WHERE clause. 3) When calculating percentage: compute as (count of triple bonds) divided by (total count of T.bond_id) multiplied by 100, using CAST for real number division. 4) When handling bond type identification: the exact literal for triple bonds is '#' (not 'triple' or variations). 5) When counting entities: use T.bond_id as the canonical counting key for bonds."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM compounds)) AS percentage\nFROM compounds\nWHERE bond_type = 'triple' OR bond_type LIKE '%triple%';",
            "SELECT CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T.bond_id) AS percentage\nFROM bond AS T"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(CASE WHEN T.bond_type = '#' THEN T.bond_id ELSE NULL END) AS REAL) / COUNT(T.bond_id)) * 100 \n    AS percentage_triple_bonds\nFROM bond T"
        ],
        "amend_res": 1
    },
    "502": {
        "db_id": "card_games",
        "question": "What is the release date for the set \"Ola de fr\u00edo\"?",
        "ground_truth": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de fr\u00edo'",
        "amends": [
            "Do specify `T1.releaseDate` instead of `release_date` to reference the correct column name. Do add `INNER JOIN set_translations AS T2` instead of omitting this required table for translation lookup. Do use join condition `ON T2.setCode = T1.code` instead of missing the table relationship entirely. Do filter on `T2.translation = 'Ola de fr\u00edo'` instead of directly filtering `sets.name` since the translation is stored in the joined table. The amended query now correctly retrieves release dates by joining with the translation table and matching on the translated text rather than assuming the original name field contains the Spanish translation."
        ],
        "rules": [
            "1) When the question asks about a set name in Spanish like \"Ola de fr\u00edo\": use the set_translations table (T2) to find the translation instead of the sets table (T1) name column. 2) When joining sets (T1) and set_translations (T2): link rows where T2.setCode equals T1.code and keep only matching pairs (inner match). 3) When filtering for a specific translation: use T2.translation = 'Ola de fr\u00edo' exactly as specified with the exact case and punctuation. 4) When selecting the release date: use T1.releaseDate (not release_date) as the correct column name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT release_date FROM sets WHERE name = 'Ola de fr\u00edo';",
            "SELECT T1.releaseDate \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T2.translation = 'Ola de fr\u00edo'"
        ],
        "rule_sql": [
            "SELECT s.releaseDate FROM sets s INNER JOIN set_translations st ON s.code = st.setCode WHERE st.translation = 'Ola de fr\u00edo';"
        ],
        "amend_res": 1
    },
    "441": {
        "db_id": "card_games",
        "question": "State the set code of the set with release date of 07/13/2007?",
        "evidence": "",
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
        "amends": [
            "Do join `set_translations AS T2` on `T2.setCode = T1.code` instead of querying only the `sets` table. Do select `T2.setCode` instead of `set_code` from the original table. Do use table alias `T1` for the `sets` table instead of referencing it directly. Do reference `T1.releaseDate` instead of `release_date` to match the joined table structure. The amended query now correctly retrieves set codes from the translations table joined with the main sets table based on release date, matching the RIGHT_SQL's behavior.",
            "Do use date format `'2007-07-13'` instead of `'07/13/2007'` in the WHERE filter. Do specify `INNER JOIN` explicitly instead of just `JOIN`. The amended query now correctly handles the date format and explicitly states the join type while maintaining the same join logic and result behavior."
        ],
        "rules": [
            "1) When querying for set codes with a specific release date: join set_translations as T2 on T2.setCode = T1.code instead of querying only the sets table. 2) When selecting the set code: select T2.setCode instead of set_code from the original table. 3) When referencing the sets table: use table alias T1 instead of referencing it directly. 4) When filtering by release date: reference T1.releaseDate instead of release_date to match the joined table structure.",
            "1) When filtering by date '07/13/2007' from the question: use the exact date format '2007-07-13' instead of '07/13/2007'. 2) When joining tables sets and set_translations: explicitly specify INNER JOIN instead of just JOIN to maintain the same join logic and result behavior."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT set_code FROM sets WHERE release_date = '2007-07-13';",
            "SELECT T2.setCode FROM sets AS T1 JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '07/13/2007'",
            "SELECT T2.setCode \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T1.releaseDate = '2007-07-13'"
        ],
        "rule_sql": [
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'"
        ],
        "amend_res": 1
    },
    "887": {
        "db_id": "formula_1",
        "question": "Name the races in year 2017 that are not hosted in year 2000.",
        "ground_truth": "SELECT name FROM races WHERE year = 2017 AND name NOT IN ( SELECT name FROM races WHERE year = 2000 )",
        "amends": [
            "Do add a subquery condition `name NOT IN (SELECT name FROM races WHERE year = 2000)` instead of the contradictory filter `year != 2000` which would never return results when combined with `year = 2017`. Do use a correlated subquery to exclude races from 2000 instead of attempting to filter the same year column with conflicting conditions. The amended query now correctly selects races from 2017 while excluding those that also existed in 2000, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about races in a specific year: filter the races table using the exact year value mentioned (e.g., year = 2017). 2) When excluding entities that exist in another condition: use a subquery condition with NOT IN to exclude names that appear in the other condition (e.g., name NOT IN (SELECT name FROM races WHERE year = 2000)). 3) When filtering the same table for different conditions: avoid using contradictory filters on the same column in the same WHERE clause, instead use subqueries to handle different conditions separately."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM races WHERE year = 2017 AND year != 2000;",
            "SELECT name FROM races WHERE year = 2017 AND name NOT IN (SELECT name FROM races WHERE year = 2000);"
        ],
        "rule_sql": [
            "SELECT name FROM races WHERE year = 2017 AND name NOT IN (SELECT name FROM races WHERE year = 2000);"
        ],
        "amend_res": 1
    },
    "1": {
        "db_id": "california_schools",
        "question": "Please list the lowest three eligible free rates for students aged 5-17 in continuation schools.",
        "ground_truth": "SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` FROM frpm WHERE `Educational Option Type` = 'Continuation School' AND `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` IS NOT NULL ORDER BY `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` ASC LIMIT 3",
        "amends": [
            "Do calculate `Free Meal Count (Ages 5-17) / Enrollment (Ages 5-17)` instead of selecting a precomputed `rate` column. Do query from the `frpm` table instead of the `school_rates` table. Do filter for `Educational Option Type = 'Continuation School'` instead of `school_type = 'continuation'`. Do add an IS NOT NULL condition on the calculated ratio instead of omitting null handling. Do order by the calculated ratio instead of a simple rate column. The amended query now correctly calculates free meal rates for continuation schools while handling null values and matches the RIGHT_SQL's behavior.",
            "Do remove `CDSCode` and `\"School Name\"` from the SELECT list instead of including them. Do change the WHERE filter to check `\"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" IS NOT NULL` instead of separate NULL checks on individual columns and the `\"Enrollment (Ages 5-17)\" > 0` condition. Do remove the explicit column alias `eligible_free_rate` from the SELECT expression instead of keeping it. Do reference the division expression directly in the ORDER BY clause instead of using the alias. The amended query now correctly filters for non-null division results rather than individual column nullity, ensuring only valid calculations are included while matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"eligible free rates\": calculate the ratio of \"Free Meal Count (Ages 5-17)\" divided by \"Enrollment (Ages 5-17)\" instead of selecting a precomputed rate column. 2) When querying about continuation schools: filter for rows where \"Educational Option Type\" exactly equals 'Continuation School' (case-sensitive). 3) When calculating rates: exclude rows where either \"Free Meal Count (Ages 5-17)\" or \"Enrollment (Ages 5-17)\" is null to avoid division errors. 4) When the question asks for \"lowest three\" rates: order the calculated ratio in ascending order and keep the first 3 rows. 5) When the question specifies students aged 5-17: use the columns specifically for ages 5-17 (\"Free Meal Count (Ages 5-17)\" and \"Enrollment (Ages 5-17)\").",
            "1) When answering about \"lowest three eligible free rates\": make sure the output order: the eligible free rate in ascending order and keep only the first 3 rows. 2) When the question mentions \"eligible free rates for students aged 5-17\": compute \"Free Meal Count (Ages 5-17)\" divided by \"Enrollment (Ages 5-17)\" as the rate. 3) When the question mentions \"continuation schools\": filter for rows where \"Educational Option Type\" equals exactly 'Continuation School'. 4) When computing division expressions: ensure the division result is not null instead of checking individual column nullity and positive denominator separately. 5) When ordering by calculated rates: reference the division expression directly in the ORDER BY clause instead of using an alias. 6) When producing output for rate queries: include only the calculated rate value, not the CDSCode or \"School Name\" columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT rate FROM school_rates WHERE age BETWEEN 5 AND 17 AND school_type = 'continuation' AND rate_type = 'free' ORDER BY rate ASC LIMIT 3;",
            "SELECT \n    CDSCode,\n    \"School Name\",\n    \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" AS eligible_free_rate\nFROM \n    frpm\nWHERE \n    \"Educational Option Type\" = 'Continuation School'\n    AND \"Free Meal Count (Ages 5-17)\" IS NOT NULL\n    AND \"Enrollment (Ages 5-17)\" IS NOT NULL\n    AND \"Enrollment (Ages 5-17)\" > 0\nORDER BY \n    eligible_free_rate ASC\nLIMIT 3;",
            "SELECT \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" \nFROM frpm \nWHERE \"Educational Option Type\" = 'Continuation School' \nAND \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" IS NOT NULL \nORDER BY \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" \nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT \n    CDSCode,\n    \"School Name\",\n    \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" AS eligible_free_rate\nFROM frpm\nWHERE \"Educational Option Type\" = 'Continuation School'\n    AND \"Free Meal Count (Ages 5-17)\" / \"Enrollment (Ages 5-17)\" IS NOT NULL\nORDER BY eligible_free_rate ASC\nLIMIT 3;",
            "SELECT \n    (\"Free Meal Count (Ages 5-17)\" * 1.0 / \"Enrollment (Ages 5-17)\") AS eligible_free_rate\nFROM frpm\nWHERE \"Educational Option Type\" = 'Continuation School'\n    AND \"Free Meal Count (Ages 5-17)\" IS NOT NULL\n    AND \"Enrollment (Ages 5-17)\" IS NOT NULL\n    AND \"Enrollment (Ages 5-17)\" > 0\nORDER BY eligible_free_rate ASC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "394": {
        "db_id": "card_games",
        "question": "How many white bordered cards are powerful?",
        "ground_truth": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "amends": [
            "Do count `id` instead of `*` to avoid counting NULL values. Do use column name `borderColor` instead of `border_color` to match the correct schema. Do add filters for `cardKingdomId IS NOT NULL` and `cardKingdomFoilId IS NOT NULL` instead of the incorrect `power > 5` condition. Do remove the erroneous power filter entirely instead of keeping it. The amended query now correctly counts cards with white borders that have both card kingdom identifiers present, matching the intended behavior."
        ],
        "rules": [
            "1) When counting cards: count using the canonical key \"id\" instead of all columns to avoid counting NULL values. 2) When the question mentions \"white bordered cards\": \"white\" actually means \"borderColor\" = 'white' in the schema. 3) When filtering for powerful cards: add conditions \"cardKingdomId IS NOT NULL\" and \"cardKingdomFoilId IS NOT NULL\" instead of using a power filter. 4) When the question asks about \"powerful\" cards: remove any power-related filters entirely as they are not part of the correct criteria."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE border_color = 'white' AND power > 5;",
            "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "1191": {
        "db_id": "thrombosis_prediction",
        "question": "What percentage of male patients who first presented to the hospital in 1981 were diagnosed with BEHCET?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE STRFTIME('%Y', `First Date`) = '1981' AND SEX = 'M'",
        "amends": [
            "Do use `SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END)` instead of `COUNT(CASE WHEN p.gender = 'M' AND strftime('%Y', p.first_visit_date) = '1981' AND d.diagnosis = 'BEHCET' THEN 1 END)` for counting specific diagnoses. Do remove the `LEFT JOIN` on `diagnoses` table and instead query only from the `Patient` table. Do use `SEX = 'M'` instead of `p.gender = 'M'` for gender filtering. Do use `First Date` instead of `p.first_visit_date` for date extraction with `STRFTIME('%Y', First Date) = '1981'`. Do apply explicit `CAST` to `REAL` instead of implicit conversion with `* 100.0`. Do calculate percentage as `SUM(...) * 100 / COUNT(ID)` instead of complex nested `COUNT` expressions. The amended query now correctly calculates the percentage of male patients from 1981 diagnosed with BEHCET without requiring a join to the diagnoses table."
        ],
        "rules": [
            "1) When the question asks for percentage of patients diagnosed with 'BEHCET': use SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) * 100 / COUNT(ID) instead of complex COUNT expressions with multiple conditions. 2) When filtering for male patients: use SEX = 'M' instead of gender = 'M' as the exact column token. 3) When filtering for patients who first presented in 1981: use STRFTIME('%Y', \"First Date\") = '1981' with the exact column name \"First Date\" in double quotes. 4) When calculating percentages: apply explicit CAST to REAL instead of implicit conversion with * 100.0. 5) When the schema shows that diagnosis information is available in the Patient table: do not perform LEFT JOIN to a separate diagnoses table, query only from the Patient table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN p.gender = 'M' AND strftime('%Y', p.first_visit_date) = '1981' AND d.diagnosis = 'BEHCET' THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN p.gender = 'M' AND strftime('%Y', p.first_visit_date) = '1981' THEN 1 END)) AS percentage\nFROM patients p\nLEFT JOIN diagnoses d ON p.patient_id = d.patient_id\nWHERE p.gender = 'M' AND strftime('%Y', p.first_visit_date) = '1981';",
            "SELECT \n    CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM \n    Patient\nWHERE \n    SEX = 'M' \n    AND STRFTIME('%Y', \"First Date\") = '1981'"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(CASE WHEN Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) AS percentage\nFROM \n    Patient\nWHERE \n    SEX = 'M' \n    AND STRFTIME('%Y', \"First Date\") = '1981'"
        ],
        "amend_res": 1
    },
    "1079": {
        "db_id": "european_football_2",
        "question": "Which player is the tallest?",
        "ground_truth": "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1",
        "amends": [
            "Do select `player_name` instead of `name` to use the correct column name. Do reference table `Player` instead of `players` to use the proper table name. Do order by `height DESC` instead of `height ASC` to get the tallest player instead of the shortest. The amended query now correctly retrieves the tallest player's name from the Player table."
        ],
        "rules": [
            "1) When the question asks for a player's name: use the exact column \"player_name\" from table \"Player\" instead of \"name\". 2) When the question asks for the tallest player: order by \"height\" in descending direction (DESC) instead of ascending (ASC). 3) When selecting from the player table: use the exact table name \"Player\" instead of \"players\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY height ASC LIMIT 1;",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name, height FROM Player ORDER BY height DESC LIMIT 1;",
            "SELECT player_name FROM Player ORDER BY height DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "238": {
        "db_id": "toxicology",
        "question": "How many molecules have a triple bond type?",
        "ground_truth": "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'",
        "amends": [
            "Do select `COUNT(DISTINCT T.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all bonds. Do reference table `bond AS T` instead of `molecules` to access the correct bond data. Do filter on `T.bond_type = '#'` instead of `bond_type = 'triple'` to use the proper bond type identifier. The amended query now correctly counts distinct molecules with triple bonds as specified in the RIGHT_SQL."
        ],
        "rules": [
            "1) When counting molecules: count distinct T.molecule_id instead of counting all rows to get unique molecules rather than all bonds. 2) When accessing bond data: use table bond AS T instead of molecules to get the correct bond information. 3) When filtering for triple bond type: use T.bond_type = '#' instead of 'triple' to match the proper bond type identifier in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE bond_type = 'triple';",
            "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T.molecule_id) FROM bond AS T WHERE T.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "1093": {
        "db_id": "european_football_2",
        "question": "What is the average overall rating of the players born before the year 1986?",
        "ground_truth": "SELECT SUM(t2.overall_rating) / COUNT(t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.birthday, 1, 4) < '1986'",
        "amends": [
            "Do join `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do calculate `SUM(t2.overall_rating) / COUNT(t1.id)` instead of `AVG(overall_rating)` from a single table. Do filter with `SUBSTR(t1.birthday, 1, 4) < '1986'` instead of `birth_year > 1986` to properly extract and compare birth years from a date string. Do reference the correct table aliases `t2.overall_rating` and `t1.id` instead of assuming columns exist in a single table. The amended query now correctly joins player data with attributes and calculates the average rating using proper aggregation for players born before 1986."
        ],
        "rules": [
            "1) When answering about average overall rating of players born before 1986: join Player as t1 with Player_Attributes as t2 where t1.player_api_id equals t2.player_api_id to combine player and rating data. 2) When calculating average rating: compute SUM(t2.overall_rating) divided by COUNT(t1.id) instead of using a single AVG function. 3) When filtering players born before 1986: extract the year from t1.birthday using SUBSTR(t1.birthday, 1, 4) and compare with '1986' using less than operator. 4) When referencing columns: use exact table aliases t2.overall_rating for ratings and t1.id for counting players."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(overall_rating) FROM players WHERE birth_year > 1986;",
            "SELECT SUM(t2.overall_rating) / COUNT(t1.id) AS average_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE SUBSTR(t1.birthday, 1, 4) < '1986'"
        ],
        "rule_sql": [
            "SELECT SUM(t2.overall_rating) / COUNT(t1.id) AS average_rating\nFROM Player AS t1\nJOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE CAST(SUBSTR(t1.birthday, 1, 4) AS INTEGER) < 1986;"
        ],
        "amend_res": 1
    },
    "651": {
        "db_id": "codebase_community",
        "question": "Provide the related post title of \"How to tell if something happened in a data set which monitors a value over time\".",
        "evidence": "",
        "ground_truth": "SELECT T3.Title FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id INNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id WHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'",
        "amends": [
            "Do join `postLinks AS T1` and `posts AS T2` with `INNER JOIN` on `T1.PostId = T2.Id` instead of querying only the `posts` table. Do add another `INNER JOIN` to `posts AS T3` on `T1.RelatedPostId = T3.Id` instead of omitting the related post relationship. Do select `T3.Title` from the related post instead of `title` from the original post. Do filter on `T2.Title = 'How to tell if something happened in a data set which monitors a value over time'` instead of using `LIKE` on `content`. The amended query now correctly retrieves titles of related posts linked to the specified post title, matching RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"related post title\" of a specific post: use the postLinks table (T1) to find relationships between posts. 2) When joining postLinks (T1) with posts: perform an inner join where T1.PostId = T2.Id to connect the linking record to the source post. 3) When joining to get the related post: perform another inner join where T1.RelatedPostId = T3.Id to connect to the target related post. 4) When filtering for a specific post title: use exact equality match T2.Title = 'How to tell if something happened in a data set which monitors a value over time' instead of content search. 5) When selecting the output: retrieve T3.Title from the related post table rather than title from the source post."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts WHERE content LIKE '%How to tell if something happened in a data set which monitors a value over time%'",
            "SELECT T3.Title \nFROM postLinks AS T1 \nINNER JOIN posts AS T2 ON T1.PostId = T2.Id \nINNER JOIN posts AS T3 ON T1.RelatedPostId = T3.Id \nWHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'"
        ],
        "rule_sql": [
            "SELECT T3.Title \nFROM postLinks T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nINNER JOIN posts T3 ON T1.RelatedPostId = T3.Id\nWHERE T2.Title = 'How to tell if something happened in a data set which monitors a value over time'"
        ],
        "amend_res": 1
    },
    "1124": {
        "db_id": "european_football_2",
        "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
        "amends": [
            "Do use `DISTINCT t1.player_name` instead of `player_name` to eliminate duplicates. Do add `INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the players table. Do change the WHERE condition to `t2.attacking_work_rate = 'high'` instead of filtering on `attack_moves > 10 AND mate_attack_moves > 5`. Do remove the ORDER BY clause instead of keeping it. The amended query now correctly joins the Player and Player_Attributes tables to filter players based on their attacking work rate attribute rather than incorrect column references."
        ],
        "rules": [
            "1) When answering about players who tend to be attacking: use DISTINCT t1.player_name to eliminate duplicate player names. 2) When combining Player and Player_Attributes tables: link rows where t1.player_api_id = t2.player_api_id and keep only matching pairs (inner match). 3) When the question mentions \"attacking when their mates were doing attack moves\": this actually means filtering for t2.attacking_work_rate = 'high' in the Player_Attributes table. 4) When the question asks for a list of player names: do not include any ORDER BY clause in the final output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_name FROM players WHERE attack_moves > 10 AND mate_attack_moves > 5 ORDER BY attack_moves DESC;",
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.attacking_work_rate = 'high'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.attacking_work_rate = 'high'"
        ],
        "amend_res": 1
    },
    "182": {
        "db_id": "financial",
        "question": "How many male customers who were born between 1974 and 1976 have made a payment on their home in excess of $4000?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN disp AS T4 ON T2.account_id = T4.account_id INNER JOIN client AS T3 ON T4.client_id = T3.client_id WHERE STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976' AND T3.gender = 'M' AND T1.amount > 4000 AND T1.k_symbol = 'SIPO'",
        "amends": [
            "Do select `COUNT(T1.account_id)` instead of `COUNT(*)` and change the table structure completely from `customers` and `payments` to `trans`, `account`, `disp`, and `client` tables. Do use `INNER JOIN` chains connecting `trans` to `account` on `account_id`, then `account` to `disp` on `account_id`, and finally `disp` to `client` on `client_id` instead of a single `JOIN` between `customers` and `payments` on `customer_id`. Do filter gender with `T3.gender = 'M'` instead of `c.gender = 'Male'` and extract birth year from `STRFTIME('%Y', T3.birth_date)` instead of using a `birth_year` column directly. Do filter amount with `T1.amount > 4000` instead of `p.amount > 4000` and use payment type filter `T1.k_symbol = 'SIPO'` instead of `p.payment_type = 'Home'`. The amended query now correctly counts specific account IDs from the proper table relationships with accurate date handling and filtering conditions."
        ],
        "rules": [
            "1) When answering about male customers born between 1974 and 1976 with payments over $4000: make sure the output order: COUNT(T1.account_id). 2) When the question mentions \"male customers\": \"male\" actually means \"T3.gender = 'M'\" in schema. 3) When the question mentions \"born between 1974 and 1976\": extract birth year from STRFTIME('%Y', T3.birth_date) and filter between 1974 and 1976 inclusive. 4) When the question mentions \"payment in excess of $4000\": use T1.amount > 4000. 5) When the question mentions \"payment on their home\": use T1.k_symbol = 'SIPO'. 6) When combining tables for this query: link T1 to T2 on T1.account_id = T2.account_id, then T2 to T3 on T2.client_id = T3.client_id, and finally T3 to T4 on T3.client_id = T4.client_id using inner joins only. 7) When counting customers: compute the number of rows using T1.account_id as the counting key."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers c\nJOIN payments p ON c.customer_id = p.customer_id\nWHERE c.gender = 'Male' \nAND c.birth_year BETWEEN 1974 AND 1976\nAND p.amount > 4000\nAND p.payment_type = 'Home'",
            "SELECT COUNT(T1.account_id) \nFROM trans T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nINNER JOIN disp T3 ON T2.account_id = T3.account_id\nINNER JOIN client T4 ON T3.client_id = T4.client_id\nWHERE T4.gender = 'M'\nAND STRFTIME('%Y', T4.birth_date) BETWEEN '1974' AND '1976'\nAND T1.amount > 4000\nAND T1.k_symbol = 'SIPO'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM trans T1\nINNER JOIN disp T2 ON T1.account_id = T2.account_id\nINNER JOIN client T3 ON T2.client_id = T3.client_id\nWHERE T3.gender = 'M'\nAND STRFTIME('%Y', T3.birth_date) BETWEEN '1974' AND '1976'\nAND T1.amount > 4000\nAND T1.k_symbol = 'SIPO'"
        ],
        "amend_res": 1
    },
    "1257": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients whose creatinine level is abnormal, how many of them aren't 70 yet?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE >= 1.5 AND STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70",
        "amends": [
            "Do use `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table to incorporate laboratory data. Do filter on `T2.CRE >= 1.5` instead of `creatinine_level != 'normal'` to use a specific numeric threshold for creatinine levels. Do calculate age with `STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70` instead of `age >= 70` to properly compute age from birthdate and filter for patients under 70 years old. The amended query now correctly identifies patients with elevated creatinine levels who are under 70 years old by joining laboratory data and using proper age calculation."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) instead of COUNT(*) to count unique patient IDs. 2) When incorporating laboratory data: add INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID to combine patient and laboratory information. 3) When filtering for abnormal creatinine levels: use T2.CRE >= 1.5 instead of text-based comparison to apply the specific numeric threshold. 4) When calculating age from birthdate: use STRFTIME('%Y', Date('now')) - STRFTIME('%Y', T1.Birthday) < 70 to properly compute current age and filter for patients under 70 years old."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE creatinine_level != 'normal' AND age >= 70;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.CRE >= 1.5\nAND (STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday)) < 70"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.CRE >= 1.5\nAND (STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday)) < 70"
        ],
        "amend_res": 1
    },
    "690": {
        "db_id": "codebase_community",
        "question": "Identify the latest badge awarded to the user with the display name Emmett.",
        "ground_truth": "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Emmett' ORDER BY T1.Date DESC LIMIT 1",
        "amends": [
            "Do select `T1.Name` instead of `*` to return only the badge name instead of all columns. Do join `users AS T2` instead of omitting it, using `INNER JOIN` on `T1.UserId = T2.Id` instead of querying the badges table alone. Do filter on `T2.DisplayName = 'Emmett'` instead of `user_display_name = 'Emmett'` to correctly reference the user's display name from the users table. Do order by `T1.Date DESC` instead of `date_awarded DESC` to use the proper column name for the award date. The amended query now correctly joins the badges and users tables to find badges for the specific user and returns only the badge name with proper date ordering."
        ],
        "rules": [
            "1) When answering about \"latest badge awarded to a user\": make sure the output order includes only the badge name column \"T1.Name\". 2) When the question mentions \"user with display name Emmett\": \"Emmett\" actually means \"T2.DisplayName = 'Emmett'\" in schema. 3) When combining badges table T1 and users table T2: link rows where T1.UserId = T2.Id and keep only matching pairs (inner match). 4) When ordering by date to find the latest badge: order by T1.Date in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM badges WHERE user_display_name = 'Emmett' ORDER BY date_awarded DESC LIMIT 1;",
            "SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Emmett' ORDER BY T1.Date DESC LIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.Name\nFROM badges T1\nINNER JOIN users T2 ON T1.UserId = T2.Id\nWHERE T2.DisplayName = 'Emmett'\nORDER BY T1.Date DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "727": {
        "db_id": "superhero",
        "question": "Who is the publisher of Sauron?",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'",
        "amends": [
            "Do select `T2.publisher_name` instead of `author` from a different table. Do use `FROM superhero AS T1 INNER JOIN publisher AS T2` instead of `FROM books` with a single table. Do add the join condition `ON T1.publisher_id = T2.id` instead of omitting any join. Do filter on `T1.superhero_name = 'Sauron'` instead of `title = 'Sauron'` to reference the correct column and table. The amended query now correctly retrieves publisher information for the superhero 'Sauron' instead of attempting to find an author from a books table."
        ],
        "rules": [
            "1) When answering about \"Who is the publisher of Sauron?\": make sure the output order: T2.publisher_name. 2) When the question mentions \"Sauron\": \"Sauron\" actually means \"T1.superhero_name = 'Sauron'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.publisher_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation for 'Sauron'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT author FROM books WHERE title = 'Sauron';",
            "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name = 'Sauron'"
        ],
        "rule_sql": [
            "SELECT T2.publisher_name\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T1.superhero_name = 'Sauron'"
        ],
        "amend_res": 1
    },
    "27": {
        "db_id": "california_schools",
        "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
        "ground_truth": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
        "amends": [
            "Do select `T2.School`, `T1.AvgScrWrite`, and `T2.Phone` instead of `school_name`, `AVG(writing_score)`, and `communication_number`. Do use a `LEFT JOIN` between `schools AS T2` and `satscores AS T1` on `T2.CDSCode = T1.cds` instead of querying only the `schools` table. Do filter using `strftime('%Y', T2.OpenDate) > '1991'` and `strftime('%Y', T2.ClosedDate) < '2000'` instead of `opened_year > 1991` and `closed_year < 2000`. Do remove the `GROUP BY` clause and aggregate function instead of keeping them, as the average score is now sourced directly from the joined table. The amended query now correctly joins the necessary tables and handles date comparisons properly to match the intended behavior."
        ],
        "rules": [
            "1) When selecting school names and writing scores: use T2.\"School\" for school names and T1.\"AvgScrWrite\" for average writing scores instead of school_name and AVG(writing_score). 2) When selecting communication information: use T2.\"Phone\" for communication numbers instead of communication_number. 3) When combining school and SAT score data: perform a LEFT JOIN between schools AS T2 and satscores AS T1 where T2.\"CDSCode\" equals T1.\"cds\". 4) When filtering for schools opened after 1991: use strftime('%Y', T2.\"OpenDate\") > '1991' instead of opened_year > 1991. 5) When filtering for schools closed before 2000: use strftime('%Y', T2.\"ClosedDate\") < '2000' instead of closed_year < 2000. 6) When the question asks for average writing scores: do not use aggregate functions or GROUP BY since the average score is directly available from T1.\"AvgScrWrite\" in the joined table."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT school_name, AVG(writing_score) as avg_writing_score, communication_number\nFROM schools\nWHERE opened_year > 1991 OR closed_year < 2000\nGROUP BY school_name, communication_number;",
            "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM schools AS T2\nLEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds\nWHERE (strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000')"
        ],
        "rule_sql": [
            "SELECT T2.School, T1.AvgScrWrite, T2.Phone\nFROM schools AS T2\nLEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds\nWHERE (strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000')\nAND T1.AvgScrWrite IS NOT NULL;",
            "SELECT T2.\"School\" AS school_name, T1.\"AvgScrWrite\" AS average_writing_score, T2.\"Phone\" AS communication_number\nFROM schools AS T2\nLEFT JOIN satscores AS T1 ON T2.\"CDSCode\" = T1.\"cds\"\nWHERE (strftime('%Y', T2.\"OpenDate\") > '1991' OR strftime('%Y', T2.\"ClosedDate\") < '2000')\nAND T1.\"AvgScrWrite\" IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "434": {
        "db_id": "card_games",
        "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
        "ground_truth": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific records. Do add `INNER JOIN set_translations AS T2 ON T2.setCode = T1.code` instead of querying only the sets table to incorporate translation data. Do move the language filter to `T2.language = 'Japanese'` instead of applying it to the sets table directly. Do replace the online_only filter with `(T1.mtgoCode IS NULL OR T1.mtgoCode = '')` instead of `online_only = 0` to properly identify sets without MTGO codes. The amended query now correctly counts Japanese set translations for sets that don't have MTGO codes, matching the intended behavior."
        ],
        "rules": [
            "1) When counting sets: use COUNT(T1.id) instead of COUNT(*) to count specific records. 2) When the question mentions \"Japanese\": filter on T2.language = 'Japanese' exactly as written. 3) When identifying sets not in Magic: The Gathering Online: use (T1.mtgoCode IS NULL OR T1.mtgoCode = '') instead of online_only = 0. 4) When combining set data with translation data: perform an INNER JOIN between T1 (sets) and T2 (set_translations) where T2.setCode = T1.code to link translations to their corresponding sets."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM sets WHERE language = 'Japanese' AND online_only = 0;",
            "SELECT COUNT(T1.id) \nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code\nWHERE T2.language = 'Japanese'\nAND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM sets T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.code\nWHERE T2.language = 'Japanese'\nAND (T1.mtgoCode IS NULL OR T1.mtgoCode = '');"
        ],
        "amend_res": 1
    },
    "119": {
        "db_id": "financial",
        "question": "For accounts in 1993 with statement issued after transaction, list the account ID, district name and district region.",
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND STRFTIME('%Y', T1.date)= '1993'",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of `a` and `d`, and select columns `T2.A2` and `T2.A3` instead of `d.district_name` and `d.region`. Do specify `INNER JOIN` explicitly instead of just `JOIN`, and join on `district` table instead of `districts`. Do add filter `T1.frequency = 'POPLATEK PO OBRATU'` instead of omitting it, and use `STRFTIME('%Y', T1.date)= '1993'` for year extraction instead of `YEAR(a.date) = 1993`. Do remove the condition `a.statement_date > a.transaction_date` instead of keeping it, and remove the `ORDER BY` clause instead of including it. The amended query now correctly filters for specific frequency accounts from 1993 without unnecessary ordering."
        ],
        "rules": [
            "1) When joining accounts and district tables: use INNER JOIN between T1 (accounts) and T2 (district) on T1.district_id = T2.district_id instead of joining with districts table. 2) When selecting district information: use T2.A2 for district name and T2.A3 for district region instead of d.district_name and d.region. 3) When filtering by year 1993: use STRFTIME('%Y', T1.date) = '1993' instead of YEAR(a.date) = 1993. 4) When filtering accounts: include the condition T1.frequency = 'POPLATEK PO OBRATU' which was previously omitted. 5) When the question mentions accounts with statement issued after transaction: remove the condition a.statement_date > a.transaction_date as it should not be included. 6) When ordering results: remove the ORDER BY clause as it is not required by the question."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT a.account_id, d.district_name, d.region\nFROM accounts a\nJOIN districts d ON a.district_id = d.district_id\nWHERE YEAR(a.date) = 1993\nAND a.statement_date > a.transaction_date\nORDER BY a.account_id;",
            "SELECT T1.account_id, T2.A2, T2.A3\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.frequency = 'POPLATEK PO OBRATU'\nAND STRFTIME('%Y', T1.date) = '1993'"
        ],
        "rule_sql": [
            "SELECT T1.account_id, T2.A2 AS district_name, T2.A3 AS district_region\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE STRFTIME('%Y', T1.date) = '1993'\nAND T1.frequency = 'POPLATEK PO OBRATU'"
        ],
        "amend_res": 1
    },
    "1189": {
        "db_id": "thrombosis_prediction",
        "question": "What number of patients with a degree of thrombosis level 2 and ANA pattern of only S, have a level of anti-Cardiolip in antibody (IgM) 20% higher than average?",
        "ground_truth": "SELECT COUNT(*) FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) * 1.2 FROM Examination WHERE Thrombosis = 2 AND `ANA Pattern` = 'S')",
        "amends": [
            "Do use table `Examination` instead of `patients` for the main query and subquery. Do reference column `Thrombosis` instead of `thrombosis_level` and use value `2` instead of `2`. Do reference column `ANA Pattern` instead of `ana_pattern` and use value `'S'` instead of `'S'`. Do reference column `aCL IgM` instead of `anti_cardiolipin_igm` for both the outer condition and subquery calculation. Do add filter conditions `Thrombosis = 2 AND ANA Pattern = 'S'` to the subquery's WHERE clause instead of omitting them, ensuring the average calculation is computed only over the relevant subset matching the outer query's criteria. The amended query now correctly matches RIGHT_SQL's behavior by properly scoping the subquery to the same filtered population."
        ],
        "rules": [
            "1) When answering about patients with thrombosis level 2 and ANA pattern S: use table \"Examination\" instead of \"patients\" for both main query and subquery. 2) When the question mentions \"degree of thrombosis level 2\": use column \"Thrombosis\" with value 2 instead of thrombosis_level. 3) When the question mentions \"ANA pattern of only S\": use column \"ANA Pattern\" with exact value 'S' instead of ana_pattern. 4) When the question mentions \"level of anti-Cardiolip in antibody (IgM)\": use column \"aCL IgM\" instead of anti_cardiolipin_igm for both outer condition and subquery calculation. 5) When computing average anti-Cardiolipin IgM level for comparison: apply the same filter conditions \"Thrombosis = 2 AND ANA Pattern = 'S'\" to the subquery's WHERE clause to scope the average calculation to the relevant population matching the outer query's criteria."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE thrombosis_level = 2 \nAND ana_pattern = 'S' \nAND anti_cardiolipin_igm > (SELECT AVG(anti_cardiolipin_igm) * 1.2 FROM patients);",
            "SELECT COUNT(*) \nFROM Examination \nWHERE Thrombosis = 2 \nAND \"ANA Pattern\" = 'S' \nAND \"aCL IgM\" > 1.2 * (\n    SELECT AVG(\"aCL IgM\") \n    FROM Examination \n    WHERE Thrombosis = 2 \n    AND \"ANA Pattern\" = 'S'\n)"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Examination \nWHERE Thrombosis = 2 \nAND \"ANA Pattern\" = 'S' \nAND \"aCL IgM\" > (\n    SELECT AVG(\"aCL IgM\") * 1.2 \n    FROM Examination \n    WHERE Thrombosis = 2 \n    AND \"ANA Pattern\" = 'S'\n)"
        ],
        "amend_res": 1
    },
    "1117": {
        "db_id": "european_football_2",
        "question": "What are the player api id of 10 heaviest players?",
        "ground_truth": "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10;"
        ],
        "rule_sql": [
            "SELECT player_api_id FROM Player ORDER BY weight DESC LIMIT 10"
        ],
        "amend_res": 1
    },
    "388": {
        "db_id": "card_games",
        "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
        "ground_truth": "SELECT id, language FROM set_translations WHERE id = ( SELECT id FROM cards WHERE convertedManaCost = 5 ) AND setCode = '10E'",
        "amends": [
            "Do select `id` and `language` instead of `c.name` and `t.language`. Do use `set_translations` as the main table instead of joining `cards` and `translations`. Do add a subquery `(SELECT id FROM cards WHERE convertedManaCost = 5)` instead of joining directly on card_id. Do filter with `setCode = '10E'` instead of `c.set = '10E'`. Do remove the explicit join condition and instead correlate through the subquery. The amended query now correctly retrieves translations for cards with specific mana cost from the designated set, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about cards with specific converted mana cost and set: use set_translations as the main table instead of joining cards and translations tables directly. 2) When filtering for set '10E': use setCode = '10E' exactly as specified. 3) When filtering for converted mana cost of 5: use a subquery (SELECT id FROM cards WHERE convertedManaCost = 5) to correlate through the main query. 4) When selecting output columns: return id and language instead of name and language. 5) When handling identifier delimiters: do not replace double quotes with backticks or unquoted forms for any identifiers."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, t.language FROM cards c JOIN translations t ON c.id = t.card_id WHERE c.set = '10E' AND c.converted_mana_cost = 5;",
            "SELECT st.id, st.language \nFROM set_translations st \nWHERE st.setCode = '10E' \nAND st.id IN (SELECT id FROM cards WHERE convertedManaCost = 5)"
        ],
        "rule_sql": [
            "SELECT st.id, st.language \nFROM set_translations st \nWHERE st.setCode = '10E' \nAND EXISTS (\n    SELECT 1 \n    FROM cards c \n    WHERE c.convertedManaCost = 5 \n    AND c.setCode = '10E'\n    AND c.id IN (\n        SELECT id \n        FROM cards \n        WHERE setCode = st.setCode\n    )\n)",
            "SELECT id, language FROM set_translations WHERE setCode = '10E' AND id IN (SELECT id FROM cards WHERE convertedManaCost = 5)"
        ],
        "amend_res": 1
    },
    "1211": {
        "db_id": "thrombosis_prediction",
        "question": "Provide the ID and age of patient with lactate dehydrogenase (LDH) between 100-300 index above the normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 600 AND T2.LDH < 800",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, select `T1.ID` instead of `patient_id`, and calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)` instead of directly selecting `age`. Do join `Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.LDH > 600 AND T2.LDH < 800` instead of `ldh > 100 AND ldh < 300`, moving the LDH condition to the Laboratory table instead of assuming it exists in the Patient table. The amended query now correctly calculates age dynamically, joins with the Laboratory table to access LDH values, and uses appropriate threshold values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patient ID and age: select T1.ID and calculate age using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) instead of selecting age directly. 2) When the question mentions lactate dehydrogenase (LDH): access LDH values from the Laboratory table (T2.LDH) instead of assuming they exist in the Patient table. 3) When filtering for LDH between 100-300 index above normal range: use the exact filter T2.LDH > 600 AND T2.LDH < 800 as specified in the amends. 4) When combining Patient and Laboratory data: perform an inner join where T1.ID = T2.ID to link patient records with their laboratory results. 5) When selecting patient identifiers: use T1.ID instead of patient_id as the exact identifier token."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, age FROM patients WHERE ldh > 100 AND ldh < 300;",
            "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) AS age\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 600 AND T2.LDH < 800"
        ],
        "rule_sql": [
            "SELECT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) AS age\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH > 600 AND T2.LDH < 800"
        ],
        "amend_res": 1
    },
    "1055": {
        "db_id": "european_football_2",
        "question": "When is the birthday of the football player who has the highest overall rating?",
        "ground_truth": "SELECT t1.birthday FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.overall_rating DESC LIMIT 1",
        "amends": [
            "Do add `Player_Attributes` table with `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do reference `t2.overall_rating` from the joined table instead of `overall_rating` directly from the players table. Do qualify `birthday` as `t1.birthday` instead of unqualified `birthday`. The amended query now correctly joins the necessary tables to access the overall_rating attribute and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about football players with highest overall rating: join Player table (T1) with Player_Attributes table (T2) using T1.player_api_id = T2.player_api_id to access the overall_rating attribute. 2) When the question asks for the highest overall rating: use T2.overall_rating from the joined Player_Attributes table instead of any column from the Player table. 3) When retrieving birthday information: use T1.birthday from the Player table as the source for birthday data. 4) When finding the player with the highest overall rating: order results by T2.overall_rating in descending direction and keep only the first row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT birthday FROM players ORDER BY overall_rating DESC LIMIT 1;",
            "SELECT t1.birthday\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT p.birthday \nFROM Player p\nJOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nORDER BY pa.overall_rating DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1354": {
        "db_id": "student_club",
        "question": "State the major name for the Vice President of the club.",
        "ground_truth": "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'",
        "amends": [
            "Do select `T2.major_name` instead of `major` to reference the joined table column. Do use `INNER JOIN major AS T2` instead of querying only `club_members` to properly join the major table. Do join on `T1.link_to_major = T2.major_id` instead of missing the join condition entirely. Do filter for `T1.position = 'Vice President'` instead of `'President'` to correct the position criteria. The amended query now correctly retrieves major names for vice presidents through proper table joining and filtering."
        ],
        "rules": [
            "1) When the question asks for \"major name\" for a position: use the exact column token \"T2.major_name\" from the joined major table instead of \"major\" from the base table. 2) When combining club_members and major tables: perform an inner join where \"T1.link_to_major = T2.major_id\" to link the tables correctly. 3) When filtering for the Vice President position: use the exact literal value \"Vice President\" for the position column filter instead of \"President\". 4) When answering about the Vice President's major name: make sure the output order includes only \"T2.major_name\" as the result column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT major FROM club_members WHERE position = 'President';",
            "SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'"
        ],
        "rule_sql": [
            "SELECT T2.major_name FROM member T1 INNER JOIN major T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President';"
        ],
        "amend_res": 1
    },
    "1097": {
        "db_id": "european_football_2",
        "question": "What is Aaron Lennox's total crossing score?",
        "ground_truth": "SELECT SUM(t2.crossing) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Lennox'",
        "amends": [
            "Do reference the `crossing` column from the `Player_Attributes` table instead of the non-existent `crossing_score` column. Do join `Player` and `Player_Attributes` tables with `INNER JOIN` on `player_api_id` instead of querying only the `players` table. Do filter on the combined `player_name` field with value 'Aaron Lennox' instead of separate `first_name` and `last_name` filters. Do use proper table aliases `t1` and `t2` for clarity instead of no aliases. The amended query now correctly aggregates crossing attributes for the specified player by properly joining the relevant tables."
        ],
        "rules": [
            "1) When the question asks for a player's crossing score: use the \"crossing\" column from the \"Player_Attributes\" table instead of any \"crossing_score\" column. 2) When combining player information with player attributes: link rows where \"Player\".\"player_api_id\" = \"Player_Attributes\".\"player_api_id\" using an inner match. 3) When filtering for a specific player by name: use the \"player_name\" column from the \"Player\" table with the exact literal value 'Aaron Lennox' instead of separate first and last name filters. 4) When aggregating crossing scores: sum the \"crossing\" values from the \"Player_Attributes\" table for the matching player."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(crossing_score) FROM players WHERE first_name = 'Aaron' AND last_name = 'Lennox';",
            "SELECT SUM(t2.crossing) AS total_crossing_score\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Aaron Lennox'"
        ],
        "rule_sql": [
            "SELECT SUM(pa.crossing) AS total_crossing_score\nFROM Player p\nINNER JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE p.player_name = 'Aaron Lennox';"
        ],
        "amend_res": 1
    },
    "14": {
        "db_id": "california_schools",
        "question": "List the top five schools, by descending order, from the highest to the lowest, the most number of Enrollment (Ages 5-17). Please give their NCES school identification number.",
        "evidence": "",
        "ground_truth": "SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5",
        "amends": [
            "Do select `T1.NCESSchool` instead of `NCESSCH` and join `frpm AS T2` instead of querying only the `schools` table. Do use `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of no join condition. Do reference `T2.Enrollment (Ages 5-17)` instead of `Enrollment_Ages_5_17` and order by `DESC` instead of `ASC`. The amended query now correctly joins the schools and frpm tables to match the enrollment data and returns the expected results."
        ],
        "rules": [
            "1) When answering about top schools by enrollment: make sure the output order: T1.NCESSchool first, then T2.\"Enrollment (Ages 5-17)\" 2) When the question mentions \"NCES school identification number\": \"NCES school identification number\" actually means \"T1.NCESSchool\" in schema 3) When the question mentions \"top five schools\" by \"Enrollment (Ages 5-17)\": rank rows by T2.\"Enrollment (Ages 5-17)\" in descending order and keep the first 5 rows 4) When combining schools table as T1 and frpm table as T2: link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match) 5) When handling text literals: do not change case, spacing, or punctuation in \"Enrollment (Ages 5-17)\" 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T2.\"Enrollment (Ages 5-17)\""
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT NCESSCH, Enrollment_Ages_5_17 \nFROM schools \nORDER BY Enrollment_Ages_5_17 ASC \nLIMIT 5;",
            "SELECT T1.NCESSchool\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT T1.NCESSchool, T2.\"Enrollment (Ages 5-17)\"\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5",
            "SELECT T1.NCESSchool, T2.\"Enrollment (Ages 5-17)\"\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T2.\"Enrollment (Ages 5-17)\" DESC\nLIMIT 5"
        ],
        "amend_res": 1
    },
    "215": {
        "db_id": "toxicology",
        "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
        "ground_truth": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
        "amends": [
            "Do use `COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END)` and `COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END)` with aliases `iodine_nums` and `sulfur_nums` instead of a single `COUNT(*)` with conflicting `element` conditions. Do join `atom AS T1` with `connected AS T2` on `T1.atom_id = T2.atom_id` and then with `bond AS T3` on `T2.bond_id = T3.bond_id` instead of querying only `atoms` without joins. Do filter on `T3.bond_type = '-'` instead of the impossible `element = 'iodine' AND element = 'sulfur'` condition and incorrect `bond_type = 'single'` value. Do remove the contradictory `WHERE` clause and add proper table relationships through joins instead of omitting them. The amended query now correctly counts distinct iodine and sulfur atoms with single bonds using proper table relationships and conditional aggregation."
        ],
        "rules": [
            "1) When counting atoms with specific element types: use COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) for iodine atoms and COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) for sulfur atoms instead of a single COUNT(*) with conflicting conditions. 2) When querying about atoms in bonds: join atom AS T1 with connected AS T2 on T1.atom_id = T2.atom_id and then with bond AS T3 on T2.bond_id = T3.bond_id instead of querying only the atoms table without relationships. 3) When filtering for single bonds: use T3.bond_type = '-' instead of bond_type = 'single' as the literal value. 4) When handling element values: use exact lowercase literals 'i' for iodine and 's' for sulfur as shown in the schema sample values, not the full element names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE element = 'iodine' AND element = 'sulfur' AND bond_type = 'single';",
            "SELECT \n    COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums,\n    COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums\nFROM \n    atom AS T1\nJOIN \n    connected AS T2 ON T1.atom_id = T2.atom_id\nJOIN \n    bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_atoms,\n    COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_atoms\nFROM \n    atom AS T1\nJOIN \n    connected AS T2 ON T1.atom_id = T2.atom_id\nJOIN \n    bond AS T3 ON T2.bond_id = T3.bond_id\nWHERE \n    T3.bond_type = '-'"
        ],
        "amend_res": 1
    },
    "378": {
        "db_id": "card_games",
        "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
        "ground_truth": "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
        "amends": [
            "Do select `id` instead of `card_id` in the SELECT list. Do add `cardKingdomId IS NOT NULL` and `cardKingdomFoilId IS NOT NULL` filters instead of the original `foil_status = 'foiled'` and `power_level > 9000` conditions. Do remove the `EXISTS` subquery with the `c2.foil_status = 'non-foiled'` correlation entirely instead of keeping it. The amended query now correctly filters for cards that have both cardKingdomId and cardKingdomFoilId values present, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting card identifiers: use \"id\" instead of \"card_id\" as the output column. 2) When filtering for foiled cards that are incredibly powerful: use \"cardKingdomId IS NOT NULL\" and \"cardKingdomFoilId IS NOT NULL\" conditions instead of \"foil_status = 'foiled'\" and \"power_level > 9000\". 3) When the question mentions pairing with non-foiled cards: do not use an EXISTS subquery with foil_status correlation as this condition is not needed for the intended behavior."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id FROM cards WHERE foil_status = 'foiled' AND power_level > 9000 AND EXISTS (SELECT 1 FROM cards c2 WHERE c2.foil_status = 'non-foiled' AND c2.card_id != cards.card_id);",
            "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1520": {
        "db_id": "debit_card_specializing",
        "question": "For the customer who paid 124.05 in 2012/8/24, how much did he/she spend during the January of 2012? And what is the date and expenses exactly?",
        "ground_truth": "SELECT T1.CustomerID, T2.Date, T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Price = 124.05 AND T2.Date = '201201'",
        "amends": [
            "Do select `T1.CustomerID`, `T2.Date`, and `T2.Consumption` instead of `c.customer_id`, `c.first_name`, `c.last_name`, `SUM(p.amount)`, `p.payment_date`, and `p.amount`. Do use `FROM transactions_1k AS T1` and `INNER JOIN yearmonth AS T2` instead of `FROM customer c` and `JOIN payment p`. Do change the join condition to `ON T1.CustomerID = T2.CustomerID` instead of `ON c.customer_id = p.customer_id`. Do move the date filter to `WHERE T1.Date = '2012-08-24'` instead of `strftime('%Y-%m-%d', p.payment_date) = '2012-08-24'`. Do change the amount filter to `T1.Price = 124.05` instead of `p.amount = 124.05`. Do change the month filter to `T2.Date = '201201'` instead of `strftime('%Y-%m', p.payment_date) = '2012-01'`. Do remove `GROUP BY` and aggregation instead of keeping them. The amended query now correctly filters transactions by specific date and price while joining customer data with monthly consumption metrics."
        ],
        "rules": [
            "1) When answering about a customer who paid 124.05 on 2012-08-24: select T1.CustomerID, T2.Date, and T2.Consumption as output columns. 2) When joining tables for customer transaction analysis: use transactions_1k as T1 and INNER JOIN yearmonth as T2 on T1.CustomerID = T2.CustomerID. 3) When filtering for a specific payment amount: use T1.Price = 124.05. 4) When filtering for a specific payment date: use T1.Date = '2012-08-24'. 5) When filtering for January 2012 consumption data: use T2.Date = '201201'. 6) When the question asks for spending during January 2012: return the T2.Consumption value directly without aggregation or grouping."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    c.customer_id,\n    c.first_name,\n    c.last_name,\n    SUM(p.amount) as total_spent_january,\n    p.payment_date,\n    p.amount as january_expense\nFROM customer c\nJOIN payment p ON c.customer_id = p.customer_id\nWHERE p.amount = 124.05 \n    AND strftime('%Y-%m-%d', p.payment_date) = '2012-08-24'\n    AND strftime('%Y-%m', p.payment_date) = '2012-01'\nGROUP BY c.customer_id, p.payment_date, p.amount;",
            "SELECT T1.CustomerID, T2.Date, T2.Consumption\nFROM transactions_1k AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Date = '2012-08-24' \nAND T1.Price = 124.05\nAND T2.Date = '201201'"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID, T2.Date, T2.Consumption \nFROM transactions_1k AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Price = 124.05 \nAND T1.Date = '2012-08-24' \nAND T2.Date = '201201'"
        ],
        "amend_res": 1
    },
    "288": {
        "db_id": "toxicology",
        "question": "Identify whether the molecule that contains atom TR001_1 is carcinogenic.",
        "ground_truth": "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'",
        "amends": [
            "Do select `T2.label AS flag_carcinogenic` instead of `carcinogenic` to use the proper column name with explicit alias. Do add `FROM atom AS T1 INNER JOIN molecule AS T2` instead of `FROM molecules` to join the correct tables with proper aliases. Do specify `ON T1.molecule_id = T2.molecule_id` instead of omitting the join condition to properly relate the tables. Do keep `WHERE T1.atom_id = 'TR001_1'` but reference it through the correct table alias `T1` instead of the incorrect table `molecules`. The amended query now correctly retrieves the carcinogenic flag by joining the atom and molecule tables through their relationship."
        ],
        "rules": [
            "1) When answering about whether a molecule containing a specific atom is carcinogenic: make sure the output order: flag_carcinogenic. 2) When the question mentions \"molecule that contains atom TR001_1\": join atom table as T1 and molecule table as T2 where T1.molecule_id = T2.molecule_id to find the molecule containing the specified atom. 3) When the question asks for carcinogenic status: use T2.label AS flag_carcinogenic instead of carcinogenic to get the proper column with explicit alias. 4) When filtering for atom TR001_1: use WHERE T1.atom_id = 'TR001_1' with exact literal value 'TR001_1' and correct table alias T1."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic FROM molecules WHERE atom_id = 'TR001_1';",
            "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'"
        ],
        "rule_sql": [
            "SELECT T2.label AS flag_carcinogenic FROM atom AS T1 JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'"
        ],
        "amend_res": 1
    },
    "302": {
        "db_id": "toxicology",
        "question": "Name the elements that comprise the atoms of bond TR001_2_4.",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_4'",
        "amends": [
            "Do select `element` from table `atom` instead of `element_name` from table `elements`. Do add `DISTINCT` instead of omitting it. Do change the FROM clause to use `atom AS T1 INNER JOIN connected AS T2` instead of a single table `elements`. Do add join condition `ON T1.atom_id = T2.atom_id` instead of omitting it. Do move the filter to `T2.bond_id = 'TR001_2_4'` instead of applying it directly to a non-existent `bond_id` column in the original table. The amended query now correctly retrieves distinct elements from joined tables using proper join conditions and filtering."
        ],
        "rules": [
            "1) When answering about \"elements that comprise atoms of bond TR001_2_4\": make sure the output order: element\n2) When the question mentions \"elements\": \"elements\" actually means \"element in table atom\"\n3) When retrieving distinct values from the element column: use DISTINCT to get unique element values\n4) When combining tables atom and connected for shared entities: link rows where T1.atom_id = T2.atom_id and keep only matching pairs (inner match)\n5) When filtering for bond TR001_2_4: apply the filter T2.bond_id = 'TR001_2_4' exactly as specified\n6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n7) When handling text literals: do not change case, spacing, or punctuation of 'TR001_2_4'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element_name FROM elements WHERE bond_id = 'TR001_2_4';",
            "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_4'"
        ],
        "rule_sql": [
            "SELECT DISTINCT a.element\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id\nWHERE c.bond_id = 'TR001_2_4'\nORDER BY a.element"
        ],
        "amend_res": 1
    },
    "808": {
        "db_id": "superhero",
        "question": "Find the race of the superhero who weighs 108kg and is 188cm tall.",
        "ground_truth": "SELECT DISTINCT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188",
        "amends": [
            "Do use `DISTINCT T2.race` instead of `race` to eliminate duplicates. Do join `superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id` instead of querying `superheroes` table directly to properly resolve race names through the relationship. Do reference columns `T1.weight_kg` and `T1.height_cm` instead of `weight` and `height` to use the correct column names with proper units. The amended query now correctly joins tables and uses proper column references to match the intended behavior."
        ],
        "rules": [
            "1) When the question asks about superhero attributes: use table \"superhero\" as T1 and table \"race\" as T2 with the join condition T1.race_id = T2.id to properly resolve race names. 2) When the question mentions \"weighs 108kg\": use column T1.weight_kg = 108 to match the exact weight value with proper units. 3) When the question mentions \"188cm tall\": use column T1.height_cm = 188 to match the exact height value with proper units. 4) When the question asks for \"race of the superhero\": use DISTINCT T2.race to eliminate duplicate race values while retrieving the race information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race FROM superheroes WHERE weight = 108 AND height = 188;",
            "SELECT DISTINCT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.race FROM superhero AS T1 JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 108 AND T1.height_cm = 188;"
        ],
        "amend_res": 1
    },
    "1529": {
        "db_id": "debit_card_specializing",
        "question": "What is the amount spent by customer \"38508\" at the gas stations? How much had the customer spent in January 2012?",
        "ground_truth": "SELECT SUM(T1.Price) , SUM(IIF(T3.Date = '201201', T1.Price, 0)) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.CustomerID = '38508'",
        "amends": [
            "Do select `SUM(T1.Price)` and `SUM(IIF(T3.Date = '201201', T1.Price, 0))` instead of `SUM(amount) AS total_spent`. Do join `gasstations AS T2` on `T1.GasStationID = T2.GasStationID` instead of filtering by `merchant_category = 'gas_station'`. Do join `yearmonth AS T3` on `T1.CustomerID = T3.CustomerID` instead of using `strftime('%Y-%m', transaction_date) = '2012-01'`. Do filter by `T1.CustomerID = '38508'` instead of `customer_id = '38508'`. The amended query now correctly joins additional tables for proper categorization and date handling, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for amount spent by customer \"38508\": filter rows where T1.CustomerID equals '38508' exactly. 2) When the question asks about spending at gas stations: join table gasstations as T2 where T1.GasStationID equals T2.GasStationID to properly categorize transactions. 3) When the question asks for total amount spent: compute the sum of T1.Price. 4) When the question asks for spending in January 2012: join table yearmonth as T3 where T1.CustomerID equals T3.CustomerID and compute the sum of T1.Price only for rows where T3.Date equals '201201' exactly. 5) When combining multiple tables for this analysis: perform inner joins using the exact key equalities shown in the amends (T1.GasStationID = T2.GasStationID and T1.CustomerID = T3.CustomerID)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) AS total_spent FROM transactions WHERE customer_id = '38508' AND merchant_category = 'gas_station' AND strftime('%Y-%m', transaction_date) = '2012-01';",
            "SELECT \n    SUM(T1.Price) AS total_spent_at_gas_stations,\n    SUM(IIF(T3.Date = '201201', T1.Price, 0)) AS spent_in_january_2012\nFROM transactions_1k AS T1\nJOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nJOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T1.CustomerID = '38508'"
        ],
        "rule_sql": [
            "SELECT \n    SUM(t1.Price) AS TotalAmountSpent,\n    SUM(CASE WHEN t3.Date = '201201' THEN t1.Price ELSE 0 END) AS January2012Spending\nFROM \n    transactions_1k t1\nINNER JOIN \n    gasstations t2 ON t1.GasStationID = t2.GasStationID\nINNER JOIN \n    yearmonth t3 ON t1.CustomerID = t3.CustomerID\nWHERE \n    t1.CustomerID = '38508'"
        ],
        "amend_res": 1
    },
    "1123": {
        "db_id": "european_football_2",
        "question": "What is the name of players with the highest potential?",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id ORDER BY t2.potential DESC LIMIT 1",
        "amends": [
            "Do select `t1.player_name` with `DISTINCT` instead of just `name` without distinct. Do use `FROM Player AS t1 INNER JOIN Player_Attributes AS t2` instead of just `FROM players`. Do add join condition `ON t1.player_api_id = t2.player_api_id` instead of omitting any join. Do order by `t2.potential DESC` instead of `potential DESC`. The amended query now correctly joins the Player and Player_Attributes tables to access the potential column and returns distinct player names ordered by potential.",
            "Do add `LIMIT 1` to the `ORDER BY` clause instead of omitting it, which ensures only the single highest-potential player is returned rather than all players ordered by potential. The amended query now matches RIGHT_SQL's behavior by limiting results to the top player with the highest potential value."
        ],
        "rules": [
            "1) When selecting player names: use \"t1.player_name\" with DISTINCT instead of just \"name\" without distinct. 2) When accessing player potential data: join \"Player AS t1\" with \"Player_Attributes AS t2\" using \"t1.player_api_id = t2.player_api_id\" instead of using a single table. 3) When ordering by potential: use \"t2.potential DESC\" instead of just \"potential DESC\" since potential is in the Player_Attributes table. 4) When finding players with highest potential: order by potential in descending order and take the top result.",
            "1) When the question asks for the highest potential: rank players by potential in descending order and keep only the top 1 row. 2) When combining Player and Player_Attributes tables: link rows where Player.player_api_id equals Player_Attributes.player_api_id and keep only matching pairs (inner match). 3) When answering about players with highest potential: make sure the output order includes only player_name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY potential DESC LIMIT 1;",
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.potential DESC;",
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.potential DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t2.potential DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "41": {
        "db_id": "california_schools",
        "question": "List the names of virtual schools that are among the top 5 in their respective counties based on average reading scores.",
        "ground_truth": "SELECT School FROM (SELECT T2.School,T1.AvgScrRead, RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) AS rnk FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Virtual = 'F' ) ranked_schools WHERE rnk <= 5",
        "amends": [
            "Do use a subquery with window functions instead of a simple SELECT with ORDER BY and LIMIT. Do add an INNER JOIN between `satscores` and `schools` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do change the filter to `T2.Virtual = 'F'` instead of `type = 'virtual'`. Do use `RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC)` to rank schools within counties by reading score instead of a simple descending sort. Do select from the ranked subquery with `WHERE rnk <= 5` to get top 5 schools per county instead of a global top 5 limit. Do return `School` column instead of `school_name`. The amended query now correctly identifies the top 5 schools by reading score within each county rather than globally, and properly filters for non-virtual schools."
        ],
        "rules": [
            "1) When the question asks for \"virtual schools\": use the exact literal 'F' for the \"Virtual\" column instead of 'virtual' for the \"type\" column. 2) When combining SAT scores and schools data: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match). 3) When ranking schools within counties by reading scores: use RANK() OVER (PARTITION BY T2.County ORDER BY T1.AvgScrRead DESC) to assign ranks within each county group. 4) When selecting top 5 schools per county: filter for rows where the rank is less than or equal to 5. 5) When the question asks for school names: return the \"School\" column instead of \"school_name\". 6) When the question mentions \"average reading scores\": use the exact column T1.AvgScrRead for reading score values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name FROM schools WHERE type = 'virtual' ORDER BY reading_score DESC LIMIT 5;",
            "WITH ranked_schools AS (\n    SELECT \n        s.School,\n        s.County,\n        ss.AvgScrRead,\n        RANK() OVER (PARTITION BY s.County ORDER BY ss.AvgScrRead DESC) as rnk\n    FROM satscores ss\n    INNER JOIN schools s ON ss.cds = s.CDSCode\n    WHERE s.Virtual = 'F'\n)\nSELECT \n    School\nFROM ranked_schools\nWHERE rnk <= 5\nORDER BY County, rnk;"
        ],
        "rule_sql": [
            "SELECT s.School\nFROM satscores sat\nINNER JOIN schools s ON sat.cds = s.CDSCode\nWHERE s.Virtual = 'F'\nQUALIFY RANK() OVER (PARTITION BY s.County ORDER BY sat.AvgScrRead DESC) <= 5\nORDER BY s.County, RANK() OVER (PARTITION BY s.County ORDER BY sat.AvgScrRead DESC)",
            "SELECT s.School\nFROM satscores t1\nINNER JOIN schools s ON t1.cds = s.CDSCode\nWHERE s.Virtual = 'F'\nAND (\n    SELECT COUNT(*) \n    FROM satscores t2\n    INNER JOIN schools s2 ON t2.cds = s2.CDSCode\n    WHERE s2.County = s.County \n    AND s2.Virtual = 'F'\n    AND t2.AvgScrRead > t1.AvgScrRead\n) < 5\nORDER BY s.County, t1.AvgScrRead DESC;"
        ],
        "amend_res": 1
    },
    "995": {
        "db_id": "formula_1",
        "question": "What is the average score of Lewis Hamilton among all the Turkish Grand Prix?",
        "ground_truth": "SELECT AVG(T2.points) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'",
        "amends": [
            "Do join `drivers` and `driverStandings` tables on `driverId` instead of querying races directly. Do use `T1.forename = 'Lewis'` and `T1.surname = 'Hamilton'` instead of `driver_name = 'Lewis Hamilton'` for proper driver identification. Do join `races` on `raceId` instead of filtering races directly. Do use `T3.name = 'Turkish Grand Prix'` instead of `race_name LIKE '%Turkish%'` for exact race name matching. Do select `AVG(T2.points)` from the driverStandings table instead of `AVG(score)` from races. The amended query now correctly calculates average points from driver standings for the specific driver and race, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about average score of a specific driver: calculate the average of T2.points from the driverStandings table instead of using a score column from races. 2) When identifying Lewis Hamilton: use T1.forename = 'Lewis' and T1.surname = 'Hamilton' from the drivers table instead of a single driver_name column. 3) When filtering for Turkish Grand Prix: use T3.name = 'Turkish Grand Prix' from the races table instead of a race_name LIKE pattern match. 4) When combining driver and race information: join drivers (T1) and driverStandings (T2) tables on driverId, then join races (T3) on raceId using exact key equality. 5) When computing aggregates across multiple tables: ensure all joins are inner matches to only include rows present in all three tables (drivers, driverStandings, and races)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(score) FROM races WHERE driver_name = 'Lewis Hamilton' AND race_name LIKE '%Turkish%';",
            "SELECT AVG(T2.points) \nFROM drivers T1\nJOIN driverStandings T2 ON T1.driverId = T2.driverId\nJOIN races T3 ON T2.raceId = T3.raceId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton' AND T3.name = 'Turkish Grand Prix'"
        ],
        "rule_sql": [
            "SELECT AVG(T2.points) AS average_score\nFROM drivers T1\nINNER JOIN driverStandings T2 ON T1.driverId = T2.driverId\nINNER JOIN races T3 ON T2.raceId = T3.raceId\nWHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'\nAND T3.name = 'Turkish Grand Prix';"
        ],
        "amend_res": 1
    },
    "1072": {
        "db_id": "european_football_2",
        "question": "What is the average overall rating of the football player Aaron Doran?",
        "ground_truth": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Aaron Doran'",
        "amends": [
            "Do use `SUM(t2.overall_rating)` and `COUNT(t2.id)` instead of `AVG(rating)` to explicitly calculate the average. Do add `Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the `players` table to properly join the player attributes data. Do reference `t1.player_name` instead of `name` to use the correct column name from the joined table. Do add `CAST(... AS REAL)` instead of relying on implicit casting to ensure proper floating-point division. Do remove the incorrect table reference `players` and instead use the properly aliased joined tables. The amended query now correctly calculates Aaron Doran's average rating by joining player data with attributes and using explicit casting for accurate division."
        ],
        "rules": [
            "1) When answering about average overall rating of a football player: use SUM(t2.overall_rating) divided by COUNT(t2.id) with explicit casting to REAL instead of AVG() function. 2) When the question mentions a player name like \"Aaron Doran\": use t1.player_name column with exact literal 'Aaron Doran' for filtering. 3) When combining player data with attributes: link Player AS t1 and Player_Attributes AS t2 using t1.player_api_id = t2.player_api_id with inner match. 4) When handling numeric calculations: use CAST(... AS REAL) to ensure proper floating-point division accuracy."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(rating) FROM players WHERE name = 'Aaron Doran';",
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) AS average_rating\nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Aaron Doran'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(t2.overall_rating) AS REAL) / CAST(COUNT(t2.id) AS REAL) AS average_overall_rating\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.player_name = 'Aaron Doran';"
        ],
        "amend_res": 1
    },
    "513": {
        "db_id": "card_games",
        "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
        "ground_truth": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
        "amends": [
            "Do select only `id` instead of selecting `s.id` with an alias. Do use `FROM sets` alone instead of joining with `cards` table. Do filter on `type = 'commander'` instead of `expansion_type = 'Commander'`. Do remove the `GROUP BY s.id` and `COUNT(c.id)` aggregation instead of keeping them. Do order by `totalSetSize DESC` instead of ordering by the count of cards. The amended query now correctly retrieves the commander set with the largest total set size directly from the sets table instead of attempting to calculate card counts through an unnecessary join and aggregation."
        ],
        "rules": [
            "1) When the question asks about sets with expansion type 'Commander': filter sets where \"type\" equals 'commander' exactly (case-sensitive). 2) When the question asks for the set with highest total number of cards including promotional and related supplemental products: order sets by \"totalSetSize\" in descending order and take the first result. 3) When the question asks to indicate the id of the set: select only the \"id\" column from the sets table. 4) When working with the sets table: use the base table directly without joining to other tables like cards. 5) When retrieving the largest total set size: do not perform aggregation or grouping since the totalSetSize column already contains the pre-calculated value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.id \nFROM sets s \nJOIN cards c ON s.id = c.set_id \nWHERE s.expansion_type = 'Commander' \nGROUP BY s.id \nORDER BY COUNT(c.id) DESC \nLIMIT 1;",
            "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "716": {
        "db_id": "codebase_community",
        "question": "Among the comments with scores between 5 to 10, what is the percentage of the users with 0 up votes?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.UpVotes = 0, 1, 0)) AS REAL) * 100/ COUNT(T1.Id) AS per FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score BETWEEN 5 AND 10",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.UpVotes = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM \n    Comments c\nJOIN \n    Users u ON c.UserId = u.Id\nWHERE \n    c.Score BETWEEN 5 AND 10"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN u.UpVotes = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM comments c\nJOIN users u ON c.UserId = u.Id\nWHERE c.Score BETWEEN 5 AND 10;"
        ],
        "amend_res": 1
    },
    "1445": {
        "db_id": "student_club",
        "question": "Find the full name of members whose t-shirt size is extra large.",
        "ground_truth": "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large'",
        "amends": [
            "Do add `last_name` to the SELECT list instead of omitting it. Do reference the table as `member` instead of `members`. Do filter on `t_shirt_size = 'X-Large'` instead of `t_shirt_size = 'XL'`. The amended query now correctly selects both name fields from the proper table with the accurate size filter."
        ],
        "rules": [
            "1) When the question asks for \"full name\" of members: include both \"first_name\" and \"last_name\" in the output. 2) When filtering by t-shirt size: use the exact literal value 'X-Large' instead of 'XL'. 3) When referencing the member table: use the exact table name \"member\" instead of \"members\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT first_name FROM members WHERE t_shirt_size = 'XL';",
            "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large';"
        ],
        "rule_sql": [
            "SELECT first_name, last_name FROM member WHERE t_shirt_size = 'X-Large';"
        ],
        "amend_res": 1
    },
    "782": {
        "db_id": "superhero",
        "question": "List the heroes' names whose eyes and hair colours are both black.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and use table aliases instead of direct column references. Do join `superhero AS T1` and `colour AS T2` instead of querying a single table. Do use `INNER JOIN` with `T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id` instead of simple OR conditions. Do filter on `T2.colour = 'Black'` with proper case sensitivity instead of `eyes = 'black' OR hair = 'black'`. The amended query now correctly joins through a colour lookup table and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"heroes' names whose eyes and hair colours are both black\": make sure the output order: T1.superhero_name. 2) When the question mentions \"heroes' names\": \"name\" actually means \"T1.superhero_name\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id; keep only matching pairs (inner match). 4) When filtering for black colour: use T2.colour = 'Black' with exact case sensitivity. 5) When the question requires both eyes and hair to be black: ensure both join conditions are satisfied simultaneously rather than using OR logic."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM heroes WHERE eyes = 'black' OR hair = 'black';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T2.colour = 'Black' AND T3.colour = 'Black'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nJOIN colour T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id\nWHERE T2.colour = 'Black'"
        ],
        "amend_res": 1
    },
    "748": {
        "db_id": "superhero",
        "question": "What is the eye colour of superhero with superhero ID 75?",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75",
        "amends": [
            "Do select `T2.colour` from the `colour` table instead of `eye_color` from the `superheroes` table. Do join `superhero AS T1` with `colour AS T2` using `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying a single table. Do filter on `T1.id = 75` instead of `superhero_id = 75` to correctly reference the joined table's primary key. The amended query now properly retrieves eye color information through the normalized relationship between superhero and color tables, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"eye colour of superhero with superhero ID 75\": make sure the output order: T2.colour. 2) When the question mentions \"superhero ID 75\": \"superhero ID 75\" actually means \"T1.id = 75\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.eye_colour_id = T2.id exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question mentions \"eye colour\": \"eye colour\" actually means \"T2.colour\" from the colour table, not \"eye_color\" from the superheroes table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM superheroes WHERE superhero_id = 75;",
            "SELECT T2.colour \nFROM superhero AS T1 \nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id \nWHERE T1.id = 75"
        ],
        "rule_sql": [
            "SELECT T2.colour\nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nWHERE T1.id = 75"
        ],
        "amend_res": 1
    },
    "81": {
        "db_id": "california_schools",
        "question": "In which city can you find the school in the state of California with the lowest latitude coordinates and what is its lowest grade? Indicate the school name.",
        "ground_truth": "SELECT T2.City, T1.`Low Grade`, T1.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.State = 'CA' ORDER BY T2.Latitude ASC LIMIT 1",
        "amends": [
            "Do select `T2.City`, `T1.Low Grade`, and `T1.School Name` instead of `city`, `lowest_grade`, and `name`. Do use `FROM frpm AS T1 INNER JOIN schools AS T2` instead of `FROM schools` alone. Do join on `T1.CDSCode = T2.CDSCode` instead of no join condition. Do filter on `T2.State = 'CA'` instead of `state = 'California'`. Do order by `T2.Latitude` instead of `latitude`. The amended query now correctly joins the frpm and schools tables using CDSCode, filters for California schools using the state abbreviation, and returns the appropriate columns from both tables while maintaining the ordering by latitude."
        ],
        "rules": [
            "1) When answering about schools in California with lowest latitude: make sure the output order: T2.City, T1.Low Grade, T1.School Name. 2) When the question mentions \"state of California\": \"California\" actually means \"T2.State = 'CA'\" in schema. 3) When combining T1 (frpm) and T2 (schools) for shared entities: link rows where T1.CDSCode = T2.CDSCode exactly as shown; keep only matching pairs (inner match). 4) When the question asks for \"lowest latitude coordinates\": order rows by T2.Latitude in ascending direction and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like T1.\"Low Grade\" and T1.\"School Name\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, lowest_grade, name FROM schools WHERE state = 'California' ORDER BY latitude ASC LIMIT 1;",
            "SELECT T2.City, T1.\"Low Grade\", T1.\"School Name\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.City, T1.\"Low Grade\", T1.\"School Name\"\nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.State = 'CA'\nORDER BY T2.Latitude ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1408": {
        "db_id": "student_club",
        "question": "Calculate the total cost spent for Parking in the list.",
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Parking'",
        "amends": [
            "Do reference the `cost` column instead of `amount` in the SELECT list. Do reference the `expense` table instead of `expenses` in the FROM clause. Do filter on `expense_description = 'Parking'` instead of `category = 'Parking'` in the WHERE clause. The amended query now correctly sums parking costs from the expense table based on description rather than using incorrect column and table names with a category filter."
        ],
        "rules": [
            "1) When the question asks about \"total cost spent for Parking\": use the exact column \"cost\" from table \"expense\" to calculate the sum. 2) When filtering for \"Parking\" expenses: use the exact literal 'Parking' with column \"expense_description\" in the WHERE condition. 3) When referencing the expense table: use the exact table name \"expense\" (not \"expenses\") in the FROM clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM expenses WHERE category = 'Parking';",
            "SELECT SUM(cost) AS total_parking_cost FROM expense WHERE expense_description = 'Parking';"
        ],
        "rule_sql": [
            "SELECT SUM(cost) AS total_cost_spent FROM expense WHERE expense_description = 'Parking';"
        ],
        "amend_res": 1
    },
    "724": {
        "db_id": "superhero",
        "question": "Please list the superhero names of all the superheroes that have blue eyes and blond hair.",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'",
        "amends": [
            "Do reference `T1.superhero_name` instead of `name` and use joined tables instead of direct column references. Do add `INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id` and `INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id` instead of querying the `superheroes` table directly. Do change the filter to `T2.colour = 'Blue' AND T3.colour = 'Blond'` instead of `eye_color = 'blue' OR hair_color = 'blond'` to require both conditions instead of either condition. The amended query now correctly joins through color reference tables and matches the intended behavior of finding superheroes with both blue eyes and blond hair."
        ],
        "rules": [
            "1) When answering about superhero names: make sure the output order: T1.superhero_name\n2) When the question mentions \"blue eyes\": \"blue eyes\" actually means T2.colour = 'Blue' in schema through T1.eye_colour_id = T2.id join\n3) When the question mentions \"blond hair\": \"blond hair\" actually means T3.colour = 'Blond' in schema through T1.hair_colour_id = T3.id join\n4) When combining T1 and T2 for eye color: link rows where T1.eye_colour_id = T2.id and keep only matching pairs (inner match)\n5) When combining T1 and T3 for hair color: link rows where T1.hair_colour_id = T3.id and keep only matching pairs (inner match)\n6) When filtering for both blue eyes and blond hair: require T2.colour = 'Blue' AND T3.colour = 'Blond' instead of using OR condition"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE eye_color = 'blue' OR hair_color = 'blond';",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nINNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id\nWHERE T2.colour = 'Blue' AND T3.colour = 'Blond'"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero T1\nINNER JOIN colour T2 ON T1.eye_colour_id = T2.id\nINNER JOIN colour T3 ON T1.hair_colour_id = T3.id\nWHERE T2.colour = 'Blue' AND T3.colour = 'Blond'"
        ],
        "amend_res": 1
    },
    "729": {
        "db_id": "superhero",
        "question": "What is the average height of the superheroes from Marvel Comics?",
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [
            "Do reference the `superhero` table as `T1` instead of `superheroes`, and join with `publisher` as `T2` on `T1.publisher_id = T2.id` instead of filtering directly on a `publisher` column. Do use `T1.height_cm` instead of `height` for the average calculation. Do filter on `T2.publisher_name = 'Marvel Comics'` instead of `publisher = 'DC Comics'` to correctly reference the joined publisher table's name column. The amended query now properly joins tables and filters by publisher name through the relationship, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average height of superheroes from Marvel Comics\": make sure the output order: AVG(T1.height_cm). 2) When the question mentions \"superheroes\": \"superheroes\" actually means \"T1\" in schema. 3) When the question mentions \"Marvel Comics\": \"Marvel Comics\" actually means \"T2.publisher_name = 'Marvel Comics'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.publisher_id = T2.id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM superheroes WHERE publisher = 'DC Comics';",
            "SELECT AVG(T1.height_cm) AS average_height FROM superhero T1 JOIN publisher T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.height_cm) FROM superhero T1 JOIN publisher T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'"
        ],
        "amend_res": 1
    },
    "1235": {
        "db_id": "thrombosis_prediction",
        "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
        "ground_truth": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `Diagnosis` and `ID` instead of `patient_id`, `age`, and `diagnosis`. Do calculate age using `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)` instead of directly selecting `age`. Do join `Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.RBC < 3.5` instead of `red_blood_cell > 5.0`, changing both the table reference and inequality direction. The amended query now correctly identifies patients with low red blood cell counts by joining laboratory data and calculating age dynamically from birthdate."
        ],
        "rules": [
            "1) When answering about patients with lower red blood cell counts: join Patient table as T1 with Laboratory table as T2 using T1.ID = T2.ID to combine patient and lab data. 2) When filtering for lower red blood cell counts: use T2.RBC < 3.5 instead of red_blood_cell > 5.0, changing both the column reference and inequality direction. 3) When selecting patient information: use DISTINCT to return unique results and select Diagnosis and ID instead of patient_id, age, and diagnosis. 4) When calculating patient age: compute it dynamically using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) instead of selecting a pre-existing age column."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT patient_id, age, diagnosis FROM patients WHERE red_blood_cell > 5.0;",
            "SELECT DISTINCT T1.Diagnosis, T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) AS age FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS Age, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.RBC < 3.5;",
            "SELECT DISTINCT T1.ID, (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS age, T1.Diagnosis\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.RBC < 3.5"
        ],
        "amend_res": 1
    },
    "628": {
        "db_id": "codebase_community",
        "question": "Which users have the highest number of views?",
        "ground_truth": "SELECT Id, DisplayName FROM users WHERE Views = ( SELECT MAX(Views) FROM users )",
        "amends": [
            "Do select `Id, DisplayName` columns instead of `user_id, COUNT(*) as view_count` aggregates. Do change the FROM clause to use `users` table instead of `views` table. Do add a WHERE filter with subquery `Views = (SELECT MAX(Views) FROM users)` instead of using GROUP BY and COUNT aggregation. Do remove the GROUP BY clause entirely instead of grouping by `user_id`. Do remove the ORDER BY and LIMIT clauses instead of ordering by `view_count ASC` with limit 10. The amended query now correctly identifies users with maximum views rather than counting view events per user."
        ],
        "rules": [
            "1) When answering about \"users with the highest number of views\": make sure the output order: Id, DisplayName. 2) When the question mentions \"users\": use the \"users\" table as T1. 3) When the question asks for \"highest number of views\": filter to only include rows where Views equals the maximum Views value from the users table. 4) When selecting columns: use the exact tokens \"Id\" and \"DisplayName\" from the users table. 5) When computing maximum views: use the exact column token \"Views\" from the users table in the subquery SELECT MAX(Views) FROM users."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT user_id, COUNT(*) as view_count FROM views GROUP BY user_id ORDER BY view_count ASC LIMIT 10;",
            "SELECT Id, DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ],
        "rule_sql": [
            "SELECT Id, DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users)"
        ],
        "amend_res": 1
    },
    "86": {
        "db_id": "california_schools",
        "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
        "evidence": "",
        "ground_truth": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
        "amends": [
            "Do use column names `AdmLName1`, `District`, `County`, and `School` instead of `administrator_last_name`, `district`, `county`, and `school_name`. Do filter with `CharterNum = '0040'` instead of `charter_number = 40`, using a string literal instead of a numeric value. The amended query now correctly matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for administrator's last name: use column \"AdmLName1\" instead of \"administrator_last_name\". 2) When the question asks for district: use column \"District\" instead of \"district\". 3) When the question asks for county: use column \"County\" instead of \"county\". 4) When the question asks for school name: use column \"School\" instead of \"school_name\". 5) When filtering by charter number 40: use condition \"CharterNum = '0040'\" with string literal '0040' instead of numeric value 40."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT administrator_last_name, district, county, school_name \nFROM schools \nWHERE charter_number = 40",
            "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'"
        ],
        "rule_sql": [
            "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'"
        ],
        "amend_res": 1
    },
    "229": {
        "db_id": "toxicology",
        "question": "What is the type of bond that molecule TR000 has when involved in any bonds?",
        "ground_truth": "SELECT DISTINCT T.bond_type FROM bond AS T WHERE T.molecule_id = 'TR000'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to return unique bond types. Do reference the table with alias `T` instead of using the bare table name. Do use the correct table name `bond` instead of `bonds`. Do maintain the filter condition `T.molecule_id = 'TR000'` instead of changing it. Do remove the `LIMIT 1` clause instead of keeping it since DISTINCT already ensures uniqueness. The amended query now correctly returns distinct bond types from the bond table for the specified molecule."
        ],
        "rules": [
            "1) When the question asks for \"type of bond\" for a specific molecule: use the exact table name \"bond\" with alias \"T\" instead of \"bonds\". 2) When filtering for molecule 'TR000': use the exact condition T.molecule_id = 'TR000' with the literal 'TR000' exactly as specified. 3) When returning bond types: use DISTINCT to ensure only unique bond_type values are returned. 4) When the question asks about \"any bonds\": do not use LIMIT 1 since DISTINCT already ensures uniqueness of results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM bonds WHERE molecule_id = 'TR000' LIMIT 1;",
            "SELECT DISTINCT bond_type FROM bond T WHERE T.molecule_id = 'TR000'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.bond_type FROM bond T WHERE T.molecule_id = 'TR000'"
        ],
        "amend_res": 1
    },
    "255": {
        "db_id": "toxicology",
        "question": "What proportion of single bonds are carcinogenic? Please provide your answer as a percentage with five decimal places.",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id),5) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do use `ROUND(CAST(...) * 100 / COUNT(...),5)` instead of `(COUNT(...) * 100.0 / COUNT(*))` for precise decimal calculation. Do select from `bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of just `FROM bonds` to incorporate the molecule relationship. Do filter on `T1.bond_type = '-'` instead of `bond_type = 'single'` for the correct bond type condition. Do count `CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END` instead of `CASE WHEN carcinogenic = 'Yes' THEN 1 END` to use the molecule label for carcinogenic identification. Do reference `T1.bond_id` in both count expressions instead of `*` for consistent counting. The amended query now correctly calculates the proportion of carcinogenic bonds using proper table joins and condition logic."
        ],
        "rules": [
            "1) When answering about proportion of single bonds that are carcinogenic: make sure the output order: proportion_carcinogenic as a percentage with five decimal places. 2) When the question mentions \"single bonds\": \"single\" actually means \"bond_type = '-' in schema\". 3) When the question mentions \"carcinogenic\": \"carcinogenic\" actually means \"molecule label = '+' in schema\". 4) When combining bond table T1 and molecule table T2: link rows where T1.molecule_id = T2.molecule_id exactly as shown; keep only matching pairs (inner match). 5) When calculating the proportion: compute (COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) * 100 / COUNT(T1.bond_id)) and ROUND to 5 decimal places. 6) When filtering for single bonds: use T1.bond_type = '-' as the exact condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN carcinogenic = 'Yes' THEN 1 END) * 100.0 / COUNT(*)) AS proportion_carcinogenic\nFROM bonds\nWHERE bond_type = 'single';",
            "SELECT ROUND(CAST(COUNT(CASE WHEN T2.label = '+' THEN T1.bond_id ELSE NULL END) AS REAL) * 100 / COUNT(T1.bond_id), 5) AS proportion\nFROM bond AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT \n    ROUND(\n        (COUNT(CASE WHEN m.label = '+' THEN b.bond_id ELSE NULL END) * 100.0 / COUNT(b.bond_id)),\n        5\n    ) AS proportion_carcinogenic\nFROM \n    bond b\nINNER JOIN \n    molecule m ON b.molecule_id = m.molecule_id\nWHERE \n    b.bond_type = '-';"
        ],
        "amend_res": 1
    },
    "868": {
        "db_id": "formula_1",
        "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
        "ground_truth": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
        "amends": [
            "Do use `DISTINCT` instead of omitting it to eliminate duplicate rows. Do select `T1.lat` and `T1.lng` instead of `latitude` and `longitude` to match the correct column names. Do add `races AS T2` table instead of querying only the `circuits` table to enable the join operation. Do use `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of no join condition to properly relate the tables. Do filter on `T2.name = 'Malaysian Grand Prix'` instead of `country = 'Malaysia'` to target the specific race event rather than all circuits in the country. The amended query now correctly retrieves coordinates for circuits that hosted the Malaysian Grand Prix, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for location coordinates of a specific Grand Prix: select T1.lat and T1.lng as the coordinate columns instead of latitude and longitude. 2) When joining circuits and races tables: use INNER JOIN on T2.circuitID = T1.circuitId to properly relate the tables. 3) When filtering for a specific Grand Prix event: use T2.name = 'Malaysian Grand Prix' instead of country filtering to target the specific race. 4) When retrieving data that might have duplicates: use DISTINCT to eliminate duplicate rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT latitude, longitude FROM circuits WHERE country = 'Malaysia';",
            "SELECT DISTINCT T1.lat, T1.lng\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T2.name = 'Malaysian Grand Prix';"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.lat, T1.lng FROM circuits T1 INNER JOIN races T2 ON T2.circuitId = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix';"
        ],
        "amend_res": 1
    },
    "1320": {
        "db_id": "student_club",
        "question": "Please list the event names of all the events attended by Maya Mclean.",
        "evidence": "",
        "ground_truth": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'",
        "amends": [
            "Do select `T1.event_name` from the `event` table instead of `event_name` from the `events` table. Do add `INNER JOIN` on `attendance AS T2` with predicate `T1.event_id = T2.link_to_event` instead of omitting this join. Do add another `INNER JOIN` on `member AS T3` with predicate `T2.link_to_member = T3.member_id` instead of omitting this join. Do change the WHERE filter to `T3.first_name = 'Maya' AND T3.last_name = 'Mclean'` instead of `attendee_name = 'Maya Mclean'` to properly match the member's first and last name separately. The amended query now correctly joins through the attendance table to find events attended by the specified member and matches RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about events attended by a specific person: use the event table (T1) to get event names instead of an events table. 2) When finding events attended by someone: join the attendance table (T2) where T1.event_id = T2.link_to_event to connect events to attendance records. 3) When identifying the attendee: join the member table (T3) where T2.link_to_member = T3.member_id to connect attendance records to members. 4) When filtering for Maya Mclean: use T3.first_name = 'Maya' AND T3.last_name = 'Mclean' instead of a single attendee_name column to match first and last names separately. 5) When selecting output: return T1.event_name from the event table as the final result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_name FROM events WHERE attendee_name = 'Maya Mclean';",
            "SELECT T1.event_name \nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nINNER JOIN member AS T3 ON T2.link_to_member = T3.member_id\nWHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'"
        ],
        "rule_sql": [
            "SELECT T1.event_name \nFROM event T1\nJOIN attendance T2 ON T1.event_id = T2.link_to_event\nJOIN member T3 ON T2.link_to_member = T3.member_id\nWHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'"
        ],
        "amend_res": 1
    },
    "210": {
        "db_id": "toxicology",
        "question": "What atoms are connected in single type bonds?",
        "ground_truth": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'",
        "amends": [
            "Do select specific columns `T2.atom_id` and `T2.atom_id2` instead of selecting all columns with `*`. Do join table `bond AS T1` with `connected AS T2` using `INNER JOIN` on `T1.bond_id = T2.bond_id` instead of querying only the `atoms` table. Do filter on `T1.bond_type = '-'` instead of filtering on `bond_type = 'single'`. The amended query now correctly retrieves connected atom pairs for single bonds by joining the bond and connected tables with proper column selection and filtering."
        ],
        "rules": [
            "1) When answering about \"atoms connected in single type bonds\": make sure the output order: T2.atom_id, T2.atom_id2. 2) When the question mentions \"single type bonds\": \"single\" actually means \"bond_type = '-' in schema\". 3) When combining bond table as T1 and connected table as T2: link rows where T1.bond_id = T2.bond_id exactly and keep only matching pairs (inner match). 4) When filtering for bond type: use T1.bond_type = '-' exactly as specified in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM atoms WHERE bond_type = 'single';",
            "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT T2.atom_id, T2.atom_id2\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nWHERE T1.bond_type = '-'"
        ],
        "amend_res": 1
    },
    "757": {
        "db_id": "superhero",
        "question": "Identify the race of the superhero who weighed 169 kg.",
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.weight_kg = 169",
        "amends": [
            "Do select `T2.race` from the race table instead of `race` directly from superheroes. Do join `superhero AS T1` with `race AS T2` on `T1.race_id = T2.id` instead of querying a single table. Do filter on `T1.weight_kg = 169` instead of `weight = 169` to use the correct column name and unit. The amended query now properly joins tables to access race information through the correct relationship and uses the appropriate weight column with kilogram units."
        ],
        "rules": [
            "1) When answering about superhero race information: access race data through the race table (T2) rather than directly from the superheroes table. 2) When combining superhero and race tables: link rows where T1.race_id equals T2.id and keep only matching pairs (inner match). 3) When filtering by weight: use the exact column T1.weight_kg with the value 169 to match the kilogram unit specification. 4) When selecting output: return T2.race as the final result."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race FROM superheroes WHERE weight = 169;",
            "SELECT T2.race \nFROM superhero AS T1 \nJOIN race AS T2 ON T1.race_id = T2.id \nWHERE T1.weight_kg = 169"
        ],
        "rule_sql": [
            "SELECT T2.race \nFROM superhero T1 \nINNER JOIN race T2 ON T1.race_id = T2.id \nWHERE T1.weight_kg = 169"
        ],
        "amend_res": 1
    },
    "1482": {
        "db_id": "debit_card_specializing",
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "ground_truth": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
        "amends": [
            "Do use explicit `CAST` operations for floating-point division instead of implicit integer division. Do reference multiple tables `customers` and `yearmonth` with an `INNER JOIN` on `CustomerID` instead of a single table `consumption_data`. Do filter by `Date LIKE '2012%'` and `Date LIKE '2013%'` patterns instead of `year IN (2012, 2013)` with exact year matching. Do use `IIF` conditional logic with explicit segment filtering (`'SME'`, `'LAM'`, `'KAM'`) instead of calculating percentage increases for all segments and then aggregating with `MAX` and `MIN`. Do remove the subquery and outer aggregation with `MAX`/`MIN`/`GROUP BY segment`/`ORDER BY segment` since the right query calculates specific segment percentages directly in the SELECT list. Do handle each segment's calculation separately in the SELECT clause instead of using a generalized approach with subsequent aggregation. The amended query now correctly calculates percentage increases for specific segments using proper date filtering and explicit casting.",
            "Do use `CAST` on the entire percentage calculation expression instead of only on the numerator difference, ensuring proper floating-point division. Do calculate percentage growth for each segment (`SME`, `LAM`, `KAM`) separately with proper year filtering using `LIKE '2013%'` and `LIKE '2012%'` instead of incorrect date handling. Do maintain the `INNER JOIN` between `customers` and `yearmonth` tables on `CustomerID` instead of changing the join structure. The amended query now correctly computes year-over-year percentage growth for each customer segment by properly casting the entire calculation to avoid integer division issues and accurately filtering for 2012 and 2013 data, matching the right SQL's behavior.",
            "Do add `T1.Segment` conditions within each `SUM` calculation instead of calculating the same percentage increase for all segments. Do use `IIF` instead of `CASE WHEN` for conditional logic. Do reference `T2.Date` instead of `y.Date` and `T2.Consumption` instead of `y.Consumption` to align with the table aliases. Do change the join order to `FROM customers AS T1 INNER JOIN yearmonth AS T2` instead of `FROM yearmonth y INNER JOIN customers c`. Do remove the explicit `WHERE` clause filtering by `c.Segment IN ('SME', 'LAM', 'KAM')` and `c.Currency = 'EUR'` and `(y.Date LIKE '2012%' OR y.Date LIKE '2013%')` since these conditions are now handled within the `IIF` statements. Do cast to `FLOAT` instead of `REAL` for the percentage calculations. The amended query now correctly calculates separate percentage increases for each customer segment by incorporating segment-specific conditions directly in the aggregate functions.",
            "Do cast the difference calculation as `FLOAT` before multiplication instead of casting the entire percentage expression, and do remove the column aliases `SME_Percentage_Increase`, `LAM_Percentage_Increase`, and `KAM_Percentage_Increase` instead of keeping them. Do maintain the same `FROM` clause with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` and preserve the `WHERE` filter on `T1.Currency = 'EUR'` without changes. The amended query now correctly calculates percentage increases by casting the numerator difference before multiplication to avoid integer division issues while maintaining the same logical behavior.",
            "Do move the `T1.Currency = 'EUR'` filter from the `WHERE` clause instead of omitting it entirely. Do change the calculation order by applying the multiplication by `100` after the division instead of before it within the `CAST` function. Do remove the explicit column aliases `SME_Percentage_Increase`, `LAM_Percentage_Increase`, and `KAM_Percentage_Increase` instead of keeping them. The amended query now correctly calculates percentage increases without the currency filter and with proper mathematical operation sequencing."
        ],
        "rules": [
            "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT \n    segment,\n    MAX(percentage_increase) AS biggest_increase,\n    MIN(percentage_increase) AS lowest_increase\nFROM (\n    SELECT \n        segment,\n        ((SUM(CASE WHEN year = 2013 AND currency = 'EUR' THEN consumption ELSE 0 END) - \n          SUM(CASE WHEN year = 2012 AND currency = 'EUR' THEN consumption ELSE 0 END)) / \n         SUM(CASE WHEN year = 2012 AND currency = 'EUR' THEN consumption ELSE 0 END)) * 100 AS percentage_increase\n    FROM consumption_data\n    WHERE year IN (2012, 2013)\n    GROUP BY segment\n) subquery\nGROUP BY segment\nORDER BY segment;",
            "error",
            "SELECT \n    CAST((SUM(CASE WHEN y.Date LIKE '2013%' THEN y.Consumption ELSE 0 END) - SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END)) * 100.0 / SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END) AS REAL) AS SME_Percentage_Increase,\n    CAST((SUM(CASE WHEN y.Date LIKE '2013%' THEN y.Consumption ELSE 0 END) - SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END)) * 100.0 / SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END) AS REAL) AS LAM_Percentage_Increase,\n    CAST((SUM(CASE WHEN y.Date LIKE '2013%' THEN y.Consumption ELSE 0 END) - SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END)) * 100.0 / SUM(CASE WHEN y.Date LIKE '2012%' THEN y.Consumption ELSE 0 END) AS REAL) AS KAM_Percentage_Increase\nFROM \n    yearmonth y\nINNER JOIN \n    customers c ON y.CustomerID = c.CustomerID\nWHERE \n    c.Currency = 'EUR' \n    AND (y.Date LIKE '2012%' OR y.Date LIKE '2013%')\n    AND c.Segment IN ('SME', 'LAM', 'KAM');",
            "SELECT \n    CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) * 100.0 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) AS SME_Percentage_Increase,\n    CAST((SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0))) * 100.0 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) AS LAM_Percentage_Increase,\n    CAST((SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0))) * 100.0 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) AS KAM_Percentage_Increase\nFROM \n    customers AS T1 \n    INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'EUR'",
            "SELECT \n    CAST(100.0 * (SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'SME', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'SME', T2.Consumption, 0))) / SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'SME', T2.Consumption, 0)) AS FLOAT) AS SME_Percentage_Increase,\n    CAST(100.0 * (SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'LAM', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'LAM', T2.Consumption, 0))) / SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'LAM', T2.Consumption, 0)) AS FLOAT) AS LAM_Percentage_Increase,\n    CAST(100.0 * (SUM(IIF(T2.Date LIKE '2013%' AND T1.Segment = 'KAM', T2.Consumption, 0)) - SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'KAM', T2.Consumption, 0))) / SUM(IIF(T2.Date LIKE '2012%' AND T1.Segment = 'KAM', T2.Consumption, 0)) AS FLOAT) AS KAM_Percentage_Increase\nFROM \n    customers AS T1 \n    INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE \n    T1.Currency = 'EUR'",
            "SELECT \n    CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100.0 / NULLIF(SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), 0) AS SME_Percentage_Increase,\n    CAST((SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100.0 / NULLIF(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)), 0) AS LAM_Percentage_Increase,\n    CAST((SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100.0 / NULLIF(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)), 0) AS KAM_Percentage_Increase\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Currency = 'EUR'"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "890": {
        "db_id": "formula_1",
        "question": "How many seasons has Silverstone Circuit hosted the United Kindom grand prix?",
        "ground_truth": "SELECT COUNT(T2.circuitid) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix'",
        "amends": [
            "Do join `circuits AS T1` and `races AS T2` with `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do filter on `T1.name = 'Silverstone Circuit'` and `T2.name = 'British Grand Prix'` instead of `circuit_name = 'Silverstone Circuit'` and `country = 'United Kingdom'`. Do count `T2.circuitid` instead of counting distinct `season` values. The amended query now correctly matches the intended behavior by properly joining circuit and race data with accurate filtering conditions."
        ],
        "rules": [
            "1) When answering about \"how many seasons Silverstone Circuit hosted the United Kingdom grand prix\": make sure the output order: count of seasons\n2) When the question mentions \"Silverstone Circuit\": \"Silverstone Circuit\" actually means \"T1.name = 'Silverstone Circuit'\" in schema\n3) When the question mentions \"United Kingdom grand prix\": \"United Kingdom grand prix\" actually means \"T2.name = 'British Grand Prix'\" in schema\n4) When combining T1 (circuits) and T2 (races) for shared entities: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)\n5) When the question asks for \"count of seasons\": compute the number of rows using the canonical key token T2.circuitid as shown in the amends"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT season) FROM races WHERE circuit_name = 'Silverstone Circuit' AND country = 'United Kingdom';",
            "SELECT COUNT(DISTINCT T2.year) AS season_count\nFROM circuits AS T1\nINNER JOIN races AS T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Silverstone Circuit' AND T2.name = 'British Grand Prix';"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT races.year) AS season_count\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE circuits.name = 'Silverstone Circuit'\nAND races.name = 'British Grand Prix'"
        ],
        "amend_res": 1
    },
    "985": {
        "db_id": "formula_1",
        "question": "Among the drivers who participated in the French Grand Prix, who has the slowest time in the 3rd lap.",
        "ground_truth": "SELECT T1.driverId FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'French Grand Prix' AND T1.lap = 3 ORDER BY T1.time DESC LIMIT 1",
        "amends": [
            "Do select `T1.driverId` instead of `driver_name` from the result set. Do join `lapTimes AS T1` with `races AS T2` using `INNER JOIN` on `T1.raceId = T2.raceId` instead of querying only the `drivers` table. Do filter with `T2.name = 'French Grand Prix'` and `T1.lap = 3` instead of just `race = 'French Grand Prix'`. Do order by `T1.time DESC` instead of `lap_3_time ASC` while maintaining the `LIMIT 1` clause. The amended query now correctly identifies the driver with the slowest lap time (maximum time) for lap 3 of the French Grand Prix instead of attempting to find the fastest lap time from an incorrect table structure."
        ],
        "rules": [
            "1) When answering about drivers who participated in the French Grand Prix: join lapTimes AS T1 with races AS T2 using inner match where T1.raceId = T2.raceId. 2) When filtering for the French Grand Prix: use T2.name = 'French Grand Prix' exactly as specified. 3) When filtering for the 3rd lap: use T1.lap = 3 exactly as specified. 4) When finding the slowest time: order by T1.time DESC (maximum time) instead of ascending order. 5) When selecting the driver: use T1.driverId instead of driver_name from the result set. 6) When limiting to the slowest driver: keep only the first row after ordering by time DESC."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name FROM drivers WHERE race = 'French Grand Prix' ORDER BY lap_3_time ASC LIMIT 1;",
            "SELECT T1.driverId\nFROM lapTimes AS T1\nINNER JOIN races AS T2 ON T1.raceId = T2.raceId\nWHERE T2.name = 'French Grand Prix'\nAND T1.lap = 3\nORDER BY T1.time DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.driverId \nFROM lapTimes AS T1 \nINNER JOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.name = 'French Grand Prix' \nAND T1.lap = 3 \nORDER BY T1.time DESC \nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1180": {
        "db_id": "thrombosis_prediction",
        "question": "Was the patient a man or a women whose ALT glutamic pylvic transaminase status got 9 on 1992-6-12?",
        "ground_truth": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT = 9.0 AND T2.Date = '1992-06-12'",
        "amends": [
            "Do select `T1.SEX` from the `Patient` table instead of `gender` from the `patients` table. Do join `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `T2.GPT = 9.0` instead of `alt_glutamic_pylvic_transaminase = 9` and use `T2.Date = '1992-06-12'` with proper date formatting instead of `date = '1992-6-12'`. The amended query now correctly retrieves gender information by joining patient and laboratory data with accurate column references and proper date format."
        ],
        "rules": [
            "1) When answering about patient gender and laboratory results: make sure the output order: T1.SEX 2) When the question mentions \"ALT glutamic pylvic transaminase status\": \"ALT glutamic pylvic transaminase status\" actually means \"T2.GPT in schema\" 3) When the question mentions a specific date \"1992-6-12\": use exact date format '1992-06-12' for T2.Date 4) When the question asks for gender information: use T1.SEX from the Patient table instead of gender from patients table 5) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match) 6) When filtering for laboratory values: use T2.GPT = 9.0 instead of alt_glutamic_pylvic_transaminase = 9"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT gender FROM patients WHERE alt_glutamic_pylvic_transaminase = 9 AND date = '1992-6-12';",
            "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT = 9 AND T2.Date = '1992-06-12'"
        ],
        "rule_sql": [
            "SELECT T1.SEX FROM Patient T1 INNER JOIN Laboratory T2 ON T1.ID = T2.ID WHERE T2.GPT = 9 AND T2.Date = '1992-06-12'"
        ],
        "amend_res": 1
    },
    "294": {
        "db_id": "toxicology",
        "question": "Which bond ids are double-bond with carcinogenic compound?",
        "ground_truth": "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='",
        "amends": [
            "Do select `T1.bond_id` with table alias qualification instead of `bond_id` without qualification. Do use `bond AS T1` as the source table instead of `bonds`. Do add `INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of the subquery approach. Do change the WHERE clause to `T2.label = '+' AND T1.bond_type = '='` instead of `bond_type = 'double' AND compound_id IN (SELECT compound_id FROM compounds WHERE carcinogenic = 'yes')`. Do remove the subquery correlation entirely instead of using it. The amended query now correctly joins bond and molecule tables directly and uses appropriate filter conditions matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting bond identifiers: use the exact column token \"T1.bond_id\" with table alias qualification instead of unqualified \"bond_id\". 2) When referencing the bond table: use the exact table name \"bond\" with alias \"T1\" instead of \"bonds\". 3) When combining bond and molecule data: perform an inner join between \"bond AS T1\" and \"molecule AS T2\" using the exact join condition \"T1.molecule_id = T2.molecule_id\" instead of using a subquery. 4) When filtering for double bonds with carcinogenic compounds: use the exact filter conditions \"T2.label = '+' AND T1.bond_type = '='\" instead of \"bond_type = 'double' AND compound_id IN (SELECT compound_id FROM compounds WHERE carcinogenic = 'yes')\". 5) When handling carcinogenic compounds: recognize that \"carcinogenic\" in the question maps to \"T2.label = '+'\" in the schema, not a separate compounds table. 6) When handling double bonds: recognize that \"double-bond\" in the question maps to \"T1.bond_type = '='\" in the schema, not the literal value 'double'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_id FROM bonds WHERE bond_type = 'double' AND compound_id IN (SELECT compound_id FROM compounds WHERE carcinogenic = 'yes')",
            "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.bond_type = '='"
        ],
        "amend_res": 1
    },
    "1266": {
        "db_id": "thrombosis_prediction",
        "question": "Which is the youngest patient with an abnormal anti-ribonuclear protein level? Please list his or her date of birth.",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP != '-' OR '+-' ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [
            "Do select `T1.Birthday` instead of `date_of_birth` and change the sort order to `DESC` instead of `ASC`. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.RNP != '-' OR '+-'` instead of `anti_ribonuclear_protein = 'abnormal'` to properly handle the laboratory result values. The amended query now correctly retrieves patient birthdays based on RNP laboratory test results with the appropriate join logic and filtering conditions."
        ],
        "rules": [
            "1) When answering about the youngest patient with an abnormal anti-ribonuclear protein level: make sure the output order is T1.Birthday. 2) When the question mentions \"date of birth\": \"date of birth\" actually means \"T1.Birthday\" in schema. 3) When the question mentions \"youngest\": rank rows by T1.Birthday in descending order and keep the first 1 row. 4) When combining T1 and T2 for shared entities: link rows where T1.ID = T2.ID exactly as shown in the amends; keep only matching pairs (inner match). 5) When filtering for abnormal anti-ribonuclear protein level: filter with T2.RNP != '-' OR '+-' to properly handle the laboratory result values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT date_of_birth FROM patients WHERE anti_ribonuclear_protein = 'abnormal' ORDER BY date_of_birth ASC LIMIT 1;",
            "SELECT T1.Birthday\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.RNP != '-' OR T2.RNP != '+-'\nORDER BY T1.Birthday DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.RNP != '-' AND T2.RNP != '+-'\nORDER BY T1.Birthday DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1270": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients who has a normal anti-scl70, how many of them are female and does not have any symptom?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T3.ID = T2.ID WHERE (T2.SC170 = 'negative' OR T2.SC170 = '0') AND T1.SEX = 'F' AND T3.Symptoms IS NULL",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count distinct patients rather than all test records. Do join `Laboratory AS T2` and `Examination AS T3` instead of only joining `lab_tests` to access additional required tables. Do use `INNER JOIN` on `T1.ID = T2.ID` and `T3.ID = T2.ID` instead of joining on `patient_id` with different table relationships. Do filter with `(T2.SC170 = 'negative' OR T2.SC170 = '0')` instead of `test_name = 'anti-scl70' AND result = 'normal'` to check for negative SC170 results using the correct column name and values. Do use `T1.SEX = 'F'` instead of `p.gender = 'female'` with the correct column name and value format. Do filter with `T3.Symptoms IS NULL` instead of `p.symptom_count = 0` to check for absence of symptoms using the proper null check rather than a numeric count. The amended query now correctly counts distinct female patients with negative SC170 laboratory results and no examination symptoms, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: count distinct T1.ID values instead of all records to get unique patient counts. 2) When combining Laboratory and Examination tables: use INNER JOIN on T1.ID = T2.ID and T3.ID = T2.ID to properly link all three tables. 3) When checking for normal anti-scl70 results: use (T2.SC170 = 'negative' OR T2.SC170 = '0') instead of test_name and result conditions to match the correct column and values. 4) When filtering for female patients: use T1.SEX = 'F' instead of gender = 'female' with the correct column name and value format. 5) When checking for absence of symptoms: use T3.Symptoms IS NULL instead of symptom_count = 0 to properly detect missing symptom records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN lab_tests l ON p.patient_id = l.patient_id\nWHERE l.test_name = 'anti-scl70' AND l.result = 'normal'\nAND p.gender = 'female'\nAND p.symptom_count = 0",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T3.ID = T2.ID\nWHERE (T2.SC170 = 'negative' OR T2.SC170 = '0')\nAND T1.SEX = 'F'\nAND T3.Symptoms IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nINNER JOIN Examination T3 ON T2.ID = T3.ID\nWHERE (T2.SC170 = 'negative' OR T2.SC170 = '0')\nAND T1.SEX = 'F'\nAND T3.Symptoms IS NULL"
        ],
        "amend_res": 1
    },
    "361": {
        "db_id": "card_games",
        "question": "How many cards of legalities whose status is restricted have text boxes?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
        "amends": [
            "Do `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct card IDs rather than all rows. Do `INNER JOIN` on `T1.uuid = T2.uuid` instead of `JOIN` on `c.id = l.card_id` to use UUID matching instead of ID matching. Do filter on `T2.status = 'Restricted'` instead of `l.status = 'restricted'` to match the proper case-sensitive status value. Do filter on `T1.isTextless = 0` instead of `c.text_box IS NOT NULL` to check for non-textless cards using a boolean flag rather than text box presence. The amended query now correctly counts distinct cards with restricted status that are not textless, matching the intended behavior."
        ],
        "rules": [
            "1) When counting cards: count distinct card IDs using COUNT(DISTINCT T1.id) instead of counting all rows. 2) When joining cards and legalities tables: use INNER JOIN on T1.uuid = T2.uuid to match rows by UUID instead of ID. 3) When filtering for restricted status: use T2.status = 'Restricted' with exact case-sensitive matching instead of 'restricted'. 4) When checking for cards with text boxes: use T1.isTextless = 0 to identify non-textless cards instead of checking for text box presence."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards c JOIN legalities l ON c.id = l.card_id WHERE l.status = 'restricted' AND c.text_box IS NOT NULL;",
            "SELECT COUNT(DISTINCT cards.id) \nFROM cards \nINNER JOIN legalities ON cards.uuid = legalities.uuid \nWHERE legalities.status = 'Restricted' \nAND cards.isTextless = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nINNER JOIN legalities T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Restricted' \nAND T1.isTextless = 0"
        ],
        "amend_res": 1
    },
    "1332": {
        "db_id": "student_club",
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "ground_truth": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "amends": [
            "Do select `T2.spent` instead of `SUM(amount)` and change the source to `event AS T1 INNER JOIN budget AS T2` instead of `expenses`. Do use join condition `T1.event_id = T2.link_to_event` instead of no join. Do filter with `T1.event_name = 'September Meeting'` and `T2.category = 'Food'` instead of `category = 'food'` and `club = 'Student_Club'`. Do use `SUBSTR(T1.event_date, 6, 2) = '09'` for date filtering instead of `date LIKE '2023-09%'`. The amended query now correctly joins event and budget tables to retrieve spending data for the specific September meeting with proper category filtering."
        ],
        "rules": [
            "1) When answering about spending on food in September Meeting: select T2.spent instead of SUM(amount) and use event AS T1 INNER JOIN budget AS T2 as the source. 2) When combining event and budget tables: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match). 3) When filtering for September Meeting: use T1.event_name = 'September Meeting' instead of club = 'Student_Club'. 4) When filtering for food category: use T2.category = 'Food' instead of category = 'food' (note exact case and spelling). 5) When filtering for September date: use SUBSTR(T1.event_date, 6, 2) = '09' to extract the month instead of date LIKE '2023-09%'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM expenses WHERE category = 'food' AND date LIKE '2023-09%' AND club = 'Student_Club';",
            "SELECT T2.spent \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'September Meeting' \nAND T2.category = 'Food' \nAND SUBSTR(T1.event_date, 6, 2) = '09'"
        ],
        "rule_sql": [
            "SELECT T2.spent \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'September Meeting' \nAND T2.category = 'Food' \nAND SUBSTR(T1.event_date, 6, 2) = '09'"
        ],
        "amend_res": 1
    },
    "1221": {
        "db_id": "thrombosis_prediction",
        "question": "Provide the ID, sex, birthday of all patients diagnosed with 'RA' that are within the UN normal index.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN < 30 AND T1.Diagnosis = 'RA'",
        "amends": [
            "Do add `DISTINCT` instead of omitting it, and do use table aliases `T1` and `T2` instead of bare table names. Do change the SELECT list to `T1.ID` instead of `patient_id`, and do use `T1.SEX` instead of `sex`, and `T1.Birthday` instead of `birthday`. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table. Do change the WHERE clause to `T2.UN < 30` instead of `un_normal_index = 'within'`, and do use `T1.Diagnosis = 'RA'` instead of `diagnosis = 'RA'`. The amended query now correctly joins patient and laboratory data to filter patients with UN values below 30 who have RA diagnosis, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patient information: make sure the output order: ID, sex, birthday. 2) When the question mentions \"ID\": \"ID\" actually means \"T1.ID\" in schema. 3) When the question mentions \"sex\": \"sex\" actually means \"T1.SEX\" in schema. 4) When the question mentions \"birthday\": \"birthday\" actually means \"T1.Birthday\" in schema. 5) When combining T1 (patients) and T2 (Laboratory) for shared entities: link rows where T1.ID = T2.ID and keep only matching pairs (inner match). 6) When filtering for patients diagnosed with 'RA': use T1.Diagnosis = 'RA' exactly as specified. 7) When filtering for patients within UN normal index: use T2.UN < 30 to identify patients with UN values below 30. 8) When selecting patient records: use DISTINCT to ensure each patient appears only once in results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, birthday FROM patients WHERE diagnosis = 'RA' AND un_normal_index = 'within'",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'RA' AND T2.UN < 30"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'RA' AND T2.UN < 30"
        ],
        "amend_res": 1
    },
    "160": {
        "db_id": "financial",
        "question": "Among the weekly issuance accounts, how many have a loan of under 200000?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000",
        "amends": [
            "Do select `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific non-null values. Do use `FROM loan AS T1 INNER JOIN account AS T2` instead of `FROM weekly_issuance_accounts` to properly join the loan and account tables. Do add join condition `ON T1.account_id = T2.account_id` instead of omitting it to establish the correct relationship between tables. Do add filter `WHERE T2.frequency = 'POPLATEK TYDNE'` instead of omitting it to restrict results to weekly accounts. Do use filter `T1.amount < 200000` instead of `loan_amount > 200000` to find loans below the threshold rather than above it. The amended query now correctly counts weekly accounts with loans under 200000 instead of counting all accounts with loans over 200000 from a non-existent table."
        ],
        "rules": [
            "1) When counting entities from the database: use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"weekly issuance accounts\": this means accounts where T2.frequency = 'POPLATEK TYDNE' exactly. 3) When combining loan and account tables: link rows where T1.account_id = T2.account_id and keep only matching pairs (inner match). 4) When the question asks for loans \"under 200000\": use T1.amount < 200000 to find amounts below the threshold. 5) When answering about \"how many have a loan of under 200000\": make sure the output order: count of accounts with weekly frequency and loan amount under 200000."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM weekly_issuance_accounts WHERE loan_amount > 200000;",
            "SELECT COUNT(T1.account_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.amount < 200000"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM loan T1\nINNER JOIN account T2 ON T1.account_id = T2.account_id\nWHERE T2.frequency = 'POPLATEK TYDNE'\nAND T1.amount < 200000"
        ],
        "amend_res": 1
    },
    "629": {
        "db_id": "codebase_community",
        "question": "Calculate the ratio of votes in 2010 and 2011.",
        "ground_truth": "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) FROM votes",
        "amends": [
            "Do use `SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0))` and `SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0))` instead of separate subqueries with `COUNT(*)` and `WHERE year` filters. Do reference `CreationDate` column instead of non-existent `year` column. Do apply `STRFTIME('%Y', CreationDate)` for year extraction instead of assuming a `year` column exists. Do cast the numerator as `REAL` instead of performing integer division. Do remove the unnecessary `LIMIT 1` and column aliases instead of keeping them. Do perform the calculation in a single SELECT expression instead of using multiple correlated subqueries. The amended query now correctly handles year extraction from date values and prevents integer division issues."
        ],
        "rules": [
            "1) When the question asks about votes in specific years: extract the year from \"CreationDate\" column using STRFTIME('%Y', CreationDate) instead of assuming a separate \"year\" column exists. 2) When calculating counts for specific years: use SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) for 2010 votes and SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) for 2011 votes instead of separate subqueries. 3) When computing a ratio between two counts: cast the numerator as REAL to prevent integer division issues. 4) When the question asks for a single ratio result: do not use LIMIT 1 or unnecessary column aliases, perform the calculation in a single SELECT expression."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM votes WHERE year = 2010) AS votes_2010,\n    (SELECT COUNT(*) FROM votes WHERE year = 2011) AS votes_2011,\n    (SELECT COUNT(*) FROM votes WHERE year = 2010) / (SELECT COUNT(*) FROM votes WHERE year = 2011) AS ratio\nFROM votes\nLIMIT 1;",
            "SELECT \n    CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) \nFROM votes"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(IIF(STRFTIME('%Y', CreationDate) = '2010', 1, 0)) AS REAL) / SUM(IIF(STRFTIME('%Y', CreationDate) = '2011', 1, 0)) AS ratio FROM votes WHERE STRFTIME('%Y', CreationDate) IN ('2010', '2011')"
        ],
        "amend_res": 1
    },
    "66": {
        "db_id": "california_schools",
        "question": "Between 1/1/2000 to 12/31/2005, how many directly funded schools opened in the county of Stanislaus?",
        "ground_truth": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded'",
        "amends": [
            "Do count `School` instead of `*` to count non-null values. Do use `strftime('%Y', OpenDate)` to extract year instead of `opening_date BETWEEN` with full date ranges. Do reference `County` instead of `county` and `FundingType` instead of `funding_type` with proper case sensitivity. Do use exact value 'Directly funded' instead of 'direct' for the funding type filter. The amended query now correctly counts schools in Stanislaus county that opened between 2000-2005 with direct funding, matching the intended behavior."
        ],
        "rules": [
            "1) When counting schools: count non-null values of \"School\" column instead of all rows. 2) When filtering by opening date between 1/1/2000 to 12/31/2005: extract year using strftime('%Y', OpenDate) instead of full date range comparison. 3) When referencing county: use exact column name \"County\" with proper case sensitivity instead of lowercase 'county'. 4) When referencing funding type: use exact column name \"FundingType\" with proper case sensitivity instead of lowercase 'funding_type'. 5) When filtering for directly funded schools: use exact literal value 'Directly funded' instead of 'direct'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM schools \nWHERE county = 'Stanislaus' \nAND opening_date BETWEEN '2000-01-01' AND '2005-12-31' \nAND funding_type = 'direct'",
            "SELECT COUNT(School) FROM schools WHERE County = 'Stanislaus' AND strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND FundingType = 'Directly funded'"
        ],
        "rule_sql": [
            "SELECT COUNT(School) FROM schools WHERE strftime('%Y', OpenDate) BETWEEN '2000' AND '2005' AND County = 'Stanislaus' AND FundingType = 'Directly funded' AND School IS NOT NULL"
        ],
        "amend_res": 1
    },
    "842": {
        "db_id": "superhero",
        "question": "Calculate the average height of all neutral superheroes.",
        "evidence": "",
        "ground_truth": "SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
        "amends": [
            "Do reference `superhero` table as `T1` instead of `superheroes`. Do join with `alignment` table as `T2` on `T1.alignment_id = T2.id` instead of directly filtering on a column from the main table. Do filter on `T2.alignment = 'Neutral'` instead of `alignment = 'good'`. Do aggregate `T1.height_cm` instead of `height`. The amended query now correctly uses proper table relationships through a join and filters based on the joined table's values, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average height of all neutral superheroes\": make sure the output order: average height. 2) When the question mentions \"neutral superheroes\": \"neutral\" actually means \"T2.alignment = 'Neutral'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.alignment_id = T2.id; keep only matching pairs (inner match). 4) When calculating average height: aggregate T1.height_cm instead of height. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM superheroes WHERE alignment = 'good';",
            "SELECT AVG(T1.height_cm) FROM superhero AS T1 JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'"
        ],
        "rule_sql": [
            "SELECT AVG(s.height_cm) AS \"average height\" FROM superhero s INNER JOIN alignment a ON s.alignment_id = a.id WHERE a.alignment = 'Neutral'"
        ],
        "amend_res": 1
    },
    "1069": {
        "db_id": "european_football_2",
        "question": "Which football player has the shortest height?",
        "ground_truth": "SELECT player_name FROM player ORDER BY height ASC LIMIT 1",
        "amends": [
            "Do select `player_name` instead of `name` and use `ASC` ordering instead of `DESC` for the height column. Do reference the `player` table instead of `players` as the data source. The amended query now correctly retrieves the shortest player's name from the player table."
        ],
        "rules": [
            "1) When the question asks about football players: use the \"player\" table instead of \"players\" as the data source. 2) When selecting the player's name: use the exact column token \"player_name\" instead of \"name\". 3) When finding the shortest height: order by the height column in ascending (ASC) direction instead of descending (DESC). 4) When the question asks for \"which football player\": return only the top 1 result after ordering by height in ascending order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY height DESC LIMIT 1;",
            "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player ORDER BY height ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1179": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient who was diagnosed with SLE on 1994/2/19, what was his/her anti-Cardiolipin antibody concentration status on 1993/11/12?",
        "ground_truth": "SELECT `aCL IgA`, `aCL IgG`, `aCL IgM` FROM Examination WHERE ID IN ( SELECT ID FROM Patient WHERE Diagnosis = 'SLE' AND Description = '1994-02-19' ) AND `Examination Date` = '1993-11-12'",
        "amends": [
            "Do select specific antibody columns `aCL IgA`, `aCL IgG`, `aCL IgM` instead of the generalized `anti_cardiolipin_antibody_concentration_status`. Do query from the `Examination` table instead of `patient_diagnoses`. Do use a subquery to filter patients with `Diagnosis = 'SLE'` and `Description = '1994-02-19'` instead of applying these filters directly in the WHERE clause. Do reference `Examination Date` instead of `test_date` for the date filter. Do use proper date format '1993-11-12' instead of '1993/11/12' and '1994-02-19' instead of '1994/2/19'. The amended query now correctly retrieves specific antibody test results from the Examination table for SLE patients diagnosed on the specified date, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about anti-Cardiolipin antibody concentration status: select the specific antibody columns \"aCL IgA\", \"aCL IgG\", and \"aCL IgM\" instead of a generalized column. 2) When querying for patient examination data: use the \"Examination\" table instead of patient_diagnoses tables. 3) When filtering for patients diagnosed with SLE on a specific date: use a subquery to filter patients where \"Diagnosis\" = 'SLE' and \"Description\" = '1994-02-19' instead of applying these filters directly in the main WHERE clause. 4) When filtering by examination date: reference \"Examination Date\" instead of test_date and use the proper date format '1993-11-12' instead of '1993/11/12'. 5) When specifying date values: always use the format 'YYYY-MM-DD' with hyphens instead of slashes (e.g., '1994-02-19' instead of '1994/2/19')."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT anti_cardiolipin_antibody_concentration_status \nFROM patient_diagnoses \nWHERE diagnosis = 'SLE' \nAND diagnosis_date = '1994/2/19' \nAND test_date = '1993/11/12';",
            "SELECT e.`aCL IgA`, e.`aCL IgG`, e.`aCL IgM`\nFROM Examination e\nWHERE e.`Examination Date` = '1993-11-12'\nAND e.ID IN (\n    SELECT p.ID\n    FROM Patient p\n    WHERE p.Diagnosis = 'SLE' \n    AND p.Description = '1994-02-19'\n)"
        ],
        "rule_sql": [
            "SELECT e.\"aCL IgA\", e.\"aCL IgG\", e.\"aCL IgM\"\nFROM Examination e\nWHERE e.ID IN (\n    SELECT p.ID\n    FROM Patient p\n    WHERE p.Diagnosis = 'SLE' AND p.Description = '1994-02-19'\n)\nAND e.\"Examination Date\" = '1993-11-12';"
        ],
        "amend_res": 1
    },
    "1099": {
        "db_id": "european_football_2",
        "question": "Which foot is preferred by Abdou Diallo?",
        "ground_truth": "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'",
        "amends": [
            "Do add `DISTINCT` modifier instead of omitting it to eliminate duplicate results. Do change the source table to `Player AS t1` instead of `players` and add `INNER JOIN` with `Player_Attributes AS t2` instead of querying a single table. Do use the join condition `t1.player_api_id = t2.player_api_id` instead of no join condition. Do change the column reference to `t2.preferred_foot` instead of `preferred_foot` to specify the joined table source. Do change the filter condition to `t1.player_name = 'Abdou Diallo'` instead of `name = 'Abdou Diallo'` to use the correct column name from the Player table. The amended query now correctly retrieves the preferred foot from the Player_Attributes table joined with Player table using the proper relationship."
        ],
        "rules": [
            "1) When answering about a player's preferred foot: make sure the output order: preferred_foot. 2) When the question mentions \"Abdou Diallo\": \"Abdou Diallo\" actually means \"t1.player_name = 'Abdou Diallo'\" in schema. 3) When combining Player table (t1) and Player_Attributes table (t2): link rows where t1.player_api_id = t2.player_api_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When retrieving preferred_foot information: use t2.preferred_foot instead of t1.preferred_foot to specify the correct table source. 5) When eliminating duplicate results: add DISTINCT modifier to ensure unique values are returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT preferred_foot FROM players WHERE name = 'Abdou Diallo';",
            "SELECT DISTINCT t2.preferred_foot FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t2.preferred_foot FROM Player t1 INNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t1.player_name = 'Abdou Diallo'"
        ],
        "amend_res": 1
    },
    "1419": {
        "db_id": "student_club",
        "question": "What is the category of event which was taken place in 2020-03-24T12:00:00?",
        "ground_truth": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'",
        "amends": [
            "Do select `T2.category` from the `budget` table instead of `category` from the `events` table. Do join `event AS T1` and `budget AS T2` with an `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only the `events` table. Do filter on `T1.event_date = '2020-03-24T12:00:00'` instead of `date = '2020-03-24T12:00:00'` to use the correct date column from the joined table. The amended query now correctly retrieves category information from the budget table through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"category of event\": make sure the output order: T2.category 2) When the question mentions \"event\": use table \"event AS T1\" for event information and \"budget AS T2\" for category information 3) When combining event and budget tables: link rows where T1.event_id = T2.link_to_event and keep only matching pairs (inner match) 4) When filtering by date \"2020-03-24T12:00:00\": use T1.event_date = '2020-03-24T12:00:00' exactly as specified"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT category FROM events WHERE date = '2020-03-24T12:00:00';",
            "SELECT T2.category \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_date = '2020-03-24T12:00:00'"
        ],
        "rule_sql": [
            "SELECT T2.category \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_date = '2020-03-24T12:00:00'"
        ],
        "amend_res": 1
    },
    "1101": {
        "db_id": "european_football_2",
        "question": "What is the average number of goals made by Parma as the away team while playing in Italy?",
        "ground_truth": "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) FROM \"Match\" AS T1 INNER JOIN TEAM AS T2 ON T1.away_team_api_id = T2.team_api_id INNER JOIN Country AS T3 ON T1.country_id = T3.id WHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `Match AS T1` with `TEAM AS T2` on `T1.away_team_api_id = T2.team_api_id` instead of filtering directly on team name. Do join with `Country AS T3` on `T1.country_id = T3.id` instead of filtering directly on country name. Do filter on `T2.team_long_name = 'Parma'` instead of `away_team = 'Parma'`. Do filter on `T3.name = 'Italy'` instead of `country = 'Italy'`. Do calculate average using `CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id)` instead of `AVG(home_goals)`. Do reference `away_team_goal` instead of `home_goals` for the correct metric. The amended query now properly joins through foreign keys to resolve team and country names while calculating the correct average of away team goals."
        ],
        "rules": [
            "1) When answering about average goals made by Parma as away team in Italy: use explicit table aliases T1 for Match, T2 for Team, and T3 for Country. 2) When combining Match (T1) and Team (T2): link rows where T1.away_team_api_id = T2.team_api_id and keep only matching pairs (inner match). 3) When combining Match (T1) and Country (T3): link rows where T1.country_id = T3.id and keep only matching pairs (inner match). 4) When filtering for Parma team: use T2.team_long_name = 'Parma' instead of direct team name filtering. 5) When filtering for Italy country: use T3.name = 'Italy' instead of direct country name filtering. 6) When calculating average away team goals: compute CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) instead of using AVG function. 7) When referencing goals metric: use T1.away_team_goal for away team goals instead of home_goals."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(home_goals) FROM matches WHERE away_team = 'Parma' AND country = 'Italy';",
            "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) AS avg_away_goals\nFROM Match AS T1\nJOIN Team AS T2 ON T1.away_team_api_id = T2.team_api_id\nJOIN Country AS T3 ON T1.country_id = T3.id\nWHERE T2.team_long_name = 'Parma' AND T3.name = 'Italy'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T1.away_team_goal) AS REAL) / COUNT(T1.id) AS average_goals\nFROM Match T1\nINNER JOIN Team T2 ON T1.away_team_api_id = T2.team_api_id\nINNER JOIN Country T3 ON T1.country_id = T3.id\nWHERE T2.team_long_name = 'Parma'\nAND T3.name = 'Italy'"
        ],
        "amend_res": 1
    },
    "849": {
        "db_id": "formula_1",
        "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
        "ground_truth": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "amends": [
            "Do select `T1.url` instead of `introduction`. Do add `DISTINCT` instead of omitting it. Do change the FROM source to `circuits AS T1` instead of only `races`. Do add `INNER JOIN races AS T2` instead of omitting the join. Do use join condition `T2.circuitID = T1.circuitId` instead of no join condition. Do move the filter to `T1.name = 'Circuit de Barcelona-Catalunya'` instead of `circuit_name = 'Circuit de Barcelona-Catalunya'`. The amended query now correctly retrieves circuit URLs by joining circuits and races tables and filtering on the circuit name."
        ],
        "rules": [
            "1) When answering about \"where to find introduction of races\": make sure the output column is T1.url instead of introduction. 2) When the question mentions \"races held on Circuit de Barcelona-Catalunya\": this requires joining circuits AS T1 with races AS T2 using the condition T2.circuitID = T1.circuitId. 3) When filtering for a specific circuit: use T1.name = 'Circuit de Barcelona-Catalunya' exactly as specified. 4) When retrieving URLs from the circuits table: ensure DISTINCT is applied to avoid duplicate results. 5) When combining tables for shared entities: perform an inner join where T2.circuitID equals T1.circuitId to keep only matching pairs."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT introduction FROM races WHERE circuit_name = 'Circuit de Barcelona-Catalunya';",
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        ],
        "amend_res": 1
    },
    "179": {
        "db_id": "financial",
        "question": "How much, in total, did client number 617 pay for all of the transactions in 1998?",
        "evidence": "",
        "ground_truth": "SELECT SUM(T3.amount) FROM client AS T1 INNER JOIN disp AS T4 ON T1.client_id = T4.client_id INNER JOIN account AS T2 ON T4.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE STRFTIME('%Y', T3.date)= '1998' AND T1.client_id = 617",
        "amends": [
            "Do join multiple tables starting with `client AS T1` instead of querying only `transactions`. Do use `INNER JOIN disp AS T4` on `T1.client_id = T4.client_id` instead of missing this relationship. Do add `INNER JOIN account AS T2` on `T4.account_id = T2.account_id` instead of omitting the account table. Do use `INNER JOIN trans AS T3` on `T2.account_id = T3.account_id` instead of directly accessing transactions. Do reference `SUM(T3.amount)` with table alias instead of `SUM(amount)` without qualification. Do use `STRFTIME('%Y', T3.date)= '1998'` for year extraction instead of `year = 1998`. Do filter on `T1.client_id = 617` with table alias instead of `client_id = 617` without qualification. The amended query now correctly joins the client-disposition-account-transaction chain to match the intended logic."
        ],
        "rules": [
            "1) When answering about client payments: start with client as T1 and join through disposition, account, and transaction tables using the exact key relationships T1.client_id = T4.client_id, T4.account_id = T2.account_id, and T2.account_id = T3.account_id. 2) When filtering by client number 617: use T1.client_id = 617 with the exact table alias. 3) When filtering transactions from year 1998: extract year using STRFTIME('%Y', T3.date) = '1998' with exact function and literal format. 4) When summing transaction amounts: use SUM(T3.amount) with exact table alias qualification. 5) When combining tables for this query: perform inner joins only to keep matching pairs across all four tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM transactions WHERE client_id = 617 AND year = 1998;",
            "SELECT SUM(T3.amount) AS total_payments\nFROM client AS T1\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T2 ON T4.account_id = T2.account_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.client_id = 617\nAND STRFTIME('%Y', T3.date) = '1998'"
        ],
        "rule_sql": [
            "SELECT SUM(T3.amount) AS total_payments\nFROM client AS T1\nINNER JOIN disp AS T4 ON T1.client_id = T4.client_id\nINNER JOIN account AS T2 ON T4.account_id = T2.account_id\nINNER JOIN trans AS T3 ON T2.account_id = T3.account_id\nWHERE T1.client_id = 617\nAND STRFTIME('%Y', T3.date) = '1998'"
        ],
        "amend_res": 1
    },
    "1345": {
        "db_id": "student_club",
        "question": "How many majors are there in \"College of Humanities and Social Sciences\"?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "amends": [
            "Do select `COUNT(major_name)` from the `major` table instead of `COUNT(*)` from the `colleges` table. Do filter on `college = 'College of Humanities and Social Sciences'` instead of `college_name = 'College of Humanities and Social Sciences'` to correctly reference the college column in the major table. The amended query now correctly counts majors within the specified college rather than attempting to count colleges themselves, matching the intended behavior of querying the major table for college-specific data."
        ],
        "rules": [
            "1) When counting majors: use COUNT(\"major_name\") from the \"major\" table instead of COUNT(*) from the \"colleges\" table. 2) When filtering for \"College of Humanities and Social Sciences\": use the exact literal 'College of Humanities and Social Sciences' with the column \"college\" in the \"major\" table instead of \"college_name\" in the \"colleges\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM colleges WHERE college_name = 'College of Humanities and Social Sciences';",
            "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences'"
        ],
        "rule_sql": [
            "SELECT COUNT(major_name) FROM major WHERE college = 'College of Humanities and Social Sciences';"
        ],
        "amend_res": 1
    },
    "747": {
        "db_id": "superhero",
        "question": "What is the total number of superheroes without full name?",
        "ground_truth": "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL",
        "amends": [
            "Do count `id` instead of `*` to exclude null values from the count. Do reference table `superhero` instead of `superheroes` to use the correct table name. Do remove the condition `OR full_name = ''` instead of keeping it to only count records where the full_name is explicitly NULL. The amended query now correctly counts records with null full_name values in the specified table."
        ],
        "rules": [
            "1) When counting superheroes: use the \"id\" column from table \"superhero\" instead of counting all columns. 2) When identifying superheroes without full name: only count records where \"full_name\" is explicitly NULL, do not include empty strings. 3) When referencing the superhero table: use the exact table name \"superhero\" instead of \"superheroes\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE full_name IS NULL OR full_name = '';",
            "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(id) FROM superhero WHERE full_name IS NULL;"
        ],
        "amend_res": 1
    },
    "19": {
        "db_id": "california_schools",
        "question": "What is the phone number of the school that has the highest average score in Math?",
        "evidence": "",
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrMath DESC LIMIT 1",
        "amends": [
            "Do select `T1.Phone` instead of `phone_number` and join `schools AS T1` with `satscores AS T2` using `INNER JOIN` on `T1.CDSCode = T2.cds` instead of querying only the schools table. Do order by `T2.AvgScrMath DESC` instead of `math_score DESC` to use the correct column from the joined table. The amended query now properly retrieves the phone number from the school with the highest math score by joining the relevant tables and using the correct score column."
        ],
        "rules": [
            "1) When answering about \"phone number of the school with highest average math score\": make sure the output order: T1.Phone. 2) When the question mentions \"school\": use table \"schools AS T1\" with exact alias T1. 3) When the question mentions \"average score in Math\": use column T2.AvgScrMath from table \"satscores AS T2\". 4) When combining T1 and T2 for shared entities: link rows where T1.CDSCode = T2.cds exactly as shown; keep only matching pairs (inner match). 5) When the question asks for \"highest average score\": rank rows by T2.AvgScrMath in descending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number FROM schools ORDER BY math_score DESC LIMIT 1;",
            "SELECT T1.Phone\nFROM schools AS T1\nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds\nORDER BY T2.AvgScrMath DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.Phone\nFROM schools AS T1\nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds\nORDER BY T2.AvgScrMath DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1348": {
        "db_id": "student_club",
        "question": "For all the budgets for \"November Meeting\", how many of them had exceeded the budget?",
        "ground_truth": "SELECT COUNT(T2.event_id) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'November Meeting' AND T1.remaining < 0",
        "amends": [
            "Do select `COUNT(T2.event_id)` instead of `COUNT(*)` to count specific event IDs rather than all rows. Do use table aliases `budget AS T1` and `event AS T2` instead of a single `budgets` table to properly reference the schema. Do perform an `INNER JOIN` on `T1.link_to_event = T2.event_id` instead of querying a single table to establish the correct relationship between budget and event data. Do filter on `T2.event_name = 'November Meeting'` instead of the original table's event_name to reference the correct table. Do check `T1.remaining < 0` instead of `actual_cost < budget_amount` to use the proper column name and condition for identifying budget deficits. The amended query now correctly counts events with negative remaining budget amounts for the specified meeting."
        ],
        "rules": [
            "1) When answering about budgets for \"November Meeting\": make sure the output order: count of events with exceeded budget. 2) When the question mentions \"budgets\": use table \"budget AS T1\" and \"event AS T2\" with aliases exactly as specified. 3) When combining budget and event tables: link rows where T1.link_to_event = T2.event_id using inner match only. 4) When filtering for \"November Meeting\": use T2.event_name = 'November Meeting' exactly as written with proper case and quotes. 5) When checking for exceeded budget: use T1.remaining < 0 to identify budget deficits. 6) When counting events with exceeded budget: count using T2.event_id as the canonical key rather than all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM budgets WHERE event_name = 'November Meeting' AND actual_cost < budget_amount;",
            "SELECT COUNT(T2.event_id) \nFROM budget AS T1 \nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id \nWHERE T2.event_name = 'November Meeting' AND T1.remaining < 0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.event_id) \nFROM budget AS T1 \nINNER JOIN event AS T2 ON T1.link_to_event = T2.event_id \nWHERE T2.event_name = 'November Meeting' \nAND T1.remaining < 0"
        ],
        "amend_res": 1
    },
    "1282": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the top three patients' birthdays with the highest glutamic pylvic transaminase in the normal range.",
        "ground_truth": "SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 ORDER BY T2.GPT DESC LIMIT 3",
        "amends": [
            "Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the `patients` table. Do add `WHERE T2.GPT < 60` filter instead of omitting any condition on laboratory values. Do change the selected column to `T1.Birthday` instead of `birthday` from the base table. Do change the sort column to `T2.GPT DESC` instead of `glutamic_pylvic_transaminase DESC` using the joined table's column. The amended query now correctly joins patient and laboratory data, filters for GPT values below 60, and returns birthdays ordered by GPT descending, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patients' birthdays with highest glutamic pylvic transaminase: make sure the output order: T1.Birthday\n2) When the question mentions \"glutamic pylvic transaminase\": \"glutamic pylvic transaminase\" actually means \"GPT in schema\" from table T2\n3) When the question mentions \"top three\" and \"highest\": rank rows by T2.GPT in descending direction and keep the first 3 rows\n4) When the question mentions \"normal range\": use the condition T2.GPT < 60 to filter for values in the normal range\n5) When combining patients table T1 and Laboratory table T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)\n6) When selecting patient birthday: use T1.Birthday from the base table instead of unqualified birthday"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT birthday FROM patients ORDER BY glutamic_pylvic_transaminase DESC LIMIT 3;",
            "SELECT T1.Birthday\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.GPT < 60\nORDER BY T2.GPT DESC\nLIMIT 3"
        ],
        "rule_sql": [
            "SELECT T1.Birthday\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.GPT < 60\nORDER BY T2.GPT DESC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "60": {
        "db_id": "california_schools",
        "question": "What are the websites for all the partially virtual chartered schools located in San Joaquin?",
        "ground_truth": "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1",
        "amends": [
            "Do reference column `County` instead of `location` in the WHERE clause filter for San Joaquin. Do reference column `Virtual` with value 'P' instead of `type` with value 'virtual' to identify virtual schools. Do reference column `Charter` with value 1 instead of `status` with value 'chartered' to filter for charter schools. Do select column `Website` instead of `website` to match the correct column name. The amended query now correctly filters for virtual charter schools in San Joaquin County using the appropriate column names and values."
        ],
        "rules": [
            "1) When the question mentions \"located in San Joaquin\": use column \"County\" with exact value 'San Joaquin' for filtering. 2) When the question mentions \"partially virtual\": use column \"Virtual\" with exact value 'P' for filtering. 3) When the question mentions \"chartered schools\": use column \"Charter\" with exact value 1 for filtering. 4) When the question asks for \"websites\": select column \"Website\" as the output. 5) When filtering for multiple conditions: apply all filters simultaneously (County = 'San Joaquin', Virtual = 'P', and Charter = 1)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website FROM schools WHERE location = 'San Joaquin' AND type = 'virtual' AND status = 'chartered';",
            "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1;"
        ],
        "rule_sql": [
            "SELECT Website FROM schools WHERE County = 'San Joaquin' AND Virtual = 'P' AND Charter = 1;"
        ],
        "amend_res": 1
    },
    "637": {
        "db_id": "codebase_community",
        "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
        "ground_truth": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
        "amends": [
            "Do use `INNER JOIN` with `users AS T1` instead of omitting the `postHistory` table entirely. Do join `postHistory AS T2` on `T1.Id = T2.UserId` instead of directly joining `tags` to `posts`. Do join `posts AS T3` on `T3.Id = T2.PostId` instead of joining `tags` to `posts` directly. Do select `T3.Tags` instead of `t.name` from the wrong table. Do remove `DISTINCT` instead of keeping it. Do filter on `T1.DisplayName = 'Mark Meckes'` instead of `u.display_name = 'Mark Meckes'`. Do filter on `T3.CommentCount = 0` instead of `p.comment_count = 0`. The amended query now correctly retrieves tags from posts through the proper relationship chain via postHistory instead of attempting to join tags directly to posts and users."
        ],
        "rules": [
            "1) When answering about tags used by a specific user in posts without comments: make sure the output order: T3.Tags\n2) When the question mentions \"Mark Meckes\": \"Mark Meckes\" actually means \"T1.DisplayName = 'Mark Meckes'\" in schema\n3) When the question mentions \"doesn't have comments\": \"doesn't have comments\" actually means \"T3.CommentCount = 0\" in schema\n4) When combining T1 (users) and T2 (postHistory) for shared entities: link rows where T1.Id = T2.UserId and keep only matching pairs (inner match)\n5) When combining T2 (postHistory) and T3 (posts) for shared entities: link rows where T3.Id = T2.PostId and keep only matching pairs (inner match)\n6) When selecting tags from posts: use T3.Tags instead of tags from a separate tags table\n7) When retrieving all tags without duplicates: do not use DISTINCT to remove duplicates"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT t.name \nFROM tags t \nJOIN posts p ON t.id = p.id \nJOIN users u ON p.owner_user_id = u.id \nWHERE u.display_name = 'Mark Meckes' \nAND p.comment_count = 0",
            "SELECT T3.Tags \nFROM users AS T1 \nINNER JOIN postHistory AS T2 ON T1.Id = T2.UserId \nINNER JOIN posts AS T3 ON T3.Id = T2.PostId \nWHERE T1.DisplayName = 'Mark Meckes' \nAND T3.CommentCount = 0"
        ],
        "rule_sql": [
            "SELECT T3.Tags\nFROM users T1\nINNER JOIN postHistory T2 ON T1.Id = T2.UserId\nINNER JOIN posts T3 ON T3.Id = T2.PostId\nWHERE T1.DisplayName = 'Mark Meckes'\nAND T3.CommentCount = 0\nORDER BY T3.Tags"
        ],
        "amend_res": 1
    },
    "591": {
        "db_id": "codebase_community",
        "question": "How many users are awarded with supporter badge during year 2011?",
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE STRFTIME('%Y', Date) = '2011' AND Name = 'Supporter'",
        "amends": [
            "Do select `COUNT(Id)` from the `badges` table instead of `COUNT(*)` from `users`. Do use `STRFTIME('%Y', Date) = '2011'` to extract the year from a date column instead of a simple `year = 2011` filter. Do filter for `Name = 'Supporter'` instead of `badge = 'supporter'`. The amended query now correctly counts supporter badges from 2011 by querying the appropriate table with proper date extraction and case-sensitive filtering, matching the intended behavior."
        ],
        "rules": [
            "1) When counting users awarded with supporter badges: count the number of rows in the badges table using the exact token \"Id\" as the counting key instead of counting all rows. 2) When filtering for supporter badges: use the exact literal 'Supporter' (with capital S) for the Name column instead of 'supporter'. 3) When filtering for year 2011: extract the year from the Date column using STRFTIME('%Y', Date) and compare to the exact string '2011' instead of using a numeric year column. 4) When answering about users awarded with badges: query the badges table directly instead of the users table, as badge awards are stored in the badges table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE badge = 'supporter' AND year = 2011;",
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Supporter' AND STRFTIME('%Y', Date) = '2011'"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM badges WHERE Name = 'Supporter' AND STRFTIME('%Y', Date) = '2011'"
        ],
        "amend_res": 1
    },
    "594": {
        "db_id": "codebase_community",
        "question": "Which user created post ID 1 and what is the reputation of this user?",
        "evidence": "",
        "ground_truth": "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1",
        "amends": [
            "Do select `T2.Id` and `T2.Reputation` instead of `users.name` and `users.reputation`. Do join from `comments AS T1` instead of `posts` and use `INNER JOIN users AS T2` instead of `JOIN users`. Do use the join condition `T1.UserId = T2.Id` instead of `posts.user_id = users.id`. Do filter on `T1.PostId = 1` instead of `posts.id = 1`. The amended query now correctly retrieves user information from comments rather than posts for the specified post ID."
        ],
        "rules": [
            "1) When the question asks about a user who created a post: use the comments table (T1) instead of the posts table to find user information. 2) When joining tables for user information: use INNER JOIN users AS T2 with join condition T1.UserId = T2.Id. 3) When filtering for post ID 1: use T1.PostId = 1 instead of posts.id = 1. 4) When selecting user information: select T2.Id and T2.Reputation instead of users.name and users.reputation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT users.name, users.reputation FROM posts JOIN users ON posts.user_id = users.id WHERE posts.id = 1",
            "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1"
        ],
        "rule_sql": [
            "SELECT T2.Id, T2.Reputation FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.PostId = 1 LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1436": {
        "db_id": "student_club",
        "question": "Please provide links to events for members who have paid more than 50 dollar.",
        "ground_truth": "SELECT DISTINCT T3.link_to_event FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member WHERE T1.cost > 50",
        "amends": [
            "Do use `DISTINCT T3.link_to_event` instead of `event_link` without distinct. Do join three tables `expense AS T1 INNER JOIN member AS T2` and `INNER JOIN attendance AS T3` instead of querying only the `members` table. Do use join conditions `T1.link_to_member = T2.member_id` and `T2.member_id = T3.link_to_member` instead of no joins. Do filter on `T1.cost > 50` instead of `payment_amount > 50` from the wrong table. The amended query now correctly retrieves distinct event links by joining expense, member, and attendance tables with proper relationships and filtering on the cost field from the expense table."
        ],
        "rules": [
            "1) When answering about \"links to events for members who have paid more than 50 dollar\": make sure the output order: T3.link_to_event. 2) When the question mentions \"paid more than 50 dollar\": \"paid\" actually means \"cost > 50\" in the expense table (T1.cost > 50). 3) When combining tables for this query: link T1 (expense) and T2 (member) where T1.link_to_member = T2.member_id, then link T2 and T3 (attendance) where T2.member_id = T3.link_to_member, keeping only matching pairs (inner match). 4) When retrieving event links: use DISTINCT T3.link_to_event to get unique values. 5) When filtering payment amounts: use T1.cost > 50 instead of payment_amount from the members table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT event_link FROM members WHERE payment_amount > 50",
            "SELECT DISTINCT T3.link_to_event\nFROM expense AS T1\nINNER JOIN member AS T2 ON T1.link_to_member = T2.member_id\nINNER JOIN attendance AS T3 ON T2.member_id = T3.link_to_member\nWHERE T1.cost > 50"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.link_to_event\nFROM expense T1\nINNER JOIN member T2 ON T1.link_to_member = T2.member_id\nINNER JOIN attendance T3 ON T2.member_id = T3.link_to_member\nWHERE T1.cost > 50\nORDER BY T3.link_to_event;"
        ],
        "amend_res": 1
    },
    "762": {
        "db_id": "superhero",
        "question": "Which power do superheroes have the most of?",
        "ground_truth": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
        "amends": [
            "Do reference `T2.power_name` from the `superpower` table instead of `power` from `superheroes`. Do join `hero_power AS T1` with `superpower AS T2` on `T1.power_id = T2.id` instead of querying a single table. Do aggregate by `T2.power_name` instead of `power`. Do count `T1.hero_id` instead of using `COUNT(*)` to count actual hero associations. Do order by `COUNT(T1.hero_id)` instead of the alias `count`. The amended query now correctly identifies the most common superpower by counting hero associations through the junction table rather than assuming a direct power column in the heroes table.",
            "Do remove `COUNT(T1.hero_id) AS hero_count` from the SELECT list instead of including it, as only the `power_name` is needed for the final result. Do use `INNER JOIN` explicitly instead of the implicit `JOIN` syntax, though both are functionally equivalent. The GROUP BY clause remains `T2.power_name` and ORDER BY uses `COUNT(T1.hero_id) DESC` with LIMIT 1 unchanged, correctly identifying the most common power. The amended query now matches RIGHT_SQL's behavior by returning only the power name with the highest hero count."
        ],
        "rules": [
            "1) When the question asks about \"power\" that superheroes have: \"power\" actually means \"T2.power_name\" from the superpower table. 2) When combining hero_power (T1) and superpower (T2) tables: link rows where T1.power_id equals T2.id exactly and keep only matching pairs (inner match). 3) When counting superhero associations with powers: count the number of unique T1.hero_id values instead of counting all rows. 4) When grouping by power: organize results by T2.power_name and compute the count per power group. 5) When the question asks for \"the most\": rank power groups by the count of T1.hero_id in descending order and keep only the top 1 result.",
            "1) When answering about \"which power do superheroes have the most of\": make sure the output order includes only \"T2.power_name\" without any count columns. 2) When counting superheroes per power: compute the number of rows using the canonical key \"T1.hero_id\" for counting. 3) When combining tables \"hero_power\" as T1 and \"superpower\" as T2: link rows where \"T1.power_id = T2.id\" and keep only matching pairs (inner match). 4) When the question asks for \"the most\": rank rows by the count of \"T1.hero_id\" in descending order and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT power, COUNT(*) as count FROM superheroes GROUP BY power ORDER BY count DESC LIMIT 1;",
            "SELECT T2.power_name, COUNT(T1.hero_id) AS hero_count\nFROM hero_power AS T1\nJOIN superpower AS T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(T1.hero_id) DESC\nLIMIT 1;",
            "SELECT T2.power_name\nFROM hero_power AS T1\nINNER JOIN superpower AS T2 ON T1.power_id = T2.id\nGROUP BY T2.power_name\nORDER BY COUNT(T1.hero_id) DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.power_name \nFROM hero_power T1 \nINNER JOIN superpower T2 ON T1.power_id = T2.id \nGROUP BY T2.power_name \nORDER BY COUNT(DISTINCT T1.hero_id) DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "126": {
        "db_id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "ground_truth": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "amends": [
            "Do use `SUM(T1.A2 = 'Decin')` with explicit casting to `REAL` instead of `COUNT(CASE WHEN district = 'Decin' THEN 1 END)` for percentage calculation. Do join `district AS T1` with `account AS T2` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do reference `T2.date` in the `STRFTIME` filter instead of `opened_date` from a single table. Do count `account_id` instead of using `COUNT(*)` for the denominator. The amended query now correctly calculates the percentage of accounts from the Decin district opened in 1993 by properly joining the district and account tables."
        ],
        "rules": [
            "1) When calculating percentages for accounts from specific districts: join the district table (T1) with the account table (T2) using T1.district_id = T2.district_id to properly link district information to accounts. 2) When filtering accounts opened in a specific year: use STRFTIME('%Y', T2.date) = '1993' to extract the year from the account opening date. 3) When counting accounts from a specific district: use SUM(T1.A2 = 'Decin') with explicit casting to REAL for accurate percentage calculation instead of COUNT(CASE WHEN...). 4) When calculating percentage denominators: count T2.account_id instead of using COUNT(*) to ensure accurate account counting. 5) When the question asks for percentage of accounts from 'Decin' district: preserve the exact literal 'Decin' with proper case and spelling."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN district = 'Decin' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM accounts\nWHERE strftime('%Y', opened_date) = '1993';",
            "SELECT \n    (SUM(CASE WHEN T1.A2 = 'Decin' THEN 1.0 ELSE 0.0 END) / COUNT(T2.account_id)) * 100.0 AS percentage\nFROM \n    account AS T2\nJOIN \n    district AS T1 ON T1.district_id = T2.district_id\nWHERE \n    STRFTIME('%Y', T2.date) = '1993'"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CAST(d.A2 = 'Decin' AS REAL)) / COUNT(a.account_id)) * 100.0 AS percentage\nFROM \n    account a\nJOIN \n    district d ON a.district_id = d.district_id\nWHERE \n    STRFTIME('%Y', a.date) = '1993';"
        ],
        "amend_res": 1
    },
    "1041": {
        "db_id": "european_football_2",
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "ground_truth": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "amends": [
            "Do reference `t3.team_long_name` instead of `team_name` and change the sort order to `DESC` instead of `ASC`. Do join `Team AS t3` with `Team_Attributes AS t4` on `t3.team_api_id = t4.team_api_id` instead of querying a single `teams` table. Do filter on `t4.buildUpPlayDribblingClass = 'Normal'` instead of `build_up_play_dribbling_class = 'Normal'` and remove the direct `year = 2014` filter. Do use a subquery that calculates the average as `CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)` instead of `AVG(chance_creation_passing)` and filter by `SUBSTR(t2.date, 1, 4) = '2014'` instead of `year = 2014`, while also maintaining the `buildUpPlayDribblingClass = 'Normal'` condition within the subquery. The amended query now correctly matches the RIGHT_SQL's behavior.",
            "Do join `Team_Attributes AS t2` with `Team AS t1` on `t1.team_api_id = t2.team_api_id` instead of joining `Team_Attributes AS t1` with `Team_Attributes AS t2` on `t1.id = t2.id` in the subquery. Do filter by `t2.buildUpPlayDribblingClass = 'Normal'` instead of `t1.buildUpPlayDribblingClass = 'Normal'` in the subquery WHERE clause. Do remove the redundant `SUBSTR(t4.date, 1, 4) = '2014'` filter from the main query instead of keeping it, as the subquery already handles the 2014 date filtering. The amended query now correctly calculates the average chanceCreationPassing for teams with Normal buildUpPlayDribblingClass in 2014 and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about team names: use \"t3.team_long_name\" instead of \"team_name\" for the output column. 2) When ordering by chance creation passing: sort in descending order (DESC) instead of ascending order (ASC). 3) When combining team and team attributes data: join \"Team AS t3\" with \"Team_Attributes AS t4\" using \"t3.team_api_id = t4.team_api_id\" instead of querying a single table. 4) When filtering for normal build-up play dribbling class: use \"t4.buildUpPlayDribblingClass = 'Normal'\" instead of \"build_up_play_dribbling_class = 'Normal'\". 5) When filtering for year 2014: remove the direct \"year = 2014\" filter and instead use \"SUBSTR(t2.date, 1, 4) = '2014'\" for date-based filtering. 6) When calculating average chance creation passing: use \"CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\" instead of \"AVG(chance_creation_passing)\" and maintain the \"buildUpPlayDribblingClass = 'Normal'\" condition within the subquery.",
            "1) When joining Team_Attributes with Team tables: use the exact join condition t1.team_api_id = t2.team_api_id where t1 is Team and t2 is Team_Attributes. 2) When filtering for buildUpPlayDribblingClass = 'Normal' in Team_Attributes: apply the filter directly on the Team_Attributes table (t2.buildUpPlayDribblingClass = 'Normal'). 3) When calculating average chanceCreationPassing for teams with Normal build-up play dribbling class in 2014: filter by year using SUBSTR(t2.date, 1, 4) = '2014' in the subquery only, not in the main query. 4) When the question asks for teams with less than average chance creation passing: compare t4.chanceCreationPassing against the calculated average from the subquery. 5) When ordering results in descending order of chance creation passing: sort by t4.chanceCreationPassing DESC."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT team_name \nFROM teams \nWHERE build_up_play_dribbling_class = 'Normal' \n  AND year = 2014 \n  AND chance_creation_passing < (SELECT AVG(chance_creation_passing) FROM teams WHERE year = 2014) \nORDER BY chance_creation_passing ASC;",
            "SELECT t3.team_long_name\nFROM Team AS t3\nJOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE t4.buildUpPlayDribblingClass = 'Normal'\n  AND t4.chanceCreationPassing < (\n    SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\n    FROM Team_Attributes AS t1\n    JOIN Team_Attributes AS t2 ON t1.id = t2.id\n    WHERE t1.buildUpPlayDribblingClass = 'Normal'\n      AND SUBSTR(t2.date, 1, 4) = '2014'\n  )\n  AND SUBSTR(t4.date, 1, 4) = '2014'\nORDER BY t4.chanceCreationPassing DESC;",
            "SELECT t3.team_long_name\nFROM Team AS t3\nJOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE t4.buildUpPlayDribblingClass = 'Normal'\nAND t4.chanceCreationPassing < (\n    SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\n    FROM Team AS t1\n    JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\n    WHERE t2.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t2.date, 1, 4) = '2014'\n)\nORDER BY t4.chanceCreationPassing DESC;"
        ],
        "rule_sql": [
            "SELECT t3.team_long_name\nFROM Team AS t3\nJOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE t4.buildUpPlayDribblingClass = 'Normal'\nAND t4.chanceCreationPassing < (\n    SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id)\n    FROM Team AS t1\n    JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\n    WHERE t2.buildUpPlayDribblingClass = 'Normal'\n    AND SUBSTR(t2.date, 1, 4) = '2014'\n)\nORDER BY t4.chanceCreationPassing DESC;"
        ],
        "amend_res": 1
    },
    "240": {
        "db_id": "toxicology",
        "question": "List all the elements of the toxicology of the molecule \"TR004\".",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
        "amends": [
            "Do select `T.element` instead of `*` and add `DISTINCT` instead of omitting it. Do use `atom AS T` as the source instead of `molecules` and add the alias `T` instead of omitting it. Do filter on `T.molecule_id = 'TR004'` instead of `name = 'TR004'` and move the filter to the WHERE clause instead of keeping it in the same position but with corrected predicate logic. The amended query now correctly retrieves distinct elements from the atom table for the specified molecule_id, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"elements of the toxicology of the molecule 'TR004'\": make sure the output order: T.element 2) When the question mentions \"elements\": \"elements\" actually means \"element in schema\" 3) When the question mentions \"molecule 'TR004'\": \"TR004\" actually means \"molecule_id = 'TR004' in schema\" 4) When selecting from the atom table: use alias T for the atom table instead of molecules 5) When retrieving distinct elements: compute the number of unique values of the exact token T.element 6) When filtering for molecule TR004: use the exact literal 'TR004' with correct case and spacing"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE name = 'TR004';",
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.element FROM atom T WHERE T.molecule_id = 'TR004' ORDER BY T.element"
        ],
        "amend_res": 1
    },
    "447": {
        "db_id": "card_games",
        "question": "Give the code of sets have expansion commander type?",
        "ground_truth": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
        "amends": [
            "Do use `T2.setCode` instead of `code` for the SELECT list. Do join `sets AS T1` with `set_translations AS T2` using `INNER JOIN` instead of querying only the `sets` table. Do apply the join condition `T2.setCode = T1.code` instead of no join condition. Do filter on `T1.type = 'commander'` instead of `type = 'expansion' AND commander = 'true'`. The amended query now correctly retrieves set codes from the joined translation table based on commander type sets."
        ],
        "rules": [
            "1) When answering about \"code of sets with expansion commander type\": make sure the output order: T2.setCode. 2) When the question mentions \"sets\": combine tables \"sets AS T1\" with \"set_translations AS T2\" using inner match where T2.setCode = T1.code. 3) When filtering for commander type sets: use T1.type = 'commander' instead of type = 'expansion' AND commander = 'true'. 4) When selecting the set code: use T2.setCode instead of code from the sets table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE type = 'expansion' AND commander = 'true';",
            "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'"
        ],
        "rule_sql": [
            "SELECT T2.setCode \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T2.setCode = T1.code \nWHERE T1.type = 'commander'"
        ],
        "amend_res": 1
    },
    "193": {
        "db_id": "financial",
        "question": "List all ID and district for clients that can only have the right to issue permanent orders or apply for loans.",
        "ground_truth": "SELECT T3.client_id, T2.district_id, T2.A2 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T1.account_id = T3.account_id WHERE T3.type = 'OWNER'",
        "amends": [
            "Do select `T3.client_id`, `T2.district_id`, and `T2.A2` instead of `ID` and `district`. Do join from `account AS T1` instead of querying `clients` directly. Do add `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` instead of omitting the district table join. Do add `INNER JOIN disp AS T3 ON T1.account_id = T3.account_id` instead of omitting the disp table join. Do filter with `T3.type = 'OWNER'` instead of `permanent_orders = 1 OR loan_applications = 1`. The amended query now correctly retrieves account owners with their district information instead of clients with order or loan flags."
        ],
        "rules": [
            "1) When answering about \"clients that can only have the right to issue permanent orders or apply for loans\": use T3.\"type\" = 'OWNER' as the filter condition instead of permanent_orders = 1 OR loan_applications = 1. 2) When selecting client ID and district information: select T3.\"client_id\", T2.\"district_id\", and T2.\"A2\" instead of ID and district from the clients table. 3) When combining account and district tables: link rows where T1.\"district_id\" = T2.\"district_id\" and keep only matching pairs (inner match). 4) When combining account and disp tables: link rows where T1.\"account_id\" = T3.\"account_id\" and keep only matching pairs (inner match). 5) When the question mentions \"clients\": the client information is actually stored in the disp table with alias T3, not the clients table directly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT ID, district FROM clients WHERE permanent_orders = 1 OR loan_applications = 1;",
            "SELECT T3.client_id, T2.district_id, T2.A2\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN disp AS T3 ON T1.account_id = T3.account_id\nWHERE T3.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT T3.client_id, T2.A2\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T3 ON T1.account_id = T3.account_id\nWHERE T3.type = 'OWNER'",
            "SELECT T3.client_id, T2.district_id, T2.A2\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN disp T3 ON T1.account_id = T3.account_id\nWHERE T3.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "961": {
        "db_id": "formula_1",
        "question": "Which race has the shortest actual finishing time? Please give the name and year.",
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN results AS T2 on T1.raceId = T2.raceId WHERE T2.milliseconds IS NOT NULL ORDER BY T2.milliseconds LIMIT 1",
        "amends": [
            "Do select `T1.name` and `T1.year` with table aliases instead of `race_name` and `year` without aliases. Do add `INNER JOIN` on `results AS T2` with join condition `T1.raceId = T2.raceId` instead of querying only the `races` table. Do add `WHERE` filter `T2.milliseconds IS NOT NULL` instead of omitting any filter condition. Do order by `T2.milliseconds` in ascending order instead of `actual_finish_time` in descending order. The amended query now correctly identifies the fastest race by joining with results data and filtering for valid timing information."
        ],
        "rules": [
            "1) When answering about \"race with shortest actual finishing time\": make sure the output order: T1.name, T1.year. 2) When combining races and results tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 3) When filtering for valid timing information: include only rows where T2.milliseconds IS NOT NULL. 4) When ordering by finishing time: sort by T2.milliseconds in ascending order to find the shortest time. 5) When selecting the fastest race: take only the first row after ordering by T2.milliseconds ascending."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_name, year FROM races ORDER BY actual_finish_time DESC LIMIT 1;",
            "SELECT T1.name, T1.year\nFROM races AS T1\nINNER JOIN results AS T2 ON T1.raceId = T2.raceId\nWHERE T2.milliseconds IS NOT NULL\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT r.name, r.year\nFROM races r\nINNER JOIN results res ON r.raceId = res.raceId\nWHERE res.milliseconds IS NOT NULL\nORDER BY res.milliseconds ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "736": {
        "db_id": "superhero",
        "question": "Who is the dumbest superhero?",
        "ground_truth": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value LIMIT 1",
        "amends": [
            "Do use `T1.superhero_name` instead of `name` and add explicit table aliases throughout. Do join `hero_attribute AS T2` and `attribute AS T3` instead of querying `superheroes` directly. Do filter on `T3.attribute_name = 'Intelligence'` instead of directly comparing `intelligence` values. Do add `ORDER BY T2.attribute_value LIMIT 1` instead of using a subquery with `MIN(intelligence)` to find the minimum value. Do remove the subquery entirely instead of using nested selection. The amended query now correctly joins normalized tables to find the superhero with the minimum intelligence attribute value."
        ],
        "rules": [
            "1) When answering about \"the dumbest superhero\": make sure the output order: T1.superhero_name. 2) When the question mentions \"dumbest\": this means the minimum value of intelligence attribute, which requires joining hero_attribute AS T2 and attribute AS T3 tables. 3) When combining T1, T2, and T3 for shared entities: link rows where T2.hero_id = T1.hero_id and T2.attribute_id = T3.attribute_id; keep only matching pairs (inner match). 4) When filtering for intelligence attribute: use exact literal filter T3.attribute_name = 'Intelligence'. 5) When finding the minimum intelligence value: order rows by T2.attribute_value in ascending direction and keep the first 1 row. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 7) When handling text literals: do not change case, spacing, or punctuation of 'Intelligence'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE intelligence = (SELECT MIN(intelligence) FROM superheroes);",
            "SELECT T1.superhero_name\nFROM superhero AS T1\nJOIN hero_attribute AS T2 ON T1.id = T2.hero_id\nJOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Intelligence'\nORDER BY T2.attribute_value\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN hero_attribute AS T2 ON T2.hero_id = T1.id\nINNER JOIN attribute AS T3 ON T2.attribute_id = T3.id\nWHERE T3.attribute_name = 'Intelligence'\nORDER BY T2.attribute_value ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "155": {
        "db_id": "financial",
        "question": "How many percent of 'Gold' cards were issued prior to 1998?",
        "ground_truth": "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) FROM card",
        "amends": [
            "Do use `SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998')` with conditional aggregation instead of `COUNT(*)` with a separate WHERE clause. Do reference `issued` column for date handling instead of `issue_year`. Do use `STRFTIME('%Y', issued)` for year extraction instead of direct comparison to `issue_year < 1998`. Do calculate percentage using `CAST(... AS REAL)` for floating-point division instead of integer division. Do reference `card_id` in the denominator count instead of counting all rows. Do use table name `card` (singular) instead of `cards` (plural). Do remove the redundant subquery for total count and instead use conditional aggregation within a single query. The amended query now correctly handles floating-point percentage calculation and uses proper date extraction functions.",
            "Do use `SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998')` with implicit boolean-to-integer conversion instead of explicit `CASE WHEN` expressions. Do divide by `COUNT(card_id)` instead of `COUNT(CASE WHEN type = 'gold' THEN 1 END)` to count all cards rather than just gold cards. Do remove the `WHERE type = 'gold'` filter instead of keeping it since the aggregation logic already handles gold card filtering internally. Do use integer division `100 / COUNT(card_id)` instead of floating-point division `100.0 / COUNT(...)` as the CAST to REAL ensures proper percentage calculation. The amended query now correctly calculates the percentage of gold cards issued before 1998 out of all cards rather than just among gold cards."
        ],
        "rules": [
            "1) When the question mentions 'Gold' cards: use the exact literal 'gold' (lowercase) for card type comparison. 2) When handling date comparisons with 'prior to 1998': extract year from the \"issued\" column using STRFTIME('%Y', issued) and compare to '1998'. 3) When calculating percentage of Gold cards issued prior to 1998: use conditional aggregation with SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') for the numerator. 4) When counting total Gold cards for the denominator: use COUNT(card_id) with condition type = 'gold' instead of counting all rows. 5) When performing percentage calculation: use CAST(... AS REAL) for floating-point division to avoid integer division. 6) When referencing the table: use the exact table name \"card\" (singular) instead of \"cards\" (plural).",
            "1) When the question asks for percentage of 'Gold' cards issued prior to 1998: use SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') with implicit boolean-to-integer conversion instead of explicit CASE WHEN expressions. 2) When counting cards for percentage calculation: divide by COUNT(card_id) to count all cards rather than just gold cards. 3) When filtering for gold cards: remove the WHERE type = 'gold' filter since the aggregation logic already handles gold card filtering internally. 4) When calculating percentage: use integer division 100 / COUNT(card_id) instead of floating-point division 100.0 / COUNT(...) as the CAST to REAL ensures proper percentage calculation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM cards WHERE card_type = 'Gold')) AS percentage\nFROM cards \nWHERE card_type = 'Gold' AND issue_year < 1998;",
            "SELECT \n    CAST(SUM(CASE WHEN type = 'gold' AND STRFTIME('%Y', issued) < '1998' THEN 1 ELSE 0 END) AS REAL) * 100.0 / \n    COUNT(CASE WHEN type = 'gold' THEN 1 END) AS percentage\nFROM card\nWHERE type = 'gold';",
            "SELECT CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) AS percentage\nFROM card;"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(type = 'gold' AND STRFTIME('%Y', issued) < '1998') AS REAL) * 100 / COUNT(card_id) AS percentage\nFROM \n    card;"
        ],
        "amend_res": 1
    },
    "915": {
        "db_id": "formula_1",
        "question": "Which country is the oldest driver from?",
        "ground_truth": "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1",
        "amends": [
            "Do select `nationality` instead of `country` and filter with `WHERE dob IS NOT NULL` instead of omitting the filter. Do order by `dob ASC` instead of `age ASC` while maintaining the `LIMIT 1` clause. The amended query now correctly retrieves the driver's nationality based on date of birth filtering and ordering instead of using country and age fields."
        ],
        "rules": [
            "1) When the question asks about \"country\" for drivers: use the exact column token \"nationality\" from the drivers table instead of \"country\". 2) When filtering drivers by birth date: include only rows where \"dob\" is not null using the exact condition \"dob IS NOT NULL\". 3) When finding the oldest driver: order by the exact column \"dob\" in ascending order (oldest first) and keep only the first result using LIMIT 1."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM drivers ORDER BY age ASC LIMIT 1;",
            "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT nationality FROM drivers WHERE dob IS NOT NULL ORDER BY dob ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "11": {
        "db_id": "california_schools",
        "question": "Please list the codes of the schools with a total enrollment of over 500.",
        "ground_truth": "SELECT T2.CDSCode FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Enrollment (K-12)` + T2.`Enrollment (Ages 5-17)` > 500",
        "amends": [
            "Do select `T2.CDSCode` instead of `school_code`. Do join `frpm AS T2` with `schools AS T1` using `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying only the `schools` table. Do filter on `T2.Enrollment (K-12) + T2.Enrollment (Ages 5-17) > 500` instead of `enrollment > 500` to use the correct enrollment calculation from the joined table. The amended query now correctly retrieves CDSCode from the frpm table based on combined enrollment criteria while maintaining proper table relationships."
        ],
        "rules": [
            "1) When answering about \"schools with total enrollment over 500\": select \"T2.CDSCode\" as the output column instead of \"school_code\". 2) When combining schools and frpm tables: link rows where \"T1.CDSCode\" equals \"T2.CDSCode\" exactly and keep only matching pairs (inner match). 3) When calculating total enrollment: use the sum of \"T2.Enrollment (K-12)\" plus \"T2.Enrollment (Ages 5-17)\" instead of a single \"enrollment\" column. 4) When filtering for enrollment over 500: apply the condition \"T2.Enrollment (K-12) + T2.Enrollment (Ages 5-17) > 500\" to identify schools meeting the enrollment threshold."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_code FROM schools WHERE enrollment > 500;",
            "SELECT T2.CDSCode\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE (T2.\"Enrollment (K-12)\" + T2.\"Enrollment (Ages 5-17)\") > 500"
        ],
        "rule_sql": [
            "SELECT T2.CDSCode \nFROM frpm T2 \nWHERE T2.\"Enrollment (K-12)\" + T2.\"Enrollment (Ages 5-17)\" > 500"
        ],
        "amend_res": 1
    },
    "1000": {
        "db_id": "formula_1",
        "question": "Which racetrack hosted the most recent race? Indicate the full location.",
        "ground_truth": "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1",
        "amends": [
            "Do select `T1.location` instead of `name, location` from the wrong table. Do use `circuits AS T1` as the main table instead of `racetracks`. Do add `INNER JOIN races AS T2` instead of omitting the join. Do join on `T1.circuitId = T2.circuitId` instead of missing the join condition. Do order by `T2.date DESC` instead of `date` from the wrong table. The amended query now correctly retrieves the latest circuit location from joined race data instead of incorrectly selecting from a single table."
        ],
        "rules": [
            "1) When answering about \"most recent race\": order results by T2.date in descending order and keep only the first row. 2) When the question mentions \"racetrack\" and \"location\": use T1.location from the circuits table (aliased as T1) to represent the full location. 3) When combining circuits and races tables: link rows where T1.circuitId = T2.circuitId and keep only matching pairs (inner match). 4) When selecting output columns: include only T1.location to show the full location of the racetrack."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, location FROM racetracks ORDER BY date DESC LIMIT 1;",
            "SELECT T1.location FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.location \nFROM circuits T1\nINNER JOIN races T2 ON T1.circuitId = T2.circuitId\nORDER BY T2.date DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1040": {
        "db_id": "european_football_2",
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "ground_truth": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "amends": [
            "Do select `t1.player_name` instead of `name`. Do add `INNER JOIN` on `Player_Attributes AS t2` with predicate `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do keep the `WHERE` filter on `t1.height > 180` but add `GROUP BY t1.id` to aggregate player data. Do change the ordering to use `CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id)` instead of simple `heading_accuracy` to calculate average heading accuracy. The amended query now correctly aggregates player attributes and calculates average heading accuracy per player, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"players' names\": use \"t1.player_name\" instead of \"name\" as the output column. 2) When combining player data with player attributes: perform an inner join between \"players\" table (as T1) and \"Player_Attributes\" table (as T2) using the exact key equality \"t1.player_api_id = t2.player_api_id\". 3) When filtering by height above 180: apply the condition \"t1.height > 180\" to the players table. 4) When calculating average heading accuracy per player: compute \"CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id)\" for each player group. 5) When grouping player data: use \"t1.id\" as the grouping key to aggregate attributes per player. 6) When ordering by average heading accuracy: sort results in descending order of the calculated average heading accuracy value. 7) When the question asks for \"top 10 players\": limit the results to the first 10 rows after ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players WHERE height > 180 ORDER BY heading_accuracy DESC LIMIT 10;",
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180\nGROUP BY t1.id\nORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id) DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180\nGROUP BY t1.id\nORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.player_fifa_api_id) DESC\nLIMIT 10"
        ],
        "amend_res": 1
    },
    "146": {
        "db_id": "financial",
        "question": "Who are the female account holders who own credit cards and also have loans?",
        "ground_truth": "SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T5 ON T2.account_id = T5.account_id INNER JOIN loan AS T3 ON T5.account_id = T3.account_id INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id WHERE T1.gender = 'F'",
        "amends": [
            "Do select `T1.client_id` instead of `*` and change the source from `account_holders` to multiple joined tables. Do add `INNER JOIN disp AS T2 ON T1.client_id = T2.client_id` instead of a single table, then add `INNER JOIN account AS T5 ON T2.account_id = T5.account_id`, `INNER JOIN loan AS T3 ON T5.account_id = T3.account_id`, and `INNER JOIN card AS T4 ON T2.disp_id = T4.disp_id` instead of simple boolean conditions. Do change the filter to `T1.gender = 'F'` instead of `gender = 'male' AND has_credit_card = 'yes' AND has_loan = 'yes'`, removing the explicit credit card and loan boolean checks since they are now implicitly enforced through the join relationships. The amended query now correctly identifies female clients with associated accounts, loans, and cards through proper table relationships instead of relying on potentially incorrect boolean flags."
        ],
        "rules": [
            "1) When answering about female account holders who own credit cards and also have loans: make sure the output order: T1.client_id\n2) When the question mentions \"female\": \"female\" actually means \"T1.gender = 'F'\" in schema\n3) When combining T1 (account_holders) and T2 (disp) for shared entities: link rows where T1.client_id = T2.client_id and keep only matching pairs (inner match)\n4) When combining T2 (disp) and T5 (account) for shared entities: link rows where T2.account_id = T5.account_id and keep only matching pairs (inner match)\n5) When combining T5 (account) and T3 (loan) for shared entities: link rows where T5.account_id = T3.account_id and keep only matching pairs (inner match)\n6) When combining T2 (disp) and T4 (card) for shared entities: link rows where T2.disp_id = T4.disp_id and keep only matching pairs (inner match)\n7) When the question asks for account holders with credit cards and loans: the presence of credit cards is determined by successful inner join with card table (T4) and loans by successful inner join with loan table (T3), not by boolean flags"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM account_holders WHERE gender = 'male' AND has_credit_card = 'yes' AND has_loan = 'yes';",
            "SELECT T1.client_id\nFROM client AS T1\nINNER JOIN disp AS T2 ON T1.client_id = T2.client_id\nINNER JOIN account AS T5 ON T2.account_id = T5.account_id\nINNER JOIN loan AS T3 ON T5.account_id = T3.account_id\nINNER JOIN card AS T4 ON T2.disp_id = T4.disp_id\nWHERE T1.gender = 'F'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.client_id\nFROM client T1\nINNER JOIN disp T2 ON T1.client_id = T2.client_id\nINNER JOIN account T5 ON T2.account_id = T5.account_id\nINNER JOIN loan T3 ON T5.account_id = T3.account_id\nINNER JOIN card T4 ON T2.disp_id = T4.disp_id\nWHERE T1.gender = 'F'"
        ],
        "amend_res": 1
    },
    "634": {
        "db_id": "codebase_community",
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "ground_truth": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "amends": [
            "Do use `users` as the main table instead of `posts`, and add joins to `postHistory` and `posts` tables instead of querying `posts` alone. Do join with `INNER JOIN postHistory ON users.Id = postHistory.UserId` and `INNER JOIN posts ON postHistory.PostId = posts.Id` instead of no joins. Do filter on `DisplayName` with `OR` conditions instead of filtering on `author` with `IN` clause. Do select only `DisplayName` instead of both `author` and `popularity`. Do add `GROUP BY DisplayName` instead of no grouping. Do order by `SUM(ViewCount) DESC` instead of `popularity DESC`. Do keep `LIMIT 1` but change the underlying metric from single post popularity to total view count aggregation per user. The amended query now correctly finds the user with highest total view count across their posts instead of just the single most popular post by either author."
        ],
        "rules": [
            "1) When answering about user popularity based on posts: use users as the main table (T1) instead of posts directly. 2) When combining user information with post data: link users to postHistory using T1.Id = T2.UserId (inner match) and link postHistory to posts using T2.PostId = T3.Id (inner match). 3) When the question mentions authors \"Harvey Motulsky\" and \"Noah Snyder\": filter on T1.DisplayName with OR conditions for exactly 'Harvey Motulsky' and 'Noah Snyder' instead of using IN clause. 4) When computing popularity per user: group results by T1.DisplayName and calculate SUM(T3.ViewCount) as the popularity metric. 5) When determining which user has higher popularity: order results by SUM(T3.ViewCount) in descending direction and keep only the top 1 row. 6) When selecting output: return only T1.DisplayName instead of multiple columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    p.author,\n    p.popularity\nFROM posts p\nWHERE p.author IN ('Harvey Motulsky', 'Noah Snyder')\nORDER BY p.popularity DESC\nLIMIT 1;",
            "SELECT u.DisplayName\nFROM users u\nINNER JOIN postHistory ph ON u.Id = ph.UserId\nINNER JOIN posts p ON ph.PostId = p.Id\nWHERE u.DisplayName = 'Harvey Motulsky' OR u.DisplayName = 'Noah Snyder'\nGROUP BY u.DisplayName\nORDER BY SUM(p.ViewCount) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT u.DisplayName\nFROM users u\nINNER JOIN postHistory ph ON u.Id = ph.UserId\nINNER JOIN posts p ON ph.PostId = p.Id\nWHERE u.DisplayName = 'Harvey Motulsky' OR u.DisplayName = 'Noah Snyder'\nGROUP BY u.DisplayName\nORDER BY SUM(p.ViewCount) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "108": {
        "db_id": "financial",
        "question": "For the client who applied the biggest loan, what was his/her first amount of transaction after opened the account?",
        "evidence": "",
        "ground_truth": "SELECT T3.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id ORDER BY T1.amount DESC, T3.date ASC LIMIT 1",
        "amends": [
            "Do use table aliases `T1`, `T2`, and `T3` instead of `l`, `a`, and `t`. Do join `loan AS T1` with `account AS T2` on `T1.account_id = T2.account_id` instead of joining `transactions t` with `accounts a` on `t.account_id = a.account_id`. Do then join `trans AS T3` with `account AS T2` on `T2.account_id = T3.account_id` instead of joining `accounts a` with `loans l` on `a.client_id = l.client_id`. Do remove the WHERE clause with subquery for maximum loan amount instead of keeping it. Do add ORDER BY `T1.amount DESC, T3.date ASC` instead of only `t.date ASC`. Do keep LIMIT 1 but change the selected column to `T3.amount` instead of `t.amount`. The amended query now correctly retrieves the transaction amount from the account with the highest loan amount, ordered by loan amount descending and transaction date ascending."
        ],
        "rules": [
            "1) When joining loan and account tables: link rows where T1.account_id equals T2.account_id exactly. 2) When joining account and trans tables: link rows where T2.account_id equals T3.account_id exactly. 3) When finding the account with the biggest loan: order rows by T1.amount in descending order. 4) When finding the first transaction after account opening: order transactions by T3.date in ascending order. 5) When selecting the transaction amount: use T3.amount as the output column. 6) When limiting to the top result: keep only the first row after ordering. 7) When the question asks about the biggest loan: do not use a subquery for maximum amount, instead use ordering by T1.amount DESC."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT t.amount \nFROM transactions t\nJOIN accounts a ON t.account_id = a.account_id\nJOIN loans l ON a.client_id = l.client_id\nWHERE l.amount = (SELECT MAX(amount) FROM loans)\nORDER BY t.date ASC\nLIMIT 1;",
            "SELECT T3.amount\nFROM loan AS T1\nJOIN account AS T2 ON T1.account_id = T2.account_id\nJOIN trans AS T3 ON T2.account_id = T3.account_id\nORDER BY T1.amount DESC, T3.date ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t3.amount\nFROM loan t1\nJOIN account t2 ON t1.account_id = t2.account_id\nJOIN trans t3 ON t2.account_id = t3.account_id\nWHERE t3.date > t2.date\nORDER BY t1.amount DESC, t3.date ASC\nLIMIT 1;",
            "SELECT t3.amount\nFROM loan t1\nJOIN account t2 ON t1.account_id = t2.account_id\nJOIN trans t3 ON t2.account_id = t3.account_id\nWHERE t3.date >= t2.date\nORDER BY t1.amount DESC, t3.date ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "104": {
        "db_id": "financial",
        "question": "The transaction of 840 USD happened in 1998/10/14, when was this account opened?",
        "evidence": "",
        "ground_truth": "SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'",
        "amends": [
            "Do select `T1.date` from the `account` table instead of `opened_date` from `accounts`. Do join `trans AS T2` with `INNER JOIN` on `T1.account_id = T2.account_id` instead of querying only the `accounts` table. Do filter on `T2.amount = 840` instead of `transaction_amount = 840` and `T2.date = '1998-10-14'` instead of `transaction_date = '1998/10/14'` with corrected date format. The amended query now correctly joins account and transaction tables to retrieve the account date for specific transaction criteria, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about account opening date: use \"T1.date\" from the \"account\" table instead of \"opened_date\" from \"accounts\". 2) When combining account and transaction information: join \"account AS T1\" with \"trans AS T2\" using \"T1.account_id = T2.account_id\" to match related records. 3) When filtering for a transaction amount of 840 USD: use \"T2.amount = 840\" instead of \"transaction_amount = 840\". 4) When filtering for transaction date 1998/10/14: use \"T2.date = '1998-10-14'\" with the corrected date format instead of '1998/10/14'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT opened_date FROM accounts WHERE transaction_amount = 840 AND transaction_date = '1998/10/14';",
            "SELECT T1.date \nFROM account AS T1\nINNER JOIN trans AS T2 ON T1.account_id = T2.account_id\nWHERE T2.amount = 840 \nAND T2.date = '1998-10-14';"
        ],
        "rule_sql": [
            "SELECT T1.date AS account_opening_date\nFROM account AS T1\nJOIN trans AS T2 ON T1.account_id = T2.account_id\nWHERE T2.amount = 840\nAND T2.date = '1998-10-14';"
        ],
        "amend_res": 1
    },
    "72": {
        "db_id": "california_schools",
        "question": "How many students from the ages of 5 to 17 are enrolled at the State Special School school in Fremont for the 2014-2015 academic year?",
        "ground_truth": "SELECT T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.EdOpsCode = 'SSS' AND T2.City = 'Fremont' AND T1.`Academic Year` BETWEEN 2014 AND 2015",
        "amends": [
            "Do select `T1.Enrollment (Ages 5-17)` instead of `COUNT(*)` to retrieve actual enrollment data rather than just counting records. Do use `FROM frpm AS T1 INNER JOIN schools AS T2` instead of `FROM students` to join the enrollment and school information tables. Do apply join condition `ON T1.CDSCode = T2.CDSCode` instead of no join to properly relate enrollment records to their corresponding schools. Do filter with `T2.EdOpsCode = 'SSS'` instead of `school_name = 'State Special School'` to use the correct column name and code value for special schools. Do use `T2.City = 'Fremont'` instead of `city = 'Fremont'` to reference the city column from the correct table. Do apply `T1.Academic Year BETWEEN 2014 AND 2015` instead of `academic_year = '2014-2015'` to use numeric range comparison rather than string equality for the year filter. The amended query now correctly retrieves enrollment data for special schools in Fremont during the specified academic years."
        ],
        "rules": [
            "1) When the question asks for enrollment count of students aged 5-17: use T1.\"Enrollment (Ages 5-17)\" instead of counting records to get actual enrollment data. 2) When combining enrollment and school information: join frpm as T1 with schools as T2 using T1.CDSCode = T2.CDSCode to properly relate enrollment records to their corresponding schools. 3) When identifying State Special School: use T2.EdOpsCode = 'SSS' instead of school name comparison to use the correct column name and code value. 4) When filtering by city Fremont: use T2.City = 'Fremont' to reference the city column from the correct table. 5) When filtering for academic year 2014-2015: use T1.\"Academic Year\" BETWEEN 2014 AND 2015 instead of string equality to use numeric range comparison for the year filter."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM students WHERE school_name = 'State Special School' AND city = 'Fremont' AND academic_year = '2014-2015' AND age BETWEEN 5 AND 17;",
            "SELECT T1.\"Enrollment (Ages 5-17)\" \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nWHERE T2.EdOpsCode = 'SSS' \nAND T2.City = 'Fremont' \nAND T1.\"Academic Year\" BETWEEN '2014' AND '2015'"
        ],
        "rule_sql": [
            "SELECT T1.\"Enrollment (Ages 5-17)\" \nFROM frpm AS T1\nJOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.EdOpsCode = 'SSS'\nAND T2.City = 'Fremont'\nAND T1.\"Academic Year\" BETWEEN 2014 AND 2015"
        ],
        "amend_res": 1
    },
    "619": {
        "db_id": "codebase_community",
        "question": "How many adults who obtained the badge Supporter?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
        "amends": [
            "Do select `COUNT(T1.Id)` from the `users` table instead of `COUNT(*)` from the `adults` table. Do join `badges AS T2` with `INNER JOIN` on `T1.Id = T2.UserId` instead of querying a single table. Do add filter conditions `T2.Name = 'Supporter'` and `T1.Age BETWEEN 19 AND 65` instead of only filtering by `badge = 'Supporter'`. The amended query now correctly counts adult users with Supporter badges by joining the appropriate tables and applying proper age filtering, matching the intended behavior."
        ],
        "rules": [
            "1) When counting users who obtained a badge: count using the canonical key T1.Id from the users table instead of counting all rows. 2) When combining user and badge information: link rows where T1.Id = T2.UserId using an inner join between users table (T1) and badges table (T2). 3) When filtering for users with a specific badge: use the exact literal 'Supporter' for T2.Name. 4) When identifying adult users: filter for users where T1.Age is between 19 and 65 inclusive."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM adults WHERE badge = 'Supporter';",
            "SELECT COUNT(T1.Id) \nFROM users AS T1 \nINNER JOIN badges AS T2 ON T1.Id = T2.UserId \nWHERE T2.Name = 'Supporter' \nAND T1.Age BETWEEN 19 AND 65"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM users T1\nINNER JOIN badges T2 ON T1.Id = T2.UserId\nWHERE T2.Name = 'Supporter'\nAND T1.Age BETWEEN 19 AND 65"
        ],
        "amend_res": 1
    },
    "1328": {
        "db_id": "student_club",
        "question": "List the last name of all the students who majored Law and Constitutional Studies. \n",
        "ground_truth": "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'",
        "amends": [
            "Do select `T1.last_name` from the `member` table instead of `last_name` from `students`. Do join `major AS T2` with `INNER JOIN` on `T1.link_to_major = T2.major_id` instead of querying a single table. Do filter with `T2.major_name = 'Law and Constitutional Studies'` instead of using `OR` conditions with `major = 'Law' OR major = 'Constitutional Studies'`. The amended query now correctly joins tables and uses the proper major name instead of attempting to match multiple separate values, ensuring it returns the expected results from the RIGHT_SQL."
        ],
        "rules": [
            "1) When answering about \"students who majored Law and Constitutional Studies\": use the exact literal 'Law and Constitutional Studies' for filtering, not separate values 'Law' and 'Constitutional Studies'. 2) When the question mentions \"students\": the actual table is \"member\" (aliased as T1) and the relevant column is \"last_name\". 3) When combining member and major tables: link rows where T1.link_to_major = T2.major_id using an inner join to keep only matching pairs. 4) When filtering by major: use T2.major_name = 'Law and Constitutional Studies' as the exact condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM students WHERE major = 'Law' OR major = 'Constitutional Studies';",
            "SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'"
        ],
        "rule_sql": [
            "SELECT T1.last_name \nFROM member T1\nINNER JOIN major T2 ON T1.link_to_major = T2.major_id\nWHERE T2.major_name = 'Law and Constitutional Studies'"
        ],
        "amend_res": 1
    },
    "230": {
        "db_id": "toxicology",
        "question": "What are the elements of the toxicology and label of molecule TR060?",
        "ground_truth": "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'",
        "amends": [
            "Do select specific columns `T1.element, T2.label` instead of selecting all columns with `*`. Do add `DISTINCT` to eliminate duplicate rows instead of omitting it. Do change the FROM source to `atom AS T1 INNER JOIN molecule AS T2` instead of just `molecules`. Do add the join condition `ON T1.molecule_id = T2.molecule_id` instead of omitting any join. Do change the WHERE filter to `T2.molecule_id = 'TR060'` instead of `molecule_name = 'TR060'`. The amended query now correctly joins the atom and molecule tables to find distinct element-label pairs for the specified molecule ID instead of querying a single table by name."
        ],
        "rules": [
            "1) When answering about \"elements of the toxicology and label of molecule TR060\": make sure the output order: T1.element, T2.label 2) When the question asks for distinct element-label pairs: use DISTINCT to eliminate duplicate rows 3) When combining atom table T1 and molecule table T2: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match) 4) When filtering for molecule TR060: use T2.molecule_id = 'TR060' instead of molecule_name 5) When selecting columns: choose specific columns T1.element and T2.label instead of all columns with *"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM molecules WHERE molecule_name = 'TR060';",
            "SELECT DISTINCT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element, T2.label FROM atom T1 INNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'"
        ],
        "amend_res": 1
    },
    "1245": {
        "db_id": "thrombosis_prediction",
        "question": "For the examinations done after 1997/1/1, how many of them have the result of an inactivated partial prothrom bin time?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
        "amends": [
            "Do select `COUNT(T1.ID)` from the `Patient` table instead of `COUNT(*)` from the `examinations` table. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table without joins. Do filter on `T2.Date > '1997-01-01'` with proper date format instead of `exam_date > '1997/1/1'`. Do use `T2.APTT >= 45` as the condition instead of `result = 'inactivated partial prothrom bin time'`. The amended query now correctly counts patients with elevated APTT values after January 1, 1997, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients from examinations: use COUNT(T1.ID) from the Patient table instead of COUNT(*) from the examinations table. 2) When combining Patient and Laboratory data: join Patient AS T1 with Laboratory AS T2 using INNER JOIN on T1.ID = T2.ID to link patient records with their laboratory results. 3) When filtering by date after January 1, 1997: use T2.Date > '1997-01-01' with the exact date format 'YYYY-MM-DD' instead of '1997/1/1'. 4) When identifying inactivated partial prothrombin time results: use the condition T2.APTT >= 45 instead of looking for the literal string 'inactivated partial prothrom bin time'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM examinations \nWHERE exam_date > '1997/1/1' \nAND result = 'inactivated partial prothrom bin time'",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01' AND T2.APTT >= 45"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Examination T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01' AND T2.APTT >= 45",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01' \nAND T2.APTT >= 45"
        ],
        "amend_res": 1
    },
    "50": {
        "db_id": "california_schools",
        "question": "What is the postal street address for the school with the 7th highest Math average? Indicate the school's name.",
        "ground_truth": "SELECT T2.MailStreet, T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 6, 1",
        "amends": [
            "Do select `T2.MailStreet` and `T2.School` instead of `school_name` and `postal_street_address`. Do use `satscores AS T1 INNER JOIN schools AS T2` instead of only `FROM schools`. Do join on `T1.cds = T2.CDSCode` instead of no join condition. Do order by `T1.AvgScrMath DESC` instead of `math_average DESC`. Do use `LIMIT 6, 1` instead of `LIMIT 1 OFFSET 6`. The amended query now correctly joins the two tables and retrieves the appropriate school data based on math scores.",
            "Do swap the column order in the SELECT list to `T2.MailStreet, T2.School` instead of `T2.School, T2.MailStreet`. The amended query now matches RIGHT_SQL's behavior with the columns presented in the specified order."
        ],
        "rules": [
            "1) When answering about \"postal street address\" and \"school name\" for schools ranked by math average: select T2.MailStreet and T2.School as output columns. 2) When combining SAT scores and school information: link T1 (satscores) and T2 (schools) using T1.cds = T2.CDSCode with inner matching. 3) When the question asks for the 7th highest math average: rank rows by T1.AvgScrMath in descending order and take the row at position 7 (using LIMIT 6, 1). 4) When handling identifier delimiters: use exact tokens T1.cds and T2.CDSCode without changing their case or quoting.",
            "1) When answering about \"postal street address for the school with the 7th highest Math average\": make sure the output order: T2.MailStreet, T2.School\n2) When the question asks for the 7th highest Math average: rank rows by T1.AvgScrMath in descending order and take the row at position 7 (using LIMIT 6, 1 to skip first 6 rows and take 1 row)\n3) When combining satscores (T1) and schools (T2) tables: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, postal_street_address FROM schools ORDER BY math_average DESC LIMIT 1 OFFSET 6;",
            "SELECT T2.School, T2.MailStreet\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 6, 1",
            "SELECT T2.MailStreet, T2.School\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 6, 1"
        ],
        "rule_sql": [
            "SELECT T2.MailStreet, T2.School\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrMath DESC\nLIMIT 6, 1"
        ],
        "amend_res": 1
    },
    "35": {
        "db_id": "california_schools",
        "question": "What is the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12?",
        "ground_truth": "SELECT T2.AdmEmail1 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`Charter School (Y/N)` = 1 ORDER BY T1.`Enrollment (K-12)` ASC LIMIT 1",
        "amends": [
            "Do select `T2.AdmEmail1` instead of `email` from a different source. Do use `INNER JOIN` between `frpm AS T1` and `schools AS T2` on `T1.CDSCode = T2.CDSCode` instead of querying `administrators` with a subquery. Do filter on `T1.Charter School (Y/N) = 1` instead of `type = 'chartered'` in a subquery. Do order by `T1.Enrollment (K-12)` instead of `total_students` and maintain the `ASC LIMIT 1` structure. The amended query now correctly joins the appropriate tables and uses the proper column names and filter conditions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about administrator email addresses: select T2.AdmEmail1 instead of email from administrators table. 2) When combining frpm and schools tables: link rows where T1.CDSCode = T2.CDSCode using an inner join. 3) When filtering for chartered schools: use T1.Charter School (Y/N) = 1 instead of type = 'chartered'. 4) When ordering by student enrollment: use T1.Enrollment (K-12) in ascending order instead of total_students. 5) When finding the school with fewest students: maintain the ASC LIMIT 1 structure to get the single row with minimum enrollment."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM administrators WHERE school_id IN (SELECT school_id FROM schools WHERE type = 'chartered' ORDER BY total_students ASC LIMIT 1);",
            "SELECT T2.AdmEmail1\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.\"Charter School (Y/N)\" = 1\nORDER BY T1.\"Enrollment (K-12)\" ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.AdmEmail1 \nFROM frpm T1 \nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode \nWHERE T1.\"Charter School (Y/N)\" = 1 \nORDER BY T1.\"Enrollment (K-12)\" ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1324": {
        "db_id": "student_club",
        "question": "What is the average attendance of meetings in 2020?",
        "ground_truth": "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
        "amends": [
            "Do calculate average attendance as `CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event)` instead of using `AVG(attendance)`. Do join tables with `INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event` instead of querying a single table. Do filter by year using `SUBSTR(T1.event_date, 1, 4) = '2020'` instead of `year = 2020`. Do add an additional filter `T1.type = 'Meeting'` instead of omitting it. The amended query now correctly calculates average attendance by counting total attendances divided by distinct events for meetings in 2020, matching the intended behavior."
        ],
        "rules": [
            "1) When calculating average attendance for meetings: compute it as total attendances divided by distinct events using CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) instead of using AVG(attendance). 2) When combining event and attendance data: link tables using INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event to match event records with their attendance records. 3) When filtering by year 2020: use SUBSTR(T1.event_date, 1, 4) = '2020' to extract the year portion from the event date field. 4) When the question specifies meetings: add filter T1.type = 'Meeting' to include only meeting type events."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(attendance) FROM meetings WHERE year = 2020;",
            "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) AS average_attendance\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nWHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting';"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) AS average_attendance\nFROM event AS T1\nINNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event\nWHERE SUBSTR(T1.event_date, 1, 4) = '2020'\nAND T1.type = 'Meeting';"
        ],
        "amend_res": 1
    },
    "669": {
        "db_id": "codebase_community",
        "question": "When did 'chl' cast its first vote in a post?",
        "ground_truth": "SELECT T2.CreationDate FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'chl' ORDER BY T2.CreationDate LIMIT 1",
        "amends": [
            "Do join `users` and `votes` tables instead of querying only `votes` table. Do use `INNER JOIN` on `users.Id = votes.UserId` instead of filtering by `user_id` directly. Do filter by `DisplayName = 'chl'` instead of `user_id = 'chl'`. Do select `CreationDate` column instead of applying `MIN(created_at)` aggregate. Do add `ORDER BY CreationDate` and `LIMIT 1` instead of using `MIN()` aggregate function. Do remove `post_id IS NOT NULL` filter instead of keeping it. The amended query now correctly retrieves the earliest vote creation date for the specified user while maintaining proper table relationships."
        ],
        "rules": [
            "1) When the question asks about a user by display name 'chl': use the exact literal 'chl' to filter the DisplayName column from the users table. 2) When combining users and votes tables: link rows where users.Id equals votes.UserId using an inner join to maintain proper table relationships. 3) When finding the first vote date for a user: order the results by CreationDate in ascending order and take only the first row instead of using MIN() aggregate function. 4) When selecting the vote creation date: use the exact column name CreationDate from the votes table. 5) When the question asks about votes in posts: do not apply post_id IS NOT NULL filter as the question does not specify this condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(created_at) FROM votes WHERE user_id = 'chl' AND post_id IS NOT NULL;",
            "SELECT v.CreationDate \nFROM votes v \nINNER JOIN users u ON u.Id = v.UserId \nWHERE u.DisplayName = 'chl' \nORDER BY v.CreationDate \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT v.CreationDate \nFROM users u\nINNER JOIN votes v ON u.Id = v.UserId\nWHERE u.DisplayName = 'chl'\nORDER BY v.CreationDate ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "209": {
        "db_id": "toxicology",
        "question": "Chlorine is in what type of bond?",
        "ground_truth": "SELECT DISTINCT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T3.element = 'cl'",
        "amends": [
            "Do use `DISTINCT T1.bond_type` instead of `bond_type` without distinct. Do join multiple tables with `INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id` and `INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id` instead of querying a single table. Do filter with `T3.element = 'cl'` instead of `element = 'Chlorine'` to use the correct table reference and element symbol. The amended query now correctly joins the necessary tables to find bond types associated with chlorine atoms and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"Chlorine\": use the exact literal 'cl' (lowercase) instead of 'Chlorine' to match the element symbol in the schema. 2) When answering about bond types for an element: join multiple tables using inner matches - connect bond table (T1) to connected table (T2) on T1.bond_id = T2.bond_id, then connect to atom table (T3) on T2.atom_id = T3.atom_id. 3) When filtering for a specific element: use T3.element = 'cl' with the correct table reference to atom table. 4) When selecting bond types: use DISTINCT T1.bond_type to return unique bond type values instead of duplicates."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM chemical_bonds WHERE element = 'Chlorine';",
            "SELECT DISTINCT T1.bond_type\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id\nWHERE T3.element = 'cl'"
        ],
        "rule_sql": [
            "SELECT DISTINCT bond.bond_type FROM bond INNER JOIN connected ON bond.bond_id = connected.bond_id INNER JOIN atom ON connected.atom_id = atom.atom_id WHERE atom.element = 'cl'"
        ],
        "amend_res": 1
    },
    "753": {
        "db_id": "superhero",
        "question": "Among the superheroes with height from 170 to 190, list the names of the superheroes with no eye color.",
        "ground_truth": "SELECT DISTINCT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'",
        "amends": [
            "Do select `DISTINCT T1.superhero_name` instead of `name` to ensure uniqueness and use proper table aliasing. Do join `superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id` instead of querying a single table to properly resolve eye color through a relationship table. Do filter on `T2.colour = 'No Colour'` instead of `eye_color IS NULL` to correctly identify missing eye colors using the color reference table's specific value. Do use `height_cm` instead of `height` to reference the correct column name with proper units. The amended query now correctly handles the eye color relationship through proper table joins and uses the appropriate reference value for missing colors."
        ],
        "rules": [
            "1) When the question asks for superhero names: use \"T1.superhero_name\" with DISTINCT to ensure unique results. 2) When filtering by height range 170 to 190: use \"T1.height_cm\" BETWEEN 170 AND 190 (inclusive) instead of \"height\". 3) When identifying superheroes with no eye color: join \"superhero AS T1\" with \"colour AS T2\" using \"T1.eye_colour_id = T2.id\" and filter for \"T2.colour = 'No Colour'\" instead of checking for NULL values. 4) When combining tables for eye color resolution: perform an INNER JOIN to keep only superheroes that have matching color records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE height BETWEEN 170 AND 190 AND eye_color IS NULL;",
            "SELECT DISTINCT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T1.height_cm BETWEEN 170 AND 190\nAND T2.colour = 'No Colour'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.superhero_name\nFROM superhero AS T1\nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE T1.height_cm BETWEEN 170 AND 190\nAND T2.colour = 'No Colour'"
        ],
        "amend_res": 1
    },
    "744": {
        "db_id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id",
        "amends": [
            "Do use a single query with `SUM(CASE)` expressions instead of separate subqueries with `COUNT(*)`. Do join `superhero` table to `publisher` table via `INNER JOIN` on `T1.publisher_id = T2.id` instead of querying the same table multiple times without joins. Do reference `publisher_name` column from the joined publisher table instead of directly filtering on `publisher` column. Do calculate the difference as Marvel count minus DC count instead of DC count minus Marvel count. The amended query now correctly joins related tables and calculates the publisher difference using proper relational data modeling.",
            "Do remove the explicit `marvel_count` and `dc_count` columns instead of including them in the SELECT list. Do remove the WHERE filter `p.publisher_name IN ('Marvel Comics', 'DC Comics')` instead of keeping it, as the CASE statements already handle the filtering logic internally. Do use table aliases `T1` and `T2` instead of full table names for better readability. The amended query now correctly calculates only the difference between Marvel and DC counts without unnecessary filtering or output columns, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When combining superhero and publisher tables: link rows where T1.publisher_id equals T2.id exactly as shown in the amends and keep only matching pairs (inner match). 2) When counting superheroes per publisher: compute the number of rows using the canonical key for superheroes (T1.id) with SUM(CASE) expressions instead of separate COUNT(*) subqueries. 3) When filtering for DC Comics: use the exact literal 'DC Comics' from the publisher_name column of the joined publisher table (T2.publisher_name). 4) When filtering for Marvel Comics: use the exact literal 'Marvel Comics' from the publisher_name column of the joined publisher table (T2.publisher_name). 5) When calculating the difference in superhero counts: compute Marvel count minus DC count instead of DC count minus Marvel count.",
            "1) When answering about the difference in superhero counts between publishers: calculate only the difference value without including individual counts for each publisher. 2) When the question mentions \"DC Comics\" and \"Marvel Comics\": use the exact literals 'DC Comics' and 'Marvel Comics' with the exact case and spacing. 3) When counting superheroes per publisher: use conditional counting with CASE statements that check T2.publisher_name against the exact publisher literals. 4) When combining superhero and publisher tables: link rows where T1.publisher_id = T2.id to associate superheroes with their publishers. 5) When filtering for specific publishers: do not use a WHERE clause filter since the CASE statements already handle the conditional counting internally."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superheroes WHERE publisher = 'DC Comics') - \n    (SELECT COUNT(*) FROM superheroes WHERE publisher = 'Marvel Comics') AS difference;",
            "SELECT \n    SUM(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) AS marvel_count,\n    SUM(CASE WHEN p.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) AS dc_count,\n    SUM(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - SUM(CASE WHEN p.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) AS difference\nFROM superhero s\nINNER JOIN publisher p ON s.publisher_id = p.id\nWHERE p.publisher_name IN ('Marvel Comics', 'DC Comics')",
            "SELECT \n    SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) AS difference\nFROM \n    superhero T1\nINNER JOIN \n    publisher T2 ON T1.publisher_id = T2.id;"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END) - \n    SUM(CASE WHEN T2.publisher_name = 'DC Comics' THEN 1 ELSE 0 END) AS difference\nFROM superhero T1\nINNER JOIN publisher T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name IN ('DC Comics', 'Marvel Comics')"
        ],
        "amend_res": 1
    },
    "1226": {
        "db_id": "thrombosis_prediction",
        "question": "Who is the oldest patient with the highest total cholesterol (T-CHO). State the patient ID and T-CHO index.",
        "ground_truth": "SELECT T1.ID, T2.`T-CHO` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.`T-CHO` DESC, T1.Birthday ASC LIMIT 1",
        "amends": [
            "Do select `T1.ID` and `T2.T-CHO` instead of `patient_id` and `MAX(t_cho)`. Do use `FROM Patient AS T1 INNER JOIN Laboratory AS T2` instead of `FROM patients`. Do join on `T1.ID = T2.ID` instead of no join condition. Do remove the aggregate function `MAX` instead of keeping it. Do order by `T2.T-CHO DESC, T1.Birthday ASC` instead of `age DESC`. Do remove the incorrect column reference `age` instead of including it. The amended query now correctly joins patient and laboratory data to find the highest T-CHO value with proper patient identification and secondary sorting by birthday."
        ],
        "rules": [
            "1) When answering about \"oldest patient with highest total cholesterol\": make sure the output order: T2.\"T-CHO\" DESC, T1.Birthday ASC 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match) 3) When selecting patient identification: use T1.ID instead of patient_id 4) When selecting cholesterol values: use T2.\"T-CHO\" instead of MAX(t_cho) 5) When ordering by age: use T1.Birthday ASC instead of age DESC 6) When the question asks for \"highest total cholesterol\": rank rows by T2.\"T-CHO\" in descending order and keep the first row"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, MAX(t_cho) FROM patients ORDER BY age DESC LIMIT 1;",
            "SELECT T1.ID, T2.\"T-CHO\"\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nORDER BY T2.\"T-CHO\" DESC, T1.Birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.ID, T2.\"T-CHO\" \nFROM Patient T1 \nINNER JOIN Laboratory T2 ON T1.ID = T2.ID \nORDER BY T2.\"T-CHO\" DESC, T1.Birthday ASC \nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "745": {
        "db_id": "superhero",
        "question": "Give the publisher ID of Star Trek.",
        "ground_truth": "SELECT id FROM publisher WHERE publisher_name = 'Star Trek'",
        "amends": [
            "Do select `id` from the `publisher` table instead of `publisher_id` from the `books` table. Do filter on `publisher_name = 'Star Trek'` instead of `title = 'Star Trek'` to correctly query publisher information by name rather than incorrectly searching for book titles. The amended query now correctly retrieves publisher IDs from the publisher table based on publisher name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for publisher ID of a publisher by name: select \"id\" from the \"publisher\" table instead of \"publisher_id\" from other tables. 2) When filtering for a specific publisher name: use \"publisher_name = 'Star Trek'\" exactly as specified, not title or other attributes. 3) When retrieving publisher information: query the publisher table directly rather than searching through related tables like books."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT publisher_id FROM books WHERE title = 'Star Trek';",
            "SELECT id FROM publisher WHERE publisher_name = 'Star Trek';"
        ],
        "rule_sql": [
            "SELECT id FROM publisher WHERE publisher_name = 'Star Trek';"
        ],
        "amend_res": 1
    },
    "943": {
        "db_id": "formula_1",
        "question": "What is the rate of drivers completing all the laps in the 2008 Australian Grand Prix?",
        "ground_truth": "SELECT CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) * 100 / COUNT(T1.resultId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008",
        "amends": [
            "Do use `SUM(IIF(T1.time IS NOT NULL, 1, 0))` instead of `COUNT(DISTINCT driverId)` to count completed races based on time presence. Do join `races AS T2` with `INNER JOIN` on `T1.raceId = T2.raceId` instead of using a subquery for race filtering. Do move the race filter conditions `T2.name = 'Australian Grand Prix'` and `T2.year = 2008` to the WHERE clause instead of using a subquery. Do use `COUNT(T1.resultId)` instead of `COUNT(*)` for the denominator calculation. Do add explicit `CAST` to `REAL` instead of relying on implicit conversion for percentage calculation. Do remove the `position IS NOT NULL` filter instead of keeping it, as the completion logic now correctly uses time presence. The amended query now correctly calculates completion rate based on time presence rather than position data and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about driver completion rate in a specific race: use SUM(IIF(T1.time IS NOT NULL, 1, 0)) to count drivers who completed all laps based on time presence instead of counting distinct driver IDs. 2) When filtering for a specific race year and name: join races AS T2 with INNER JOIN on T1.raceId = T2.raceId and apply conditions T2.year = 2008 and T2.name = 'Australian Grand Prix' in the WHERE clause instead of using a subquery. 3) When calculating the denominator for completion rate: use COUNT(T1.resultId) instead of COUNT(*) to count all race entries. 4) When calculating percentage rates: explicitly cast to REAL instead of relying on implicit conversion. 5) When determining race completion: do not use position IS NOT NULL filter as completion is correctly determined by time presence."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(DISTINCT driverId) / COUNT(*) * 100 AS completion_rate \nFROM results \nWHERE raceId = (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix') \nAND position IS NOT NULL;",
            "SELECT \n    CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) / COUNT(T1.resultId) * 100 AS completion_rate\nFROM \n    results AS T1\nINNER JOIN \n    races AS T2 ON T1.raceId = T2.raceId\nWHERE \n    T2.name = 'Australian Grand Prix' AND \n    T2.year = 2008"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(IIF(T1.time IS NOT NULL, 1, 0)) AS REAL) / CAST(COUNT(T1.resultId) AS REAL) * 100 AS completion_rate\nFROM \n    results AS T1\nINNER JOIN \n    races AS T2 ON T1.raceId = T2.raceId\nWHERE \n    T2.year = 2008 \n    AND T2.name = 'Australian Grand Prix';"
        ],
        "amend_res": 1
    },
    "958": {
        "db_id": "formula_1",
        "question": "Which driver has the fastest lap time? Please give their forenames and surnames.",
        "evidence": "",
        "ground_truth": "SELECT T2.forename, T2.surname, T1.fastestLapTime FROM results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T1.fastestLapTime IS NOT NULL ORDER BY T1.fastestLapTime ASC LIMIT 1",
        "amends": [
            "Do add `T1.fastestLapTime` to the SELECT list instead of omitting it. Do change the FROM clause to use `results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId` instead of just `drivers`. Do add `WHERE T1.fastestLapTime IS NOT NULL` filter instead of omitting it. Do change ORDER BY to use `T1.fastestLapTime ASC` instead of `fastestLapTime ASC`. The amended query now correctly joins results with drivers, filters out null fastest lap times, and returns the complete result set matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"fastest lap time\": make sure the output order includes T1.fastestLapTime as the first column. 2) When the question mentions \"driver\": use results AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId to combine driver information with lap time results. 3) When filtering for valid lap times: include WHERE T1.fastestLapTime IS NOT NULL to exclude null values. 4) When ordering by fastest lap time: use T1.fastestLapTime ASC to find the smallest (fastest) time. 5) When selecting driver names: include both T2.forename and T2.surname from the joined drivers table."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT forename, surname FROM drivers ORDER BY fastestLapTime ASC LIMIT 1;",
            "SELECT T2.forename, T2.surname, T1.fastestLapTime \nFROM results AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T1.fastestLapTime IS NOT NULL \nORDER BY T1.fastestLapTime ASC \nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.fastestLapTime, T2.forename, T2.surname \nFROM results AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T1.fastestLapTime IS NOT NULL \nORDER BY T1.fastestLapTime ASC \nLIMIT 1",
            "SELECT T1.fastestLapTime, T2.forename, T2.surname \nFROM results AS T1 \nINNER JOIN drivers AS T2 ON T1.driverId = T2.driverId \nWHERE T1.fastestLapTime IS NOT NULL \nORDER BY T1.fastestLapTime ASC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "369": {
        "db_id": "card_games",
        "question": "How many cards that illusrtated in German have been reprinted?",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.isReprint = 1",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN foreign_data AS T2` instead of omitting the join to access language data. Do use join condition `ON T1.uuid = T2.uuid` instead of no join condition to properly relate the tables. Do filter on `T2.language = 'German'` instead of `language = 'German'` to reference the correct table's column. Do filter on `T1.isReprint = 1` instead of `reprint = 1` to use the correct column name from the proper table. The amended query now correctly counts German reprint cards by joining the necessary tables and using the appropriate column references."
        ],
        "rules": [
            "1) When counting cards: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When accessing language data: add INNER JOIN foreign_data AS T2 to access language information. 3) When combining cards and foreign_data tables: link rows where T1.uuid = T2.uuid to properly relate the tables. 4) When filtering by German language: use T2.language = 'German' instead of language = 'German' to reference the correct table's column. 5) When filtering for reprinted cards: use T1.isReprint = 1 instead of reprint = 1 to use the correct column name from the proper table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE language = 'German' AND reprint = 1;",
            "SELECT COUNT(T1.id) \nFROM cards AS T1\nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\nWHERE T2.language = 'German' \nAND T1.isReprint = 1"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards AS T1 \nINNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid \nWHERE T2.language = 'German' \nAND T1.isReprint = 1"
        ],
        "amend_res": 1
    },
    "136": {
        "db_id": "financial",
        "question": "Between 1/1/1995 and 12/31/1997, how many loans in the amount of at least 250,000 per account that chose monthly statement issuance were approved?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.frequency = 'POPLATEK MESICNE' AND T2.amount >= 250000",
        "amends": [
            "Do use `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific non-null values. Do reference tables as `account AS T1` and `loan AS T2` instead of `loans l` and `accounts a` with different aliases. Do use `INNER JOIN` with explicit specification instead of just `JOIN` while maintaining the same join condition `ON T1.account_id = T2.account_id`. Do filter on `T2.date BETWEEN '1995-01-01' AND '1997-12-31'` instead of `l.loan_date` with the same date range. Do use `T1.frequency = 'POPLATEK MESICNE'` instead of `a.statement_frequency = 'monthly'` for the account frequency filter. Do keep `T2.amount >= 250000` instead of `l.amount >= 250000` with the same amount threshold. Do remove the `l.status = 'approved'` filter instead of keeping it. The amended query now correctly matches the intended behavior with proper table references, column names, and filtering conditions."
        ],
        "rules": [
            "1) When counting loans per account: use COUNT(T2.account_id) instead of COUNT(*) to count specific non-null values. 2) When referencing tables: use account AS T1 and loan AS T2 instead of loans l and accounts a. 3) When combining account and loan tables: use INNER JOIN with condition T1.account_id = T2.account_id. 4) When filtering by date range: use T2.date BETWEEN '1995-01-01' AND '1997-12-31' instead of loan_date. 5) When filtering by account frequency: use T1.frequency = 'POPLATEK MESICNE' instead of statement_frequency = 'monthly'. 6) When filtering by loan amount: keep T2.amount >= 250000. 7) When the question does not mention loan status: do not include any status filter like 'approved'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM loans l\nJOIN accounts a ON l.account_id = a.account_id\nWHERE l.loan_date BETWEEN '1995-01-01' AND '1997-12-31'\nAND l.amount >= 250000\nAND a.statement_frequency = 'monthly'\nAND l.status = 'approved';",
            "SELECT COUNT(T1.account_id)\nFROM account AS T1\nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id\nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31'\nAND T1.frequency = 'POPLATEK MESICNE'\nAND T2.amount >= 250000"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) \nFROM account AS T1 \nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id \nWHERE T2.date BETWEEN '1995-01-01' AND '1997-12-31' \nAND T1.frequency = 'POPLATEK MESICNE' \nAND T2.amount >= 250000"
        ],
        "amend_res": 1
    },
    "522": {
        "db_id": "card_games",
        "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
        "ground_truth": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
        "amends": [
            "Do select `T1.name` and `T2.format` instead of `card_name` and `banned_play_format`. Do join `legalities AS T2` on `T2.uuid = T1.uuid` instead of querying only the `cards` table. Do filter with `T1.edhrecRank = 1` instead of `rank = 1` and add `T2.status = 'Banned'` instead of omitting it. Do add `GROUP BY T1.name, T2.format` instead of omitting grouping. Do remove `ORDER BY card_name` instead of keeping it. The amended query now correctly joins card and legality data, filters for banned cards with rank 1, and groups results appropriately."
        ],
        "rules": [
            "1) When answering about \"cards ranked 1st on EDHRec\": make sure the output order: T1.name, T2.format 2) When the question mentions \"cards name\": \"cards name\" actually means \"T1.name in schema\" 3) When the question mentions \"banned play format\": \"banned play format\" actually means \"T2.format where T2.status = 'Banned'\" 4) When combining T1 and T2 for shared entities: link rows where T2.uuid = T1.uuid and keep only matching pairs (inner match) 5) When filtering for rank 1 on EDHRec: use T1.edhrecRank = 1 instead of generic rank 6) When grouping results: organize by T1.name and T2.format to show each card's banned formats 7) When producing output: do not include ORDER BY clause as the question doesn't specify ordering"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_name, banned_play_format FROM cards WHERE rank = 1 ORDER BY card_name;",
            "SELECT T1.name, T2.format FROM cards AS T1 JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format"
        ],
        "rule_sql": [
            "SELECT T1.name, T2.format\nFROM cards T1\nINNER JOIN legalities T2 ON T2.uuid = T1.uuid\nWHERE T1.edhrecRank = 1\nAND T2.status = 'Banned'"
        ],
        "amend_res": 1
    },
    "199": {
        "db_id": "toxicology",
        "question": "In the molecule containing sodium atoms, how many are non-carcinogenic?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'",
        "amends": [
            "Do select `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all rows. Do change the FROM clause to use `atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table, adding the necessary join between atom and molecule tables. Do modify the WHERE clause to use `T1.element = 'na'` instead of `element = 'sodium'` to filter by atomic symbol rather than element name, and add `T2.label = '-'` instead of `carcinogenic = 'yes'` to filter by molecule label rather than carcinogenic property. The amended query now correctly counts distinct molecules containing sodium atoms with the specified label, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting molecules containing sodium atoms: count distinct T2.molecule_id instead of counting all rows. 2) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id using an inner join. 3) When filtering for sodium atoms: use T1.element = 'na' instead of 'sodium' to filter by atomic symbol. 4) When filtering for non-carcinogenic molecules: use T2.label = '-' instead of carcinogenic = 'yes' to filter by molecule label."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE element = 'sodium' AND carcinogenic = 'yes';",
            "SELECT COUNT(DISTINCT T2.molecule_id) \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.element = 'na' AND T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.molecule_id) \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id \nWHERE T1.element = 'na' AND T2.label = '-'"
        ],
        "amend_res": 1
    },
    "1302": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients with a normal range of creatinine phosphokinase, how many of them have a positive measure of degree of coagulation?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')",
        "amends": [
            "Do specify `COUNT(T1.ID)` instead of `COUNT(*)` to count specific patient IDs. Do join `Patient AS T1` instead of querying only `patients` table. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` to incorporate laboratory data instead of omitting it. Do add `INNER JOIN Examination AS T3 ON T1.ID = T3.ID` to include examination data instead of omitting it. Do filter with `T2.CPK < 250` instead of `creatinine_phosphokinase BETWEEN 0 AND 1000` to use the correct column name and threshold. Do replace `degree_of_coagulation > 0` with `(T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')` to use proper coagulation test indicators instead of a numeric comparison. The amended query now correctly joins multiple tables and uses appropriate clinical test criteria to match the intended patient count logic."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs. 2) When answering about patients with laboratory and examination data: join Patient AS T1 with Laboratory AS T2 using T1.ID = T2.ID and with Examination AS T3 using T1.ID = T3.ID, keeping only matching pairs (inner match). 3) When filtering for normal creatinine phosphokinase range: use T2.CPK < 250 instead of a 0-1000 range. 4) When identifying positive coagulation measures: use (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+') instead of degree_of_coagulation > 0 to check for positive test indicators."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients \nWHERE creatinine_phosphokinase BETWEEN 0 AND 1000 \nAND degree_of_coagulation > 0;",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.CPK < 250 \nAND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nINNER JOIN Examination AS T3 ON T1.ID = T3.ID\nWHERE T2.CPK < 250 \nAND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')"
        ],
        "amend_res": 1
    },
    "518": {
        "db_id": "card_games",
        "question": "Which of the play format has the highest number of banned status? Indicate the play format and the names of all the card meet the condition.",
        "ground_truth": "WITH MaxBanned AS (SELECT format, COUNT(*) AS count_banned FROM legalities WHERE status = 'Banned' GROUP BY format ORDER BY COUNT(*) DESC LIMIT 1) SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid INNER JOIN MaxBanned MB ON MB.format = T2.format WHERE T2.status = 'Banned'",
        "amends": [
            "Do use a CTE named `MaxBanned` to find the format with the most banned cards instead of querying directly from the cards table. Do select from the `legalities` table instead of the `cards` table for the main query. Do use `INNER JOIN` between `legalities` and `cards` on `uuid` instead of querying only the cards table. Do add a second `INNER JOIN` to the `MaxBanned` CTE on `format` instead of not joining to the CTE. Do filter on `T2.status = 'Banned'` in the WHERE clause instead of filtering only on the cards table. Do select specific columns `T2.format` and `T1.name` instead of aggregating with `COUNT` and `GROUP_CONCAT`. Do remove the `GROUP BY play_format` and `ORDER BY banned_count DESC LIMIT 1` from the main query instead of keeping them, as the limiting logic is now handled in the CTE. The amended query now correctly identifies and returns the actual banned cards for the format with the most bans, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"play format with highest number of banned status\": use a CTE named MaxBanned to find the format with the most banned cards instead of querying directly from the cards table. 2) When selecting data for banned cards: select from the legalities table instead of the cards table for the main query. 3) When combining legalities and cards tables: use INNER JOIN between legalities and cards on uuid instead of querying only the cards table. 4) When joining to the MaxBanned CTE: add a second INNER JOIN to the MaxBanned CTE on format instead of not joining to the CTE. 5) When filtering for banned status: filter on T2.status = 'Banned' in the WHERE clause instead of filtering only on the cards table. 6) When selecting output columns: select specific columns T2.format and T1.name instead of aggregating with COUNT and GROUP_CONCAT. 7) When handling grouping and ordering: remove the GROUP BY play_format and ORDER BY banned_count DESC LIMIT 1 from the main query, as the limiting logic is handled in the CTE."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT play_format, COUNT(*) as banned_count, GROUP_CONCAT(card_name) as banned_cards\nFROM cards\nWHERE status = 'banned'\nGROUP BY play_format\nORDER BY banned_count DESC\nLIMIT 1;",
            "WITH MaxBanned AS (\n    SELECT format, COUNT(*) AS banned_count\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n    ORDER BY banned_count DESC\n    LIMIT 1\n)\nSELECT T2.format, T1.name\nFROM cards T1\nINNER JOIN legalities T2 ON T1.uuid = T2.uuid\nINNER JOIN MaxBanned T3 ON T2.format = T3.format\nWHERE T2.status = 'Banned';"
        ],
        "rule_sql": [
            "WITH MaxBanned AS (\n    SELECT format, COUNT(*) AS banned_count\n    FROM legalities\n    WHERE status = 'Banned'\n    GROUP BY format\n    ORDER BY banned_count DESC\n    LIMIT 1\n)\nSELECT T2.format, T1.name\nFROM legalities T2\nINNER JOIN cards T1 ON T2.uuid = T1.uuid\nINNER JOIN MaxBanned MB ON T2.format = MB.format\nWHERE T2.status = 'Banned'\nORDER BY T2.format, T1.name;"
        ],
        "amend_res": 1
    },
    "1184": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient whose birthday was 1959/3/1, what symptoms did he/she have during the examination on 1993/9/27?",
        "evidence": "",
        "ground_truth": "SELECT T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-03-01' AND T2.`Examination Date` = '1993-09-27'",
        "amends": [
            "Do select `T2.Symptoms` instead of `symptom` and use table aliases. Do join `Patient AS T1` and `Examination AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `T1.Birthday` with date format '1959-03-01' instead of '1959/3/1' and `T2.Examination Date` with format '1993-09-27' instead of '1993/9/27', using proper date formatting and table-qualified columns. The amended query now correctly joins patient and examination tables to retrieve symptoms with proper date handling."
        ],
        "rules": [
            "1) When answering about symptoms for a patient with specific birthday and examination date: make sure the output order: T2.Symptoms\n2) When the question mentions \"symptoms\": \"symptoms\" actually means \"T2.Symptoms\" in schema\n3) When combining Patient as T1 and Examination as T2 for shared entities: link rows where T1.ID = T2.ID; keep only matching pairs (inner match)\n4) When filtering by patient birthday: use exact date format '1959-03-01' for T1.Birthday\n5) When filtering by examination date: use exact date format '1993-09-27' for T2.\"Examination Date\""
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT symptom FROM examinations WHERE patient_birthday = '1959/3/1' AND examination_date = '1993/9/27';",
            "SELECT T2.Symptoms \nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE T1.Birthday = '1959-03-01' \nAND T2.\"Examination Date\" = '1993-09-27'"
        ],
        "rule_sql": [
            "SELECT T2.Symptoms \nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE T1.Birthday = '1959-03-01' \nAND T2.\"Examination Date\" = '1993-09-27'"
        ],
        "amend_res": 1
    },
    "57": {
        "db_id": "california_schools",
        "question": "What is the phone number and extension number for the school that had the 333rd highest average writing score?",
        "evidence": "",
        "ground_truth": "SELECT T2.Phone, T2.Ext FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrWrite DESC LIMIT 332, 1",
        "amends": [
            "Do select `T2.Phone` and `T2.Ext` instead of `phone_number` and `extension_number`. Do add `INNER JOIN` between `satscores AS T1` and `schools AS T2` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do order by `T1.AvgScrWrite DESC` instead of `average_writing_score DESC`. Do use `LIMIT 332, 1` syntax instead of `LIMIT 1 OFFSET 332`. The amended query now correctly joins the SAT scores table to retrieve writing scores and uses proper column references with table aliases."
        ],
        "rules": [
            "1) When answering about phone number and extension number for schools: select \"T2\".\"Phone\" and \"T2\".\"Ext\" as output columns. 2) When combining SAT scores and schools data: link rows where \"T1\".\"cds\" equals \"T2\".\"CDSCode\" and keep only matching pairs (inner join). 3) When ranking schools by average writing score: order rows by \"T1\".\"AvgScrWrite\" in descending order. 4) When the question asks for the 333rd highest ranked school: take 1 row starting from position 333 (using LIMIT 332, 1 syntax). 5) When handling identifier delimiters: use double quotes exactly as shown in the schema (\"T1\", \"T2\", \"Phone\", \"Ext\", \"cds\", \"CDSCode\", \"AvgScrWrite\")."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone_number, extension_number \nFROM schools \nORDER BY average_writing_score DESC \nLIMIT 1 OFFSET 332;",
            "SELECT T2.Phone, T2.Ext\nFROM satscores AS T1\nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode\nORDER BY T1.AvgScrWrite DESC\nLIMIT 332, 1"
        ],
        "rule_sql": [
            "SELECT \"T2\".\"Phone\", \"T2\".\"Ext\"\nFROM \"satscores\" AS \"T1\"\nINNER JOIN \"schools\" AS \"T2\" ON \"T1\".\"cds\" = \"T2\".\"CDSCode\"\nORDER BY \"T1\".\"AvgScrWrite\" DESC\nLIMIT 332, 1"
        ],
        "amend_res": 1
    },
    "1210": {
        "db_id": "thrombosis_prediction",
        "question": "What is the average index of the lactate dehydrogenase (LDH) for all patients with lactate dehydrogenase (LDH) within the normal range.",
        "ground_truth": "SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500",
        "amends": [
            "Do use the `Laboratory` table instead of the `patients` table as the data source. Do change the filter condition to `LDH < 500` instead of `LDH > 200` to calculate the average of lower LDH values rather than higher ones. The amended query now correctly calculates the average LDH from the Laboratory table for values below 500, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average index of lactate dehydrogenase (LDH) for patients with LDH within normal range\": use the \"Laboratory\" table as the data source instead of the \"patients\" table. 2) When filtering for lactate dehydrogenase (LDH) within normal range: use the condition LDH < 500 instead of LDH > 200 to select lower LDH values. 3) When calculating the average LDH: compute the average of the LDH column from the Laboratory table for values below 500."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(LDH) FROM patients WHERE LDH > 200;",
            "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;"
        ],
        "rule_sql": [
            "SELECT AVG(LDH) AS average_LDH FROM Laboratory WHERE LDH < 500;"
        ],
        "amend_res": 1
    },
    "1277": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients have a normal anti-DNA level, yet their data are not recorded.",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA < 8 AND T1.Description IS NULL",
        "amends": [
            "Do select `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count distinct patient IDs rather than all rows. Do use `INNER JOIN` on `Laboratory AS T2` with `T1.ID = T2.ID` instead of querying only the `patients` table to incorporate laboratory data. Do filter with `T2.DNA < 8` instead of `anti_dna_level = 'normal'` to use a numeric threshold comparison rather than a string value. Do check `T1.Description IS NULL` instead of `data_recorded IS NULL` to reference the correct column for null description values. The amended query now correctly counts distinct patients with low DNA levels and null descriptions, matching the intended behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count distinct patient IDs rather than all rows. 2) When combining patient and laboratory data: use INNER JOIN between patients as T1 and Laboratory as T2 where T1.ID = T2.ID to incorporate laboratory data. 3) When filtering for normal anti-DNA level: use T2.DNA < 8 instead of string comparison to apply the numeric threshold for normal DNA levels. 4) When checking for unrecorded data: use T1.Description IS NULL to reference the correct column for null description values indicating unrecorded data."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE anti_dna_level = 'normal' AND data_recorded IS NULL;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.DNA < 8 \nAND T1.Description IS NULL"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.DNA < 8 \nAND T1.Description IS NULL"
        ],
        "amend_res": 1
    },
    "473": {
        "db_id": "card_games",
        "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
        "ground_truth": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
        "amends": [
            "Do select `IIF(isForeignOnly = 1, 'YES', 'NO')` instead of `*` to return a conditional flag rather than all columns. Do add `INNER JOIN sets AS T2 ON T2.code = T1.setCode` instead of omitting the join to access set information. Do remove `AND country != 'United States'` instead of keeping an incorrect country filter that doesn't exist in the schema. The amended query now correctly joins the cards and sets tables to determine foreign-only status for the specific card name, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about availability of cards with specific names: join the cards table (T1) with the sets table (T2) using T1.setCode = T2.code to access set information. 2) When the question asks about cards being \"only available outside the United States\": check the isForeignOnly column from the sets table and return 'YES' when isForeignOnly = 1, otherwise return 'NO'. 3) When filtering for a specific card name: use the exact literal 'Adarkar Valkyrie' with the name column from the cards table. 4) When producing output: return only the conditional flag indicating foreign-only status rather than all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE name = 'Adarkar Valkyrie' AND country != 'United States';",
            "SELECT IIF(T2.isForeignOnly = 1, 'YES', 'NO') AS is_foreign_only\nFROM cards AS T1\nINNER JOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T1.name = 'Adarkar Valkyrie'"
        ],
        "rule_sql": [
            "SELECT CASE WHEN s.isForeignOnly = 1 THEN 'YES' ELSE 'NO' END AS is_foreign_only\nFROM cards c\nJOIN sets s ON c.setCode = s.code\nWHERE c.name = 'Adarkar Valkyrie';"
        ],
        "amend_res": 1
    },
    "809": {
        "db_id": "superhero",
        "question": "What is the publisher name of the superhero ID 38?",
        "ground_truth": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38",
        "amends": [
            "Do use `T2.publisher_name` in the SELECT list instead of `name` to retrieve the publisher name rather than the superhero name. Do add `publisher AS T2` as a join source instead of omitting it, and do use `INNER JOIN` on `T1.publisher_id = T2.id` instead of querying only the `superheroes` table. Do change the table reference to `superhero AS T1` instead of `superheroes` for proper table naming. Do keep the filter `WHERE T1.id = 38` but apply it to the joined table structure instead of the single table. The amended query now correctly joins the superhero and publisher tables to retrieve the publisher name for the specified superhero ID, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"publisher name\" of a superhero: use \"T2.publisher_name\" in the output instead of \"name\" to retrieve the publisher name rather than the superhero name. 2) When combining superhero and publisher information: add \"publisher AS T2\" as a join source and use INNER JOIN on \"T1.publisher_id = T2.id\" to link the tables correctly. 3) When referring to the superhero table: use \"superhero AS T1\" instead of \"superheroes\" for proper table naming. 4) When filtering by superhero ID: keep the condition \"WHERE T1.id = 38\" but apply it to the joined table structure instead of a single table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE id = 38;",
            "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38"
        ],
        "rule_sql": [
            "SELECT T2.publisher_name\nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T1.id = 38"
        ],
        "amend_res": 1
    },
    "346": {
        "db_id": "card_games",
        "question": "List all the card id and artist with unknown power which are legal for commander play format.",
        "ground_truth": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
        "amends": [
            "Do select `T1.id` and `T1.artist` instead of `card_id` and `artist`. Do add `INNER JOIN legalities AS T2` on `T1.uuid = T2.uuid` instead of omitting the join. Do change the WHERE clause to include `T2.status = 'Legal'` and `T2.format = 'commander'` instead of `play_format = 'commander'`. Do modify the power filter to `T1.power IS NULL OR T1.power = '*'` instead of only `power IS NULL`. The amended query now correctly joins with the legalities table to verify commander format legality and handles both null and asterisk power values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting card identifiers and artists: use T1.id and T1.artist instead of generic card_id and artist columns. 2) When checking for commander format legality: join cards table T1 with legalities table T2 using T1.uuid = T2.uuid and require T2.status = 'Legal' and T2.format = 'commander'. 3) When identifying cards with unknown power: include both T1.power IS NULL and T1.power = '*' conditions to capture all unknown power values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_id, artist FROM cards WHERE power IS NULL AND play_format = 'commander';",
            "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')"
        ],
        "rule_sql": [
            "SELECT T1.id, T1.artist FROM cards T1 JOIN legalities T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal' AND (T1.power IS NULL OR T1.power = '*')"
        ],
        "amend_res": 1
    },
    "569": {
        "db_id": "codebase_community",
        "question": "Give the number of votes for the post about data visualization.",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T1.Title LIKE '%data visualization%'",
        "amends": [
            "Do use an `INNER JOIN` between `posts` and `votes` tables on `T1.Id = T2.PostId` instead of a subquery with `post_id = (SELECT id FROM posts)`. Do reference the joined table aliases `T1` and `T2` instead of using a correlated subquery. Do count `T1.Id` from the posts table instead of counting all rows from votes. Do place the title filter `T1.Title LIKE '%data visualization%'` in the WHERE clause instead of embedding it in a subquery. The amended query now correctly counts posts with matching titles that have associated votes, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"number of votes for the post about data visualization\": make sure the output order: count of posts with matching titles that have associated votes. 2) When the question mentions \"post about data visualization\": \"data visualization\" actually means \"T1.Title LIKE '%data visualization%' in schema\". 3) When combining T1 (posts) and T2 (votes) for shared entities: link rows where T1.Id = T2.PostId exactly as shown in the amends; keep only matching pairs (inner match). 4) When the question asks for \"number of votes\": compute the count using the canonical key token T1.Id from the posts table instead of counting all rows from votes. 5) When filtering for specific content: place the title filter T1.Title LIKE '%data visualization%' in the WHERE clause instead of using a subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM votes WHERE post_id = (SELECT id FROM posts WHERE title LIKE '%data visualization%')",
            "SELECT COUNT(T1.Id) \nFROM posts T1\nINNER JOIN votes T2 ON T1.Id = T2.PostId\nWHERE T1.Title LIKE '%data visualization%'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.Id) \nFROM posts T1 \nINNER JOIN votes T2 ON T1.Id = T2.PostId \nWHERE T1.Title LIKE '%data visualization%'"
        ],
        "amend_res": 1
    },
    "1444": {
        "db_id": "student_club",
        "question": "List the expenses that spend more than fifty dollars on average.",
        "ground_truth": "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50",
        "amends": [
            "Do select `expense_description` instead of `*` and use `HAVING AVG(cost) > 50` instead of `WHERE amount > 50`. Do change the table reference to `expense` instead of `expenses` and add `GROUP BY expense_description` instead of omitting it. Do remove the incorrect column `amount` and replace it with the correct aggregate function on `cost`. The amended query now correctly filters groups based on average cost rather than filtering individual rows by amount, matching the intended behavior of finding expense descriptions with average costs exceeding 50.",
            "Do remove `AVG(cost) as average_cost` from the SELECT list instead of including it, while keeping the `HAVING AVG(cost) > 50` clause unchanged to filter groups by their average cost. The amended query now correctly returns only the expense_description column for groups where the average cost exceeds 50, matching the RIGHT_SQL's behavior of filtering groups without including the aggregate value in the output."
        ],
        "rules": [
            "1) When answering about \"expenses that spend more than fifty dollars on average\": make sure the output order: expense_description. 2) When the question mentions \"expenses\": \"expenses\" actually means \"expense\" in schema. 3) When the question mentions \"spend more than fifty dollars on average\": compute the average of \"cost\" column and keep only groups where this average is greater than 50. 4) When the question asks for \"expenses\" by description: organize results by expense_description and compute requested aggregates per group. 5) When producing output: include only the expense_description column instead of all columns.",
            "1) When answering about \"expenses that spend more than fifty dollars on average\": make sure the output order: expense_description only, without including the average cost calculation in the results. 2) When filtering groups by average cost exceeding 50: apply the condition AVG(cost) > 50 to filter groups while keeping the expense_description in the output. 3) When the question asks for expense descriptions with average cost over 50: return only the expense_description column for groups that meet the average cost threshold, not the calculated average values themselves."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM expenses WHERE amount > 50;",
            "SELECT expense_description, AVG(cost) as average_cost FROM expense GROUP BY expense_description HAVING AVG(cost) > 50",
            "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50"
        ],
        "rule_sql": [
            "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50 ORDER BY expense_description;"
        ],
        "amend_res": 1
    },
    "273": {
        "db_id": "toxicology",
        "question": "What is the percentage of element chlorine in carcinogenic molecules?",
        "ground_truth": "SELECT CAST(COUNT( CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use `CAST(COUNT(CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element)` instead of `COUNT(*) * 100.0 / (SELECT COUNT(*) FROM molecules WHERE carcinogenic = 1)` for the percentage calculation. Do reference tables `atom AS T1` and `molecule AS T2` instead of `molecules m` and `elements e`. Do use `INNER JOIN` with `T1.molecule_id = T2.molecule_id` instead of `JOIN` with `m.molecule_id = e.molecule_id`. Do apply filter `WHERE T2.label = '+'` instead of `WHERE e.element = 'chlorine' AND m.carcinogenic = 1`. Do remove the subquery and carcinogenic condition instead of including them. The amended query now correctly calculates the percentage of chlorine atoms in molecules with a positive label."
        ],
        "rules": [
            "1) When calculating percentage of chlorine atoms in carcinogenic molecules: use CAST(COUNT(CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) instead of a subquery approach. 2) When referencing tables: use atom AS T1 and molecule AS T2 instead of molecules and elements. 3) When joining tables: use INNER JOIN with T1.molecule_id = T2.molecule_id to link atoms to molecules. 4) When filtering for carcinogenic molecules: use WHERE T2.label = '+' instead of checking carcinogenic = 1. 5) When identifying chlorine atoms: check for T1.element = 'cl' (lowercase) instead of 'chlorine'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM molecules WHERE carcinogenic = 1)) AS percentage\nFROM molecules m\nJOIN elements e ON m.molecule_id = e.molecule_id\nWHERE e.element = 'chlorine' AND m.carcinogenic = 1;",
            "SELECT \n    CAST(COUNT(CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) AS percentage\nFROM \n    atom AS T1\nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(CASE WHEN T1.element = 'cl' THEN T1.element ELSE NULL END) AS REAL) * 100 / COUNT(T1.element) AS percentage_chlorine\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T2.label = '+';"
        ],
        "amend_res": 1
    },
    "861": {
        "db_id": "formula_1",
        "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
        "ground_truth": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
        "amends": [
            "Do select `T2.number` from the `drivers` table instead of `driver_number` from `qualifying_results`. Do join `qualifying AS T1` with `drivers AS T2` using `INNER JOIN` on `T2.driverId = T1.driverId` instead of querying only `qualifying_results` without any joins. Do filter on `T1.raceId = 903` instead of `race_id = 903`. Do use the pattern match `T1.q3 LIKE '1:54%'` instead of the exact time comparison `q3_time = '0:01:54'` to handle time formatting variations. The amended query now correctly retrieves driver numbers by joining qualifying data with driver information and using appropriate pattern matching for time values."
        ],
        "rules": [
            "1) When answering about driver numbers: make sure the output order: T2.number 2) When combining qualifying and drivers tables: link rows where T2.driverId = T1.driverId and keep only matching pairs (inner match) 3) When filtering by race ID: use T1.raceId = 903 instead of race_id = 903 4) When filtering by Q3 time value '0:01:54': use pattern matching T1.q3 LIKE '1:54%' instead of exact time comparison to handle time formatting variations"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_number FROM qualifying_results WHERE race_id = 903 AND q3_time = '0:01:54';",
            "SELECT T2.number \nFROM qualifying AS T1 \nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId \nWHERE T1.raceId = 903 \nAND T1.q3 LIKE '1:54%'"
        ],
        "rule_sql": [
            "SELECT T2.number \nFROM qualifying T1 \nINNER JOIN drivers T2 ON T1.driverId = T2.driverId \nWHERE T1.raceId = 903 \nAND T1.q3 LIKE '1:54%'"
        ],
        "amend_res": 1
    },
    "1028": {
        "db_id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 season?",
        "ground_truth": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2009/2010' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "amends": [
            "Do select `teamInfo.team_long_name` instead of `home_team` and `wins`. Do join `League AS leagueData` and `Team AS teamInfo` instead of omitting them, with `INNER JOIN` on `leagueData.id = matchData.league_id` and `matchData.away_team_api_id = teamInfo.team_api_id` instead of no joins. Do filter on `leagueData.name = 'Scotland Premier League'` and `matchData.season = '2009/2010'` instead of just `season = '2010'`, and use `matchData.away_team_goal - matchData.home_team_goal > 0` instead of `home_score > away_score`. Do group by `matchData.away_team_api_id` instead of `home_team`. Do order by `COUNT(*) DESC` instead of `wins DESC`. The amended query now correctly identifies away team wins in the specified league and season.",
            "Do remove `COUNT(*) AS wins` from the SELECT list instead of including it, and do change the WHERE condition to `away_team_goal - home_team_goal > 0` instead of `away_team_goal > home_team_goal` to handle potential NULL values more robustly. Do move the ordering to `ORDER BY COUNT(*) DESC` instead of using the alias `wins` since the aggregate is no longer selected, and do remove the alias from the output entirely. The amended query now correctly identifies away team wins by goal difference while maintaining the same filtering and grouping logic to match the intended behavior."
        ],
        "rules": [
            "1) When answering about away team wins in Scotland Premier League: make sure the output order: teamInfo.team_long_name first, then the count of wins. 2) When the question mentions \"Scotland Premier League\": \"Scotland Premier League\" actually means \"leagueData.name = 'Scotland Premier League'\" in schema. 3) When the question mentions \"2010 season\": \"2010 season\" actually means \"matchData.season = '2009/2010'\" in schema. 4) When the question asks for \"away team won\": use condition \"matchData.away_team_goal - matchData.home_team_goal > 0\" instead of home_score > away_score. 5) When combining leagueData and matchData: link rows where leagueData.id = matchData.league_id and keep only matching pairs (inner match). 6) When combining matchData and teamInfo: link rows where matchData.away_team_api_id = teamInfo.team_api_id and keep only matching pairs (inner match). 7) When grouping by away team: group by matchData.away_team_api_id instead of home_team. 8) When counting wins: count the number of rows using the matchData table's records that satisfy the win condition. 9) When the question asks for \"the most\" wins: rank rows by the count of wins in descending order and keep the first 1 row.",
            "1) When the question asks for \"which away team won the most\": count the number of wins using the canonical counting method of goal difference comparison (away_team_goal - home_team_goal > 0) instead of direct goal comparison. 2) When computing aggregate counts for ordering: use COUNT(*) directly in the ORDER BY clause instead of referencing an alias when the aggregate is not selected in the output. 3) When filtering for Scottish Premier League matches: use the exact literal 'Scotland Premier League' for league name comparison. 4) When filtering for the 2010 season: use the exact literal '2009/2010' for season comparison. 5) When identifying away team wins: ensure the output includes only the team_long_name from the Team table without any aggregate columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT home_team, COUNT(*) as wins FROM matches WHERE season = '2010' AND home_score > away_score GROUP BY home_team ORDER BY wins DESC LIMIT 1;",
            "SELECT teamInfo.team_long_name, COUNT(*) AS wins\nFROM Match AS matchData\nINNER JOIN League AS leagueData ON leagueData.id = matchData.league_id\nINNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id\nWHERE leagueData.name = 'Scotland Premier League' \nAND matchData.season = '2009/2010'\nAND matchData.away_team_goal > matchData.home_team_goal\nGROUP BY matchData.away_team_api_id\nORDER BY wins DESC\nLIMIT 1;",
            "SELECT teamInfo.team_long_name\nFROM Match AS matchData\nINNER JOIN League AS leagueData ON leagueData.id = matchData.league_id\nINNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id\nWHERE leagueData.name = 'Scotland Premier League'\nAND matchData.season = '2009/2010'\nAND matchData.away_team_goal - matchData.home_team_goal > 0\nGROUP BY matchData.away_team_api_id\nORDER BY COUNT(*) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT t.team_long_name\nFROM Match m\nJOIN League l ON m.league_id = l.id\nJOIN Team t ON m.away_team_api_id = t.team_api_id\nWHERE l.name = 'Scotland Premier League'\nAND m.season = '2009/2010'\nAND m.away_team_goal - m.home_team_goal > 0\nGROUP BY m.away_team_api_id\nORDER BY COUNT(*) DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1238": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients who were diagnosed with SLE, who is the oldest with normal hemoglobin level. Provide the ID and sex.",
        "ground_truth": "SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17 ORDER BY T1.Birthday ASC LIMIT 1",
        "amends": [
            "Do select `T1.ID` and `T1.SEX` instead of `patient_id` and `sex`. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the patients table. Do filter on `T1.Diagnosis = 'SLE'` instead of `diagnosis = 'SLE'`. Do add hemoglobin range filter `T2.HGB > 10 AND T2.HGB < 17` instead of the incorrect string comparison `hemoglobin_level = 'normal'`. Do order by `T1.Birthday ASC` instead of `age ASC`. The amended query now correctly joins patient and laboratory data, uses proper numeric range filtering for hemoglobin values, and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients diagnosed with SLE: use \"T1.Diagnosis = 'SLE'\" as the filter condition. 2) When determining normal hemoglobin level: use numeric range filtering \"T2.HGB > 10 AND T2.HGB < 17\" instead of string comparison. 3) When combining patient and laboratory data: join \"Patient AS T1\" with \"Laboratory AS T2\" on \"T1.ID = T2.ID\" using inner match. 4) When identifying the oldest patient: order by \"T1.Birthday ASC\" and take the first result. 5) When selecting output columns: use \"T1.ID\" and \"T1.SEX\" exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex FROM patients WHERE diagnosis = 'SLE' AND hemoglobin_level = 'normal' ORDER BY age ASC LIMIT 1;",
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nJOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE'\nAND T2.HGB > 10 AND T2.HGB < 17\nORDER BY T1.Birthday ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.ID, T1.SEX\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17\nORDER BY T1.Birthday ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "979": {
        "db_id": "formula_1",
        "question": "What race number has the most finishers?",
        "ground_truth": "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1",
        "amends": [
            "Do select `raceId` instead of `race_number` and omit the `finisher_count` alias instead of including it. Do use `results` table instead of `finishers` table. Do change the aggregate function to `COUNT(time IS NOT NULL)` instead of `COUNT(*)` to count only non-null time values. Do change the sort order to `DESC` instead of `ASC` to find the race with the most finishers instead of the fewest. The amended query now correctly identifies the race with the highest number of finishers by counting non-null time values in descending order.",
            "Do remove the `WHERE time IS NOT NULL` filter from the main query instead of keeping it, as the `COUNT(time IS NOT NULL)` expression in the ORDER BY clause already handles the null checking logic correctly by counting only non-null values. The amended query now matches RIGHT_SQL's behavior by properly identifying the raceId with the most non-null time values."
        ],
        "rules": [
            "1) When answering about \"race number with the most finishers\": use the \"raceId\" column instead of \"race_number\" from the results table. 2) When counting finishers: count only rows where the \"time\" column is not null using COUNT(time IS NOT NULL) instead of counting all rows. 3) When ordering by finisher count to find the most finishers: sort in descending order (DESC) instead of ascending order (ASC). 4) When selecting output columns: include only \"raceId\" and omit any aliases like \"finisher_count\" from the final output.",
            "1) When counting finishers for races: count only non-null time values using COUNT(time IS NOT NULL) to identify finishers. 2) When finding the race with the most finishers: group by raceId and order by the count of non-null time values in descending order. 3) When selecting the top result: limit to 1 row to get the race with the highest count."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT race_number, COUNT(*) as finisher_count FROM finishers GROUP BY race_number ORDER BY finisher_count ASC LIMIT 1;",
            "SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;",
            "SELECT raceId FROM results GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(time IS NOT NULL) DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "6": {
        "db_id": "california_schools",
        "question": "Among the schools with the SAT test takers of over 500, please list the schools that are magnet schools or offer a magnet program.",
        "ground_truth": "SELECT T2.School FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.Magnet = 1 AND T1.NumTstTakr > 500",
        "amends": [
            "Do select `T2.School` instead of `*` to specify the exact column needed. Do use `satscores AS T1 INNER JOIN schools AS T2` instead of a single `schools` table to properly join the two data sources. Do join on `T1.cds = T2.CDSCode` instead of no join condition to correctly relate the tables. Do filter with `T2.Magnet = 1` instead of `(magnet_school = 'Yes' OR magnet_program = 'Yes')` to use the proper boolean flag column. Do filter with `T1.NumTstTakr > 500` instead of `sat_takers > 500` to reference the correct table and column name for SAT test takers. The amended query now correctly joins the satscores and schools tables and uses the appropriate column names and boolean values to match the intended logic."
        ],
        "rules": [
            "1) When answering about schools with SAT test takers over 500: use T1.NumTstTakr > 500 as the filter condition instead of sat_takers > 500. 2) When identifying magnet schools or programs: use T2.Magnet = 1 as the filter condition instead of (magnet_school = 'Yes' OR magnet_program = 'Yes'). 3) When combining SAT scores and school information: join T1 (satscores) and T2 (schools) using T1.cds = T2.CDSCode with an inner match. 4) When selecting output columns: return T2.School specifically instead of all columns (*)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM schools WHERE sat_takers > 500 AND (magnet_school = 'Yes' OR magnet_program = 'Yes');",
            "SELECT T2.School \nFROM satscores AS T1 \nINNER JOIN schools AS T2 ON T1.cds = T2.CDSCode \nWHERE T1.NumTstTakr > 500 \nAND T2.Magnet = 1"
        ],
        "rule_sql": [
            "SELECT T2.School \nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T1.NumTstTakr > 500\nAND T2.Magnet = 1;"
        ],
        "amend_res": 1
    },
    "1364": {
        "db_id": "student_club",
        "question": "Where is Amy Firth's hometown?",
        "ground_truth": "SELECT T2.city, T2.county, T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'",
        "amends": [
            "Do select `T2.city`, `T2.county`, and `T2.state` instead of just `hometown`. Do join `member AS T1` with `zip_code AS T2` using `INNER JOIN` on `T1.zip = T2.zip_code` instead of querying only the `users` table. Do filter on `T1.first_name = 'Amy'` and `T1.last_name = 'Firth'` instead of filtering on the same conditions but from the wrong table. The amended query now correctly retrieves location data from the zip_code table through proper table joining instead of attempting to get hometown directly from a users table."
        ],
        "rules": [
            "1) When answering about \"Amy Firth's hometown\": make sure the output order: T2.city, T2.county, T2.state 2) When the question mentions \"hometown\": \"hometown\" actually means \"city, county, and state in schema\" 3) When combining member table as T1 and zip_code table as T2: link rows where T1.zip = T2.zip_code and keep only matching pairs (inner match) 4) When filtering for Amy Firth: filter on T1.first_name = 'Amy' and T1.last_name = 'Firth' using exact literals 'Amy' and 'Firth'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM users WHERE first_name = 'Amy' AND last_name = 'Firth';",
            "SELECT T2.city, T2.county, T2.state\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'"
        ],
        "rule_sql": [
            "SELECT T2.city, T2.county, T2.state\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\nWHERE T1.first_name = 'Amy' AND T1.last_name = 'Firth'"
        ],
        "amend_res": 1
    },
    "697": {
        "db_id": "codebase_community",
        "question": "What is the reputation and view count of the user, who is known by his or her display name 'Jarrod Dixon'?",
        "evidence": "",
        "ground_truth": "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'",
        "amends": [
            "Do use column names `Reputation` and `Views` instead of `reputation` and `view_count` in the SELECT list. Do use filter condition `DisplayName = 'Jarrod Dixon'` instead of `display_name = 'Jarrod Dixon'` in the WHERE clause. The amended query now correctly references the actual column names in the database schema."
        ],
        "rules": [
            "1) When the question asks for reputation and view count: use column names \"Reputation\" and \"Views\" exactly as shown in the schema. 2) When filtering by display name 'Jarrod Dixon': use the exact literal 'Jarrod Dixon' with the column name \"DisplayName\" exactly as specified in the amends. 3) When selecting from the users table: ensure the output columns are ordered as \"Reputation\" followed by \"Views\" to match the question's request order."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT reputation, view_count FROM users WHERE display_name = 'Jarrod Dixon';",
            "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';"
        ],
        "rule_sql": [
            "SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';"
        ],
        "amend_res": 1
    },
    "1112": {
        "db_id": "european_football_2",
        "question": "What was the chance creation crossing class for \"Hull City\" on 2010/2/22?",
        "ground_truth": "SELECT t2.chanceCreationCrossingClass FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t1.team_long_name = 'Hull City' AND SUBSTR(t2.`date`, 1, 10) = '2010-02-22'",
        "amends": [
            "Do select `t2.chanceCreationCrossingClass` instead of `chance_creation_crossing`. Do use `Team AS t1 INNER JOIN Team_Attributes AS t2` instead of single table `matches`. Do join on `t1.team_api_id = t2.team_api_id` instead of no join condition. Do filter with `t1.team_long_name = 'Hull City'` instead of `team = 'Hull City'`. Do filter with `SUBSTR(t2.date, 1, 10) = '2010-02-22'` instead of `date = '2010-02-22'`. The amended query now correctly joins team attributes and uses proper date handling to match the intended behavior."
        ],
        "rules": [
            "1) When answering about chance creation crossing class for a team: use the exact column token \"t2.chanceCreationCrossingClass\" from the Team_Attributes table. 2) When the question mentions a team name like \"Hull City\": use the exact filter condition \"t1.team_long_name = 'Hull City'\" with the exact literal value 'Hull City'. 3) When the question mentions a specific date like \"2010/2/22\": convert it to the format '2010-02-22' and use the exact filter condition \"SUBSTR(t2.date, 1, 10) = '2010-02-22'\". 4) When combining Team and Team_Attributes tables: link rows where \"t1.team_api_id = t2.team_api_id\" and keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like \"chanceCreationCrossingClass\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT chance_creation_crossing FROM matches WHERE team = 'Hull City' AND date = '2010-02-22';",
            "SELECT t2.chanceCreationCrossingClass \nFROM Team AS t1 \nINNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hull City' \nAND SUBSTR(t2.date, 1, 10) = '2010-02-22'"
        ],
        "rule_sql": [
            "SELECT t2.chanceCreationCrossingClass \nFROM Team t1 \nINNER JOIN Team_Attributes t2 ON t1.team_api_id = t2.team_api_id \nWHERE t1.team_long_name = 'Hull City' \nAND SUBSTR(t2.date, 1, 10) = '2010-02-22'"
        ],
        "amend_res": 1
    },
    "582": {
        "db_id": "codebase_community",
        "question": "List the title of posts which were edited by Vebjorn Ljosa.",
        "ground_truth": "SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'",
        "amends": [
            "Do join `posts AS T1` with `users AS T2` on `T1.OwnerUserId = T2.Id` instead of querying only the `posts` table. Do filter on `T2.DisplayName = 'Vebjorn Ljosa'` instead of filtering directly on `editor = 'Vebjorn Ljosa'`. Do select `T1.Title` instead of `title` to use the table alias. The amended query now correctly joins user data to filter by display name instead of relying on a potentially incorrect editor field, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"posts edited by Vebjorn Ljosa\": make sure to join posts AS T1 with users AS T2 on T1.OwnerUserId = T2.Id to link user information. 2) When the question mentions \"Vebjorn Ljosa\": \"Vebjorn Ljosa\" actually means T2.DisplayName = 'Vebjorn Ljosa' in the schema. 3) When selecting the title of posts: use T1.Title instead of title to use the table alias correctly."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT title FROM posts WHERE editor = 'Vebjorn Ljosa';",
            "SELECT T1.Title \nFROM posts AS T1 \nJOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'Vebjorn Ljosa'"
        ],
        "rule_sql": [
            "SELECT T1.Title \nFROM posts AS T1 \nJOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'Vebjorn Ljosa'"
        ],
        "amend_res": 1
    },
    "904": {
        "db_id": "formula_1",
        "question": "State the race and year of race in which Michael Schumacher had his fastest lap.",
        "ground_truth": "SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher' ORDER BY T2.milliseconds ASC LIMIT 1",
        "amends": [
            "Do select `T1.name` and `T1.year` instead of `race` and `year`. Do join `races AS T1` with `lapTimes AS T2` on `T2.raceId = T1.raceId` instead of querying only the races table. Do add a second join to `drivers AS T3` on `T3.driverId = T2.driverId` instead of omitting driver table relationships. Do filter with `T3.forename = 'Michael' AND T3.surname = 'Schumacher'` instead of `driver = 'Michael Schumacher'` to properly match the driver's full name across separate columns. Do order by `T2.milliseconds ASC` instead of `fastest_lap DESC` to correctly identify the fastest lap based on time measurement rather than a descriptive field. The amended query now properly joins the necessary tables to correlate race information with lap times and driver details, ensuring accurate identification of Michael Schumacher's fastest lap race."
        ],
        "rules": [
            "1) When answering about Michael Schumacher's fastest lap race: join races AS T1 with lapTimes AS T2 on T2.raceId = T1.raceId and join drivers AS T3 on T3.driverId = T2.driverId to properly link race information with lap times and driver details. 2) When filtering for Michael Schumacher: use T3.forename = 'Michael' AND T3.surname = 'Schumacher' instead of a single driver column to match the driver's full name across separate columns. 3) When identifying the fastest lap: order by T2.milliseconds ASC instead of fastest_lap DESC to correctly identify the fastest lap based on time measurement. 4) When selecting output columns: use T1.name and T1.year instead of race and year to get the correct race name and year information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race, year FROM races WHERE driver = 'Michael Schumacher' ORDER BY fastest_lap DESC LIMIT 1;",
            "SELECT T1.name, T1.year\nFROM races AS T1\nJOIN lapTimes AS T2 ON T2.raceId = T1.raceId\nJOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher'\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.year\nFROM races AS T1\nJOIN lapTimes AS T2 ON T2.raceId = T1.raceId\nJOIN drivers AS T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Michael' AND T3.surname = 'Schumacher'\nORDER BY T2.milliseconds ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "456": {
        "db_id": "card_games",
        "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
        "amends": [
            "Do select `DISTINCT subtypes, supertypes` instead of `type` in the SELECT list. Do add the `supertypes` column instead of omitting it. Do change the column selection from `type` to `subtypes` instead of keeping the original column. The amended query now correctly retrieves distinct card type classifications rather than a single type field, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"types for the card 'Molimo, Maro-Sorcerer'\": make sure to select both \"subtypes\" and \"supertypes\" columns instead of just \"type\". 2) When retrieving type classifications for a specific card: use DISTINCT on both \"subtypes\" and \"supertypes\" to get unique type combinations. 3) When filtering for a specific card name: use the exact literal 'Molimo, Maro-Sorcerer' with the correct case and punctuation. 4) When the question asks for \"all types\" of a card: include both subtype classifications (from \"subtypes\") and supertype classifications (from \"supertypes\") as they represent the complete type information."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT type FROM cards WHERE name = 'Molimo, Maro-Sorcerer';",
            "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';"
        ],
        "rule_sql": [
            "SELECT DISTINCT supertypes, subtypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';",
            "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';"
        ],
        "amend_res": 1
    },
    "828": {
        "db_id": "superhero",
        "question": "Count the fastest superheroes.",
        "ground_truth": "SELECT COUNT(T3.superhero_name) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id WHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100",
        "amends": [
            "Do use explicit table joins with `hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id INNER JOIN superhero AS T3 ON T1.hero_id = T3.id` instead of querying a single `superheroes` table. Do filter by specific attribute name with `T2.attribute_name = 'Speed'` instead of assuming a speed column exists. Do check for exact attribute value with `T1.attribute_value = 100` instead of using a subquery to find maximum speed. Do count specific superhero names with `COUNT(T3.superhero_name)` instead of counting all rows. The amended query now correctly counts superheroes with the maximum speed attribute value by properly joining the normalized schema tables."
        ],
        "rules": [
            "1) When answering about \"fastest superheroes\": make sure the output order: COUNT(T3.superhero_name). 2) When the question mentions \"fastest superheroes\": use the exact literal 'Speed' for T2.attribute_name and the exact value 100 for T1.attribute_value. 3) When combining tables for superhero attributes: link rows using T1.attribute_id = T2.id and T1.hero_id = T3.id with inner matches only. 4) When counting superheroes: count using the canonical key T3.superhero_name instead of counting all rows. 5) When filtering by speed attribute: use exact equality T2.attribute_name = 'Speed' and T1.attribute_value = 100 instead of finding maximum values through subqueries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE speed = (SELECT MAX(speed) FROM superheroes);",
            "SELECT COUNT(T3.superhero_name) \nFROM hero_attribute AS T1 \nINNER JOIN attribute AS T2 ON T1.attribute_id = T2.id \nINNER JOIN superhero AS T3 ON T1.hero_id = T3.id \nWHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100"
        ],
        "rule_sql": [
            "SELECT COUNT(T3.superhero_name) \nFROM hero_attribute T1\nINNER JOIN attribute T2 ON T1.attribute_id = T2.id\nINNER JOIN superhero T3 ON T1.hero_id = T3.id\nWHERE T2.attribute_name = 'Speed' AND T1.attribute_value = 100"
        ],
        "amend_res": 1
    },
    "1233": {
        "db_id": "thrombosis_prediction",
        "question": "List each patient's ID and blood glucose (GLU) index that were within normal range for patient's whose data was first recorded in 1991.",
        "ground_truth": "SELECT DISTINCT T1.ID, T2.GLU FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.`First Date`) = '1991' AND T2.GLU < 180",
        "amends": [
            "Do select `DISTINCT T1.ID, T2.GLU` instead of `patient_id, GLU`. Do use `INNER JOIN` between `Patient AS T1` and `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the patients table. Do filter with `STRFTIME('%Y', T1.First Date) = '1991'` instead of `YEAR(first_record_date) = 1991`. Do use `T2.GLU < 180` instead of `GLU BETWEEN 70 AND 140`. The amended query now correctly joins laboratory data with patient information and uses appropriate date formatting and glucose threshold filtering."
        ],
        "rules": [
            "1) When answering about patient ID and blood glucose: make sure the output order: T1.ID, T2.GLU\n2) When the question mentions \"patient's ID\": \"patient's ID\" actually means \"T1.ID in schema\"\n3) When the question mentions \"blood glucose (GLU)\": \"blood glucose (GLU)\" actually means \"T2.GLU in schema\"\n4) When combining Patient as T1 and Laboratory as T2: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)\n5) When filtering for patients whose data was first recorded in 1991: use STRFTIME('%Y', T1.\"First Date\") = '1991' to extract the year from the date field\n6) When filtering for glucose within normal range: use T2.GLU < 180 as the threshold condition\n7) When selecting patient IDs: use DISTINCT T1.ID to ensure each patient appears only once in the results"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, GLU FROM patients WHERE YEAR(first_record_date) = 1991 AND GLU BETWEEN 70 AND 140;",
            "SELECT DISTINCT T1.ID, T2.GLU\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.\"First Date\") = '1991'\nAND T2.GLU < 180"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T2.GLU\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE STRFTIME('%Y', T1.\"First Date\") = '1991'\nAND T2.GLU < 180"
        ],
        "amend_res": 1
    },
    "1016": {
        "db_id": "formula_1",
        "question": "In the race a driver set the lap record for the Austrian Grand Prix Circuit, how long did he spent at the pit stop at that same race?",
        "ground_truth": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL), lap_record_race AS ( SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT T4.duration FROM lap_record_race INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
        "amends": [
            "Do use a CTE structure with `fastest_lap_times` and `lap_record_race` instead of a simple subquery. Do calculate lap times in seconds using `CAST` and string manipulation functions instead of assuming a simple `pit_stop_time` column. Do join multiple tables including `results`, `races`, and `circuits` instead of querying only the `races` table. Do filter by `T2.name = 'Austrian Grand Prix'` instead of `race_name = 'Austrian Grand Prix Circuit'`. Do find the minimum lap time using `MIN(fastest_lap_times.time_in_seconds)` instead of assuming a direct relationship between driver names. Do use proper join conditions with `raceId` and `driverId` instead of driver name matching. Do retrieve `duration` from `pitStops` table instead of `pit_stop_time` from `races`. The amended query now correctly identifies the fastest lap record and retrieves corresponding pit stop information using proper table relationships and time calculations.",
            "Do use `results` table with `FastestLapTime` column instead of `lapTimes` table with `time` column for the fastest lap calculation. Do simplify the time conversion to handle only the `MM:SS.fff` format instead of multiple conditional formats. Do calculate time conversion as `(minutes*60) + seconds + (milliseconds/1000)` instead of complex string parsing with nested `INSTR` functions. Do filter for `FastestLapTime IS NOT NULL` instead of omitting null handling. Do use a subquery to find the minimum time instead of `GROUP BY` with `MIN` aggregation. Do join on the calculated time matching the minimum time instead of grouping by race and driver. Do filter races by `T2.name = 'Austrian Grand Prix'` instead of `c.name = 'Austrian Grand Prix'`. Do remove the `ORDER BY` and `LIMIT` in the CTE instead of keeping them. Do select only `raceId` and `driverId` from the CTE instead of including the time value. Do join directly with `pitStops` table instead of using an additional CTE layer. The amended query now correctly identifies the fastest lap using the results table and properly handles the time format conversion to find the corresponding pit stop duration."
        ],
        "rules": [
            "1) When answering about lap records and pit stops: use a CTE structure with fastest_lap_times and lap_record_race instead of simple subqueries. 2) When calculating lap times: convert to seconds using CAST and string manipulation functions instead of assuming a simple time column. 3) When combining data from multiple tables: join results, races, and circuits tables instead of querying only races. 4) When filtering for the Austrian Grand Prix: use T2.name = 'Austrian Grand Prix' instead of 'Austrian Grand Prix Circuit'. 5) When finding the fastest lap record: use MIN(fastest_lap_times.time_in_seconds) to identify the minimum lap time. 6) When joining tables: use proper join conditions with raceId and driverId columns instead of driver name matching. 7) When retrieving pit stop duration: get duration from pitStops table instead of pit_stop_time from races.",
            "1) When answering about the fastest lap time: use the \"results\" table with \"FastestLapTime\" column instead of \"lapTimes\" table with \"time\" column. 2) When converting time format: handle only the MM:SS.fff format and calculate as (minutes*60) + seconds + (milliseconds/1000) instead of complex string parsing. 3) When filtering for valid fastest lap times: ensure FastestLapTime IS NOT NULL. 4) When finding the minimum time: use a subquery to find the minimum time instead of GROUP BY with MIN aggregation. 5) When joining on the calculated time: match the minimum time instead of grouping by race and driver. 6) When filtering races by circuit name: use T2.name = 'Austrian Grand Prix' instead of c.name = 'Austrian Grand Prix'. 7) When selecting from CTE: only select raceId and driverId instead of including the time value. 8) When joining with pitStops: join directly with pitStops table instead of using additional CTE layers."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT pit_stop_time FROM races WHERE driver_name = (SELECT driver_name FROM lap_records WHERE circuit = 'Austrian Grand Prix Circuit') AND race_name = 'Austrian Grand Prix Circuit';",
            "WITH fastest_lap_times AS (\n    SELECT \n        lt.raceId,\n        lt.driverId,\n        lt.lap,\n        lt.time,\n        CAST(\n            CASE \n                WHEN lt.time LIKE '%:%:%' THEN \n                    (CAST(SUBSTR(lt.time, 1, INSTR(lt.time, ':') - 1) AS REAL) * 60) + \n                    CAST(SUBSTR(lt.time, INSTR(lt.time, ':') + 1, INSTR(SUBSTR(lt.time, INSTR(lt.time, ':') + 1), ':') - 1) AS REAL) + \n                    CAST(SUBSTR(lt.time, INSTR(lt.time, ':', INSTR(lt.time, ':') + 1) + 1) AS REAL)\n                WHEN lt.time LIKE '%:%' THEN \n                    CAST(SUBSTR(lt.time, 1, INSTR(lt.time, ':') - 1) AS REAL) + \n                    CAST(SUBSTR(lt.time, INSTR(lt.time, ':') + 1) AS REAL) / 60\n                ELSE CAST(lt.time AS REAL)\n            END AS REAL\n        ) AS time_in_seconds\n    FROM lapTimes lt\n),\nlap_record_race AS (\n    SELECT \n        flt.raceId,\n        flt.driverId,\n        MIN(flt.time_in_seconds) AS fastest_lap_time\n    FROM fastest_lap_times flt\n    JOIN races r ON flt.raceId = r.raceId\n    JOIN circuits c ON r.circuitId = c.circuitId\n    WHERE c.name = 'Austrian Grand Prix'\n    GROUP BY flt.raceId, flt.driverId\n    ORDER BY fastest_lap_time ASC\n    LIMIT 1\n)\nSELECT \n    ps.duration\nFROM pitStops ps\nJOIN lap_record_race lrr ON ps.raceId = lrr.raceId AND ps.driverId = lrr.driverId\nORDER BY ps.stop ASC\nLIMIT 1;",
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        CAST(SUBSTR(r.FastestLapTime, 1, INSTR(r.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, ':') + 1, INSTR(r.FastestLapTime, '.') - INSTR(r.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(r.FastestLapTime, INSTR(r.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results r\n    JOIN races rc ON r.raceId = rc.raceId\n    JOIN circuits c ON rc.circuitId = c.circuitId\n    WHERE c.name = 'Red Bull Ring'\n    AND r.FastestLapTime IS NOT NULL\n),\nlap_record_race AS (\n    SELECT \n        raceId,\n        driverId\n    FROM fastest_lap_times\n    WHERE time_in_seconds = (SELECT MIN(time_in_seconds) FROM fastest_lap_times)\n)\nSELECT ps.duration\nFROM pitStops ps\nJOIN lap_record_race lrr ON ps.raceId = lrr.raceId AND ps.driverId = lrr.driverId;"
        ],
        "rule_sql": [
            "WITH fastest_lap_times AS (\n    SELECT \n        r.raceId,\n        r.driverId,\n        CAST(SUBSTR(res.FastestLapTime, 1, INSTR(res.FastestLapTime, ':') - 1) AS REAL) * 60 +\n        CAST(SUBSTR(res.FastestLapTime, INSTR(res.FastestLapTime, ':') + 1, INSTR(res.FastestLapTime, '.') - INSTR(res.FastestLapTime, ':') - 1) AS REAL) +\n        CAST(SUBSTR(res.FastestLapTime, INSTR(res.FastestLapTime, '.') + 1) AS REAL) / 1000 AS time_in_seconds\n    FROM results res\n    JOIN races r ON res.raceId = r.raceId\n    JOIN circuits c ON r.circuitId = c.circuitId\n    WHERE res.FastestLapTime IS NOT NULL\n    AND c.name = 'Red Bull Ring'\n),\nlap_record_race AS (\n    SELECT \n        raceId,\n        driverId\n    FROM fastest_lap_times\n    WHERE time_in_seconds = (SELECT MIN(time_in_seconds) FROM fastest_lap_times)\n)\nSELECT \n    ps.duration\nFROM pitStops ps\nJOIN lap_record_race lrr ON ps.raceId = lrr.raceId AND ps.driverId = lrr.driverId;"
        ],
        "amend_res": 1
    },
    "1284": {
        "db_id": "thrombosis_prediction",
        "question": "For the patient with the highest lactate dehydrogenase in the normal range, when was his or her data first recorded?",
        "ground_truth": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH < 500 ORDER BY T2.LDH ASC LIMIT 1",
        "amends": [
            "Do select `T1.First Date` instead of `MIN(record_date)` and do add explicit table aliases instead of omitting them. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table and do reference `Laboratory` table instead of only `patient_data`. Do filter with `T2.LDH < 500` instead of `lactate_dehydrogenase <= 250` and do remove the subquery condition instead of using a correlated subquery. Do add `ORDER BY T2.LDH ASC` instead of omitting ordering and do add `LIMIT 1` instead of using aggregate functions. The amended query now correctly retrieves the earliest date for patients with LDH values below 500 from joined Patient and Laboratory tables."
        ],
        "rules": [
            "1) When answering about the patient with the highest lactate dehydrogenase in the normal range: use T1 as alias for Patient table and T2 as alias for Laboratory table. 2) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID using inner join and keep only matching pairs. 3) When filtering for lactate dehydrogenase in normal range: use T2.LDH < 500 instead of lactate_dehydrogenase <= 250. 4) When finding the highest value within the normal range: order by T2.LDH ASC and take the first row using LIMIT 1. 5) When retrieving the first recorded date: select T1.First Date instead of MIN(record_date). 6) When handling identifier delimiters: do not replace double quotes with backticks or unquoted forms for any table or column names."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MIN(record_date) FROM patient_data WHERE lactate_dehydrogenase = (SELECT MAX(lactate_dehydrogenase) FROM patient_data WHERE lactate_dehydrogenase <= 250);",
            "SELECT T1.`First Date`\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.LDH < 500\nORDER BY T2.LDH ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.\"First Date\"\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.LDH < 500\nORDER BY T2.LDH ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "300": {
        "db_id": "toxicology",
        "question": "What atoms comprise TR186?",
        "ground_truth": "SELECT T.atom_id FROM atom AS T WHERE T.molecule_id = 'TR186'",
        "amends": [
            "Do reference the table with alias `T` instead of using the bare table name. Do select `atom_id` instead of `atom_name` to return the correct column. Do use the full table name `atom` instead of `atoms` to reference the proper table. The amended query now correctly retrieves atom identifiers for the specified molecule."
        ],
        "rules": [
            "1) When answering about \"atoms comprise TR186\": make sure the output order: atom_id. 2) When the question mentions \"TR186\": \"TR186\" actually means \"molecule_id = 'TR186'\" in schema. 3) When selecting from the atom table: use the exact table name \"atom\" (not \"atoms\") and alias it as \"T\". 4) When returning atom identifiers: select the exact column \"atom_id\" (not \"atom_name\") from table T."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT atom_name FROM atoms WHERE molecule_id = 'TR186';",
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id = 'TR186';"
        ],
        "rule_sql": [
            "SELECT T.atom_id FROM atom T WHERE T.molecule_id = 'TR186' ORDER BY T.atom_id"
        ],
        "amend_res": 1
    },
    "1267": {
        "db_id": "thrombosis_prediction",
        "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
        "amends": [
            "Do select `COUNT(T1.ID)` from specific columns instead of `COUNT(*)` from all rows. Do use `Examination AS T1` and `Laboratory AS T2` as source tables with an `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T2.SM IN ('negative','0')` instead of `anti_sm = 'normal'` and `T1.Thrombosis = 0` instead of `thrombosis IS NULL`. The amended query now correctly joins examination and laboratory data while using proper value comparisons instead of null checks, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patients with normal anti-SM: use \"T2.SM IN ('negative','0')\" instead of \"anti_sm = 'normal'\" to identify normal anti-SM status. 2) When counting patients who do not have thrombosis: use \"T1.Thrombosis = 0\" instead of checking for NULL values. 3) When combining examination and laboratory data: perform an inner join between \"Examination AS T1\" and \"Laboratory AS T2\" using \"T1.ID = T2.ID\" to link patient records. 4) When counting patients: use \"COUNT(T1.ID)\" instead of \"COUNT(*)\" to count based on the patient identifier key."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE anti_sm = 'normal' AND thrombosis IS NULL;",
            "SELECT COUNT(T1.ID) \nFROM Examination AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.SM IN ('negative', '0') \nAND T1.Thrombosis = 0"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Examination AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.SM IN ('negative', '0') \nAND T1.Thrombosis = 0"
        ],
        "amend_res": 1
    },
    "1138": {
        "db_id": "european_football_2",
        "question": "In what country did the Poland Ekstraklasa take place?",
        "evidence": "",
        "ground_truth": "SELECT name FROM Country WHERE id IN ( SELECT country_id FROM League WHERE name = 'Poland Ekstraklasa' )",
        "amends": [
            "Do select `name` from the `Country` table instead of `country` from the `leagues` table. Do use a subquery with `SELECT country_id FROM League` filtered by `name = 'Poland Ekstraklasa'` instead of directly querying the `leagues` table. Do reference the correct table names `Country` and `League` instead of the incorrect `leagues` table. The amended query now correctly retrieves the country name by first finding the country_id from the League table and then looking up the corresponding name in the Country table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about the country where a league takes place: use the \"name\" column from the \"Country\" table to get the country name. 2) When the question mentions a specific league name like \"Poland Ekstraklasa\": first find the country_id from the \"League\" table where name = 'Poland Ekstraklasa'. 3) When combining information from \"League\" and \"Country\" tables: use the country_id from \"League\" to match with the corresponding record in \"Country\" table to get the country name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM leagues WHERE name = 'Poland Ekstraklasa';",
            "SELECT c.name \nFROM Country c\nWHERE c.id = (SELECT l.country_id FROM League l WHERE l.name = 'Poland Ekstraklasa')"
        ],
        "rule_sql": [
            "SELECT c.name \nFROM Country c\nJOIN League l ON c.id = l.country_id\nWHERE l.name = 'Poland Ekstraklasa';"
        ],
        "amend_res": 1
    },
    "560": {
        "db_id": "codebase_community",
        "question": "Give the number of \"Revival\" badges.",
        "ground_truth": "SELECT COUNT(Id) FROM badges WHERE Name = 'Revival'",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM badges WHERE name = 'Revival'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS NumberOfRevivalBadges FROM badges WHERE Name = 'Revival';"
        ],
        "amend_res": 1
    },
    "40": {
        "db_id": "california_schools",
        "question": "What is the telephone number for the school with the lowest average score in reading in Fresno Unified?",
        "ground_truth": "SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.District = 'Fresno Unified' AND T1.AvgScrRead IS NOT NULL ORDER BY T1.AvgScrRead ASC LIMIT 1",
        "amends": [
            "Do select `T2.Phone` from the `schools` table instead of `telephone` from `schools` alone. Do add an `INNER JOIN` with `satscores AS T1` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do add a filter `T1.AvgScrRead IS NOT NULL` in the `WHERE` clause instead of omitting this null check. Do order by `T1.AvgScrRead` instead of `reading_score` to use the joined table's column. The amended query now correctly joins the necessary tables and filters out null reading scores to match the intended behavior."
        ],
        "rules": [
            "1) When answering about telephone numbers for schools: use T2.Phone from the schools table instead of telephone. 2) When combining schools and satscores tables: link rows where T1.cds = T2.CDSCode and keep only matching pairs (inner match). 3) When filtering for reading scores: ensure T1.AvgScrRead IS NOT NULL to exclude null reading scores. 4) When ordering by reading performance: use T1.AvgScrRead to sort by average reading score instead of reading_score. 5) When finding the lowest average reading score: order by T1.AvgScrRead in ascending direction and keep the first row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT telephone FROM schools WHERE district = 'Fresno Unified' ORDER BY reading_score ASC LIMIT 1;",
            "SELECT T2.Phone \nFROM schools AS T2\nINNER JOIN satscores AS T1 ON T1.cds = T2.CDSCode\nWHERE T2.District = 'Fresno Unified' \nAND T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Phone\nFROM satscores T1\nINNER JOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE T2.District = 'Fresno Unified'\nAND T1.AvgScrRead IS NOT NULL\nORDER BY T1.AvgScrRead ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "331": {
        "db_id": "toxicology",
        "question": "How many of the molecules are carcinogenic?",
        "ground_truth": "SELECT COUNT(T.molecule_id) FROM molecule AS T WHERE T.label = '+'",
        "amends": [
            "Do select `COUNT(T.molecule_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference the table with alias `T` instead of the bare table name `molecules` for clarity. Do use the table name `molecule` instead of `molecules` to match the correct schema. Do filter on `T.label = '+'` instead of `carcinogenic = 'yes'` to use the appropriate column and value for identifying positive cases. The amended query now correctly counts molecules with positive labels instead of using incorrect column semantics."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(T.molecule_id) to count specific non-null values rather than all rows. 2) When referencing the molecule table: use alias T instead of the bare table name for clarity. 3) When identifying carcinogenic molecules: filter on T.label = '+' instead of carcinogenic = 'yes' to use the appropriate column and value for positive cases. 4) When using table names: use molecule instead of molecules to match the correct schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE carcinogenic = 'yes';",
            "SELECT COUNT(T.molecule_id) FROM molecule T WHERE T.label = '+'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.molecule_id) FROM molecule T WHERE T.label = '+';"
        ],
        "amend_res": 1
    },
    "399": {
        "db_id": "card_games",
        "question": "Lists all types of cards available in arena.",
        "ground_truth": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
        "amends": [
            "Do select specific columns `subtypes` and `supertypes` instead of selecting all columns with `*`. Do add `DISTINCT` to remove duplicate rows instead of returning all matches. Do change the table source filter to use column `availability` with value `'arena'` instead of filtering on column `arena` with value `'available'`. Do add explicit NULL checks with `subtypes IS NOT NULL` and `supertypes IS NOT NULL` instead of omitting these filters. The amended query now correctly filters for Arena availability while ensuring non-null card type classifications and returns only unique combinations."
        ],
        "rules": [
            "1) When selecting card types from the cards table: return only the specific columns \"subtypes\" and \"supertypes\" instead of all columns. 2) When listing all types of cards: remove duplicate rows by using DISTINCT on the combination of \"subtypes\" and \"supertypes\". 3) When filtering for Arena availability: use the column \"availability\" with the exact literal value 'arena' instead of filtering on column \"arena\". 4) When ensuring valid card type classifications: add explicit filters for \"subtypes IS NOT NULL\" and \"supertypes IS NOT NULL\" to exclude null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM cards WHERE arena = 'available';",
            "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL;"
        ],
        "rule_sql": [
            "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL;"
        ],
        "amend_res": 1
    },
    "981": {
        "db_id": "formula_1",
        "question": "On what year did the youngest driver had his first qualifying race? Also state the name, date and time of the race.",
        "ground_truth": "SELECT T3.year, T3.name, T3.date, T3.time FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 on T1.raceId = T3.raceId WHERE T1.driverId = ( SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1 ) ORDER BY T3.date ASC LIMIT 1",
        "amends": [
            "Do join `qualifying` as `T1` and `drivers` as `T2` on `T1.driverId = T2.driverId` instead of only joining `drivers` and `races`. Do then join `races` as `T3` on `T1.raceId = T3.raceId` instead of directly joining drivers to races. Do use the filter `T1.driverId = (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1)` instead of `d.age = (SELECT MIN(age) FROM drivers)` to find the youngest driver by date of birth rather than minimum age. Do select columns from `T3` (`year`, `name`, `date`, `time`) instead of from individual tables `d` and `r`. The amended query now correctly joins through the qualifying table to connect drivers to races and uses proper date-based identification of the youngest driver, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about the youngest driver's first qualifying race: join qualifying as T1 and drivers as T2 on T1.driverId = T2.driverId, then join races as T3 on T1.raceId = T3.raceId. 2) When identifying the youngest driver: use T1.driverId = (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1) to find the driver with the most recent date of birth. 3) When selecting output columns: choose T3.year, T3.name, T3.date, and T3.time from the races table. 4) When handling the qualifying race relationship: ensure the connection is made through the qualifying table (T1) rather than directly between drivers and races."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT d.year, d.name, r.date, r.time \nFROM drivers d \nJOIN races r ON d.driver_id = r.driver_id \nWHERE d.age = (SELECT MIN(age) FROM drivers) \nORDER BY r.date ASC \nLIMIT 1;",
            "SELECT T3.year, T3.name, T3.date, T3.time\nFROM qualifying AS T1\nJOIN drivers AS T2 ON T1.driverId = T2.driverId\nJOIN races AS T3 ON T1.raceId = T3.raceId\nWHERE T1.driverId = (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1)\nORDER BY T3.date ASC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T3.year, T3.name, T3.date, T3.time \nFROM qualifying AS T1 \nJOIN drivers AS T2 ON T1.driverId = T2.driverId \nJOIN races AS T3 ON T1.raceId = T3.raceId \nWHERE T1.driverId = (SELECT driverId FROM drivers ORDER BY dob DESC LIMIT 1) \nORDER BY T3.date ASC \nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "900": {
        "db_id": "formula_1",
        "question": "List circuits in USA which hosted f1 races in 2006. State the name and location of circuit and the name of the race it hosted.",
        "evidence": "",
        "ground_truth": "SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.country = 'USA' AND T2.year = 2006",
        "amends": [],
        "rules": [],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.location, r.name \nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE c.country = 'USA' AND r.year = 2006;"
        ],
        "rule_sql": [
            "SELECT c.name AS circuit_name, c.location, r.name AS race_name\nFROM circuits c\nJOIN races r ON c.circuitId = r.circuitId\nWHERE c.country = 'USA' AND r.year = 2006\nORDER BY c.name;"
        ],
        "amend_res": 1
    },
    "1143": {
        "db_id": "european_football_2",
        "question": "What was the highest score of the home team in the Netherlands Eredivisie league?",
        "ground_truth": "SELECT MAX(t2.home_team_goal) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Netherlands Eredivisie'",
        "amends": [
            "Do select `MAX(t2.home_team_goal)` from the Match table instead of `MAX(away_score)` from a non-existent column. Do join `League AS t1` and `Match AS t2` with `INNER JOIN` on `t1.id = t2.league_id` instead of querying a single table without proper joins. Do filter on `t1.name = 'Netherlands Eredivisie'` in the League table instead of `league = 'Netherlands Eredivisie'` in a table that lacks proper league identification. The amended query now correctly retrieves maximum home goals from the appropriate league by establishing the proper table relationships and using the correct column references."
        ],
        "rules": [
            "1) When answering about \"highest score of the home team\": make sure the output order: MAX(t2.home_team_goal). 2) When the question mentions \"Netherlands Eredivisie league\": \"Netherlands Eredivisie\" actually means \"t1.name = 'Netherlands Eredivisie'\" in schema. 3) When combining League AS t1 and Match AS t2 for shared entities: link rows where the canonical keys are equal exactly as shown in the amends (t1.id = t2.league_id); keep only matching pairs (inner match). 4) When the question asks for \"highest score\": rank rows by t2.home_team_goal in descending direction and keep the first 1 row."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(away_score) FROM matches WHERE league = 'Netherlands Eredivisie';",
            "SELECT MAX(t2.home_team_goal) AS highest_home_score\nFROM Match AS t2\nINNER JOIN League AS t1 ON t1.id = t2.league_id\nWHERE t1.name = 'Netherlands Eredivisie'"
        ],
        "rule_sql": [
            "SELECT MAX(t2.home_team_goal) AS highest_home_score\nFROM Match AS t2\nINNER JOIN League AS t1 ON t1.id = t2.league_id\nWHERE t1.name = 'Netherlands Eredivisie'\nORDER BY t2.home_team_goal DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "967": {
        "db_id": "formula_1",
        "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
        "ground_truth": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
        "amends": [
            "Do use a subquery to select `nationality` from `drivers` instead of selecting `state_code` and `COUNT(*)` directly. Do order by `JULIANDAY(dob)` in descending order instead of ordering by `age` in ascending order. Do apply a limit of 3 within the subquery instead of applying it to the outer query. Do filter for `nationality = 'Dutch'` in the outer query instead of filtering for `nationality = 'Netherlandic'` in the main query. Do remove the `GROUP BY` and aggregation from the outer query instead of counting all rows. The amended query now correctly counts how many of the three oldest drivers have Dutch nationality, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"top 3 youngest drivers\": rank drivers by JULIANDAY(dob) in descending order (most recent birth dates first) and keep the first 3 rows. 2) When the question mentions \"Netherlandic drivers\": \"Netherlandic\" actually means \"Dutch\" in the schema, so use nationality = 'Dutch' exactly. 3) When counting how many drivers among the top 3 youngest have Dutch nationality: count the number of rows where nationality = 'Dutch' within the selected top 3 drivers. 4) When ordering by date of birth: use JULIANDAY(dob) function instead of age column for proper date-based ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT state_code, COUNT(*) \nFROM drivers \nWHERE nationality = 'Netherlandic' \nORDER BY age ASC \nLIMIT 3;",
            "SELECT COUNT(*) AS dutch_count\nFROM (\n    SELECT driverId, code, nationality\n    FROM drivers\n    ORDER BY JULIANDAY(dob) DESC\n    LIMIT 3\n) AS youngest_drivers\nWHERE nationality = 'Dutch';"
        ],
        "rule_sql": [
            "SELECT COUNT(*) AS dutch_count\nFROM (\n    SELECT d.driverId, d.code, d.nationality\n    FROM drivers d\n    WHERE d.dob IS NOT NULL\n    ORDER BY JULIANDAY(d.dob) DESC\n    LIMIT 3\n) AS top_youngest\nWHERE top_youngest.nationality = 'Dutch';"
        ],
        "amend_res": 1
    },
    "1269": {
        "db_id": "thrombosis_prediction",
        "question": "Please list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70.",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SC170 IN ('negative','0') AND T2.Date > 1997-01-01",
        "amends": [
            "Do select `T1.ID` from the `Patient` table instead of `patient_id` from `examinations`. Do join `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `examinations` table. Do filter with `T2.SC170 IN ('negative','0')` instead of `anti_scl70 = 'normal'`. Do use `T2.Date > 1997-01-01` instead of `exam_date > '1997-01-01'` and remove the quotes around the date value. The amended query now correctly joins patient and laboratory data to find patients with specific SC170 test results after 1997, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about patients with specific laboratory tests: select \"T1\".\"ID\" from the \"Patient\" table instead of patient_id from examinations. 2) When combining patient and laboratory data: link rows where \"T1\".\"ID\" = \"T2\".\"ID\" using an inner join between \"Patient\" as T1 and \"Laboratory\" as T2. 3) When filtering for normal anti-scl70 results: use \"T2\".\"SC170\" IN ('negative','0') instead of anti_scl70 = 'normal'. 4) When filtering for dates after 1997/1/1: use \"T2\".\"Date\" > 1997-01-01 (without quotes around the date value) instead of exam_date > '1997-01-01'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM examinations WHERE exam_date > '1997-01-01' AND anti_scl70 = 'normal';",
            "SELECT T1.ID \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date > 1997-01-01 \nAND T2.SC170 IN ('negative', '0')"
        ],
        "rule_sql": [
            "SELECT T1.ID \nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.Date > '1997-01-01' \nAND T2.SC170 IN ('negative', '0')",
            "SELECT DISTINCT T1.ID \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.Date > 1997-01-01 \nAND T2.SC170 IN ('negative', '0')"
        ],
        "amend_res": 1
    },
    "1507": {
        "db_id": "debit_card_specializing",
        "question": "Please list the disparate time of the transactions taken place in the gas stations from chain no. 11.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11",
        "amends": [
            "Do reference `T1.Time` with table alias instead of `time` without qualification. Do add `INNER JOIN gasstations AS T2` instead of omitting the join to the gasstations table. Do use join condition `T1.GasStationID = T2.GasStationID` instead of filtering directly on chain_id. Do move the chain filter to `WHERE T2.ChainID = 11` instead of applying it to the transactions table. Do remove the `location_type = 'gas station'` filter instead of keeping it since the join to gasstations table already ensures this relationship. The amended query now correctly joins through the proper relationship and matches the intended behavior."
        ],
        "rules": [
            "1) When answering about \"disparate time of transactions in gas stations from chain no. 11\": make sure the output order: T1.Time 2) When the question mentions \"transactions taken place in the gas stations\": combine T1 (transactions) and T2 (gasstations) using T1.GasStationID = T2.GasStationID and keep only matching pairs (inner match) 3) When the question mentions \"chain no. 11\": filter to include only rows where T2.ChainID = 11 4) When the question asks for \"disparate time\": select distinct values of T1.Time"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT time FROM transactions WHERE chain_id = 11 AND location_type = 'gas station';",
            "SELECT DISTINCT T1.Time \nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nWHERE T2.ChainID = 11"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.Time \nFROM transactions_1k t1\nINNER JOIN gasstations t2 ON t1.GasStationID = t2.GasStationID\nWHERE t2.ChainID = 11\nORDER BY t1.Time"
        ],
        "amend_res": 1
    },
    "12": {
        "db_id": "california_schools",
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "ground_truth": "SELECT MAX(CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3",
        "amends": [
            "Do use explicit table aliases `T1` and `T2` instead of unspecified table references. Do join tables `frpm` and `satscores` with `INNER JOIN` on `T1.CDSCode = T2.cds` instead of querying a single unspecified table. Do calculate the free rate as `CAST(T1.`Free Meal Count (Ages 5-17)` AS REAL) / T1.`Enrollment (Ages 5-17)` instead of using a precomputed `free_rate` column. Do filter with `CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3` instead of `sat_excellence_rate > 0.3`. Do remove the unnecessary `age = '5-17'` filter instead of keeping it, as the age-specific columns already handle this constraint. The amended query now correctly joins the required tables and calculates both metrics dynamically from the source data."
        ],
        "rules": [
            "1) When answering about schools with SAT excellence rate over 0.3: use T1 for frpm table and T2 for satscores table with inner join on T1.CDSCode = T2.cds. 2) When calculating SAT excellence rate: compute CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3 instead of using a precomputed column. 3) When calculating free rate for students aged 5-17: compute CAST(T1.\"Free Meal Count (Ages 5-17)\" AS REAL) / T1.\"Enrollment (Ages 5-17)\" instead of using a precomputed free_rate column. 4) When filtering by age group: do not add age = '5-17' filter since the age-specific columns \"Free Meal Count (Ages 5-17)\" and \"Enrollment (Ages 5-17)\" already handle this constraint. 5) When finding the highest eligible free rate: use MAX() function on the calculated free rate expression."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT MAX(free_rate) FROM schools WHERE sat_excellence_rate > 0.3 AND age = '5-17';",
            "SELECT MAX(CAST(T1.\"Free Meal Count (Ages 5-17)\" AS REAL) / T1.\"Enrollment (Ages 5-17)\") AS highest_eligible_free_rate\nFROM frpm T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3"
        ],
        "rule_sql": [
            "SELECT MAX(CAST(T1.\"Free Meal Count (Ages 5-17)\" AS REAL) / T1.\"Enrollment (Ages 5-17)\") AS highest_free_rate\nFROM frpm T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nWHERE CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr > 0.3\nAND T1.\"Enrollment (Ages 5-17)\" > 0"
        ],
        "amend_res": 1
    },
    "262": {
        "db_id": "toxicology",
        "question": "Among the single bond molecule id, which molecules are not carcinogenic?",
        "ground_truth": "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'",
        "amends": [
            "Do query from `bond AS T1` and `molecule AS T2` with an `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying only from `molecules`. Do filter on `T2.label = '-'` and `T1.bond_type = '-'` instead of filtering on `bond_type = 'single'` and `carcinogenic = 'yes'`. Do add `DISTINCT` to the `SELECT` clause instead of omitting it. Do select `T1.molecule_id` with table qualification instead of selecting just `molecule_id`. The amended query now correctly joins the bond and molecule tables to find distinct molecule IDs matching specific bond and label conditions."
        ],
        "rules": [
            "1) When answering about molecules with single bonds: query from both bond table as T1 and molecule table as T2 with an inner match on T1.molecule_id = T2.molecule_id instead of querying only from molecules. 2) When filtering for single bond molecules: use T1.bond_type = '-' instead of bond_type = 'single'. 3) When filtering for non-carcinogenic molecules: use T2.label = '-' instead of carcinogenic = 'yes'. 4) When selecting molecule identifiers: use T1.molecule_id with table qualification instead of just molecule_id. 5) When returning distinct molecule IDs: add DISTINCT to ensure unique values are returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM molecules WHERE bond_type = 'single' AND carcinogenic = 'yes';",
            "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T2.label = '-'"
        ],
        "amend_res": 1
    },
    "1076": {
        "db_id": "european_football_2",
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "amends": [
            "Do use a single query with `INNER JOIN` between `Player` and `Player_Attributes` tables on `player_api_id` instead of separate subqueries on a single table. Do calculate averages using conditional aggregation with `SUM(CASE...) / COUNT(CASE...)` instead of separate `AVG` subqueries. Do cast the sums to `REAL` for proper division instead of relying on implicit casting. Do reference `player_name` from the `Player` table and `ball_control` from the `Player_Attributes` table instead of assuming both exist in a single table. Do handle the division properly by counting only relevant records with `COUNT(CASE... ELSE NULL END)` instead of simple averages that might include null values. The amended query now correctly joins the two tables and calculates the difference in ball control averages between the two players using proper conditional aggregation."
        ],
        "rules": [
            "1) When answering about the difference of average ball control scores between two specific players: join the Player table (T1) and Player_Attributes table (T2) where T1.player_api_id equals T2.player_api_id to combine player names with their attributes. 2) When calculating averages for specific players: use conditional aggregation with SUM(CASE WHEN T1.player_name = 'Abdou Diallo' THEN CAST(T2.ball_control AS REAL) ELSE NULL END) / COUNT(CASE WHEN T1.player_name = 'Abdou Diallo' THEN 1 ELSE NULL END) for the first player and similarly for 'Aaron Appindangoye' for the second player. 3) When handling division operations: cast sums to REAL type to ensure proper decimal division instead of integer division. 4) When counting records for averages: use COUNT(CASE... ELSE NULL END) to only count relevant records and exclude null values from the denominator. 5) When referencing player names: use T1.player_name from the Player table with exact literals 'Abdou Diallo' and 'Aaron Appindangoye' including proper capitalization and spacing. 6) When referencing ball control scores: use T2.ball_control from the Player_Attributes table. 7) When combining tables for this question: perform an inner join between Player and Player_Attributes using the exact equality condition T1.player_api_id = T2.player_api_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT AVG(ball_control) FROM players WHERE name = 'Abdou Diallo') - \n    (SELECT AVG(ball_control) FROM players WHERE name = 'Aaron Appindangoye') \nAS difference",
            "SELECT \n    (SUM(CASE WHEN p.player_name = 'Abdou Diallo' THEN pa.ball_control ELSE NULL END) * 1.0 / COUNT(CASE WHEN p.player_name = 'Abdou Diallo' THEN pa.ball_control ELSE NULL END)) - \n    (SUM(CASE WHEN p.player_name = 'Aaron Appindangoye' THEN pa.ball_control ELSE NULL END) * 1.0 / COUNT(CASE WHEN p.player_name = 'Aaron Appindangoye' THEN pa.ball_control ELSE NULL END)) AS ball_control_difference\nFROM \n    Player p\nINNER JOIN \n    Player_Attributes pa ON p.player_api_id = pa.player_api_id\nWHERE \n    p.player_name IN ('Abdou Diallo', 'Aaron Appindangoye');"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN T1.player_name = 'Abdou Diallo' THEN CAST(T2.ball_control AS REAL) ELSE NULL END) / \n     COUNT(CASE WHEN T1.player_name = 'Abdou Diallo' THEN 1 ELSE NULL END)) -\n    (SUM(CASE WHEN T1.player_name = 'Aaron Appindangoye' THEN CAST(T2.ball_control AS REAL) ELSE NULL END) / \n     COUNT(CASE WHEN T1.player_name = 'Aaron Appindangoye' THEN 1 ELSE NULL END)) AS ball_control_difference\nFROM \n    Player T1\nINNER JOIN \n    Player_Attributes T2 ON T1.player_api_id = T2.player_api_id\nWHERE \n    T1.player_name IN ('Abdou Diallo', 'Aaron Appindangoye')"
        ],
        "amend_res": 1
    },
    "77": {
        "db_id": "california_schools",
        "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
        "ground_truth": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
        "amends": [
            "Do select `T2.School` and calculate `FRPM Count (Ages 5-17) * 100 / Enrollment (Ages 5-17)` instead of selecting `school_name` and `percent_eligible_frpm` directly. Do use `FROM frpm AS T1 INNER JOIN schools AS T2` instead of only `FROM schools`. Do join on `T1.CDSCode = T2.CDSCode` instead of no join condition. Do filter on `T2.County = 'Los Angeles'` instead of `county = 'Los Angeles'`. Do filter on `T2.GSserved = 'K-9'` instead of `grade_span = 'Kindergarten to 9th grade'`. Do remove `ORDER BY` instead of keeping it. The amended query now correctly calculates the FRPM percentage by joining the frpm and schools tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about schools and their Percent (%) Eligible FRPM (Ages 5-17): combine data from both \"frpm\" table as T1 and \"schools\" table as T2 using an inner match where T1.CDSCode = T2.CDSCode. 2) When the question mentions \"schools served a grade span of Kindergarten to 9th grade\": filter for rows where T2.GSserved = 'K-9'. 3) When the question mentions \"county of Los Angeles\": filter for rows where T2.County = 'Los Angeles'. 4) When the question asks for \"Percent (%) Eligible FRPM (Ages 5-17)\": calculate it as (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\") instead of selecting a precomputed percentage column. 5) When producing output: return T2.School and the calculated percentage, without any ordering."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, percent_eligible_frpm \nFROM schools \nWHERE county = 'Los Angeles' \nAND grade_span = 'Kindergarten to 9th grade' \nORDER BY percent_eligible_frpm DESC;",
            "SELECT T2.School, (T1.\"FRPM Count (Ages 5-17)\" * 100.0 / T1.\"Enrollment (Ages 5-17)\") AS \"Percent Eligible FRPM\"\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'"
        ],
        "rule_sql": [
            "SELECT T2.School, (T1.\"FRPM Count (Ages 5-17)\" * 100 / T1.\"Enrollment (Ages 5-17)\") AS \"Percent Eligible FRPM (Ages 5-17)\" FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.GSserved = 'K-9' AND T2.County = 'Los Angeles'"
        ],
        "amend_res": 1
    },
    "234": {
        "db_id": "toxicology",
        "question": "How many bonds which involved atom 12 does molecule TR009 have?",
        "ground_truth": "SELECT COUNT(T2.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2'",
        "amends": [
            "Do join `bond AS T1` with `connected AS T2` on `T1.bond_id = T2.bond_id` instead of querying only the `bonds` table. Do filter on `T1.molecule_id = 'TR009'` instead of `molecule_id = 'TR009'`. Do filter on `T2.atom_id = T1.molecule_id || '_1'` and `T2.atom_id2 = T1.molecule_id || '_2'` instead of `atom_id = 12`. Do count `T2.bond_id` instead of `COUNT(*)`. The amended query now correctly counts bonds in the connected table with specific atom ID patterns rather than using a hardcoded atom ID value.",
            "Do use `AND` to combine both atom_id conditions instead of `OR` in the WHERE clause. Do specify `T2.atom_id = T1.molecule_id || '_1'` and `T2.atom_id2 = T1.molecule_id || '_2'` as separate AND conditions instead of using OR between them. The amended query now correctly requires both atom_id conditions to be satisfied simultaneously rather than allowing either condition to fulfill the filter, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about bonds involving atom 12 for molecule TR009: join bond table as T1 with connected table as T2 using T1.bond_id = T2.bond_id. 2) When filtering for molecule TR009: use T1.molecule_id = 'TR009' exactly. 3) When filtering for atom 12: use T2.atom_id = T1.molecule_id || '_1' and T2.atom_id2 = T1.molecule_id || '_2' instead of hardcoded atom_id = 12. 4) When counting bonds: count T2.bond_id instead of using COUNT(*). 5) When combining bond and connected tables: perform an inner join where T1.bond_id = T2.bond_id to keep only matching pairs.",
            "1) When answering about \"bonds which involved atom 12\": make sure the output order: COUNT(T2.bond_id)\n2) When the question mentions \"molecule TR009\": \"TR009\" actually means \"T1.molecule_id = 'TR009'\" in schema\n3) When filtering for bonds involving atom 12: require both T2.atom_id = T1.molecule_id || '_1' AND T2.atom_id2 = T1.molecule_id || '_2' conditions to be satisfied simultaneously\n4) When combining bond and connected tables: link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match)\n5) When counting bonds: compute the number of rows using the canonical key token T2.bond_id"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM bonds WHERE atom_id = 12 AND molecule_id = 'TR009';",
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nJOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND (T2.atom_id = T1.molecule_id || '_1' OR T2.atom_id2 = T1.molecule_id || '_2')",
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nJOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND T2.atom_id = T1.molecule_id || '_1' \nAND T2.atom_id2 = T1.molecule_id || '_2'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.bond_id) \nFROM bond AS T1 \nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id \nWHERE T1.molecule_id = 'TR009' \nAND T2.atom_id = T1.molecule_id || '_1' \nAND T2.atom_id2 = T1.molecule_id || '_2'"
        ],
        "amend_res": 1
    },
    "1213": {
        "db_id": "thrombosis_prediction",
        "question": "Name the ID of the patient who is born on the April 1st, 1982. Is his/her alkaliphophatase (ALP) within normal range?",
        "ground_truth": "SELECT T1.ID , CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'",
        "amends": [
            "Do select `T1.ID` and a `CASE` expression evaluating `T2.ALP` instead of `patient_id` and `alp` directly. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T1.Birthday = '1982-04-01'` instead of `birth_date = '1982-04-01'`. Do remove the `BETWEEN 40 AND 130` filter on `alp` instead of keeping it, as the CASE expression now handles the ALP evaluation. The amended query now correctly joins patient and laboratory data to categorize ALP values and matches the RIGHT_SQL's behavior.",
            "Do use `CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END` instead of `CASE WHEN T2.ALP BETWEEN 40 AND 130 THEN 'Within normal range' ELSE 'Outside normal range' END AS ALP_Status` for the conditional logic and remove the column alias. The amended query now correctly implements the revised ALP threshold check and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patient ID and ALP status: select T1.ID and a CASE expression evaluating T2.ALP instead of patient_id and alp directly. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 using inner join on T1.ID = T2.ID instead of querying only the patients table. 3) When filtering by birth date: use T1.Birthday = '1982-04-01' instead of birth_date = '1982-04-01'. 4) When evaluating ALP values: remove the BETWEEN 40 AND 130 filter on alp and instead use a CASE expression to categorize ALP values.",
            "1) When the question asks about a patient born on April 1st, 1982: filter rows where T1.Birthday equals exactly '1982-04-01'. 2) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID equals T2.ID and keep only matching pairs (inner match). 3) When checking if ALP is within normal range: use the condition T2.ALP < 300 to determine 'normal' status, otherwise 'abNormal'. 4) When answering about patient ID and ALP status: output T1.ID first, followed by the ALP status evaluation without a column alias."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, alp FROM patients WHERE birth_date = '1982-04-01' AND alp BETWEEN 40 AND 130;",
            "SELECT \n    T1.ID,\n    CASE \n        WHEN T2.ALP BETWEEN 40 AND 130 THEN 'Within normal range' \n        ELSE 'Outside normal range' \n    END AS ALP_Status\nFROM \n    Patient AS T1\nINNER JOIN \n    Laboratory AS T2 ON T1.ID = T2.ID\nWHERE \n    T1.Birthday = '1982-04-01';",
            "SELECT T1.ID, \n       CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.Birthday = '1982-04-01'"
        ],
        "rule_sql": [
            "SELECT T1.ID, CASE WHEN T2.ALP < 300 THEN 'normal' ELSE 'abNormal' END FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1982-04-01'"
        ],
        "amend_res": 1
    },
    "566": {
        "db_id": "codebase_community",
        "question": "For the owner user of post No. 65041, what is his/her reputation points?",
        "ground_truth": "SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041",
        "amends": [
            "Do use an `INNER JOIN` between `users` and `posts` tables on `T1.Id = T2.OwnerUserId` instead of a subquery with `user_id = (SELECT owner_user_id FROM posts)`. Do reference the joined table with aliases `T1` and `T2` instead of no aliases. Do filter directly on `T2.Id = 65041` in the WHERE clause instead of using a subquery predicate. Do select `T1.Reputation` with proper table qualification instead of just `reputation`. The amended query now correctly joins the tables and filters on the post ID to retrieve the user's reputation."
        ],
        "rules": [
            "1) When combining users and posts tables: link rows where T1.Id equals T2.OwnerUserId exactly as shown and keep only matching pairs (inner match). 2) When filtering for a specific post: use T2.Id = 65041 to identify the exact post. 3) When selecting reputation points: use T1.Reputation with proper table qualification instead of just reputation. 4) When answering about the owner user of post No. 65041: make sure the output order includes only the reputation points value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT reputation FROM users WHERE user_id = (SELECT owner_user_id FROM posts WHERE post_id = 65041);",
            "SELECT T1.Reputation \nFROM users T1\nINNER JOIN posts T2 ON T1.Id = T2.OwnerUserId\nWHERE T2.Id = 65041"
        ],
        "rule_sql": [
            "SELECT u.Reputation FROM users u INNER JOIN posts p ON u.Id = p.OwnerUserId WHERE p.Id = 65041"
        ],
        "amend_res": 1
    },
    "285": {
        "db_id": "toxicology",
        "question": "Name chemical elements that form a bond TR001_10_11.",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR001_10_11'",
        "amends": [
            "Do select `element` from table `atom` instead of `element_name` from `chemical_elements`. Do add `INNER JOIN` on `connected` with predicate `T1.atom_id = T2.atom_id` instead of omitting this table. Do add `INNER JOIN` on `bond` with predicate `T2.bond_id = T3.bond_id` instead of omitting this table. Do filter on `T3.bond_id` instead of `bond_id` from the original single table. The amended query now correctly joins through the relationship chain to find elements associated with the specified bond ID."
        ],
        "rules": [
            "1) When answering about \"chemical elements that form a bond TR001_10_11\": select \"element\" from table \"atom\" (T1) instead of \"element_name\" from \"chemical_elements\". 2) When combining tables for this relationship: add an INNER JOIN on \"connected\" (T2) with predicate T1.atom_id = T2.atom_id. 3) When combining tables for this relationship: add an INNER JOIN on \"bond\" (T3) with predicate T2.bond_id = T3.bond_id. 4) When filtering for bond TR001_10_11: filter on T3.bond_id = 'TR001_10_11' instead of bond_id from the original single table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element_name FROM chemical_elements WHERE bond_id = 'TR001_10_11';",
            "SELECT DISTINCT a.element \nFROM atom a\nINNER JOIN connected c ON a.atom_id = c.atom_id\nINNER JOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR001_10_11'"
        ],
        "rule_sql": [
            "SELECT DISTINCT a.element \nFROM atom a\nINNER JOIN connected c ON a.atom_id = c.atom_id\nINNER JOIN bond b ON c.bond_id = b.bond_id\nWHERE b.bond_id = 'TR001_10_11'"
        ],
        "amend_res": 1
    },
    "774": {
        "db_id": "superhero",
        "question": "Which group does superhero A-Bomb belong to?",
        "ground_truth": "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'",
        "amends": [
            "Do select `T2.race` instead of `group_name` and change the source table to `superhero AS T1` instead of `superheroes`. Do add an `INNER JOIN` on `race AS T2` with predicate `T1.race_id = T2.id` instead of querying a single table. Do use filter `T1.superhero_name = 'A-Bomb'` instead of `name = 'A-Bomb'` to reference the correct column name. The amended query now correctly joins tables to retrieve race information and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about a superhero's group: use \"T2.race\" instead of \"group_name\" as the output column. 2) When querying for superhero information: use table \"superhero AS T1\" instead of \"superheroes\". 3) When retrieving group/race information for a superhero: perform an inner join between \"superhero AS T1\" and \"race AS T2\" where \"T1.race_id = T2.id\". 4) When filtering by superhero name: use the exact column \"T1.superhero_name\" and literal value \"'A-Bomb'\" with exact case and punctuation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT group_name FROM superheroes WHERE name = 'A-Bomb';",
            "SELECT T2.race \nFROM superhero AS T1 \nINNER JOIN race AS T2 ON T1.race_id = T2.id \nWHERE T1.superhero_name = 'A-Bomb'"
        ],
        "rule_sql": [
            "SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'"
        ],
        "amend_res": 1
    },
    "1272": {
        "db_id": "thrombosis_prediction",
        "question": "Which patient is the first patient with an abnormal anti-SSA to come to the hospital? Please give his or her ID.",
        "ground_truth": "SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`First Date` IS NOT NULL AND T2.SSA NOT IN ('negative', '0') ORDER BY T1.`First Date` ASC LIMIT 1",
        "amends": [
            "Do select `T1.ID` instead of `patient_id`. Do join `Patient AS T1` and `Laboratory AS T2` with `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter with `T1.First Date IS NOT NULL` instead of omitting this condition. Do filter with `T2.SSA NOT IN ('negative', '0')` instead of `anti_ssa = 'abnormal'`. Do order by `T1.First Date ASC` instead of `visit_date ASC`. The amended query now correctly joins patient and laboratory data, applies proper null handling, and uses appropriate exclusion criteria for SSA values to match the intended behavior.",
            "Do use backticks for the column name `First Date` instead of writing it as two separate words without proper quoting. Do maintain the same SELECT list with `T1.ID`, FROM sources with `Patient AS T1` and `Laboratory AS T2`, INNER JOIN condition on `T1.ID = T2.ID`, WHERE filters for `T1.First Date IS NOT NULL` and `T2.SSA NOT IN ('negative', '0')`, ORDER BY `T1.First Date ASC`, and LIMIT 1 instead of changing any of these elements. The amended query now correctly handles the column name with spaces using proper quoting and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"first patient with an abnormal anti-SSA\": make sure the output order: T1.ID. 2) When the question mentions \"patient ID\": \"patient_id\" actually means \"T1.ID in schema\". 3) When combining Patient as T1 and Laboratory as T2 for shared entities: link rows where T1.ID = T2.ID exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for patients who came to the hospital: include only rows where T1.First Date IS NOT NULL. 5) When filtering for abnormal anti-SSA: include only rows where T2.SSA NOT IN ('negative', '0') instead of using 'abnormal' literal. 6) When the question asks for \"first patient\": order rows by T1.First Date ASC and keep the first 1 row.",
            "1) When the question asks for the first patient by date: order results by the exact column \"First Date\" in ascending order and take only the first row. 2) When the question mentions \"abnormal anti-SSA\": filter Laboratory results where the exact column \"SSA\" is not in the literal values 'negative' or '0'. 3) When combining Patient and Laboratory tables: link rows where the exact column \"ID\" from both tables are equal using an inner match. 4) When handling column names with spaces: use backticks to quote the exact column name `First Date` as shown in the schema. 5) When selecting output: return only the exact column `T1.ID` from the Patient table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE anti_ssa = 'abnormal' ORDER BY visit_date ASC LIMIT 1;",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.First Date IS NOT NULL\nAND T2.SSA NOT IN ('negative', '0')\nORDER BY T1.First Date ASC\nLIMIT 1;",
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.`First Date` IS NOT NULL\nAND T2.SSA NOT IN ('negative', '0')\nORDER BY T1.`First Date` ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.ID\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.`First Date` IS NOT NULL\nAND T2.SSA NOT IN ('negative', '0')\nORDER BY T1.`First Date` ASC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1330": {
        "db_id": "student_club",
        "question": "What college offers the major that Tyler Hewitt took?",
        "evidence": "",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'",
        "amends": [
            "Do select `T2.college` instead of `college_name` from the `students` table. Do use `member AS T1` and `major AS T2` as source tables instead of just `students`. Do add an `INNER JOIN` on `T1.link_to_major = T2.major_id` instead of querying a single table. Do filter with `T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'` instead of `student_name = 'Tyler Hewitt'` to properly match separate first and last name fields. The amended query now correctly joins member and major tables to retrieve college information based on the proper name matching logic."
        ],
        "rules": [
            "1) When the question asks about a college offering a major taken by a specific person: use \"member\" as T1 and \"major\" as T2 as source tables instead of a single students table. 2) When combining T1 and T2 for shared entities: link rows where T1.link_to_major = T2.major_id and keep only matching pairs (inner match). 3) When the question mentions a person's full name \"Tyler Hewitt\": use separate first and last name fields with T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt' instead of a single student_name field. 4) When answering about what college offers the major: make sure the output column is T2.college instead of college_name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT college_name FROM students WHERE student_name = 'Tyler Hewitt'",
            "SELECT T2.college \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'"
        ],
        "rule_sql": [
            "SELECT T2.college FROM member AS T1 JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Tyler' AND T1.last_name = 'Hewitt'"
        ],
        "amend_res": 1
    },
    "290": {
        "db_id": "toxicology",
        "question": "Which toxic element can be found in the molecule TR151?",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'",
        "amends": [
            "Do select `T.element` with table alias qualification instead of `element` without qualification. Do query from `atom AS T` table instead of `toxic_elements` table. Do filter on `T.molecule_id = 'TR151'` instead of `molecule_name = 'TR151'`. Do add `DISTINCT` to eliminate duplicates instead of omitting it. The amended query now correctly retrieves distinct elements from the atom table filtered by molecule_id rather than incorrectly querying from a non-existent toxic_elements table with the wrong filter condition, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about toxic elements in molecule TR151: make sure the output order: T.element 2) When the question mentions \"toxic element\": \"toxic element\" actually means \"element in schema\" from table atom 3) When the question mentions molecule TR151: use literal value 'TR151' exactly as shown 4) When querying from the atom table: use alias T for the atom table 5) When filtering for molecule TR151: use condition T.molecule_id = 'TR151' 6) When selecting elements: use T.element with table alias qualification instead of unqualified element 7) When eliminating duplicate elements: add DISTINCT to the selection 8) When handling text literals: preserve exact case and formatting of 'TR151'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM toxic_elements WHERE molecule_name = 'TR151';",
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR151'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T.element FROM atom T WHERE T.molecule_id = 'TR151'"
        ],
        "amend_res": 1
    },
    "1356": {
        "db_id": "student_club",
        "question": "Which department was the President of the club in?",
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'",
        "amends": [
            "Do use `T2.department` from the joined `major` table instead of `department` from the `club_members` table. Do add `INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id` instead of querying only the `club_members` table. Do reference `member AS T1` instead of `club_members` as the main table. Do use `T1.position` filter instead of directly filtering on the original table. The amended query now correctly joins the member and major tables to retrieve department information from the appropriate source."
        ],
        "rules": [
            "1) When answering about \"which department was the President of the club in\": make sure the output order: T2.department. 2) When the question mentions \"department\": \"department\" actually means \"T2.department in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.link_to_major = T2.major_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for position: use T1.position = 'President' with exact case and spacing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT department FROM club_members WHERE position = 'President';",
            "SELECT T2.department \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T1.position = 'President'"
        ],
        "rule_sql": [
            "SELECT T2.department \nFROM member T1 \nINNER JOIN major T2 ON T1.link_to_major = T2.major_id \nWHERE T1.position = 'President'"
        ],
        "amend_res": 1
    },
    "983": {
        "db_id": "formula_1",
        "question": "Which of the Italian constructor got the highest point to date? Give its introduction website?",
        "ground_truth": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1",
        "amends": [
            "Do select `T1.url` instead of `constructor, MAX(points) as highest_points, website`. Do use `INNER JOIN` with `constructorStandings AS T2` on `T1.constructorId = T2.constructorId` instead of querying only the `constructors` table. Do filter by `T1.nationality = 'Italian'` instead of `nationality = 'Italian'`. Do order by `T2.points DESC` instead of `highest_points DESC`. Do remove the `GROUP BY constructor` clause instead of keeping it. The amended query now correctly joins the constructors and constructorStandings tables to find the Italian constructor with the highest points, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"Italian constructor with highest points\": make sure the output order: constructor's website (T1.url). 2) When combining constructors and constructorStandings tables: link rows where T1.constructorId = T2.constructorId and keep only matching pairs (inner match). 3) When filtering by nationality: use T1.nationality = 'Italian' exactly as specified. 4) When finding the highest points: order by T2.points DESC and take only the top result. 5) When the question asks for the constructor's website: select T1.url as the website field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT constructor, MAX(points) as highest_points, website FROM constructors WHERE nationality = 'Italian' GROUP BY constructor ORDER BY highest_points DESC LIMIT 1;",
            "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T1.url\nFROM constructors T1\nINNER JOIN constructorStandings T2 ON T1.constructorId = T2.constructorId\nWHERE T1.nationality = 'Italian'\nORDER BY T2.points DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "1427": {
        "db_id": "student_club",
        "question": "What are the budget category of the events located at MU 215 and a guest speaker type with a 0 budget spent?",
        "ground_truth": "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T2.spent = 0 AND T1.type = 'Guest Speaker'",
        "amends": [
            "Do select `T2.category` and `T1.type` instead of only `budget_category`. Do use `DISTINCT` instead of omitting it. Do join `event AS T1` with `budget AS T2` using `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only the `events` table. Do filter on `T1.location = 'MU 215'` instead of `location = 'MU 215'`. Do filter on `T2.spent = 0` instead of `budget_spent = 0`. Do filter on `T1.type = 'Guest Speaker'` instead of `guest_speaker_type = 0`. The amended query now correctly retrieves distinct category and type values from joined tables with proper filtering conditions."
        ],
        "rules": [
            "1) When answering about budget categories and types for events: make sure the output order includes both T2.category and T1.type. 2) When the question mentions \"budget category\": \"budget category\" actually means \"T2.category in schema\". 3) When the question mentions \"guest speaker type\": \"guest speaker type\" actually means \"T1.type = 'Guest Speaker' in schema\". 4) When combining event AS T1 and budget AS T2: link rows where T1.event_id = T2.link_to_event exactly as shown; keep only matching pairs (inner match). 5) When filtering for location: use T1.location = 'MU 215' exactly as specified. 6) When filtering for budget spent: use T2.spent = 0 exactly as specified. 7) When filtering for guest speaker type: use T1.type = 'Guest Speaker' exactly as specified. 8) When retrieving results: use DISTINCT to return unique combinations of T2.category and T1.type."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT budget_category FROM events WHERE location = 'MU 215' AND guest_speaker_type = 0 AND budget_spent = 0;",
            "SELECT DISTINCT T2.category, T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.location = 'MU 215' AND T1.type = 'Guest Speaker' AND T2.spent = 0;"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.category, T1.type\nFROM event AS T1\nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event\nWHERE T1.location = 'MU 215'\nAND T1.type = 'Guest Speaker'\nAND T2.spent = 0"
        ],
        "amend_res": 1
    },
    "1504": {
        "db_id": "debit_card_specializing",
        "question": "What is the average total price of the transactions taken place in January, 2012?",
        "ground_truth": "SELECT AVG(Amount) FROM transactions_1k WHERE Date LIKE '2012-01%'",
        "amends": [
            "Do reference column `Amount` instead of `price` in the SELECT list. Do reference table `transactions_1k` instead of `transactions` in the FROM clause. Do use a LIKE pattern `'2012-01%'` for date filtering instead of separate YEAR and MONTH functions. Do remove the explicit AND condition for month filtering since it's now handled by the pattern match. The amended query now correctly calculates the average transaction amount for January 2012 from the appropriate table using efficient string pattern matching instead of function-based date extraction."
        ],
        "rules": [
            "1) When the question asks for \"average total price\": use the exact column name \"Amount\" from the transactions_1k table instead of \"price\". 2) When filtering for transactions in January 2012: use the pattern '2012-01%' to match dates starting with January 2012 instead of separate YEAR and MONTH functions. 3) When selecting from the transactions table: use the exact table name \"transactions_1k\" instead of \"transactions\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(price) FROM transactions WHERE YEAR(date) = 2012 AND MONTH(date) = 1;",
            "SELECT AVG(Amount) AS average_total_price FROM transactions_1k WHERE Date LIKE '2012-01%'"
        ],
        "rule_sql": [
            "SELECT AVG(Amount) AS average_total_price FROM transactions_1k WHERE Date LIKE '2012-01%'"
        ],
        "amend_res": 1
    },
    "1188": {
        "db_id": "thrombosis_prediction",
        "question": "How many female patients born in 1964 were admitted to the hospital? List them by ID.",
        "ground_truth": "SELECT ID FROM Patient WHERE STRFTIME('%Y', Birthday) = '1964' AND SEX = 'F' AND Admission = '+'",
        "amends": [
            "Do select `ID` instead of `patient_id` and use table `Patient` instead of `patients`. Do filter with `SEX = 'F'` instead of `gender = 'male'` and use `STRFTIME('%Y', Birthday) = '1964'` instead of `year(birth_date) = 1964`. Do check `Admission = '+'` instead of `admission_status = 'admitted'` and remove the `AND` operator that was incorrectly connecting the original filters. The amended query now correctly selects female patients born in 1964 with positive admission status, matching the intended behavior."
        ],
        "rules": [
            "1) When selecting patient identifiers: use \"ID\" from table \"Patient\" instead of \"patient_id\" from \"patients\". 2) When filtering for female patients: use \"SEX = 'F'\" instead of \"gender = 'male'\". 3) When filtering for birth year 1964: use \"STRFTIME('%Y', Birthday) = '1964'\" instead of \"year(birth_date) = 1964\". 4) When checking admission status: use \"Admission = '+'\" instead of \"admission_status = 'admitted'\". 5) When combining multiple conditions: ensure proper logical connection without incorrect AND operators."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id FROM patients WHERE gender = 'male' AND year(birth_date) = 1964 AND admission_status = 'admitted';",
            "SELECT ID FROM Patient WHERE SEX = 'F' AND STRFTIME('%Y', Birthday) = '1964' AND Admission = '+'"
        ],
        "rule_sql": [
            "SELECT ID FROM Patient WHERE SEX = 'F' AND STRFTIME('%Y', Birthday) = '1964' AND Admission = '+'"
        ],
        "amend_res": 1
    },
    "118": {
        "db_id": "financial",
        "question": "For loan amount less than USD100,000, what is the percentage of accounts that is still running with no issue.",
        "ground_truth": "SELECT CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) FROM loan WHERE amount < 100000",
        "amends": [
            "Do use `CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id)` instead of `(COUNT(CASE WHEN status = 'running' THEN 1 END) * 100.0 / COUNT(*))` for the percentage calculation. Do reference table `loan` instead of `accounts` as the data source. Do filter on `amount < 100000` instead of `loan_amount < 100000` for the amount condition. Do check for status value `'C'` instead of `'running'` in the conditional logic. Do use `COUNT(account_id)` instead of `COUNT(*)` for the denominator calculation. The amended query now correctly calculates the percentage of accounts with status 'C' from the loan table where amount is less than 100,000."
        ],
        "rules": [
            "1) When answering about percentage of accounts with status 'C' for loans under 100,000: use table \"loan\" as the data source instead of \"accounts\". 2) When filtering by loan amount less than 100,000: use column \"amount\" instead of \"loan_amount\" with the condition amount < 100000. 3) When checking account status: use literal value 'C' instead of 'running' to identify accounts with no issues. 4) When calculating the percentage: use CAST(SUM(status = 'C') AS REAL) * 100 / COUNT(account_id) instead of COUNT(CASE WHEN status = 'running' THEN 1 END) * 100.0 / COUNT(*). 5) When counting accounts for the denominator: use COUNT(account_id) instead of COUNT(*) to ensure accurate account counting."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN status = 'running' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM accounts\nWHERE loan_amount < 100000",
            "SELECT \n    CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(account_id) AS percentage\nFROM \n    loan\nWHERE \n    amount < 100000"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(CASE WHEN status = 'C' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(account_id) AS percentage\nFROM loan\nWHERE amount < 100000;"
        ],
        "amend_res": 1
    },
    "562": {
        "db_id": "codebase_community",
        "question": "For the post which got 1910 view counts, how many comments does it get?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
        "amends": [
            "Do use an `INNER JOIN` between `posts` and `comments` on `T1.Id = T2.PostId` instead of a subquery with equality comparison. Do reference `T1.Id` in the `COUNT` function instead of `COUNT(*)` to count specific comment IDs. Do filter directly on `T1.ViewCount = 1910` in the WHERE clause instead of using a subquery to find the post ID. Do add explicit table aliases `T1` and `T2` instead of using unaliased table references. The amended query now correctly counts comments for posts with the specified view count using proper join semantics instead of potentially incorrect subquery logic."
        ],
        "rules": [
            "1) When combining posts and comments tables: link rows where T1.Id equals T2.PostId exactly and keep only matching pairs (inner join). 2) When filtering for posts with 1910 view counts: include only rows where T1.ViewCount equals 1910 exactly. 3) When counting comments for the specified post: compute the number of rows using T1.Id as the counting key instead of counting all columns. 4) When answering about comments for a post with specific view count: make sure to use explicit table aliases T1 for posts and T2 for comments as established in the join condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE post_id = (SELECT id FROM posts WHERE view_count = 1910);",
            "SELECT COUNT(T2.Id) \nFROM posts T1\nINNER JOIN comments T2 ON T1.Id = T2.PostId\nWHERE T1.ViewCount = 1910"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.Id) AS comment_count\nFROM posts T1\nINNER JOIN comments T2 ON T1.Id = T2.PostId\nWHERE T1.ViewCount = 1910"
        ],
        "amend_res": 1
    },
    "1119": {
        "db_id": "european_football_2",
        "question": "How many home team goal have been scored by Aaron Lennon?",
        "ground_truth": "SELECT SUM(t2.home_team_goal) FROM Player AS t1 INNER JOIN match AS t2 ON t1.player_api_id = t2.away_player_9 WHERE t1.player_name = 'Aaron Lennon'",
        "amends": [
            "Do use `SUM(t2.home_team_goal)` instead of `COUNT(*)` to sum actual goal values rather than counting rows. Do join `Player AS t1` and `match AS t2` tables instead of querying only the `goals` table. Do use `INNER JOIN` with `t1.player_api_id = t2.away_player_9` instead of filtering on `player_name` and `team_type` in WHERE. Do filter on `t1.player_name = 'Aaron Lennon'` in WHERE instead of using multiple conditions. Do remove the `team_type = 'away'` condition entirely instead of keeping it, as the join logic now handles the player-team relationship. The amended query now correctly sums home team goals for the specified player through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"home team goals scored by Aaron Lennon\": use SUM(t2.home_team_goal) instead of COUNT(*) to sum actual goal values. 2) When combining Player and match tables: link rows where t1.player_api_id = t2.away_player_9 using INNER JOIN and keep only matching pairs. 3) When filtering for a specific player: use t1.player_name = 'Aaron Lennon' exactly as specified. 4) When the question asks about home team goals: do not include team_type = 'away' condition as the join logic handles the player-team relationship."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM goals WHERE player_name = 'Aaron Lennon' AND team_type = 'away'",
            "SELECT SUM(t2.home_team_goal) \nFROM Player AS t1 \nINNER JOIN Match AS t2 ON t1.player_api_id = t2.away_player_9 \nWHERE t1.player_name = 'Aaron Lennon'"
        ],
        "rule_sql": [
            "SELECT SUM(t2.home_team_goal) \nFROM Player t1\nINNER JOIN Match t2 ON t1.player_api_id = t2.away_player_9\nWHERE t1.player_name = 'Aaron Lennon'"
        ],
        "amend_res": 1
    },
    "457": {
        "db_id": "card_games",
        "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
        "ground_truth": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
        "amends": [
            "Do select `purchaseUrls` instead of `website_name` and add `DISTINCT` instead of omitting it. Do use filter condition `promoTypes = 'bundle'` instead of `promotional_type = 'bundle'`. The amended query now correctly retrieves distinct purchase URLs for bundle promotions."
        ],
        "rules": [
            "1) When the question asks for websites to purchase cards: select the exact column \"purchaseUrls\" from table \"cards\" instead of any other column name like \"website_name\". 2) When filtering for promotional type \"bundle\": use the exact filter condition \"promoTypes = 'bundle'\" with the exact literal value 'bundle' and exact column name \"promoTypes\". 3) When listing distinct websites: ensure the result contains only unique values by applying DISTINCT to the \"purchaseUrls\" column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website_name FROM cards WHERE promotional_type = 'bundle';",
            "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle';"
        ],
        "rule_sql": [
            "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle';"
        ],
        "amend_res": 1
    },
    "978": {
        "db_id": "formula_1",
        "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
        "ground_truth": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
        "amends": [
            "Do select `DISTINCT location, lat, lng` instead of `COUNT(*) as count` with aggregation. Do remove the `GROUP BY location, lat, lng` clause instead of keeping it, as the distinct selection eliminates duplicate location coordinates without needing aggregation. The amended query now returns unique location coordinates instead of counting occurrences, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks for \"how many times the circuits were held in Austria\" but also requests \"their location and coordinates\": return the distinct location coordinates instead of counting occurrences. 2) When selecting location coordinates from circuits: use DISTINCT to eliminate duplicate location entries with the same coordinates. 3) When filtering circuits by country: use the exact literal 'Austria' with the correct case and spelling. 4) When outputting results: include the exact columns location, lat, and lng in the output."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as count, location, lat, lng FROM circuits WHERE country = 'Austria' GROUP BY location, lat, lng",
            "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria';"
        ],
        "rule_sql": [
            "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria';"
        ],
        "amend_res": 1
    },
    "1239": {
        "db_id": "thrombosis_prediction",
        "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
        "ground_truth": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
        "amends": [
            "Do select `DISTINCT T1.ID` and calculate age using `STRFTIME` functions instead of selecting `patient_id` and `age` directly. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter using a subquery that selects `ID` from `Laboratory` where `HCT >= 52` grouped by `ID` with `HAVING COUNT(ID) >= 2` instead of filtering directly on `hematocrit > 100` with `COUNT(lab_exam_id) >= 2` in the WHERE clause. The amended query now correctly identifies patients with high hematocrit values through proper table joins and subquery filtering, matching the RIGHT_SQL's behavior.",
            "Do remove the complex age calculation `STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T1.Birthday))` instead of keeping it, and do use `CURRENT_TIMESTAMP` instead of `'now'` for the year extraction. The amended query now matches RIGHT_SQL's behavior by simplifying the age calculation to just extract the birth year difference."
        ],
        "rules": [
            "1) When answering about patient ID and age: make sure the output order: T1.ID first, then calculated age using STRFTIME functions. 2) When the question mentions \"patient with two or more laboratory examinations\": use a subquery that selects ID from Laboratory where HCT >= 52 grouped by ID with HAVING COUNT(ID) >= 2. 3) When combining Patient (T1) and Laboratory (T2) tables: link rows where T1.ID = T2.ID using an inner join and keep only matching pairs. 4) When the question mentions \"hematocrit level exceeded the normal range\": filter using HCT >= 52 as the threshold for abnormal hematocrit values. 5) When selecting patient identifiers: use DISTINCT T1.ID to avoid duplicate patient records.",
            "1) When calculating patient age from birthday: compute age as the difference between the current year and the birth year using CURRENT_TIMESTAMP for the current timestamp and extracting the year from T1.Birthday, without complex month-day adjustments.\n2) When identifying patients with two or more laboratory examinations showing hematocrit level exceeding normal range: use the condition T2.HCT >= 52 to identify hematocrit levels exceeding normal range, and count occurrences per patient ID to find those with at least 2 such examinations.\n3) When joining Patient and Laboratory tables: link rows where T1.ID = T2.ID to associate laboratory results with the correct patients, keeping only matching pairs (inner match).\n4) When selecting output columns: include T1.ID and the computed age value in the results, ensuring distinct patient records are returned."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, age FROM patients WHERE hematocrit > 100 AND COUNT(lab_exam_id) >= 2;",
            "SELECT DISTINCT T1.ID, STRFTIME('%Y', 'now') - STRFTIME('%Y', T1.Birthday) - (STRFTIME('%m-%d', 'now') < STRFTIME('%m-%d', T1.Birthday)) AS age\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.ID IN (\n    SELECT ID\n    FROM Laboratory\n    WHERE HCT >= 52\n    GROUP BY ID\n    HAVING COUNT(ID) >= 2\n)",
            "SELECT DISTINCT T1.ID, \n       (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS age\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T1.ID IN (\n    SELECT ID \n    FROM Laboratory \n    WHERE HCT >= 52 \n    GROUP BY ID \n    HAVING COUNT(ID) >= 2\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, \n       (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) AS Age\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T1.ID IN (\n    SELECT ID \n    FROM Laboratory \n    WHERE HCT >= 52 \n    GROUP BY ID \n    HAVING COUNT(ID) >= 2\n)\nORDER BY T1.ID, Age;"
        ],
        "amend_res": 1
    },
    "1027": {
        "db_id": "european_football_2",
        "question": "Indicate the full names of the top 10 players with the highest number of penalties.",
        "ground_truth": "SELECT t2.player_name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.id = t2.id ORDER BY t1.penalties DESC LIMIT 10",
        "amends": [
            "Do select `t2.player_name` from the `Player` table instead of `name` from the `players` table. Do join `Player_Attributes AS t1` with `Player AS t2` using `INNER JOIN` on `t1.id = t2.id` instead of querying a single table. Do order by `t1.penalties DESC` instead of `penalties DESC` to reference the correct table's column. The amended query now correctly retrieves player names from the Player table while ordering by penalties from the Player_Attributes table, matching the intended behavior.",
            "Do join on `t1.id = t2.id` instead of `t1.player_api_id = t2.player_api_id` to use the correct primary/foreign key relationship between the tables. The amended query now matches RIGHT_SQL's behavior by properly linking the Player_Attributes and Player tables through their id columns rather than the incorrect player_api_id reference."
        ],
        "rules": [
            "1) When answering about \"top 10 players with highest number of penalties\": make sure the output order: t2.player_name. 2) When combining Player_Attributes (as T1) and Player (as T2) tables: link rows where T1.id = T2.id and keep only matching pairs (inner match). 3) When ordering by penalties: use T1.penalties DESC to rank players from highest to lowest. 4) When the question mentions \"top 10\": rank rows by T1.penalties in descending order and keep the first 10 rows.",
            "1) When joining Player_Attributes and Player tables: link rows where t1.id = t2.id exactly as shown in the amends, keeping only matching pairs (inner match). 2) When answering about \"top 10 players with highest number of penalties\": rank rows by t1.penalties in descending order and keep the first 10 rows. 3) When producing output: make sure the output order includes only t2.player_name as the full names of players."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY penalties DESC LIMIT 10;",
            "SELECT t2.player_name\nFROM Player_Attributes AS t1\nINNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id\nORDER BY t1.penalties DESC\nLIMIT 10",
            "SELECT t2.player_name\nFROM Player_Attributes AS t1\nINNER JOIN Player AS t2 ON t1.id = t2.id\nORDER BY t1.penalties DESC\nLIMIT 10"
        ],
        "rule_sql": [
            "SELECT t2.player_name\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.id = t2.id\nORDER BY t1.penalties DESC\nLIMIT 10"
        ],
        "amend_res": 1
    },
    "1515": {
        "db_id": "debit_card_specializing",
        "question": "What segment did the customer have at 2012/8/23 21:20:00?",
        "ground_truth": "SELECT T2.Segment FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.date = '2012-08-23' AND T1.time = '21:20:00'",
        "amends": [
            "Do add `transactions_1k AS T1` table with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `customers` table. Do change the source from `customers` to `customers AS T2` instead of using it directly. Do replace the timestamp filter with separate `T1.date = '2012-08-23'` and `T1.time = '21:20:00'` conditions instead of the combined `timestamp = '2012/8/23 21:20:00'` predicate. Do use the correct date format `'2012-08-23'` instead of `'2012/8/23'` and separate time component. The amended query now correctly joins transaction and customer data to retrieve segments for specific transaction timestamps."
        ],
        "rules": [
            "1) When answering about customer segment at a specific timestamp: use transactions_1k AS T1 and customers AS T2 tables with an inner join on T1.CustomerID = T2.CustomerID instead of querying only the customers table. 2) When filtering by date and time: use separate conditions T1.date = '2012-08-23' and T1.time = '21:20:00' instead of a combined timestamp filter. 3) When handling date literals: use the exact format '2012-08-23' (YYYY-MM-DD) instead of '2012/8/23'. 4) When retrieving customer segment: select the segment column from the customers table (T2.segment) after joining with transactions data."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT segment FROM customers WHERE timestamp = '2012/8/23 21:20:00';",
            "SELECT T2.Segment \nFROM transactions_1k AS T1 \nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'"
        ],
        "rule_sql": [
            "SELECT T2.Segment \nFROM transactions_1k AS T1 \nINNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'"
        ],
        "amend_res": 1
    },
    "464": {
        "db_id": "card_games",
        "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
        "ground_truth": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
        "amends": [
            "Do use `DISTINCT T1.name` instead of `card_name` to select from the cards table with an alias. Do add an `INNER JOIN` with `set_translations AS T2` on `T2.setCode = T1.setCode` instead of querying only the cards table. Do change the filter to `T2.translation = 'Hauptset Zehnte Edition'` instead of `set_name = 'Hauptset Zehnte Edition'` to properly reference the translated set name from the joined table. The amended query now correctly joins the translation table to filter by the German set name translation instead of relying on a potentially incorrect set_name field, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"cards in the set 'Hauptset Zehnte Edition'\": make sure the output order: T1.name 2) When the question mentions \"cards\": \"cards\" actually means \"T1.name in schema\" 3) When the question mentions \"set 'Hauptset Zehnte Edition'\": use T2.translation = 'Hauptset Zehnte Edition' to filter by the exact German translation 4) When combining T1 and T2 for shared entities: link rows where T2.setCode = T1.setCode exactly as shown; keep only matching pairs (inner match) 5) When selecting card names: use DISTINCT T1.name to get unique card names from the cards table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT card_name FROM cards WHERE set_name = 'Hauptset Zehnte Edition';",
            "SELECT DISTINCT T1.name\nFROM cards AS T1\nINNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode\nWHERE T2.translation = 'Hauptset Zehnte Edition'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.name\nFROM cards T1\nINNER JOIN set_translations T2 ON T2.setCode = T1.setCode\nWHERE T2.translation = 'Hauptset Zehnte Edition'\nORDER BY T1.name"
        ],
        "amend_res": 1
    },
    "705": {
        "db_id": "codebase_community",
        "question": "Give the user's reputation and up vote number of the user that commented \"fine, you win :)\".",
        "ground_truth": "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'",
        "amends": [
            "Do select `T2.Reputation` and `T2.UpVotes` from the `users` table instead of `reputation` and `up_votes` directly. Do join `comments AS T1` with `users AS T2` on `T1.UserId = T2.Id` instead of querying the `users` table alone. Do filter on `T1.Text = 'fine, you win :)'` instead of filtering `users.comment` directly, as the comment text is stored in the comments table rather than the users table. The amended query now correctly retrieves user reputation and upvotes by joining through the comments table where the specific text appears, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for user attributes based on a specific comment text: join comments table as T1 with users table as T2 using T1.UserId = T2.Id to connect comment authors to their user profiles. 2) When filtering for a specific comment text: use T1.Text = 'fine, you win :)' exactly as written with the same case, spacing, and punctuation. 3) When selecting user reputation and upvotes: output T2.Reputation and T2.UpVotes in that order, using the exact column names with proper casing. 4) When combining tables for this query: perform an inner match where T1.UserId equals T2.Id to ensure only matching comment-user pairs are included."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT reputation, up_votes FROM users WHERE comment = 'fine, you win :)';",
            "SELECT T2.Reputation, T2.UpVotes \nFROM comments AS T1 \nJOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T1.Text = 'fine, you win :)'"
        ],
        "rule_sql": [
            "SELECT T2.Reputation, T2.UpVotes FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Text = 'fine, you win :)'"
        ],
        "amend_res": 1
    },
    "137": {
        "db_id": "financial",
        "question": "How many accounts have running contracts in Branch location 1?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T1.district_id = 1 AND (T3.status = 'C' OR T3.status = 'D')",
        "amends": [
            "Do use `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN district AS T2 ON T1.district_id = T2.district_id` and `INNER JOIN loan AS T3 ON T1.account_id = T3.account_id` instead of querying only the accounts table. Do change the filter to `T1.district_id = 1` instead of `branch_location = 1` to use the correct column reference. Do replace `contract_status = 'running'` with `(T3.status = 'C' OR T3.status = 'D')` instead to check loan status values. The amended query now correctly joins multiple tables and uses appropriate filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values. 2) When answering about accounts with contracts in Branch location 1: add INNER JOIN district AS T2 ON T1.district_id = T2.district_id and INNER JOIN loan AS T3 ON T1.account_id = T3.account_id instead of querying only the accounts table. 3) When filtering by branch location: use T1.district_id = 1 instead of branch_location = 1 to use the correct column reference. 4) When checking for running contracts: replace contract_status = 'running' with (T3.status = 'C' OR T3.status = 'D') to check loan status values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE branch_location = 1 AND contract_status = 'running';",
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T1.district_id = 1 \nAND (T3.status = 'C' OR T3.status = 'D')"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T1.district_id = 1 \nAND (T3.status = 'C' OR T3.status = 'D')"
        ],
        "amend_res": 1
    },
    "731": {
        "db_id": "superhero",
        "question": "How many superheroes did DC Comics publish?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `publisher AS T2` instead of querying the `superheroes` table directly. Do use `INNER JOIN` on `T1.publisher_id = T2.id` instead of filtering by a column that doesn't exist in the table. Do filter on `T2.publisher_name = 'DC Comics'` instead of `publisher = 'Marvel Comics'` to correctly reference the publisher table and query for DC Comics rather than Marvel Comics. The amended query now properly joins tables and counts superheroes from the correct publisher."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When answering about superheroes from a specific publisher: join publisher AS T2 to superheroes AS T1 using INNER JOIN on T1.publisher_id = T2.id instead of filtering directly on the superheroes table. 3) When filtering for DC Comics: use T2.publisher_name = 'DC Comics' instead of publisher = 'Marvel Comics' to correctly reference the publisher table and query for the exact publisher name."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE publisher = 'Marvel Comics';",
            "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nINNER JOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'DC Comics'"
        ],
        "amend_res": 1
    },
    "1472": {
        "db_id": "debit_card_specializing",
        "question": "In 2012, who had the least consumption in LAM?",
        "ground_truth": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "amends": [
            "Do select `T1.CustomerID` instead of `country, MIN(consumption)` and change the FROM clause to use `customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID` instead of a single table `energy_data`. Do filter with `T1.Segment = 'LAM'` instead of `region = 'LAM'` and use `SUBSTR(T2.Date, 1, 4) = '2012'` instead of `year = 2012`. Do add `GROUP BY T1.CustomerID` instead of omitting grouping, and change the ordering to `ORDER BY SUM(T2.Consumption) ASC LIMIT 1` instead of selecting the minimum consumption directly. The amended query now correctly identifies the customer with the lowest total consumption in 2012 from the LAM segment through proper joining and aggregation."
        ],
        "rules": [
            "1) When answering about \"who had the least consumption in LAM in 2012\": make sure the output order: T1.CustomerID. 2) When the question mentions \"consumption\": \"consumption\" actually means \"T2.Consumption in schema\". 3) When the question mentions \"least\" or \"lowest\": rank rows by SUM(T2.Consumption) in ascending order and keep the first 1 row. 4) When the question asks about \"in LAM\": filter rows where T1.Segment = 'LAM'. 5) When the question asks about \"in 2012\": filter rows where SUBSTR(T2.Date, 1, 4) = '2012'. 6) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match). 7) When computing total consumption per customer: group results by T1.CustomerID and compute SUM(T2.Consumption) per group."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country, MIN(consumption) FROM energy_data WHERE year = 2012 AND region = 'LAM'",
            "SELECT T1.CustomerID\nFROM customers AS T1\nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'\nAND SUBSTR(T2.Date, 1, 4) = '2012'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.CustomerID\nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'LAM'\nAND SUBSTR(T2.Date, 1, 4) = '2012'\nGROUP BY T1.CustomerID\nORDER BY SUM(T2.Consumption) ASC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1131": {
        "db_id": "european_football_2",
        "question": "What is the average heights of Italy players?",
        "ground_truth": "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) FROM Player AS T1 INNER JOIN Match AS T2 ON T1.id = T2.id INNER JOIN Country AS T3 ON T2.country_id = T3.ID WHERE T3.NAME = 'Italy'",
        "amends": [
            "Do use `CAST(SUM(T1.height) AS REAL) / COUNT(T1.id)` instead of `AVG(height)` to ensure proper floating-point division. Do add `INNER JOIN Match AS T2 ON T1.id = T2.id` and `INNER JOIN Country AS T3 ON T2.country_id = T3.ID` instead of omitting these table joins. Do change the filter to `T3.NAME = 'Italy'` instead of `country = 'Italy'` to reference the correct table and column. Do include `COUNT(T1.id)` instead of relying on implicit averaging to handle potential NULL values correctly. The amended query now properly calculates the average height by joining through the necessary tables and using explicit casting for accurate division.",
            "Do `INNER JOIN` on `T1.id = T2.id` instead of using `T1.player_api_id IN` with multiple player columns. Do remove the alias `average_height` instead of keeping it. The amended query now correctly joins tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average height of players: use CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) instead of AVG(height) for proper floating-point division. 2) When filtering for Italy players: join Match table as T2 using T1.id = T2.id and join Country table as T3 using T2.country_id = T3.ID, then filter with T3.NAME = 'Italy' instead of country = 'Italy'. 3) When counting players: use COUNT(T1.id) instead of implicit averaging to handle potential NULL values correctly.",
            "1) When joining Player and Match tables: use T1.id = T2.id for the join condition instead of checking T1.player_api_id against multiple player columns. 2) When computing average height: do not include an alias for the result column. 3) When filtering for Italy players: use T3.name = 'Italy' with exact case and spelling."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(height) FROM players WHERE country = 'Italy';",
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) AS average_height\nFROM Player AS T1\nINNER JOIN Match AS T2 ON T1.player_api_id IN (\n    T2.home_player_1, T2.home_player_2, T2.home_player_3, T2.home_player_4, T2.home_player_5,\n    T2.home_player_6, T2.home_player_7, T2.home_player_8, T2.home_player_9, T2.home_player_10, T2.home_player_11,\n    T2.away_player_1, T2.away_player_2, T2.away_player_3, T2.away_player_4, T2.away_player_5,\n    T2.away_player_6, T2.away_player_7, T2.away_player_8, T2.away_player_9, T2.away_player_10, T2.away_player_11\n)\nINNER JOIN Country AS T3 ON T2.country_id = T3.id\nWHERE T3.name = 'Italy';",
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) \nFROM Player AS T1\nINNER JOIN Match AS T2 ON T1.id = T2.id\nINNER JOIN Country AS T3 ON T2.country_id = T3.id\nWHERE T3.name = 'Italy'"
        ],
        "rule_sql": [
            "SELECT CAST(SUM(T1.height) AS REAL) / COUNT(T1.id) \nFROM Player AS T1\nJOIN Match AS T2 ON T1.id = T2.id\nJOIN Country AS T3 ON T2.country_id = T3.id\nWHERE T3.name = 'Italy'"
        ],
        "amend_res": 1
    },
    "994": {
        "db_id": "formula_1",
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "ground_truth": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "amends": [
            "Do use `constructorResults` table instead of `results` table for points data. Do join `constructorResults` to `constructors` on `constructorId` instead of joining `results` to `constructors`. Do select `SUM(T1.points)` as an aggregate without alias instead of `SUM(r.points) as total_points`. Do group by `T2.name` instead of `c.constructorId` to match the non-aggregated columns in SELECT. Do order by `SUM(T1.points)` directly instead of using the alias `total_points`. Do maintain the same Monaco Grand Prix filter and year range condition. The amended query now correctly aggregates constructor points from the appropriate table and groups by constructor name to match the expected output structure."
        ],
        "rules": [
            "1) When answering about constructor points from Monaco Grand Prix: use the \"constructorResults\" table instead of the \"results\" table for points data. 2) When joining constructor data: link \"constructorResults\" to \"constructors\" using \"constructorId\" as the join key. 3) When aggregating points: compute the sum of \"T1.points\" without using an alias in the aggregation. 4) When grouping results: group by \"T2.name\" to match the non-aggregated columns in the output. 5) When ordering results: sort by the sum of points directly rather than using an alias. 6) When filtering for Monaco Grand Prix: use the exact literal 'Monaco Grand Prix' for race name comparison. 7) When filtering for years between 1980 and 2010: use inclusive range comparison with years 1980 and 2010."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT c.name, c.nationality, SUM(r.points) as total_points\nFROM constructors c\nJOIN results r ON c.constructorId = r.constructorId\nJOIN races ra ON r.raceId = ra.raceId\nWHERE ra.name = 'Monaco Grand Prix'\nAND ra.year BETWEEN 1980 AND 2010\nGROUP BY c.constructorId\nORDER BY total_points DESC\nLIMIT 1;",
            "SELECT SUM(cr.points) AS score, c.name, c.nationality\nFROM constructorResults cr\nJOIN constructors c ON cr.constructorId = c.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.name LIKE '%Monaco Grand Prix%'\nAND r.year BETWEEN 1980 AND 2010\nGROUP BY c.name, c.nationality\nORDER BY SUM(cr.points) DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT SUM(cr.points) AS score, c.name, c.nationality\nFROM constructorResults cr\nJOIN constructors c ON cr.constructorId = c.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.name = 'Monaco Grand Prix'\nAND r.year BETWEEN 1980 AND 2010\nGROUP BY c.name, c.nationality\nORDER BY SUM(cr.points) DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "202": {
        "db_id": "toxicology",
        "question": "How many triple type bonds are there?",
        "ground_truth": "SELECT COUNT(T.bond_id) FROM bond AS T WHERE T.bond_type = '#'",
        "amends": [
            "Do use `COUNT(T.bond_id)` instead of `COUNT(*)` to count specific non-null values rather than all rows. Do reference the table with alias `T` instead of using the bare table name `bonds`. Do use the correct table name `bond` instead of the incorrect `bonds`. Do filter with `T.bond_type = '#'` instead of `bond_type = 'triple'` to match the correct bond type value. The amended query now correctly counts specific bond records with the proper table reference and filter condition."
        ],
        "rules": [
            "1) When counting bonds: use COUNT(T.bond_id) to count specific non-null bond_id values rather than all rows. 2) When referencing the bond table: use alias T instead of the bare table name bonds. 3) When filtering by bond type: use T.bond_type = '#' instead of bond_type = 'triple' to match the correct bond type value. 4) When answering about triple type bonds: the literal 'triple' in the question actually means '#' in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM bonds WHERE bond_type = 'triple'",
            "SELECT COUNT(T.bond_id) FROM bond T WHERE T.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.bond_id) FROM bond T WHERE T.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "712": {
        "db_id": "codebase_community",
        "question": "What is the post ID and the comments commented in the post titled by \"Group differences on a five point Likert item\"?",
        "ground_truth": "SELECT T2.Id, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'Group differences on a five point Likert item'",
        "amends": [
            "Do reference `T2.Id` and `T1.Text` instead of `post_id` and `comment_text` in the SELECT list. Do join `comments AS T1` with `posts AS T2` using `INNER JOIN` on `T1.PostId = T2.Id` instead of querying only the `comments` table without any join. Do filter on `T2.Title` instead of `post_title` in the WHERE clause, as the title column exists in the posts table rather than the comments table. The amended query now correctly joins the tables and references the appropriate columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"post ID and comments for a specific post title\": make sure the output order: T2.Id, T1.Text\n2) When the question mentions \"post titled by 'Group differences on a five point Likert item'\": filter rows where T2.Title equals exactly 'Group differences on a five point Likert item'\n3) When combining comments (T1) and posts (T2) tables: link rows where T1.PostId equals T2.Id and keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation of 'Group differences on a five point Likert item'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT post_id, comment_text FROM comments WHERE post_title = 'Group differences on a five point Likert item';",
            "SELECT T2.Id AS post_id, T1.Text AS comment_text\nFROM comments AS T1\nINNER JOIN posts AS T2 ON T1.PostId = T2.Id\nWHERE T2.Title = 'Group differences on a five point Likert item'"
        ],
        "rule_sql": [
            "SELECT T2.Id, T1.Text\nFROM comments T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE T2.Title = 'Group differences on a five point Likert item'"
        ],
        "amend_res": 1
    },
    "1337": {
        "db_id": "student_club",
        "question": "What is the total budgeted amount for all category in \"October Speaker\" event?",
        "ground_truth": "SELECT SUM(T2.amount) FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'October Speaker'",
        "amends": [
            "Do select `SUM(T2.amount)` from the `budget` table instead of `SUM(budgeted_amount)` from the `categories` table. Do join `event AS T1` with `budget AS T2` using `INNER JOIN` on `T1.event_id = T2.link_to_event` instead of querying only the `categories` table. Do apply the filter `T1.event_name = 'October Speaker'` to the joined `event` table instead of filtering the `categories` table directly. The amended query now correctly aggregates budget amounts from the appropriate tables with proper joins to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"total budgeted amount for all category in 'October Speaker' event\": make sure the output order: SUM(T2.amount) 2) When the question mentions \"October Speaker\" event: \"October Speaker\" actually means T1.event_name = 'October Speaker' in schema 3) When combining T1 (event) and T2 (budget) for shared entities: link rows where T1.event_id = T2.link_to_event exactly as shown in the amends; keep only matching pairs (inner match) 4) When computing total budgeted amount: use SUM(T2.amount) from the budget table instead of SUM(budgeted_amount) from categories table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(budgeted_amount) FROM categories WHERE event_name = 'October Speaker';",
            "SELECT SUM(T2.amount) \nFROM event AS T1 \nINNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'October Speaker'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.amount) \nFROM event T1 \nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event \nWHERE T1.event_name = 'October Speaker'"
        ],
        "amend_res": 1
    },
    "1424": {
        "db_id": "student_club",
        "question": "Among the members, how many of them have an extra large t-shirt size?",
        "ground_truth": "SELECT COUNT(member_id) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large'",
        "amends": [
            "Do count `member_id` instead of `*` to exclude NULL values. Do use table name `member` instead of `members` to reference the correct table. Do add filter `position = 'Member'` instead of omitting it to count only members with that position. Do use value `'X-Large'` instead of `'XL'` for the t-shirt size condition to match the correct size designation. The amended query now correctly counts only members with the specified position and t-shirt size, matching the intended behavior."
        ],
        "rules": [
            "1) When counting members: use \"member_id\" instead of \"*\" to exclude NULL values. 2) When referencing the member table: use table name \"member\" instead of \"members\" to reference the correct table. 3) When filtering for members: add condition \"position = 'Member'\" to count only members with that position. 4) When filtering for extra large t-shirt size: use value \"'X-Large'\" instead of \"'XL'\" to match the correct size designation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM members WHERE t_shirt_size = 'XL';",
            "SELECT COUNT(member_id) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large';"
        ],
        "rule_sql": [
            "SELECT COUNT(member_id) FROM member WHERE position = 'Member' AND t_shirt_size = 'X-Large';"
        ],
        "amend_res": 1
    },
    "383": {
        "db_id": "card_games",
        "question": "How many of the banned cards are white border?",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'",
        "amends": [
            "Do select `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `cards AS T1` with `legalities AS T2` using `INNER JOIN` on `T1.uuid = T2.uuid` instead of querying only the `cards` table without any join. Do filter on `T2.status = 'Banned'` instead of `banned = 'yes'` to use the proper status column from the joined table. Do keep the `T1.borderColor = 'white'` filter but reference it through the table alias. The amended query now correctly counts banned cards by joining with the legalities table and using the proper status value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"banned cards\": join cards AS T1 with legalities AS T2 using inner join where T1.uuid = T2.uuid to get proper banned status information. 2) When counting banned cards: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 3) When filtering for banned cards: use T2.status = 'Banned' instead of banned = 'yes' to use the proper status column and value. 4) When filtering for white border cards: use T1.borderColor = 'white' with the exact case and spelling as shown in the schema. 5) When combining tables for banned status: perform an inner match to keep only cards that have corresponding legalities entries with T1.uuid = T2.uuid."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE banned = 'yes' AND border_color = 'white';",
            "SELECT COUNT(T1.id) \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Banned' \nAND T1.borderColor = 'white'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T2.status = 'Banned' \nAND T1.borderColor = 'white'"
        ],
        "amend_res": 1
    },
    "571": {
        "db_id": "codebase_community",
        "question": "For the user No.24, how many times is the number of his/her posts compared to his/her votes?",
        "ground_truth": "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.UserId = T2.OwnerUserId WHERE T1.UserId = 24",
        "amends": [
            "Do use `INNER JOIN` between `votes` and `posts` instead of `LEFT JOIN` from `users` to both tables. Do join on `T1.UserId = T2.OwnerUserId` instead of joining both tables to `users.id`. Do calculate `CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id)` instead of `COUNT(posts.id) / COUNT(votes.id)`. Do filter with `WHERE T1.UserId = 24` instead of `WHERE users.id = 24`. Do remove the `users` table entirely instead of including it as the primary source. Do use `COUNT(DISTINCT T1.Id)` instead of simple counts without deduplication. Do cast the numerator to `REAL` instead of performing integer division. The amended query now correctly calculates the ratio of posts to distinct votes for the specified user.",
            "Do use `COUNT(T2.Id)` for posts count instead of `COUNT(DISTINCT posts.Id)` to avoid unnecessary distinct counting on unique post IDs. Do reference tables with aliases `T1` for votes and `T2` for posts instead of using raw table names. Do maintain the same `INNER JOIN` on `T1.UserId = T2.OwnerUserId` instead of changing the join condition. Do keep the filter `WHERE T1.UserId = 24` instead of altering the filtering logic. Do preserve the cast to `REAL` and the division operation for calculating the posts to votes ratio instead of modifying the aggregation approach. The amended query now correctly calculates the ratio without redundant distinct operations while maintaining the same logical behavior."
        ],
        "rules": [
            "1) When calculating the ratio of posts to votes for a specific user: use INNER JOIN between votes and posts tables instead of LEFT JOIN from users to both tables. 2) When joining votes and posts tables: link rows where T1.UserId = T2.OwnerUserId instead of joining both tables to users.id. 3) When calculating the posts-to-votes ratio: compute CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) instead of COUNT(posts.id) / COUNT(votes.id). 4) When filtering for a specific user: use WHERE T1.UserId = 24 instead of WHERE users.id = 24. 5) When structuring the query: remove the users table entirely instead of including it as the primary source. 6) When counting votes: use COUNT(DISTINCT T1.Id) instead of simple counts without deduplication. 7) When performing division: cast the numerator to REAL instead of performing integer division.",
            "1) When answering about \"number of posts compared to votes for user No.24\": make sure the output order: posts_to_votes_ratio. 2) When counting posts: use COUNT(T2.Id) instead of COUNT(DISTINCT T2.Id) since post IDs are unique. 3) When combining votes and posts tables: link rows where T1.UserId = T2.OwnerUserId and keep only matching pairs (inner match). 4) When filtering for user No.24: apply the condition T1.UserId = 24 exactly as specified. 5) When calculating the ratio of posts to votes: compute (COUNT(T2.Id)) divided by (COUNT(T1.Id)) and cast the result to REAL to handle decimal values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(posts.id) AS post_count, COUNT(votes.id) AS vote_count, COUNT(posts.id) / COUNT(votes.id) AS ratio FROM users LEFT JOIN posts ON users.id = posts.user_id LEFT JOIN votes ON users.id = votes.user_id WHERE users.id = 24",
            "SELECT CAST(COUNT(DISTINCT posts.Id) AS REAL) / COUNT(DISTINCT votes.Id) AS posts_to_votes_ratio\nFROM votes\nINNER JOIN posts ON votes.UserId = posts.OwnerUserId\nWHERE votes.UserId = 24",
            "SELECT CAST(COUNT(T2.Id) AS REAL) / COUNT(DISTINCT T1.Id) AS posts_to_votes_ratio\nFROM votes T1\nINNER JOIN posts T2 ON T1.UserId = T2.OwnerUserId\nWHERE T1.UserId = 24"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(posts.Id) AS REAL) / COUNT(DISTINCT votes.Id) AS posts_to_votes_ratio\nFROM votes\nINNER JOIN posts ON votes.UserId = posts.OwnerUserId\nWHERE votes.UserId = 24"
        ],
        "amend_res": 1
    },
    "133": {
        "db_id": "financial",
        "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
        "ground_truth": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
        "amends": [
            "Do select `district_id` and `A2` instead of `branch_location` and `district_name`. Do use table `district` instead of `districts`. Do remove the `WHERE year = 1996` filter instead of keeping it. Do order by `A13 DESC` instead of `unemployment_rate ASC`. Do limit to `1` row instead of `5` rows. The amended query now matches the correct behavior by selecting the appropriate columns from the correct table with the proper ordering and limit."
        ],
        "rules": [
            "1) When answering about districts with highest unemployment rate: select \"district_id\" and \"A2\" from table \"district\" instead of \"branch_location\" and \"district_name\" from \"districts\". 2) When the question mentions year 1996: do not filter by year as the schema does not contain year information. 3) When the question asks for highest unemployment rate: order by \"A13\" in descending direction instead of ascending. 4) When the question asks for highest unemployment rate: limit to 1 row instead of 5 rows to get the single highest value."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT branch_location, district_name \nFROM districts \nWHERE year = 1996 \nORDER BY unemployment_rate ASC \nLIMIT 5;",
            "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1494": {
        "db_id": "debit_card_specializing",
        "question": "What percentage of Slovakian gas stations are premium?",
        "ground_truth": "SELECT CAST(SUM(IIF(Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK'",
        "amends": [
            "Do use `SUM(IIF(Segment = 'Premium', 1, 0))` instead of `COUNT(CASE WHEN type = 'premium' THEN 1 END)` for counting premium segments. Do cast the sum to `FLOAT` instead of using `100.0` for proper division. Do reference `GasStationID` instead of `*` in the count. Do use table name `gasstations` instead of `gas_stations`. Do filter on `Country = 'SVK'` instead of `country = 'Slovakia'` using the country code. The amended query now correctly calculates the percentage of premium gas stations in Slovakia using proper country code identification and precise floating-point division."
        ],
        "rules": [
            "1) When the question asks for percentage of premium gas stations: use SUM(IIF(Segment = 'Premium', 1, 0)) to count premium segments instead of COUNT(CASE WHEN type = 'premium' THEN 1 END). 2) When calculating percentages: cast the sum to FLOAT for proper division instead of using 100.0. 3) When counting total gas stations: reference GasStationID instead of * for counting. 4) When referencing the gas stations table: use table name gasstations instead of gas_stations. 5) When filtering for Slovakian gas stations: use Country = 'SVK' instead of country = 'Slovakia' using the country code."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN type = 'premium' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\nFROM gas_stations\nWHERE country = 'Slovakia';",
            "SELECT \n    (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID)) AS PercentagePremium\nFROM \n    gasstations\nWHERE \n    Country = 'SVK';"
        ],
        "rule_sql": [
            "SELECT (SUM(IIF(Segment = 'Premium', 1, 0)) * 100.0 / COUNT(GasStationID)) AS PercentagePremium FROM gasstations WHERE Country = 'SVK';"
        ],
        "amend_res": 1
    },
    "460": {
        "db_id": "card_games",
        "question": "Which artist designed the card whose promotional name is \"Battra, Dark Destroyer\"?",
        "ground_truth": "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer'",
        "amends": [
            "Do reference the `flavorName` column instead of the non-existent `promotional_name` column in the WHERE filter, as the correct column name for flavor text is `flavorName` rather than `promotional_name`. The amended query now correctly filters cards by the specified flavor name and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question mentions \"promotional name\": \"promotional name\" actually means \"flavorName in schema\". 2) When filtering for a specific card flavor name: use the exact literal \"Battra, Dark Destroyer\" with the correct column name \"flavorName\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT artist FROM cards WHERE promotional_name = 'Battra, Dark Destroyer';",
            "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';"
        ],
        "rule_sql": [
            "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';"
        ],
        "amend_res": 1
    },
    "1162": {
        "db_id": "thrombosis_prediction",
        "question": "How many female patients who came at the hospital in 1997 was immediately followed at the outpatient clinic?",
        "ground_truth": "SELECT COUNT(*) FROM Patient WHERE STRFTIME('%Y', Description) = '1997' AND SEX = 'F' AND Admission = '-'",
        "amends": [
            "Do use table `Patient` instead of joining `patients` and `visits` tables. Do filter with `SEX = 'F'` instead of `p.gender = 'Female'`. Do use `STRFTIME('%Y', Description) = '1997'` instead of applying the date function to `v.visit_date`. Do add filter `Admission = '-'` instead of omitting it. Do remove the `v.follow_up_type = 'Outpatient'` condition instead of keeping it. The amended query now correctly counts patients from 1997 with female gender and unspecified admission status."
        ],
        "rules": [
            "1) When answering about female patients: use \"SEX = 'F'\" instead of \"gender = 'Female'\" 2) When filtering by year 1997: use \"STRFTIME('%Y', Description) = '1997'\" to extract year from the Description column 3) When checking admission status: include filter \"Admission = '-'\" for unspecified admission status 4) When counting patients from 1997: do not include any follow-up type conditions like \"follow_up_type = 'Outpatient'\" 5) When working with this schema: use the \"Patient\" table directly instead of joining separate patients and visits tables"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM patients p\nJOIN visits v ON p.patient_id = v.patient_id\nWHERE p.gender = 'Female' \nAND strftime('%Y', v.visit_date) = '1997'\nAND v.follow_up_type = 'Outpatient'",
            "SELECT COUNT(*) \nFROM Patient \nWHERE SEX = 'F' \nAND STRFTIME('%Y', Description) = '1997' \nAND Admission = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(*) \nFROM Patient \nWHERE SEX = 'F' \nAND STRFTIME('%Y', Description) = '1997' \nAND Admission = '-'"
        ],
        "amend_res": 1
    },
    "1166": {
        "db_id": "thrombosis_prediction",
        "question": "What are the symptoms observed by the youngest patient to ever did a medical examination? Identify their diagnosis.",
        "ground_truth": "SELECT T2.Symptoms, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Symptoms IS NOT NULL ORDER BY T1.Birthday DESC LIMIT 1",
        "amends": [
            "Do select `T2.Symptoms` and `T1.Diagnosis` instead of `s.symptom_name` and `d.diagnosis_name`. Do use `Patient AS T1` and `Examination AS T2` as FROM sources instead of multiple joined tables including `patients`, `medical_examinations`, `symptoms`, and `diagnoses`. Do use `INNER JOIN` on `T1.ID = T2.ID` instead of multiple joins on `patient_id` and `examination_id` relationships. Do add `WHERE T2.Symptoms IS NOT NULL` filter instead of omitting it. Do remove the subquery for minimum age condition instead of keeping it. Do order by `T1.Birthday DESC` instead of `me.examination_date DESC`. The amended query now correctly filters for non-null symptoms and uses proper table relationships to match the intended behavior."
        ],
        "rules": [
            "1) When selecting output columns: use T2.Symptoms and T1.Diagnosis instead of symptom_name and diagnosis_name. 2) When combining Patient and Examination tables: use Patient as T1 and Examination as T2 with INNER JOIN on T1.ID = T2.ID. 3) When filtering for valid symptoms: add WHERE T2.Symptoms IS NOT NULL to exclude null symptom values. 4) When finding the youngest patient: order by T1.Birthday DESC instead of examination date to identify the patient with the most recent birthday (youngest). 5) When limiting results: take only the first row after ordering by birthday to get the youngest patient's record."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT s.symptom_name, d.diagnosis_name \nFROM patients p\nJOIN medical_examinations me ON p.patient_id = me.patient_id\nJOIN symptoms s ON me.examination_id = s.examination_id\nJOIN diagnoses d ON me.examination_id = d.examination_id\nWHERE p.age = (SELECT MIN(age) FROM patients)\nORDER BY me.examination_date DESC\nLIMIT 1;",
            "SELECT T2.Symptoms, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Examination AS T2 ON T1.ID = T2.ID\nWHERE T2.Symptoms IS NOT NULL\nORDER BY T1.Birthday DESC\nLIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.Symptoms, T1.Diagnosis \nFROM Patient AS T1 \nINNER JOIN Examination AS T2 ON T1.ID = T2.ID \nWHERE T2.Symptoms IS NOT NULL \nORDER BY T1.Birthday DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "885": {
        "db_id": "formula_1",
        "question": "State the name and date of the last round of race in year 1999.",
        "ground_truth": "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1",
        "amends": [
            "Do order by `round DESC` instead of `date ASC` to sort by race round in descending order rather than date in ascending order, which changes the prioritization logic for the LIMIT 1 result. The amended query now matches RIGHT_SQL's behavior by selecting the race with the highest round number from 1999 instead of the earliest date."
        ],
        "rules": [
            "1) When answering about \"the last round of race in year 1999\": make sure the output order: round DESC. 2) When the question mentions \"last round\": this means the highest round number in the year. 3) When the question asks for \"name and date\" of the last round: select the name and date columns from the races table. 4) When filtering for year 1999: include only rows where year = 1999. 5) When selecting the last round: use LIMIT 1 after ordering by round DESC to get the single row with the highest round number."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, date FROM races WHERE year = 1999 ORDER BY date ASC LIMIT 1;",
            "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "95": {
        "db_id": "financial",
        "question": "List out the account numbers of clients who are youngest and have highest average salary?",
        "ground_truth": "SELECT T1.account_id  FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id INNER JOIN district AS T4 on T4.district_id = T1.district_id WHERE T2.client_id = ( SELECT client_id FROM client ORDER BY birth_date DESC LIMIT 1) GROUP BY T4.A11, T1.account_id",
        "amends": [
            "Do use `SELECT T1.account_id` instead of `SELECT account_number` and change the source from `clients` to multiple joined tables including `account AS T1`, `disp AS T2`, `client AS T3`, and `district AS T4`. Do add `INNER JOIN` relationships with `ON T1.account_id = T2.account_id`, `ON T2.client_id = T3.client_id`, and `on T4.district_id = T1.district_id` instead of no joins. Do add a `WHERE` filter with `T2.client_id = (subquery)` instead of no filter, where the subquery uses `ORDER BY birth_date DESC` instead of `ORDER BY age ASC, salary DESC`. Do add `GROUP BY T4.A11, T1.account_id` instead of no grouping, and remove the `LIMIT 1` from the main query instead of keeping it. The amended query now correctly identifies the account associated with the youngest client based on birth date rather than simply selecting from a single table with age and salary ordering."
        ],
        "rules": [
            "1) When the question asks for \"account numbers\": use the exact identifier \"T1.account_id\" instead of \"account_number\" and source from multiple joined tables including \"account AS T1\", \"disp AS T2\", \"client AS T3\", and \"district AS T4\". 2) When combining tables for shared entities: link rows where \"T1.account_id = T2.account_id\", \"T2.client_id = T3.client_id\", and \"T4.district_id = T1.district_id\" using inner matches only. 3) When the question asks for \"youngest client\": use \"birth_date DESC\" ordering instead of \"age ASC\" to identify the youngest client based on birth date. 4) When filtering for the youngest client: use a subquery with \"ORDER BY birth_date DESC\" to identify the target client instead of direct ordering in the main query. 5) When organizing results: use \"GROUP BY T4.A11, T1.account_id\" instead of no grouping. 6) When the question asks for \"highest average salary\": this condition is not directly addressed in the final query structure as the amends focus on birth date for youngest client identification."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_number FROM clients ORDER BY age ASC, salary DESC LIMIT 1;",
            "SELECT T1.account_id\nFROM account AS T1\nINNER JOIN disp AS T2 ON T1.account_id = T2.account_id\nINNER JOIN client AS T3 ON T2.client_id = T3.client_id\nINNER JOIN district AS T4 ON T4.district_id = T1.district_id\nWHERE T2.client_id = (\n    SELECT client_id \n    FROM client \n    ORDER BY birth_date DESC \n    LIMIT 1\n)\nGROUP BY T4.A11, T1.account_id"
        ],
        "rule_sql": [
            "SELECT T1.account_id\nFROM account AS T1\nJOIN disp AS T2 ON T1.account_id = T2.account_id\nJOIN client AS T3 ON T2.client_id = T3.client_id\nJOIN district AS T4 ON T4.district_id = T1.district_id\nWHERE T3.client_id = (\n    SELECT client_id \n    FROM client \n    ORDER BY birth_date DESC \n    LIMIT 1\n)\nGROUP BY T4.A11, T1.account_id;"
        ],
        "amend_res": 1
    },
    "422": {
        "db_id": "card_games",
        "question": "What is the language of the card with the multiverse number 149934?",
        "ground_truth": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
        "amends": [
            "Do query the `foreign_data` table instead of the `cards` table. Do use the column name `multiverseid` instead of `multiverse_id`. Do remove the quotes around the numeric value `149934` instead of treating it as a string. The amended query now correctly retrieves language data from the appropriate table with proper column reference and numeric value handling."
        ],
        "rules": [
            "1) When answering about the language of a card with a specific multiverse number: query the \"foreign_data\" table instead of the \"cards\" table. 2) When the question mentions \"multiverse number\": use the column name \"multiverseid\" (without quotes) instead of \"multiverse_id\". 3) When searching for a numeric multiverseid value like \"149934\": use the numeric value 149934 without quotes instead of treating it as a string."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language FROM cards WHERE multiverse_id = '149934';",
            "SELECT language FROM foreign_data WHERE multiverseid = 149934;"
        ],
        "rule_sql": [
            "SELECT language FROM foreign_data WHERE multiverseid = 149934"
        ],
        "amend_res": 1
    },
    "183": {
        "db_id": "financial",
        "question": "How many accounts in Beroun were opened after 1996?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T1.date) > '1996' AND T2.A2 = 'Beroun'",
        "amends": [
            "Do join `account AS T1` with `district AS T2` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do filter on `T2.A2 = 'Beroun'` instead of `city = 'Beroun'` to reference the correct table and column. Do use `STRFTIME('%Y', T1.date) > '1996'` for year extraction and comparison instead of `opened_date > '1996-12-31'` for proper date handling. Do count `account_id` instead of `COUNT(*)` for more precise counting of non-null values. The amended query now correctly joins the necessary tables and uses proper date filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about accounts in Beroun: join table \"account\" as T1 with table \"district\" as T2 using T1.district_id = T2.district_id to get location information. 2) When filtering for Beroun location: use T2.A2 = 'Beroun' instead of city column to reference the correct district table column. 3) When checking accounts opened after 1996: extract year from T1.date using STRFTIME('%Y', T1.date) > '1996' for proper date handling instead of direct date comparison. 4) When counting accounts: count T1.account_id instead of all rows for more precise counting of non-null values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE city = 'Beroun' AND opened_date > '1996-12-31';",
            "SELECT COUNT(T1.account_id) \nFROM account AS T1 \nJOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T2.A2 = 'Beroun' \nAND STRFTIME('%Y', T1.date) > '1996'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM account AS T1\nJOIN district AS T2 ON T1.district_id = T2.district_id\nWHERE T2.A2 = 'Beroun' \nAND STRFTIME('%Y', T1.date) > '1996'"
        ],
        "amend_res": 1
    },
    "768": {
        "db_id": "superhero",
        "question": "How many superheroes were published by Dark Horse Comics?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'",
        "amends": [
            "Do count `T1.id` instead of `*` to avoid counting nulls. Do join `publisher AS T2` instead of querying the `publisher` column directly. Do use the join condition `T1.publisher_id = T2.id` instead of filtering on a string value. Do filter on `T2.publisher_name = 'Dark Horse Comics'` instead of `publisher = 'Marvel Comics'` to correctly reference the publisher table and change the target publisher. The amended query now properly counts superheroes from Dark Horse Comics using the correct table relationships."
        ],
        "rules": [
            "1) When counting superheroes: count using T1.id instead of all columns to avoid counting nulls. 2) When the question mentions \"published by Dark Horse Comics\": this means filtering on T2.publisher_name = 'Dark Horse Comics' exactly as written. 3) When combining superheroes and publisher tables: link rows where T1.publisher_id = T2.id and keep only matching pairs (inner match). 4) When answering about \"how many superheroes were published by Dark Horse Comics\": make sure to count T1.id after filtering for T2.publisher_name = 'Dark Horse Comics'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE publisher = 'Marvel Comics';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id\nWHERE T2.publisher_name = 'Dark Horse Comics'"
        ],
        "rule_sql": [
            "SELECT COUNT(superhero.id) \nFROM superhero \nINNER JOIN publisher ON superhero.publisher_id = publisher.id \nWHERE publisher.publisher_name = 'Dark Horse Comics'"
        ],
        "amend_res": 1
    },
    "831": {
        "db_id": "superhero",
        "question": "What is Abomination's eye colour?",
        "ground_truth": "SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Abomination'",
        "amends": [
            "Do select `T2.colour` from the joined `colour` table instead of directly selecting `eye_color` from the `characters` table. Do join `superhero AS T1` and `colour AS T2` with an `INNER JOIN` on `T1.eye_colour_id = T2.id` instead of querying a single table without any joins. Do filter on `T1.superhero_name = 'Abomination'` instead of filtering on `name = 'Abomination'` to use the correct column name from the proper table. The amended query now correctly retrieves eye color information through proper table relationships and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about eye colour for a specific character: use the exact literal 'Abomination' to filter by superhero_name in the superhero table (T1). 2) When retrieving eye colour information: select the colour column from the colour table (T2) instead of directly from the characters table. 3) When combining superhero and colour tables: link rows where T1.eye_colour_id equals T2.id using an inner join to ensure proper table relationships. 4) When filtering by character name: use T1.superhero_name = 'Abomination' instead of name = 'Abomination' to match the correct column name from the proper table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color FROM characters WHERE name = 'Abomination';",
            "SELECT T2.colour \nFROM superhero AS T1 \nINNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id \nWHERE T1.superhero_name = 'Abomination'"
        ],
        "rule_sql": [
            "SELECT c.colour \nFROM superhero s\nINNER JOIN colour c ON s.eye_colour_id = c.id\nWHERE s.superhero_name = 'Abomination'"
        ],
        "amend_res": 1
    },
    "549": {
        "db_id": "codebase_community",
        "question": "From which post is the tag \"bayesian\" excerpted from? Please give the body of the post.",
        "ground_truth": "SELECT T2.Body FROM tags AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId WHERE T1.TagName = 'bayesian'",
        "amends": [
            "Do use `T2.Body` instead of `body` and specify the table alias. Do add `tags AS T1` and `posts AS T2` as FROM sources instead of only `posts`. Do use `INNER JOIN` on `T2.Id = T1.ExcerptPostId` instead of no join condition. Do filter on `T1.TagName = 'bayesian'` instead of `tag = 'bayesian'`. Do remove `LIMIT 1` instead of keeping it. The amended query now correctly joins the tags and posts tables to find posts associated with the 'bayesian' tag through the ExcerptPostId relationship."
        ],
        "rules": [
            "1) When the question asks about a tag excerpted from a post: use \"tags\" as T1 and \"posts\" as T2 with an inner join on T2.Id = T1.ExcerptPostId. 2) When filtering for the tag \"bayesian\": use T1.TagName = 'bayesian' exactly as specified. 3) When selecting the post body: use T2.Body as the output column. 4) When the question asks for the post from which a tag is excerpted: do not apply any row limits since there should be exactly one matching post per tag."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT body FROM posts WHERE tag = 'bayesian' LIMIT 1;",
            "SELECT T2.Body \nFROM tags AS T1 \nINNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId \nWHERE T1.TagName = 'bayesian'"
        ],
        "rule_sql": [
            "SELECT T2.Body \nFROM tags AS T1 \nINNER JOIN posts AS T2 ON T2.Id = T1.ExcerptPostId \nWHERE T1.TagName = 'bayesian'"
        ],
        "amend_res": 1
    },
    "1449": {
        "db_id": "student_club",
        "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
        "ground_truth": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
        "amends": [
            "Do select `DISTINCT T1.first_name, T1.last_name, T2.major_name` instead of `name, major`. Do add `INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major` and `INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member` instead of omitting these table joins. Do change the filter to `T3.cost > 100` instead of `expense > 100` to reference the correct expense table column. Do use proper table aliases `T1`, `T2`, and `T3` instead of unqualified column references. The amended query now correctly joins the member, major, and expense tables to filter members with expenses over 100 and returns their distinct names with proper major information."
        ],
        "rules": [
            "1) When answering about members who spent more than a hundred dollars on an expense: make sure the output order: first_name, last_name, major_name. 2) When the question mentions \"name\": \"name\" actually means \"first_name and last_name in schema\". 3) When the question mentions \"major\": \"major\" actually means \"major_name in schema\". 4) When combining T1 (members) and T2 (major) for shared entities: link rows where T2.major_id = T1.link_to_major; keep only matching pairs (inner match). 5) When combining T1 (members) and T3 (expense) for shared entities: link rows where T1.member_id = T3.link_to_member; keep only matching pairs (inner match). 6) When filtering for expenses over 100 dollars: use T3.cost > 100 as the exact condition. 7) When selecting member information: return distinct combinations of T1.first_name, T1.last_name, T2.major_name to avoid duplicate entries."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, major FROM members WHERE expense > 100",
            "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nINNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member\nWHERE T3.cost > 100"
        ],
        "rule_sql": [
            "SELECT DISTINCT m.first_name, m.last_name, maj.major_name\nFROM member m\nINNER JOIN major maj ON m.link_to_major = maj.major_id\nINNER JOIN expense e ON m.member_id = e.link_to_member\nWHERE e.cost > 100\nORDER BY m.first_name, m.last_name, maj.major_name;"
        ],
        "amend_res": 1
    },
    "1006": {
        "db_id": "formula_1",
        "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
        "evidence": "",
        "ground_truth": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
        "amends": [
            "Do select `time` instead of `MIN(lap_time)` and use the `lapTimes` table instead of `lap_records`. Do remove the `WHERE` filter with subquery on `circuits` table instead of keeping it. Do add complex time parsing logic using `INSTR`, `SUBSTR`, and `CAST` functions to convert time strings to seconds instead of omitting it. Do use `ORDER BY` with arithmetic expression for time conversion instead of aggregation. Do add `LIMIT 1` instead of using `MIN()` aggregation. The amended query now correctly handles time format conversion and finds the minimum lap time by sorting converted time values.",
            "Do use a comprehensive `CASE` expression to handle both minute:second.millisecond and hour:minute:second.millisecond time formats instead of assuming only minute:second format. Do add conditional logic to check for multiple colons with `INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')` instead of omitting this validation. Do include hour conversion with `* 3600` when multiple colons are detected instead of only handling minutes and seconds. Do adjust the minute extraction logic to account for different time format scenarios with conditional positioning instead of fixed substring positions. Do use `REAL` casting consistently throughout the time conversion instead of mixing `INTEGER` and `REAL` types. Do add explicit `ASC` ordering instead of relying on default ordering. The amended query now correctly handles both time formats and matches RIGHT_SQL's behavior.",
            "Do use a simplified arithmetic expression with four additive components instead of complex nested CASE logic with string manipulation. Do calculate hours component as `CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END` instead of the original hour-minute-second conversion. Do compute minutes using conditional position calculation `INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':'))` instead of the previous substring approach. Do extract seconds before decimal point with `SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1)` instead of the complex nested substring logic. Do add millisecond precision with `CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000` instead of ignoring fractional seconds. The amended query now correctly handles time formats with hours, minutes, seconds, and milliseconds while maintaining the same ORDER BY ASC LIMIT 1 behavior.",
            "Do simplify the time parsing logic by removing the complex CASE statements for minute extraction and instead use `INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':'))` for minute position calculation instead of nested conditional logic. Do use direct position calculation `INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1` for seconds extraction instead of complex CASE-based substring positioning. Do maintain the same hour calculation logic with `CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END` for proper hour detection. Do preserve the millisecond handling with `CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000` for fractional seconds. The amended query now correctly parses time strings in MM:SS.sss or HH:MM:SS.sss format by simplifying the complex conditional logic while maintaining the same ordering behavior to find the fastest lap time.",
            "Do add proper parentheses around each arithmetic component in the ORDER BY expression instead of having them concatenated without grouping. Do fix the second CAST expression's SUBSTR parameters to use `INSTR(time, ':') - 1` instead of the complex incorrect calculation that referenced `INSTR(time, '.') - INSTR(time, ':') - 1`. Do maintain the same CASE logic for hour conversion but ensure all time components are properly isolated with parentheses for correct mathematical precedence. The amended query now correctly parses time strings by properly separating hours, minutes, seconds, and milliseconds with appropriate mathematical operations."
        ],
        "rules": [],
        "rule_res": 0,
        "amend_sql": [
            "SELECT MIN(lap_time) FROM lap_records WHERE circuit_id = (SELECT circuit_id FROM circuits WHERE country = 'Monaco');",
            "SELECT time \nFROM lapTimes \nORDER BY CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS INTEGER) * 60 + \n         CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS INTEGER) + \n         CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') + 1) AS REAL)\n        ELSE\n            CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 + \n            CAST(SUBSTR(time, INSTR(time, ':') + 1) AS REAL)\n    END ASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    CASE \n        WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n        THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n        ELSE 0 \n    END +\n    CAST(SUBSTR(time, \n        CASE \n            WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n            THEN INSTR(time, ':') + 1 \n            ELSE 1 \n        END, \n        CASE \n            WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n            THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1 \n            ELSE INSTR(time, ':') - 1 \n        END\n    ) AS REAL) * 60 +\n    CAST(SUBSTR(time, \n        CASE \n            WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n            THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1 \n            ELSE INSTR(time, ':') + 1 \n        END, \n        INSTR(time, '.') - \n        CASE \n            WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n            THEN INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + 1 \n            ELSE INSTR(time, ':') + 1 \n        END\n    ) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nASC \nLIMIT 1;",
            "SELECT time\nFROM lapTimes\nORDER BY \n    CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n         THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n         ELSE 0 \n    END +\n    CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), \n         INSTR(time, ':') + 1, \n         INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) * 60 +\n    CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000\nASC\nLIMIT 1;",
            "SELECT time \nFROM lapTimes \nORDER BY \n    (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n          THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 \n          ELSE 0 \n     END) +\n    (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') \n          THEN CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') - 1) AS REAL) * 60 \n          ELSE CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 60 \n     END) +\n    CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL) +\n    CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000 \nASC \nLIMIT 1;"
        ],
        "rule_sql": [],
        "amend_res": 0
    },
    "1078": {
        "db_id": "european_football_2",
        "question": "Which player is older, Aaron Lennon or Abdelaziz Barrada?",
        "ground_truth": "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1",
        "amends": [
            "Do select `player_name` instead of using a CASE expression with subqueries. Do query from `Player` table instead of `players` table. Do use `WHERE player_name IN` with explicit names instead of separate subqueries for each player. Do add `ORDER BY birthday ASC` to sort by birth date instead of comparing dates in a CASE statement. Do add `LIMIT 1` to return only the oldest player instead of returning a descriptive string. Do remove the CASE expression and subqueries entirely instead of keeping complex conditional logic. The amended query now correctly identifies the older player by sorting by birthday and returning the first result, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about player ages: use the \"Player\" table instead of \"players\" table. 2) When comparing specific players by age: use \"WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada')\" with exact name literals instead of separate subqueries. 3) When determining the older player: sort by \"birthday ASC\" to get players in ascending order of birth date. 4) When only the oldest player is needed: use \"LIMIT 1\" to return only the first result after sorting. 5) When outputting results: return the actual \"player_name\" value instead of a descriptive CASE statement."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    CASE \n        WHEN (SELECT birth_date FROM players WHERE name = 'Aaron Lennon') > (SELECT birth_date FROM players WHERE name = 'Abdelaziz Barrada') \n        THEN 'Aaron Lennon is older' \n        ELSE 'Abdelaziz Barrada is older' \n    END AS older_player;",
            "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT player_name FROM Player WHERE player_name IN ('Aaron Lennon', 'Abdelaziz Barrada') ORDER BY birthday ASC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1290": {
        "db_id": "thrombosis_prediction",
        "question": "What is the examination date of the patient whose albumin is the highest in the normal range?",
        "ground_truth": "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1",
        "amends": [
            "Do select `Date` instead of `examination_date` and use `ALB` instead of `albumin` for the column name. Do filter with `ALB > 3.5 AND ALB < 5.5` instead of `albumin BETWEEN 18 AND 54` to use proper range boundaries. Do remove the subquery that finds maximum albumin and instead use `ORDER BY ALB DESC LIMIT 1` to directly get the highest value within the range. Do change the table name from `patients` to `Laboratory` to reflect the correct data source. Do add `ORDER BY` and `LIMIT` clauses instead of using an equality subquery to efficiently retrieve the single highest value. The amended query now correctly returns the date of the highest albumin measurement within the specified clinical range."
        ],
        "rules": [
            "1) When the question asks for \"examination date\": use the exact column name \"Date\" from the Laboratory table. 2) When the question refers to \"albumin\": use the exact column name \"ALB\" from the Laboratory table. 3) When filtering for \"normal range\" of albumin: use the condition ALB > 3.5 AND ALB < 5.5 as the proper clinical range boundaries. 4) When finding the \"highest\" value within a range: order rows by ALB in descending order and take only the first row. 5) When retrieving data about laboratory measurements: use the Laboratory table as the data source instead of patients."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT examination_date FROM patients WHERE albumin = (SELECT MAX(albumin) FROM patients WHERE albumin BETWEEN 18 AND 54) AND albumin BETWEEN 18 AND 54;",
            "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1;"
        ],
        "amend_res": 1
    },
    "1018": {
        "db_id": "formula_1",
        "question": "What was the average time in milliseconds Lewis Hamilton spent at a pit stop during Formula_1 races?",
        "ground_truth": "SELECT AVG(milliseconds) FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'",
        "amends": [
            "Do join `pitStops AS T1` with `drivers AS T2` on `T1.driverId = T2.driverId` instead of querying only the `pit_stops` table without any join. Do filter on `T2.forename = 'Lewis' AND T2.surname = 'Hamilton'` instead of using `driver_name = 'Lewis Hamilton'` which doesn't exist in the schema. Do aggregate `AVG(milliseconds)` instead of `AVG(pit_stop_time)` to use the correct column name from the joined table. The amended query now correctly joins the necessary tables and uses proper column references to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"average time in milliseconds Lewis Hamilton spent at a pit stop\": make sure the output order: AVG(milliseconds). 2) When the question mentions \"Lewis Hamilton\": \"Lewis Hamilton\" actually means \"T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.driverId = T2.driverId; keep only matching pairs (inner match). 4) When the question asks for \"average time in milliseconds\": compute AVG(milliseconds) from T1 instead of pit_stop_time."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(pit_stop_time) FROM pit_stops WHERE driver_name = 'Lewis Hamilton';",
            "SELECT AVG(T1.milliseconds) AS average_pit_stop_time\nFROM pitStops AS T1\nJOIN drivers AS T2 ON T1.driverId = T2.driverId\nWHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'"
        ],
        "rule_sql": [
            "SELECT AVG(pitStops.milliseconds) \nFROM pitStops \nJOIN drivers ON pitStops.driverId = drivers.driverId \nWHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'"
        ],
        "amend_res": 1
    },
    "1528": {
        "db_id": "debit_card_specializing",
        "question": "What is the percentage of \"premium\" against the overall segment in Country = \"SVK\"?",
        "evidence": "",
        "ground_truth": "SELECT CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations",
        "amends": [
            "Do use `SUM(IIF(condition, 1, 0))` aggregation instead of `COUNT(CASE WHEN condition THEN 1 END)` for conditional counting. Do apply the `Country = 'SVK'` filter within the conditional expressions instead of in a `WHERE` clause to ensure proper denominator calculation. Do cast the numerator to `FLOAT` instead of using `100.0` for explicit type handling. Do query from the `gasstations` table instead of the `customers` table to use the correct data source. Do calculate the percentage using the formula `numerator * 100 / denominator` instead of `numerator * 100.0 / COUNT(*)` to properly handle the conditional denominator. The amended query now correctly calculates the premium percentage for SVK country while ensuring both numerator and denominator use the same country filter condition.",
            "Do cast the numerator as `FLOAT` before division instead of using implicit integer division. Do use `Premium` instead of `premium` for case-sensitive string matching. Do remove the table alias `g` from column references instead of keeping unnecessary aliasing. Do place the `Country` filter before the `Segment` filter in the IIF condition instead of the reverse order. Do omit the redundant `AS PremiumPercentage` alias instead of including it. The amended query now correctly handles floating-point division and case-sensitive string matching to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about percentage of \"premium\" segment in Country = \"SVK\": use the gasstations table as the data source instead of customers table. 2) When calculating conditional counts: use SUM(IIF(condition, 1, 0)) aggregation instead of COUNT(CASE WHEN condition THEN 1 END). 3) When filtering for Country = \"SVK\": apply the filter within both numerator and denominator conditional expressions instead of using a WHERE clause to ensure proper denominator calculation. 4) When handling numeric calculations: cast the numerator to FLOAT instead of using 100.0 for explicit type handling. 5) When calculating percentage: use the formula numerator * 100 / denominator instead of numerator * 100.0 / COUNT(*) to properly handle the conditional denominator.",
            "1) When the question asks for percentage of \"premium\" segment in Country = \"SVK\": compute (number of rows where \"Segment\" = 'Premium' and \"Country\" = 'SVK') divided by (number of rows where \"Country\" = 'SVK') multiplied by 100.0. 2) When handling string literals: use exact case 'Premium' instead of 'premium' for matching the \"Segment\" column. 3) When performing division: cast the numerator to FLOAT before division to avoid integer division. 4) When filtering conditions: place the \"Country\" = 'SVK' filter before the \"Segment\" = 'Premium' filter in conditional logic. 5) When referencing columns: use unaliased column names \"Country\" and \"Segment\" instead of table-prefixed versions."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN segment = 'premium' THEN 1 END) * 100.0 / COUNT(*)) AS premium_percentage\nFROM customers\nWHERE country = 'SVK';",
            "SELECT \n    (SUM(IIF(g.Segment = 'premium' AND g.Country = 'SVK', 1, 0)) * 100.0 / \n     SUM(IIF(g.Country = 'SVK', 1, 0))) AS PremiumPercentage\nFROM \n    gasstations g",
            "SELECT \n    SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) * 100.0 / \n    SUM(IIF(Country = 'SVK', 1, 0)) AS PremiumPercentage\nFROM gasstations"
        ],
        "rule_sql": [
            "SELECT \n    CAST(SUM(IIF(Country = 'SVK' AND Segment = 'Premium', 1, 0)) AS FLOAT) * 100 / \n    SUM(IIF(Country = 'SVK', 1, 0)) AS Percentage\nFROM gasstations"
        ],
        "amend_res": 1
    },
    "1276": {
        "db_id": "thrombosis_prediction",
        "question": "For the patients who have an abnormal level of anti-DNA, please list the diseases they are diagnosed with.",
        "ground_truth": "SELECT DISTINCT(T1.Diagnosis) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA >= 8",
        "amends": [
            "Do select `DISTINCT(T1.Diagnosis)` instead of `disease_name` to retrieve unique diagnosis values. Do use `FROM Patient AS T1 INNER JOIN Laboratory AS T2` instead of `FROM patients` to join two tables. Do apply join condition `ON T1.ID = T2.ID` instead of no join condition. Do filter with `WHERE T2.DNA >= 8` instead of `WHERE anti_dna_level = 'normal'` to use a numeric comparison against a threshold value. The amended query now correctly joins patient and laboratory data to find diagnoses where DNA levels meet the specified threshold."
        ],
        "rules": [
            "1) When answering about \"diseases diagnosed with abnormal anti-DNA level\": make sure the output order: T1.Diagnosis\n2) When the question mentions \"diseases they are diagnosed with\": \"diseases\" actually means \"T1.Diagnosis in schema\"\n3) When retrieving diagnosis values: select distinct T1.Diagnosis to get unique values\n4) When combining Patient and Laboratory tables: link rows where T1.ID = T2.ID and keep only matching pairs (inner match)\n5) When filtering for abnormal anti-DNA level: use T2.DNA >= 8 as the threshold condition\n6) When handling text literals: do not change case, spacing, or punctuation for numeric threshold values"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT disease_name FROM patients WHERE anti_dna_level = 'normal';",
            "SELECT DISTINCT(T1.Diagnosis) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA >= 8"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.Diagnosis\nFROM Patient T1\nINNER JOIN Laboratory T2 ON T1.ID = T2.ID\nWHERE T2.DNA >= 8"
        ],
        "amend_res": 1
    },
    "310": {
        "db_id": "toxicology",
        "question": "How many molecules have a double bond type and among these molecule, how many are labeled as carcinogenic compound?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id), SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '='",
        "amends": [
            "Do use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all bonds. Do change the source tables to `bond AS T1 INNER JOIN molecule AS T2` instead of just `molecules` to properly join the bond and molecule tables. Do use the join condition `ON T1.molecule_id = T2.molecule_id` instead of no join condition. Do change the carcinogenic check to `T2.label = '+'` instead of `carcinogenic = 'yes'` to use the correct column and value. Do modify the bond type filter to `T1.bond_type = '='` instead of `bond_type = 'double'` to use the correct table reference and value syntax. The amended query now correctly counts distinct molecules with double bonds and properly identifies carcinogenic molecules using the label column.",
            "Do use `COUNT(DISTINCT T2.molecule_id)` for the first column instead of `COUNT(DISTINCT T1.molecule_id)` to ensure consistent molecule counting from the molecule table. Do use `SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END)` instead of `COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T1.molecule_id END)` to count occurrences rather than distinct molecules, which correctly handles multiple double bonds per molecule. Do remove the column aliases `total_molecules_with_double_bonds` and `carcinogenic_molecules_with_double_bonds` instead of keeping them for a more concise output format. The amended query now matches RIGHT_SQL's behavior by properly counting carcinogenic occurrences rather than distinct carcinogenic molecules with double bonds."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(DISTINCT T2.molecule_id) instead of COUNT(*) to count unique molecules rather than all bonds. 2) When combining bond and molecule tables: use bond AS T1 INNER JOIN molecule AS T2 with join condition ON T1.molecule_id = T2.molecule_id instead of querying a single table. 3) When checking for carcinogenic compounds: use T2.label = '+' instead of carcinogenic = 'yes' to use the correct column and value. 4) When filtering for double bond type: use T1.bond_type = '=' instead of bond_type = 'double' to use the correct table reference and value syntax.",
            "1) When counting molecules with double bonds: use COUNT(DISTINCT T2.molecule_id) to count distinct molecules from the molecule table rather than from the bond table. 2) When counting carcinogenic compounds among molecules with double bonds: use SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) to count occurrences rather than distinct molecules, as multiple double bonds per molecule should be handled. 3) When the question asks about molecules labeled as carcinogenic compounds: \"labeled as carcinogenic compound\" means T2.label = '+' exactly. 4) When the question asks about double bond type: \"double bond type\" means T1.bond_type = '=' exactly. 5) When combining bond and molecule tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 6) When producing output: do not include column aliases total_molecules_with_double_bonds and carcinogenic_molecules_with_double_bonds for a concise format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS total_molecules, \n       SUM(CASE WHEN carcinogenic = 'yes' THEN 1 ELSE 0 END) AS carcinogenic_count\nFROM molecules\nWHERE bond_type = 'double'",
            "SELECT \n    COUNT(DISTINCT T1.molecule_id) AS total_molecules_with_double_bonds,\n    COUNT(DISTINCT CASE WHEN T2.label = '+' THEN T1.molecule_id END) AS carcinogenic_molecules_with_double_bonds\nFROM \n    bond AS T1 \nINNER JOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '='",
            "SELECT \n    COUNT(DISTINCT T2.molecule_id) AS total_molecules_with_double_bonds,\n    SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules_with_double_bonds\nFROM bond AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT \n    COUNT(DISTINCT T2.molecule_id) AS total_molecules_with_double_bonds,\n    SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS carcinogenic_molecules_with_double_bonds\nFROM \n    bond AS T1 \nINNER JOIN \n    molecule AS T2 \nON \n    T1.molecule_id = T2.molecule_id\nWHERE \n    T1.bond_type = '='"
        ],
        "amend_res": 1
    },
    "542": {
        "db_id": "codebase_community",
        "question": "What is the total number of comments of all the posts owned by csgillespie?",
        "ground_truth": "SELECT SUM(T1.CommentCount) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do use `SUM(T1.CommentCount)` instead of `COUNT(*)` to sum existing comment counts rather than counting comment rows. Do join `posts AS T1` with `users AS T2` on `T1.OwnerUserId = T2.Id` instead of using a subquery with `post_id IN (SELECT id FROM posts)`. Do filter on `T2.DisplayName = 'csgillespie'` instead of `owner = 'csgillespie'` to properly reference the user's display name through the joined users table. Do remove the subquery structure and instead use a direct join between posts and users tables. The amended query now correctly calculates the total comment count for the specified user by summing existing comment counts through proper table relationships."
        ],
        "rules": [
            "1) When answering about \"total number of comments of all the posts owned by csgillespie\": make sure the output order: SUM(T1.CommentCount). 2) When the question mentions \"csgillespie\": \"csgillespie\" actually means \"T2.DisplayName = 'csgillespie'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.OwnerUserId = T2.Id; keep only matching pairs (inner match). 4) When calculating total comments: use SUM(T1.CommentCount) to sum existing comment counts rather than counting comment rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM comments WHERE post_id IN (SELECT id FROM posts WHERE owner = 'csgillespie');",
            "SELECT SUM(T1.CommentCount) \nFROM posts AS T1 \nJOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie'"
        ],
        "rule_sql": [
            "SELECT SUM(posts.CommentCount) \nFROM posts \nINNER JOIN users ON posts.OwnerUserId = users.Id \nWHERE users.DisplayName = 'csgillespie'"
        ],
        "amend_res": 1
    },
    "867": {
        "db_id": "formula_1",
        "question": "For the driver who set the fastest lap speed in race No.933, where does he come from?",
        "ground_truth": "SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.raceId = 933 AND T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
        "amends": [
            "Do use table alias `T1` for `drivers` instead of `driver`, and `T2` for `results` instead of `race_result`. Do specify `INNER JOIN` explicitly instead of just `JOIN`. Do join on `T2.driverId = T1.driverId` instead of `driver.driver_id = race_result.driver_id`. Do add filter `T2.fastestLapTime IS NOT NULL` to exclude null lap times instead of omitting it. Do reference `T2.fastestLapSpeed` in ORDER BY instead of `race_result.fastest_lap_speed`. The amended query now correctly filters for non-null lap times before ordering by speed, ensuring valid results."
        ],
        "rules": [
            "1) When answering about the fastest lap speed driver's nationality: use table alias T1 for \"drivers\" and T2 for \"results\" 2) When combining drivers and results tables: link rows where T2.driverId = T1.driverId using inner join 3) When filtering for race No.933: use T2.race_id = 933 4) When handling fastest lap data: add filter T2.fastestLapTime IS NOT NULL to exclude null lap times 5) When ordering by fastest lap speed: reference T2.fastestLapSpeed in descending order 6) When limiting to the fastest driver: take only the first row after ordering 7) When selecting the driver's origin: output T1.nationality"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver.nationality FROM driver JOIN race_result ON driver.driver_id = race_result.driver_id WHERE race_result.race_id = 933 ORDER BY race_result.fastest_lap_speed DESC LIMIT 1;",
            "SELECT T1.nationality \nFROM drivers T1\nINNER JOIN results T2 ON T2.driverId = T1.driverId\nWHERE T2.raceId = 933 \nAND T2.fastestLapTime IS NOT NULL\nORDER BY T2.fastestLapSpeed DESC\nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T1.nationality \nFROM drivers T1\nINNER JOIN results T2 ON T2.driverId = T1.driverId\nWHERE T2.raceId = 933 \nAND T2.fastestLapTime IS NOT NULL\nORDER BY T2.fastestLapSpeed DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "386": {
        "db_id": "card_games",
        "question": "How many cards are having future frame version and what are the legality status of these cards?",
        "ground_truth": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
        "amends": [
            "Do specify `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do add `INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid` instead of querying only the `cards` table to incorporate legality data through proper table joining. Do reference `T1.frameVersion` instead of `frame_version` to use the correct column name with proper table alias. Do remove `GROUP BY legality_status` and the `legality_status` column from the SELECT list instead of grouping by it, as the right query performs a simple count without grouping. Do omit the `card_count` alias instead of including it since the count result doesn't require an alias in this context. The amended query now correctly counts future frame cards with associated legality records by joining the appropriate tables."
        ],
        "rules": [
            "1) When counting cards: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When incorporating legality data: add INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid to properly join tables through the uuid key. 3) When checking frame version: reference T1.frameVersion instead of frame_version to use the correct column name with proper table alias. 4) When the question asks for count without grouping by legality status: remove GROUP BY legality_status and the legality_status column from the SELECT list. 5) When producing count results: omit the card_count alias since the count result doesn't require an alias in this context."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) as card_count, legality_status \nFROM cards \nWHERE frame_version = 'future' \nGROUP BY legality_status;",
            "SELECT COUNT(T1.id) \nFROM cards AS T1 \nINNER JOIN legalities AS T2 ON T1.uuid = T2.uuid \nWHERE T1.frameVersion = 'future'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'"
        ],
        "amend_res": 1
    },
    "838": {
        "db_id": "superhero",
        "question": "Provide the full name of the superhero named Alien.",
        "evidence": "",
        "ground_truth": "SELECT full_name FROM superhero WHERE superhero_name = 'Alien'",
        "amends": [
            "Do select `full_name` instead of `name` to reference the correct column. Do reference table `superhero` instead of `superheroes` to use the correct table name. The amended query now correctly retrieves the full name from the superhero table for the specified superhero name, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for \"full name\" of a superhero: use the exact column token \"full_name\" from table \"superhero\". 2) When the question specifies a superhero named \"Alien\": use the exact literal value 'Alien' for matching. 3) When referencing the superhero table: use the exact table name \"superhero\" (not \"superheroes\")."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM superheroes WHERE superhero_name = 'Alien';",
            "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';"
        ],
        "rule_sql": [
            "SELECT full_name FROM superhero WHERE superhero_name = 'Alien';"
        ],
        "amend_res": 1
    },
    "1341": {
        "db_id": "student_club",
        "question": "Give the location for \"Spring Budget Review\".",
        "ground_truth": "SELECT location FROM event WHERE event_name = 'Spring Budget Review'",
        "amends": [
            "Do reference table `event` instead of `events` in the FROM clause. Do filter on column `event_name` instead of `title` in the WHERE condition. The amended query now correctly retrieves location data from the appropriate table using the proper column name for event identification."
        ],
        "rules": [
            "1) When answering about \"location for Spring Budget Review\": make sure the output order: location. 2) When the question mentions \"Spring Budget Review\": \"Spring Budget Review\" actually means \"event_name = 'Spring Budget Review' in schema\". 3) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 4) When handling text literals: do not change case, spacing, or punctuation - use exact literal 'Spring Budget Review'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT location FROM events WHERE title = 'Spring Budget Review';",
            "SELECT location FROM event WHERE event_name = 'Spring Budget Review';"
        ],
        "rule_sql": [
            "SELECT location FROM event WHERE event_name = 'Spring Budget Review';"
        ],
        "amend_res": 1
    },
    "198": {
        "db_id": "toxicology",
        "question": "On average how many carcinogenic molecules are single bonded?",
        "ground_truth": "SELECT AVG(single_bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count FROM bond AS T1  INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' AND T3.label = '+' GROUP BY T3.molecule_id) AS subquery",
        "amends": [
            "Do use a subquery with `AVG(single_bond_count)` instead of directly aggregating `AVG(bond_count)`. Do calculate `single_bond_count` by counting `T1.bond_type` instead of using a simple aggregate. Do join `bond AS T1`, `atom AS T2`, and `molecule AS T3` with `INNER JOIN` conditions instead of querying only the `molecules` table. Do filter on `T1.bond_type = '-'` and `T3.label = '+'` instead of `carcinogenic = 1 AND bond_type = 'single'`. Do group by `T3.molecule_id` instead of omitting grouping. The amended query now correctly calculates the average count of single bonds for molecules with positive labels using proper table relationships and filtering.",
            "Do add an `INNER JOIN` with `atom AS T2` on `T1.molecule_id = T2.molecule_id` instead of omitting this table entirely, and do change the second join condition to `T3.molecule_id = T2.molecule_id` instead of directly joining `bond` to `molecule` with `T1.molecule_id = T3.molecule_id`. Do keep the same `SELECT` list with `AVG(single_bond_count)` and maintain the same `WHERE` filters for `T1.bond_type = '-'` and `T3.label = '+'`, along with the same `GROUP BY T3.molecule_id` structure. The amended query now correctly joins through the intermediate `atom` table to establish the proper relationship between bonds and molecules, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average count of single bonds for carcinogenic molecules: use AVG(single_bond_count) instead of AVG(bond_count). 2) When calculating single_bond_count: count T1.bond_type occurrences instead of using a simple aggregate. 3) When combining data from multiple tables: join bond AS T1, atom AS T2, and molecule AS T3 with INNER JOIN conditions instead of querying only the molecules table. 4) When filtering for single bonds: use T1.bond_type = '-' instead of bond_type = 'single'. 5) When filtering for carcinogenic molecules: use T3.label = '+' instead of carcinogenic = 1. 6) When grouping for molecule-level calculations: group by T3.molecule_id instead of omitting grouping.",
            "1) When joining bond and molecule tables: use atom as an intermediate table by performing an INNER JOIN between bond AS T1 and atom AS T2 on T1.molecule_id = T2.molecule_id, then INNER JOIN atom AS T2 to molecule AS T3 on T3.molecule_id = T2.molecule_id instead of directly joining bond to molecule. 2) When filtering for carcinogenic molecules: use T3.label = '+' exactly as specified. 3) When filtering for single bonds: use T1.bond_type = '-' exactly as specified. 4) When counting single bonds per molecule: group by T3.molecule_id and count T1.bond_type. 5) When computing the average: calculate the average of the single_bond_count values across all carcinogenic molecules with single bonds."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(bond_count) FROM molecules WHERE carcinogenic = 1 AND bond_type = 'single';",
            "SELECT AVG(single_bond_count) AS average_single_bonds\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count\n    FROM bond AS T1\n    INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id\n    WHERE T1.bond_type = '-' AND T3.label = '+'\n    GROUP BY T3.molecule_id\n)",
            "SELECT AVG(single_bond_count) \nFROM (\n    SELECT COUNT(T1.bond_type) AS single_bond_count\n    FROM bond AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN molecule AS T3 ON T3.molecule_id = T2.molecule_id\n    WHERE T1.bond_type = '-' AND T3.label = '+'\n    GROUP BY T3.molecule_id\n)"
        ],
        "rule_sql": [
            "SELECT AVG(single_bond_count) AS average_single_bonds\nFROM (\n    SELECT T3.molecule_id, COUNT(T1.bond_type) AS single_bond_count\n    FROM bond AS T1\n    INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n    INNER JOIN molecule AS T3 ON T2.molecule_id = T3.molecule_id\n    WHERE T3.label = '+' AND T1.bond_type = '-'\n    GROUP BY T3.molecule_id\n)"
        ],
        "amend_res": 1
    },
    "203": {
        "db_id": "toxicology",
        "question": "In how many atoms is there no bromine?",
        "ground_truth": "SELECT COUNT(DISTINCT T.atom_id) FROM atom AS T WHERE T.element <> 'br'",
        "amends": [
            "Do use `COUNT(DISTINCT T.atom_id)` instead of `COUNT(*)` to count unique atom identifiers rather than all rows. Do reference the table with alias `T` instead of using the bare table name. Do filter with `T.element <> 'br'` instead of `element = 'bromine'` to exclude bromine elements rather than including them. Do specify the table as `atom` instead of `atoms` to use the correct table name. The amended query now correctly counts distinct atom IDs excluding bromine elements, matching the intended behavior."
        ],
        "rules": [
            "1) When counting atoms: use COUNT(DISTINCT T.atom_id) to count unique atom identifiers rather than all rows. 2) When referencing the atom table: use alias T and table name atom instead of atoms. 3) When filtering for atoms without bromine: use T.element <> 'br' to exclude bromine elements rather than including them with element = 'bromine'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM atoms WHERE element = 'bromine';",
            "SELECT COUNT(DISTINCT T.atom_id) FROM atom T WHERE T.element <> 'br'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T.atom_id) FROM atom T WHERE T.element <> 'br'"
        ],
        "amend_res": 1
    },
    "301": {
        "db_id": "toxicology",
        "question": "What is the bond type of TR007_4_19?",
        "ground_truth": "SELECT T.bond_type FROM bond AS T WHERE T.bond_id = 'TR007_4_19'",
        "amends": [
            "Do use table alias `T` in the `SELECT` clause instead of omitting it. Do reference the table as `bond` instead of `bonds` in the `FROM` clause. Do use table alias `T` in the `WHERE` clause predicate `T.bond_id` instead of the unqualified column reference. The amended query now correctly uses table aliasing and the proper table name to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"bond type of TR007_4_19\": make sure the output order: bond_type. 2) When the question mentions \"bond type\": \"bond type\" actually means \"bond_type in schema\". 3) When the question mentions \"TR007_4_19\": use the exact literal 'TR007_4_19' in the condition. 4) When selecting from the bond table: use table alias T and reference columns as T.column_name. 5) When filtering for a specific bond: use the condition T.bond_id = 'TR007_4_19' with exact token matching."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT bond_type FROM bonds WHERE bond_id = 'TR007_4_19';",
            "SELECT T.bond_type FROM bond T WHERE T.bond_id = 'TR007_4_19'"
        ],
        "rule_sql": [
            "SELECT T.bond_type FROM bond T WHERE T.bond_id = 'TR007_4_19'"
        ],
        "amend_res": 1
    },
    "765": {
        "db_id": "superhero",
        "question": "How many heroes have stealth power?",
        "ground_truth": "SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'",
        "amends": [
            "Do use `COUNT(T1.hero_id)` instead of `COUNT(*)` to count specific hero records. Do join tables `hero_power AS T1 INNER JOIN superpower AS T2` instead of querying a single `heroes` table. Do use join condition `T1.power_id = T2.id` instead of a direct column filter. Do filter on `T2.power_name = 'Stealth'` with proper case sensitivity instead of `power = 'stealth'` on a non-existent column. The amended query now correctly counts heroes with the 'Stealth' power by properly joining the relationship tables instead of relying on incorrect schema assumptions."
        ],
        "rules": [
            "1) When counting heroes: use COUNT(T1.hero_id) to count specific hero records instead of COUNT(*). 2) When the question mentions \"stealth power\": \"stealth power\" actually means T2.power_name = 'Stealth' with exact case sensitivity. 3) When combining hero_power and superpower tables: link rows where T1.power_id = T2.id and keep only matching pairs (inner match). 4) When answering about \"how many heroes have stealth power\": make sure to join hero_power AS T1 INNER JOIN superpower AS T2 instead of querying a single heroes table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM heroes WHERE power = 'stealth'",
            "SELECT COUNT(T1.hero_id) \nFROM hero_power AS T1 \nINNER JOIN superpower AS T2 ON T1.power_id = T2.id \nWHERE T2.power_name = 'Stealth'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.hero_id) \nFROM hero_power AS T1 \nINNER JOIN superpower AS T2 ON T1.power_id = T2.id \nWHERE T2.power_name = 'Stealth'"
        ],
        "amend_res": 1
    },
    "479": {
        "db_id": "card_games",
        "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
        "ground_truth": "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
        "amends": [
            "Do use `SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END)` instead of `COUNT(*)` to count only specific power conditions. Do join `sets AS T2` on `T2.code = T1.setCode` instead of filtering directly on `set_name`. Do filter on `T2.name = 'Coldsnap'` instead of `set_name = 'Coldsnap'` to use the joined table's name. Do use `T1.convertedManaCost` instead of `converted_mana_cost` with correct column naming. Do remove the explicit `power IS NULL` filter from WHERE since it's handled in the CASE expression, instead counting both NULL and '*' values. The amended query now correctly counts cards with power containing '*' or being NULL while properly joining to the sets table."
        ],
        "rules": [
            "1) When joining cards and sets tables: link rows where T1.setCode = T2.code and keep only matching pairs (inner match). 2) When filtering for the Coldsnap set: use T2.name = 'Coldsnap' exactly as specified. 3) When filtering for converted mana cost higher than 5: use T1.convertedManaCost > 5 with exact column naming. 4) When counting cards with unknown power: count rows where T1.power LIKE '*' OR T1.power IS NULL using SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END). 5) When handling power conditions: do not include explicit power filters in WHERE clause since counting logic is handled in the CASE expression."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards WHERE set_name = 'Coldsnap' AND converted_mana_cost > 5 AND power IS NULL;",
            "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) AS count_unknown_power\nFROM cards AS T1\nJOIN sets AS T2 ON T2.code = T1.setCode\nWHERE T1.convertedManaCost > 5\nAND T2.name = 'Coldsnap';"
        ],
        "rule_sql": [
            "SELECT SUM(CASE WHEN T1.power LIKE '*' OR T1.power IS NULL THEN 1 ELSE 0 END) AS count_unknown_power\nFROM cards T1\nINNER JOIN sets T2 ON T1.setCode = T2.code\nWHERE T2.name = 'Coldsnap'\nAND T1.convertedManaCost > 5"
        ],
        "amend_res": 1
    },
    "975": {
        "db_id": "formula_1",
        "question": "Which year has the lowest speed of lap time?",
        "ground_truth": "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1",
        "amends": [
            "Do select `T2.year` instead of `year, MIN(lap_time) as min_lap_time` to return only the year column. Do use `FROM lapTimes AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId` instead of `FROM races` to properly join the lapTimes and races tables on the correct relationship. Do remove the `GROUP BY year` and aggregation since we're now ordering by individual lap times. Do order by `T1.time DESC` instead of `min_lap_time ASC` to find the maximum lap time rather than the minimum. Do keep the `LIMIT 1` to return only the single result. The amended query now correctly identifies the year with the slowest lap time by joining the necessary tables and ordering appropriately."
        ],
        "rules": [
            "1) When answering about \"year with lowest speed of lap time\": make sure the output order contains only T2.year. 2) When combining lapTimes and races tables: link rows where T1.raceId = T2.raceId and keep only matching pairs (inner match). 3) When the question mentions \"lowest speed\" which implies slowest lap time: order rows by T1.time in descending direction to find the maximum lap time. 4) When the question asks for a single result: keep only the first row after ordering. 5) When handling the query: do not use GROUP BY or aggregation functions since we're working with individual lap times."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT year, MIN(lap_time) as min_lap_time FROM races GROUP BY year ORDER BY min_lap_time ASC LIMIT 1;",
            "SELECT T2.year FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId ORDER BY T1.time DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT T2.year\nFROM lapTimes T1\nINNER JOIN races T2 ON T1.raceId = T2.raceId\nORDER BY T1.time DESC\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "902": {
        "db_id": "formula_1",
        "question": "Which race was Alex Yoong in when he was in track number less than 20?",
        "ground_truth": "SELECT T1.name FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId WHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20",
        "amends": [
            "Do select `T1.name` instead of `race`. Do add `races AS T1` with `INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId` and `INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId` instead of just `races`. Do change the filter to `T3.forename = 'Alex' AND T3.surname = 'Yoong'` instead of `driver = 'Alex Yoong'`. Do change the condition to `T2.position < 20` instead of `track_number > 20`. The amended query now correctly joins multiple tables to find races where Alex Yoong finished in position less than 20, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"which race Alex Yoong was in with track number less than 20\": make sure the output order: T1.name 2) When the question mentions \"race\": \"race\" actually means \"T1.name in schema\" 3) When combining tables for driver information: link rows using T2.raceId = T1.raceId and T3.driverId = T2.driverId; keep only matching pairs (inner match) 4) When filtering for driver \"Alex Yoong\": use T3.forename = 'Alex' AND T3.surname = 'Yoong' 5) When the question mentions \"track number less than 20\": \"track number\" actually means \"T2.position\" and use T2.position < 20"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT race FROM races WHERE driver = 'Alex Yoong' AND track_number > 20;",
            "SELECT T1.name \nFROM races AS T1 \nINNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId \nINNER JOIN drivers AS T3 ON T3.driverId = T2.driverId \nWHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20"
        ],
        "rule_sql": [
            "SELECT T1.name \nFROM races T1\nJOIN results T2 ON T2.raceId = T1.raceId\nJOIN drivers T3 ON T3.driverId = T2.driverId\nWHERE T3.forename = 'Alex' AND T3.surname = 'Yoong' AND T2.position < 20\nORDER BY T1.name"
        ],
        "amend_res": 1
    },
    "595": {
        "db_id": "codebase_community",
        "question": "Which user have only one post history per post and having at least 1000 views?",
        "ground_truth": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
        "amends": [
            "Do add table joins with `users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id` instead of querying only the `posts` table. Do move the view count filter to `WHERE T3.ViewCount >= 1000` instead of using `HAVING views >= 1000`. Do change the grouping to `GROUP BY T2.UserId` instead of `GROUP BY user_id`. Do modify the count condition to `COUNT(DISTINCT T2.PostHistoryTypeId) = 1` instead of `COUNT(*) = 1` to count distinct post history types. Do select `T2.UserId` instead of `user_id` from the appropriate joined table. The amended query now correctly joins multiple tables, filters before aggregation, and counts distinct post history types to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"users with only one post history per post and at least 1000 views\": make sure to join tables users AS T1, postHistory AS T2, and posts AS T3 using T1.Id = T2.UserId and T2.PostId = T3.Id. 2) When filtering for view count: apply T3.ViewCount >= 1000 in the WHERE clause before aggregation. 3) When grouping results: group by T2.UserId to organize by user. 4) When counting distinct post history types per user: compute COUNT(DISTINCT T2.PostHistoryTypeId) = 1 to ensure only one post history type per post. 5) When selecting output: return T2.UserId as the user identifier."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT user_id FROM posts GROUP BY user_id HAVING COUNT(*) = 1 AND views >= 1000;",
            "SELECT T2.UserId\nFROM users AS T1 \nINNER JOIN postHistory AS T2 ON T1.Id = T2.UserId \nINNER JOIN posts AS T3 ON T2.PostId = T3.Id\nWHERE T3.ViewCount >= 1000\nGROUP BY T2.UserId\nHAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1"
        ],
        "rule_sql": [
            "SELECT T2.UserId\nFROM users AS T1\nJOIN postHistory AS T2 ON T1.Id = T2.UserId\nJOIN posts AS T3 ON T2.PostId = T3.Id\nWHERE T3.ViewCount >= 1000\nGROUP BY T2.UserId\nHAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1;"
        ],
        "amend_res": 1
    },
    "1533": {
        "db_id": "debit_card_specializing",
        "question": "For all the people who paid more than 29.00 per unit of product id No.5. Give their consumption status in the August of 2012.",
        "ground_truth": "SELECT T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price / T1.Amount > 29.00 AND T1.ProductID = 5 AND T2.Date = '201208'",
        "amends": [
            "Do select `Consumption` from table `yearmonth` instead of `consumption_status` from table `payments`. Do join `transactions_1k` with `yearmonth` on `CustomerID` instead of querying a single table. Do filter by `Price / Amount > 29.00` instead of `unit_price > 29.00`. Do filter by `ProductID = 5` instead of `product_id = 5`. Do filter by `Date = '201208'` instead of `payment_date LIKE '2012-08%'`. The amended query now correctly joins customer data and uses exact date matching instead of pattern matching."
        ],
        "rules": [
            "1) When the question asks for \"consumption status\": select \"Consumption\" from table \"yearmonth\" instead of \"consumption_status\" from table \"payments\". 2) When combining customer transaction and yearmonth data: join \"transactions_1k\" with \"yearmonth\" on \"CustomerID\" using inner match. 3) When filtering for price per unit greater than 29.00: use condition \"Price / Amount > 29.00\" instead of \"unit_price > 29.00\". 4) When filtering for product ID No.5: use exact condition \"ProductID = 5\". 5) When filtering for August 2012: use exact date matching \"Date = '201208'\" instead of pattern matching with LIKE."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT consumption_status FROM payments WHERE product_id = 5 AND unit_price > 29.00 AND payment_date LIKE '2012-08%';",
            "SELECT ym.Consumption\nFROM transactions_1k t\nJOIN yearmonth ym ON t.CustomerID = ym.CustomerID\nWHERE t.ProductID = 5\nAND t.Price / t.Amount > 29.00\nAND ym.Date = '201208'"
        ],
        "rule_sql": [
            "SELECT y.Consumption\nFROM transactions_1k t\nINNER JOIN yearmonth y ON t.CustomerID = y.CustomerID\nWHERE t.ProductID = 5\nAND t.Price / t.Amount > 29.00\nAND y.Date = '201208'"
        ],
        "amend_res": 1
    },
    "187": {
        "db_id": "financial",
        "question": "How many clients who choose statement of weekly issuance are Owner?",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T2.account_id = T1.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'",
        "amends": [
            "Do select `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific non-null values. Do join `account AS T1` and `disp AS T2` with `INNER JOIN` on `T2.account_id = T1.account_id` instead of querying a single table. Do filter on `T1.frequency = 'POPLATEK TYDNE'` instead of `issuance_type = 'weekly'` to use the correct column name and value for weekly frequency. Do filter on `T2.type = 'OWNER'` instead of `occupation = 'Owner'` to use the proper column and value format for account ownership type. The amended query now correctly counts account owners with weekly frequency by joining the appropriate tables and using the correct column names and values."
        ],
        "rules": [
            "1) When counting clients who choose weekly issuance: use COUNT(T2.account_id) instead of COUNT(*) to count specific non-null values. 2) When combining account and disp tables: join account AS T1 and disp AS T2 with T2.account_id = T1.account_id using inner match. 3) When filtering for weekly frequency: use T1.frequency = 'POPLATEK TYDNE' instead of issuance_type = 'weekly'. 4) When filtering for owner type: use T2.type = 'OWNER' instead of occupation = 'Owner' with exact case and value format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE issuance_type = 'weekly' AND occupation = 'Owner';",
            "SELECT COUNT(T2.account_id) \nFROM account AS T1 \nINNER JOIN disp AS T2 ON T2.account_id = T1.account_id \nWHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.client_id) \nFROM account AS T1 \nINNER JOIN disp AS T2 ON T2.account_id = T1.account_id \nWHERE T1.frequency = 'POPLATEK TYDNE' AND T2.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "601": {
        "db_id": "codebase_community",
        "question": "What is the score and the link type ID for post ID 395?",
        "evidence": "",
        "ground_truth": "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395",
        "amends": [
            "Do add `INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId` instead of querying only the `posts` table. Do reference `T1.Score` and `T2.LinkTypeId` instead of `score` and `link_type_id` from a single table. Do filter on `T2.PostId = 395` instead of `post_id = 395` to correctly target the joined table's condition. The amended query now properly joins the two tables and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"score and link type ID for post ID 395\": make sure the output order: T1.Score, T2.LinkTypeId. 2) When combining posts and postLinks tables: link rows where T1.Id = T2.PostId and keep only matching pairs (inner match). 3) When filtering for post ID 395: use T2.PostId = 395 to correctly target the joined table's condition. 4) When referring to score: use T1.Score from the posts table. 5) When referring to link type ID: use T2.LinkTypeId from the postLinks table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT score, link_type_id FROM posts WHERE post_id = 395;",
            "SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T2.PostId = 395"
        ],
        "rule_sql": [
            "SELECT T1.Score, T2.LinkTypeId \nFROM posts T1 \nINNER JOIN postLinks T2 ON T1.Id = T2.PostId \nWHERE T2.PostId = 395"
        ],
        "amend_res": 1
    },
    "1042": {
        "db_id": "european_football_2",
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "ground_truth": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "amends": [
            "Do select `t1.name` from the `League` table instead of `league_name` from `leagues`. Do join `Match AS t2` with `INNER JOIN` on `t1.id = t2.league_id` instead of querying a single table. Do filter by `t2.season = '2009/2010'` in the WHERE clause instead of filtering by goal comparisons. Do add `GROUP BY t1.name` and move the goal comparison to a `HAVING` clause that calculates the average goal difference per match using `CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)` minus `CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0` instead of comparing individual match goals. The amended query now correctly calculates leagues where the average home goals exceed average away goals for the 2009/2010 season, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"leagues where average home goals exceed average away goals\": make sure the output order: t1.name 2) When the question mentions \"leagues\": \"leagues\" actually means \"League table as t1\" in schema 3) When the question mentions \"2009/2010 season\": filter rows where t2.season = '2009/2010' exactly 4) When combining League (t1) and Match (t2) tables: link rows where t1.id = t2.league_id and keep only matching pairs (inner match) 5) When the question asks for \"average goals by home team vs away team per league\": group results by t1.name and compute (average home goals) minus (average away goals) using (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) minus (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) 6) When filtering for leagues where home average exceeds away average: apply the condition (average home goals minus average away goals) > 0 in the HAVING clause 7) When counting matches for average calculations: use COUNT(DISTINCT t2.id) as the canonical key for match counting"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT league_name \nFROM leagues \nWHERE home_goals > away_goals \nAND season = '2009/2010';",
            "SELECT t1.name \nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2009/2010'\nGROUP BY t1.name\nHAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0"
        ],
        "rule_sql": [
            "SELECT t1.name \nFROM League AS t1\nINNER JOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t2.season = '2009/2010'\nGROUP BY t1.name\nHAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0\nORDER BY t1.name"
        ],
        "amend_res": 1
    },
    "303": {
        "db_id": "toxicology",
        "question": "How many double bonds does TR006 have and is it carcinogenic?",
        "ground_truth": "SELECT COUNT(T1.bond_id), T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006' GROUP BY T2.label",
        "amends": [
            "Do select `COUNT(T1.bond_id)` and `T2.label` instead of `double_bonds` and `carcinogenic`. Do use `FROM bond AS T1 INNER JOIN molecule AS T2` instead of `FROM compounds`. Do add join condition `ON T1.molecule_id = T2.molecule_id` instead of omitting it. Do add filter `T1.bond_type = '='` instead of omitting it. Do change filter to `T2.molecule_id = 'TR006'` instead of `compound_id = 'TR006'`. Do add `GROUP BY T2.label` instead of omitting it. The amended query now correctly counts double bonds per molecule label for the specified molecule ID."
        ],
        "rules": [
            "1) When the question asks about \"double bonds\" for a molecule: count the number of bond records using COUNT(T1.bond_id) where T1.bond_type = '='. 2) When the question asks about \"carcinogenic\" status: use T2.label from the molecule table instead. 3) When combining bond and molecule data: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 4) When filtering for a specific molecule ID 'TR006': use T2.molecule_id = 'TR006' exactly as specified. 5) When producing output for molecule properties: group the results by T2.label to get per-molecule aggregates."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT double_bonds, carcinogenic FROM compounds WHERE compound_id = 'TR006';",
            "SELECT COUNT(T1.bond_id), T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006' GROUP BY T2.label"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.bond_id) AS double_bond_count, T2.label AS is_carcinogenic\nFROM bond T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.bond_type = '=' AND T2.molecule_id = 'TR006'\nGROUP BY T2.label"
        ],
        "amend_res": 1
    },
    "780": {
        "db_id": "superhero",
        "question": "List the powers of Hunter Zolomon.",
        "ground_truth": "SELECT T3.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.full_name = 'Hunter Zolomon'",
        "amends": [
            "Do select `T3.power_name` instead of `*` from all columns. Do use `superhero AS T1` joined with `hero_power AS T2` on `T1.id = T2.hero_id` instead of querying `powers` table directly. Do add a second join to `superpower AS T3` on `T2.power_id = T3.id` instead of omitting this relationship. Do filter on `T1.full_name = 'Hunter Zolomon'` instead of `character_name = 'Barry Allen'` to target the correct character. The amended query now properly navigates the relational schema through appropriate joins to retrieve powers for the specified superhero, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"powers of Hunter Zolomon\": make sure the output order: T3.power_name. 2) When the question mentions \"Hunter Zolomon\": \"Hunter Zolomon\" actually means \"T1.full_name = 'Hunter Zolomon'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.id = T2.hero_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.power_id = T3.id exactly as shown in the amends; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM powers WHERE character_name = 'Barry Allen';",
            "SELECT T3.power_name\nFROM superhero AS T1\nJOIN hero_power AS T2 ON T1.id = T2.hero_id\nJOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T1.full_name = 'Hunter Zolomon'"
        ],
        "rule_sql": [
            "SELECT T3.power_name\nFROM superhero T1\nINNER JOIN hero_power T2 ON T1.id = T2.hero_id\nINNER JOIN superpower T3 ON T2.power_id = T3.id\nWHERE T1.full_name = 'Hunter Zolomon'"
        ],
        "amend_res": 1
    },
    "49": {
        "db_id": "california_schools",
        "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
        "ground_truth": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
        "amends": [
            "Do select `DISTINCT County, School, ClosedDate` instead of `county, COUNT(*) as school_count, school_name, closure_date`. Do use a subquery to find the county with the most closed schools instead of directly grouping by county. Do filter with `WHERE County = (subquery)` instead of grouping by county. Do add `StatusType = 'Closed'` filter in the main query instead of only in the subquery. Do add `school IS NOT NULL` condition instead of omitting null checks. Do remove the `GROUP BY` and aggregate count instead of including them in the main query. Do remove the `ORDER BY` and `LIMIT` from the main query instead of keeping them, as the limiting is handled in the subquery. The amended query now correctly returns all distinct schools from the county with the most closures while filtering for closed status and non-null school names, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"different county has the most number of closed schools\": use a subquery to find the county with the maximum count of closed schools instead of direct grouping in the main query. 2) When selecting output columns: use DISTINCT \"County\", \"School\", \"ClosedDate\" instead of county, COUNT(*) as school_count, school_name, closure_date. 3) When filtering for closed schools: include \"StatusType\" = 'Closed' condition in both main query and subquery. 4) When handling school names: add \"School\" IS NOT NULL condition to exclude null school names. 5) When finding the target county: use WHERE \"County\" = (subquery) to filter for the county with most closed schools instead of GROUP BY county. 6) When ordering and limiting: remove ORDER BY and LIMIT from main query as limiting is handled through the subquery. 7) When counting closed schools per county: count using the canonical key for schools in the subquery to determine the county with maximum closures."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT county, COUNT(*) as school_count, school_name, closure_date \nFROM schools \nWHERE status = 'closed' \nGROUP BY county \nORDER BY school_count DESC \nLIMIT 1;",
            "SELECT DISTINCT County, School, ClosedDate \nFROM schools \nWHERE StatusType = 'Closed' \nAND School IS NOT NULL \nAND County = (\n    SELECT County \n    FROM schools \n    WHERE StatusType = 'Closed' \n    AND School IS NOT NULL \n    GROUP BY County \n    ORDER BY COUNT(*) DESC \n    LIMIT 1\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT \"County\", \"School\", \"ClosedDate\"\nFROM schools\nWHERE \"StatusType\" = 'Closed'\nAND \"School\" IS NOT NULL\nAND \"County\" = (\n    SELECT \"County\"\n    FROM schools\n    WHERE \"StatusType\" = 'Closed'\n    AND \"School\" IS NOT NULL\n    GROUP BY \"County\"\n    ORDER BY COUNT(CDSCode) DESC\n    LIMIT 1\n)"
        ],
        "amend_res": 1
    },
    "1336": {
        "db_id": "student_club",
        "question": "What department offers the major that Pierce and Guidi took?",
        "evidence": "",
        "ground_truth": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'",
        "amends": [
            "Do select `T2.department` instead of `department` from the wrong table. Do use `member AS T1 INNER JOIN major AS T2` instead of querying only the `students` table, adding proper table sources and join relationships. Do change the join condition to `ON T1.link_to_major = T2.major_id` instead of missing the join entirely. Do change the WHERE filter to use `T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'` instead of the impossible `first_name = 'Pierce' AND first_name = 'Guidi'` that could never return results, fixing the logical error by using OR instead of AND and correcting the column name from first_name to last_name. The amended query now correctly retrieves department information through proper table relationships and filtering logic."
        ],
        "rules": [
            "1) When answering about department for majors taken by specific students: make sure the output order: T2.department. 2) When the question mentions \"Pierce\" and \"Guidi\": these actually mean T1.last_name = 'Pierce' OR T1.last_name = 'Guidi' in the schema. 3) When combining member table (T1) and major table (T2) for shared entities: link rows where T1.link_to_major = T2.major_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for column names like T2.department. 5) When handling text literals: do not change case, spacing, or punctuation for values like 'Pierce' and 'Guidi'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT department FROM students WHERE first_name = 'Pierce' AND first_name = 'Guidi'",
            "SELECT T2.department \nFROM member AS T1 \nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id \nWHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'"
        ],
        "rule_sql": [
            "SELECT T2.department\nFROM member T1\nJOIN major T2 ON T1.link_to_major = T2.major_id\nWHERE T1.last_name = 'Pierce' OR T1.last_name = 'Guidi'\nGROUP BY T2.department"
        ],
        "amend_res": 1
    },
    "259": {
        "db_id": "toxicology",
        "question": "How many elements are there for single bond molecules?",
        "ground_truth": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
        "amends": [
            "Do use `COUNT(DISTINCT T.element)` instead of `COUNT(*)` to count distinct elements rather than all rows. Do add a subquery with `SELECT DISTINCT T2.molecule_id, T1.element` instead of querying the molecules table directly. Do change the FROM clause to use `atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id` instead of a single table, adding proper joins between atom, molecule, and bond tables. Do change the WHERE filter to `T3.bond_type = '-'` instead of `bond_type = 'single'` and remove the `element_count > 1` condition. The amended query now correctly counts distinct elements in molecules with single bonds by properly joining the relevant tables and filtering for the correct bond type representation."
        ],
        "rules": [
            "1) When counting distinct elements in molecules: use COUNT(DISTINCT T1.element) instead of COUNT(*) to count unique elements rather than all rows. 2) When joining tables for molecule analysis: use atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id to properly connect atom, molecule, and bond tables. 3) When filtering for single bond molecules: use T3.bond_type = '-' instead of bond_type = 'single' to match the exact representation of single bonds in the schema. 4) When the question asks about \"single bond molecules\": do not include element_count > 1 condition as it is not relevant to counting distinct elements."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE bond_type = 'single' AND element_count > 1",
            "SELECT COUNT(DISTINCT T1.element) \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id \nWHERE T3.bond_type = '-'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.element) \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id \nWHERE T3.bond_type = '-'"
        ],
        "amend_res": 1
    },
    "719": {
        "db_id": "superhero",
        "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
        "amends": [
            "Do select `COUNT(T1.id)` from specific column instead of `COUNT(*)` from all rows. Do use table aliases `T1`, `T2`, and `T3` instead of single table reference. Do join `hero_power AS T2` on `T1.id = T2.hero_id` and `superpower AS T3` on `T2.power_id = T3.id` instead of querying a single table. Do filter on `T3.power_name = 'Super Strength'` instead of `super_power = 'Super Strength'` to reference the correct table and column. Do filter on `T1.height_cm > 200` instead of `height > 200` to use the correct column name with unit specification. The amended query now correctly joins related tables and uses proper column references to match the intended logic."
        ],
        "rules": [
            "1) When answering about superheroes with super power \"Super Strength\": join tables hero_power as T2 on T1.id = T2.hero_id and superpower as T3 on T2.power_id = T3.id to connect superheroes to their powers. 2) When filtering for super power \"Super Strength\": use T3.power_name = 'Super Strength' exactly as specified. 3) When filtering for height over 200cm: use T1.height_cm > 200 to reference the correct column with unit specification. 4) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) to count specific entities using the canonical key. 5) When combining tables for shared entities: perform inner matches using the exact key equalities T1.id = T2.hero_id and T2.power_id = T3.id as shown in the amends."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE super_power = 'Super Strength' AND height > 200;",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nJOIN hero_power AS T2 ON T1.id = T2.hero_id\nJOIN superpower AS T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Super Strength' \nAND T1.height_cm > 200"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero T1\nJOIN hero_power T2 ON T1.id = T2.hero_id\nJOIN superpower T3 ON T2.power_id = T3.id\nWHERE T3.power_name = 'Super Strength'\nAND T1.height_cm > 200"
        ],
        "amend_res": 1
    },
    "1431": {
        "db_id": "student_club",
        "question": "List the last name of the members of the club that attended the women's soccer event.",
        "ground_truth": "SELECT T3.last_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T2.event_name = 'Women''s Soccer' AND T3.position = 'Member'",
        "amends": [
            "Do select `T3.last_name` from the `member` table instead of `last_name` from the `members` table. Do add joins to `attendance AS T1` and `event AS T2` instead of querying a single table. Do use `INNER JOIN` between `event AS T2` and `attendance AS T1` on `T2.event_id = T1.link_to_event` instead of no join condition. Do add another `INNER JOIN` to `member AS T3` on `T1.link_to_member = T3.member_id` instead of no member table join. Do filter on `T2.event_name = 'Women''s Soccer'` instead of `event_type = 'women''s soccer'`. Do add an additional filter `T3.position = 'Member'` instead of omitting it. The amended query now correctly joins the necessary tables and applies proper filtering to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"members of the club that attended the women's soccer event\": make sure the output order: T3.last_name. 2) When the question mentions \"members of the club\": this actually means \"T3.position = 'Member'\" in the schema. 3) When the question mentions \"women's soccer event\": this actually means \"T2.event_name = 'Women''s Soccer'\" in the schema. 4) When combining T1, T2, and T3 for shared entities: link rows where T2.event_id = T1.link_to_event and T1.link_to_member = T3.member_id; keep only matching pairs (inner match). 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 6) When handling text literals: do not change case, spacing, or punctuation for 'Women''s Soccer' or 'Member'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT last_name FROM members WHERE event_type = 'women''s soccer';",
            "SELECT T3.last_name \nFROM event AS T2\nINNER JOIN attendance AS T1 ON T2.event_id = T1.link_to_event\nINNER JOIN member AS T3 ON T1.link_to_member = T3.member_id\nWHERE T2.event_name = 'Women''s Soccer'\nAND T3.position = 'Member'"
        ],
        "rule_sql": [
            "SELECT T3.last_name\nFROM \"attendance\" T1\nJOIN event T2 ON T2.event_id = T1.link_to_event\nJOIN member T3 ON T3.member_id = T1.link_to_member\nWHERE T2.event_name = 'Women''s Soccer'\nAND T3.position = 'Member'\nORDER BY T3.last_name;"
        ],
        "amend_res": 1
    },
    "253": {
        "db_id": "toxicology",
        "question": "List the elements of all the triple bonds.",
        "ground_truth": "SELECT DISTINCT T3.element FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id INNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id WHERE T1.bond_type = '#'",
        "amends": [
            "Do select `DISTINCT T3.element` instead of `*` from all columns. Do use `bond AS T1` instead of `triple_bonds` as the main table. Do add `INNER JOIN connected AS T2` on `T1.bond_id = T2.bond_id` instead of omitting this join. Do add `INNER JOIN atom AS T3` on `T2.atom_id = T3.atom_id` instead of omitting this join. Do filter on `T1.bond_type = '#'` instead of `bond_type = 'double'` with the correct table alias and bond type value. The amended query now correctly retrieves distinct elements from atoms connected by bonds of the specified type."
        ],
        "rules": [
            "1) When answering about \"elements of triple bonds\": make sure the output order: T3.element. 2) When the question mentions \"triple bonds\": \"triple bonds\" actually means \"bonds with bond_type = '#'\" in schema. 3) When combining T1 and T2 for shared entities: link rows where T1.bond_id = T2.bond_id exactly as shown in the amends; keep only matching pairs (inner match). 4) When combining T2 and T3 for shared entities: link rows where T2.atom_id = T3.atom_id exactly as shown in the amends; keep only matching pairs (inner match). 5) When the question asks for \"distinct elements\": compute the number of unique values of the exact token T3.element. 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 7) When handling text literals: do not change case, spacing, or punctuation for the literal '#'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM triple_bonds WHERE bond_type = 'double';",
            "SELECT DISTINCT T3.element\nFROM bond AS T1\nINNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom AS T3 ON T2.atom_id = T3.atom_id\nWHERE T1.bond_type = '#'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.element\nFROM bond T1\nINNER JOIN connected T2 ON T1.bond_id = T2.bond_id\nINNER JOIN atom T3 ON T2.atom_id = T3.atom_id\nWHERE T1.bond_type = '#'\nORDER BY T3.element"
        ],
        "amend_res": 1
    },
    "3": {
        "db_id": "california_schools",
        "question": "What is the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students?",
        "evidence": "",
        "ground_truth": "SELECT T2.MailStreet FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 1",
        "amends": [
            "Do select `T2.MailStreet` instead of `mailing_street_address` from the correct table. Do join `frpm AS T1` with `schools AS T2` using `INNER JOIN` instead of querying only the schools table. Do use the join condition `T1.CDSCode = T2.CDSCode` instead of no join condition. Do order by `T1.FRPM Count (K-12)` instead of `frpm_count_k12` to reference the correct column from the joined table. The amended query now correctly retrieves the mailing street address from schools joined with frpm data, ordered by the FRPM count from the frpm table."
        ],
        "rules": [
            "1) When answering about \"mailing street address\": make sure to select \"T2.MailStreet\" instead of \"mailing_street_address\". 2) When combining frpm and schools tables: link rows where \"T1.CDSCode = T2.CDSCode\" and keep only matching pairs (inner match). 3) When the question mentions \"highest FRPM count for K-12 students\": rank rows by \"T1.FRPM Count (K-12)\" in descending order and keep the first 1 row. 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for columns like \"T1.FRPM Count (K-12)\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT mailing_street_address FROM schools ORDER BY frpm_count_k12 DESC LIMIT 1;",
            "SELECT T2.MailStreet \nFROM frpm AS T1 \nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode \nORDER BY T1.\"FRPM Count (K-12)\" DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.MailStreet \nFROM frpm T1\nINNER JOIN schools T2 ON T1.CDSCode = T2.CDSCode\nORDER BY T1.\"FRPM Count (K-12)\" DESC\nLIMIT 1"
        ],
        "amend_res": 1
    },
    "207": {
        "db_id": "toxicology",
        "question": "What elements are in a double type bond?",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id WHERE T2.bond_type = '='",
        "amends": [
            "Do select only `T1.element` with `DISTINCT` instead of all columns with `*`. Do use `atom AS T1` and `bond AS T2` tables instead of a single `chemical_bonds` table. Do perform `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of filtering on `element = 'carbon'`. Do add another `INNER JOIN` on `connected AS T3` with `T1.atom_id = T3.atom_id` instead of omitting this table. Do filter on `T2.bond_type = '='` instead of `bond_type = 'double'`. The amended query now correctly identifies distinct elements involved in double bonds through proper table relationships."
        ],
        "rules": [
            "1) When answering about elements in double bonds: make sure the output order: T1.element with DISTINCT. 2) When the question mentions \"double type bond\": \"double\" actually means \"T2.bond_type = '='\" in schema. 3) When combining tables atom AS T1, bond AS T2, and connected AS T3: link rows where T1.molecule_id = T2.molecule_id and T1.atom_id = T3.atom_id; keep only matching pairs (inner match). 4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms. 5) When handling text literals: do not change case, spacing, or punctuation for '='."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM chemical_bonds WHERE bond_type = 'double' AND element = 'carbon';",
            "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.bond_type = '='"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element\nFROM atom AS T1\nINNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN connected AS T3 ON T1.atom_id = T3.atom_id\nWHERE T2.bond_type = '='"
        ],
        "amend_res": 1
    },
    "963": {
        "db_id": "formula_1",
        "question": "How many French drivers who obtain the laptime less than 02:00.00?",
        "ground_truth": "SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 on T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
        "amends": [
            "Do add `lapTimes AS T2` table with `INNER JOIN` on `T1.driverId = T2.driverId` instead of querying only the `drivers` table. Do change the aggregate to `COUNT(T1.driverId)` instead of `COUNT(*)` to count distinct drivers. Do replace the simple `laptime < '02:00.00'` filter with a complex time conversion expression `(CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120` that properly parses and converts the time string format to seconds for numerical comparison. The amended query now correctly joins to access lap time data and performs proper time conversion to match the RIGHT_SQL's behavior.",
            "Do remove `DISTINCT` from the `COUNT` function instead of keeping it, as the join condition already ensures unique driver IDs are counted correctly when filtering for French drivers with lap times under 120 seconds. The amended query now matches RIGHT_SQL's behavior by counting all French drivers with qualifying lap times without unnecessary deduplication."
        ],
        "rules": [
            "1) When answering about French drivers with laptime less than 02:00.00: make sure to join the lapTimes table as T2 with drivers table as T1 using T1.driverId = T2.driverId to access laptime data. 2) When counting French drivers: use COUNT(T1.driverId) to count distinct drivers instead of COUNT(*). 3) When filtering laptime less than 02:00.00: convert the time string format using (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120 to properly parse and compare time values numerically. 4) When filtering by nationality: use nationality = 'French' with exact case and quotes as shown.",
            "1) When counting French drivers with qualifying lap times: use COUNT(T1.driverId) without DISTINCT since the join condition ensures unique driver IDs are counted correctly. 2) When filtering for French nationality: use T1.nationality = 'French' with exact case and quotes. 3) When filtering for lap times less than 02:00.00: convert the time format to total seconds and compare against 120 seconds using the exact conversion logic shown in the query."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM drivers WHERE nationality = 'French' AND laptime < '02:00.00';",
            "SELECT COUNT(DISTINCT T1.driverId) \nFROM drivers AS T1 \nINNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId \nWHERE T1.nationality = 'French' \nAND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120",
            "SELECT COUNT(T1.driverId)\nFROM drivers AS T1\nINNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId\nWHERE T1.nationality = 'French'\nAND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.driverId) \nFROM drivers T1 \nJOIN lapTimes T2 ON T1.driverId = T2.driverId \nWHERE T1.nationality = 'French' \nAND (CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) + CAST(SUBSTR(T2.time, 7, 2) AS REAL) / 1000) < 120"
        ],
        "amend_res": 1
    },
    "1489": {
        "db_id": "debit_card_specializing",
        "question": "How much did the KAM customers consume in total in May 2013?",
        "ground_truth": "SELECT SUM(T2.Consumption) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '201305' AND T1.Segment = 'KAM'",
        "amends": [
            "Do select `SUM(T2.Consumption)` from the joined table instead of `SUM(amount)` from a single table. Do join `customers AS T1` and `yearmonth AS T2` with `INNER JOIN` on `T1.CustomerID = T2.CustomerID` instead of querying only the `sales` table. Do filter on `T2.Date = '201305'` instead of separate `month = 'May' AND year = 2013` conditions. Do filter on `T1.Segment = 'KAM'` instead of `customer_type = 'KAM'`. The amended query now correctly joins customer and consumption data while using proper date formatting and segment filtering, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"total consumption for KAM customers in May 2013\": make sure the output order: SUM(T2.Consumption). 2) When the question mentions \"KAM customers\": \"KAM\" actually means \"T1.Segment = 'KAM'\" in schema. 3) When the question mentions \"May 2013\": this date actually means \"T2.Date = '201305'\" in schema. 4) When combining T1 and T2 for shared entities: link rows where T1.CustomerID = T2.CustomerID; keep only matching pairs (inner match). 5) When computing total consumption: use SUM(T2.Consumption) instead of SUM(amount)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(amount) FROM sales WHERE customer_type = 'KAM' AND month = 'May' AND year = 2013",
            "SELECT SUM(T2.Consumption) \nFROM customers AS T1 \nINNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID \nWHERE T1.Segment = 'KAM' AND T2.Date = '201305'"
        ],
        "rule_sql": [
            "SELECT SUM(T2.Consumption) \nFROM customers T1\nINNER JOIN yearmonth T2 ON T1.CustomerID = T2.CustomerID\nWHERE T1.Segment = 'KAM' AND T2.Date = '201305'"
        ],
        "amend_res": 1
    },
    "1361": {
        "db_id": "student_club",
        "question": "What is the total cost of the pizzas for all the events?",
        "ground_truth": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
        "amends": [
            "Do select `SUM(cost)` from the `expense` table instead of `SUM(price)` from the `pizzas` table. Do add a WHERE filter `expense_description = 'Pizza'` instead of omitting any filtering condition. The amended query now correctly calculates pizza-related expenses from the appropriate table with proper filtering to match the intended behavior."
        ],
        "rules": [
            "1) When calculating total cost of pizzas: use SUM(\"cost\") from the \"expense\" table instead of SUM(price) from the \"pizzas\" table. 2) When filtering for pizza expenses: add a condition where \"expense_description\" equals exactly 'Pizza' to ensure only pizza-related costs are included."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(price) FROM pizzas;",
            "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza';"
        ],
        "rule_sql": [
            "SELECT SUM(cost) AS total_pizza_cost FROM expense WHERE expense_description = 'Pizza';"
        ],
        "amend_res": 1
    },
    "24": {
        "db_id": "california_schools",
        "question": "Give the names of the schools with the percent eligible for free meals in K-12 is more than 0.1 and test takers whose test score is greater than or equal to 1500?",
        "ground_truth": "SELECT T2.`School Name` FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.CDSCode WHERE CAST(T2.`Free Meal Count (K-12)` AS REAL) / T2.`Enrollment (K-12)` > 0.1 AND T1.NumGE1500 > 0",
        "amends": [
            "Do use table aliases `T1` and `T2` instead of plain table names. Do join `satscores AS T1` with `frpm AS T2` on `T1.cds = T2.CDSCode` instead of querying a single table. Do select `T2.School Name` instead of `school_name`. Do calculate free meal percentage using `CAST(T2.Free Meal Count (K-12) AS REAL) / T2.Enrollment (K-12) > 0.1` instead of comparing a direct column `percent_free_meals > 0.1`. Do filter by `T1.NumGE1500 > 0` instead of `test_score >= 1500` to check for existence of qualifying scores rather than comparing a specific score value. The amended query now correctly joins the two related datasets and uses appropriate column references and calculations to match the intended logic."
        ],
        "rules": [
            "1) When joining tables for school data: combine satscores as T1 with frpm as T2 where T1.cds equals T2.CDSCode and keep only matching pairs (inner match). 2) When calculating free meal percentage: compute CAST(T2.\"Free Meal Count (K-12)\" AS REAL) divided by T2.\"Enrollment (K-12)\" and check if greater than 0.1. 3) When checking for test takers with scores >= 1500: verify that T1.NumGE1500 is greater than 0 to indicate existence of qualifying scores. 4) When selecting school names: output T2.\"School Name\" as the result. 5) When answering about schools meeting both criteria: ensure both the free meal percentage condition and test score condition are satisfied simultaneously."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name \nFROM schools \nWHERE percent_free_meals > 0.1 \nAND test_score >= 1500;",
            "SELECT T2.\"School Name\"\nFROM satscores AS T1\nJOIN frpm AS T2 ON T1.cds = T2.CDSCode\nWHERE CAST(T2.\"Free Meal Count (K-12)\" AS REAL) / T2.\"Enrollment (K-12)\" > 0.1\nAND T1.NumGE1500 > 0;"
        ],
        "rule_sql": [
            "SELECT T2.\"School Name\"\nFROM satscores T1\nINNER JOIN frpm T2 ON T1.cds = T2.CDSCode\nWHERE CAST(T2.\"Free Meal Count (K-12)\" AS REAL) / T2.\"Enrollment (K-12)\" > 0.1\nAND T1.NumGE1500 > 0;"
        ],
        "amend_res": 1
    },
    "924": {
        "db_id": "formula_1",
        "question": "Please list the exact dates on which a Formula_1 race took place on the Barcelona-Catalunya circuit.",
        "evidence": "",
        "ground_truth": "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
        "amends": [
            "Do select `T2.date` from the `races` table instead of `race_date` from the `races` table. Do join `circuits AS T1` with `races AS T2` using `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table. Do filter on `T1.name = 'Circuit de Barcelona-Catalunya'` instead of `circuit_name = 'Barcelona-Catalunya'`. Do remove the `race_type = 'Formula_1'` filter instead of keeping it. The amended query now correctly joins the circuits and races tables to find dates for the specific circuit and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about Formula 1 race dates on Barcelona-Catalunya circuit: make sure the output order: T2.date\n2) When the question mentions \"Barcelona-Catalunya circuit\": \"Barcelona-Catalunya\" actually means \"T1.name = 'Circuit de Barcelona-Catalunya'\" in schema\n3) When combining T1 (circuits) and T2 (races) for shared entities: link rows where T2.circuitID = T1.circuitId exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for Formula 1 race dates: do not filter on race_type = 'Formula_1' as this filter should be removed according to the amends"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT race_date FROM races WHERE circuit_name = 'Barcelona-Catalunya' AND race_type = 'Formula_1';",
            "SELECT T2.date FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'"
        ],
        "rule_sql": [
            "SELECT T2.date\nFROM circuits T1\nINNER JOIN races T2 ON T2.circuitId = T1.circuitId\nWHERE T1.name = 'Circuit de Barcelona-Catalunya'\nORDER BY T2.date"
        ],
        "amend_res": 1
    },
    "1438": {
        "db_id": "student_club",
        "question": "Please indicate the college of the person whose first name is Katy with the link to the major \"rec1N0upiVLy5esTO\".",
        "evidence": "",
        "ground_truth": "SELECT T2.college FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.link_to_major = 'rec1N0upiVLy5esTO' AND T1.first_name = 'Katy'",
        "amends": [
            "Do select `T2.college` from the `major` table instead of `college` from the `people` table. Do join `member AS T1` with `major AS T2` using `INNER JOIN` on `T2.major_id = T1.link_to_major` instead of querying only the `people` table. Do filter on `T1.link_to_major = 'rec1N0upiVLy5esTO'` and `T1.first_name = 'Katy'` in the WHERE clause instead of filtering on `major_link` and `first_name` from a single table. The amended query now correctly retrieves college information by joining member and major tables through the proper relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"college of the person whose first name is Katy with link to major 'rec1N0upiVLy5esTO'\": make sure the output order: T2.college\n2) When the question mentions \"person\": \"person\" actually means \"member table (T1) in schema\"\n3) When the question mentions \"college\": \"college\" actually means \"college column in major table (T2) in schema\"\n4) When combining T1 (member) and T2 (major) for shared entities: link rows where T2.major_id = T1.link_to_major exactly as shown in the amends; keep only matching pairs (inner match)\n5) When filtering for first name \"Katy\": use T1.first_name = 'Katy' with exact case and spacing\n6) When filtering for major link \"rec1N0upiVLy5esTO\": use T1.link_to_major = 'rec1N0upiVLy5esTO' with exact identifier and literal"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT college FROM people WHERE first_name = 'Katy' AND major_link = 'rec1N0upiVLy5esTO';",
            "SELECT T2.college \nFROM member AS T1\nINNER JOIN major AS T2 ON T2.major_id = T1.link_to_major\nWHERE T1.first_name = 'Katy' AND T1.link_to_major = 'rec1N0upiVLy5esTO'"
        ],
        "rule_sql": [
            "SELECT T2.college\nFROM member T1\nINNER JOIN major T2 ON T2.major_id = T1.link_to_major\nWHERE T1.first_name = 'Katy' AND T1.link_to_major = 'rec1N0upiVLy5esTO'"
        ],
        "amend_res": 1
    },
    "1200": {
        "db_id": "thrombosis_prediction",
        "question": "What proportion of patients who had signs of thrombocytopenia had SLE diagnosed?",
        "ground_truth": "SELECT CAST(SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(ID) FROM Examination WHERE Symptoms = 'thrombocytopenia'",
        "amends": [
            "Do use `SUM(CASE WHEN Diagnosis = 'SLE' THEN 1 ELSE 0 END)` instead of `COUNT(*)` to calculate the percentage of SLE patients. Do reference `Examination` table instead of `patients` table. Do filter by `Symptoms = 'thrombocytopenia'` instead of separate `thrombocytopenia = 1 AND sle_diagnosis = 1` conditions. Do calculate a percentage using `CAST(... AS REAL) * 100 / COUNT(ID)` instead of a simple count. Do remove the `total_patients` alias instead of keeping it. The amended query now correctly calculates the percentage of SLE patients among those with thrombocytopenia symptoms, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about proportion of patients with thrombocytopenia who had SLE diagnosed: calculate the percentage using (number of SLE patients) divided by (total patients with thrombocytopenia) multiplied by 100. 2) When the question mentions \"patients who had signs of thrombocytopenia\": filter rows where \"Symptoms\" equals 'thrombocytopenia' exactly. 3) When counting SLE patients: use SUM(CASE WHEN \"Diagnosis\" = 'SLE' THEN 1 ELSE 0 END) to count patients with SLE diagnosis. 4) When calculating total patients with thrombocytopenia: use COUNT(\"ID\") to count all patients with thrombocytopenia symptoms. 5) When computing the proportion: cast the SLE count to REAL before multiplying by 100 and dividing by total count to get percentage. 6) When handling diagnosis values: use exact literal 'SLE' for SLE diagnosis comparison."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) AS total_patients FROM patients WHERE thrombocytopenia = 1 AND sle_diagnosis = 1;",
            "SELECT \n    CAST(SUM(CASE WHEN e.Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT e.ID) AS percentage\nFROM \n    Examination e\nWHERE \n    e.Symptoms = 'thrombocytopenia';"
        ],
        "rule_sql": [
            "SELECT \n    (SUM(CASE WHEN e.Diagnosis = 'SLE' THEN 1 ELSE 0 END) * 100.0 / COUNT(e.ID)) AS proportion\nFROM \n    Examination e\nWHERE \n    e.Symptoms = 'thrombocytopenia';"
        ],
        "amend_res": 1
    },
    "835": {
        "db_id": "superhero",
        "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "amends": [
            "Do use explicit table aliases `T1`, `T2`, and `T3` instead of direct table references. Do join `publisher AS T2` on `T1.publisher_id = T2.id` and `alignment AS T3` on `T1.alignment_id = T3.id` instead of querying a single table. Do reference `T3.alignment` instead of `alignment` and use 'Good' instead of 'good' for case sensitivity. Do calculate percentage using `CAST(... AS REAL) * 100 / COUNT(T1.id)` instead of `(COUNT(...) / COUNT(*)) * 100` for proper real number division. Do filter on `T2.publisher_name = 'Marvel Comics'` instead of `publisher = 'Marvel Comics'` to use the joined table's column. The amended query now correctly handles the relational schema with proper joins and real number casting."
        ],
        "rules": [
            "1) When the question mentions \"Marvel Comics\": use \"T2.publisher_name = 'Marvel Comics'\" instead of direct publisher column references. 2) When the question mentions \"good\" alignment: use \"T3.alignment = 'Good'\" with exact case sensitivity. 3) When combining superheroes with publisher and alignment tables: link rows where T1.publisher_id = T2.id and T1.alignment_id = T3.id, keeping only matching pairs (inner match). 4) When calculating percentage of good superheroes: compute (COUNT(CASE WHEN T3.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(T1.id)) to ensure real number division. 5) When counting superheroes: use T1.id as the canonical counting key instead of counting all columns."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(CASE WHEN alignment = 'good' THEN 1 END) / COUNT(*)) * 100 AS percentage_good FROM superheroes WHERE publisher = 'Marvel Comics';",
            "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN 1 END) AS REAL) * 100 / COUNT(T1.id) AS percentage_good\nFROM superhero AS T1\nJOIN publisher AS T2 ON T1.publisher_id = T2.id\nJOIN alignment AS T3 ON T1.alignment_id = T3.id\nWHERE T2.publisher_name = 'Marvel Comics';"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T3.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(T1.id)) AS percentage_good\nFROM \n    superhero T1\n    INNER JOIN publisher T2 ON T1.publisher_id = T2.id\n    INNER JOIN alignment T3 ON T1.alignment_id = T3.id\nWHERE \n    T2.publisher_name = 'Marvel Comics'"
        ],
        "amend_res": 1
    },
    "574": {
        "db_id": "codebase_community",
        "question": "Which user has the website URL listed at 'http://stackoverflow.com'",
        "ground_truth": "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'",
        "amends": [
            "Do select `DisplayName` instead of `*` to return only the specific column needed. Do filter on `WebsiteUrl` instead of `website` to use the correct column name that contains the website URL data. The amended query now correctly returns only display names for users with the specified website URL, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"user\" with a specific website URL: use the \"DisplayName\" column from the \"users\" table to return the user's display name. 2) When filtering for website URLs: use the \"WebsiteUrl\" column from the \"users\" table and match the exact literal value 'http://stackoverflow.com' with correct case and punctuation. 3) When selecting output columns: return only the \"DisplayName\" column instead of all columns (*) to provide the specific information requested."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM users WHERE website = 'http://stackoverflow.com';",
            "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'"
        ],
        "rule_sql": [
            "SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';"
        ],
        "amend_res": 1
    },
    "404": {
        "db_id": "card_games",
        "question": "Indicates the name of all the languages into which the set whose number of cards is 309 is translated.",
        "ground_truth": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309",
        "amends": [
            "Do select `T2.language` instead of `language_name` and use table aliases `T1` and `T2` instead of direct table names. Do join `sets AS T1` and `set_translations AS T2` with `INNER JOIN` on `T1.code = T2.setCode` instead of using a subquery to find `set_id` from `card_sets`. Do filter with `WHERE T1.baseSetSize = 309` instead of `WHERE set_id = (SELECT set_id FROM card_sets WHERE card_count = 309)`. Do remove the subquery correlation and use direct table joins instead of nested subqueries. The amended query now correctly retrieves language information through proper table relationships and filtering criteria."
        ],
        "rules": [
            "1) When answering about languages for sets with specific card counts: use table aliases T1 for \"sets\" and T2 for \"set_translations\" 2) When combining sets and set_translations tables: link rows where T1.code equals T2.setCode using inner join 3) When filtering for sets with exactly 309 cards: use condition T1.baseSetSize = 309 4) When selecting language information: output T2.language instead of language_name"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT language_name FROM languages WHERE set_id = (SELECT set_id FROM card_sets WHERE card_count = 309);",
            "SELECT DISTINCT T2.language \nFROM sets AS T1 \nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode \nWHERE T1.baseSetSize = 309"
        ],
        "rule_sql": [
            "SELECT T2.language FROM sets T1 INNER JOIN set_translations T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309"
        ],
        "amend_res": 1
    },
    "1468": {
        "db_id": "student_club",
        "question": "Where is the hometown of Garrett Gerke?",
        "ground_truth": "SELECT T2.city FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip WHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'",
        "amends": [
            "Do select `T2.city` instead of `hometown` from the result set. Do use `member AS T1` and `zip_code AS T2` as source tables instead of `people`. Do add an `INNER JOIN` on `T2.zip_code = T1.zip` instead of having no join condition. Do reference `T1.first_name` and `T1.last_name` in the WHERE clause instead of directly using column names without table aliases. The amended query now correctly joins member and zip_code tables to retrieve the city based on zip code matching, ensuring it returns the proper location information for the specified person."
        ],
        "rules": [
            "1) When answering about \"hometown of Garrett Gerke\": make sure the output order: T2.city 2) When the question mentions \"hometown\": \"hometown\" actually means \"city in schema\" from the zip_code table 3) When combining T1 (member) and T2 (zip_code) for shared entities: link rows where T2.zip_code = T1.zip exactly as shown; keep only matching pairs (inner match) 4) When filtering for a specific person: use exact literals T1.first_name = 'Garrett' AND T1.last_name = 'Gerke' with the correct case and spacing"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT hometown FROM people WHERE first_name = 'Garrett' AND last_name = 'Gerke'",
            "SELECT T2.city\nFROM member AS T1\nINNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip\nWHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'"
        ],
        "rule_sql": [
            "SELECT T2.city \nFROM member T1 \nINNER JOIN zip_code T2 ON T2.zip_code = T1.zip \nWHERE T1.first_name = 'Garrett' AND T1.last_name = 'Gerke'"
        ],
        "amend_res": 1
    },
    "1087": {
        "db_id": "european_football_2",
        "question": "Among the players whose height is over 180, how many of them have a volley score of over 70?",
        "ground_truth": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 AND t2.volleys > 70",
        "amends": [
            "Do `COUNT(DISTINCT t1.id)` instead of `COUNT(*)` to count unique player IDs rather than all rows. Do add `INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of querying only the players table, joining to access volley attributes. Do reference `t2.volleys > 70` instead of `volley_score > 70` to use the correct column name from the joined table. Do specify `FROM Player AS t1` instead of just `players` with proper table alias. The amended query now correctly counts distinct players meeting both height and volley criteria by joining the necessary tables."
        ],
        "rules": [
            "1) When counting players: count distinct player IDs using \"t1.id\" rather than counting all rows. 2) When the question mentions \"players\": use table \"Player\" with alias \"t1\" as the base table. 3) When the question mentions \"volley score\": this actually means column \"volleys\" from table \"Player_Attributes\" with alias \"t2\". 4) When combining player and attribute information: link rows where \"t1.player_api_id = t2.player_api_id\" using an inner match to keep only players with attribute records. 5) When filtering for height over 180: use condition \"t1.height > 180\". 6) When filtering for volley score over 70: use condition \"t2.volleys > 70\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM players WHERE height > 180 AND volley_score > 70;",
            "SELECT COUNT(DISTINCT t1.id) \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.height > 180 AND t2.volleys > 70"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT t1.id) \nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t1.height > 180 AND t2.volleys > 70"
        ],
        "amend_res": 1
    },
    "539": {
        "db_id": "codebase_community",
        "question": "Who is the owner of the post \"Eliciting priors from experts\"?",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Title = 'Eliciting priors from experts'",
        "amends": [
            "Do select `T2.DisplayName` instead of `owner` to retrieve the user's display name rather than the owner ID. Do add `INNER JOIN users AS T2` instead of querying only the posts table to properly join with the users table. Do use join condition `ON T1.OwnerUserId = T2.Id` instead of missing the join entirely, which correctly links posts to their respective users. The amended query now matches RIGHT_SQL's behavior by properly retrieving user display names through the appropriate table join."
        ],
        "rules": [
            "1) When the question asks for \"owner\" of a post: use \"T2.DisplayName\" instead of \"owner\" to get the user's display name. 2) When joining posts table (T1) with users table (T2): link rows where \"T1.OwnerUserId = T2.Id\" using an inner join. 3) When filtering by post title: use exact literal match with \"title = 'Eliciting priors from experts'\" including the exact case and spacing of the title."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT owner FROM posts WHERE title = 'Eliciting priors from experts';",
            "SELECT T2.DisplayName \nFROM posts AS T1 \nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Title = 'Eliciting priors from experts'"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName \nFROM posts T1 \nINNER JOIN users T2 ON T1.OwnerUserId = T2.Id \nWHERE T1.Title = 'Eliciting priors from experts'"
        ],
        "amend_res": 1
    },
    "881": {
        "db_id": "formula_1",
        "question": "For the drivers who took part in the race in 1983/7/16, what's their race completion rate?",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'",
        "amends": [
            "Do use `CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId)` instead of `COUNT(*) / (SELECT COUNT(*) FROM races WHERE race_date = '1983/7/16')` for calculating completion percentage. Do join `races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId` instead of `drivers d JOIN race_results rr ON d.driver_id = rr.driver_id JOIN races r ON rr.race_id = r.race_id` with different table aliases and join conditions. Do filter with `WHERE T1.date = '1983-07-16'` instead of `WHERE r.race_date = '1983/7/16'` with corrected date format. Do remove `GROUP BY d.driver_id, driver_name` instead of keeping it since the query now returns a single aggregate value. Do use date format `'1983-07-16'` instead of `'1983/7/16'` for proper date handling. The amended query now correctly calculates the completion rate percentage for all drivers in the specified race."
        ],
        "rules": [
            "1) When calculating race completion rate: use CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) to compute the percentage of drivers who completed the race. 2) When joining tables for race results: use races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId to link race information with driver results. 3) When filtering for a specific race date: use WHERE T1.date = '1983-07-16' with the exact date format '1983-07-16'. 4) When the question asks for overall completion rate: do not group by individual drivers but return a single aggregate value for all drivers in the specified race."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_name, COUNT(*) / (SELECT COUNT(*) FROM races WHERE race_date = '1983/7/16') AS completion_rate\nFROM drivers d\nJOIN race_results rr ON d.driver_id = rr.driver_id\nJOIN races r ON rr.race_id = r.race_id\nWHERE r.race_date = '1983/7/16'\nGROUP BY d.driver_id, driver_name;",
            "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) AS completion_rate\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.raceId = T1.raceId\nWHERE T1.date = '1983-07-16'"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN T2.driverId END) AS REAL) * 100 / COUNT(T2.driverId) AS completion_rate\nFROM races AS T1\nINNER JOIN results AS T2 ON T2.raceId = T1.raceId\nWHERE T1.date = '1983-07-16';"
        ],
        "amend_res": 1
    },
    "1372": {
        "db_id": "student_club",
        "question": "When did the member, Casey Mason, received the income?",
        "ground_truth": "SELECT T2.date_received FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'",
        "amends": [
            "Do select `T2.date_received` instead of `income_date` from the `income` table. Do join `member AS T1` and `income AS T2` with an `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying only the `members` table. Do keep the same `WHERE` filter conditions `T1.first_name = 'Casey' AND T1.last_name = 'Mason'` but apply them to the member table instead of a members table. The amended query now correctly retrieves income dates by properly joining member and income tables through their relationship."
        ],
        "rules": [
            "1) When answering about \"When did the member, Casey Mason, received the income?\": make sure the output order: T2.date_received\n2) When the question mentions \"Casey Mason\": \"Casey\" actually means T1.first_name = 'Casey' and \"Mason\" actually means T1.last_name = 'Mason' in schema\n3) When combining T1 and T2 for shared entities: link rows where T1.member_id = T2.link_to_member exactly as shown in the amends; keep only matching pairs (inner match)\n4) When selecting from multiple tables: use T2.date_received from the income table instead of income_date from members table"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT income_date FROM members WHERE first_name = 'Casey' AND last_name = 'Mason';",
            "SELECT T2.date_received \nFROM member AS T1 \nINNER JOIN income AS T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason'"
        ],
        "rule_sql": [
            "SELECT T2.date_received \nFROM member T1 \nINNER JOIN income T2 ON T1.member_id = T2.link_to_member \nWHERE T1.first_name = 'Casey' AND T1.last_name = 'Mason' \nORDER BY T2.date_received"
        ],
        "amend_res": 1
    },
    "546": {
        "db_id": "codebase_community",
        "question": "Please list the display names of all the users who owns a post that is well-finished.",
        "ground_truth": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.ClosedDate IS NOT NULL",
        "amends": [
            "Do reference `T2.DisplayName` instead of `u.display_name` for the column selection. Do use `posts AS T1` and `users AS T2` instead of `users u` and `posts p` for table aliases. Do join on `T1.OwnerUserId = T2.Id` instead of `u.user_id = p.user_id` for the join condition. Do filter with `T1.ClosedDate IS NOT NULL` instead of `p.status = 'well-finished'` for the WHERE clause. The amended query now correctly identifies users who have posts with a closed date rather than using an ambiguous status value, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When selecting display names from users: use \"T2.DisplayName\" as the output column. 2) When combining posts and users tables: use aliases \"posts AS T1\" and \"users AS T2\". 3) When joining posts and users tables: link rows where \"T1.OwnerUserId = T2.Id\" exactly. 4) When filtering for well-finished posts: use condition \"T1.ClosedDate IS NOT NULL\" instead of status values. 5) When answering about users who own posts: ensure the join is an inner match keeping only users with matching posts."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT u.display_name FROM users u JOIN posts p ON u.user_id = p.user_id WHERE p.status = 'well-finished'",
            "SELECT T2.DisplayName\nFROM posts AS T1\nJOIN users AS T2 ON T1.OwnerUserId = T2.Id\nWHERE T1.ClosedDate IS NOT NULL\nGROUP BY T2.DisplayName"
        ],
        "rule_sql": [
            "SELECT T2.DisplayName\nFROM posts AS T1\nINNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id\nWHERE T1.ClosedDate IS NOT NULL"
        ],
        "amend_res": 1
    },
    "756": {
        "db_id": "superhero",
        "question": "How many bad superheroes are there?",
        "ground_truth": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Bad'",
        "amends": [
            "Do use `COUNT(T1.id)` instead of `COUNT(*)` to count specific non-null values. Do join `superhero AS T1` with `alignment AS T2` instead of querying a single table. Do specify the join condition `ON T1.alignment_id = T2.id` instead of directly filtering on alignment values. Do filter on `T2.alignment = 'Bad'` instead of `alignment = 'good'` to target the correct alignment category. The amended query now properly counts superheroes with 'Bad' alignment by joining through the relationship table instead of relying on direct column values."
        ],
        "rules": [
            "1) When counting superheroes: use COUNT(T1.id) instead of COUNT(*) to count specific non-null values. 2) When answering about superhero alignment: join superhero AS T1 with alignment AS T2 using the condition T1.alignment_id = T2.id instead of querying a single table. 3) When filtering for bad superheroes: filter on T2.alignment = 'Bad' instead of alignment = 'good' to target the correct alignment category. 4) When combining superhero and alignment tables: link rows where T1.alignment_id = T2.id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE alignment = 'good';",
            "SELECT COUNT(T1.id) \nFROM superhero AS T1\nJOIN alignment AS T2 ON T1.alignment_id = T2.id\nWHERE T2.alignment = 'Bad'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.id) \nFROM superhero AS T1 \nINNER JOIN alignment AS T2 ON T1.alignment_id = T2.id \nWHERE T2.alignment = 'Bad'"
        ],
        "amend_res": 1
    },
    "220": {
        "db_id": "toxicology",
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "ground_truth": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "amends": [
            "Do select `DISTINCT T.element` instead of `element_name` without distinct. Do use table alias `T` and source `atom AS T` instead of `toxicology_elements` without alias. Do reference column as `T.element` instead of `element_name` and maintain the same filter condition `T.molecule_id = 'TR000'`. Do order by `T.element` instead of `element_name ASC` while keeping the same limit of 3. The amended query now correctly retrieves distinct elements from the atom table with proper table referencing and maintains the same filtering and output behavior."
        ],
        "rules": [
            "1) When answering about \"top three elements of the toxicology of the molecule TR000 in alphabetical order\": make sure the output order: T.element in alphabetical order and limit to 3 rows. 2) When the question mentions \"elements\": \"elements\" actually means \"T.element in schema\". 3) When the question asks for distinct elements: compute the number of unique values of the exact token T.element. 4) When filtering for molecule TR000: use the exact literal 'TR000' with the condition T.molecule_id = 'TR000'. 5) When using table atom: use the alias T for the atom table as specified in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element_name FROM toxicology_elements WHERE molecule_id = 'TR000' ORDER BY element_name ASC LIMIT 3;",
            "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3"
        ],
        "rule_sql": [
            "SELECT T.element FROM atom T WHERE T.molecule_id = 'TR000' GROUP BY T.element ORDER BY T.element ASC LIMIT 3"
        ],
        "amend_res": 1
    },
    "228": {
        "db_id": "toxicology",
        "question": "How much of the hydrogen in molecule TR206 is accounted for? Please provide your answer as a percentage with four decimal places.",
        "ground_truth": "SELECT ROUND(CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100 / COUNT(T.atom_id),4) FROM atom AS T WHERE T.molecule_id = 'TR206'",
        "amends": [
            "Do use `COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END)` instead of `SUM(accounted_hydrogen)` for counting hydrogen atoms. Do use `COUNT(T.atom_id)` instead of `total_hydrogen` for the total count denominator. Do calculate the percentage by casting the hydrogen count to `REAL` and multiplying by 100 before division instead of dividing summed values first. Do query from `atom AS T` table instead of `hydrogen_data`. Do filter on `T.molecule_id = 'TR206'` instead of `molecule_id = 'TR206'` with proper table qualification. Do remove the column alias `percentage_accounted` instead of keeping it. The amended query now correctly calculates the percentage of hydrogen atoms in molecule TR206 by properly counting hydrogen elements and total atoms with appropriate type casting for accurate division.",
            "Do add `ROUND(...,4)` to round the percentage result to 4 decimal places instead of leaving it unrounded. Do remove the explicit `* 100.0` decimal notation and use `* 100` instead for integer multiplication. Do consolidate the calculation within a single ROUND function instead of having separate CAST operations for numerator and denominator. The amended query now correctly calculates the rounded percentage of hydrogen atoms in molecule TR206 with proper precision handling."
        ],
        "rules": [
            "1) When counting hydrogen atoms in molecule TR206: count atoms where T.element equals 'h' exactly using COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END). 2) When calculating total atoms for the denominator: use COUNT(T.atom_id) to count all atoms regardless of element. 3) When computing the percentage: cast the hydrogen count to REAL type and multiply by 100 before division to ensure accurate decimal calculation. 4) When querying for molecule TR206: filter using T.molecule_id = 'TR206' with proper table qualification. 5) When selecting from the atom table: use the alias T for the atom table instead of hydrogen_data. 6) When formatting the output: do not include a column alias for the percentage result.",
            "1) When calculating percentages that require rounding to four decimal places: use ROUND(...,4) to round the result to exactly four decimal places. 2) When multiplying by 100 for percentage conversion: use integer multiplication (* 100) instead of decimal notation (* 100.0). 3) When performing percentage calculations with division: consolidate the entire calculation within a single ROUND function rather than using separate CAST operations for numerator and denominator."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT ROUND((SUM(accounted_hydrogen) / total_hydrogen) * 100, 4) AS percentage_accounted\nFROM hydrogen_data\nWHERE molecule_id = 'TR206';",
            "SELECT \n    (CAST(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) AS REAL) * 100.0 / \n     CAST(COUNT(T.atom_id) AS REAL)) \nFROM \n    atom AS T \nWHERE \n    T.molecule_id = 'TR206'",
            "SELECT ROUND(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) * 100.0 / COUNT(T.atom_id), 4) FROM atom AS T WHERE T.molecule_id = 'TR206';"
        ],
        "rule_sql": [
            "SELECT ROUND(COUNT(CASE WHEN T.element = 'h' THEN T.atom_id ELSE NULL END) * 100.0 / COUNT(T.atom_id), 4) FROM atom T WHERE T.molecule_id = 'TR206';"
        ],
        "amend_res": 1
    },
    "1428": {
        "db_id": "student_club",
        "question": "List the city and state of members enrolled under electrical and computer engineering department.",
        "ground_truth": "SELECT city, state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE department = 'Electrical and Computer Engineering Department' AND position = 'Member'",
        "amends": [
            "Do add `INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major` and `INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip` instead of querying only the `members` table. Do use table alias `T1` for `member` instead of directly referencing `members`. Do change the department filter to `'Electrical and Computer Engineering Department'` instead of `'electrical and computer engineering'`. Do add `AND position = 'Member'` filter instead of omitting it. The amended query now correctly joins related tables and applies proper filtering conditions to match the intended behavior."
        ],
        "rules": [
            "1) When querying about members: use table alias T1 for the member table instead of directly referencing members. 2) When the question mentions \"electrical and computer engineering department\": the exact literal value is 'Electrical and Computer Engineering Department' with proper capitalization and spacing. 3) When filtering members by department: add an additional filter for position = 'Member' to only include actual members. 4) When combining member data with major information: link rows where T2.major_id = T1.link_to_major using an inner join with major table as T2. 5) When combining member data with location information: link rows where T3.zip_code = T1.zip using an inner join with zip_code table as T3."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT city, state FROM members WHERE department = 'electrical and computer engineering';",
            "SELECT T3.city, T3.state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE T2.department = 'Electrical and Computer Engineering Department' AND T1.position = 'Member'"
        ],
        "rule_sql": [
            "SELECT T3.city, T3.state FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN zip_code AS T3 ON T3.zip_code = T1.zip WHERE T2.department = 'Electrical and Computer Engineering Department' AND T1.position = 'Member'"
        ],
        "amend_res": 1
    },
    "139": {
        "db_id": "financial",
        "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
        "ground_truth": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
        "amends": [
            "Do select `COUNT(T1.card_id)` instead of `COUNT(*)` to count specific non-null values. Do join `card AS T1` and `disp AS T2` with `INNER JOIN` on `T1.disp_id = T2.disp_id` instead of querying only `credit_cards` table. Do filter on `T1.type = 'gold'` instead of `card_level = 'high'` to use the correct column and value. Do filter on `T2.type = 'OWNER'` instead of `disposition_type = 'OWNER'` to reference the joined table's column. The amended query now correctly counts gold cards owned by their owners through the proper table relationship."
        ],
        "rules": [
            "1) When counting credit cards: use COUNT(T1.card_id) to count specific non-null values instead of COUNT(*). 2) When combining card and disposition information: join card AS T1 and disp AS T2 using INNER JOIN where T1.disp_id = T2.disp_id to properly link the tables. 3) When filtering for high-level credit cards: use T1.type = 'gold' instead of card_level = 'high' to reference the correct column and value. 4) When filtering for disposition type: use T2.type = 'OWNER' instead of disposition_type = 'OWNER' to reference the joined table's column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM credit_cards WHERE card_level = 'high' AND disposition_type = 'OWNER';",
            "SELECT COUNT(T1.card_id) \nFROM card AS T1 \nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id \nWHERE T1.type = 'gold' AND T2.type = 'OWNER'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.card_id) \nFROM card AS T1 \nINNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id \nWHERE T1.type = 'gold' AND T2.type = 'OWNER'"
        ],
        "amend_res": 1
    },
    "819": {
        "db_id": "superhero",
        "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
        "ground_truth": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
        "amends": [
            "Do use `SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END)` instead of `COUNT(*) FROM superheroes WHERE weight IS NULL AND eye_color = 'blue' - COUNT(*) FROM superheroes WHERE weight IS NULL AND eye_color IS NULL`. Do join `superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id` instead of querying a single table. Do filter with `WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL` instead of `WHERE weight IS NULL AND eye_color = 'blue'` and `WHERE weight IS NULL AND eye_color IS NULL`. Do reference `T1.weight_kg` and `T1.eye_colour_id` instead of direct column references. The amended query now correctly calculates the difference between blue-eyed and null-eyed superheroes with missing weight data using proper table joins and conditional aggregation."
        ],
        "rules": [
            "1) When answering about superheroes with missing weight data: filter rows where T1.weight_kg = 0 OR T1.weight_kg is NULL. 2) When combining superhero and colour tables: link rows where T1.eye_colour_id = T2.id using an inner match. 3) When calculating the difference between blue-eyed and no-eye-color superheroes: compute SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END). 4) When handling eye color identifiers: use T2.id = 7 for blue eyes and T2.id = 1 for no eye color (null). 5) When referencing columns: use exact tokens T1.weight_kg and T1.eye_colour_id as shown in the schema."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM superheroes WHERE weight IS NULL AND eye_color = 'blue' - COUNT(*) FROM superheroes WHERE weight IS NULL AND eye_color IS NULL;",
            "SELECT \n    SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) AS difference\nFROM \n    superhero AS T1 \nINNER JOIN \n    colour AS T2 ON T1.eye_colour_id = T2.id\nWHERE \n    T1.weight_kg = 0 OR T1.weight_kg IS NULL;"
        ],
        "rule_sql": [
            "SELECT \n    SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) AS difference\nFROM \n    superhero T1\nINNER JOIN \n    colour T2 ON T1.eye_colour_id = T2.id\nWHERE \n    T1.weight_kg = 0 OR T1.weight_kg IS NULL"
        ],
        "amend_res": 1
    },
    "1502": {
        "db_id": "debit_card_specializing",
        "question": "Please list the chains of the gas stations with transactions in euro.",
        "evidence": "",
        "ground_truth": "SELECT DISTINCT T3.ChainID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID INNER JOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID WHERE T2.Currency = 'EUR'",
        "amends": [
            "Do select `T3.ChainID` instead of `chain` and change the table source to join `transactions_1k AS T1` with `customers AS T2` on `T1.CustomerID = T2.CustomerID` and `gasstations AS T3` on `T1.GasStationID = T3.GasStationID` instead of querying `gas_stations` alone. Do move the currency filter to `T2.Currency = 'EUR'` instead of applying it to the gas station table and change the currency value to `'EUR'` instead of `'euro'`. The amended query now correctly identifies gas station chains based on customer transactions and currency preferences, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about \"chains of gas stations with transactions in euro\": make sure the output order: T3.ChainID\n2) When the question mentions \"transactions in euro\": \"euro\" actually means \"T2.Currency = 'EUR'\" in schema\n3) When combining tables for shared entities: link rows where T1.CustomerID = T2.CustomerID and T1.GasStationID = T3.GasStationID; keep only matching pairs (inner match)\n4) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms\n5) When handling text literals: do not change case, spacing, or punctuation - use 'EUR' exactly as specified"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT chain FROM gas_stations WHERE currency = 'euro';",
            "SELECT DISTINCT T3.ChainID\nFROM transactions_1k AS T1\nJOIN customers AS T2 ON T1.CustomerID = T2.CustomerID\nJOIN gasstations AS T3 ON T1.GasStationID = T3.GasStationID\nWHERE T2.Currency = 'EUR'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T3.ChainID\nFROM \"transactions_1k\" T1\nINNER JOIN customers T2 ON T1.CustomerID = T2.CustomerID\nINNER JOIN gasstations T3 ON T1.GasStationID = T3.GasStationID\nWHERE T2.Currency = 'EUR'\nORDER BY T3.ChainID;"
        ],
        "amend_res": 1
    },
    "322": {
        "db_id": "toxicology",
        "question": "What is the element of toxicology for the atom with the ID of TR000_1?",
        "ground_truth": "SELECT T.element FROM atom AS T WHERE T.atom_id = 'TR000_1'",
        "amends": [
            "Do reference the `element` column with table alias `T` instead of using it unqualified, and do query from table `atom` with alias `T` instead of table `toxicology`. Do use the filter condition `T.atom_id = 'TR000_1'` with proper table qualification instead of the unqualified `atom_id` filter. The amended query now correctly retrieves data from the intended table with proper column references."
        ],
        "rules": [
            "1) When the question asks about \"element of toxicology\" for an atom: \"element\" actually means column \"element\" in table \"atom\" with alias T. 2) When the question mentions an atom with ID \"TR000_1\": use the exact literal value 'TR000_1' for filtering. 3) When querying for atom information: use table \"atom\" with alias T instead of table \"toxicology\". 4) When filtering by atom_id: use the qualified column reference T.atom_id instead of unqualified atom_id."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM toxicology WHERE atom_id = 'TR000_1';",
            "SELECT T.element FROM atom AS T WHERE T.atom_id = 'TR000_1'"
        ],
        "rule_sql": [
            "SELECT T.element FROM atom T WHERE T.atom_id = 'TR000_1'"
        ],
        "amend_res": 1
    },
    "21": {
        "db_id": "california_schools",
        "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)`< 700",
        "amends": [
            "Do reference table `frpm` instead of `schools` and count `CDSCode` instead of using `COUNT(*)`. Do filter on `County Name = 'Los Angeles'` instead of `city = 'Los Angeles'`. Do use column `Free Meal Count (K-12) > 500` instead of `free_meals > 500` and `FRPM Count (K-12) < 700` instead of `free_or_reduced_meals < 700`. Do remove the `grade_level = 'K-12'` filter instead of keeping it since the meal count columns already specify the K-12 scope. The amended query now correctly counts schools in Los Angeles County with the specified free and reduced-price meal ranges."
        ],
        "rules": [
            "1) When answering about schools in Los Angeles: use \"County Name\" = 'Los Angeles' instead of city = 'Los Angeles' 2) When counting schools: count using \"CDSCode\" instead of counting all rows 3) When filtering for free meals over 500: use \"Free Meal Count (K-12)\" > 500 4) When filtering for free or reduced price meals under 700: use \"FRPM Count (K-12)\" < 700 5) When the question mentions K-12 meal counts: do not add an additional grade_level filter since the meal columns already specify K-12 scope"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE city = 'Los Angeles' AND free_meals > 500 AND free_or_reduced_meals < 700 AND grade_level = 'K-12';",
            "SELECT COUNT(CDSCode) FROM frpm WHERE \"County Name\" = 'Los Angeles' AND \"Free Meal Count (K-12)\" > 500 AND \"FRPM Count (K-12)\" < 700"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT CDSCode) \nFROM frpm \nWHERE \"County Name\" = 'Los Angeles' \nAND \"Free Meal Count (K-12)\" > 500 \nAND \"FRPM Count (K-12)\" < 700"
        ],
        "amend_res": 1
    },
    "871": {
        "db_id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:15 in race No. 347, where is he from?",
        "ground_truth": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'",
        "amends": [
            "Do use `DISTINCT` for `nationality` instead of omitting it to remove duplicates. Do select from `qualifying AS T1` instead of `driver` and join with `drivers AS T2` instead of `race_result`. Do use `INNER JOIN` on `T2.driverId = T1.driverId` instead of `JOIN` on `driver.driver_id = race_result.driver_id`. Do filter with `T1.raceId = 347` instead of `race_result.race_no = 347` and use `T1.q2 LIKE '1:15%'` for pattern matching instead of exact equality `race_result.q2_time = '0:01:15'`. The amended query now correctly identifies drivers who qualified with q2 times starting with '1:15' for race 347 and returns their distinct nationalities."
        ],
        "rules": [
            "1) When the question asks about a driver's nationality: use \"T2.nationality\" from the drivers table with DISTINCT to remove duplicates. 2) When filtering by race number: use \"T1.raceId = 347\" instead of race_no. 3) When matching Q2 time pattern '0:01:15': use pattern matching \"T1.q2 LIKE '1:15%'\" instead of exact equality. 4) When combining qualifying and drivers tables: link rows using \"T2.driverId = T1.driverId\" for inner join. 5) When selecting from multiple tables: use qualifying as T1 and drivers as T2 as specified in the schema mapping."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver.nationality FROM driver JOIN race_result ON driver.driver_id = race_result.driver_id WHERE race_result.race_no = 347 AND race_result.q2_time = '0:01:15'",
            "SELECT DISTINCT T2.nationality\nFROM qualifying AS T1\nINNER JOIN drivers AS T2 ON T2.driverId = T1.driverId\nWHERE T1.raceId = 347\nAND T1.q2 LIKE '1:15%'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.nationality FROM qualifying T1 INNER JOIN drivers T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 347 AND T1.q2 LIKE '1:15%'"
        ],
        "amend_res": 1
    },
    "1485": {
        "db_id": "debit_card_specializing",
        "question": "How much more was customer 7 consuming in April 2013 than customer 5?",
        "ground_truth": "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) FROM yearmonth WHERE Date = '201304'",
        "amends": [
            "Do use `SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0))` instead of `(c7.consumption - c5.consumption)` for conditional aggregation. Do query from `yearmonth` table instead of `customer_consumption` table. Do filter with `Date = '201304'` instead of separate `year = 2013` and `month = 'April'` conditions. Do remove the subquery structure and instead use conditional aggregation within a single query. The amended query now correctly handles the date filtering and conditional consumption calculation in a single table scan, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about customer consumption differences: use conditional aggregation with SUM(IIF(CustomerID = <CUSTOMER_ID>, Consumption, 0)) instead of subqueries. 2) When filtering by year and month: use the combined Date column with format 'YYYYMM' (e.g., '201304' for April 2013) instead of separate year and month conditions. 3) When querying customer consumption data: use the yearmonth table instead of customer_consumption table. 4) When calculating consumption differences between specific customers: subtract the conditional sums directly (SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)))."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (c7.consumption - c5.consumption) AS consumption_difference\nFROM (\n    SELECT consumption \n    FROM customer_consumption \n    WHERE customer_id = 7 \n    AND year = 2013 \n    AND month = 'April'\n) AS c7,\n(\n    SELECT consumption \n    FROM customer_consumption \n    WHERE customer_id = 5 \n    AND year = 2013 \n    AND month = 'April'\n) AS c5;",
            "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) AS consumption_difference FROM yearmonth WHERE Date = '201304'"
        ],
        "rule_sql": [
            "SELECT SUM(IIF(CustomerID = 7, Consumption, 0)) - SUM(IIF(CustomerID = 5, Consumption, 0)) AS ConsumptionDifference FROM yearmonth WHERE Date = '201304';"
        ],
        "amend_res": 1
    },
    "1135": {
        "db_id": "european_football_2",
        "question": "Please provide top five football players' IDs who are among the lowest potential players and prefer to use the right foot when attacking.",
        "ground_truth": "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5",
        "amends": [
            "Do select `id` from `Player_Attributes` instead of `player_id` from `players`. Do use `ORDER BY potential DESC` with `LIMIT 5` instead of filtering with `WHERE potential = (SELECT MIN(potential) FROM players)`. Do keep the `preferred_foot = 'right'` filter but move it to the main query instead of a subquery context. Do remove the subquery entirely instead of using it to find minimum potential values. The amended query now correctly retrieves the top 5 players by potential with right preferred foot from the Player_Attributes table, matching the RIGHT_SQL's behavior.",
            "Do order by `potential DESC` instead of `potential ASC` to sort in descending order rather than ascending order, which changes the query to return the top 5 players with the highest potential values instead of the lowest 5 players with the lowest potential values. The amended query now matches RIGHT_SQL's behavior by correctly ordering results from highest to lowest potential."
        ],
        "rules": [
            "1) When answering about \"top five football players' IDs who are among the lowest potential players and prefer to use the right foot\": make sure the output order: id from Player_Attributes table. 2) When the question mentions \"player's IDs\": \"player's IDs\" actually means \"id in Player_Attributes table\". 3) When the question mentions \"top five\" by potential: rank rows by potential in descending order and keep the first 5 rows. 4) When the question mentions \"prefer to use the right foot\": \"right foot\" actually means \"preferred_foot = 'right'\" in Player_Attributes table. 5) When selecting from Player_Attributes table: use double quotes around \"Player_Attributes\" as shown in the schema.",
            "1) When the question asks for \"top five football players' IDs who are among the lowest potential players\": order by \"potential\" in ascending order to get the lowest potential values first, then take the first 5 rows. 2) When the question mentions players who \"prefer to use the right foot when attacking\": filter rows where \"preferred_foot\" equals exactly 'right' (case-sensitive). 3) When answering about football players' IDs: select the \"id\" column from the Player_Attributes table."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT player_id FROM players WHERE potential = (SELECT MIN(potential) FROM players) AND preferred_foot = 'right' LIMIT 5;",
            "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 5",
            "SELECT id FROM Player_Attributes WHERE preferred_foot = 'right' ORDER BY potential DESC LIMIT 5"
        ],
        "rule_sql": [
            "SELECT id FROM \"Player_Attributes\" WHERE preferred_foot = 'right' ORDER BY potential ASC LIMIT 5"
        ],
        "amend_res": 1
    },
    "1103": {
        "db_id": "european_football_2",
        "question": "What was the overall rating for Aaron Mooy on 2016/2/4?",
        "ground_truth": "SELECT t2.overall_rating FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2016-02-04' AND t1.player_name = 'Aaron Mooy'",
        "amends": [
            "Do select `t2.overall_rating` instead of `rating` and use table aliases `t1` and `t2` instead of single table reference. Do join `Player AS t1` and `Player_Attributes AS t2` with `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of querying only `player_ratings` table. Do filter with `SUBSTR(t2.date, 1, 10) = '2016-02-04'` for date comparison instead of `date = '2016/2/4'` and maintain the player name filter `t1.player_name = 'Aaron Mooy'` instead of `player_name = 'Aaron Mooy'`. The amended query now correctly joins the player and attributes tables using the proper API ID relationship and handles date formatting consistently."
        ],
        "rules": [
            "1) When answering about player ratings: use table aliases T1 for Player table and T2 for Player_Attributes table instead of single table references. 2) When combining Player and Player_Attributes tables: link rows where T1.player_api_id = T2.player_api_id and keep only matching pairs (inner match). 3) When filtering by player name \"Aaron Mooy\": use T1.player_name = 'Aaron Mooy' with exact case and spacing. 4) When filtering by date \"2016/2/4\": convert to format '2016-02-04' and use SUBSTR(T2.date, 1, 10) = '2016-02-04' for date comparison. 5) When selecting the overall rating: output T2.overall_rating instead of just rating."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT rating FROM player_ratings WHERE player_name = 'Aaron Mooy' AND date = '2016/2/4';",
            "SELECT t2.overall_rating \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Aaron Mooy' \nAND SUBSTR(t2.date, 1, 10) = '2016-02-04'"
        ],
        "rule_sql": [
            "SELECT T2.overall_rating \nFROM Player T1 \nINNER JOIN Player_Attributes T2 ON T1.player_api_id = T2.player_api_id \nWHERE T1.player_name = 'Aaron Mooy' \nAND SUBSTR(T2.date, 1, 10) = '2016-02-04'"
        ],
        "amend_res": 1
    },
    "664": {
        "db_id": "codebase_community",
        "question": "What is the sum of score of the post on 2010-07-19?",
        "ground_truth": "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%'",
        "amends": [
            "Do use the correct column name `Score` instead of `score` in the SELECT clause. Do reference the correct date column `LasActivityDate` instead of `date` in the WHERE clause. Do use a LIKE operator with wildcard pattern matching (`'2010-07-19%'`) instead of exact equality comparison (`'2010-07-19'`) to capture all records from that date regardless of time component. The amended query now correctly aggregates scores from posts with activity on July 19, 2010, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for sum of score: use the exact column name \"Score\" from the posts table. 2) When filtering by date '2010-07-19': use the column \"LasActivityDate\" with a pattern match using '2010-07-19%' to capture all records from that date regardless of time component. 3) When computing aggregates on posts: ensure the query uses the correct column identifiers as specified in the schema without case or spelling variations."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(score) FROM posts WHERE date = '2010-07-19';",
            "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%'"
        ],
        "rule_sql": [
            "SELECT SUM(Score) FROM posts WHERE LasActivityDate LIKE '2010-07-19%'"
        ],
        "amend_res": 1
    },
    "953": {
        "db_id": "formula_1",
        "question": "How many French constructors have a lap number of over 50?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.constructorId) FROM results AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.laps > 50 AND T2.nationality = 'French'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.constructorId)` instead of `COUNT(*)` to count unique constructors rather than all rows. Do join `results AS T1 INNER JOIN constructors AS T2` instead of querying only the `constructors` table to access race results data. Do use the join condition `T1.constructorId = T2.constructorId` instead of no join to properly relate results to constructors. Do move the `laps > 50` filter to the `results` table instead of applying it to `constructors` since laps data belongs to race results. Do keep the `nationality = 'French'` filter on the `constructors` table but reference it as `T2.nationality` instead of the original table name. The amended query now correctly counts distinct French constructors who have completed more than 50 laps in races, matching the intended behavior."
        ],
        "rules": [
            "1) When counting constructors: use COUNT(DISTINCT T2.constructorId) instead of COUNT(*) to count unique constructors rather than all rows. 2) When accessing both constructor and race results data: join results AS T1 INNER JOIN constructors AS T2 using the condition T1.constructorId = T2.constructorId instead of querying only the constructors table. 3) When filtering by lap count: apply the laps > 50 filter to the results table (T1.laps > 50) instead of the constructors table since laps data belongs to race results. 4) When filtering by nationality: apply the nationality = 'French' filter to the constructors table (T2.nationality = 'French') using the exact literal 'French'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM constructors WHERE nationality = 'French' AND laps > 50;",
            "SELECT COUNT(DISTINCT T2.constructorId) \nFROM results AS T1 \nINNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId \nWHERE T2.nationality = 'French' AND T1.laps > 50"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.constructorId) \nFROM results AS T1 \nINNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId \nWHERE T1.laps > 50 \nAND T2.nationality = 'French'"
        ],
        "amend_res": 1
    },
    "191": {
        "db_id": "financial",
        "question": "How many loan accounts are for pre-payment of duration of 24 months with weekly issuance of statement.",
        "ground_truth": "SELECT COUNT(T2.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration = 24 AND T1.frequency = 'POPLATEK TYDNE'",
        "amends": [
            "Do select `COUNT(T2.account_id)` instead of `COUNT(*)` to count specific loan accounts. Do join `account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id` instead of querying only `loan_accounts` to properly relate account and loan tables. Do filter on `T2.duration = 24` instead of `duration = 24` to specify the table alias. Do filter on `T1.frequency = 'POPLATEK TYDNE'` instead of `statement_frequency = 'weekly' AND payment_type = 'pre-payment'` to use the correct frequency column and value from the account table while removing the incorrect payment_type condition. The amended query now correctly counts loan accounts with 24-month duration and weekly frequency as specified in the right SQL."
        ],
        "rules": [
            "1) When counting loan accounts: use COUNT(T2.account_id) instead of COUNT(*) to count specific loan account entities. 2) When relating account and loan information: join account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id to properly combine account and loan tables. 3) When filtering by duration: use T2.duration = 24 to specify the duration condition from the loan table. 4) When filtering by statement frequency: use T1.frequency = 'POPLATEK TYDNE' instead of statement_frequency = 'weekly' to use the correct frequency column and value from the account table. 5) When the question mentions \"pre-payment\": do not include payment_type = 'pre-payment' condition as it is not required based on the schema relationship."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM loan_accounts WHERE duration = 24 AND statement_frequency = 'weekly' AND payment_type = 'pre-payment';",
            "SELECT COUNT(T2.account_id) \nFROM account AS T1 \nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id \nWHERE T2.duration = 24 \nAND T1.frequency = 'POPLATEK TYDNE'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.account_id) \nFROM account AS T1 \nINNER JOIN loan AS T2 ON T1.account_id = T2.account_id \nWHERE T2.duration = 24 \nAND T1.frequency = 'POPLATEK TYDNE'"
        ],
        "amend_res": 1
    },
    "612": {
        "db_id": "codebase_community",
        "question": "What is the name of badge that the user whose display name is \"Pierre\" obtained?",
        "evidence": "",
        "ground_truth": "SELECT T2.Name FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre'",
        "amends": [
            "Do use an explicit `INNER JOIN` between `users` and `badges` tables instead of a subquery for user lookup. Do reference the joined table as `T2` instead of querying `badges` directly. Do join on `T1.Id = T2.UserId` instead of using a subquery with `user_id = (SELECT id FROM users)`. Do select `T2.Name` instead of `badge_name` from the badges table. Do filter on `T1.DisplayName` instead of `display_name` in the WHERE clause. The amended query now correctly retrieves badge names through a proper table join instead of a potentially inefficient subquery approach."
        ],
        "rules": [
            "1) When the question asks about badges obtained by a user with display name \"Pierre\": use an inner join between users table (T1) and badges table (T2) instead of subqueries. 2) When combining users and badges tables: link rows where T1.Id equals T2.UserId and keep only matching pairs (inner match). 3) When selecting badge names: use T2.Name instead of badge_name from the badges table. 4) When filtering by user display name: use T1.DisplayName instead of display_name in the WHERE clause with the exact literal value \"Pierre\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT badge_name FROM badges WHERE user_id = (SELECT id FROM users WHERE display_name = 'Pierre')",
            "SELECT T2.Name \nFROM users T1 \nINNER JOIN badges T2 ON T1.Id = T2.UserId \nWHERE T1.DisplayName = 'Pierre'"
        ],
        "rule_sql": [
            "SELECT T2.Name FROM users T1 INNER JOIN badges T2 ON T1.Id = T2.UserId WHERE T1.DisplayName = 'Pierre';"
        ],
        "amend_res": 1
    },
    "869": {
        "db_id": "formula_1",
        "question": "For the constructor which got the highest point in the race No. 9 , what is its introduction website?",
        "ground_truth": "SELECT T2.url FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1",
        "amends": [
            "Do select `T2.url` instead of `website` and use explicit table aliases. Do join `constructorResults AS T1` with `constructors AS T2` on `T2.constructorId = T1.constructorId` instead of using a subquery to find the constructor_id. Do filter with `T1.raceId = 9` in the WHERE clause instead of using a subquery condition. Do add `ORDER BY T1.points DESC` and `LIMIT 1` to the main query instead of having them in a subquery. The amended query now correctly retrieves the constructor website by joining the results table directly and ordering by points to find the top result for race 9, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about the constructor with highest points in race No. 9: make sure the output order: T2.url 2) When combining constructorResults (T1) and constructors (T2): link rows where T2.constructorId = T1.constructorId and keep only matching pairs (inner match). 3) When filtering for race No. 9: use T1.raceId = 9 exactly. 4) When the question mentions \"highest point\": rank rows by T1.points in descending order and keep the first 1 row. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT website FROM constructors WHERE constructor_id = (SELECT constructor_id FROM results WHERE race_id = 9 ORDER BY points DESC LIMIT 1);",
            "SELECT T2.url \nFROM constructorResults AS T1 \nJOIN constructors AS T2 ON T2.constructorId = T1.constructorId \nWHERE T1.raceId = 9 \nORDER BY T1.points DESC \nLIMIT 1"
        ],
        "rule_sql": [
            "SELECT T2.url FROM constructorResults T1 INNER JOIN constructors T2 ON T2.constructorId = T1.constructorId WHERE T1.raceId = 9 ORDER BY T1.points DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "413": {
        "db_id": "card_games",
        "question": "How many cards with print rarity have ruling text printed on 01/02/2007?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'rare' AND T2.date = '2007-02-01'",
        "amends": [
            "Do `COUNT(DISTINCT T1.id)` instead of `COUNT(*)` to count distinct card IDs rather than all rows. Do `INNER JOIN` with `T1.uuid = T2.uuid` instead of `JOIN` with `c.id = r.card_id` to join on UUID columns rather than ID columns. Do filter with `T1.rarity = 'rare'` instead of `c.print_rarity IS NOT NULL` to specifically target rare cards rather than any non-null rarity. Do filter with `T2.date = '2007-02-01'` instead of `r.text LIKE '%01/02/2007%'` to match the exact date value in the date column rather than searching for a text pattern. Do use table aliases `T1` and `T2` instead of `c` and `r` for consistency. The amended query now correctly counts distinct rare cards with rulings on the specific date 2007-02-01."
        ],
        "rules": [
            "1) When counting cards: count distinct T1.id values rather than all rows. 2) When joining cards and rulings tables: use inner join with T1.uuid = T2.uuid to match on UUID columns. 3) When filtering for print rarity: use T1.rarity = 'rare' to specifically target rare cards. 4) When filtering for ruling date: use T2.date = '2007-02-01' to match the exact date value. 5) When referring to tables: use aliases T1 for cards and T2 for rulings consistently."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM cards c JOIN rulings r ON c.id = r.card_id WHERE c.print_rarity IS NOT NULL AND r.text LIKE '%01/02/2007%';",
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1\nINNER JOIN rulings T2 ON T1.uuid = T2.uuid\nWHERE T1.rarity = 'rare'\nAND T2.date = '2007-02-01'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.id) \nFROM cards T1 \nINNER JOIN rulings T2 ON T1.uuid = T2.uuid \nWHERE T1.rarity = 'rare' \nAND T2.date = '2007-02-01'"
        ],
        "amend_res": 1
    },
    "334": {
        "db_id": "toxicology",
        "question": "What is the element with the atom ID of TR004_7 in molecule that is not carcinogenic?",
        "ground_truth": "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR004_7' AND T2.label = '-'",
        "amends": [
            "Do specify the table alias `T1.element` instead of just `element` in the SELECT list. Do join `atom AS T1` and `molecule AS T2` with an `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table. Do filter on `T2.label = '-'` instead of `carcinogenic = 'yes'` while keeping the `T1.atom_id = 'TR004_7'` condition. The amended query now correctly joins the atom and molecule tables and filters based on the appropriate label condition instead of the carcinogenic property."
        ],
        "rules": [
            "1) When answering about \"element with atom ID of TR004_7 in molecule that is not carcinogenic\": make sure the output order: T1.element 2) When the question mentions \"atom ID\": \"atom ID\" actually means \"T1.atom_id in schema\" 3) When the question mentions \"not carcinogenic\": \"not carcinogenic\" actually means \"T2.label = '-' in schema\" 4) When combining T1 (atom) and T2 (molecule) for shared entities: link rows where T1.molecule_id = T2.molecule_id; keep only matching pairs (inner match) 5) When filtering for specific atom ID: use exact literal value 'TR004_7' for T1.atom_id"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT element FROM molecules WHERE atom_id = 'TR004_7' AND carcinogenic = 'yes';",
            "SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR004_7' AND T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT T1.element \nFROM atom T1\nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nWHERE T1.atom_id = 'TR004_7' AND T2.label = '-'"
        ],
        "amend_res": 1
    },
    "950": {
        "db_id": "formula_1",
        "question": "Please list the constructor names with 0 points at race 291.",
        "ground_truth": "SELECT T2.name FROM constructorStandings AS T1 INNER JOIN constructors AS T2 on T1.constructorId = T2.constructorId WHERE T1.points = 0 AND T1.raceId = 291",
        "amends": [
            "Do select `T2.name` from the `constructors` table instead of `constructor_name` from the `constructors` table. Do join `constructorStandings AS T1` with `constructors AS T2` using `INNER JOIN` on `T1.constructorId = T2.constructorId` instead of querying only the `constructors` table. Do filter on `T1.points = 0` and `T1.raceId = 291` from the joined `constructorStandings` table instead of filtering `points` and `race_id` directly on the `constructors` table. The amended query now correctly retrieves constructor names based on standings data rather than incorrectly assuming points and race information exists directly in the constructors table, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about constructor names with 0 points at a specific race: make sure the output order: T2.name. 2) When the question mentions \"constructor names\": \"constructor names\" actually means \"T2.name in schema\". 3) When combining T1 and T2 for shared entities: link rows where T1.constructorId = T2.constructorId exactly as shown in the amends; keep only matching pairs (inner match). 4) When filtering for 0 points at race 291: filter on T1.points = 0 and T1.raceId = 291 from the constructorStandings table instead of filtering directly on the constructors table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT constructor_name FROM constructors WHERE points = 0 AND race_id = 291;",
            "SELECT T2.name \nFROM constructorStandings AS T1 \nINNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId \nWHERE T1.points = 0 AND T1.raceId = 291;"
        ],
        "rule_sql": [
            "SELECT T2.name \nFROM constructorStandings T1 \nINNER JOIN constructors T2 ON T1.constructorId = T2.constructorId \nWHERE T1.raceId = 291 AND T1.points = 0 \nORDER BY T2.name"
        ],
        "amend_res": 1
    },
    "1127": {
        "db_id": "european_football_2",
        "question": "Locate players with vision scores of 90 and above, state the country of these players.",
        "ground_truth": "SELECT DISTINCT t4.name FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id INNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8 INNER JOIN Country AS t4 ON t3.country_id = t4.id WHERE t1.vision > 89",
        "amends": [
            "Do use `DISTINCT t4.name` instead of `country` in the SELECT list. Do add joins to `Player_Attributes AS t1`, `Player AS t2`, `Match AS t3`, and `Country AS t4` instead of querying only the `players` table. Do use `INNER JOIN` relationships with `t1.player_api_id = t2.player_api_id`, `t2.player_api_id = t3.home_player_8`, and `t3.country_id = t4.id` instead of no joins. Do filter with `t1.vision > 89` instead of `vision_score > 90` in the WHERE clause. The amended query now correctly retrieves distinct country names based on player vision attributes through proper table relationships."
        ],
        "rules": [
            "1) When the question asks for \"country of these players\": use \"DISTINCT t4.name\" instead of \"country\" in the output. 2) When combining player data with country information: link tables using INNER JOIN relationships with \"t1.player_api_id = t2.player_api_id\", \"t2.player_api_id = t3.home_player_8\", and \"t3.country_id = t4.id\". 3) When filtering for players with vision scores of 90 and above: use \"t1.vision > 89\" instead of \"vision_score > 90\" in the filter condition. 4) When answering about players with high vision scores: make sure to join Player_Attributes as t1, Player as t2, Match as t3, and Country as t4 instead of querying only a single players table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT country FROM players WHERE vision_score > 90;",
            "SELECT DISTINCT t4.name\nFROM Player_Attributes AS t1\nINNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id\nINNER JOIN Match AS t3 ON t2.player_api_id = t3.home_player_8\nINNER JOIN Country AS t4 ON t3.country_id = t4.id\nWHERE t1.vision > 89"
        ],
        "rule_sql": [
            "SELECT DISTINCT t4.name\nFROM Player_Attributes t1\nINNER JOIN Player t2 ON t1.player_api_id = t2.player_api_id\nINNER JOIN Match t3 ON t2.player_api_id = t3.home_player_8\nINNER JOIN Country t4 ON t3.country_id = t4.id\nWHERE t1.vision > 89;"
        ],
        "amend_res": 1
    },
    "481": {
        "db_id": "card_games",
        "question": "Please list all the foreign languages in which the card \"Ancestor's Chosen\" has a flavor text.",
        "ground_truth": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.flavorText IS NOT NULL",
        "amends": [
            "Do join `foreign_data AS T2` on `T2.uuid = T1.uuid` instead of querying only the `cards` table. Do reference `T2.language` instead of `language` from the original table. Do use `T2.flavorText IS NOT NULL` instead of `flavor_text IS NOT NULL` to reference the correct column name from the joined table. Do remove `DISTINCT` instead of keeping it since the join relationship ensures uniqueness. Do specify `T1.name = 'Ancestor''s Chosen'` with proper table qualification instead of just `name`. The amended query now correctly retrieves language data from the foreign_data table while maintaining the same filtering logic."
        ],
        "rules": [
            "1) When answering about foreign languages for a specific card: join foreign_data as T2 on T2.uuid = T1.uuid to access language data. 2) When filtering for card \"Ancestor's Chosen\": use T1.name = 'Ancestor''s Chosen' with exact table qualification and literal value. 3) When checking for flavor text existence: use T2.flavorText IS NOT NULL to reference the correct column from the joined table. 4) When retrieving languages: reference T2.language instead of language from the original table. 5) When ensuring unique results: do not use DISTINCT since the join relationship ensures uniqueness."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT DISTINCT language FROM cards WHERE name = 'Ancestor\\'s Chosen' AND flavor_text IS NOT NULL;",
            "SELECT T2.language\nFROM cards AS T1\nJOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.name = 'Ancestor''s Chosen'\nAND T2.flavorText IS NOT NULL"
        ],
        "rule_sql": [
            "SELECT T2.language \nFROM cards AS T1\nJOIN foreign_data AS T2 ON T2.uuid = T1.uuid\nWHERE T1.name = 'Ancestor''s Chosen'\nAND T2.flavorText IS NOT NULL"
        ],
        "amend_res": 1
    },
    "1172": {
        "db_id": "thrombosis_prediction",
        "question": "How many male patients have elevated total bilirubin count?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`T-BIL` >= 2.0 AND T1.SEX = 'M'",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do join `Patient AS T1` with `Laboratory AS T2` on `T1.ID = T2.ID` instead of querying only the `patients` table to incorporate lab data. Do filter on `T2.\"T-BIL\" >= 2.0` instead of `total_bilirubin > 1.2` to use the correct lab value column with a different threshold. Do filter on `T1.SEX = 'M'` instead of `gender = 'male'` to use the correct column name and value format. The amended query now correctly counts distinct male patients with elevated bilirubin levels from laboratory results."
        ],
        "rules": [
            "1) When counting patients: use COUNT(DISTINCT T1.ID) to count unique patient IDs rather than all rows. 2) When combining patient and laboratory data: join Patient AS T1 with Laboratory AS T2 on T1.ID = T2.ID to incorporate lab data. 3) When filtering for elevated bilirubin: use T2.\"T-BIL\" >= 2.0 instead of total_bilirubin > 1.2 to use the correct lab value column with the proper threshold. 4) When filtering for male patients: use T1.SEX = 'M' instead of gender = 'male' to use the correct column name and value format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND total_bilirubin > 1.2",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' AND T2.\"T-BIL\" >= 2.0"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nJOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'M' AND T2.\"T-BIL\" >= 2.0"
        ],
        "amend_res": 1
    },
    "26": {
        "db_id": "california_schools",
        "question": "State the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17?",
        "ground_truth": "SELECT T1.`School Name`, T2.Street, T2.City, T2.State, T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Monterey' AND T1.`Free Meal Count (Ages 5-17)` > 800 AND T1.`School Type` = 'High Schools (Public)'",
        "amends": [
            "Do select `T1.School Name`, `T2.Street`, `T2.City`, `T2.State`, and `T2.Zip` instead of `name` and `address`. Do use `frpm AS T1` and `schools AS T2` as source tables instead of `high_schools`. Do perform an `INNER JOIN` on `T1.CDSCode = T2.CDSCode` instead of querying a single table. Do filter on `T2.County = 'Monterey'` instead of `city = 'Monterey'`. Do filter on `T1.Free Meal Count (Ages 5-17) > 800` instead of `free_reduced_meals > 800`. Do filter on `T1.School Type = 'High Schools (Public)'` instead of `age_group = '15-17'`. The amended query now correctly joins the appropriate tables and uses the proper column names and filter conditions to match the intended logic."
        ],
        "rules": [
            "1) When answering about high schools in Monterey: use T1.School Name, T2.Street, T2.City, T2.State, and T2.Zip as output columns in that order. 2) When combining data about free meals and school addresses: link frpm as T1 and schools as T2 where T1.CDSCode = T2.CDSCode and keep only matching pairs (inner match). 3) When the question mentions \"Monterey\": filter on T2.County = 'Monterey' exactly. 4) When the question mentions \"more than 800 free or reduced price meals\": filter on T1.\"Free Meal Count (Ages 5-17)\" > 800. 5) When the question mentions \"high schools\": filter on T1.\"School Type\" = 'High Schools (Public)' exactly. 6) When the question mentions \"ages 15-17\": the condition is already covered by filtering for high schools (ages 15-17 are typically in high schools)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name, address FROM high_schools WHERE city = 'Monterey' AND free_reduced_meals > 800 AND age_group = '15-17';",
            "SELECT T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Monterey'\nAND T1.\"Free Meal Count (Ages 5-17)\" > 800\nAND T1.\"School Type\" = 'High Schools (Public)'"
        ],
        "rule_sql": [
            "SELECT T1.\"School Name\", T2.Street, T2.City, T2.State, T2.Zip\nFROM frpm AS T1\nINNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T2.County = 'Monterey'\nAND T1.\"Free Meal Count (Ages 5-17)\" > 800\nAND T1.\"School Type\" = 'High Schools (Public)'"
        ],
        "amend_res": 1
    },
    "239": {
        "db_id": "toxicology",
        "question": "How many connections does the atom 19 have?",
        "ground_truth": "SELECT COUNT(T.bond_id) FROM connected AS T WHERE SUBSTR(T.atom_id, -2) = '19'",
        "amends": [
            "Do specify `COUNT(T.bond_id)` instead of `COUNT(*)` to count specific non-null values. Do use table alias `T` instead of no alias for explicit column references. Do change the table name to `connected` instead of `connections` to reference the correct data source. Do apply `SUBSTR(T.atom_id, -2) = '19'` instead of `atom_id = 19` to extract and compare the last two characters as strings rather than performing numeric comparison. The amended query now correctly matches the intended behavior by counting bonds where the atom_id ends with '19'."
        ],
        "rules": [
            "1) When counting connections for an atom: count the number of bond_id values from table \"connected\" (aliased as T) where the bond_id is not null. 2) When matching atom identifiers by their ending digits: extract the last two characters of T.atom_id using SUBSTR and compare them to the string literal '19' exactly. 3) When referencing columns from the connected table: use the alias T for explicit column references (e.g., T.atom_id, T.bond_id). 4) When the question asks about \"connections\": this refers to bonds in the \"connected\" table, not a \"connections\" table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM connections WHERE atom_id = 19;",
            "SELECT COUNT(T.bond_id) \nFROM connected T \nWHERE SUBSTR(T.atom_id, -2) = '19'"
        ],
        "rule_sql": [
            "SELECT COUNT(T.bond_id) \nFROM connected T \nWHERE T.bond_id IS NOT NULL \nAND SUBSTR(T.atom_id, -2) = '19';"
        ],
        "amend_res": 1
    },
    "1091": {
        "db_id": "european_football_2",
        "question": "How many matches were held in the Belgium Jupiler League in April, 2009?",
        "ground_truth": "SELECT COUNT(t2.id) FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t1.name = 'Belgium Jupiler League' AND SUBSTR(t2.`date`, 1, 7) = '2009-04'",
        "amends": [
            "Do join `League AS t1` and `Match AS t2` with `INNER JOIN` on `t1.id = t2.league_id` instead of querying only the `matches` table. Do filter by `t1.name = 'Belgium Jupiler League'` instead of directly filtering `league` column. Do use `SUBSTR(t2.date, 1, 7) = '2009-04'` for date filtering instead of `date LIKE '2009-04%'`. Do count `t2.id` instead of using `COUNT(*)`. The amended query now correctly joins related tables and uses proper date comparison functions to match the intended behavior."
        ],
        "rules": [
            "1) When answering about matches in a specific league: join League AS t1 and Match AS t2 where t1.id = t2.league_id to link league information with match data. 2) When filtering for 'Belgium Jupiler League': use t1.name = 'Belgium Jupiler League' to identify the correct league. 3) When filtering for April 2009: use SUBSTR(t2.date, 1, 7) = '2009-04' to extract year-month from the date column. 4) When counting matches: count t2.id as the canonical identifier for matches instead of counting all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM matches WHERE league = 'Belgium Jupiler League' AND date LIKE '2009-04%';",
            "SELECT COUNT(t2.id) \nFROM League AS t1 \nINNER JOIN Match AS t2 ON t1.id = t2.league_id \nWHERE t1.name = 'Belgium Jupiler League' \nAND SUBSTR(t2.date, 1, 7) = '2009-04'"
        ],
        "rule_sql": [
            "SELECT COUNT(t2.id) AS match_count\nFROM League AS t1\nJOIN Match AS t2 ON t1.id = t2.league_id\nWHERE t1.name = 'Belgium Jupiler League'\nAND SUBSTR(t2.date, 1, 7) = '2009-04'"
        ],
        "amend_res": 1
    },
    "1036": {
        "db_id": "european_football_2",
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "ground_truth": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE STRFTIME('%Y',t2.`date`) = '2012')",
        "amends": [
            "Do select `t4.team_long_name` with `DISTINCT` instead of `long_name` without distinct. Do join `Team_Attributes AS t3` with `Team AS t4` on `t3.team_api_id = t4.team_api_id` instead of querying a single `teams` table. Do filter with `SUBSTR(t3.date, 1, 4) = '2012'` instead of `year = 2012`. Do use the subquery with explicit casting and proper aggregation `CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id)` instead of simple `AVG(build_up_play_passing)`. Do correlate the subquery by joining `Team AS t1` with `Team_Attributes AS t2` on `team_api_id` and filtering with `STRFTIME('%Y',t2.date) = '2012'` instead of an uncorrelated average. The amended query now correctly handles the schema separation between teams and their attributes while ensuring proper year filtering and accurate average calculation."
        ],
        "rules": [
            "1) When the question asks for team long names: use \"t4.team_long_name\" with DISTINCT instead of \"long_name\" without distinct. 2) When combining team attributes and team information: join \"Team_Attributes AS t3\" with \"Team AS t4\" on \"t3.team_api_id = t4.team_api_id\" using inner match. 3) When filtering for year 2012 in team attributes: use \"SUBSTR(t3.date, 1, 4) = '2012'\" instead of a year column. 4) When calculating the average build-up play passing: use \"CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id)\" with proper casting and aggregation. 5) When correlating the subquery for average calculation: join \"Team AS t1\" with \"Team_Attributes AS t2\" on \"team_api_id\" and filter with \"STRFTIME('%Y',t2.date) = '2012'\" to ensure year-specific correlation."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT long_name FROM teams WHERE build_up_play_passing > (SELECT AVG(build_up_play_passing) FROM teams) AND year = 2012;",
            "SELECT DISTINCT t4.team_long_name\nFROM Team_Attributes AS t3\nJOIN Team AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE SUBSTR(t3.date, 1, 4) = '2012'\nAND t3.buildUpPlayPassing > (\n    SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id)\n    FROM Team AS t1\n    JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\n    WHERE STRFTIME('%Y', t2.date) = '2012'\n)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t4.team_long_name\nFROM Team_Attributes AS t3\nINNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id\nWHERE SUBSTR(t3.date, 1, 4) = '2012'\nAND t3.buildUpPlayPassing > (\n    SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id)\n    FROM Team AS t1\n    INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id\n    WHERE STRFTIME('%Y', t2.date) = '2012'\n)"
        ],
        "amend_res": 1
    },
    "52": {
        "db_id": "california_schools",
        "question": "What is the total number of schools whose total SAT scores are greater or equal to 1500 whose mailing city is Lakeport?",
        "ground_truth": "SELECT COUNT(T1.cds) FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.MailCity = 'Lakeport' AND (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500",
        "amends": [
            "Do join `satscores AS T1` with `schools AS T2` on `T1.cds = T2.CDSCode` instead of querying only the `schools` table. Do reference `T2.MailCity` instead of `city` for the city filter. Do calculate the SAT score as `(T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite)` instead of using `total_sat_score`. Do count `T1.cds` instead of using `COUNT(*)`. The amended query now correctly joins the necessary tables and calculates the composite SAT score from individual components to match the intended behavior."
        ],
        "rules": [
            "1) When answering about schools with SAT scores: join \"satscores\" as T1 with \"schools\" as T2 where T1.cds equals T2.CDSCode to combine SAT and school information. 2) When calculating total SAT scores: compute the sum of T1.AvgScrRead, T1.AvgScrMath, and T1.AvgScrWrite instead of using a precomputed total_sat_score column. 3) When filtering by mailing city: use T2.MailCity instead of city and match exactly 'Lakeport' with proper case. 4) When counting schools: count T1.cds (the canonical key) instead of using COUNT(*) to ensure accurate school counting. 5) When applying SAT score threshold: ensure the calculated total SAT score is greater than or equal to 1500."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE total_sat_score >= 1500 AND city = 'Lakeport';",
            "SELECT COUNT(T1.cds) \nFROM satscores AS T1 \nJOIN schools AS T2 ON T1.cds = T2.CDSCode \nWHERE (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500 \nAND T2.MailCity = 'Lakeport';"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.cds) \nFROM satscores T1\nJOIN schools T2 ON T1.cds = T2.CDSCode\nWHERE (T1.AvgScrRead + T1.AvgScrMath + T1.AvgScrWrite) >= 1500\nAND T2.MailCity = 'Lakeport';"
        ],
        "amend_res": 1
    },
    "1104": {
        "db_id": "european_football_2",
        "question": "What was the potiential for Francesco Parravicini on 2010/8/30?",
        "ground_truth": "SELECT t2.potential FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2010-08-30' AND t1.player_name = 'Francesco Parravicini'",
        "amends": [
            "Do select `t2.potential` instead of `potential` without table qualification. Do use `INNER JOIN` between `Player AS t1` and `Player_Attributes AS t2` on `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do filter with `t1.player_name = 'Francesco Parravicini'` instead of `name = 'Francesco Parravicini'` to use the correct column name. Do filter with `SUBSTR(t2.date, 1, 10) = '2010-08-30'` instead of `date = '2010/8/30'` to handle date format differences and extract only the date portion. The amended query now correctly joins player data with their attributes and handles the date comparison properly to match the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about player potential: select \"t2.potential\" instead of unqualified \"potential\" to specify the correct table source. 2) When the question mentions a player name: \"Francesco Parravicini\" maps to \"t1.player_name\" in the schema, not \"name\". 3) When combining player data with attributes: link rows where \"t1.player_api_id = t2.player_api_id\" using an inner match between Player AS t1 and Player_Attributes AS t2. 4) When filtering by date \"2010/8/30\": convert to format \"2010-08-30\" and use SUBSTR(t2.date, 1, 10) = '2010-08-30' to handle date format differences and extract only the date portion."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT potential FROM players WHERE name = 'Francesco Parravicini' AND date = '2010/8/30';",
            "SELECT t2.potential \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Francesco Parravicini' \nAND SUBSTR(t2.date, 1, 10) = '2010-08-30'"
        ],
        "rule_sql": [
            "SELECT t2.potential \nFROM Player AS t1 \nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id \nWHERE t1.player_name = 'Francesco Parravicini' \nAND SUBSTR(t2.date, 1, 10) = '2010-08-30'"
        ],
        "amend_res": 1
    },
    "945": {
        "db_id": "formula_1",
        "question": "How many circuits are there in Adelaide, Australia?",
        "ground_truth": "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'",
        "amends": [
            "Do count `circuitId` instead of `*` to exclude null values from the count. Do filter on `location` instead of `city` to use the correct column name that contains the Adelaide location data. The amended query now correctly counts non-null circuit IDs from circuits located in Adelaide, Australia, matching the intended behavior."
        ],
        "rules": [
            "1) When counting circuits: count non-null values of \"circuitId\" instead of counting all rows to exclude null values from the count. 2) When filtering for circuits in Adelaide, Australia: use the \"location\" column instead of \"city\" to match the correct column name that contains Adelaide location data. 3) When the question asks about circuits in a specific location: filter using exact string literals 'Adelaide' and 'Australia' with the correct case and spacing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM circuits WHERE city = 'Adelaide' AND country = 'Australia';",
            "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';"
        ],
        "rule_sql": [
            "SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';"
        ],
        "amend_res": 1
    },
    "1229": {
        "db_id": "thrombosis_prediction",
        "question": "For all patients with triglyceride (TG) level beyond the normal range, how many are age more than 50 years?",
        "ground_truth": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200 AND STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50",
        "amends": [
            "Do `COUNT(DISTINCT T1.ID)` instead of `COUNT(*)` to count unique patient IDs rather than all rows. Do add `INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID` instead of querying only the patients table to incorporate laboratory data. Do change the table reference from `patients` to `Patient AS T1` for proper table aliasing. Do change the TG filter to `T2.TG >= 200` instead of `TG > 150` to use the laboratory value with a higher threshold and proper table qualification. Do change the age calculation to `STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50` instead of `age > 50` to compute age from birthday rather than relying on a direct age column. The amended query now correctly counts distinct patients with high triglyceride levels from laboratory data who are over 50 years old based on their birthdate."
        ],
        "rules": [
            "1) When counting patients: count distinct T1.ID values instead of all rows to get unique patient counts. 2) When combining patient and laboratory data: perform an inner join between Patient AS T1 and Laboratory AS T2 where T1.ID = T2.ID to link patient records with their lab results. 3) When filtering for high triglyceride levels: use T2.TG >= 200 instead of TG > 150 to apply the correct threshold from laboratory data. 4) When calculating patient age: compute age as current year minus birth year from T1.Birthday using STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 50 instead of using a direct age column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE TG > 150 AND age > 50;",
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.TG >= 200 \nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) > 50"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T2.TG >= 200 \nAND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) > 50"
        ],
        "amend_res": 1
    },
    "13": {
        "db_id": "california_schools",
        "question": "Please list the phone numbers of the schools with the top 3 SAT excellence rate.",
        "ground_truth": "SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC LIMIT 3",
        "amends": [
            "Do add `INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds` instead of querying only the `schools` table. Do change the SELECT list to `T1.Phone` instead of `phone` and add table alias `T1` for the schools table. Do replace the ORDER BY clause with `CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC` instead of `sat_score DESC` to calculate the proper ratio of students scoring above 1500. The amended query now correctly joins the schools and satscores tables and calculates the percentage of high-scoring students for proper ranking."
        ],
        "rules": [
            "1) When answering about \"phone numbers of schools with top SAT excellence rate\": make sure the output order: T1.Phone. 2) When combining schools and satscores tables: link rows where T1.CDSCode = T2.cds exactly as shown and keep only matching pairs (inner match). 3) When calculating SAT excellence rate: compute CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr instead of using sat_score. 4) When the question mentions \"top 3\": rank rows by the excellence rate in descending order and keep the first 3 rows. 5) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms for T1.Phone, T1.CDSCode, and T2.cds."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT phone FROM schools ORDER BY sat_score DESC LIMIT 3;",
            "SELECT T1.Phone\nFROM schools AS T1\nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds\nORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC\nLIMIT 3;"
        ],
        "rule_sql": [
            "SELECT T1.Phone\nFROM schools T1\nINNER JOIN satscores T2 ON T1.CDSCode = T2.cds\nORDER BY CAST(T2.NumGE1500 AS REAL) / T2.NumTstTakr DESC\nLIMIT 3"
        ],
        "amend_res": 1
    },
    "1147": {
        "db_id": "european_football_2",
        "question": "Please name one player whose overall strength is the greatest.",
        "ground_truth": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = ( SELECT MAX(overall_rating) FROM Player_Attributes)",
        "amends": [
            "Do select `t1.player_name` with `DISTINCT` instead of `name` without distinct. Do add `FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id` instead of just `FROM players`. Do add `WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)` instead of `ORDER BY overall_strength ASC`. Do remove `LIMIT 1` instead of keeping it. The amended query now correctly finds players with the maximum overall rating instead of just the first player by strength."
        ],
        "rules": [
            "1) When answering about \"player whose overall strength is the greatest\": make sure the output order: t1.player_name. 2) When the question mentions \"name\": \"name\" actually means \"t1.player_name\" in schema. 3) When combining T1 (Player) and T2 (Player_Attributes) for shared entities: link rows where t1.player_api_id = t2.player_api_id; keep only matching pairs (inner match). 4) When the question asks for \"greatest overall strength\": find players where t2.overall_rating equals the maximum overall_rating value from Player_Attributes. 5) When selecting player names: use DISTINCT to ensure each player appears only once in results."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM players ORDER BY overall_strength ASC LIMIT 1;",
            "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\nORDER BY t1.player_name\nLIMIT 1;"
        ],
        "amend_res": 1
    },
    "206": {
        "db_id": "toxicology",
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
        "amends": [
            "Do select `T1.element` instead of `*` and add `DISTINCT` instead of omitting it. Do use `atom AS T1` and `connected AS T2` as sources instead of just `atoms`, and do `INNER JOIN` on `T1.atom_id = T2.atom_id` instead of querying a single table. Do move the filter to `T2.bond_id = 'TR004_8_9'` instead of applying it directly to the main table. The amended query now correctly retrieves distinct elements from joined tables matching the specified bond_id."
        ],
        "rules": [
            "1) When answering about elements in bond atoms: make sure the output order: T1.element\n2) When the question asks for distinct elements: compute the number of unique values of the exact token T1.element\n3) When combining T1 (atom) and T2 (connected) for shared entities: link rows where T1.atom_id = T2.atom_id exactly as shown; keep only matching pairs (inner match)\n4) When filtering for bond_id 'TR004_8_9': apply the condition T2.bond_id = 'TR004_8_9' exactly with the literal 'TR004_8_9'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM atoms WHERE bond_id = 'TR004_8_9';",
            "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element\nFROM atom T1\nINNER JOIN connected T2 ON T1.atom_id = T2.atom_id\nWHERE T2.bond_id = 'TR004_8_9'\nORDER BY T1.element"
        ],
        "amend_res": 1
    },
    "488": {
        "db_id": "card_games",
        "question": "What's the code for the set which was released on 2017/7/14?",
        "ground_truth": "SELECT code FROM sets WHERE releaseDate = '2017-07-14' GROUP BY releaseDate, code",
        "amends": [
            "Do reference column `releaseDate` instead of `release_date` in the WHERE filter. Do add a GROUP BY clause with `releaseDate, code` instead of omitting it entirely. The amended query now correctly groups by both the release date and code columns to match the intended behavior.",
            "Do use the ISO date format `'2017-07-14'` instead of the non-standard `'2017/7/14'` in the WHERE clause to ensure proper date comparison and avoid potential parsing errors. The amended query now correctly filters for the specified date while maintaining the same GROUP BY structure with `releaseDate` and `code`, ensuring the result set matches the intended behavior."
        ],
        "rules": [
            "1) When the question mentions \"released on 2017/7/14\": use the exact date literal '2017-07-14' for comparison. 2) When filtering by release date in the sets table: use the column name \"releaseDate\" exactly as shown in the schema, not \"release_date\". 3) When selecting the code for a specific release date: include both \"releaseDate\" and \"code\" in the grouping to ensure correct behavior.",
            "1) When the question asks for a specific date like \"2017/7/14\": use the ISO date format '2017-07-14' instead of the non-standard format to ensure proper date comparison and avoid parsing errors. 2) When filtering by releaseDate in the sets table: use the exact column name \"releaseDate\" with the ISO formatted date literal '2017-07-14' for accurate date matching. 3) When selecting the code from sets table: use the exact column name \"code\" to return the set codes that match the specified release date."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT code FROM sets WHERE release_date = '2017-07-14';",
            "SELECT code FROM sets WHERE releaseDate = '2017/7/14' GROUP BY releaseDate, code;",
            "SELECT code FROM sets WHERE releaseDate = '2017-07-14' GROUP BY releaseDate, code;"
        ],
        "rule_sql": [
            "SELECT code FROM sets WHERE releaseDate = '2017-07-14';"
        ],
        "amend_res": 1
    },
    "430": {
        "db_id": "card_games",
        "question": "Please list top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block in alphabetical order.",
        "evidence": "",
        "ground_truth": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian' ORDER BY T1.id LIMIT 2",
        "amends": [
            "Do select `T1.name` and `T1.id` instead of `id` and `name`. Do join `sets AS T1` with `set_translations AS T2` on `T1.code = T2.setCode` instead of querying only `cards`. Do filter with `T1.block = 'Shadowmoor'` and `T2.language = 'Italian'` instead of `language = 'Italian'` and `block = 'Shadowmoor'`. Do order by `T1.id` instead of `name ASC`. The amended query now correctly retrieves Italian-translated Shadowmoor sets by joining the appropriate tables and filtering on the correct language and block fields."
        ],
        "rules": [
            "1) When answering about \"top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block\": make sure the output order: T1.name, T1.id 2) When the question mentions \"Italian-language cards\": \"Italian\" actually means T2.language = 'Italian' in schema 3) When the question mentions \"located in the Shadowmoor block\": \"Shadowmoor\" actually means T1.block = 'Shadowmoor' in schema 4) When combining sets AS T1 and set_translations AS T2 for shared entities: link rows where T1.code = T2.setCode exactly as shown in the amends; keep only matching pairs (inner match) 5) When the question asks for \"top two sets\": rank rows by T1.id in alphabetical order and keep the first 2 rows 6) When choosing identifier delimiters: do not replace double quotes with backticks or unquoted forms 7) When handling text literals: do not change case, spacing, or punctuation of 'Italian' or 'Shadowmoor'"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT id, name FROM cards WHERE language = 'Italian' AND block = 'Shadowmoor' ORDER BY name ASC LIMIT 2;",
            "SELECT T1.name, T1.id\nFROM sets AS T1\nJOIN set_translations AS T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian'\nORDER BY T1.id\nLIMIT 2"
        ],
        "rule_sql": [
            "SELECT T1.name, T1.id\nFROM sets AS T1\nINNER JOIN set_translations AS T2 ON T1.code = T2.setCode\nWHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian'\nORDER BY T1.name ASC\nLIMIT 2"
        ],
        "amend_res": 1
    },
    "998": {
        "db_id": "formula_1",
        "question": "In terms of number of points acquired, how many victories did the driver who ranked 91st acquired?",
        "ground_truth": "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) FROM driverStandings",
        "amends": [
            "Do use `SUM(CASE WHEN points = 91 THEN wins ELSE 0 END)` instead of `COUNT(*)` to calculate the sum of wins for drivers with 91 points rather than counting race results. Do query from `driverStandings` instead of `races` to access driver statistics rather than individual race results. Do remove the `WHERE position = 1 AND driver_id = (SELECT driver_id FROM driver_standings WHERE rank = 91)` filter instead of keeping it, as the logic now aggregates wins based on points rather than filtering for specific race positions and driver rankings. The amended query correctly calculates the total wins for drivers who have 91 points, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks about \"number of points acquired\" and \"victories\" for a specific rank: use the exact column \"points\" to identify drivers and \"wins\" to count victories. 2) When the question mentions \"ranked 91st\": this refers to drivers with exactly 91 points in the \"points\" column, not the \"rank\" column. 3) When calculating victories for drivers with specific points: sum the \"wins\" values using SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) instead of counting race results. 4) When accessing driver statistics: query from the \"driverStandings\" table to get driver-level statistics rather than individual race results. 5) When filtering for specific points values: use the exact literal value 91 without quotes for numeric comparison in the points column."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM races WHERE position = 1 AND driver_id = (SELECT driver_id FROM driver_standings WHERE rank = 91);",
            "SELECT SUM(CASE WHEN points = 91 THEN wins ELSE 0 END) AS total_wins FROM driverStandings"
        ],
        "rule_sql": [
            "SELECT SUM(wins) AS total_victories \nFROM driverStandings \nWHERE points = 91;"
        ],
        "amend_res": 1
    },
    "485": {
        "db_id": "card_games",
        "question": "When was the ruling for the card 'Reminisce' created?",
        "ground_truth": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
        "amends": [
            "Do select `T2.date` from the `rulings` table instead of `created_date` from the `rulings` table alone. Do join `cards AS T1` with `rulings AS T2` using an `INNER JOIN` on `T2.uuid = T1.uuid` instead of querying only the `rulings` table without any join. Do filter on `T1.name = 'Reminisce'` instead of filtering directly on `card_name = 'Reminisce'` in the `rulings` table. The amended query now correctly retrieves ruling dates by joining through the cards table using UUID matching instead of relying on potentially inconsistent card name matching in the rulings table."
        ],
        "rules": [
            "1) When answering about \"When was the ruling for the card 'Reminisce' created\": make sure the output order: T2.date\n2) When the question mentions \"card 'Reminisce'\": \"card 'Reminisce'\" actually means \"T1.name = 'Reminisce'\" in schema\n3) When combining T1 and T2 for shared entities: link rows where T2.uuid = T1.uuid exactly as shown in the amends; keep only matching pairs (inner match)\n4) When the question asks for ruling date: use T2.date from the rulings table instead of created_date"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT created_date FROM rulings WHERE card_name = 'Reminisce';",
            "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'"
        ],
        "rule_sql": [
            "SELECT T2.date\nFROM cards T1\nINNER JOIN rulings T2 ON T2.uuid = T1.uuid\nWHERE T1.name = 'Reminisce'\nORDER BY T2.date"
        ],
        "amend_res": 1
    },
    "123": {
        "db_id": "financial",
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "ground_truth": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
        "amends": [
            "Do select `T1.account_id`, `T2.A2`, and `T2.A3` instead of `account_id`, `district`, and `region`. Do join `account AS T1` and `district AS T2` with `INNER JOIN` on `T1.district_id = T2.district_id` instead of missing these table sources entirely. Do add `INNER JOIN loan AS T3` on `T1.account_id = T3.account_id` instead of omitting the loan table join. Do apply the amount filter on `T3.amount > 300000` instead of filtering an unspecified amount column. The amended query now correctly joins the necessary tables and references the proper columns to match the intended behavior."
        ],
        "rules": [
            "1) When answering about \"account ID, district and region for loan amount greater than USD300,000\": make sure the output order: T1.account_id, T2.A2, T2.A3\n2) When combining account and district tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)\n3) When combining account and loan tables: link rows where T1.account_id = T3.account_id and keep only matching pairs (inner match)\n4) When filtering for loan amount greater than USD300,000: apply the condition T3.amount > 300000\n5) When the question mentions \"district\": \"district\" actually means \"T2.A2 in schema\"\n6) When the question mentions \"region\": \"region\" actually means \"T2.A3 in schema\""
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT account_id, district, region FROM loans WHERE amount > 300000",
            "SELECT T1.account_id, T2.A2, T2.A3\nFROM account AS T1\nINNER JOIN district AS T2 ON T1.district_id = T2.district_id\nINNER JOIN loan AS T3 ON T1.account_id = T3.account_id\nWHERE T3.amount > 300000"
        ],
        "rule_sql": [
            "SELECT T1.account_id, T2.A2, T2.A3\nFROM account T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nINNER JOIN loan T3 ON T1.account_id = T3.account_id\nWHERE T3.amount > 300000"
        ],
        "amend_res": 1
    },
    "34": {
        "db_id": "california_schools",
        "question": "What is the free rate for students between the ages of 5 and 17 at the school run by Kacey Gibson?",
        "ground_truth": "SELECT CAST(T2.`Free Meal Count (Ages 5-17)` AS REAL) / T2.`Enrollment (Ages 5-17)` FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'",
        "amends": [
            "Do select `CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\"` instead of `free_rate` to calculate the free meal rate from joined tables. Do add `INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode` instead of querying only the schools table to properly join with the frpm data. Do change the WHERE condition to `T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'` instead of `principal = 'Kacey Gibson'` to match the correct column structure for first and last name separation. Do remove the `age BETWEEN 5 AND 17` filter instead of keeping it since the age range is now handled through the joined frpm table columns specifically for ages 5-17. The amended query now correctly calculates the free meal rate by joining the necessary tables and using the proper administrator name filtering to match RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating free rate for students between ages 5-17: compute CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\" instead of using a free_rate column. 2) When querying about schools run by Kacey Gibson: filter using T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson' instead of principal = 'Kacey Gibson' to match the separated first and last name columns. 3) When combining schools and frpm data: link rows using T1.CDSCode = T2.CDSCode and keep only matching pairs (inner join). 4) When handling age range 5-17: use the specific frpm table columns \"Free Meal Count (Ages 5-17)\" and \"Enrollment (Ages 5-17)\" instead of filtering by age range in the WHERE clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT free_rate FROM schools WHERE principal = 'Kacey Gibson' AND age BETWEEN 5 AND 17",
            "SELECT CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\" AS free_rate\nFROM schools AS T1\nINNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'"
        ],
        "rule_sql": [
            "SELECT CAST(T2.\"Free Meal Count (Ages 5-17)\" AS REAL) / T2.\"Enrollment (Ages 5-17)\" AS free_rate\nFROM schools T1\nINNER JOIN frpm T2 ON T1.CDSCode = T2.CDSCode\nWHERE T1.AdmFName1 = 'Kacey' AND T1.AdmLName1 = 'Gibson'"
        ],
        "amend_res": 1
    },
    "1484": {
        "db_id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "ground_truth": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "amends": [
            "Do use `SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0))` instead of separate subqueries with `COUNT(*)` and country name comparisons. Do reference `Country` column values 'CZE' and 'SVK' instead of full country names 'Czech Republic' and 'Slovakia'. Do filter with `WHERE Segment = 'Discount'` instead of `WHERE type = 'discount'`. Do query from table `gasstations` instead of `gas_stations`. The amended query now correctly calculates the difference between discount gas stations in Czech Republic and Slovakia using proper country codes and a single table scan."
        ],
        "rules": [
            "1) When the question mentions \"Czech Republic\": use the exact country code 'CZE' instead of the full name 'Czech Republic' for the Country column. 2) When the question mentions \"Slovakia\": use the exact country code 'SVK' instead of the full name 'Slovakia' for the Country column. 3) When the question mentions \"discount\" gas stations: use the exact segment value 'Discount' (with capital D) for the Segment column instead of 'discount'. 4) When calculating the difference between counts for two countries: compute SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) in a single table scan rather than using separate subqueries. 5) When querying gas station data: use the exact table name \"gasstations\" instead of \"gas_stations\"."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM gas_stations WHERE country = 'Czech Republic' AND type = 'discount') - \n    (SELECT COUNT(*) FROM gas_stations WHERE country = 'Slovakia' AND type = 'discount') \nAS difference;",
            "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) AS difference\nFROM gasstations\nWHERE Segment = 'Discount';"
        ],
        "rule_sql": [
            "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) AS difference\nFROM gasstations\nWHERE Segment = 'Discount';"
        ],
        "amend_res": 1
    },
    "18": {
        "db_id": "california_schools",
        "question": "How many schools in Fresno (directly funded) have number of test takers not more than 250?",
        "evidence": "",
        "ground_truth": "SELECT COUNT(T1.CDSCode) FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.`Charter Funding Type` = 'Directly funded' AND T1.`County Name` = 'Fresno' AND T2.NumTstTakr <= 250",
        "amends": [
            "Do use `COUNT(T1.CDSCode)` instead of `COUNT(*)` to count specific non-null values. Do join `frpm AS T1` and `satscores AS T2` with `INNER JOIN` on `T1.CDSCode = T2.cds` instead of querying a single `schools` table. Do filter on `T1.Charter Funding Type = 'Directly funded'` instead of `funding_type = 'direct'` for the correct column name and value. Do filter on `T1.County Name = 'Fresno'` instead of `city = 'Fresno'` to use the proper geographic attribute. Do filter on `T2.NumTstTakr <= 250` instead of `test_takers > 250` to correctly identify schools with 250 or fewer test takers rather than more than 250. The amended query now correctly joins the frpm and satscores tables with proper join conditions and filters to match the intended logic."
        ],
        "rules": [
            "1) When counting schools: use COUNT(T1.CDSCode) instead of COUNT(*) to count specific non-null values. 2) When combining school data from multiple tables: join frpm AS T1 and satscores AS T2 with INNER JOIN on T1.CDSCode = T2.cds instead of querying a single schools table. 3) When filtering by funding type: use T1.Charter Funding Type = 'Directly funded' instead of funding_type = 'direct' for the correct column name and value. 4) When filtering by geographic location: use T1.County Name = 'Fresno' instead of city = 'Fresno' to use the proper geographic attribute. 5) When filtering by number of test takers: use T2.NumTstTakr <= 250 instead of test_takers > 250 to correctly identify schools with 250 or fewer test takers rather than more than 250."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM schools WHERE city = 'Fresno' AND funding_type = 'direct' AND test_takers > 250;",
            "SELECT COUNT(T1.CDSCode) \nFROM frpm AS T1 \nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds \nWHERE T1.\"Charter Funding Type\" = 'Directly funded' \nAND T1.\"County Name\" = 'Fresno' \nAND T2.NumTstTakr <= 250"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.CDSCode) \nFROM frpm AS T1 \nINNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds \nWHERE T1.\"Charter Funding Type\" = 'Directly funded' \nAND T1.\"County Name\" = 'Fresno' \nAND T2.NumTstTakr <= 250"
        ],
        "amend_res": 1
    },
    "79": {
        "db_id": "california_schools",
        "question": "Between San Diego and Santa Barbara, which county offers the most number of schools that does not offer physical building? Indicate the amount.",
        "ground_truth": "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1",
        "amends": [
            "Do use `County` instead of `county` for the column name and `COUNT(Virtual)` instead of `COUNT(*)` for the aggregate function. Do change the WHERE clause to use `(County = 'San Diego' OR County = 'Santa Barbara')` instead of `county IN ('San Diego', 'Santa Barbara')` and `Virtual = 'F'` instead of `physical_building = 'no'` for the filter condition. Do remove the alias `as school_count` instead of keeping it and change the ORDER BY to use `COUNT(Virtual)` instead of `school_count`. The amended query now correctly counts virtual schools with 'F' status in the specified counties and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about counties \"San Diego\" and \"Santa Barbara\": use exact literal values 'San Diego' and 'Santa Barbara' with the column \"County\". 2) When identifying schools without physical buildings: use the condition \"Virtual\" = 'F' instead of physical_building = 'no'. 3) When counting schools: use COUNT(\"Virtual\") instead of COUNT(*) to count only virtual schools. 4) When grouping results by county: use the column \"County\" for grouping. 5) When ordering results by count: order by COUNT(\"Virtual\") in descending order to find the highest count. 6) When selecting output columns: include \"County\" and the count without aliases. 7) When combining conditions for multiple counties: use (\"County\" = 'San Diego' OR \"County\" = 'Santa Barbara') instead of IN clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT county, COUNT(*) as school_count \nFROM schools \nWHERE county IN ('San Diego', 'Santa Barbara') \nAND physical_building = 'no' \nGROUP BY county \nORDER BY school_count DESC \nLIMIT 1;",
            "SELECT County, COUNT(Virtual) FROM schools WHERE (County = 'San Diego' OR County = 'Santa Barbara') AND Virtual = 'F' GROUP BY County ORDER BY COUNT(Virtual) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT County, COUNT(\"Virtual\") \nFROM schools \nWHERE (\"County\" = 'San Diego' OR \"County\" = 'Santa Barbara') \nAND \"Virtual\" = 'F' \nGROUP BY County \nORDER BY COUNT(\"Virtual\") DESC \nLIMIT 1"
        ],
        "amend_res": 1
    },
    "1394": {
        "db_id": "student_club",
        "question": "How many members of the Student_Club have major in 'Physics Teaching'?",
        "ground_truth": "SELECT COUNT(T2.member_id) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T1.major_name = 'Physics Teaching'",
        "amends": [
            "Do select `COUNT(T2.member_id)` from the `member` table instead of `COUNT(*)` from a non-existent `Student_Club` table. Do join `major AS T1` and `member AS T2` with an `INNER JOIN` on `T1.major_id = T2.link_to_major` instead of querying a single incorrect table. Do filter on `T1.major_name = 'Physics Teaching'` instead of filtering on a non-existent `major` column in the wrong table. The amended query now correctly counts members specifically for the Physics Teaching major by properly joining the major and member tables through their relationship, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When the question asks about \"members of the Student_Club\": the correct table to query is \"member\" (aliased as T2) instead of a non-existent \"Student_Club\" table. 2) When counting members: use COUNT(T2.member_id) as the counting key instead of COUNT(*). 3) When the question mentions \"major in 'Physics Teaching'\": this refers to T1.major_name = 'Physics Teaching' where T1 represents the \"major\" table. 4) When combining major and member tables: link rows where T1.major_id = T2.link_to_major using an inner join to keep only matching pairs. 5) When filtering for specific majors: apply the exact literal filter T1.major_name = 'Physics Teaching' with the exact case and spacing."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM Student_Club WHERE major = 'Physics Teaching';",
            "SELECT COUNT(T2.member_id) \nFROM member AS T2\nINNER JOIN major AS T1 ON T1.major_id = T2.link_to_major\nWHERE T1.major_name = 'Physics Teaching'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.member_id) \nFROM member T2\nINNER JOIN major T1 ON T1.major_id = T2.link_to_major\nWHERE T1.major_name = 'Physics Teaching'"
        ],
        "amend_res": 1
    },
    "1440": {
        "db_id": "student_club",
        "question": "List emails of people who paid more than 20 dollars from 9/10/2019 to 11/19/2019.",
        "ground_truth": "SELECT DISTINCT T1.email FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19' AND T2.cost > 20",
        "amends": [
            "Do select `DISTINCT T1.email` from the `member` table instead of `email` from the `payments` table. Do join `member AS T1` with `expense AS T2` using `INNER JOIN` on `T1.member_id = T2.link_to_member` instead of querying only the `payments` table. Do filter on `T2.cost > 20` instead of `amount > 20`. Do use `date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19'` for date filtering instead of `payment_date BETWEEN` the same range. The amended query now correctly retrieves distinct member emails with expense criteria from the proper tables."
        ],
        "rules": [
            "1) When the question asks for emails of people: select distinct \"email\" from the \"member\" table (as T1) instead of from \"payments\". 2) When combining member and expense information: join \"member\" AS T1 with \"expense\" AS T2 using inner join where T1.\"member_id\" = T2.\"link_to_member\". 3) When filtering for payments over 20 dollars: use T2.\"cost\" > 20 instead of \"amount\" > 20. 4) When filtering for dates from 9/10/2019 to 11/19/2019: use date(SUBSTR(T2.\"expense_date\", 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19' instead of \"payment_date\" BETWEEN the same range."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT email FROM payments WHERE amount > 20 AND payment_date BETWEEN '2019-09-10' AND '2019-11-19';",
            "SELECT DISTINCT T1.email \nFROM member AS T1\nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member\nWHERE T2.cost > 20 \nAND date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.email \nFROM member AS T1\nINNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member\nWHERE T2.cost > 20 \nAND date(SUBSTR(T2.expense_date, 1, 10)) BETWEEN '2019-09-10' AND '2019-11-19'"
        ],
        "amend_res": 1
    },
    "140": {
        "db_id": "financial",
        "question": "How many accounts are there in the district of \"Pisek\"?",
        "ground_truth": "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Pisek'",
        "amends": [
            "Do select `COUNT(T1.account_id)` instead of `COUNT(*)` to count specific non-null values. Do join `account AS T1` with `district AS T2` using `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying only the `accounts` table. Do filter on `T2.A2 = 'Pisek'` instead of `district = 'Pisek'` to correctly reference the district name column from the joined table. The amended query now properly correlates accounts with their corresponding district names and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting accounts: use COUNT(T1.account_id) instead of COUNT(*) to count specific non-null values. 2) When answering about accounts in a specific district: join account AS T1 with district AS T2 using INNER JOIN on T1.district_id = T2.district_id to properly correlate accounts with their districts. 3) When filtering by district name \"Pisek\": use T2.A2 = 'Pisek' instead of district = 'Pisek' to correctly reference the district name column from the joined table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM accounts WHERE district = 'Pisek';",
            "SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Pisek'"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.account_id) \nFROM account AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T2.A2 = 'Pisek'"
        ],
        "amend_res": 1
    },
    "1203": {
        "db_id": "thrombosis_prediction",
        "question": "How many patients who were female got white blood cells that were below 3.5?",
        "ground_truth": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC < 3.5 AND T1.SEX = 'F'",
        "amends": [
            "Do select `COUNT(T1.ID)` instead of `COUNT(*)` to count specific patient IDs. Do use `Patient AS T1` and `Laboratory AS T2` tables instead of only the `patients` table, adding an `INNER JOIN` on `T1.ID = T2.ID` instead of querying a single table. Do filter on `T2.WBC < 3.5` instead of `white_blood_cells < 3.5` to reference the correct laboratory table column. Do filter on `T1.SEX = 'F'` instead of `gender = 'male'` to select female patients rather than male patients. The amended query now correctly joins patient and laboratory data to count female patients with low white blood cell values, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting patients: use COUNT(T1.ID) instead of COUNT(*) to count specific patient IDs. 2) When combining patient and laboratory data: link rows using T1.ID = T2.ID with an inner join between Patient AS T1 and Laboratory AS T2 tables. 3) When filtering for white blood cell values below 3.5: use T2.WBC < 3.5 instead of white_blood_cells < 3.5 to reference the correct laboratory table column. 4) When selecting female patients: use T1.SEX = 'F' instead of gender = 'male' to filter for female patients rather than male patients."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM patients WHERE gender = 'male' AND white_blood_cells < 3.5",
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'F' AND T2.WBC < 3.5"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.ID) \nFROM Patient AS T1 \nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID \nWHERE T1.SEX = 'F' AND T2.WBC < 3.5"
        ],
        "amend_res": 1
    },
    "281": {
        "db_id": "toxicology",
        "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
        "ground_truth": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
        "amends": [
            "Do use `DISTINCT T1.element` in the SELECT list instead of `molecule_id, element` without distinct. Do join `atom AS T1` and `molecule AS T2` with `INNER JOIN` on `T1.molecule_id = T2.molecule_id` instead of querying only the `toxicology` table. Do add filter `T2.label = '+'` instead of omitting molecule label conditions. Do use `SUBSTR(T1.atom_id, -1) = '4'` for atom position filtering instead of `atom_position = 4`. Do add `LENGTH(T1.atom_id) = 7` constraint instead of omitting atom_id length validation. Do remove `carcinogenic = 'yes'` filter instead of keeping it. The amended query now correctly identifies distinct elements from properly joined atom and molecule tables with accurate position and length constraints."
        ],
        "rules": [
            "1) When answering about toxicology elements of the 4th atom: use DISTINCT T1.element in the output instead of molecule_id and element without distinct. 2) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id using an inner match. 3) When filtering for carcinogenic molecules: use T2.label = '+' instead of carcinogenic = 'yes'. 4) When identifying the 4th atom position: use SUBSTR(T1.atom_id, -1) = '4' instead of atom_position = 4. 5) When validating atom_id format: add constraint LENGTH(T1.atom_id) = 7. 6) When the question asks for distinct elements: compute unique values of T1.element."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id, element FROM toxicology WHERE atom_position = 4 AND carcinogenic = 'yes';",
            "SELECT DISTINCT T1.element \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.label = '+' \nAND SUBSTR(T1.atom_id, -1) = '4' \nAND LENGTH(T1.atom_id) = 7"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.element \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.label = '+' \nAND LENGTH(T1.atom_id) = 7 \nAND SUBSTR(T1.atom_id, -1) = '4'"
        ],
        "amend_res": 1
    },
    "1387": {
        "db_id": "student_club",
        "question": "Which student has been entrusted to manage the budget for the Yearly Kickoff?",
        "ground_truth": "SELECT T4.first_name, T4.last_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget INNER JOIN member AS T4 ON T3.link_to_member = T4.member_id WHERE T1.event_name = 'Yearly Kickoff'",
        "amends": [
            "Do select `T4.first_name` and `T4.last_name` instead of `student_name`. Do use a multi-table join structure with `event`, `budget`, `expense`, and `member` tables instead of a single `students` table. Do perform `INNER JOIN` operations with specific join conditions: `T1.event_id = T2.link_to_event`, `T2.budget_id = T3.link_to_budget`, and `T3.link_to_member = T4.member_id` instead of no joins. Do filter on `T1.event_name = 'Yearly Kickoff'` instead of `budget_role = 'Yearly Kickoff Manager'`. The amended query now correctly retrieves member names associated with the Yearly Kickoff event through the proper table relationships."
        ],
        "rules": [
            "1) When answering about \"which student has been entrusted to manage the budget for the Yearly Kickoff\": make sure the output order: T4.first_name, T4.last_name. 2) When the question mentions \"student\": \"student\" actually means \"member in schema\" and requires joining through event, budget, and expense tables. 3) When combining T1 (event), T2 (budget), T3 (expense), and T4 (member) tables: link rows where T1.event_id = T2.link_to_event, T2.budget_id = T3.link_to_budget, and T3.link_to_member = T4.member_id; keep only matching pairs (inner match). 4) When filtering for the Yearly Kickoff event: use T1.event_name = 'Yearly Kickoff' exactly as specified."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT student_name FROM students WHERE budget_role = 'Yearly Kickoff Manager';",
            "SELECT T4.first_name, T4.last_name\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nINNER JOIN member T4 ON T3.link_to_member = T4.member_id\nWHERE T1.event_name = 'Yearly Kickoff'"
        ],
        "rule_sql": [
            "SELECT T4.first_name, T4.last_name\nFROM event T1\nINNER JOIN budget T2 ON T1.event_id = T2.link_to_event\nINNER JOIN expense T3 ON T2.budget_id = T3.link_to_budget\nINNER JOIN member T4 ON T3.link_to_member = T4.member_id\nWHERE T1.event_name = 'Yearly Kickoff'"
        ],
        "amend_res": 1
    },
    "801": {
        "db_id": "superhero",
        "question": "Find the ratio between male superheroes and female superheroes.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
        "amends": [
            "Do use a single query with `INNER JOIN` between `superhero` and `gender` tables instead of separate subqueries on a single table. Do calculate counts using `COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END)` and `COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END)` instead of separate `COUNT(*)` subqueries. Do cast the numerator to `REAL` instead of performing integer division. Do reference the proper table structure with `T1.gender_id = T2.id` join condition instead of assuming gender is a direct column in the superhero table. The amended query now correctly handles the schema relationships and prevents division by zero while producing accurate ratio calculations."
        ],
        "rules": [
            "1) When the question asks for a ratio between male superheroes and female superheroes: use a single query with an inner join between \"superhero\" table as T1 and \"gender\" table as T2 instead of separate subqueries. 2) When combining T1 and T2 for shared entities: link rows where T1.gender_id = T2.id exactly as shown in the amends and keep only matching pairs (inner match). 3) When counting male superheroes: compute COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) using the exact tokens and literals. 4) When counting female superheroes: compute COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) using the exact tokens and literals. 5) When calculating the ratio: cast the male count to REAL before division to prevent integer division. 6) When handling division: guard against division by zero by ensuring the denominator (female count) is not zero."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SELECT COUNT(*) FROM superheroes WHERE gender = 'Male') / \n    (SELECT COUNT(*) FROM superheroes WHERE gender = 'Female') AS male_to_female_ratio;",
            "SELECT \n    CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / \n    COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) AS male_to_female_ratio\nFROM superhero T1\nINNER JOIN gender T2 ON T1.gender_id = T2.id\nWHERE T2.gender IN ('Male', 'Female');"
        ],
        "rule_sql": [
            "SELECT \n    CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / \n    NULLIF(COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END), 0) AS male_to_female_ratio\nFROM \n    superhero T1\nINNER JOIN \n    gender T2 ON T1.gender_id = T2.id;"
        ],
        "amend_res": 1
    },
    "462": {
        "db_id": "card_games",
        "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
        "ground_truth": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
        "amends": [
            "Do query the `set_translations` table instead of the `sets` table. Do select `translation` instead of `name`. Do use a subquery to get `setCode` values from the `cards` table where `name = 'Ancestor''s Chosen'` instead of directly filtering with `cards LIKE '%Ancestor\\'s Chosen%'`. Do filter by `language = 'Italian'` in the outer query instead of the inner query. The amended query now correctly retrieves Italian translations for sets containing the specified card by using proper table relationships instead of a fragile text pattern match."
        ],
        "rules": [
            "1) When the question asks for Italian translations of sets containing a specific card: use the set_translations table instead of the sets table. 2) When selecting the Italian name: select the translation column instead of the name column. 3) When filtering for sets containing \"Ancestor's Chosen\": use a subquery to get setCode values from the cards table where name = 'Ancestor''s Chosen' instead of using a LIKE pattern match. 4) When filtering by language: apply language = 'Italian' in the outer query on set_translations instead of in a subquery. 5) When combining set_translations with cards data: link through setCode values obtained from the cards table subquery."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT name FROM sets WHERE language = 'Italian' AND cards LIKE '%Ancestor\\'s Chosen%';",
            "SELECT translation \nFROM set_translations \nWHERE setCode IN (\n    SELECT setCode \n    FROM cards \n    WHERE name = 'Ancestor''s Chosen'\n) \nAND language = 'Italian';"
        ],
        "rule_sql": [
            "SELECT st.translation\nFROM set_translations st\nWHERE st.language = 'Italian'\nAND st.setCode IN (\n    SELECT c.setCode\n    FROM cards c\n    WHERE c.name = 'Ancestor''s Chosen'\n)"
        ],
        "amend_res": 1
    },
    "1159": {
        "db_id": "thrombosis_prediction",
        "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
        "ground_truth": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
        "amends": [
            "Do use `DISTINCT` instead of omitting it, and select `ID`, `SEX`, and `Diagnosis` instead of `patient_id`, `sex`, and `diagnosis`. Do join `Patient AS T1` with `Laboratory AS T2` using `INNER JOIN` on `T1.ID = T2.ID` instead of querying only the `patients` table. Do filter on `T2.ALB < 3.5` instead of `albumin > 3.5`, and reference the laboratory table's albumin value rather than a presumed column in the patient table. The amended query now correctly identifies patients with low albumin levels by joining with laboratory results and matches the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about patients with albumin level lower than 3.5: use DISTINCT to ensure unique patient records. 2) When selecting patient information: output columns must be \"ID\", \"SEX\", and \"Diagnosis\" exactly as specified in the schema. 3) When combining patient and laboratory data: perform an inner join between \"Patient AS T1\" and \"Laboratory AS T2\" where \"T1.ID = T2.ID\" to match patients with their lab results. 4) When filtering for low albumin levels: use condition \"T2.ALB < 3.5\" to identify patients with albumin values below 3.5. 5) When referencing albumin values: use the \"ALB\" column from the \"Laboratory\" table (T2) rather than any presumed column in the patient table."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT patient_id, sex, diagnosis FROM patients WHERE albumin > 3.5",
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.ALB < 3.5"
        ],
        "rule_sql": [
            "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis\nFROM Patient AS T1\nINNER JOIN Laboratory AS T2 ON T1.ID = T2.ID\nWHERE T2.ALB < 3.5"
        ],
        "amend_res": 1
    },
    "93": {
        "db_id": "financial",
        "question": "How many male customers who are living in North Bohemia have average salary greater than 8000?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000",
        "amends": [
            "Do use `COUNT(T1.client_id)` instead of `COUNT(*)` to count specific non-null values. Do reference `client AS T1` and `district AS T2` tables instead of just `customers`. Do use `INNER JOIN` with `T1.district_id = T2.district_id` instead of querying a single table. Do filter on `T1.gender = 'M'` instead of `gender = 'male'` using the correct gender code. Do filter on `T2.A3 = 'north Bohemia'` instead of `region = 'North Bohemia'` using the district table's region column. Do filter on `T2.A11 > 8000` instead of `salary > 8000` using the district table's salary-related column. The amended query now correctly joins client and district tables to count male clients in North Bohemia with the specified salary threshold, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting customers: use COUNT(T1.client_id) instead of COUNT(*) to count specific non-null values. 2) When the question mentions \"customers\": it refers to the \"client\" table which should be aliased as T1. 3) When the question mentions \"region\" or \"North Bohemia\": it refers to district table column T2.A3 with value 'north Bohemia' (case-sensitive). 4) When the question mentions \"gender\" or \"male\": it refers to client table column T1.gender with value 'M' (not 'male'). 5) When the question mentions \"average salary greater than 8000\": it refers to district table column T2.A11 with condition > 8000. 6) When combining client and district information: use INNER JOIN where T1.district_id = T2.district_id to link the tables. 7) When answering about customer counts: ensure the output is a single count value using the correct counting method."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers \nWHERE gender = 'male' \nAND region = 'North Bohemia' \nAND salary > 8000;",
            "SELECT COUNT(T1.client_id) \nFROM client AS T1 \nINNER JOIN district AS T2 ON T1.district_id = T2.district_id \nWHERE T1.gender = 'M' \nAND T2.A3 = 'north Bohemia' \nAND T2.A11 > 8000"
        ],
        "rule_sql": [
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'M' \nAND T2.A3 = 'north Bohemia' \nAND T2.A11 > 8000"
        ],
        "amend_res": 1
    },
    "728": {
        "db_id": "superhero",
        "question": "Rank superheroes from Marvel Comics by their eye color popularity, starting with the most common color.",
        "ground_truth": "SELECT colour.colour AS EyeColor, COUNT(superhero.id) AS Count, RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour",
        "amends": [
            "Do join `colour` on `superhero.eye_colour_id = colour.id` instead of directly selecting `eye_color` from a single table. Do join `publisher` on `superhero.publisher_id = publisher.id` instead of filtering by publisher name directly. Do filter on `publisher.publisher_name = 'Marvel Comics'` instead of `publisher = 'Marvel Comics'`. Do select `colour.colour AS EyeColor` instead of `eye_color`. Do count `superhero.id` instead of using `COUNT(*)`. Do add `RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank` instead of ordering by popularity ASC. Do group by `colour.colour` instead of `eye_color`. The amended query now correctly joins related tables, uses proper foreign key relationships, and provides a ranked popularity result instead of a simple count ordering."
        ],
        "rules": [
            "1) When answering about superhero eye color popularity from Marvel Comics: join the colour table on superhero.eye_colour_id = colour.id to get the correct eye color values. 2) When filtering for Marvel Comics superheroes: join the publisher table on superhero.publisher_id = publisher.id and filter where publisher.publisher_name = 'Marvel Comics'. 3) When counting superheroes: count superhero.id instead of using COUNT(*) to get the accurate count of superhero entities. 4) When grouping by eye color: group by colour.colour instead of the raw eye_color field. 5) When ranking by popularity: use RANK() OVER (ORDER BY COUNT(superhero.id) DESC) to rank from most common to least common eye color. 6) When selecting eye color information: select colour.colour AS EyeColor to get the proper formatted eye color values."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT eye_color, COUNT(*) as popularity FROM superheroes WHERE publisher = 'Marvel Comics' GROUP BY eye_color ORDER BY popularity ASC;",
            "SELECT \n    colour.colour AS EyeColor,\n    COUNT(superhero.id) AS HeroCount,\n    RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank\nFROM \n    superhero\nJOIN \n    publisher ON superhero.publisher_id = publisher.id\nJOIN \n    colour ON superhero.eye_colour_id = colour.id\nWHERE \n    publisher.publisher_name = 'Marvel Comics'\nGROUP BY \n    colour.colour\nORDER BY \n    COUNT(superhero.id) DESC;"
        ],
        "rule_sql": [
            "SELECT \n    colour.colour AS EyeColor,\n    COUNT(superhero.id) AS SuperheroCount,\n    RANK() OVER (ORDER BY COUNT(superhero.id) DESC) AS PopularityRank\nFROM \n    superhero\nJOIN \n    publisher ON superhero.publisher_id = publisher.id\nJOIN \n    colour ON superhero.eye_colour_id = colour.id\nWHERE \n    publisher.publisher_name = 'Marvel Comics'\nGROUP BY \n    colour.colour\nORDER BY \n    COUNT(superhero.id) DESC;"
        ],
        "amend_res": 1
    },
    "960": {
        "db_id": "formula_1",
        "question": "What is the average of fastest lap speed in the 2009 Spanish Grand Prix race?",
        "ground_truth": "SELECT AVG(T1.fastestLapSpeed) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'",
        "amends": [
            "Do join `results AS T1` with `races AS T2` on `T1.raceId = T2.raceId` instead of querying only the `races` table. Do reference `AVG(T1.fastestLapSpeed)` instead of `AVG(fastest_lap_speed)` to use the correct column from the joined table. Do apply the year and name filters to `T2.year` and `T2.name` instead of directly to the races table without proper joining. The amended query now correctly calculates the average fastest lap speed from the results table for the specified race, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about average fastest lap speed for a specific race: join results AS T1 with races AS T2 on T1.raceId = T2.raceId to combine race information with lap speed data. 2) When the question mentions \"fastest lap speed\": \"fastest lap speed\" actually means T1.fastestLapSpeed in the results table. 3) When filtering for the 2009 Spanish Grand Prix race: apply year filter to T2.year = 2009 and name filter to T2.name = 'Spanish Grand Prix' exactly as specified. 4) When computing the average: calculate AVG(T1.fastestLapSpeed) from the joined results to get the correct average fastest lap speed."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(fastest_lap_speed) FROM races WHERE year = 2009 AND name = 'Spanish Grand Prix';",
            "SELECT AVG(T1.fastestLapSpeed) \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.fastestLapSpeed) \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T2.year = 2009 AND T2.name = 'Spanish Grand Prix'"
        ],
        "amend_res": 1
    },
    "533": {
        "db_id": "codebase_community",
        "question": "How many users last accessed the website after 2014/9/1?",
        "ground_truth": "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01'",
        "amends": [
            "Do use `COUNT(Id)` instead of `COUNT(*)` to count only non-null user IDs. Do reference `LastAccessDate` instead of `last_access_date` to match the correct column name. Do apply `date()` function to `LastAccessDate` instead of comparing the raw timestamp value directly. Do use the ISO date format `'2014-09-01'` instead of `'2014/9/1'` for proper date comparison semantics. The amended query now correctly counts users with non-null IDs who accessed the system after September 1, 2014, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When counting users: use COUNT(Id) instead of COUNT(*) to count only non-null user IDs. 2) When referencing the last access date column: use the exact column name \"LastAccessDate\" instead of \"last_access_date\". 3) When comparing date values: apply the date() function to \"LastAccessDate\" instead of comparing the raw timestamp value directly. 4) When specifying date literals: use ISO date format '2014-09-01' instead of '2014/9/1' for proper date comparison semantics."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM users WHERE last_access_date > '2014/9/1';",
            "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01';"
        ],
        "rule_sql": [
            "SELECT COUNT(Id) FROM users WHERE date(LastAccessDate) > '2014-09-01';"
        ],
        "amend_res": 1
    },
    "218": {
        "db_id": "toxicology",
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "ground_truth": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "amends": [
            "Do use `CAST` to convert the count to `REAL` instead of implicit conversion. Do count `DISTINCT` molecule IDs instead of simple counts. Do filter with `WHERE T2.label = '+'` instead of filtering by molecule type in CASE expressions. Do join `atom AS T1` with `molecule AS T2` on `T1.molecule_id = T2.molecule_id` instead of querying a single table. Do check for `T1.element <> 'f'` in the CASE condition instead of `fluorine_atoms = 0`. Do calculate the percentage using distinct molecule counts from the joined tables instead of counts from a single table without proper filtering. The amended query now correctly calculates the percentage of molecules without fluorine atoms among labeled molecules by properly joining the atom and molecule tables and using distinct counts with appropriate filtering."
        ],
        "rules": [
            "1) When joining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id and keep only matching pairs (inner match). 2) When filtering for labeled molecules: include only rows where T2.label = '+'. 3) When counting molecules without fluorine atoms: count distinct T2.molecule_id where T1.element <> 'f'. 4) When counting total labeled molecules: count distinct T2.molecule_id. 5) When calculating percentages: convert counts to REAL using CAST to ensure proper division. 6) When the question asks for percentage of carcinogenic-type molecules without fluorine: compute (distinct molecules without fluorine) divided by (distinct total labeled molecules) and multiply by 100.0."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (COUNT(CASE WHEN molecule_type = 'carcinogenic' AND fluorine_atoms = 0 THEN 1 END) * 100.0 / \n     COUNT(CASE WHEN molecule_type = 'carcinogenic' THEN 1 END)) AS percentage\nFROM molecules;",
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id END) AS REAL) / \n     CAST(COUNT(DISTINCT T2.molecule_id) AS REAL)) * 100.0 AS percentage\nFROM \n    atom AS T1\nJOIN \n    molecule AS T2 ON T1.molecule_id = T2.molecule_id\nWHERE \n    T2.label = '+'"
        ],
        "rule_sql": [
            "SELECT \n    (CAST(COUNT(DISTINCT CASE WHEN a.element <> 'f' THEN m.molecule_id END) AS REAL) / \n     CAST(COUNT(DISTINCT m.molecule_id) AS REAL)) * 100.0 AS percentage\nFROM \n    molecule m\nINNER JOIN \n    atom a ON m.molecule_id = a.molecule_id\nWHERE \n    m.label = '+';"
        ],
        "amend_res": 1
    },
    "100": {
        "db_id": "financial",
        "question": "Among the account opened, how many female customers who were born before 1950 and stayed in Sokolov?",
        "ground_truth": "SELECT COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T2.gender = 'F' AND STRFTIME('%Y', T2.birth_date) < '1950' AND T1.A2 = 'Sokolov'",
        "amends": [
            "Do select `COUNT(T2.client_id)` instead of `COUNT(*)` to count specific non-null values. Do use tables `district AS T1` and `client AS T2` instead of just `customers` to properly structure the data model. Do perform an `INNER JOIN` on `T1.district_id = T2.district_id` instead of querying a single table to establish the correct relationship. Do filter on `T2.gender = 'F'` instead of `gender = 'female'` to match the actual data format. Do use `STRFTIME('%Y', T2.birth_date) < '1950'` instead of `birth_year < 1950` to extract year from a date field rather than using a separate year column. Do filter on `T1.A2 = 'Sokolov'` instead of `city = 'Sokolov'` to reference the district table's city name field. The amended query now correctly counts female clients born before 1950 in the Sokolov district using proper table relationships and data formats."
        ],
        "rules": [
            "1) When counting customers: use COUNT(T2.client_id) instead of COUNT(*) to count specific non-null values. 2) When structuring the data model: use tables district AS T1 and client AS T2 instead of a single customers table. 3) When combining district and client tables: link rows where T1.district_id = T2.district_id using an inner match. 4) When filtering for female customers: use T2.gender = 'F' instead of 'female' to match the actual data format. 5) When filtering for birth year before 1950: use STRFTIME('%Y', T2.birth_date) < '1950' to extract year from a date field rather than using a separate year column. 6) When filtering for customers in Sokolov: use T1.A2 = 'Sokolov' instead of city = 'Sokolov' to reference the district table's city name field."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) \nFROM customers \nWHERE gender = 'female' \nAND birth_year < 1950 \nAND city = 'Sokolov';",
            "SELECT COUNT(T2.client_id) \nFROM district AS T1 \nINNER JOIN client AS T2 ON T1.district_id = T2.district_id \nWHERE T2.gender = 'F' \nAND STRFTIME('%Y', T2.birth_date) < '1950' \nAND T1.A2 = 'Sokolov'"
        ],
        "rule_sql": [
            "SELECT COUNT(T2.client_id) \nFROM district AS T1 \nINNER JOIN client AS T2 ON T1.district_id = T2.district_id \nWHERE T2.gender = 'F' \nAND STRFTIME('%Y', T2.birth_date) < '1950' \nAND T1.A2 = 'Sokolov'"
        ],
        "amend_res": 1
    },
    "289": {
        "db_id": "toxicology",
        "question": "Is molecule TR151 carcinogenic?",
        "ground_truth": "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'",
        "amends": [
            "Do select `T.label` instead of `carcinogenic` and do reference table `molecule AS T` instead of `molecules`. Do filter on `T.molecule_id = 'TR151'` instead of `name = 'TR151'`. The amended query now correctly retrieves the label from the molecule table using the appropriate identifier column."
        ],
        "rules": [
            "1) When answering about whether a molecule is carcinogenic: make sure the output order: T.label 2) When the question mentions \"molecule TR151\": \"TR151\" actually means \"T.molecule_id = 'TR151'\" in schema 3) When referring to the molecule table: use table alias \"T\" for molecule table instead of \"molecules\""
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT carcinogenic FROM molecules WHERE name = 'TR151';",
            "SELECT T.label FROM molecule AS T WHERE T.molecule_id = 'TR151'"
        ],
        "rule_sql": [
            "SELECT T.label FROM molecule T WHERE T.molecule_id = 'TR151'"
        ],
        "amend_res": 1
    },
    "22": {
        "db_id": "california_schools",
        "question": "Which school in Contra Costa has the highest number of test takers?",
        "evidence": "",
        "ground_truth": "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1",
        "amends": [
            "Do select `sname` instead of `school_name, MAX(test_takers)` and remove the aggregate function. Do use table `satscores` instead of `schools` and column `cname` instead of `county`. Do add filter `sname IS NOT NULL` instead of omitting it. Do order by `NumTstTakr DESC` instead of `test_takers DESC` and remove the `GROUP BY` clause. The amended query now correctly retrieves the school name with the highest number of test takers in Contra Costa county while ensuring non-null school names."
        ],
        "rules": [
            "1) When answering about \"school in Contra Costa with highest number of test takers\": make sure the output order: sname only. 2) When the question mentions \"school\": \"school\" actually means \"sname in satscores table\". 3) When the question mentions \"Contra Costa\": \"Contra Costa\" actually means \"cname = 'Contra Costa' in satscores table\". 4) When the question mentions \"highest number of test takers\": \"test takers\" actually means \"NumTstTakr in satscores table\" and rank rows by NumTstTakr in descending direction and keep the first 1 row. 5) When selecting school names: ensure sname IS NOT NULL to exclude null values. 6) When handling the satscores table: do not use aggregate functions like MAX when selecting individual school records."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT school_name, MAX(test_takers) FROM schools WHERE county = 'Contra Costa' GROUP BY school_name ORDER BY test_takers DESC LIMIT 1;",
            "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT sname FROM satscores WHERE cname = 'Contra Costa' AND sname IS NOT NULL ORDER BY NumTstTakr DESC LIMIT 1"
        ],
        "amend_res": 1
    },
    "937": {
        "db_id": "formula_1",
        "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
        "ground_truth": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
        "amends": [
            "Do select `T1.time` from the `results` table instead of `finish_time` from `races`. Do join `results AS T1` with `races AS T2` on `T1.raceId = T2.raceId` instead of querying only the `races` table. Do filter for `T1.rank = 2` instead of ordering by `position` with `LIMIT 1 OFFSET 1`. Do filter for `T2.name = 'Chinese Grand Prix'` instead of `race_name = 'Australian Grand Prix'`. Do keep the `T2.year = 2008` filter instead of the original year condition. Do remove the `ORDER BY` and `LIMIT/OFFSET` clauses instead of keeping them. The amended query now correctly retrieves the second-place finish time from the specified race by joining results with races and filtering by rank instead of using positional offset."
        ],
        "rules": [
            "1) When answering about finish time for a driver: use T1.time from the results table instead of finish_time from races table. 2) When combining results and races tables: join T1 (results) with T2 (races) on T1.raceId = T2.raceId using inner match. 3) When filtering for a specific rank position: use T1.rank = 2 instead of ordering and offsetting. 4) When filtering for a specific race name: use T2.name = 'Chinese Grand Prix' instead of 'Australian Grand Prix'. 5) When filtering for a specific year: use T2.year = 2008. 6) When the question asks for second ranked driver: do not use ORDER BY and LIMIT/OFFSET clauses, filter directly by rank value instead."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT finish_time FROM races WHERE year = 2008 AND race_name = 'Australian Grand Prix' ORDER BY position LIMIT 1 OFFSET 1;",
            "SELECT T1.time \nFROM results AS T1 \nJOIN races AS T2 ON T1.raceId = T2.raceId \nWHERE T1.rank = 2 \nAND T2.name = 'Chinese Grand Prix' \nAND T2.year = 2008"
        ],
        "rule_sql": [
            "SELECT T1.time \nFROM results T1 \nINNER JOIN races T2 ON T1.raceId = T2.raceId \nWHERE T2.year = 2008 \nAND T2.name = 'Chinese Grand Prix' \nAND T1.rank = 2"
        ],
        "amend_res": 1
    },
    "1380": {
        "db_id": "student_club",
        "question": "What is the total amount of money spent for food?",
        "ground_truth": "SELECT SUM(spent) FROM budget WHERE category = 'Food'",
        "amends": [
            "Do reference table `budget` instead of `purchases` in the FROM clause. Do use column `spent` for aggregation instead of `price` in the SELECT list. Do filter for category `'Food'` instead of `'electronics'` in the WHERE clause. The amended query now correctly calculates the total spending from the budget table for food-related expenses."
        ],
        "rules": [
            "1) When answering about \"total amount of money spent for food\": make sure the output order: SUM(\"spent\"). 2) When the question mentions \"food\": \"food\" actually means \"category = 'Food'\" in schema. 3) When computing total spending: use the column \"spent\" from table \"budget\" for aggregation. 4) When filtering for food expenses: use the exact literal 'Food' (case-sensitive) for the category condition."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT SUM(price) FROM purchases WHERE category = 'electronics';",
            "SELECT SUM(spent) AS total_spent FROM budget WHERE category = 'Food';"
        ],
        "rule_sql": [
            "SELECT SUM(spent) FROM budget WHERE category = 'Food';"
        ],
        "amend_res": 1
    },
    "848": {
        "db_id": "formula_1",
        "question": "Please list the year during which the race is held on circuits in Shanghai.",
        "ground_truth": "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.location = 'Shanghai'",
        "amends": [
            "Do select `T2.year` with table alias instead of just `year` without qualification. Do join `circuits AS T1` with `races AS T2` using `INNER JOIN` on `T2.circuitID = T1.circuitId` instead of querying only the `races` table without any join. Do filter on `T1.location = 'Shanghai'` instead of filtering on `circuit_name = 'Shanghai'` since the location attribute is in the circuits table rather than the races table. The amended query now correctly joins the circuits and races tables to find years where races occurred at the Shanghai circuit location, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about races held on circuits in Shanghai: join tables circuits AS T1 and races AS T2 using T2.circuitID = T1.circuitId to link race information with circuit details. 2) When filtering for Shanghai circuits: use T1.location = 'Shanghai' instead of circuit_name since the location attribute is in the circuits table. 3) When selecting the year information: use T2.year with table alias qualification instead of unqualified year to specify the source table. 4) When combining circuits and races tables: perform an inner join to keep only matching pairs where circuit IDs are equal between both tables."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT year FROM races WHERE circuit_name = 'Shanghai';",
            "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.location = 'Shanghai'"
        ],
        "rule_sql": [
            "SELECT T2.year FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T1.location = 'Shanghai'"
        ],
        "amend_res": 1
    },
    "976": {
        "db_id": "formula_1",
        "question": "List the driver's ID of the top five driver, by descending order, the fastest time during the first lap of the race.",
        "ground_truth": "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time LIMIT 5",
        "amends": [
            "Do reference column `driverId` instead of `driver_id` and table `lapTimes` instead of `lap_times`. Do filter on `lap = 1` instead of `lap_number = 1`. Do remove the explicit `ASC` direction from the `ORDER BY time` clause instead of keeping it, as ascending order is the default. The amended query now correctly matches the intended behavior with proper column and table references."
        ],
        "rules": [
            "1) When the question mentions \"driver's ID\": use the exact column token \"driverId\" from the schema. 2) When the question mentions \"first lap\": filter rows where the exact column \"lap\" equals the literal value 1. 3) When the question asks for \"top five driver by fastest time\": rank rows by the \"time\" column in ascending order (fastest to slowest) and keep the first 5 rows. 4) When choosing table and column identifiers: use \"lapTimes\" for the table name and \"driverId\" for the column name exactly as specified in the schema, without changing case or adding underscores."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT driver_id FROM lap_times WHERE lap_number = 1 ORDER BY time ASC LIMIT 5;",
            "SELECT driverId \nFROM lapTimes \nWHERE lap = 1 \nORDER BY time \nLIMIT 5"
        ],
        "rule_sql": [
            "SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time ASC LIMIT 5"
        ],
        "amend_res": 1
    },
    "272": {
        "db_id": "toxicology",
        "question": "List down two molecule id of triple bond non carcinogenic molecules with element carbon.",
        "ground_truth": "SELECT DISTINCT T2.molecule_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '#' AND T1.element = 'c' AND T2.label = '-'",
        "amends": [
            "Do query from `atom AS T1`, `molecule AS T2`, and `bond AS T3` tables instead of only `molecules` table. Do use `INNER JOIN` relationships between `T1.molecule_id = T2.molecule_id` and `T2.molecule_id = T3.molecule_id` instead of no joins. Do filter on `T3.bond_type = '#'` instead of `bond_type = 'triple'`. Do filter on `T1.element = 'c'` instead of `element = 'carbon'`. Do add filter `T2.label = '-'` instead of omitting it. Do remove `carcinogenic = 'yes'` filter instead of keeping it. Do add `DISTINCT` modifier instead of omitting it. Do remove `LIMIT 2` instead of keeping it. The amended query now correctly joins the necessary tables and applies the proper filters to match the intended logic."
        ],
        "rules": [
            "1) When answering about \"molecule id of triple bond non carcinogenic molecules with element carbon\": make sure the output order: T2.molecule_id\n2) When the question mentions \"triple bond\": \"triple bond\" actually means \"T3.bond_type = '#'\" in schema\n3) When the question mentions \"element carbon\": \"element carbon\" actually means \"T1.element = 'c'\" in schema\n4) When the question mentions \"non carcinogenic\": \"non carcinogenic\" actually means \"T2.label = '-'\" in schema\n5) When combining T1, T2, and T3 for shared entities: link rows where T1.molecule_id = T2.molecule_id and T2.molecule_id = T3.molecule_id; keep only matching pairs (inner match)\n6) When the question asks for \"molecule id\": compute the distinct values of T2.molecule_id instead of all values\n7) When the question asks for \"two molecule id\": remove any limit clause instead of keeping it"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT molecule_id FROM molecules WHERE bond_type = 'triple' AND carcinogenic = 'yes' AND element = 'carbon' LIMIT 2;",
            "SELECT DISTINCT T2.molecule_id\nFROM atom AS T1\nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id\nINNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id\nWHERE T3.bond_type = '#'\nAND T1.element = 'c'\nAND T2.label = '-'"
        ],
        "rule_sql": [
            "SELECT DISTINCT T2.molecule_id\nFROM atom T1\nJOIN molecule T2 ON T1.molecule_id = T2.molecule_id\nJOIN bond T3 ON T2.molecule_id = T3.molecule_id\nWHERE T1.element = 'c'\nAND T2.label = '-'\nAND T3.bond_type = '#'"
        ],
        "amend_res": 1
    },
    "1064": {
        "db_id": "european_football_2",
        "question": "List out of players whose preferred foot is left.",
        "ground_truth": "SELECT DISTINCT t1.id, t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.preferred_foot = 'left'",
        "amends": [
            "Do select specific columns `t1.id, t1.player_name` with `DISTINCT` instead of selecting all columns with `*`. Do join `Player AS t1` with `Player_Attributes AS t2` using `INNER JOIN` on `t1.player_api_id = t2.player_api_id` instead of querying only the `players` table. Do filter on `t2.preferred_foot = 'left'` instead of filtering on `preferred_foot = 'right'`. The amended query now correctly retrieves distinct player information by joining the necessary tables and filtering on the appropriate preferred foot attribute."
        ],
        "rules": [
            "1) When answering about \"players whose preferred foot is left\": select specific columns \"t1.id\" and \"t1.player_name\" with distinct values instead of all columns. 2) When combining Player and Player_Attributes tables: link rows where \"t1.player_api_id = t2.player_api_id\" using inner join instead of querying only the players table. 3) When filtering on preferred foot: use condition \"t2.preferred_foot = 'left'\" instead of 'right' to match the question requirement."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM players WHERE preferred_foot = 'right';",
            "SELECT DISTINCT t1.id, t1.player_name\nFROM Player AS t1\nINNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left'"
        ],
        "rule_sql": [
            "SELECT DISTINCT t1.id, t1.player_name\nFROM Player t1\nINNER JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id\nWHERE t2.preferred_foot = 'left'"
        ],
        "amend_res": 1
    },
    "1375": {
        "db_id": "student_club",
        "question": "List all the members of the \"School of Applied Sciences, Technology and Education\" department.",
        "ground_truth": "SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'",
        "amends": [
            "Do select specific columns `T1.first_name, T1.last_name` instead of using `SELECT *`. Do join table `major AS T2` instead of querying only the `members` table. Do use `INNER JOIN` with predicate `T1.link_to_major = T2.major_id` instead of no join condition. Do filter on `T2.department` instead of filtering on a non-existent `department` column in the members table. The amended query now correctly retrieves members associated with the specified department through their major linkage."
        ],
        "rules": [
            "1) When the question asks for members of a specific department: join table \"members\" as T1 with table \"major\" as T2 using the exact join condition T1.link_to_major = T2.major_id to connect members to their departments. 2) When filtering for department \"School of Applied Sciences, Technology and Education\": apply the filter condition to T2.department column with the exact literal value 'School of Applied Sciences, Technology and Education'. 3) When selecting output columns for members: return T1.first_name and T1.last_name instead of using SELECT * to get only the member names. 4) When combining tables for department queries: perform an inner join to keep only members who have a matching major record with the specified department."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM members WHERE department = 'School of Applied Sciences, Technology and Education';",
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'School of Applied Sciences, Technology and Education'"
        ],
        "rule_sql": [
            "SELECT T1.first_name, T1.last_name\nFROM member AS T1\nINNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\nWHERE T2.department = 'School of Applied Sciences, Technology and Education'"
        ],
        "amend_res": 1
    },
    "1511": {
        "db_id": "debit_card_specializing",
        "question": "For the customers who paid in the euro, what is their average total price of the transactions?",
        "evidence": "",
        "ground_truth": "SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'",
        "amends": [
            "Do use `AVG(T1.Price)` instead of `AVG(total_price)` for the aggregate calculation. Do add joins to `gasstations AS T2` and `customers AS T3` instead of querying only the `transactions` table. Do use `INNER JOIN` on `T1.GasStationID = T2.GasStationID` and `INNER JOIN` on `T1.CustomerID = T3.CustomerID` instead of no joins. Do move the currency filter to `T3.Currency = 'EUR'` instead of `currency = 'euro'` and change the currency code format. Do reference the joined table aliases `T1`, `T2`, and `T3` instead of direct table names. The amended query now correctly calculates average prices from joined tables with proper currency filtering."
        ],
        "rules": [
            "1) When answering about average total price for customers who paid in euro: use AVG(T1.Price) instead of AVG(total_price) for the aggregate calculation. 2) When combining tables for this question: link transactions as T1 with gasstations as T2 using T1.GasStationID = T2.GasStationID and with customers as T3 using T1.CustomerID = T3.CustomerID, keeping only matching pairs (inner match). 3) When filtering for currency: use T3.Currency = 'EUR' instead of currency = 'euro' and match the exact currency code format 'EUR'. 4) When referencing tables: use the aliases T1 for transactions, T2 for gasstations, and T3 for customers as established in the joins."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(total_price) FROM transactions WHERE currency = 'euro';",
            "SELECT AVG(T1.Price) AS average_price\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Currency = 'EUR'"
        ],
        "rule_sql": [
            "SELECT AVG(T1.Price) AS average_total_price\nFROM transactions_1k AS T1\nINNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID\nINNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID\nWHERE T3.Currency = 'EUR'"
        ],
        "amend_res": 1
    },
    "665": {
        "db_id": "codebase_community",
        "question": "What is the average monthly number of links created in 2010 for posts that have no more than 2 answers?",
        "ground_truth": "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.AnswerCount <= 2 AND STRFTIME('%Y', T1.CreationDate) = '2010'",
        "amends": [
            "Do calculate the average monthly count by dividing the total count by 12 using `CAST(COUNT(T1.Id) AS REAL) / 12` instead of using a subquery with `AVG(monthly_count)`. Do reference the `postLinks` table as `T1` instead of `links l` and `posts` as `T2` instead of `posts p`. Do use `INNER JOIN` with `T1.PostId = T2.Id` instead of `JOIN` with `l.post_id = p.id`. Do move the `strftime('%Y', T1.CreationDate) = '2010'` filter to the main query's `WHERE` clause instead of keeping it in the subquery. Do remove the `GROUP BY strftime('%m', l.creation_date)` clause instead of grouping by month. Do use `T2.AnswerCount <= 2` instead of `p.answer_count <= 2` for the answer count filter. The amended query now correctly calculates the average monthly count by dividing the total annual count by 12, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When calculating average monthly count for a year: compute total annual count divided by 12 using CAST(COUNT(T1.Id) AS REAL) / 12 instead of averaging monthly counts. 2) When referencing the postLinks table: use alias T1 instead of links l. 3) When referencing the posts table: use alias T2 instead of posts p. 4) When joining T1 and T2: use INNER JOIN with T1.PostId = T2.Id instead of l.post_id = p.id. 5) When filtering by year 2010: use strftime('%Y', T1.CreationDate) = '2010' in the main WHERE clause. 6) When filtering posts by answer count: use T2.AnswerCount <= 2 instead of p.answer_count <= 2. 7) When counting links: use T1.Id as the counting key instead of generic COUNT(*). 8) When grouping is not required for monthly average calculation: remove GROUP BY strftime('%m', l.creation_date) clause."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT AVG(monthly_count) \nFROM (\n    SELECT COUNT(*) as monthly_count\n    FROM links l\n    JOIN posts p ON l.post_id = p.id\n    WHERE strftime('%Y', l.creation_date) = '2010'\n    AND p.answer_count <= 2\n    GROUP BY strftime('%m', l.creation_date)\n)",
            "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 AS average_monthly_links\nFROM postLinks T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE strftime('%Y', T1.CreationDate) = '2010'\nAND T2.AnswerCount <= 2"
        ],
        "rule_sql": [
            "SELECT CAST(COUNT(T1.Id) AS REAL) / 12 AS average_monthly_links\nFROM postLinks T1\nINNER JOIN posts T2 ON T1.PostId = T2.Id\nWHERE strftime('%Y', T1.CreationDate) = '2010'\nAND T2.AnswerCount <= 2"
        ],
        "amend_res": 1
    },
    "553": {
        "db_id": "codebase_community",
        "question": "Among the badges obtained by csgillespie, how many of them were obtained in the year 2011?",
        "ground_truth": "SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE STRFTIME('%Y', T1.Date) = '2011' AND T2.DisplayName = 'csgillespie'",
        "amends": [
            "Do add `INNER JOIN users AS T2 ON T1.UserId = T2.Id` instead of querying only the badges table. Do change the user identification from `user_id = 'csgillespie'` to `T2.DisplayName = 'csgillespie'` to properly reference the user's display name. Do modify the date filtering from `YEAR(date) = 2011` to `STRFTIME('%Y', T1.Date) = '2011'` to use SQLite-compatible date formatting. Do change the count expression from `COUNT(*)` to `COUNT(T1.Id)` to count specific badge IDs. The amended query now correctly joins tables and uses proper identifiers to match the right SQL's behavior."
        ],
        "rules": [
            "1) When answering about badges obtained by a specific user: join the badges table (T1) with the users table (T2) where T1.UserId equals T2.Id to properly link user information. 2) When the question mentions a username like \"csgillespie\": use T2.DisplayName = 'csgillespie' exactly to identify the user by their display name. 3) When filtering for a specific year like 2011: use STRFTIME('%Y', T1.Date) = '2011' to extract and compare the year portion of dates in SQLite-compatible format. 4) When counting badges: use COUNT(T1.Id) to count specific badge IDs rather than counting all rows."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM badges WHERE user_id = 'csgillespie' AND YEAR(date) = 2011;",
            "SELECT COUNT(T1.Id) \nFROM badges AS T1 \nINNER JOIN users AS T2 ON T1.UserId = T2.Id \nWHERE T2.DisplayName = 'csgillespie' \nAND STRFTIME('%Y', T1.Date) = '2011'"
        ],
        "rule_sql": [
            "SELECT COUNT(badges.Id) \nFROM badges \nJOIN users ON badges.UserId = users.Id \nWHERE users.DisplayName = 'csgillespie' \nAND STRFTIME('%Y', badges.Date) = '2011'"
        ],
        "amend_res": 1
    },
    "1363": {
        "db_id": "student_club",
        "question": "List all of the College of Humanities and Social Sciences' departments.",
        "evidence": "",
        "ground_truth": "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'",
        "amends": [
            "Do select `department` instead of `*` from the `major` table instead of the `departments` table while keeping the same `WHERE` filter on `college = 'College of Humanities and Social Sciences'`. The amended query now correctly retrieves department names from the major table rather than all columns from the departments table, matching the intended behavior."
        ],
        "rules": [
            "1) When answering about \"College of Humanities and Social Sciences' departments\": make sure the output order: department\n2) When the question mentions \"departments\": \"departments\" actually means \"department in major table\"\n3) When selecting from the major table: use the exact literal 'College of Humanities and Social Sciences' for the college filter\n4) When producing output: only return the department column, not all columns (*)"
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT * FROM departments WHERE college = 'College of Humanities and Social Sciences';",
            "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences';"
        ],
        "rule_sql": [
            "SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences' ORDER BY department;"
        ],
        "amend_res": 1
    },
    "109": {
        "db_id": "financial",
        "question": "How many clients opened their accounts in Jesenik branch were women?",
        "ground_truth": "SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'",
        "amends": [
            "Do join `district` table via `INNER JOIN` on `district_id` instead of querying only the `clients` table. Do reference `T1.client_id` in the count instead of using `COUNT(*)`. Do filter on `T2.A2 = 'Jesenik'` instead of `branch = 'Jesenik'` to use the correct district name column. Do use `T1.gender = 'F'` instead of `gender = 'female'` for the gender filter syntax. The amended query now correctly counts female clients from the Jesenik district by properly joining the district table and using the appropriate column references.",
            "Do remove the unnecessary `account` table join and reference instead of including it in the FROM clause. Do reference `district` as `T2` instead of `T3` to match the table alias change. Do place both filters in the WHERE clause instead of keeping them there, maintaining the same logical conditions `T1.gender = 'F'` and `T2.A2 = 'Jesenik'`. The amended query now correctly counts female clients from the Jesenik district without the extraneous account table join, matching the RIGHT_SQL's behavior."
        ],
        "rules": [
            "1) When answering about clients from a specific branch: join the district table (T2) with clients table (T1) using INNER JOIN where T1.district_id = T2.district_id to get branch information. 2) When counting clients: use T1.client_id as the counting key instead of counting all rows. 3) When filtering by branch name \"Jesenik\": use T2.A2 = 'Jesenik' instead of the branch column in clients table. 4) When filtering for female clients: use T1.gender = 'F' instead of 'female' for the gender value.",
            "1) When the question asks about clients opening accounts in a specific branch: use the district table to filter by branch name instead of joining with the account table. 2) When the question mentions \"Jesenik branch\": the exact literal value is 'Jesenik' and it corresponds to column T2.A2 in the district table. 3) When the question asks about gender being women: the exact literal value is 'F' and it corresponds to column T1.gender in the client table. 4) When counting clients: use T1.client_id as the counting key to get the number of clients. 5) When combining client and district tables: link rows where T1.district_id = T2.district_id and keep only matching pairs (inner match)."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM clients WHERE branch = 'Jesenik' AND gender = 'female';",
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN account T2 ON T1.district_id = T2.district_id\nINNER JOIN district T3 ON T1.district_id = T3.district_id\nWHERE T3.A2 = 'Jesenik' AND T1.gender = 'F'",
            "SELECT COUNT(T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T1.client_id) \nFROM client T1\nINNER JOIN district T2 ON T1.district_id = T2.district_id\nWHERE T2.A2 = 'Jesenik' AND T1.gender = 'F'"
        ],
        "amend_res": 1
    },
    "1526": {
        "db_id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "ground_truth": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "amends": [
            "Do use `CAST(... AS FLOAT)` for division instead of implicit integer division. Do use `IIF()` conditional logic instead of `CASE WHEN` expressions. Do extract year with `SUBSTR(Date, 1, 4)` instead of `strftime('%Y', paymentDate)`. Do reference `Consumption` column instead of `amount`. Do query from `yearmonth` table instead of `payments`. Do filter by `CustomerID = (...)` instead of `customerNumber IN (...)`. Do use a single-row subquery with `=` instead of `IN` with a multi-row subquery. Do reference `Date` column instead of `paymentDate`. Do use a different subquery structure joining `transactions_1k` with `gasstations` on `GasStationID` instead of a simple filter on `payments`. Do remove the outer `WHERE` clause filtering years since the calculation handles this internally instead of keeping it. The amended query now correctly calculates the consumption decrease rate between 2012 and 2013 for the specific customer.",
            "Do use a single aggregate expression with conditional sums `SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0))` instead of separate scalar subqueries for each year. Do calculate the decrease rate directly in the main query instead of using a nested derived table structure. Do use `INNER JOIN` with explicit alias `T1` and `T2` instead of implicit aliases in the subquery. Do use date format '2012-08-25' instead of '2012/8/25' in the filter condition. Do remove the `DISTINCT` modifier from the subquery since only one customer ID is expected. Do place the subquery directly in the `WHERE CustomerID =` clause instead of using multiple nested levels. Do handle division by zero implicitly through the aggregate structure instead of explicit `IIF(cons_2012 > 0, ...)` logic. The amended query now correctly calculates the consumption decrease rate for the specified customer matching the transaction criteria.",
            "Do cast the numerator difference as `FLOAT` instead of omitting explicit casting. Do remove the `* 100.0` multiplication factor instead of keeping it. Do remove the `DISTINCT` keyword from the subquery instead of including it. Do use table aliases `T1` and `T2` instead of `t` and `g`. Do remove the column alias `DecreaseRate` instead of keeping it. The amended query now correctly calculates the consumption decrease rate without percentage scaling and with proper type casting for division."
        ],
        "rules": [
            "1) When calculating a ratio involving division: use CAST(... AS FLOAT) to ensure floating-point division instead of integer division. 2) When implementing conditional logic: use IIF() expressions instead of CASE WHEN statements. 3) When extracting year from a date field: use SUBSTR(Date, 1, 4) to get the first 4 characters instead of strftime functions. 4) When referring to consumption amounts: use the Consumption column instead of amount. 5) When querying consumption data: use the yearmonth table instead of payments. 6) When filtering by customer: use CustomerID = (...) with a single-row subquery instead of customerNumber IN (...) with a multi-row subquery. 7) When referencing date fields: use the Date column instead of paymentDate. 8) When identifying a specific customer who made a payment: join transactions_1k with gasstations on GasStationID to find the correct CustomerID instead of simple filtering. 9) When calculating year-over-year changes: handle the year filtering internally within the calculation logic instead of using an outer WHERE clause for years.",
            "1) When the question asks about a customer who paid a specific amount on a specific date: use the exact date format '2012-08-25' instead of '2012/8/25' in filter conditions. 2) When calculating consumption for different years from the same table: use conditional aggregation with SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) instead of separate scalar subqueries. 3) When joining tables for customer identification: use INNER JOIN with explicit aliases T1 and T2 instead of implicit aliases. 4) When expecting only one customer ID result: remove the DISTINCT modifier from the subquery. 5) When calculating percentage decrease rates: handle division by zero implicitly through the aggregate structure rather than explicit IIF(cons_2012 > 0, ...) logic. 6) When filtering for a specific customer: place the subquery directly in the WHERE CustomerID = clause instead of using multiple nested levels.",
            "1) When calculating a ratio difference between two years: cast the numerator difference as FLOAT instead of omitting explicit casting to ensure proper division. 2) When computing a decrease rate: remove any multiplication factor like * 100.0 instead of keeping percentage scaling. 3) When retrieving a CustomerID from a subquery: remove the DISTINCT keyword instead of including it to avoid unnecessary deduplication. 4) When joining tables in a subquery: use table aliases T1 and T2 instead of t and g for consistency with the schema convention. 5) When presenting the final result: remove column aliases like DecreaseRate instead of keeping them for the output format."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT \n    (SUM(CASE WHEN strftime('%Y', paymentDate) = '2012' THEN amount ELSE 0 END) - \n     SUM(CASE WHEN strftime('%Y', paymentDate) = '2013' THEN amount ELSE 0 END)) / \n    SUM(CASE WHEN strftime('%Y', paymentDate) = '2012' THEN amount ELSE 0 END) * 100 AS decrease_rate\nFROM payments\nWHERE customerNumber IN (\n    SELECT customerNumber \n    FROM payments \n    WHERE amount = 634.8 AND paymentDate = '2012-08-25'\n)\nAND strftime('%Y', paymentDate) IN ('2012', '2013');",
            "SELECT \n    IIF(cons_2012 > 0, \n        (cons_2012 - cons_2013) / CAST(cons_2012 AS FLOAT) * 100, \n        0\n    ) AS decrease_rate\nFROM (\n    SELECT \n        (SELECT Consumption FROM yearmonth WHERE CustomerID = target_customer AND SUBSTR(Date, 1, 4) = '2012') AS cons_2012,\n        (SELECT Consumption FROM yearmonth WHERE CustomerID = target_customer AND SUBSTR(Date, 1, 4) = '2013') AS cons_2013\n    FROM (\n        SELECT DISTINCT t.CustomerID AS target_customer\n        FROM transactions_1k t\n        JOIN gasstations g ON t.GasStationID = g.GasStationID\n        WHERE t.Date = '2012/8/25' AND t.Price = 634.8\n    )\n)",
            "SELECT \n    (SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - \n     SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))) * 100.0 / \n    SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) AS DecreaseRate\nFROM yearmonth\nWHERE CustomerID = (\n    SELECT DISTINCT t.CustomerID\n    FROM transactions_1k t\n    INNER JOIN gasstations g ON t.GasStationID = g.GasStationID\n    WHERE t.Date = '2012-08-25' AND t.Price = 634.8\n)",
            "SELECT \n    (SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))) \n    / CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) AS FLOAT) AS DecreaseRate\nFROM yearmonth\nWHERE CustomerID = (\n    SELECT T1.CustomerID\n    FROM transactions_1k T1\n    INNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\n    WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8\n)"
        ],
        "rule_sql": [
            "SELECT \n    CAST((SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0))) AS FLOAT) / \n    SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0))\nFROM yearmonth\nWHERE CustomerID = (\n    SELECT T1.CustomerID\n    FROM transactions_1k T1\n    INNER JOIN gasstations T2 ON T1.GasStationID = T2.GasStationID\n    WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8\n)"
        ],
        "amend_res": 1
    },
    "235": {
        "db_id": "toxicology",
        "question": "How many molecules are carcinogenic and have the bromine element?",
        "ground_truth": "SELECT COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'br'",
        "amends": [
            "Do use `COUNT(DISTINCT T2.molecule_id)` instead of `COUNT(*)` to count unique molecules rather than all rows. Do join `atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id` instead of querying only the `molecules` table. Do filter with `T2.label = '+'` instead of `carcinogenic = 'yes'` and `T1.element = 'br'` instead of `element = 'bromine'`. The amended query now correctly counts distinct molecules containing bromine atoms with positive labels, matching the intended behavior."
        ],
        "rules": [
            "1) When counting molecules: use COUNT(DISTINCT T2.molecule_id) to count unique molecules rather than all rows. 2) When combining atom and molecule tables: link rows where T1.molecule_id = T2.molecule_id using an inner join to keep only matching pairs. 3) When filtering for carcinogenic molecules: use T2.label = '+' instead of carcinogenic = 'yes'. 4) When filtering for bromine element: use T1.element = 'br' instead of element = 'bromine'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT COUNT(*) FROM molecules WHERE carcinogenic = 'yes' AND element = 'bromine';",
            "SELECT COUNT(DISTINCT T2.molecule_id) \nFROM atom AS T1 \nINNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.label = '+' AND T1.element = 'br'"
        ],
        "rule_sql": [
            "SELECT COUNT(DISTINCT T2.molecule_id) \nFROM atom T1 \nINNER JOIN molecule T2 ON T1.molecule_id = T2.molecule_id \nWHERE T2.label = '+' AND T1.element = 'br'"
        ],
        "amend_res": 1
    },
    "587": {
        "db_id": "codebase_community",
        "question": "Calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post.",
        "ground_truth": "SELECT AVG(T2.ViewCount), T2.Title, T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T2.Id = T1.PostId  WHERE T2.Tags = '<humor>' GROUP BY T2.Title, T1.Text ",
        "amends": [
            "Do use `AVG(T2.ViewCount)` instead of `AVG(view_count) as avg_views` and select `T2.Title, T1.Text` instead of `title, comment`. Do join `comments AS T1 INNER JOIN posts AS T2` instead of querying only `FROM posts` and use `ON T2.Id = T1.PostId` instead of no join condition. Do filter with `T2.Tags = '<humor>'` instead of `tag = 'humor'` and group by `T2.Title, T1.Text` instead of `title, comment`. The amended query now correctly joins the comments and posts tables to calculate average view counts for humor-tagged posts with their associated comments."
        ],
        "rules": [
            "1) When answering about \"average view count of posts tagged as 'humor' with title and comment\": make sure the output order: T2.Title, T1.Text, AVG(T2.ViewCount) 2) When the question mentions \"post tagged as 'humor'\": \"humor\" actually means \"T2.Tags = '<humor>'\" in schema 3) When combining comments and posts tables: link rows where T2.Id = T1.PostId and keep only matching pairs (inner match) 4) When calculating average view count: use AVG(T2.ViewCount) instead of view_count 5) When grouping results: organize by T2.Title, T1.Text instead of title, comment"
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT title, comment, AVG(view_count) as avg_views \nFROM posts \nWHERE tag = 'humor' \nGROUP BY title, comment;",
            "SELECT AVG(T2.ViewCount) AS avg_views, T2.Title, T1.Text\nFROM comments AS T1\nINNER JOIN posts AS T2 ON T2.Id = T1.PostId\nWHERE T2.Tags = '<humor>'\nGROUP BY T2.Title, T1.Text"
        ],
        "rule_sql": [
            "SELECT T2.Title, T1.Text, AVG(T2.ViewCount) \nFROM comments T1 \nINNER JOIN posts T2 ON T2.Id = T1.PostId \nWHERE T2.Tags = '<humor>' \nGROUP BY T2.Title, T1.Text"
        ],
        "amend_res": 1
    },
    "912": {
        "db_id": "formula_1",
        "question": "What's the reference name of Marina Bay Street Circuit?",
        "ground_truth": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'",
        "amends": [
            "Do select `circuitRef` instead of `circuit_name` in the SELECT list. Do filter on `name = 'Marina Bay Street Circuit'` instead of `circuit_ref = 'Marina Bay Street Circuit'` in the WHERE clause. The amended query now correctly retrieves the circuit reference value by filtering on the circuit name column, matching the intended behavior."
        ],
        "rules": [
            "1) When the question asks for the reference name of a circuit: select the exact column \"circuitRef\" from the circuits table. 2) When filtering by circuit name to find its reference: use the exact literal 'Marina Bay Street Circuit' to match against the name column, not the circuitRef column. 3) When the question mentions \"Marina Bay Street Circuit\": this refers to the name value, not the circuitRef value, so filter using name = 'Marina Bay Street Circuit'."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT circuit_name FROM circuits WHERE circuit_ref = 'Marina Bay Street Circuit';",
            "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';"
        ],
        "rule_sql": [
            "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';"
        ],
        "amend_res": 1
    },
    "800": {
        "db_id": "superhero",
        "question": "Calculate the percentage of superheroes with blue eyes.",
        "ground_truth": "SELECT CAST(COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id",
        "amends": [
            "Do use `COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END)` instead of `COUNT(*)` with a simple `WHERE` filter to properly handle the conditional count within the join context. Do join `colour AS T2` on `T1.eye_colour_id = T2.id` instead of querying `superheroes` directly without the necessary join to access color information. Do reference `T2.colour` instead of the non-existent `eye_color` column to correctly access the color data from the joined table. Do calculate the percentage using `COUNT(T1.id)` as the denominator instead of a subquery `(SELECT COUNT(*) FROM superheroes)` to ensure proper counting within the joined dataset. Do cast the result to `REAL` instead of relying on integer division to get accurate percentage values with decimal precision. The amended query now correctly calculates the percentage of superheroes with blue eyes by properly joining the color reference table and handling the conditional count and division with appropriate data types."
        ],
        "rules": [
            "1) When calculating percentages of superheroes with specific eye colors: join the color reference table using T1.eye_colour_id = T2.id to access color information instead of querying superheroes directly. 2) When counting superheroes with blue eyes: use COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) instead of COUNT(*) with a simple WHERE filter to handle conditional counting within the join context. 3) When accessing eye color data: reference T2.colour instead of non-existent columns like eye_color to correctly access color data from the joined table. 4) When calculating percentage denominators: use COUNT(T1.id) as the denominator instead of subqueries to ensure proper counting within the joined dataset. 5) When computing percentage values: cast the result to REAL instead of relying on integer division to get accurate percentage values with decimal precision."
        ],
        "rule_res": 1,
        "amend_sql": [
            "SELECT (COUNT(*) * 100 / (SELECT COUNT(*) FROM superheroes)) AS percentage_blue_eyes FROM superheroes WHERE eye_color = 'Blue';",
            "SELECT \n    (COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) * 100.0 / COUNT(T1.id)) AS percentage_blue_eyes\nFROM \n    superhero T1\nJOIN \n    colour T2 ON T1.eye_colour_id = T2.id;"
        ],
        "rule_sql": [
            "SELECT \n    (COUNT(CASE WHEN T2.colour = 'Blue' THEN 1 ELSE NULL END) * 100.0 / COUNT(T1.id)) AS percentage_blue_eyes\nFROM \n    superhero T1\nJOIN \n    colour T2 ON T1.eye_colour_id = T2.id;"
        ],
        "amend_res": 1
    },
    "68": {
        "db_id": "california_schools",
        "question": "Which county reported the most number of school closure in the 1980s with school wonership code belonging to Youth Authority Facilities (CEA)?",
        "ground_truth": "SELECT County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND StatusType = 'Closed' AND SOC = 11 GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1",
        "amends": [
            "Do select `County` instead of `county, COUNT(*) as closure_count`. Do use table `schools` instead of `school_closures`. Do filter with `strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'` instead of `year BETWEEN 1980 AND 1989`. Do add `StatusType = 'Closed'` instead of omitting it. Do use `SOC = 11` instead of `ownership_code = 'Youth Authority Facilities (CEA)'`. Do group by `County` instead of `county`. Do order by `COUNT(School) DESC` instead of `closure_count ASC`. Do remove the alias `closure_count` instead of keeping it. The amended query now correctly identifies counties with the most school closures during 1980-1989 for SOC code 11 closed facilities."
        ],
        "rules": [
            "1) When answering about school closures: use table \"schools\" instead of \"school_closures\". 2) When filtering by county: use column \"County\" exactly as shown in the schema. 3) When filtering for 1980s closures: use strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' to extract year from ClosedDate. 4) When identifying closed schools: filter for StatusType = 'Closed'. 5) When filtering for Youth Authority Facilities: use SOC = 11 instead of the text literal. 6) When counting school closures: count using COUNT(School) as the canonical key. 7) When grouping results by county: group by \"County\". 8) When finding the county with most closures: order by COUNT(School) DESC and take the top result. 9) When selecting output columns: include \"County\" and the count without aliases."
        ],
        "rule_res": 0,
        "amend_sql": [
            "SELECT county, COUNT(*) as closure_count \nFROM school_closures \nWHERE year BETWEEN 1980 AND 1989 \nAND ownership_code = 'Youth Authority Facilities (CEA)' \nGROUP BY county \nORDER BY closure_count ASC \nLIMIT 1;",
            "SELECT County FROM schools WHERE StatusType = 'Closed' AND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND SOC = '11' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1;"
        ],
        "rule_sql": [
            "SELECT County, COUNT(School) \nFROM schools \nWHERE StatusType = 'Closed' \nAND strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' \nAND SOC = '11' \nGROUP BY County \nORDER BY COUNT(School) DESC \nLIMIT 1"
        ],
        "amend_res": 1
    }
}